1, makeCoffee, Main, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Main.java, 217, 244
3
/**
   * Make coffee user interface the processes input.
   */
28
  public static void makeCoffee() {
    Recipe [] recipes = coffeeMaker.getRecipes();
    for(int i = 0; i < recipes.length; i++) {
      if (recipes[i] != null) {
        System.out.println((i+1) + ". " + recipes[i].getName());
      }
    }
    
    int recipeToPurchase = recipeListSelection("Please select the number of the recipe to purchase.");
    
    String amountPaid = inputOutput("Please enter the amount you wish to pay");
    int amtPaid = 0;
    try {
      amtPaid @= Integer.parseInt(amountPaid);
    } catch (NumberFormatException e) {
      System.out.println("Please enter a positive integer");
      mainMenu();
    }
    
    int change = coffeeMaker.makeCoffee(recipeToPurchase, amtPaid);
    
    if (change == amtPaid) {
      System.out.println("Insufficient funds to purchase.");
    } else {
      System.out.println("Thank you for purchasing " + coffeeMaker.getRecipes()[recipeToPurchase].getName());
    }
    System.out.println("Your change is: " + change + "\n");
    mainMenu();
###
2, deleteRecipe, Main, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Main.java, 103, 123
3
/**
   * Delete recipe user interface that processes input.
   */
21
  public static void deleteRecipe() {
    Recipe [] recipes = coffeeMaker.getRecipes();
    for(int i = 0; i < recipes.length; i++) {
      if (recipes[i] != null) {
        System.out.println((i+1) + ". " + recipes[i].getName());
      }
    }
    int recipeToDelete = recipeListSelection("Please select the number of the recipe to delete.");
    
    if(recipeToDelete < 0) {
      mainMenu();
    }
    
    String recipeDeleted = coffeeMaker.deleteRecipe(recipeToDelete);
    
    if (recipeDeleted != null) {
      System.out.println(recipeDeleted + " successfully deleted.\n");
    } else {
      System.out.println("Selected recipe doesn't exist and could not be deleted.\n");
    }
    mainMenu();
###
3, mainMenu, Main, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Main.java, 23, 50
4
/**
   * Prints the main menu and handles user input for 
   * main menu commands.
   */
28
  public static void mainMenu() {
    System.out.println("1. Add a recipe");
    System.out.println("2. Delete a recipe");
    System.out.println("3. Edit a recipe");
    System.out.println("4. Add inventory");
    System.out.println("5. Check inventory");
    System.out.println("6. Make coffee");
    System.out.println("0. Exit\n");
    
    //Get user input
    try {
      int userInput = Integer.parseInt(inputOutput("Please press the number that corresponds to what you would like the coffee maker to do."));
      
      if (userInput >= 0 && userInput <=6) {
        if (userInput == 1) addRecipe();
        if (userInput == 2) deleteRecipe();
        if (userInput == 3) editRecipe();
        if (userInput == 4) addInventory();
        if (userInput == 5) checkInventory();
        if (userInput == 6) makeCoffee();
        if (userInput == 0) System.exit(0);
      } else {
        System.out.println("Please enter a number from 0 - 6");
        mainMenu();
      }
    } catch (NumberFormatException e) {
      System.out.println("Please enter a number from 0 - 6");
      mainMenu();
###
4, inputOutput, Main, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Main.java, 253, 264
6
/**
   * Passes a prompt to the user and returns the user specified 
   * string.
   * @param message
   * @return String
   */
12
  private static String inputOutput(String message) {
    System.out.println(message);
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String returnString = "";
    try {
      returnString = br.readLine();
    }
    catch (IOException e){
      System.out.println("Error reading in value");
      mainMenu();
    }
    return returnString;
###
5, addInventory, Main, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Main.java, 183, 202
3
/**
   * Add inventory user interface that processes input.
   */
20
  public static void addInventory() {
    //Read in amt coffee
    String coffeeString = inputOutput("\nPlease enter the units of coffee to add: ");
        
    //Read in amt milk
    String milkString = inputOutput("\nPlease enter the units of milk to add: ");
        
    //Read in amt sugar
    String sugarString = inputOutput("\nPlease enter the units of sugar to add: ");
        
    //Read in amt chocolate
    String chocolateString = inputOutput("\nPlease enter the units of chocolate to add: ");
        
    try {
      coffeeMaker.addInventory(coffeeString, milkString, sugarString, chocolateString);
      System.out.println("Inventory successfully added");
    } catch (InventoryException e) {
      System.out.println("Inventory was not added");
    } finally {
      mainMenu();
###
6, editRecipe, Main, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Main.java, 129, 176
3
/**
   * Edit recipe user interface the processes user input.
   */
48
  public static void editRecipe() {
    Recipe [] recipes = coffeeMaker.getRecipes();
    for(int i = 0; i < recipes.length; i++) {
      if (recipes[i] != null) {
        System.out.println((i+1) + ". " + recipes[i].getName());
      }
    }
    int recipeToEdit = recipeListSelection("Please select the number of the recipe to edit.");
    
    if(recipeToEdit < 0) {
      mainMenu();
    }
    
    //Read in recipe price
    String priceString = inputOutput("\nPlease enter the recipe price: $");
    
    //Read in amt coffee
    String coffeeString = inputOutput("\nPlease enter the units of coffee in the recipe: ");
    
    //Read in amt milk
    String milkString = inputOutput("\nPlease enter the units of milk in the recipe: ");
    
    //Read in amt sugar
    String sugarString = inputOutput("\nPlease enter the units of sugar in the recipe: ");
    
    //Read in amt chocolate
    String chocolateString = inputOutput("\nPlease enter the units of chocolate in the recipe: ");
    
    Recipe newRecipe = new Recipe();
    try {
      newRecipe.setPrice(priceString);
      newRecipe.setAmtCoffee(coffeeString);
      newRecipe.setAmtMilk(milkString);
      newRecipe.setAmtSugar(sugarString);
      newRecipe.setAmtChocolate(chocolateString);
      
      String recipeEdited = coffeeMaker.editRecipe(recipeToEdit, newRecipe);
      
      if (recipeEdited != null) {
        System.out.println(recipeEdited + " successfully edited.\n");
      }
      else {
        System.out.println(recipeEdited + "could not be edited.\n");
      }
    } catch (RecipeException e) {
      System.out.println(e.getMessage());
    } finally {
      mainMenu();
###
7, recipeListSelection, Main, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Main.java, 273, 287
6
/**
   * Passes a prompt to the user that deals with the recipe list
   * and returns the user selected number.
   * @param message
   * @return int
   */
15
  private static int recipeListSelection(String message) {
    String userSelection = inputOutput(message);
    int recipe = 0;
    try {
      recipe = Integer.parseInt(userSelection) - 1;
      if (recipe >= 0 && recipe <=2) {
        //do nothing here.
      } else {
        recipe = -1;
      }
    } catch (NumberFormatException e) {
      System.out.println("Please select a number from 1-3.");
      recipe = -1;
    }
    return recipe;
###
8, addRecipe, Main, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Main.java, 57, 96
3
/**
   * The add recipe user interface that process user input.
   */
40
  public static void addRecipe() {
    
    //Read in recipe name
    String name = inputOutput("\nPlease enter the recipe name: ");
    
    //Read in recipe price
    String priceString = inputOutput("\nPlease enter the recipe price: $");
        
    //Read in amt coffee
    String coffeeString = inputOutput("\nPlease enter the units of coffee in the recipe: ");
        
    //Read in amt milk
    String milkString = inputOutput("\nPlease enter the units of milk in the recipe: ");
        
    //Read in amt sugar
    String sugarString = inputOutput("\nPlease enter the units of sugar in the recipe: ");
        
    //Read in amt chocolate
    String chocolateString = inputOutput("\nPlease enter the units of chocolate in the recipe: ");
        
    Recipe r = new Recipe();
    try {
      r.setName(name);
      r.setPrice(priceString);
      r.setAmtCoffee(coffeeString);
      r.setAmtMilk(milkString);
      r.setAmtSugar(sugarString);
      r.setAmtChocolate(chocolateString);
      
      boolean recipeAdded = coffeeMaker.addRecipe(r);
      
      if(recipeAdded) {
        System.out.println(name + " successfully added.\n");
      } else {
        System.out.println(name + " could not be added.\n");
      }
    } catch (RecipeException e) {
      System.out.println(e.getMessage());
    } finally {
      mainMenu();
###
9, checkInventory, Main, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Main.java, 209, 211
3
/**
   * Check inventory user interface that processes input.
   */
3
  public static void checkInventory() {
    System.out.println(coffeeMaker.checkInventory());
    mainMenu();
###
10, getRecipes, RecipeBook, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/RecipeBook.java, 22, 23
5
/**
   * Returns the recipe array.
   * @param r
   * @return Recipe[]
   */
2
  public synchronized Recipe[] getRecipes() {
    return recipeArray;
###
11, deleteRecipe, RecipeBook, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/RecipeBook.java, 57, 63
6
/**
   * Returns the name of the recipe deleted at the position specified
   * and null if the recipe does not exist.
   * @param recipeToDelete
   * @return String
   */
7
  public synchronized String deleteRecipe(int recipeToDelete) {
    if (recipeArray[recipeToDelete] != null) {
      String recipeName = recipeArray[recipeToDelete].getName();
      recipeArray[recipeToDelete] = null;
      return recipeName;
    } else {
      return null;
###
12, RecipeBook, RecipeBook, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/RecipeBook.java, 13, 14
3
/**
   * Default constructor for a RecipeBook.
   */
2
  public RecipeBook() {
    recipeArray = new Recipe[NUM_RECIPES];
###
13, makeCoffee, CoffeeMaker, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/CoffeeMaker.java, 86, 101
7
/**
   * Returns the change of a user's beverage purchase, or
   * the user's money if the beverage cannot be made
   * @param r
   * @param amtPaid
   * @return int
   */
16
  public synchronized int makeCoffee(int recipeToPurchase, int amtPaid) {
    int change = 0;
    
    if (getRecipes()[recipeToPurchase] == null) {
      change = amtPaid;
    } else if (getRecipes()[recipeToPurchase].getPrice() <= amtPaid) {
      if (inventory.useIngredients(getRecipes()[recipeToPurchase])) {
        change = amtPaid - getRecipes()[recipeToPurchase].getPrice();
      } else {
        change = amtPaid;
      }
    } else {
      change = amtPaid;
    }
    
    return change;
###
14, addInventory, CoffeeMaker, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/CoffeeMaker.java, 64, 68
8
/**
   * Returns true if inventory was successfully added
   * @param amtCoffee
   * @param amtMilk
   * @param amtSugar
   * @param amtChocolate
   * @return boolean
   */
5
  public synchronized void addInventory(String amtCoffee, String amtMilk, String amtSugar, String amtChocolate) throws InventoryException {
    inventory.addCoffee(amtCoffee);
    inventory.addMilk(amtMilk);
    inventory.addSugar(amtSugar);
    inventory.addChocolate(amtChocolate);
###
15, checkInventory, CoffeeMaker, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/CoffeeMaker.java, 75, 76
4
/**
   * Returns the inventory of the coffee maker
   * @return Inventory
   */
2
  public synchronized String checkInventory() {
    return inventory.toString();
###
16, deleteRecipe, CoffeeMaker, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/CoffeeMaker.java, 41, 42
7
/**
   * Returns the name of the successfully deleted recipe
   * or null if the recipe cannot be deleted.
   * 
   * @param recipeToDelete
   * @return String
   */
2
  public String deleteRecipe(int recipeToDelete) {
    return recipeBook.deleteRecipe(recipeToDelete);
###
17, editRecipe, CoffeeMaker, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/CoffeeMaker.java, 52, 53
7
/**
   * Returns the name of the successfully edited recipe
   * or null if the recipe cannot be edited.
   * @param recipeToEdit
   * @param r
   * @return String
   */
2
  public String editRecipe(int recipeToEdit, Recipe r) {
    return recipeBook.editRecipe(recipeToEdit, r);
###
18, CoffeeMaker, CoffeeMaker, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/CoffeeMaker.java, 18, 20
4
/**
   * Constructor for the coffee maker
   *
   */
3
  public CoffeeMaker() {
    recipeBook = new RecipeBook();
    inventory = new Inventory();
###
19, addRecipe, CoffeeMaker, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/CoffeeMaker.java, 30, 31
7
/**
   * Returns true if the recipe is added to the
   * list of recipes in the CoffeeMaker and false
   * otherwise.
   * @param r
   * @return boolean
   */
2
  public boolean addRecipe(Recipe r) {
    return recipeBook.addRecipe(r);
###
20, setAmtChocolate, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 37, 47
3
/**
   * @param amtChocolate   The amtChocolate to set.
   */
11
  public void setAmtChocolate(String chocolate) throws RecipeException {
    int amtChocolate = 0;
    try {
      amtChocolate = Integer.parseInt(chocolate);
    } catch (NumberFormatException e) {
      throw new RecipeException("Units of chocolate must be a positive integer");
    }
    if (amtChocolate >= 0) {
      this.amtChocolate = amtChocolate;
    } else {
      throw new RecipeException("Units of chocolate must be a positive integer");
###
21, getPrice, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 133, 134
3
/**
   * @return   Returns the price.
   */
2
  public int getPrice() {
    return price;
###
22, setPrice, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 139, 149
3
/**
   * @param price   The price to set.
   */
11
  public void setPrice(String price) throws RecipeException{
    int amtPrice = 0;
    try {
      amtPrice = Integer.parseInt(price);
    } catch (NumberFormatException e) {
      throw new RecipeException("Price must be a positive integer");
    }
    if (amtPrice >= 0) {
      this.price = amtPrice;
    } else {
      throw new RecipeException("Price must be a positive integer");
###
23, getAmtCoffee, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 53, 54
3
/**
   * @return   Returns the amtCoffee.
   */
2
  public int getAmtCoffee() {
    return amtCoffee;
###
24, setAmtMilk, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 81, 91
3
/**
   * @param amtMilk   The amtMilk to set.
   */
11
  public void setAmtMilk(String milk) throws RecipeException{
    int amtMilk = 0;
    try {
      amtMilk = Integer.parseInt(milk);
    } catch (NumberFormatException e) {
      throw new RecipeException("Units of milk must be a positive integer");
    }
    if (amtMilk >= 0) {
      this.amtMilk = amtMilk;
    } else {
      throw new RecipeException("Units of milk must be a positive integer");
###
25, getAmtMilk, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 75, 76
3
/**
   * @return   Returns the amtMilk.
   */
2
  public int getAmtMilk() {
    return amtMilk;
###
26, setAmtCoffee, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 59, 69
3
/**
   * @param amtCoffee   The amtCoffee to set.
   */
11
  public void setAmtCoffee(String coffee) throws RecipeException {
    int amtCoffee = 0;
    try {
      amtCoffee = Integer.parseInt(coffee);
    } catch (NumberFormatException e) {
      throw new RecipeException("Units of coffee must be a positive integer");
    }
    if (amtCoffee >= 0) {
      this.amtCoffee = amtCoffee;
    } else {
      throw new RecipeException("Units of coffee must be a positive integer");
###
27, getAmtSugar, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 97, 98
3
/**
   * @return   Returns the amtSugar.
   */
2
  public int getAmtSugar() {
    return amtSugar;
###
28, getName, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 119, 120
3
/**
   * @return   Returns the name.
   */
2
  public String getName() {
    return name;
###
29, getAmtChocolate, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 31, 32
3
/**
   * @return   Returns the amtChocolate.
   */
2
  public int getAmtChocolate() {
    return amtChocolate;
###
30, setName, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 125, 127
3
/**
   * @param name   The name to set.
   */
3
  public void setName(String name) {
    if(name != null) {
      this.name = name;
###
31, Recipe, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 19, 25
3
/**
   * Creates a default recipe for the coffee maker.
   */
7
  public Recipe() {
    this.name = "";
    this.price = 0;
    this.amtCoffee = 0;
    this.amtMilk = 0;
    this.amtSugar = 0;
    this.amtChocolate = 0;
###
32, setAmtSugar, Recipe, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Recipe.java, 103, 113
3
/**
   * @param amtSugar   The amtSugar to set.
   */
11
  public void setAmtSugar(String sugar) throws RecipeException {
    int amtSugar = 0;
    try {
      amtSugar = Integer.parseInt(sugar);
    } catch (NumberFormatException e) {
      throw new RecipeException("Units of sugar must be a positive integer");
    }
    if (amtSugar >= 0) {
      this.amtSugar = amtSugar;
    } else {
      throw new RecipeException("Units of sugar must be a positive integer");
###
33, setMilk, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 123, 125
5
/**
   * Sets the number of milk units in the inventory
   * to the specified amount.
   * @param milk
   */
3
  public synchronized void setMilk(int milk) {
    if(milk >= 0) {
      Inventory.milk = milk;
###
34, getChocolate, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 33, 34
5
/**
   * Returns the current number of chocolate units in 
   * the inventory.
   * @return int
   */
2
  public int getChocolate() {
    return chocolate;
###
35, addSugar, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 175, 185
6
/**
   * Add the number of sugar units in the inventory 
   * to the current amount of sugar units.
   * @param sugar
   * @throws InventoryException
   */
11
  public synchronized void addSugar(String sugar) throws InventoryException {
    int amtSugar = 0;
    try {
      amtSugar = Integer.parseInt(sugar);
    } catch (NumberFormatException e) {
      throw new InventoryException("Units of sugar must be a positive integer");
    }
    if (amtSugar >= 0) { 
      Inventory.sugar += amtSugar;
    } else {
      throw new InventoryException("Units of sugar must be a positive integer");
###
36, setSugar, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 163, 165
5
/**
   * Sets the number of sugar units in the inventory
   * to the specified amount.
   * @param sugar
   */
3
  public synchronized void setSugar(int sugar) {
    if(sugar >= 0) {
      Inventory.sugar = sugar;
###
37, getSugar, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 154, 155
5
/**
   * Returns the current number of sugar units in 
   * the inventory.
   * @return int
   */
2
  public int getSugar() {
    return sugar;
###
38, useIngredients, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 218, 226
6
/**
   * Removes the ingredients used to make the specified 
   * recipe.  Assumes that the user has checked that there
   * are enough ingredients to make 
   * @param r
   */
9
  public synchronized boolean useIngredients(Recipe r) {
    if (enoughIngredients(r)) {
      Inventory.coffee -= r.getAmtCoffee();
      Inventory.milk -= r.getAmtMilk();
      Inventory.sugar -= r.getAmtSugar();
      Inventory.chocolate -= r.getAmtChocolate();
      return true;
    } else {
      return false;
###
39, setCoffee, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 83, 85
5
/**
   * Sets the number of coffee units in the inventory 
   * to the specified amount.
   * @param coffee
   */
3
  public synchronized void setCoffee(int coffee) {
    if(coffee >= 0) {
      Inventory.coffee = coffee;
###
40, addChocolate, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 55, 65
6
/**
   * Add the number of chocolate units in the inventory 
   * to the current amount of chocolate units.
   * @param chocolate
   * @throws InventoryException
   */
11
  public synchronized void addChocolate(String chocolate) throws InventoryException {
    int amtChocolate = 0;
    try {
      amtChocolate = Integer.parseInt(chocolate);
    } catch (NumberFormatException e) {
      throw new InventoryException("Units of chocolate must be a positive integer");
    }
    if (amtChocolate >= 0) {
      Inventory.chocolate += amtChocolate;
    } else {
      throw new InventoryException("Units of chocolate must be a positive integer");
###
41, setChocolate, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 42, 44
5
/**
   * Sets the number of chocolate units in the inventory
   * to the specified amount.
   * @param chocolate
   */
3
  public synchronized void setChocolate(int chocolate) {
    if(chocolate >= 0) {
      Inventory.chocolate = chocolate;
###
42, getCoffee, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 74, 75
5
/**
   * Returns the current number of coffee units in
   * the inventory.
   * @return int
   */
2
  public int getCoffee() {
    return coffee;
###
43, getMilk, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 114, 115
5
/**
   * Returns the current number of milk units in
   * the inventory.
   * @return int
   */
2
  public int getMilk() {
    return milk;
###
44, enoughIngredients, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 195, 209
6
/**
   * Returns true if there are enough ingredients to make
   * the beverage.
   * @param r
   * @return boolean
   */
15
  protected synchronized boolean enoughIngredients(Recipe r) {
    boolean isEnough = true;
    if(Inventory.coffee < r.getAmtCoffee()) {
      isEnough = false;
    }
    if(Inventory.milk < r.getAmtMilk()) {
      isEnough = false;
    }
    if(Inventory.sugar < r.getAmtSugar()) {
      isEnough = false;
    }
    if(Inventory.chocolate < r.getAmtChocolate()) {
      isEnough = false;
    }
    return isEnough;
###
45, addMilk, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 135, 145
6
/**
   * Add the number of milk units in the inventory 
   * to the current amount of milk units.
   * @param milk
   * @throws InventoryException
   */
11
  public synchronized void addMilk(String milk) throws InventoryException {
    int amtMilk = 0;
    try {
      amtMilk = Integer.parseInt(milk);
    } catch (NumberFormatException e) {
      throw new InventoryException("Units of milk must be a positive integer");
    }
    if (amtMilk >= 0) {
      Inventory.milk += amtMilk;
    } else {
      throw new InventoryException("Units of milk must be a positive integer");
###
46, Inventory, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 21, 25
4
/**
   * Creates a coffee maker inventory object and
   * fills each item in the inventory with 15 units.
   */
5
  public Inventory() {
    setCoffee(15);
    setMilk(15);
    setSugar(15);
    setChocolate(15);
###
47, addCoffee, Inventory, CoffeeMaker10
CoffeeMaker_Web/src/edu/ncsu/csc326/coffeemaker/Inventory.java, 95, 105
6
/**
   * Add the number of coffee units in the inventory 
   * to the current amount of coffee units.
   * @param coffee
   * @throws InventoryException
   */
11
  public synchronized void addCoffee(String coffee) throws InventoryException {
    int amtCoffee = 0;
    try {
      amtCoffee = Integer.parseInt(coffee);
    } catch (NumberFormatException e) {
      throw new InventoryException("Units of coffee must be a positive integer");
    }
    if (amtCoffee >= 0) {
      Inventory.coffee += amtCoffee;
    } else {
      throw new InventoryException("Units of coffee must be a positive integer");
###
58, close, ContentReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java, 177, 208
6
/**
  * Skips remaining data and closes the stream.
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
28
   public void close()
    throws IOException
   {
    try {
     int bufferLength = this.buffer.length();
     for (;;) {
      String str = "";
      char ch;
      if (this.bufferIndex >= bufferLength) {
         str = XMLUtil.read(this.reader, '&');
         ch = str.charAt(0);
      } else {
         ch = this.buffer.charAt(this.bufferIndex);
         this.bufferIndex++;
         continue; // don't interprete chars in the buffer
      }
      if (ch == '<') {
         this.reader.unread(ch);
         break;
      }
      if ((ch == '&') && (str.length() > 1)) {
         if (str.charAt(1) != '#') {
          XMLUtil.processEntity(str, this.reader, this.resolver);
         }
      }
     }
    } catch (XMLParseException e) {
     throw new IOException(e.getMessage());
###
59, ContentReader, ContentReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java, 78, 85
7
/**
  * Creates the reader.
  *
  * @param reader the encapsulated reader
  * @param resolver the entity resolver
  * @param buffer data that has already been read from <code>reader</code>
  */
8
   ContentReader(IXMLReader     reader,
         IXMLEntityResolver resolver,
         String       buffer)
   {
    this.reader = reader;
    this.resolver = resolver;
    this.buffer = buffer;
    this.bufferIndex = 0;
###
60, read, ContentReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java, 114, 166
12
/**
  * Reads a block of data.
  *
  * @param outputBuffer where to put the read data
  * @param offset first position in buffer to put the data
  * @param size maximum number of chars to read
  *
  * @return the number of chars read, or -1 if at EOF
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
45
   public int read(char[] outputBuffer,
           int  offset,
           int  size)
    throws IOException
   {
    try {
     int charsRead = 0;
     int bufferLength = this.buffer.length();
     if ((offset + size) > outputBuffer.length) {
      size = outputBuffer.length - offset;
     }
     while (charsRead < size) {
      String str = "";
      char ch;
      if (this.bufferIndex >= bufferLength) {
         str = XMLUtil.read(this.reader, '&');
         ch = str.charAt(0);
      } else {
         ch = this.buffer.charAt(this.bufferIndex);
         this.bufferIndex++;
         outputBuffer[charsRead] = ch;
         charsRead++;
         continue; // don't interprete chars in the buffer
      }
      if (ch == '<') {
         this.reader.unread(ch);
         break;
      }
      if ((ch == '&') && (str.length() > 1)) {
         if (str.charAt(1) == '#') {
          ch = XMLUtil.processCharLiteral(str);
         } else {
          XMLUtil.processEntity(str, this.reader, this.resolver);
          continue;
         }
      }
      outputBuffer[charsRead] = ch;
      charsRead++;
     }
     if (charsRead == 0) {
      charsRead = -1;
     }
     return charsRead;
    } catch (XMLParseException e) {
     throw new IOException(e.getMessage());
###
61, finalize, ContentReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java, 92, 98
3
/**
  * Cleans up the object when it's destroyed.
  */
7
   protected void finalize()
    throws Throwable
   {
    this.reader = null;
    this.resolver = null;
    this.buffer = null;
    super.finalize();
###
62, finalize, PIReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/PIReader.java, 74, 78
3
/**
  * Cleans up the object when it's destroyed.
  */
5
   protected void finalize()
    throws Throwable
   {
    this.reader = null;
    super.finalize();
###
63, read, PIReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/PIReader.java, 94, 131
12
/**
  * Reads a block of data.
  *
  * @param buffer where to put the read data
  * @param offset first position in buffer to put the data
  * @param size maximum number of chars to read
  *
  * @return the number of chars read, or -1 if at EOF
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
29
   public int read(char[] buffer,
           int  offset,
           int  size)
    throws IOException
   {
    if (this.atEndOfData) {
     return -1;
    }
    int charsRead = 0;
    if ((offset + size) > buffer.length) {
     size = buffer.length - offset;
    }
    while (charsRead < size) {
     char ch = this.reader.read();
     if (ch == '?') {
      char ch2 = this.reader.read();
      if (ch2 == '>') {
         this.atEndOfData = true;
         break;
      }
      this.reader.unread(ch2);
     }
     buffer[charsRead] = ch;
     charsRead++;
    }
    if (charsRead == 0) {
     charsRead = -1;
    }
    return charsRead;
###
64, PIReader, PIReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/PIReader.java, 64, 67
5
/**
  * Creates the reader.
  *
  * @param reader the encapsulated reader
  */
4
   PIReader(IXMLReader reader)
   {
    this.reader = reader;
    this.atEndOfData = false;
###
77, getParameterEntityResolver, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 115, 117
5
/**
  * Returns the parameter entity resolver.
  *
  * @return the entity resolver.
  */
3
   public IXMLEntityResolver getParameterEntityResolver()
   {
    return this.parameterEntityResolver;
###
78, attributeAdded, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 608, 616
8
/**
  * Indicates that an attribute has been added to the current element.
  *
  * @param key    the name of the attribute.
  * @param value    the value of the attribute.
  * @param systemId   the system ID of the XML data of the element.
  * @param lineNr   the line number in the XML data of the element.
  */
8
   public void attributeAdded(String key,
                String value,
                String systemId,
                int  lineNr)
   {
    Properties props = (Properties) this.currentElements.peek();
    if (props.containsKey(key)) {
     props.remove(key);
###
79, processElement, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 184, 217
9
/**
  * Processes an element in the DTD.
  *
  * @param reader     the reader to read data from.
  * @param entityResolver the entity resolver.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
27
   protected void processElement(IXMLReader     reader,
                 IXMLEntityResolver entityResolver)
    throws Exception
   {
    String str = XMLUtil.read(reader, '%');
    char ch = str.charAt(0);
    if (ch != '!') {
     XMLUtil.skipTag(reader);
     return;
    }
    str = XMLUtil.read(reader, '%');
    ch = str.charAt(0);
    switch (ch) {
     case '-':
      XMLUtil.skipComment(reader);
      break;
     case '[':
      this.processConditionalSection(reader, entityResolver);
      break;
     case 'E':
      this.processEntity(reader, entityResolver);
      break;
     case 'A':
      this.processAttList(reader, entityResolver);
      break;
     default:
      XMLUtil.skipTag(reader);
###
80, NonValidator, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 76, 80
3
/**
  * Creates the &quot;validator&quot;.
  */
5
   public NonValidator()
   {
    this.attributeDefaultValues = new Hashtable();
    this.currentElements = new Stack();
    this.parameterEntityResolver = new XMLEntityResolver();
###
81, processEntity, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 460, 530
9
/**
  * Processes an ENTITY element.
  *
  * @param reader     the reader to read data from.
  * @param entityResolver the entity resolver.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
61
   protected void processEntity(IXMLReader     reader,
                IXMLEntityResolver entityResolver)
    throws Exception
   {
    if (! XMLUtil.checkLiteral(reader, "NTITY")) {
     XMLUtil.skipTag(reader);
     return;
    }
    XMLUtil.skipWhitespace(reader, null);
    char ch = XMLUtil.readChar(reader, '\0');
    if (ch == '%') {
     XMLUtil.skipWhitespace(reader, null);
     entityResolver = this.parameterEntityResolver;
    } else {
     reader.unread(ch);
    }
    String key = XMLUtil.scanIdentifier(reader);
    XMLUtil.skipWhitespace(reader, null);
    ch = XMLUtil.readChar(reader, '%');
    String systemID = null;
    String publicID = null;
    switch (ch) {
     case 'P':
      if (! XMLUtil.checkLiteral(reader, "UBLIC")) {
         XMLUtil.skipTag(reader);
         return;
      }
      XMLUtil.skipWhitespace(reader, null);
      publicID = XMLUtil.scanString(reader, '%',
                      this.parameterEntityResolver);
      XMLUtil.skipWhitespace(reader, null);
      systemID = XMLUtil.scanString(reader, '%',
                      this.parameterEntityResolver);
      XMLUtil.skipWhitespace(reader, null);
      XMLUtil.readChar(reader, '%');
      break;
     case 'S':
      if (! XMLUtil.checkLiteral(reader, "YSTEM")) {
         XMLUtil.skipTag(reader);
         return;
      }
      XMLUtil.skipWhitespace(reader, null);
      systemID = XMLUtil.scanString(reader, '%',
                      this.parameterEntityResolver);
      XMLUtil.skipWhitespace(reader, null);
      XMLUtil.readChar(reader, '%');
      break;
     case '"':
     case '\'':
      reader.unread(ch);
      String value = XMLUtil.scanString(reader, '%',
                        this.parameterEntityResolver);
      entityResolver.addInternalEntity(key, value);
      XMLUtil.skipWhitespace(reader, null);
      XMLUtil.readChar(reader, '%');
      break;
     default:
      XMLUtil.skipTag(reader);
    }
    if (systemID != null) {
     entityResolver.addExternalEntity(key, publicID, systemID);
###
83, parseDTD, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 133, 170
12
/**
  * Parses the DTD. The validator object is responsible for reading the
  * full DTD.
  *
  * @param publicID     the public ID, which may be null.
  * @param reader     the reader to read the DTD from.
  * @param entityResolver the entity resolver.
  * @param external     true if the DTD is external.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
33
   public void parseDTD(String       publicID,
            IXMLReader     reader,
            IXMLEntityResolver entityResolver,
            boolean      external)
    throws Exception
   {
    XMLUtil.skipWhitespace(reader, null);
    int origLevel = reader.getStreamLevel();
    for (;;) {
     String str = XMLUtil.read(reader, '%');
     char ch = str.charAt(0);
     if (ch == '%') {
      XMLUtil.processEntity(str, reader,
                  this.parameterEntityResolver);
      continue;
     } else if (ch == '<') {
      this.processElement(reader, entityResolver);
     } else if (ch == ']') {
      return; // end internal DTD
     } else {
      XMLUtil.errorInvalidInput(reader.getSystemID(),
                    reader.getLineNr(),
                    str);
     }
     do {
      ch = reader.read();
      if (external && (reader.getStreamLevel() < origLevel)) {
         reader.unread(ch);
         return; // end external DTD
      }
     } while ((ch == ' ') || (ch == '\t') || (ch == '\n')
          || (ch == '\r'));
     reader.unread(ch);
###
84, elementStarted, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 542, 555
7
/**
  * Indicates that an element has been started.
  *
  * @param name     the name of the element.
  * @param systemId   the system ID of the XML data of the element.
  * @param lineNr   the line number in the XML data of the element.
  */
12
   public void elementStarted(String name,
                String systemId,
                int  lineNr)
   {
    Properties attribs
     = (Properties) this.attributeDefaultValues.get(name);
    if (attribs == null) {
     attribs = new Properties();
    } else {
     attribs = (Properties) attribs.clone();
    }
    this.currentElements.push(attribs);
###
85, elementAttributesProcessed, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 585, 595
14
/**
  * This method is called when the attributes of an XML element have been
  * processed.
  * If there are attributes with a default value which have not been
  * specified yet, they have to be put into <I>extraAttributes</I>.
  *
  * @param name      the name of the element.
  * @param extraAttributes where to put extra attributes.
  * @param systemId    the system ID of the XML data of the element.
  * @param lineNr      the line number in the XML data of the element.
  */
 --------------
// nothing to do
 --------------
10
   public void elementAttributesProcessed(String   name,
                      Properties extraAttributes,
                      String   systemId,
                      int    lineNr)
   {
    Properties props = (Properties) this.currentElements.pop();
    Enumeration enm = props.keys();
    while (enm.hasMoreElements()) {
     String key = (String) enm.nextElement();
     extraAttributes.put(key, props.get(key));
###
86, processIgnoreSection, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 303, 323
9
/**
  * Processes an ignore section.
  *
  * @param reader     the reader to read data from.
  * @param entityResolver the entity resolver.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
17
   protected void processIgnoreSection(IXMLReader     reader,
                     IXMLEntityResolver entityResolver)
    throws Exception
   {
    if (! XMLUtil.checkLiteral(reader, "NORE")) {
     XMLUtil.skipTag(reader);
     return;
    }
    XMLUtil.skipWhitespace(reader, null);
    String str = XMLUtil.read(reader, '%');
    char ch = str.charAt(0);
    if (ch != '[') {
     XMLUtil.skipTag(reader);
     return;
    }
    Reader subreader = new CDATAReader(reader);
    subreader.close();
###
87, processConditionalSection, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 231, 290
9
/**
  * Processes a conditional section.
  *
  * @param reader     the reader to read data from.
  * @param entityResolver the entity resolver.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
45
   protected void processConditionalSection(IXMLReader     reader,
                      IXMLEntityResolver entityResolver)
    throws Exception
   {
    XMLUtil.skipWhitespace(reader, null);
    String str = XMLUtil.read(reader, '%');
    char ch = str.charAt(0);
    if (ch != 'I') {
     XMLUtil.skipTag(reader);
     return;
    }
    str = XMLUtil.read(reader, '%');
    ch = str.charAt(0);
    switch (ch) {
     case 'G':
      this.processIgnoreSection(reader, entityResolver);
      return;
     case 'N':
      break;
     default:
      XMLUtil.skipTag(reader);
      return;
    }
    if (! XMLUtil.checkLiteral(reader, "CLUDE")) {
     XMLUtil.skipTag(reader);
     return;
    }
    XMLUtil.skipWhitespace(reader, null);
    str = XMLUtil.read(reader, '%');
    ch = str.charAt(0);
    if (ch != '[') {
     XMLUtil.skipTag(reader);
     return;
    }
    Reader subreader = new CDATAReader(reader);
    StringBuffer buf = new StringBuffer(1024);
    for (;;) {
     int ch2 = subreader.read();
     if (ch2 < 0) {
      break;
     }
     buf.append((char) ch2);
    }
    subreader.close();
    reader.startNewStream(new StringReader(buf.toString()));
###
88, setParameterEntityResolver, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 104, 106
5
/**
  * Sets the parameter entity resolver.
  *
  * @param resolver the entity resolver.
  */
3
   public void setParameterEntityResolver(IXMLEntityResolver resolver)
   {
    this.parameterEntityResolver = resolver;
###
89, processAttList, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 336, 446
9
/**
  * Processes an ATTLIST element.
  *
  * @param reader     the reader to read data from.
  * @param entityResolver the entity resolver.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
100
   protected void processAttList(IXMLReader     reader,
                 IXMLEntityResolver entityResolver)
    throws Exception
   {
    if (! XMLUtil.checkLiteral(reader,  "TTLIST")) {
     XMLUtil.skipTag(reader);
     return;
    }
    XMLUtil.skipWhitespace(reader, null);
    String str = XMLUtil.read(reader, '%');
    char ch = str.charAt(0);
    while (ch == '%') {
     XMLUtil.processEntity(str, reader,
                 this.parameterEntityResolver);
     str = XMLUtil.read(reader, '%');
     ch = str.charAt(0);
    }
    reader.unread(ch);
    String elementName = XMLUtil.scanIdentifier(reader);
    XMLUtil.skipWhitespace(reader, null);
    
    str = XMLUtil.read(reader, '%');
    ch = str.charAt(0);
    while (ch == '%') {
     XMLUtil.processEntity(str, reader,
                 this.parameterEntityResolver);
     str = XMLUtil.read(reader, '%');
     ch = str.charAt(0);
    }
    Properties props = new Properties();
    while (ch != '>') {
     reader.unread(ch);
     String attName = XMLUtil.scanIdentifier(reader);
     XMLUtil.skipWhitespace(reader, null);
     str = XMLUtil.read(reader, '%');
     ch = str.charAt(0);
     while (ch == '%') {
       XMLUtil.processEntity(str, reader,
                   this.parameterEntityResolver);
       str = XMLUtil.read(reader, '%');
       ch = str.charAt(0);
     }
     if (ch == '(') {
       while (ch != ')') {
         str = XMLUtil.read(reader, '%');
         ch = str.charAt(0);
         while (ch == '%') {
           XMLUtil.processEntity(str, reader,
                       this.parameterEntityResolver);
           str = XMLUtil.read(reader, '%');
           ch = str.charAt(0);
         }
       }
     } else {
      reader.unread(ch);
      XMLUtil.scanIdentifier(reader);
     }
     XMLUtil.skipWhitespace(reader, null);
     str = XMLUtil.read(reader, '%');
     ch = str.charAt(0);
     while (ch == '%') {
       XMLUtil.processEntity(str, reader,
                   this.parameterEntityResolver);
       str = XMLUtil.read(reader, '%');
       ch = str.charAt(0);
     }
     
     if (ch == '#') {
      str = XMLUtil.scanIdentifier(reader);
      XMLUtil.skipWhitespace(reader, null);
      if (! str.equals("FIXED")) {
         XMLUtil.skipWhitespace(reader, null);
         str = XMLUtil.read(reader, '%');
         ch = str.charAt(0);
         while (ch == '%') {
          XMLUtil.processEntity(str, reader,
                    this.parameterEntityResolver);
          str = XMLUtil.read(reader, '%');
          ch = str.charAt(0);
         }
         continue;
      }
     } else {
      reader.unread(ch);
     }
     String value = XMLUtil.scanString(reader, '%',
                       this.parameterEntityResolver);
     props.put(attName, value);
     XMLUtil.skipWhitespace(reader, null);
     str = XMLUtil.read(reader, '%');
     ch = str.charAt(0);
     while (ch == '%') {
      XMLUtil.processEntity(str, reader,
                  this.parameterEntityResolver);
      str = XMLUtil.read(reader, '%');
      ch = str.charAt(0);
     }
    }
    if (! props.isEmpty()) {
     this.attributeDefaultValues.put(elementName, props);
###
90, finalize, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 87, 95
3
/**
  * Cleans up the object when it's destroyed.
  */
9
   protected void finalize()
    throws Throwable
   {
    this.parameterEntityResolver = null;
    this.attributeDefaultValues.clear();
    this.attributeDefaultValues = null;
    this.currentElements.clear();
    this.currentElements = null;
    super.finalize();
###
149, CDATAReader, CDATAReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/CDATAReader.java, 70, 74
5
/**
  * Creates the reader.
  *
  * @param reader the encapsulated reader
  */
5
   CDATAReader(IXMLReader reader)
   {
    this.reader = reader;
    this.savedChar = 0;
    this.atEndOfData = false;
###
150, finalize, CDATAReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/CDATAReader.java, 81, 85
3
/**
  * Cleans up the object when it's destroyed.
  */
5
   protected void finalize()
    throws Throwable
   {
    this.reader = null;
    super.finalize();
###
151, read, CDATAReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/CDATAReader.java, 101, 150
12
/**
  * Reads a block of data.
  *
  * @param buffer where to put the read data
  * @param offset first position in buffer to put the data
  * @param size maximum number of chars to read
  *
  * @return the number of chars read, or -1 if at EOF
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
41
   public int read(char[] buffer,
           int  offset,
           int  size)
    throws IOException
   {
    int charsRead = 0;
    if (this.atEndOfData) {
     return -1;
    }
    if ((offset + size) > buffer.length) {
     size = buffer.length - offset;
    }
    while (charsRead < size) {
     char ch = this.savedChar;
     if (ch == 0) {
      ch = this.reader.read();
     } else {
      this.savedChar = 0;
     }
     if (ch == ']') {
      char ch2 = this.reader.read();
      
      if (ch2 == ']') {
         char ch3 = this.reader.read();
         if (ch3 == '>') {
          this.atEndOfData = true;
          break;
         }
         this.savedChar = ch2;
         this.reader.unread(ch3);
      } else {
         this.reader.unread(ch2);
      }
     }
     buffer[charsRead] = ch;
     charsRead++;
    }
    if (charsRead == 0) {
     charsRead = -1;
    }
    return charsRead;
###
215, getElementName, XMLValidationException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java, 165, 167
4
/**
  * Returns the name of the element in which the validation is violated.
  * If there is no current element, null is returned.
  */
3
   public String getElementName()
   {
    return this.elementName;
###
216, getAttributeName, XMLValidationException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java, 175, 177
4
/**
  * Returns the name of the attribute in which the validation is violated.
  * If there is no current attribute, null is returned.
  */
3
   public String getAttributeName()
   {
    return this.attributeName;
###
217, XMLValidationException, XMLValidationException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java, 127, 144
12
/**
  * Creates a new exception.
  *
  * @param errorType    the type of validity error
  * @param systemID     the system ID from where the data came
  * @param lineNr     the line number in the XML data where the
  *             exception occurred.
  * @param elementName  the name of the offending element
  * @param attributeName  the name of the offending attribute
  * @param attributeValue the value of the offending attribute
  * @param msg      the message of the exception.
  */
18
   public XMLValidationException(int  errorType,
                 String systemID,
                 int  lineNr,
                 String elementName,
                 String attributeName,
                 String attributeValue,
                 String msg)
   {
    super(systemID, lineNr, null,
      msg + ((elementName == null) ? "" : (", element=" + elementName))
      + ((attributeName == null) ? ""
                     : (", attribute=" + attributeName))
      + ((attributeValue == null) ? ""
                     : (", value='" + attributeValue + "'")),
      false);
    this.elementName = elementName;
    this.attributeName = attributeName;
    this.attributeValue = attributeValue;
###
218, finalize, XMLValidationException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java, 151, 157
3
/**
  * Cleans up the object when it's destroyed.
  */
7
   protected void finalize()
    throws Throwable
   {
    this.elementName = null;
    this.attributeName = null;
    this.attributeValue = null;
    super.finalize();
###
219, errorClosingTagNotEmpty, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 552, 557
7
/**
  * Throws an XMLParseException to indicate that extra data is encountered
  * in a closing tag.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  */
6
   static void errorClosingTagNotEmpty(String systemID,
                     int  lineNr)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "Closing tag must be empty");
###
221, errorUnexpectedPCData, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 722, 733
8
/**
  * Throws an XMLValidationException to indicate that a #PCDATA element was
  * unexpected.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param parentElementName the name of the parent element
  */
12
   static void errorUnexpectedPCData(String systemID,
                   int  lineNr,
                   String parentElementName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
            XMLValidationException.UNEXPECTED_PCDATA,
            systemID, lineNr,
            /*elementName*/ null,
            /*attributeName*/ null,
            /*attributeValue*/ null,
            "Unexpected #PCDATA in element " + parentElementName);
###
223, errorUnexpectedCDATA, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 496, 501
7
/**
  * Throws an XMLParseException to indicate that a CDATA section is
  * unexpected at this point.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  */
6
   static void errorUnexpectedCDATA(String systemID,
                  int  lineNr)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "No CDATA section is expected here");
###
225, errorInvalidAttributeValue, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 674, 687
10
/**
  * Throws an XMLValidationException to indicate that an attribute has an
  * invalid value.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param elementName  the name of the element
  * @param attributeName  the name of the attribute
  * @param attributeValue the value of that attribute
  */
14
   static void errorInvalidAttributeValue(String systemID,
                      int  lineNr,
                      String elementName,
                      String attributeName,
                      String attributeValue)
    throws XMLValidationException
   {
    throw new XMLValidationException(
               XMLValidationException.ATTRIBUTE_WITH_INVALID_VALUE,
               systemID, lineNr,
               elementName,
               attributeName,
               attributeValue,
               "Invalid value for attribute " + attributeName);
###
227, errorUnexpectedAttribute, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 647, 660
9
/**
  * Throws an XMLValidationException to indicate that an attribute is
  * unexpected.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param elementName  the name of the element
  * @param attributeName  the name of the unexpected attribute
  */
14
   static void errorUnexpectedAttribute(String systemID,
                    int  lineNr,
                    String elementName,
                    String attributeName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
           XMLValidationException.UNEXPECTED_ATTRIBUTE,
           systemID, lineNr,
           elementName,
           attributeName,
           /*attributeValue*/ null,
           "Element " + elementName + " did not expect an attribute "
           + "named " + attributeName);
###
230, scanPublicID, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 128, 140
11
/**
  * Scans a public ID.
  *
  * @param publicID     will contain the public ID
  * @param reader     the reader
  *
  * @return the system ID
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
12
   static String scanPublicID(StringBuffer publicID,
                IXMLReader   reader)
    throws IOException,
       XMLParseException
   {
    if (! XMLUtil.checkLiteral(reader, "UBLIC")) {
     return null;
    }
    XMLUtil.skipWhitespace(reader, null);
    publicID.append(XMLUtil.scanString(reader, '\0', null));
    XMLUtil.skipWhitespace(reader, null);
    return XMLUtil.scanString(reader, '\0', null);
###
231, errorWrongClosingTag, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 532, 541
9
/**
  * Throws an XMLParseException to indicate that the closing tag of an
  * element does not match the opening tag.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param expectedName the name of the opening tag
  * @param wrongName  the name of the closing tag
  */
10
   static void errorWrongClosingTag(String systemID,
                  int  lineNr,
                  String   expectedName,
                  String   wrongName)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "Closing tag does not match opening tag: `"
                  + wrongName + "' != `" + expectedName
                  + "'");
###
232, readChar, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 391, 405
7
/**
  * Reads a character from the reader disallowing entities.
  *
  * @param reader     the reader
  * @param entityChar   the escape character (&amp; or %) used to indicate
  *             an entity
  */
13
   static char readChar(IXMLReader reader,
            char     entityChar)
    throws IOException,
       XMLParseException
   {
    String str = XMLUtil.read(reader, entityChar);
    char ch = str.charAt(0);
    if (ch == entityChar) {
     XMLUtil.errorUnexpectedEntity(reader.getSystemID(),
                     reader.getLineNr(),
                     str);
    }
    return ch;
###
233, updateApplicationEnabled, AbstractApplicationAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java, 91, 94
4
/**
   * Updates the enabled state of this action depending on the new enabled
   * state of the application.
   */
4
  protected void updateApplicationEnabled() {
    firePropertyChange("enabled",
        Boolean.valueOf(!isEnabled()),
        Boolean.valueOf(isEnabled()));
###
234, checkLiteral, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 419, 430
10
/**
  * Returns true if the data starts with <I>literal</I>.
  * Enough chars are read to determine this result.
  *
  * @param reader     the reader
  * @param literal    the literal to check
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
11
   static boolean checkLiteral(IXMLReader     reader,
                 String       literal)
    throws IOException,
       XMLParseException
   {
    for (int i = 0; i < literal.length(); i++) {
     if (reader.read() != literal.charAt(i)) {
      return false;
     }
    }
    return true;
###
235, isEnabled, AbstractApplicationAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java, 105, 107
8
/**
   * Returns true if the action is enabled.
   * The enabled state of the action depends on the state that has been set
   * using setEnabled() and on the enabled state of the application.
   *
   * @return true if the action is enabled, false otherwise
   * @see Action#isEnabled
   */
3
  @Override
  public boolean isEnabled() {
    return app != null && app.isEnabled() && enabled;
###
236, installApplicationListeners, AbstractApplicationAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java, 58, 62
3
/*
   * Installs listeners on the application object.
   */
5
  protected void installApplicationListeners(Application app) {
    if (applicationListener == null) {
      applicationListener = createApplicationListener();
    }
    app.addPropertyChangeListener(new WeakPropertyChangeListener(applicationListener));
###
237, scanString, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 209, 256
10
/**
  * Retrieves a delimited string from the data.
  *
  * @param reader        the reader
  * @param entityChar      the escape character (&amp; or %)
  * @param entityResolver    the entity resolver
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
44
   static String scanString(IXMLReader     reader,
              char         entityChar,
              IXMLEntityResolver entityResolver)
    throws IOException,
       XMLParseException
   {
    StringBuffer result = new StringBuffer();
    int startingLevel = reader.getStreamLevel();
    char delim = reader.read();
    if ((delim != '\'') && (delim != '"')) {
     XMLUtil.errorExpectedInput(reader.getSystemID(),
                  reader.getLineNr(),
                  "delimited string");
    }
    for (;;) {
     String str = XMLUtil.read(reader, entityChar);
     char ch = str.charAt(0);
     if (ch == entityChar) {
      if (str.charAt(1) == '#') {
         result.append(XMLUtil.processCharLiteral(str));
      } else {
         XMLUtil.processEntity(str, reader, entityResolver);
      }
     } else if (ch == '&') {
      reader.unread(ch);
      str = XMLUtil.read(reader, '&');
      if (str.charAt(1) == '#') {
         result.append(XMLUtil.processCharLiteral(str));
      } else {
         result.append(str);
      }
     } else if (reader.getStreamLevel() == startingLevel) {
      if (ch == delim) {
         break;
      } else if ((ch == 9) || (ch == 10) || (ch == 13)) {
         result.append(' ');
      } else {
         result.append(ch);
      }
     } else {
      result.append(ch);
     }
    }
    return result.toString();
###
238, uninstallApplicationListeners, AbstractApplicationAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java, 68, 69
3
/**
   * Installs listeners on the application object.
   */
2
  protected void uninstallApplicationListeners(Application app) {
    app.removePropertyChangeListener(applicationListener);
###
239, AbstractApplicationAction, AbstractApplicationAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java, 49, 52
1
/** Creates a new instance. */
4
  public AbstractApplicationAction(Application app) {
    this.app = app;
    installApplicationListeners(app);
    updateApplicationEnabled();
###
240, errorMissingAttribute, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 621, 634
9
/**
  * Throws an XMLValidationException to indicate that an attribute is
  * missing.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param elementName  the name of the element
  * @param attributeName  the name of the missing attribute
  */
14
   static void errorMissingAttribute(String systemID,
                   int  lineNr,
                   String elementName,
                   String attributeName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
           XMLValidationException.MISSING_ATTRIBUTE,
           systemID, lineNr,
           elementName,
           attributeName,
           /*attributeValue*/ null,
           "Element " + elementName + " expects an attribute named "
           + attributeName);
###
241, scanSystemID, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 154, 163
10
/**
  * Scans a system ID.
  *
  * @param reader     the reader
  *
  * @return the system ID
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
9
   static String scanSystemID(IXMLReader reader)
    throws IOException,
      XMLParseException
   {
    if (! XMLUtil.checkLiteral(reader, "YSTEM")) {
     return null;
    }
    XMLUtil.skipWhitespace(reader, null);
    return XMLUtil.scanString(reader, '\0', null);
###
242, skipComment, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 55, 81
9
/**
  * Skips the remainder of a comment.
  * It is assumed that &lt;!- is already read.
  *
  * @param reader the reader
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
23
   static void skipComment(IXMLReader reader)
    throws IOException,
       XMLParseException
   {
    if (reader.read() != '-') {
     XMLUtil.errorExpectedInput(reader.getSystemID(),
                  reader.getLineNr(),
                  "<!--");
    }
    
    int dashesRead = 0;
    for (;;) {
     char ch = reader.read();
     switch (ch) {
      case '-':
         dashesRead++;
         break;
      case '>':
         if (dashesRead == 2) {
          return;
         }
      default:
         dashesRead = 0;
###
243, read, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 364, 380
12
/**
  * Reads a character from the reader.
  *
  * @param reader     the reader
  * @param entityChar   the escape character (&amp; or %) used to indicate
  *             an entity
  *
  * @return the character, or an entity expression (like e.g. &amp;lt;)
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
15
   static String read(IXMLReader     reader,
            char         entityChar)
    throws IOException,
       XMLParseException
   {
    char ch = reader.read();
    StringBuffer buf = new StringBuffer();
    buf.append(ch);
    if (ch == entityChar) {
     while (ch != ';') {
      ch = reader.read();
      buf.append(ch);
     }
    }
    return buf.toString();
###
244, errorInvalidEntity, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 460, 466
8
/**
  * Throws an XMLParseException to indicate that an entity could not be
  * resolved.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param entity  the name of the entity
  */
7
   static void errorInvalidEntity(String systemID,
                  int  lineNr,
                  String   entity)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "Invalid entity: `&" + entity + ";'");
###
245, errorUnexpectedElement, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 595, 608
9
/**
  * Throws an XMLValidationException to indicate that an element is
  * unexpected.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param parentElementName the name of the parent element
  * @param unexpectedElementName the name of the unexpected element
  */
14
   static void errorUnexpectedElement(String systemID,
                    int  lineNr,
                    String parentElementName,
                    String unexpectedElementName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
                XMLValidationException.UNEXPECTED_ELEMENT,
                systemID, lineNr,
                unexpectedElementName,
                /*attributeName*/ null,
                /*attributeValue*/ null,
                "Unexpected " + unexpectedElementName + " in a "
                + parentElementName);
###
246, errorInvalidInput, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 513, 519
8
/**
  * Throws an XMLParseException to indicate that a string is not expected
  * at this point.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param unexpectedString the string that is unexpected
  */
7
   static void errorInvalidInput(String systemID,
                 int  lineNr,
                 String   unexpectedString)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "Invalid input: " + unexpectedString);
###
247, errorMissingPCData, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 699, 710
8
/**
  * Throws an XMLValidationException to indicate that a #PCDATA element was
  * missing.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param parentElementName the name of the parent element
  */
12
   static void errorMissingPCData(String systemID,
                  int  lineNr,
                  String parentElementName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
               XMLValidationException.MISSING_PCDATA,
               systemID, lineNr,
               /*elementName*/ null,
               /*attributeName*/ null,
               /*attributeValue*/ null,
               "Missing #PCDATA in element " + parentElementName);
###
248, errorExpectedInput, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 442, 448
8
/**
  * Throws an XMLParseException to indicate that an expected string is not
  * encountered.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param expectedString the string that is expected
  */
7
   static void errorExpectedInput(String systemID,
                  int  lineNr,
                  String expectedString)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "Expected: " + expectedString);
###
249, errorMissingElement, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 569, 582
8
/**
  * Throws an XMLValidationException to indicate that an element is missing.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param parentElementName the name of the parent element
  * @param missingElementName the name of the missing element
  */
14
   static void errorMissingElement(String systemID,
                   int  lineNr,
                   String parentElementName,
                   String missingElementName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
                XMLValidationException.MISSING_ELEMENT,
                systemID, lineNr,
                missingElementName,
                /*attributeName*/ null,
                /*attributeValue*/ null,
                "Element " + parentElementName
                + " expects to have a " + missingElementName);
###
250, errorUnexpectedEntity, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 478, 485
8
/**
  * Throws an XMLParseException to indicate that an entity reference is
  * unexpected at this point.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param entity  the name of the entity
  */
8
   static void errorUnexpectedEntity(String systemID,
                   int  lineNr,
                   String entity)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "No entity reference is expected here ("
                  + entity + ")");
###
251, AbstractSaveUnsavedChangesAction, AbstractSaveUnsavedChangesAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractSaveUnsavedChangesAction.java, 52, 53
1
/** Creates a new instance. */
2
  public AbstractSaveUnsavedChangesAction(Application app, View view) {
    super(app, view);
###
252, processEntity, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 270, 286
10
/**
  * Processes an entity.
  *
  * @param entity     the entity
  * @param reader     the reader
  * @param entityResolver the entity resolver
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
15
   static void processEntity(String       entity,
               IXMLReader     reader,
               IXMLEntityResolver entityResolver)
    throws IOException,
       XMLParseException
   {
    entity = entity.substring(1, entity.length() - 1);
    Reader entityReader = entityResolver.getEntity(reader, entity);
    if (entityReader == null) {
     XMLUtil.errorInvalidEntity(reader.getSystemID(),
                  reader.getLineNr(),
                  entity);
    }
    boolean externalEntity = entityResolver.isExternalEntity(entity);
    reader.startNewStream(entityReader, !externalEntity);
###
253, scanIdentifier, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 175, 195
8
/**
  * Retrieves an identifier from the data.
  *
  * @param reader     the reader
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
18
   static String scanIdentifier(IXMLReader reader)
    throws IOException,
       XMLParseException
   {
    StringBuffer result = new StringBuffer();
    for (;;) {
     char ch = reader.read();
     if ((ch == '_') || (ch == ':') || (ch == '-') || (ch == '.')
       || ((ch >= 'a') && (ch <= 'z'))
       || ((ch >= 'A') && (ch <= 'Z'))
       || ((ch >= '0') && (ch <= '9')) || (ch > '\u007E')) {
      result.append(ch);
     } else {
      reader.unread(ch);
      break;
     }
    }
    return result.toString();
###
254, skipWhitespace, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 322, 348
10
/**
  * Skips whitespace from the reader.
  *
  * @param reader     the reader
  * @param buffer     where to put the whitespace; null if the
  *             whitespace does not have to be stored.
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
23
   static void skipWhitespace(IXMLReader   reader,
                StringBuffer buffer)
    throws IOException
   {
    char ch;
    if (buffer == null) {
     do {
      ch = reader.read();
     } while ((ch == ' ') || (ch == '\t') || (ch == '\n'));
    } else {
     for (;;) {
      ch = reader.read();
      if ((ch != ' ') && (ch != '\t') && (ch != '\n')) {
         break;
      }
      if (ch == '\n') {
         buffer.append('\n');
      } else {
         buffer.append(' ');
      }
     }
    }
    reader.unread(ch);
###
255, skipTag, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 95, 111
8
/**
  * Skips the remainder of the current XML tag.
  *
  * @param reader     the reader
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
14
   static void skipTag(IXMLReader reader)
    throws IOException,
       XMLParseException
   {
    int level = 1;
    while (level > 0) {
     char ch = reader.read();
     switch (ch) {
      case '<':
         ++level;
         break;
      case '>':
         --level;
         break;
###
256, processCharLiteral, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 298, 307
8
/**
  * Processes a character literal.
  *
  * @param entity     the entity
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
10
   static char processCharLiteral(String entity)
    throws IOException,
       XMLParseException
   {
    if (entity.charAt(2) == 'x') {
     entity = entity.substring(3, entity.length() - 1);
     return (char) Integer.parseInt(entity, 16);
    } else {
     entity = entity.substring(2, entity.length() - 1);
     return (char) Integer.parseInt(entity, 10);
###
260, setViewClassName, AbstractApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplicationModel.java, 79, 82
3
/**
   * Use this method for best application startup performance.
   */
4
  public void setViewClassName(String newValue) {
    String oldValue = viewClassName;
    viewClassName = newValue;
    firePropertyChange(VIEW_CLASS_NAME_PROPERTY, oldValue, newValue);
###
263, createImportChooser, AbstractApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplicationModel.java, 166, 168
1
/** Returns createOpenChooser. */
3
  @Override
  public URIChooser createImportChooser(Application a, View v) {
    return createOpenChooser(a,v);
###
264, setViewClass, AbstractApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplicationModel.java, 88, 91
3
/**
   * Use this method only, if setViewClassName() does not suit you.
   */
4
  public void setViewClass(Class newValue) {
    Class oldValue = viewClass;
    viewClass = newValue;
    firePropertyChange(VIEW_CLASS_PROPERTY, oldValue, newValue);
###
266, XMLParseException, XMLParseException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLParseException.java, 48, 50
5
/**
  * Creates a new exception.
  *
  * @param msg the message of the exception.
  */
3
   public XMLParseException(String msg)
   {
    super(msg);
###
268, createMenuBar, OSXApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/OSXApplication.java, 300, 371
3
/**
   * Creates a menu bar.
   */
68
  protected JMenuBar createMenuBar(View v) {
    JMenuBar mb = new JMenuBar();
    // Get menus from application model
    JMenu fileMenu = null;
    JMenu editMenu = null;
    JMenu helpMenu = null;
    JMenu viewMenu = null;
    JMenu windowMenu = null;
    String fileMenuText = labels.getString("file.text");
    String editMenuText = labels.getString("edit.text");
    String viewMenuText = labels.getString("view.text");
    String windowMenuText = labels.getString("window.text");
    String helpMenuText = labels.getString("help.text");
    for (JMenu mm : getModel().createMenus(this, v)) {
      String text = mm.getText();
      if (text == null) {
        mm.setText("-null-");
      } else if (text.equals(fileMenuText)) {
        fileMenu = mm;
        continue;
      } else if (text.equals(editMenuText)) {
        editMenu = mm;
        continue;
      } else if (text.equals(viewMenuText)) {
        viewMenu = mm;
        continue;
      } else if (text.equals(windowMenuText)) {
        windowMenu = mm;
        continue;
      } else if (text.equals(helpMenuText)) {
        helpMenu = mm;
        continue;
      }
      mb.add(mm);
    }
    // Create missing standard menus
    if (fileMenu == null) {
      fileMenu = createFileMenu(v);
    }
    if (editMenu == null) {
      editMenu = createEditMenu(v);
    }
    if (viewMenu == null) {
      viewMenu = createViewMenu(v);
    }
    if (windowMenu == null) {
      windowMenu = createWindowMenu(v);
    }
    if (helpMenu == null) {
      helpMenu = createHelpMenu(v);
    }
    // Insert standard menus into menu bar
    if (fileMenu != null) {
      mb.add(fileMenu, 0);
    }
    if (editMenu != null) {
      mb.add(editMenu, Math.min(1, mb.getComponentCount()));
    }
    if (viewMenu != null) {
      mb.add(viewMenu, Math.min(2, mb.getComponentCount()));
    }
    if (windowMenu != null) {
      mb.add(windowMenu);
    }
    if (helpMenu != null) {
      mb.add(helpMenu);
    }
    return mb;
###
270, addDisposable, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 238, 242
6
/**
   * Adds a disposable object, which will be disposed when the specified view
   * is disposed.
   *
   * @param disposable
   */
5
  public void addDisposable(Disposable disposable) {
    if (disposables == null) {
      disposables = new LinkedList<Disposable>();
    }
    disposables.add(disposable);
###
271, initComponents, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 152, 154
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
2
  private void initComponents() {
    setLayout(new java.awt.BorderLayout());
###
272, updateViewTitle, OSXApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/OSXApplication.java, 267, 283
6
/**
   * Updates the title of a view and displays it in the given frame.
   * 
   * @param v The view.
   * @param f The frame.
   */
16
  protected void updateViewTitle(View v, JFrame f) {
    String title;
    URI uri = v.getURI();
    if (uri == null) {
      title = labels.getString("unnamedFile");
    } else {
      title = URIUtil.getName(uri);
    }
    v.setTitle(labels.getFormatted("frame.title", title, getName(), v.getMultipleOpenId()));
    f.setTitle(v.getTitle());
    // Adds a proxy icon for the file to the title bar
    // See http://developer.apple.com/technotes/tn2007/tn2196.html#WINDOW_DOCUMENTFILE
    if (uri != null && uri.getScheme() != null && uri.getScheme().equals("file")) {
      f.getRootPane().putClientProperty("Window.documentFile", new File(uri));
    } else {
      f.getRootPane().putClientProperty("Window.documentFile", null);
###
273, hasUnsavedChanges, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 176, 177
4
/**
   * Returns true, if the view has unsaved changes.
   * This is a bound property.
   */
2
  public boolean hasUnsavedChanges() {
    return hasUnsavedChanges;
###
277, getComponent, OSXApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/OSXApplication.java, 557, 571
2
/** Returns the Frame which holds the frameless JMenuBar.
   */
15
  public Component getComponent() {
    if (invisibleFrame == null) {
      invisibleFrame = new JFrame();
      invisibleFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
      invisibleFrame.setUndecorated(true);
      // Move it way off screen
      invisibleFrame.setLocation(10000, 10000);
      // make the frame transparent and shadowless
      // see https://developer.apple.com/mac/library/technotes/tn2007/tn2196.html
      invisibleFrame.getRootPane().putClientProperty("Window.alpha", 0f);
      invisibleFrame.getRootPane().putClientProperty("Window.shadow", false);
      // make it visible, so the menu bar will show
      invisibleFrame.setVisible(true);
    }
    return invisibleFrame;
###
278, addExternalEntity, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 102, 107
7
/**
  * Adds an external entity.
  *
  * @param name the name of the entity.
  * @param publicID the public ID of the entity, which may be null.
  * @param systemID the system ID of the entity.
  */
6
   public void addExternalEntity(String name,
                 String publicID,
                 String systemID)
   {
    if (! this.entities.containsKey(name)) {
     this.entities.put(name, new String[] { publicID, systemID } );
###
279, execute, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 191, 195
5
/**
   * Executes the specified runnable on the worker thread of the view.
   * Execution is perfomred sequentially in the same sequence as the
   * runnables have been passed to this method.
   */
5
  public void execute(Runnable worker) {
    if (executor == null) {
      executor = Executors.newSingleThreadExecutor();
    }
    executor.execute(worker);
###
280, isExternalEntity, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 142, 145
5
/**
  * Returns true if an entity is external.
  *
  * @param name the name of the entity.
  */
4
   public boolean isExternalEntity(String name)
   {
    Object obj = this.entities.get(name);
    return ! (obj instanceof java.lang.String);
###
281, dispose, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 111, 125
4
/**
   * Gets rid of all the resources of the view.
   * No other methods should be invoked on the view afterwards.
   */
13
      @SuppressWarnings("unchecked")
  public void dispose() {
    if (executor != null) {
      executor.shutdown();
      executor = null;
    }
    if (disposables != null) {
      for (Disposable d : (LinkedList<Disposable>)disposables.clone()) {
        d.dispose();
      }
      disposables = null;
    }
    removeAll();
###
283, addInternalEntity, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 86, 90
6
/**
  * Adds an internal entity.
  *
  * @param name the name of the entity.
  * @param value the value of the entity.
  */
5
   public void addInternalEntity(String name,
                 String value)
   {
    if (! this.entities.containsKey(name)) {
     this.entities.put(name, value);
###
284, AbstractView, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 78, 79
3
/**
   * Creates a new instance.
   */
2
  public AbstractView() {
    preferences = PreferencesUtil.userNodeForPackage(getClass());
###
286, XMLEntityResolver, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 57, 64
3
/**
  * Initializes the resolver.
  */
8
   public XMLEntityResolver()
   {
    this.entities = new Hashtable();
    this.entities.put("amp", "&#38;");
    this.entities.put("quot", "&#34;");
    this.entities.put("apos", "&#39;");
    this.entities.put("lt", "&#60;");
    this.entities.put("gt", "&#62;");
###
287, getEntity, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 120, 132
8
/**
  * Returns a Java reader containing the value of an entity.
  *
  * @param xmlReader the current XML reader
  * @param name the name of the entity.
  *
  * @return the reader, or null if the entity could not be resolved.
  */
12
   public Reader getEntity(IXMLReader xmlReader,
               String   name)
    throws XMLParseException
   {
    Object obj = this.entities.get(name);
    if (obj == null) {
     return null;
    } else if (obj instanceof java.lang.String) {
     return new StringReader((String)obj);
    } else {
     String[] id = (String[]) obj;
     return this.openExternalEntity(xmlReader, id[0], id[1]);
###
288, finalize, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 71, 76
3
/**
  * Cleans up the object when it's destroyed.
  */
6
   protected void finalize()
    throws Throwable
   {
    this.entities.clear();
    this.entities = null;
    super.finalize();
###
289, XMLWriter, XMLWriter, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java, 79, 81
5
/**
  * Creates a new XML writer.
  *
  * @param stream where to write the output to.
  */
3
   public XMLWriter(OutputStream stream)
   {
    this.writer = new PrintWriter(stream);
###
291, write, XMLWriter, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java, 148, 261
8
/**
  * Writes an XML element.
  *
  * @param xml the non-null XML element to write.
  * @param prettyPrint if spaces need to be inserted to make the output more
  *          readable
  * @param indent how many spaces to indent the element.
  */
95
   public void write(IXMLElement xml,
           boolean   prettyPrint,
           int     indent,
           boolean   collapseEmptyElements)
    throws IOException
   {
    if (prettyPrint) {
     for (int i = 0; i < indent; i++) {
      this.writer.print(' ');
     }
    }
    if (xml.getName() == null) {
     if (xml.getContent() != null) {
      if (prettyPrint) {
         this.writeEncoded(xml.getContent().trim());
         writer.println();
      } else {
         this.writeEncoded(xml.getContent());
      }
     }
    } else {
     this.writer.print('<');
     this.writer.print(xml.getFullName());
     Vector nsprefixes = new Vector();
     if (xml.getNamespace() != null) {
      if (xml.getName().equals(xml.getFullName())) {
         this.writer.print(" xmlns=\"" + xml.getNamespace() + '"');
      } else {
         String prefix = xml.getFullName();
         prefix = prefix.substring(0, prefix.indexOf(':'));
         nsprefixes.addElement(prefix);
         this.writer.print(" xmlns:" + prefix);
         this.writer.print("=\"" + xml.getNamespace() + "\"");
      }
     }
     Iterator enm = xml.iterateAttributeNames();
     while (enm.hasNext()) {
      String key = (String) enm.next();
      int index = key.indexOf(':');
      if (index >= 0) {
         String namespace = xml.getAttributeNamespace(key);
         if (namespace != null) {
          String prefix = key.substring(0, index);
          if (! nsprefixes.contains(prefix)) {
           this.writer.print(" xmlns:" + prefix);
           this.writer.print("=\"" + namespace + '"');
           nsprefixes.addElement(prefix);
          }
         }
      }
     }
     enm = xml.iterateAttributeNames();
     while (enm.hasNext()) {
      String key = (String) enm.next();
      String value = xml.getAttribute(key, null);
      this.writer.print(" " + key + "=\"");
      this.writeEncoded(value);
      this.writer.print('"');
     }
     if ((xml.getContent() != null)
       && (xml.getContent().length() > 0)) {
      writer.print('>');
      this.writeEncoded(xml.getContent());
      writer.print("</" + xml.getFullName() + '>');
      if (prettyPrint) {
         writer.println();
      }
     } else if (xml.hasChildren() || (! collapseEmptyElements)) {
      writer.print('>');
      if (prettyPrint) {
         writer.println();
      }
      enm = xml.iterateChildren();
      while (enm.hasNext()) {
         IXMLElement child = (IXMLElement) enm.next();
         this.write(child, prettyPrint, indent + 4,
              collapseEmptyElements);
      }
      if (prettyPrint) {
         for (int i = 0; i < indent; i++) {
          this.writer.print(' ');
         }
      }
      this.writer.print("</" + xml.getFullName() + ">");
      if (prettyPrint) {
         writer.println();
      }
     } else {
      this.writer.print("/>");
      if (prettyPrint) {
         writer.println();
      }
     }
    }
    this.writer.flush();
###
292, write, XMLWriter, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java, 101, 104
5
/**
  * Writes an XML element.
  *
  * @param xml the non-null XML element to write.
  */
4
   public void write(IXMLElement xml)
    throws IOException
   {
    this.write(xml, false, 0, true);
###
295, XMLWriter, XMLWriter, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java, 64, 69
5
/**
  * Creates a new XML writer.
  *
  * @param writer where to write the output to.
  */
6
   public XMLWriter(Writer writer)
   {
    if (writer instanceof PrintWriter) {
     this.writer = (PrintWriter) writer;
    } else {
     this.writer = new PrintWriter(writer);
###
297, createMenuBar, MDIApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/MDIApplication.java, 384, 455
3
/**
   * Creates a menu bar.
   */
68
  protected JMenuBar createMenuBar(View v) {
    JMenuBar mb = new JMenuBar();
    // Get menus from application model
    JMenu fileMenu = null;
    JMenu editMenu = null;
    JMenu helpMenu = null;
    JMenu viewMenu = null;
    JMenu windowMenu = null;
    String fileMenuText = labels.getString("file.text");
    String editMenuText = labels.getString("edit.text");
    String viewMenuText = labels.getString("view.text");
    String windowMenuText = labels.getString("window.text");
    String helpMenuText = labels.getString("help.text");
    for (JMenu mm : getModel().createMenus(this, v)) {
      String text = mm.getText();
      if (text == null) {
        mm.setText("-null-");
      } else if (text.equals(fileMenuText)) {
        fileMenu = mm;
        continue;
      } else if (text.equals(editMenuText)) {
        editMenu = mm;
        continue;
      } else if (text.equals(viewMenuText)) {
        viewMenu = mm;
        continue;
      } else if (text.equals(windowMenuText)) {
        windowMenu = mm;
        continue;
      } else if (text.equals(helpMenuText)) {
        helpMenu = mm;
        continue;
      }
      mb.add(mm);
    }
    // Create missing standard menus
    if (fileMenu == null) {
      fileMenu = createFileMenu(v);
    }
    if (editMenu == null) {
      editMenu = createEditMenu(v);
    }
    if (viewMenu == null) {
      viewMenu = createViewMenu(v);
    }
    if (windowMenu == null) {
      windowMenu = createWindowMenu(v);
    }
    if (helpMenu == null) {
      helpMenu = createHelpMenu(v);
    }
    // Insert standard menus into menu bar
    if (fileMenu != null) {
      mb.add(fileMenu, 0);
    }
    if (editMenu != null) {
      mb.add(editMenu, Math.min(1, mb.getComponentCount()));
    }
    if (viewMenu != null) {
      mb.add(viewMenu, Math.min(2, mb.getComponentCount()));
    }
    if (windowMenu != null) {
      mb.add(windowMenu);
    }
    if (helpMenu != null) {
      mb.add(helpMenu);
    }
    return mb;
###
298, wrapDesktopPane, MDIApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/MDIApplication.java, 365, 378
3
/**
   * Returns the wrapped desktop pane.
   */
14
  protected Component wrapDesktopPane(Component c, LinkedList<Action> toolBarActions) {
    if (getModel() != null) {
      int id = 0;
      for (JToolBar tb : new ReversedList<JToolBar>(getModel().createToolBars(this, null))) {
        id++;
        JPanel panel = new JPanel(new BorderLayout());
        panel.add(tb, BorderLayout.NORTH);
        panel.add(c, BorderLayout.CENTER);
        c = panel;
        PreferencesUtil.installToolBarPrefsHandler(prefs, "toolbar." + id, tb);
        toolBarActions.addFirst(new ToggleToolBarAction(tb, tb.getName()));
      }
    }
    return c;
###
299, getNamespace, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 312, 313
6
/**
   * Returns the namespace of the element.
   *
   * @return the namespace, or null if no namespace is associated with the
   *     element.
   */
2
  public String getNamespace() {
    return this.namespace;
###
300, getChildren, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 464, 465
5
/**
   * Returns a vector containing all the child iterator.
   *
   * @return the vector.
   */
2
  public ArrayList getChildren() {
    return this.children;
###
301, maybeAddSeparator, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 306, 307
2
/** Adds a separator to the supplied menu. The separator will only
  be added, if additional items are added using addAction. */
2
  protected void maybeAddSeparator(JMenu m) {
    m.putClientProperty("needsSeparator", Boolean.TRUE);
###
302, addAction, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 275, 276
1
/** Adds the specified action as a menu item to the supplied menu. */
2
  protected void addAction(JMenu m, View view, String actionID) {
    addAction(m, getAction(view, actionID));
###
304, setActiveView, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 138, 147
6
/**
   * Sets the active view. Calls deactivate on the previously
   * active view, and then calls activate on the given view.
   * 
   * @param newValue Active view, can be null.
   */
10
  public void setActiveView(View newValue) {
    View oldValue = activeView;
    if (activeView != null) {
      activeView.deactivate();
    }
    activeView = newValue;
    if (activeView != null) {
      activeView.activate();
    }
    firePropertyChange(ACTIVE_VIEW_PROPERTY, oldValue, newValue);
###
305, hasChildren, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 444, 445
5
/**
   * Returns whether the element has children.
   *
   * @return true if the element has children.
   */
2
  public boolean hasChildren() {
    return (! this.children.isEmpty());
###
306, getAttributeType, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 828, 834
8
/**
   * Returns the type of an attribute.
   *
   * @param name the non-null name of the attribute.
   * @param namespace the namespace URI, which may be null.
   *
   * @return the type, or null if the attribute does not exist.
   */
7
  public String getAttributeType(String name,
      String namespace) {
    XMLAttribute attr = this.findAttribute(name, namespace);
    if (attr == null) {
      return null;
    } else {
      return attr.getType();
###
307, AbstractSelectionAction, AbstractSelectionAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractSelectionAction.java, 49, 66
5
/** Creates a new instance which acts on the specified component.
   *
   * @param target The target of the action. Specify null for the currently
   * focused component.
   */
16
  public AbstractSelectionAction(JComponent target) {
    this.target = target;
    if (target != null) {
      // Register with a weak reference on the JComponent.
      propertyHandler = new PropertyChangeListener() {
        @Override
        public void propertyChange(PropertyChangeEvent evt) {
          String n = evt.getPropertyName();
          if (n.equals("enabled")) {
            updateEnabled();
          } else if (n.equals(EditableComponent.SELECTION_EMPTY_PROPERTY)) {
            updateEnabled();
          }
        }
      };
      target.addPropertyChangeListener(new WeakPropertyChangeListener(propertyHandler));
###
308, addChild, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 354, 368
5
/**
   * Adds a child element.
   *
   * @param child the non-null child to add.
   */
15
  public void addChild(IXMLElement child) {
    if (child == null) {
      throw new IllegalArgumentException("child must not be null");
    }
    if ((child.getName() == null) && (! this.children.isEmpty())) {
      IXMLElement lastChild = (IXMLElement) this.children.get(this.children.size() - 1);
      
      if (lastChild.getName() == null) {
        lastChild.setContent(lastChild.getContent()
        + child.getContent());
        return;
      }
    }
    ((XMLElement)child).parent = this;
    this.children.add(child);
###
310, getFirstChildNamed, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 513, 530
8
/**
   * Searches a child element.
   *
   * @param name    the name of the child to search for.
   * @param namespace the namespace, which may be null.
   *
   * @return the child element, or null if no such child was found.
   */
18
  public IXMLElement getFirstChildNamed(String name,
      String namespace) {
    Iterator enm = this.children.iterator();
    while (enm.hasNext()) {
      IXMLElement child = (IXMLElement) enm.next();
      String str = child.getName();
      boolean found = (str != null) && (str.equals(name));
      str = child.getNamespace();
      if (str == null) {
        found &= (name == null);
      } else {
        found &= str.equals(namespace);
      }
      if (found) {
        return child;
      }
    }
    return null;
###
311, addAction, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 280, 289
1
/** Adds the specified action as a menu item to the supplied menu. */
10
  protected void addAction(JMenu m, Action a) {
    if (a != null) {
      if (m.getClientProperty("needsSeparator") == Boolean.TRUE) {
        m.addSeparator();
        m.putClientProperty("needsSeparator", null);
      }
      JMenuItem mi;
      mi = m.add(a);
      mi.setIcon(null);
      mi.setToolTipText(null);
###
312, getActiveView, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 155, 156
5
/**
   * Gets the active view.
   * 
   * @return The active view can be null.
   */
2
  public View getActiveView() {
    return activeView;
###
313, removeChildAtIndex, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 414, 415
5
/**
   * Removes the child located at a certain index.
   *
   * @param index the index of the child, where the first child has index 0.
   */
2
  public void removeChildAtIndex(int index) {
    this.children.remove(index);
###
314, setActionMap, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 536, 537
3
/**
   * Sets the application-wide action map.
   */
2
  public void setActionMap(ActionMap m) {
    actionMap = m;
###
315, getFullName, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 291, 292
6
/**
   * Returns the full name (i.e. the name including an eventual namespace
   * prefix) of the element.
   *
   * @return the name, or null if the element only contains #PCDATA.
   */
2
  public String getFullName() {
    return this.fullName;
###
316, getParent, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 280, 281
4
/**
   * Returns the parent element. This method returns null for the root
   * element.
   */
2
  public IXMLElement getParent() {
    return this.parent;
###
319, setAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 845, 852
6
/**
   * Sets an attribute.
   *
   * @param name the non-null full name of the attribute.
   * @param value the non-null value of the attribute.
   */
8
  public void setAttribute(String name,
      String value) {
    XMLAttribute attr = this.findAttribute(name);
    if (attr == null) {
      attr = new XMLAttribute(name, name, null, value, "CDATA");
      this.attributes.add(attr);
    } else {
      attr.setValue(value);
###
320, addMenuItem, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 294, 300
1
/** Adds the specified action as a menu item to the supplied menu. */
7
  protected void addMenuItem(JMenu m, JMenuItem mi) {
    if (mi != null) {
      if (m.getClientProperty("needsSeparator") == Boolean.TRUE) {
        m.addSeparator();
        m.putClientProperty("needsSeparator", null);
      }
      m.add(mi);
###
321, equals, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1053, 1057
5
/**
   * Returns true if the element equals another element.
   *
   * @param rawElement the element to compare to
   */
5
  public boolean equals(Object rawElement) {
    try {
      return this.equalsXMLElement((IXMLElement) rawElement);
    } catch (ClassCastException e) {
      return false;
###
322, getName, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 301, 302
5
/**
   * Returns the name of the element.
   *
   * @return the name, or null if the element only contains #PCDATA.
   */
2
  public String getName() {
    return this.name;
###
324, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 725, 728
8
/**
   * Returns the value of an attribute.
   *
   * @param name the non-null full name of the attribute.
   * @param defaultValue the default value of the attribute.
   *
   * @return the value, or defaultValue if the attribute does not exist.
   */
4
  public int getAttribute(String name,
      int  defaultValue) {
    String value = this.getAttribute(name, Integer.toString(defaultValue));
    return Integer.parseInt(value);
###
326, XMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 135, 136
5
/**
   * Creates an empty element.
   *
   * @param fullName the name of the element.
   */
2
  public XMLElement(String fullName) {
    this(fullName, null, null, NO_LINE);
###
329, XMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 125, 126
3
/**
   * Creates an empty element to be used for #PCDATA content.
   */
2
  public XMLElement() {
    this(null, null, null, NO_LINE);
###
331, getContent, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1032, 1033
8
/**
   * Return the #PCDATA content of the element. If the element has a
   * combination of #PCDATA content and child iterator, the #PCDATA
   * sections can be retrieved as unnamed child objects. In this case,
   * this method returns null.
   *
   * @return the content.
   */
2
  public String getContent() {
    return this.content;
###
333, createElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 224, 227
7
/**
   * Creates an empty element.
   *
   * @param fullName the name of the element.
   * @param systemID the system ID of the XML data where the element starts.
   * @param lineNr   the line in the XML data where the element starts.
   */
4
  public IXMLElement createElement(String fullName,
      String systemID,
      int  lineNr) {
    return new XMLElement(fullName, systemID, lineNr);
###
337, updateOpenRecentMenu, OpenRecentMenuHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 393, 428
3
/**
     * Updates the "File &gt; Open Recent" menu.
     */
33
    protected void updateOpenRecentMenu() {
      if (openRecentMenu.getItemCount() > 0) {
        JMenuItem clearRecentFilesItem = (JMenuItem) openRecentMenu.getItem(
            openRecentMenu.getItemCount() - 1);
        openRecentMenu.remove(openRecentMenu.getItemCount() - 1);
        // Dispose the actions and the menu items that are currently in the menu
        for (Action action : openRecentActions) {
          if (action instanceof Disposable) {
            ((Disposable) action).dispose();
          }
        }
        openRecentActions.clear();
        openRecentMenu.removeAll();
        // Create new actions and add them to the menu
        if (getAction(view, LoadFileAction.ID) != null || //
            getAction(view, LoadDirectoryAction.ID) != null) {
          for (URI f : getRecentURIs()) {
            LoadRecentFileAction action = new LoadRecentFileAction(AbstractApplication.this, view, f);
            openRecentMenu.add(action);
            openRecentActions.add(action);
          }
        } else {
          for (URI f : getRecentURIs()) {
            OpenRecentFileAction action = new OpenRecentFileAction(AbstractApplication.this, f);
            openRecentMenu.add(action);
            openRecentActions.add(action);
          }
        }
        if (getRecentURIs().size() > 0) {
          openRecentMenu.addSeparator();
        }
        // Add a separator and the clear recent files item.
        openRecentMenu.add(clearRecentFilesItem);
###
338, getAttributesInNamespace, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 980, 995
7
/**
   * Returns all attributes in a specific namespace as a Properties object.
   *
   * @param namespace the namespace URI of the attributes, which may be null.
   *
   * @return the non-null set.
   */
16
  public Properties getAttributesInNamespace(String namespace) {
    Properties result = new Properties();
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      if (namespace == null) {
        if (attr.getNamespace() == null) {
          result.put(attr.getName(), attr.getValue());
        }
      } else {
        if (namespace.equals(attr.getNamespace())) {
          result.put(attr.getName(), attr.getValue());
        }
      }
    }
    return result;
###
343, equalsXMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1067, 1103
5
/**
   * Returns true if the element equals another element.
   *
   * @param elt the element to compare to
   */
37
  public boolean equalsXMLElement(IXMLElement elt) {
    if (! this.name.equals(elt.getName())) {
      return false;
    }
    if (this.attributes.size() != elt.getAttributeCount()) {
      return false;
    }
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      if (! elt.hasAttribute(attr.getName(), attr.getNamespace())) {
        return false;
      }
      String value = elt.getAttribute(attr.getName(),
          attr.getNamespace(),
          null);
      if (! attr.getValue().equals(value)) {
        return false;
      }
      String type = elt.getAttributeType(attr.getName(),
          attr.getNamespace());
      if (! attr.getType().equals(type)) {
        return false;
      }
    }
    if (this.children.size() != elt.getChildrenCount()) {
      return false;
    }
    for (int i = 0; i < this.children.size(); i++) {
      IXMLElement child1 = this.getChildAtIndex(i);
      IXMLElement child2 = elt.getChildAtIndex(i);
      
      if (! child1.equalsXMLElement(child2)) {
        return false;
      }
    }
    return true;
###
346, getLineNr, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1019, 1020
8
/**
   * Returns the line number in the data where the element started.
   *
   * @return the line number, or NO_LINE if unknown.
   *
   * @see #NO_LINE
   * @see #getSystemID
   */
2
  public int getLineNr() {
    return this.lineNr;
###
348, removeChild, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 401, 405
5
/**
   * Removes a child element.
   *
   * @param child the non-null child to remove.
   */
5
  public void removeChild(IXMLElement child) {
    if (child == null) {
      throw new IllegalArgumentException("child must not be null");
    }
    this.children.remove(child);
###
350, createPCDataElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 202, 203
3
/**
   * Creates an element to be used for #PCDATA content.
   */
2
  public IXMLElement createPCDataElement() {
    return new XMLElement();
###
353, XMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 160, 162
6
/**
   * Creates an empty element.
   *
   * @param fullName  the full name of the element
   * @param namespace the namespace URI.
   */
3
  public XMLElement(String fullName,
      String namespace) {
    this(fullName, namespace, null, NO_LINE);
###
355, getAttributeNamespace, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 810, 815
7
/**
   * Returns the namespace of an attribute.
   *
   * @param name the non-null full name of the attribute.
   *
   * @return the namespace, or null if there is none associated.
   */
6
  public String getAttributeNamespace(String name) {
    XMLAttribute attr = this.findAttribute(name);
    if (attr == null) {
      return null;
    } else {
      return attr.getNamespace();
###
358, getChildrenNamed, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 541, 551
7
/**
   * Returns a vector of all child iterator named <I>name</I>.
   *
   * @param name the full name of the children to search for.
   *
   * @return the non-null vector of child iterator.
   */
11
  public ArrayList getChildrenNamed(String name) {
    ArrayList result = new ArrayList(this.children.size());
    Iterator enm = this.children.iterator();
    while (enm.hasNext()) {
      IXMLElement child = (IXMLElement) enm.next();
      String childName = child.getFullName();
      if ((childName != null) && childName.equals(name)) {
        result.add(child);
      }
    }
    return result;
###
361, createElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 251, 255
8
/**
   * Creates an empty element.
   *
   * @param fullName  the full name of the element
   * @param namespace the namespace URI.
   * @param systemID  the system ID of the XML data where the element starts.
   * @param lineNr  the line in the XML data where the element starts.
   */
5
  public IXMLElement createElement(String fullName,
      String namespace,
      String systemID,
      int  lineNr) {
    return new XMLElement(fullName, namespace, systemID, lineNr);
###
363, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 683, 690
9
/**
   * Returns the value of an attribute.
   *
   * @param name the non-null name of the attribute.
   * @param namespace the namespace URI, which may be null.
   * @param defaultValue the default value of the attribute.
   *
   * @return the value, or defaultValue if the attribute does not exist.
   */
8
  public String getAttribute(String name,
      String namespace,
      String defaultValue) {
    XMLAttribute attr = this.findAttribute(name, namespace);
    if (attr == null) {
      return defaultValue;
    } else {
      return attr.getValue();
###
365, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 741, 746
9
/**
   * Returns the value of an attribute.
   *
   * @param name the non-null name of the attribute.
   * @param namespace the namespace URI, which may be null.
   * @param defaultValue the default value of the attribute.
   *
   * @return the value, or defaultValue if the attribute does not exist.
   */
6
  public int getAttribute(String name,
      String namespace,
      int  defaultValue) {
    String value = this.getAttribute(name, namespace,
        Integer.toString(defaultValue));
    return Integer.parseInt(value);
###
368, getFirstChildNamed, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 492, 501
7
/**
   * Searches a child element.
   *
   * @param name the full name of the child to search for.
   *
   * @return the child element, or null if no such child was found.
   */
10
  public IXMLElement getFirstChildNamed(String name) {
    Iterator enm = this.children.iterator();
    while (enm.hasNext()) {
      IXMLElement child = (IXMLElement) enm.next();
      String childName = child.getFullName();
      if ((childName != null) && childName.equals(name)) {
        return child;
      }
    }
    return null;
###
370, getAttributeCount, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 636, 637
3
/**
   * Returns the number of attributes.
   */
2
  public int getAttributeCount() {
    return this.attributes.size();
###
372, XMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 147, 150
7
/**
   * Creates an empty element.
   *
   * @param fullName the name of the element.
   * @param systemID the system ID of the XML data where the element starts.
   * @param lineNr   the line in the XML data where the element starts.
   */
4
  public XMLElement(String fullName,
      String systemID,
      int  lineNr) {
    this(fullName, null, systemID, lineNr);
###
374, XMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 174, 195
8
/**
   * Creates an empty element.
   *
   * @param fullName  the full name of the element
   * @param namespace the namespace URI.
   * @param systemID  the system ID of the XML data where the element starts.
   * @param lineNr  the line in the XML data where the element starts.
   */
22
  public XMLElement(String fullName,
      String namespace,
      String systemID,
      int  lineNr) {
    this.attributes = new ArrayList();
    this.children = new ArrayList(8);
    this.fullName = fullName;
    if (namespace == null) {
      this.name = fullName;
    } else {
      int index = fullName.indexOf(':');
      if (index >= 0) {
        this.name = fullName.substring(index + 1);
      } else {
        this.name = fullName;
      }
    }
    this.namespace = namespace;
    this.content = null;
    this.lineNr = lineNr;
    this.systemID = systemID;
    this.parent = null;
###
375, createElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 212, 213
5
/**
   * Creates an empty element.
   *
   * @param fullName the name of the element.
   */
2
  public IXMLElement createElement(String fullName) {
    return new XMLElement(fullName);
###
376, setName, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 336, 345
6
/**
   * Sets the name.
   *
   * @param fullName  the non-null full name.
   * @param namespace the namespace URI, which may be null.
   */
10
  public void setName(String fullName,
      String namespace) {
    int index = fullName.indexOf(':');
    if ((namespace == null) || (index < 0)) {
      this.name = fullName;
    } else {
      this.name = fullName.substring(index + 1);
    }
    this.fullName = fullName;
    this.namespace = namespace;
###
377, hasAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 941, 942
5
/**
   * Returns whether an attribute exists.
   *
   * @return true if the attribute exists.
   */
2
  public boolean hasAttribute(String name) {
    return this.findAttribute(name) != null;
###
378, removeAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 884, 889
5
/**
   * Removes an attribute.
   *
   * @param name the non-null name of the attribute.
   */
6
  public void removeAttribute(String name) {
    for (int i = 0; i < this.attributes.size(); i++) {
      XMLAttribute attr = (XMLAttribute) this.attributes.get(i);
      if (attr.getFullName().equals(name)) {
        this.attributes.remove(i);
        return;
###
379, createElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 237, 239
6
/**
   * Creates an empty element.
   *
   * @param fullName  the full name of the element
   * @param namespace the namespace URI.
   */
3
  public IXMLElement createElement(String fullName,
      String namespace) {
    return new XMLElement(fullName, namespace);
###
381, getAttributes, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 962, 969
5
/**
   * Returns all attributes as a Properties object.
   *
   * @return the non-null set.
   */
8
  public Properties getAttributes() {
    Properties result = new Properties();
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      result.put(attr.getFullName(), attr.getValue());
    }
    return result;
###
382, isLeaf, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 434, 435
5
/**
   * Returns whether the element is a leaf element.
   *
   * @return true if the element has no children.
   */
2
  public boolean isLeaf() {
    return this.children.isEmpty();
###
383, findAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 593, 601
7
/**
   * Searches an attribute.
   *
   * @param fullName the non-null full name of the attribute.
   *
   * @return the attribute, or null if the attribute does not exist.
   */
9
  private XMLAttribute findAttribute(String fullName) {
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      if (attr.getFullName().equals(fullName)) {
        return attr;
      }
    }
    return null;
###
384, findAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 613, 629
8
/**
   * Searches an attribute.
   *
   * @param name the non-null short name of the attribute.
   * @param namespace the name space, which may be null.
   *
   * @return the attribute, or null if the attribute does not exist.
   */
17
  private XMLAttribute findAttribute(String name,
      String namespace) {
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      boolean found = attr.getName().equals(name);
      if (namespace == null) {
        found &= (attr.getNamespace() == null);
      } else {
        found &= namespace.equals(attr.getNamespace());
      }
      
      if (found) {
        return attr;
      }
    }
    return null;
###
385, getChildrenCount, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 454, 455
5
/**
   * Returns the number of children.
   *
   * @return the count.
   */
2
  public int getChildrenCount() {
    return this.children.size();
###
386, getDoubleAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 702, 712
9
/**
   * Returns an attribute of the element.
   * If the attribute doesn't exist, <code>defaultValue</code> is returned.
   *
   * @param name     The name of the attribute.
   * @param namespace the namespace URI, which may be null.
   * @param defaultValue Key to use if the attribute is missing.
   *
   */
11
  public double getDoubleAttribute(String name,
      String namespace,
      double defaultValue) {
    XMLAttribute attr = this.findAttribute(name, namespace);
    if (attr == null) {
      return defaultValue;
    } else {
      try {
        return Double.parseDouble(attr.getValue());
      } catch (NumberFormatException e) {
        return defaultValue;
###
387, getChildrenNamed, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 563, 582
8
/**
   * Returns a vector of all child iterator named <I>name</I>.
   *
   * @param name    the name of the children to search for.
   * @param namespace the namespace, which may be null.
   *
   * @return the non-null vector of child iterator.
   */
20
  public ArrayList getChildrenNamed(String name,
      String namespace) {
    ArrayList result = new ArrayList(this.children.size());
    Iterator enm = this.children.iterator();
    while (enm.hasNext()) {
      IXMLElement child = (IXMLElement) enm.next();
      String str = child.getName();
      boolean found = (str != null) && (str.equals(name));
      str = child.getNamespace();
      if (str == null) {
        found &= (name == null);
      } else {
        found &= str.equals(namespace);
      }
      
      if (found) {
        result.add(child);
      }
    }
    return result;
###
388, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 775, 782
27
/**
   * Returns an attribute by looking up a key in a hashtable.
   * If the attribute doesn't exist, the value corresponding to defaultKey
   * is returned.
   * <P>
   * As an example, if valueSet contains the mapping <code>"one" =&gt;
   * "1"</code>
   * and the element contains the attribute <code>attr="one"</code>, then
   * <code>getAttribute("attr", mapping, defaultKey, false)</code> returns
   * <code>"1"</code>.
   *
   * @param name
   *   The name of the attribute.
   * @param namespace the namespace URI, which may be null.
   * @param valueSet
   *   HashMap mapping keySet().iterator to values.
   * @param defaultKey
   *   Key to use if the attribute is missing.
   *
   * </dl><dl><dt><b>Preconditions:</b></dt><dd>
   * <ul><li><code>name != null</code>
   *   <li><code>name</code> is a valid XML identifier
   *   <li><code>valueSet</code> != null
   *   <li>the keySet().iterator of <code>valueSet</code> are strings
   * </ul></dd></dl><dl>
   *
   */
8
  public Object getAttribute(String name, String namespace,
      Map valueSet,
      String  defaultKey) {
    String key = this.getAttribute(name, namespace, null);
    if (key == null || ! valueSet.containsKey(key)) {
      return valueSet.get(defaultKey);
    }
    return valueSet.get(key);
###
389, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 650, 651
9
/**
   * @deprecated As of NanoXML/Java 2.1, replaced by
   *       {@link #getAttribute(java.lang.String,java.lang.String)}
   * Returns the value of an attribute.
   *
   * @param name the non-null name of the attribute.
   *
   * @return the value, or null if the attribute does not exist.
   */
2
  public String getAttribute(String name) {
    return this.getAttribute(name, null);
###
390, removeAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 901, 914
6
/**
   * Removes an attribute.
   *
   * @param name the non-null name of the attribute.
   * @param namespace the namespace URI of the attribute, which may be null.
   */
14
  public void removeAttribute(String name,
      String namespace) {
    for (int i = 0; i < this.attributes.size(); i++) {
      XMLAttribute attr = (XMLAttribute) this.attributes.get(i);
      boolean found = attr.getName().equals(name);
      if (namespace == null) {
        found &= (attr.getNamespace() == null);
      } else {
        found &= attr.getNamespace().equals(namespace);
      }
      
      if (found) {
        this.attributes.remove(i);
        return;
###
391, setContent, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1043, 1044
6
/**
   * Sets the #PCDATA content. It is an error to call this method with a
   * non-null value if there are child objects.
   *
   * @param content the (possibly null) content.
   */
2
  public void setContent(String content) {
    this.content = content;
###
392, getSystemID, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1006, 1007
7
/**
   * Returns the system ID of the data where the element started.
   *
   * @return the system ID, or null if unknown.
   *
   * @see #getLineNr
   */
2
  public String getSystemID() {
    return this.systemID;
###
393, getAttributeType, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 793, 798
7
/**
   * Returns the type of an attribute.
   *
   * @param name the non-null full name of the attribute.
   *
   * @return the type, or null if the attribute does not exist.
   */
6
  public String getAttributeType(String name) {
    XMLAttribute attr = this.findAttribute(name);
    if (attr == null) {
      return null;
    } else {
      return attr.getType();
###
395, getChildAtIndex, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 479, 481
10
/**
   * Returns the child at a specific index.
   *
   * @param index the index of the child
   *
   * @return the non-null child
   *
   * @throws java.lang.ArrayIndexOutOfBoundsException
   *    if the index is out of bounds.
   */
3
  public IXMLElement getChildAtIndex(int index)
  throws ArrayIndexOutOfBoundsException {
    return (IXMLElement) this.children.get(index);
###
396, iterateChildren, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 424, 425
5
/**
   * Returns an enumeration of all child iterator.
   *
   * @return the non-null enumeration
   */
2
  public Iterator iterateChildren() {
    return this.children.iterator();
###
397, setName, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 323, 326
6
/**
   * Sets the full name. This method also sets the short name and clears the
   * namespace URI.
   *
   * @param name the non-null name.
   */
4
  public void setName(String name) {
    this.name = name;
    this.fullName = name;
    this.namespace = null;
###
398, insertChild, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 378, 392
6
/**
   * Inserts a child element.
   *
   * @param child the non-null child to add.
   * @param index where to put the child.
   */
15
  public void insertChild(IXMLElement child,
      int     index) {
    if (child == null) {
      throw new IllegalArgumentException("child must not be null");
    }
    if ((child.getName() == null) && (! this.children.isEmpty())) {
      IXMLElement lastChild = (IXMLElement) this.children.get(this.children.size() - 1);
      if (lastChild.getName() == null) {
        lastChild.setContent(lastChild.getContent()
        + child.getContent());
        return;
      }
    }
    ((XMLElement) child).parent = this;
    this.children.add(index, child);
###
399, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 663, 669
8
/**
   * Returns the value of an attribute.
   *
   * @param name the non-null full name of the attribute.
   * @param defaultValue the default value of the attribute.
   *
   * @return the value, or defaultValue if the attribute does not exist.
   */
7
  public String getAttribute(String name,
      String defaultValue) {
    XMLAttribute attr = this.findAttribute(name);
    if (attr == null) {
      return defaultValue;
    } else {
      return attr.getValue();
###
400, createMenuBar, SDIApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/SDIApplication.java, 249, 319
3
/**
   * Creates a menu bar.
   */
67
  protected JMenuBar createMenuBar(View v) {
    JMenuBar mb = new JMenuBar();
    // Get menus from application model
    JMenu fileMenu = null;
    JMenu editMenu = null;
    JMenu helpMenu = null;
    JMenu viewMenu = null;
    JMenu windowMenu = null;
    String fileMenuText = labels.getString("file.text");
    String editMenuText = labels.getString("edit.text");
    String viewMenuText = labels.getString("view.text");
    String windowMenuText = labels.getString("window.text");
    String helpMenuText = labels.getString("help.text");
    for (JMenu mm : getModel().createMenus(this, v)) {
      String text = mm.getText();
      if (text == null) {
      } else if (text.equals(fileMenuText)) {
        fileMenu = mm;
        continue;
      } else if (text.equals(editMenuText)) {
        editMenu = mm;
        continue;
      } else if (text.equals(viewMenuText)) {
        viewMenu = mm;
        continue;
      } else if (text.equals(windowMenuText)) {
        windowMenu = mm;
        continue;
      } else if (text.equals(helpMenuText)) {
        helpMenu = mm;
        continue;
      }
      mb.add(mm);
    }
    // Create missing standard menus
    if (fileMenu == null) {
      fileMenu = createFileMenu(v);
    }
    if (editMenu == null) {
      editMenu = createEditMenu(v);
    }
    if (viewMenu == null) {
      viewMenu = createViewMenu(v);
    }
    if (windowMenu == null) {
      windowMenu = createWindowMenu(v);
    }
    if (helpMenu == null) {
      helpMenu = createHelpMenu(v);
    }
    // Insert standard menus into menu bar
    if (fileMenu != null) {
      mb.add(fileMenu, 0);
    }
    if (editMenu != null) {
      mb.add(editMenu, Math.min(1, mb.getComponentCount()));
    }
    if (viewMenu != null) {
      mb.add(viewMenu, Math.min(2, mb.getComponentCount()));
    }
    if (windowMenu != null) {
      mb.add(windowMenu);
    }
    if (helpMenu != null) {
      mb.add(helpMenu);
    }
    return mb;
###
401, iterateAttributeNames, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 925, 932
5
/**
   * Returns an enumeration of all attribute names.
   *
   * @return the non-null enumeration.
   */
8
  public Iterator iterateAttributeNames() {
    ArrayList result = new ArrayList();
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      result.add(attr.getFullName());
    }
    return result.iterator();
###
402, updateViewTitle, SDIApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/SDIApplication.java, 390, 402
6
/**
   * Updates the title of a view and displays it in the given frame.
   * 
   * @param view The view.
   * @param f The frame.
   */
13
  protected void updateViewTitle(View view, JFrame f) {
    URI uri = view.getURI();
    String title;
    if (uri == null) {
      title = labels.getString("unnamedFile");
    } else {
      title = URIUtil.getName(uri);
    }
    if (view.hasUnsavedChanges()) {
      title += "*";
    }
    view.setTitle(labels.getFormatted("frame.title", title, getName(), view.getMultipleOpenId()));
    f.setTitle(view.getTitle());
###
403, setAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 864, 874
7
/**
   * Sets an attribute.
   *
   * @param fullName the non-null full name of the attribute.
   * @param namespace the namespace URI of the attribute, which may be null.
   * @param value the non-null value of the attribute.
   */
11
  public void setAttribute(String fullName,
      String namespace,
      String value) {
    int index = fullName.indexOf(':');
    String name = fullName.substring(index + 1);
    XMLAttribute attr = this.findAttribute(name, namespace);
    if (attr == null) {
      attr = new XMLAttribute(fullName, name, namespace, value, "CDATA");
      this.attributes.add(attr);
    } else {
      attr.setValue(value);
###
404, wrapViewComponent, SDIApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/SDIApplication.java, 209, 226
4
/**
   * Returns the view component. Eventually wraps it into
   * another component in order to provide additional functionality.
   */
17
  protected Component wrapViewComponent(View p) {
    JComponent c = p.getComponent();
    if (getModel() != null) {
      LinkedList<Action> toolBarActions = new LinkedList<Action>();
      int id = 0;
      for (JToolBar tb : new ReversedList<JToolBar>(getModel().createToolBars(this, p))) {
        id++;
        JPanel panel = new JPanel(new BorderLayout());
        panel.add(tb, BorderLayout.NORTH);
        panel.add(c, BorderLayout.CENTER);
        c = panel;
        PreferencesUtil.installToolBarPrefsHandler(prefs, "toolbar." + id, tb);
        toolBarActions.addFirst(new ToggleVisibleAction(tb, tb.getName()));
      }
      p.getComponent().putClientProperty("toolBarActions", toolBarActions);
    }
    return c;
###
405, stringReader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 97, 99
5
/**
  * Creates a new reader using a string as input.
  *
  * @param str the string containing the XML data
  */
3
   public static IXMLReader stringReader(String str)
   {
    return new StdXMLReader(new StringReader(str));
###
406, fileReader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 113, 125
10
/**
  * Creates a new reader using a file as input.
  *
  * @param filename the name of the file containing the XML data
  *
  * @throws java.io.FileNotFoundException
  *   if the file could not be found
  * @throws java.io.IOException
  *   if an I/O error occurred
  */
11
   public static IXMLReader fileReader(String filename)
    throws FileNotFoundException,
       IOException
   {
    StdXMLReader r = new StdXMLReader(new FileInputStream(filename));
    r.setSystemID(filename);
    for (int i = 0; i < r.readers.size(); i++) {
     StackedReader sr = (StackedReader) r.readers.elementAt(i);
     sr.systemId = r.currentReader.systemId;
    }
    return r;
###
407, getSystemID, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 613, 615
3
/**
  * Returns the current system ID.
  */
3
   public String getSystemID()
   {
    return this.currentReader.systemId.toString();
###
408, getLineNr, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 567, 579
3
/**
  * Returns the line number of the data in the current stream.
  */
11
   public int getLineNr()
   {
    if (this.currentReader.lineReader == null) {
     StackedReader sr = (StackedReader) this.readers.peek();
     if (sr.lineReader == null) {
      return 0;
     } else {
      return sr.lineReader.getLineNumber() + 1;
     }
    }
    return this.currentReader.lineReader.getLineNumber() + 1;
###
409, StdXMLReader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 346, 365
8
/**
  * Initializes the XML reader.
  *
  * @param stream the input for the XML data.
  *
  * @throws java.io.IOException
  *    if an I/O error occurred
  */
18
   public StdXMLReader(InputStream stream)
    throws IOException
   {
    PushbackInputStream pbstream = new PushbackInputStream(stream);
    StringBuffer charsRead = new StringBuffer();
    Reader reader = this.stream2reader(stream, charsRead);
    this.currentReader = new StackedReader();
    this.readers = new Stack();
    this.currentReader.lineReader = new LineNumberReader(reader);
    this.currentReader.pbReader
     = new PushbackReader(this.currentReader.lineReader, 2);
    this.currentReader.publicId = "";
    try {
     this.currentReader.systemId = new URL("file:.");
    } catch (MalformedURLException e) {
     // never happens
    }
    this.startNewStream(new StringReader(charsRead.toString()));
###
410, getEncoding, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 216, 270
7
/**
  * Scans the encoding from an &lt;?xml...?&gt; tag.
  *
  * @param str the first tag in the XML data.
  *
  * @return the encoding, or null if no encoding has been specified.
  */
42
   protected String getEncoding(String str)
   {
    if (! str.startsWith("<?xml")) {
     return null;
    }
    int index = 5;
    while (index < str.length()) {
     StringBuffer key = new StringBuffer();
     while ((index < str.length()) && (str.charAt(index) <= ' ')) {
      index++;
     }
     while ((index < str.length())
        && (str.charAt(index) >= 'a')
        && (str.charAt(index) <= 'z')) {
      key.append(str.charAt(index));
      index++;
     }
     while ((index < str.length()) && (str.charAt(index) <= ' ')) {
      index++;
     }
     if ((index >= str.length()) || (str.charAt(index) != '=')) {
      break;
     }
     while ((index < str.length()) && (str.charAt(index) != '\'')
        && (str.charAt(index) != '"')) {
      index++;
     }
     if (index >= str.length()) {
      break;
     }
     char delimiter = str.charAt(index);
     index++;
     int index2 = str.indexOf(delimiter, index);
     if (index2 < 0) {
      break;
     }
     if (key.toString().equals("encoding")) {
      return str.substring(index, index2);
     }
     index = index2 + 1;
    }
    return null;
###
411, startNewStream, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 519, 521
7
/**
  * Starts a new stream from a Java reader. The new stream is used
  * temporary to read data from. If that stream is exhausted, control
  * returns to the parent stream.
  *
  * @param reader the non-null reader to read the new data from
  */
3
   public void startNewStream(Reader reader)
   {
    this.startNewStream(reader, false);
###
412, unread, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 451, 454
8
/**
  * Pushes the last character read back to the stream.
  *
  * @param ch the character to push back.
  *
  * @throws java.io.IOException
  *   if an I/O error occurred
  */
4
   public void unread(char ch)
    throws IOException
   {
    this.currentReader.pbReader.unread(ch);
###
413, setPublicID, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 604, 606
5
/**
  * Sets the public ID of the current stream.
  *
  * @param publicID the public ID
  */
3
   public void setPublicID(String publicID)
   {
    this.currentReader.publicId = publicID;
###
414, stream2reader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 283, 333
9
/**
  * Converts a stream to a reader while detecting the encoding.
  *
  * @param stream  the input for the XML data.
  * @param charsRead buffer where to put characters that have been read
  *
  * @throws java.io.IOException
  *   if an I/O error occurred
  */
40
   protected Reader stream2reader(InputStream  stream,
                  StringBuffer charsRead)
    throws IOException
   {
    PushbackInputStream pbstream = new PushbackInputStream(stream);
    int b = pbstream.read();
    switch (b) {
     case 0x00:
     case 0xFE:
     case 0xFF:
      pbstream.unread(b);
      return new InputStreamReader(pbstream, "UTF-16");
     case 0xEF:
      for (int i = 0; i < 2; i++) {
         pbstream.read();
      }
      return new InputStreamReader(pbstream, "UTF-8");
     case 0x3C:
      b = pbstream.read();
      charsRead.append('<');
      while ((b > 0) && (b != 0x3E)) {
         charsRead.append((char) b);
         b = pbstream.read();
      }
      if (b > 0) {
         charsRead.append((char) b);
      }
      String encoding = this.getEncoding(charsRead.toString());
      if (encoding == null) {
         return new InputStreamReader(pbstream, "UTF-8");
      }
      charsRead.setLength(0);
      try {
         return new InputStreamReader(pbstream, encoding);
      } catch (UnsupportedEncodingException e) {
         return new InputStreamReader(pbstream, "UTF-8");
      }
      default:
         charsRead.append((char) b);
         return new InputStreamReader(pbstream, "UTF-8");
###
415, openStream, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 471, 508
13
/**
  * Opens a stream from a public and system ID.
  *
  * @param publicID the public ID, which may be null
  * @param systemID the system ID, which is never null
  *
  * @throws java.net.MalformedURLException
  *   if the system ID does not contain a valid URL
  * @throws java.io.FileNotFoundException
  *   if the system ID refers to a local file which does not exist
  * @throws java.io.IOException
  *   if an error occurred opening the stream
  */
31
   public Reader openStream(String publicID,
              String systemID)
    throws MalformedURLException,
       FileNotFoundException,
       IOException
   {
    URL url = new URL(this.currentReader.systemId, systemID);
    if (url.getRef() != null) {
     String ref = url.getRef();
     if (url.getFile().length() > 0) {
      url = new URL(url.getProtocol(), url.getHost(), url.getPort(),
              url.getFile());
      url = new URL("jar:" + url + '!' + ref);
     } else {
      url = StdXMLReader.class.getResource(ref);
     }
    }
    this.currentReader.publicId = publicID;
    this.currentReader.systemId = url;
    StringBuffer charsRead = new StringBuffer();
    Reader reader = this.stream2reader(url.openStream(), charsRead);
    if (charsRead.length() == 0) {
     return reader;
    }
    String charsReadStr = charsRead.toString();
    PushbackReader pbreader = new PushbackReader(reader,
                           charsReadStr.length());
    for (int i = charsReadStr.length() - 1; i >= 0; i--) {
     pbreader.unread(charsReadStr.charAt(i));
    }
    return pbreader;
###
416, read, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 377, 392
8
/**
  * Reads a character.
  *
  * @return the character
  *
  * @throws java.io.IOException
  *    if no character could be read
  */
13
   public char read()
    throws IOException
   {
    int ch = this.currentReader.pbReader.read();
    while (ch < 0) {
     if (this.readers.empty()) {
      throw new IOException("Unexpected EOF");
     }
     this.currentReader.pbReader.close();
     this.currentReader = (StackedReader) this.readers.pop();
     ch = this.currentReader.pbReader.read();
    }
    return (char) ch;
###
417, StdXMLReader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 176, 187
5
/**
  * Initializes the XML reader.
  *
  * @param reader the input for the XML data.
  */
11
   public StdXMLReader(Reader reader)
   {
    this.currentReader = new StackedReader();
    this.readers = new Stack();
    this.currentReader.lineReader = new LineNumberReader(reader);
    this.currentReader.pbReader
     = new PushbackReader(this.currentReader.lineReader, 2);
    this.currentReader.publicId = "";
    try {
     this.currentReader.systemId = new URL("file:.");
    } catch (MalformedURLException e) {
###
418, atEOF, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 423, 439
6
/**
  * Returns true if there are no more characters left to be read.
  *
  * @throws java.io.IOException
  *    if an I/O error occurred
  */
14
   public boolean atEOF()
    throws IOException
   {
    int ch = this.currentReader.pbReader.read();
    while (ch < 0) {
     if (this.readers.empty()) {
      return true;
     }
     this.currentReader.pbReader.close();
     this.currentReader = (StackedReader) this.readers.pop();
     ch = this.currentReader.pbReader.read();
    }
    this.currentReader.pbReader.unread(ch);
    return false;
###
419, atEOFOfCurrentStream, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 403, 412
7
/**
  * Returns true if the current stream has no more characters left to be
  * read.
  *
  * @throws java.io.IOException
  *    if an I/O error occurred
  */
9
   public boolean atEOFOfCurrentStream()
    throws IOException
   {
    int ch = this.currentReader.pbReader.read();
    if (ch < 0) {
     return true;
    } else {
     this.currentReader.pbReader.unread(ch);
     return false;
###
420, StdXMLReader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 142, 167
13
/**
  * Initializes the reader from a system and public ID.
  *
  * @param publicID the public ID which may be null.
  * @param systemID the non-null system ID.
  *
  * @throws MalformedURLException
  *   if the system ID does not contain a valid URL
  * @throws FileNotFoundException
  *   if the system ID refers to a local file which does not exist
  * @throws IOException
  *   if an error occurred opening the stream
  */
23
   public StdXMLReader(String publicID,
             String systemID)
    throws MalformedURLException,
       FileNotFoundException,
       IOException
   {
    URL systemIDasURL = null;
    try {
     systemIDasURL = new URL(systemID);
    } catch (MalformedURLException e) {
     systemID = "file:" + systemID;
     try {
      systemIDasURL = new URL(systemID);
     } catch (MalformedURLException e2) {
      throw e;
     }
    }
    this.currentReader = new StackedReader();
    this.readers = new Stack();
    Reader reader = this.openStream(publicID, systemIDasURL.toString());
    this.currentReader.lineReader = new LineNumberReader(reader);
    this.currentReader.pbReader
     = new PushbackReader(this.currentReader.lineReader, 2);
###
421, setSystemID, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 591, 595
8
/**
  * Sets the system ID of the current stream.
  *
  * @param systemID the system ID
  *
  * @throws java.net.MalformedURLException
  *   if the system ID does not contain a valid URL
  */
5
   public void setSystemID(String systemID)
    throws MalformedURLException
   {
    this.currentReader.systemId = new URL(this.currentReader.systemId,
                      systemID);
###
422, finalize, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 196, 205
3
/**
  * Cleans up the object when it's destroyed.
  */
10
   protected void finalize()
    throws Throwable
   {
    this.currentReader.lineReader = null;
    this.currentReader.pbReader = null;
    this.currentReader.systemId = null;
    this.currentReader.publicId = null;
    this.currentReader = null;
    this.readers.clear();
    super.finalize();
###
423, getStreamLevel, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 558, 560
3
/**
  * Returns the current "level" of the stream on the stack of streams.
  */
3
   public int getStreamLevel()
   {
    return this.readers.size();
###
424, startNewStream, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 534, 551
9
/**
  * Starts a new stream from a Java reader. The new stream is used
  * temporary to read data from. If that stream is exhausted, control
  * returns to the parent stream.
  *
  * @param reader the non-null reader to read the new data from
  * @param isInternalEntity true if the reader is produced by resolving
  *             an internal entity
  */
16
   public void startNewStream(Reader  reader,
                boolean isInternalEntity)
   {
    StackedReader oldReader = this.currentReader;
    this.readers.push(this.currentReader);
    this.currentReader = new StackedReader();
    if (isInternalEntity) {
     this.currentReader.lineReader = null;
     this.currentReader.pbReader = new PushbackReader(reader, 2);
    } else {
     this.currentReader.lineReader = new LineNumberReader(reader);
     this.currentReader.pbReader
      = new PushbackReader(this.currentReader.lineReader, 2);
    }
    this.currentReader.systemId = oldReader.systemId;
    this.currentReader.publicId = oldReader.publicId;
###
426, invalidAttributeValue, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 345, 353
13
/**
  * Throws an XMLValidationException to indicate that an attribute has an
  * invalid value.
  *
  * @param systemID     the system ID of the XML data of the element
  * @param lineNr     the line number in the XML data of the element
  * @param elementName  the name of the element
  * @param attributeName  the name of the attribute
  * @param attributeValue the value of the attribute
  *
  * @throws net.n3.nanoxml.XMLValidationException
  *    of course :-)
  */
9
   public void invalidAttributeValue(String systemID,
                   int  lineNr,
                   String elementName,
                   String attributeName,
                   String attributeValue)
    throws XMLValidationException
   {
    XMLUtil.errorInvalidAttributeValue(systemID, lineNr, elementName,
                     attributeName, attributeValue);
###
430, getDelegate, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 77, 79
3
/**
  * Returns the delegate.
  */
3
   public IXMLValidator getDelegate()
   {
    return this.delegate;
###
432, setParameterEntityResolver, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 99, 101
5
/**
  * Sets the parameter entity resolver.
  *
  * @param resolver the entity resolver.
  */
3
   public void setParameterEntityResolver(IXMLEntityResolver resolver)
   {
    this.delegate.setParameterEntityResolver(resolver);
###
433, getParameterEntityResolver, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 110, 112
5
/**
  * Returns the parameter entity resolver.
  *
  * @return the entity resolver.
  */
3
   public IXMLEntityResolver getParameterEntityResolver()
   {
    return this.delegate.getParameterEntityResolver();
###
434, ValidatorPlugin, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 57, 59
3
/**
  * Initializes the plugin.
  */
3
   public ValidatorPlugin()
   {
    this.delegate = null;
###
438, finalize, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 66, 70
3
/**
  * Cleans up the object when it's destroyed.
  */
5
   protected void finalize()
    throws Throwable
   {
    this.delegate = null;
    super.finalize();
###
439, setDelegate, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 88, 90
5
/**
  * Sets the delegate.
  *
  * @param delegate the delegate
  */
3
   public void setDelegate(IXMLValidator delegate)
   {
    this.delegate = delegate;
###
440, unexpectedAttribute, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 321, 328
12
/**
  * Throws an XMLValidationException to indicate that an attribute is
  * unexpected.
  *
  * @param systemID    the system ID of the XML data of the element
  * @param lineNr    the line number in the XML data of the element
  * @param elementName   the name of the element
  * @param attributeName the name of the unexpected attribute
  *
  * @throws net.n3.nanoxml.XMLValidationException
  *    of course :-)
  */
8
   public void unexpectedAttribute(String systemID,
                   int  lineNr,
                   String elementName,
                   String attributeName)
    throws XMLValidationException
   {
    XMLUtil.errorUnexpectedAttribute(systemID, lineNr, elementName,
                     attributeName);
###
441, parseDTD, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 128, 134
12
/**
  * Parses the DTD. The validator object is responsible for reading the
  * full DTD.
  *
  * @param publicID     the public ID, which may be null.
  * @param reader     the reader to read the DTD from.
  * @param entityResolver the entity resolver.
  * @param external     true if the DTD is external.
  *
  * @throws java.lang.Exception
  *   if something went wrong.
  */
7
   public void parseDTD(String       publicID,
            IXMLReader     reader,
            IXMLEntityResolver entityResolver,
            boolean      external)
    throws Exception
   {
    this.delegate.parseDTD(publicID, reader, entityResolver, external);
###
444, StdXMLBuilder, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 72, 74
3
/**
  * Creates the builder.
  */
3
   public StdXMLBuilder()
   {
    this(new XMLElement());
###
445, StdXMLBuilder, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 83, 87
5
/**
  * Creates the builder.
  *
  * @param prototype the prototype to use when building the tree.
  */
5
   public StdXMLBuilder(IXMLElement prototype)
   {
    this.stack = null;
    this.root = null;
    this.prototype = prototype;
###
447, addPCData, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 282, 318
12
/**
  * This method is called when a PCDATA element is encountered. A Java
  * reader is supplied from which you can read the data. The reader will
  * only read the data of the element. You don't need to check for
  * boundaries. If you don't read the full element, the rest of the data
  * is skipped. You also don't have to care about entities; they are
  * resolved by the parser.
  *
  * @param reader   the Java reader from which you can retrieve the data.
  * @param systemID the system ID of the XML data source.
  * @param lineNr   the line in the source where the element starts.
  */
30
   public void addPCData(Reader reader,
             String systemID,
             int  lineNr)
   {
    int bufSize = 2048;
    int sizeRead = 0;
    StringBuffer str = new StringBuffer(bufSize);
    char[] buf = new char[bufSize];
    for (;;) {
     if (sizeRead >= bufSize) {
      bufSize *= 2;
      str.ensureCapacity(bufSize);
     }
     int size;
     try {
      size = reader.read(buf);
     } catch (IOException e) {
      break;
     }
     if (size < 0) {
      break;
     }
     str.append(buf, 0, size);
     sizeRead += size;
    }
    IXMLElement elt = this.prototype.createElement(null, systemID, lineNr);
    elt.setContent(str.toString());
    if (! this.stack.empty()) {
     IXMLElement top = (IXMLElement) this.stack.peek();
     top.addChild(elt);
###
448, finalize, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 94, 101
3
/**
  * Cleans up the object when it's destroyed.
  */
8
   protected void finalize()
    throws Throwable
   {
    this.prototype = null;
    this.root = null;
    this.stack.clear();
    this.stack = null;
    super.finalize();
###
449, addAttribute, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 241, 265
17
/**
  * This method is called when a new attribute of an XML element is
  * encountered.
  *
  * @param key    the key (name) of the attribute.
  * @param nsPrefix   the prefix used to identify the namespace. If no
  *           namespace has been specified, this parameter is null.
  * @param nsURI    the URI associated with the namespace. If no
  *           namespace has been specified, or no URI is
  *           associated with nsPrefix, this parameter is null.
  * @param value    the value of the attribute.
  * @param type     the type of the attribute. If no type is known,
  *           "CDATA" is returned.
  *
  * @throws java.lang.Exception
  *   If an exception occurred while processing the event.
  */
21
   public void addAttribute(String key,
              String nsPrefix,
              String nsURI,
              String value,
              String type)
    throws Exception
   {
    String fullName = key;
    if (nsPrefix != null) {
     fullName = nsPrefix + ':' + key;
    }
    IXMLElement top = (IXMLElement) this.stack.peek();
    if (top.hasAttribute(fullName)) {
     throw new XMLParseException(top.getSystemID(),
                   top.getLineNr(),
                   "Duplicate attribute: " + key);
    }
    if (nsPrefix != null) {
     top.setAttribute(fullName, nsURI, value);
    } else {
     top.setAttribute(fullName, value);
###
450, endElement, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 207, 218
15
/**
  * This method is called when the end of an XML elemnt is encountered.
  *
  * @see #startElement
  *
  * @param name     the name of the element.
  * @param nsPrefix   the prefix used to identify the namespace. If no
  *           namespace has been specified, this parameter is null.
  * @param nsURI    the URI associated with the namespace. If no
  *           namespace has been specified, or no URI is
  *           associated with nsPrefix, this parameter is null.
  */
 --------------
// nothing to do
 --------------
10
   public void endElement(String name,
              String nsPrefix,
              String nsURI)
   {
    IXMLElement elt = (IXMLElement) this.stack.pop();
    if (elt.getChildrenCount() == 1) {
     IXMLElement child = elt.getChildAtIndex(0);
     if (child.getName() == null) {
      elt.setContent(child.getContent());
      elt.removeChildAtIndex(0);
###
451, startBuilding, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 111, 115
6
/**
  * This method is called before the parser starts processing its input.
  *
  * @param systemID the system ID of the XML data source.
  * @param lineNr   the line on which the parsing starts.
  */
5
   public void startBuilding(String systemID,
               int  lineNr)
   {
    this.stack = new Stack();
    this.root = null;
###
452, startElement, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 147, 169
14
/**
  * This method is called when a new XML element is encountered.
  *
  * @see #endElement
  *
  * @param name   the name of the element.
  * @param nsPrefix   the prefix used to identify the namespace. If no
  *       namespace has been specified, this parameter is null.
  * @param nsURI  the URI associated with the namespace. If no
  *       namespace has been specified, or no URI is
  *       associated with nsPrefix, this parameter is null.
  * @param systemID   the system ID of the XML data source.
  * @param lineNr   the line in the source where the element starts.
  */
19
   public void startElement(String name,
              String nsPrefix,
              String nsURI,
              String systemID,
              int  lineNr)
   {
    String fullName = name;
    if (nsPrefix != null) {
     fullName = nsPrefix + ':' + name;
    }
    IXMLElement elt = this.prototype.createElement(fullName, nsURI,
                           systemID, lineNr);
    if (this.stack.empty()) {
     this.root = elt;
    } else {
     IXMLElement top = (IXMLElement) this.stack.peek();
     top.addChild(elt);
    }
    this.stack.push(elt);
###
454, setReader, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 173, 175
5
/**
  * Sets the reader from which the parser retrieves its data.
  *
  * @param reader the reader
  */
3
   public void setReader(IXMLReader reader)
   {
    this.reader = reader;
###
455, setValidator, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 129, 131
5
/**
  * Sets the validator that validates the XML data.
  *
  * @param validator the non-null validator
  */
3
   public void setValidator(IXMLValidator validator)
   {
    this.validator = validator;
###
456, setResolver, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 151, 153
5
/**
  * Sets the entity resolver.
  *
  * @param resolver the non-null resolver
  */
3
   public void setResolver(IXMLEntityResolver resolver)
   {
    this.entityResolver = resolver;
###
457, scanSomeTag, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 269, 294
10
/**
  * Scans an XML tag.
  *
  * @param allowCDATA true if CDATA sections are allowed at this point
  * @param defaultNamespace the default namespace URI (or null)
  * @param namespaces list of defined namespaces
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
22
   protected void scanSomeTag(boolean  allowCDATA,
                String   defaultNamespace,
                Properties namespaces)
    throws Exception
   {
    String str = XMLUtil.read(this.reader, '&');
    char ch = str.charAt(0);
    if (ch == '&') {
     XMLUtil.errorUnexpectedEntity(reader.getSystemID(),
                     reader.getLineNr(),
                     str);
    }
    switch (ch) {
     case '?':
      this.processPI();
      break;
     case '!':
      this.processSpecialTag(allowCDATA);
      break;
     default:
      this.reader.unread(ch);
      this.processElement(defaultNamespace, namespaces);
###
458, processElement, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 461, 655
12
/**
  * Processes a regular element.
  *
  * @param defaultNamespace the default namespace URI (or null)
  * @param namespaces list of defined namespaces
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
 --------------
// END PATCH W. Randelshofer Don't read DTD
 --------------
165
   protected void processElement(String   defaultNamespace,
                 Properties namespaces)
    throws Exception
   {
    String fullName = XMLUtil.scanIdentifier(this.reader);
    String name = fullName;
    XMLUtil.skipWhitespace(this.reader, null);
    String prefix = null;
    int colonIndex = name.indexOf(':');
    if (colonIndex > 0) {
     prefix = name.substring(0, colonIndex);
     name = name.substring(colonIndex + 1);
    }
    Vector attrNames = new Vector();
    Vector attrValues = new Vector();
    Vector attrTypes = new Vector();
    this.validator.elementStarted(fullName,
                  this.reader.getSystemID(),
                  this.reader.getLineNr());
    char ch;
    for (;;) {
     ch = this.reader.read();
     if ((ch == '/') || (ch == '>')) {
      break;
     }
     this.reader.unread(ch);
     this.processAttribute(attrNames, attrValues, attrTypes);
     XMLUtil.skipWhitespace(this.reader, null);
    }
    Properties extraAttributes = new Properties();
    this.validator.elementAttributesProcessed(fullName,
                        extraAttributes,
                        this.reader.getSystemID(),
                        this.reader.getLineNr());
    Enumeration enm = extraAttributes.keys();
    while (enm.hasMoreElements()) {
     String key = (String) enm.nextElement();
     String value = extraAttributes.getProperty(key);
     attrNames.addElement(key);
     attrValues.addElement(value);
     attrTypes.addElement("CDATA");
    }
    for (int i = 0; i < attrNames.size(); i++) {
     String key = (String) attrNames.elementAt(i);
     String value = (String) attrValues.elementAt(i);
     String type = (String) attrTypes.elementAt(i);
     if (key.equals("xmlns")) {
      defaultNamespace = value;
     } else if (key.startsWith("xmlns:")) {
      namespaces.put(key.substring(6), value);
     }
    }
    if (prefix == null) {
     this.builder.startElement(name, prefix, defaultNamespace,
                   this.reader.getSystemID(),
                   this.reader.getLineNr());
    } else {
     this.builder.startElement(name, prefix,
                   namespaces.getProperty(prefix),
                   this.reader.getSystemID(),
                   this.reader.getLineNr());
    }
    for (int i = 0; i < attrNames.size(); i++) {
     String key = (String) attrNames.elementAt(i);
     if (key.startsWith("xmlns")) {
      continue;
     }
     String value = (String) attrValues.elementAt(i);
     String type = (String) attrTypes.elementAt(i);
     colonIndex = key.indexOf(':');
     if (colonIndex > 0) {
      String attPrefix = key.substring(0, colonIndex);
      key = key.substring(colonIndex + 1);
      this.builder.addAttribute(key, attPrefix,
                    namespaces.getProperty(attPrefix),
                    value, type);
     } else {
      this.builder.addAttribute(key, null, null, value, type);
     }
    }
    if (prefix == null) {
     this.builder.elementAttributesProcessed(name, prefix,
                         defaultNamespace);
    } else {
     this.builder.elementAttributesProcessed(name, prefix,
                         namespaces
                           .getProperty(prefix));
    }
    if (ch == '/') {
     if (this.reader.read() != '>') {
      XMLUtil.errorExpectedInput(reader.getSystemID(),
                     reader.getLineNr(),
                     "`>'");
     }
     this.validator.elementEnded(name,
                   this.reader.getSystemID(),
                   this.reader.getLineNr());
     if (prefix == null) {
      this.builder.endElement(name, prefix, defaultNamespace);
     } else {
      this.builder.endElement(name, prefix,
                  namespaces.getProperty(prefix));
     }
     return;
    }
    StringBuffer buffer = new StringBuffer(16);
    for (;;) {
     buffer.setLength(0);
     String str;
     for (;;) {
      XMLUtil.skipWhitespace(this.reader, buffer);
      str = XMLUtil.read(this.reader, '&');
      if ((str.charAt(0) == '&') && (str.charAt(1) != '#')) {
         XMLUtil.processEntity(str, this.reader,
                   this.entityResolver);
      } else {
         break;
      }
     }
     if (str.charAt(0) == '<') {
      str = XMLUtil.read(this.reader, '\0');
      if (str.charAt(0) == '/') {
         XMLUtil.skipWhitespace(this.reader, null);
         str = XMLUtil.scanIdentifier(this.reader);
         if (! str.equals(fullName)) {
          XMLUtil.errorWrongClosingTag(reader.getSystemID(),
                         reader.getLineNr(),
                         name, str);
         }
         XMLUtil.skipWhitespace(this.reader, null);
         if (this.reader.read() != '>') {
          XMLUtil.errorClosingTagNotEmpty(reader.getSystemID(),
                          reader.getLineNr());
         }
         this.validator.elementEnded(fullName,
                       this.reader.getSystemID(),
                       this.reader.getLineNr());
         if (prefix == null) {
           this.builder.endElement(name, prefix, defaultNamespace);
         } else {
           this.builder.endElement(name, prefix,
                       namespaces.getProperty(prefix));
         }
         break;
      } else { // <[^/]
         this.reader.unread(str.charAt(0));
         this.scanSomeTag(true, //CDATA allowed
                defaultNamespace,
                (Properties) namespaces.clone());
      }
     } else { // [^<]
      if (str.charAt(0) == '&') {
         ch = XMLUtil.processCharLiteral(str);
         buffer.append(ch);
      } else {
         reader.unread(str.charAt(0));
      }
      this.validator.PCDataAdded(this.reader.getSystemID(),
                     this.reader.getLineNr());
      Reader r = new ContentReader(this.reader,
                     this.entityResolver,
                     buffer.toString());
      this.builder.addPCData(r, this.reader.getSystemID(),
                   this.reader.getLineNr());
      r.close();
###
459, getResolver, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 162, 164
5
/**
  * Returns the entity resolver.
  *
  * @return the non-null resolver
  */
3
   public IXMLEntityResolver getResolver()
   {
    return this.entityResolver;
###
460, finalize, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 91, 98
3
/**
  * Cleans up the object when it's destroyed.
  */
8
   protected void finalize()
    throws Throwable
   {
    this.builder = null;
    this.reader = null;
    this.entityResolver = null;
    this.validator = null;
    super.finalize();
###
461, processDocType, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 393, 445
6
/**
  * Processes a document type declaration.
  *
  * @throws java.lang.Exception
  *    if an error occurred reading or parsing the data
  */
49
   protected void processDocType()
    throws Exception
   {
    if (! XMLUtil.checkLiteral(this.reader, "OCTYPE")) {
     XMLUtil.errorExpectedInput(reader.getSystemID(),
                  reader.getLineNr(),
                  "<!DOCTYPE");
     return;
    }
    XMLUtil.skipWhitespace(this.reader, null);
    String systemID = null;
    StringBuffer publicID = new StringBuffer();
    String rootElement = XMLUtil.scanIdentifier(this.reader);
    XMLUtil.skipWhitespace(this.reader, null);
    char ch = this.reader.read();
    if (ch == 'P') {
     systemID = XMLUtil.scanPublicID(publicID, reader);
     XMLUtil.skipWhitespace(this.reader, null);
     ch = this.reader.read();
    } else if (ch == 'S') {
     systemID = XMLUtil.scanSystemID(reader);
     XMLUtil.skipWhitespace(this.reader, null);
     ch = this.reader.read();
    }
    if (ch == '[') {
     this.validator.parseDTD(publicID.toString(),
                 this.reader,
                 this.entityResolver,
                 false);
     XMLUtil.skipWhitespace(this.reader, null);
     ch = this.reader.read();
    }
    if (ch != '>') {
     XMLUtil.errorExpectedInput(reader.getSystemID(),
                  reader.getLineNr(),
                  "`>'");
    }
// BEGIN PATCH W. Randelshofer Don't read DTD
  if (false) {
    if (systemID != null) {
     Reader reader = this.reader.openStream(publicID.toString(),
                        systemID);
     this.reader.startNewStream(reader);
     this.reader.setSystemID(systemID);
     this.reader.setPublicID(publicID.toString());
     this.validator.parseDTD(publicID.toString(),
                 this.reader,
                 this.entityResolver,
                 true);
###
462, StdXMLParser, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 79, 84
3
/**
  * Creates a new parser.
  */
6
   public StdXMLParser()
   {
    this.builder = null;
    this.validator = null;
    this.reader = null;
    this.entityResolver = new XMLEntityResolver();
###
463, scanData, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 223, 253
9
/**
  * Scans the XML data for elements.
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
 --------------
// throw new XMLException(e);
 --------------
28
   protected void scanData()
    throws Exception
   {
    while ((! this.reader.atEOF()) && (this.builder.getResult() == null)) {
     String str = XMLUtil.read(this.reader, '&');
     char ch = str.charAt(0);
     if (ch == '&') {
      XMLUtil.processEntity(str, this.reader, this.entityResolver);
      continue;
     }
     switch (ch) {
      case '<':
         this.scanSomeTag(false, // don't allow CDATA
                null,  // no default namespace
                new Properties());
         break;
      case ' ':
      case '\t':
      case '\r':
      case '\n':
         // skip whitespace
         break;
      default:
         XMLUtil.errorInvalidInput(reader.getSystemID(),
                     reader.getLineNr(),
                     "`" + ch + "' (0x"
                     + Integer.toHexString((int) ch)
                     + ')');
###
464, getValidator, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 140, 142
5
/**
  * Returns the validator that validates the XML data.
  *
  * @return the validator
  */
3
   public IXMLValidator getValidator()
   {
    return this.validator;
###
465, PasteAction, PasteAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/PasteAction.java, 46, 47
1
/** Creates a new instance which acts on the currently focused component. */
2
  public PasteAction() {
    this(null);
###
466, processCDATA, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 369, 383
6
/**
  * Processes a CDATA section.
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
14
   protected void processCDATA()
    throws Exception
   {
    if (! XMLUtil.checkLiteral(this.reader, "CDATA[")) {
     XMLUtil.errorExpectedInput(reader.getSystemID(),
                  reader.getLineNr(),
                  "<![[CDATA[");
    }
    this.validator.PCDataAdded(this.reader.getSystemID(),
                 this.reader.getLineNr());
    Reader reader = new CDATAReader(this.reader);
    this.builder.addPCData(reader, this.reader.getSystemID(),
               this.reader.getLineNr());
    reader.close();
###
467, processPI, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 305, 317
6
/**
  * Processes a "processing instruction".
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
11
   protected void processPI()
    throws Exception
   {
    XMLUtil.skipWhitespace(this.reader, null);
    String target = XMLUtil.scanIdentifier(this.reader);
    XMLUtil.skipWhitespace(this.reader, null);
    Reader reader = new PIReader(this.reader);
    if (! target.equalsIgnoreCase("xml")) {
     this.builder.newProcessingInstruction(target, reader);
    }
    reader.close();
###
468, parse, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 198, 211
8
/**
  * Parses the data and lets the builder create the logical data structure.
  *
  * @return the logical structure built by the builder
  *
  * @throws net.n3.nanoxml.XMLException
  *    if an error occurred reading or parsing the data
  */
14
   public Object parse()
    throws XMLException
   {
    try {
     this.builder.startBuilding(this.reader.getSystemID(),
                  this.reader.getLineNr());
     this.scanData();
     return this.builder.getResult();
    } catch (XMLException e) {
     throw e;
    } catch (Exception e) {
      XMLException error = new XMLException(e);
      error.initCause(e);
      throw error;
###
469, getReader, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 184, 186
5
/**
  * Returns the reader from which the parser retrieves its data.
  *
  * @return the reader
  */
3
   public IXMLReader getReader()
   {
    return this.reader;
###
470, getBuilder, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 118, 120
5
/**
  * Returns the builder which creates the logical structure of the XML data.
  *
  * @return the builder
  */
3
   public IXMLBuilder getBuilder()
   {
    return this.builder;
###
471, setBuilder, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 107, 109
5
/**
  * Sets the builder which creates the logical structure of the XML data.
  *
  * @param builder the non-null builder
  */
3
   public void setBuilder(IXMLBuilder builder)
   {
    this.builder = builder;
###
472, processSpecialTag, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 329, 358
8
/**
  * Processes a tag that starts with a bang (&lt;!...&gt;).
  *
  * @param allowCDATA true if CDATA sections are allowed at this point
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
25
   protected void processSpecialTag(boolean allowCDATA)
    throws Exception
   {
    String str = XMLUtil.read(this.reader, '&');
    char ch = str.charAt(0);
    if (ch == '&') {
     XMLUtil.errorUnexpectedEntity(reader.getSystemID(),
                     reader.getLineNr(),
                     str);
    }
    switch (ch) {
     case '[':
      if (allowCDATA) {
         this.processCDATA();
      } else {
         XMLUtil.errorUnexpectedCDATA(reader.getSystemID(),
                      reader.getLineNr());
      }
      return;
     case 'D':
      this.processDocType();
      return;
     case '-':
      XMLUtil.skipComment(this.reader);
      return;
###
473, installViewListeners, RedoAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/RedoAction.java, 87, 92
3
/**
   * Installs listeners on the view object.
   */
6
  @Override
  protected void installViewListeners(View p) {
    super.installViewListeners(p);
    Action redoActionInView = p.getActionMap().get(ID);
    if (redoActionInView != null && redoActionInView != this) {
      redoActionInView.addPropertyChangeListener(redoActionPropertyListener);
###
474, RedoAction, RedoAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/RedoAction.java, 58, 60
1
/** Creates a new instance. */
3
  public RedoAction(Application app, View view) {
    super(app, view);
    labels.configureAction(this, ID);
###
475, createDefaultXMLParser, XMLParserFactory, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLParserFactory.java, 71, 85
15
/**
   * Creates a default parser.
   *
   * @see #DEFAULT_CLASS
   * @see #CLASS_KEY
   *
   * @return the non-null parser.
   *
   * @throws java.lang.ClassNotFoundException
   *    if the class of the parser or validator could not be found.
   * @throws java.lang.InstantiationException
   *    if the parser could not be created
   * @throws java.lang.IllegalAccessException
   *    if the parser could not be created
   */
15
  public static IXMLParser createDefaultXMLParser()
  throws ClassNotFoundException,
      InstantiationException,
      IllegalAccessException {
    // BEGIN PATCH W. Randelshofer catch AccessControlException
    String className = XMLParserFactory.DEFAULT_CLASS;
    try {
      className = System.getProperty(XMLParserFactory.CLASS_KEY,
          XMLParserFactory.DEFAULT_CLASS);
    } catch (AccessControlException e) {
      // do nothing
    }
    // END PATCH W. Randelshofer catch AccessControlException
    return XMLParserFactory.createXMLParser(className,
        new StdXMLBuilder());
###
476, createDefaultXMLParser, XMLParserFactory, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLParserFactory.java, 106, 119
17
/**
   * Creates a default parser.
   *
   * @see #DEFAULT_CLASS
   * @see #CLASS_KEY
   *
   * @param builder the XML builder.
   *
   * @return the non-null parser.
   *
   * @throws java.lang.ClassNotFoundException
   *    if the class of the parser could not be found.
   * @throws java.lang.InstantiationException
   *    if the parser could not be created
   * @throws java.lang.IllegalAccessException
   *    if the parser could not be created
   */
14
  public static IXMLParser createDefaultXMLParser(IXMLBuilder builder)
  throws ClassNotFoundException,
      InstantiationException,
      IllegalAccessException {
    // BEGIN PATCH W. Randelshofer catch AccessControlException
    String className = XMLParserFactory.DEFAULT_CLASS;
    try {
     className = System.getProperty(XMLParserFactory.CLASS_KEY,
        XMLParserFactory.DEFAULT_CLASS);
     } catch (AccessControlException e) {
       // do nothing
     }
    // END PATCH W. Randelshofer catch AccessControlException
    return XMLParserFactory.createXMLParser(className, builder);
###
477, installViewListeners, UndoAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/UndoAction.java, 83, 87
3
/**
   * Installs listeners on the view object.
   */
5
  @Override protected void installViewListeners(View p) {
    super.installViewListeners(p);
    Action undoActionInView = p.getActionMap().get(ID);
    if (undoActionInView != null && undoActionInView != this) {
    undoActionInView.addPropertyChangeListener(redoActionPropertyListener);
###
478, XMLAttribute, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 82, 92
9
/**
  * Creates a new attribute.
  *
  * @param fullName  the non-null full name
  * @param name    the non-null short name
  * @param namespace the namespace URI, which may be null
  * @param value   the value of the attribute
  * @param type    the type of the attribute
  */
11
   XMLAttribute(String fullName,
        String name,
        String namespace,
        String value,
        String type)
   {
    this.fullName = fullName;
    this.name = name;
    this.namespace = namespace;
    this.value = value;
    this.type = type;
###
480, UndoAction, UndoAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/UndoAction.java, 56, 58
1
/** Creates a new instance. */
3
  public UndoAction(Application app, View view) {
    super(app, view);
    labels.configureAction(this, ID);
###
481, setValue, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 137, 139
5
/**
  * Sets the value of the attribute.
  *
  * @param value the new value.
  */
3
   void setValue(String value)
   {
    this.value = value;
###
483, getValue, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 126, 128
3
/**
  * Returns the value of the attribute.
  */
3
   String getValue()
   {
    return this.value;
###
485, getName, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 108, 110
3
/**
  * Returns the short name of the attribute.
  */
3
   String getName()
   {
    return this.name;
###
487, getNamespace, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 117, 119
3
/**
  * Returns the namespace of the attribute.
  */
3
   String getNamespace()
   {
    return this.namespace;
###
489, getFullName, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 99, 101
3
/**
  * Returns the full name of the attribute.
  */
3
   String getFullName()
   {
    return this.fullName;
###
490, ClearSelectionAction, ClearSelectionAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/ClearSelectionAction.java, 46, 47
1
/** Creates a new instance which acts on the currently focused component. */
2
  public ClearSelectionAction() {
    this(null);
###
493, DuplicateAction, DuplicateAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/DuplicateAction.java, 45, 46
1
/** Creates a new instance which acts on the currently focused component. */
2
  public DuplicateAction() {
    this(null);
###
496, CopyAction, CopyAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/CopyAction.java, 54, 57
5
/** Creates a new instance which acts on the specified component.
   *
   * @param target The target of the action. Specify null for the currently
   * focused component.
   */
4
  public CopyAction(JComponent target) {
    super(target);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
497, buildMessage, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 164, 186
11
/**
  * Builds the exception message
  *
  * @param systemID   the system ID from where the data came
  * @param lineNr     the line number in the XML data where the exception
  *           occurred.
  * @param e      the encapsulated exception.
  * @param msg      the message of the exception.
  * @param reportParams true if the systemID, lineNr and e params need to be
  *           appended to the message
  */
19
   private static String buildMessage(String  systemID,
                    int     lineNr,
                    Exception e,
                    String  msg,
                    boolean   reportParams)
   {
    String str = msg;
    if (reportParams) {
     if (systemID != null) {
      str += ", SystemID='" + systemID + "'";
     }
     if (lineNr >= 0) {
      str += ", Line=" + lineNr;
     }
     if (e != null) {
      str += ", Exception: " + e;
     }
    }
    return str;
###
498, CopyAction, CopyAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/CopyAction.java, 45, 46
1
/** Creates a new instance which acts on the currently focused component. */
2
  public CopyAction() {
    this(null);
###
499, XMLException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 118, 122
9
/**
  * Creates a new exception.
  *
  * @param systemID the system ID of the XML data where the exception
  *         occurred
  * @param lineNr   the line number in the XML data where the exception
  *         occurred.
  * @param msg    the message of the exception.
  */
5
   public XMLException(String systemID,
             int  lineNr,
             String msg)
   {
    this(systemID, lineNr, null, msg, true);
###
500, XMLException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 101, 105
9
/**
  * Creates a new exception.
  *
  * @param systemID the system ID of the XML data where the exception
  *         occurred
  * @param lineNr   the line number in the XML data where the exception
  *         occurred.
  * @param e    the encapsulated exception.
  */
5
   public XMLException(String systemID,
             int  lineNr,
             Exception e)
   {
    this(systemID, lineNr, e, "Nested Exception", true);
###
501, printStackTrace, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 253, 259
5
/**
  * Dumps the exception stack to an output stream.
  *
  * @param stream the output stream
  */
6
   public void printStackTrace(PrintStream stream)
   {
    super.printStackTrace(stream);
    if (this.encapsulatedException != null) {
     stream.println("*** Nested Exception:");
     this.encapsulatedException.printStackTrace(stream);
###
502, getSystemID, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 206, 208
4
/**
  * Returns the system ID of the XML data where the exception occurred.
  * If there is no system ID known, null is returned.
  */
3
   public String getSystemID()
   {
    return this.systemID;
###
503, XMLException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 75, 77
5
/**
  * Creates a new exception.
  *
  * @param msg the message of the exception.
  */
3
   public XMLException(String msg)
   {
    this(null, -1, null, msg, false);
###
504, XMLException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 137, 149
11
/**
  * Creates a new exception.
  *
  * @param systemID   the system ID from where the data came
  * @param lineNr     the line number in the XML data where the exception
  *           occurred.
  * @param e      the encapsulated exception.
  * @param msg      the message of the exception.
  * @param reportParams true if the systemID, lineNr and e params need to be
  *           appended to the message
  */
13
   public XMLException(String  systemID,
             int     lineNr,
             Exception e,
             String  msg,
             boolean   reportParams)
   {
    super(XMLException.buildMessage(systemID, lineNr, e, msg,
                    reportParams));
    this.systemID = systemID;
    this.lineNr = lineNr;
    this.encapsulatedException = e;
    this.msg = XMLException.buildMessage(systemID, lineNr, e, msg,
                       reportParams);
###
506, DeleteAction, DeleteAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/DeleteAction.java, 54, 55
1
/** Creates a new instance which acts on the currently focused component. */
2
  public DeleteAction() {
    this(null);
###
507, contains, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 80, 81
3
/**
   * Tests if a point is contained in the connector.
   */
2
  public boolean contains(Point2D.Double p) {
    return getOwner().contains(p);
###
508, getException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 226, 228
4
/**
  * Returns the encapsulated exception, or null if no exception is
  * encapsulated.
  */
3
   public Exception getException()
   {
    return this.encapsulatedException;
###
509, DeleteAction, DeleteAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/DeleteAction.java, 63, 80
5
/** Creates a new instance which acts on the specified component.
   *
   * @param target The target of the action. Specify null for the currently
   * focused component.
   */
17
  public DeleteAction(JComponent target) {
    super(ID);
    this.target = target;
    if (target != null) {
      // Register with a weak reference on the JComponent.
      propertyHandler = new PropertyChangeListener() {
        @Override
        public void propertyChange(PropertyChangeEvent evt) {
          if (evt.getPropertyName().equals("enabled")) {
            setEnabled((Boolean) evt.getNewValue());
          }
        }
      };
      target.addPropertyChangeListener(new WeakPropertyChangeListener(propertyHandler));
    }
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
510, AbstractConnector, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 63, 64
3
/**
   * Constructs a connector with the given owner figure.
   */
2
  public AbstractConnector(Figure owner) {
    this.owner = owner;
###
511, printStackTrace, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 237, 243
5
/**
  * Dumps the exception stack to a print writer.
  *
  * @param writer the print writer
  */
6
   public void printStackTrace(PrintWriter writer)
   {
    super.printStackTrace(writer);
    if (this.encapsulatedException != null) {
     writer.println("*** Nested Exception:");
     this.encapsulatedException.printStackTrace(writer);
###
512, findPoint, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 97, 98
5
/**
   * Gets the connection point. Override when the connector
   * does not need to distinguish between the start and end
   * point of a connection.
   */
2
  protected Point2D.Double findPoint(ConnectionFigure connection) {
    return Geom.center(getBounds());
###
513, finalize, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 193, 198
3
/**
  * Cleans up the object when it's destroyed.
  */
6
   protected void finalize()
    throws Throwable
   {
    this.systemID = null;
    this.encapsulatedException = null;
    super.finalize();
###
514, getOwner, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 104, 105
3
/**
   * Gets the connector's owner.
   */
2
  public Figure getOwner() {
    return owner;
###
515, XMLException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 86, 88
5
/**
  * Creates a new exception.
  *
  * @param e the encapsulated exception.
  */
3
   public XMLException(Exception e)
   {
    this(null, -1, e, "Nested Exception", false);
###
516, setOwner, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 110, 111
3
/**
   * Sets the connector's owner.
   */
2
  protected void setOwner(Figure newValue) {
    owner = newValue;
###
517, printStackTrace, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 267, 273
3
/**
  * Dumps the exception stack to System.err.
  */
6
   public void printStackTrace()
   {
    super.printStackTrace();
    if (this.encapsulatedException != null) {
     System.err.println("*** Nested Exception:");
     this.encapsulatedException.printStackTrace();
###
518, AbstractConnector, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 57, 58
5
/**
   * Constructs a connector that has no owner. It is only
   * used internally to resurrect a connectors from a
   * StorableOutput. It should never be called directly.
   */
2
  public AbstractConnector() {
    owner = null;
###
519, getLineNr, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 216, 218
4
/**
  * Returns the line number in the XML data where the exception occurred.
  * If there is no line number known, -1 is returned.
  */
3
   public int getLineNr()
   {
    return this.lineNr;
###
521, CutAction, CutAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/CutAction.java, 45, 46
1
/** Creates a new instance which acts on the currently focused component. */
2
  public CutAction() {
    this(null);
###
522, contains, LocatorConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/LocatorConnector.java, 69, 70
3
/**
   * Tests if a point is contained in the connector.
   */
2
  @Override public boolean contains(Point2D.Double p) {
    return getBounds().contains(p);
###
525, ZoomEditorAction, ZoomEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ZoomEditorAction.java, 37, 38
3
/**
   * Creates a new instance.
   */
2
  public ZoomEditorAction(DrawingEditor editor, double scaleFactor, AbstractButton button) {
    this(editor, scaleFactor, button, true);
###
527, chop, ChopDiamondConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/ChopDiamondConnector.java, 44, 119
3
/**
   * Return an appropriate connection point on the edge of a diamond figure
   */
76
  protected Point2D.Double chop(Figure target, Point2D.Double from) {
    target = getConnectorTarget(target);
    Rectangle2D.Double r = target.getBounds();
    
    if (target.get(DiamondFigure.IS_QUADRATIC)) {
      double side = Math.max(r.width, r.height);
      r.x -= (side - r.width) / 2;
      r.y -= (side - r.height) / 2;
      r.width = r.height = side;
    }
    double growx;
    double growy;
    // FIXME - This code is wrong. Copy correct code from DiamondFigure.
    switch (target.get(STROKE_PLACEMENT)) {
      case INSIDE : {
        growx = growy = 0f;
        break;
      }
      case OUTSIDE : {
        double lineLength = Math.sqrt(r.width * r.width + r.height * r.height);
        double scale = getStrokeTotalWidth(target) * 2d / lineLength;
        growx = scale * r.height;
        growy = scale * r.width;
        //growy = getStrokeTotalWidth() * SQRT2;
        break;
      }
      case CENTER :
      default :
        double lineLength = Math.sqrt(r.width * r.width + r.height * r.height);
        double scale = getStrokeTotalWidth(target) / lineLength;
        growx = scale * r.height;
        growy = scale * r.width;
        //growx = growy = getStrokeTotalWidth() / 2d * SQRT2;
        break;
    }
    Geom.grow(r, growx, growy);
    
    // Center point
    Point2D.Double c1 = new Point2D.Double(r.x + r.width/2, r.y + (r.height/2));
    Point2D.Double p2 = new Point2D.Double(r.x + r.width/2, r.y + r.height);
    Point2D.Double p4 = new Point2D.Double(r.x + r.width/2, r.y);
    
    // If overlapping, just return the opposite corners
    if (r.contains(from)) {
      if (from.y > r.y && from.y < (r.y +r.height/2)) {
        return p2;
      } else {
        return p4;
      }
    }
    
    // Calculate angle to determine quadrant
    double ang = Geom.pointToAngle(r, from);
    
    // Dermine line points
    Point2D.Double p1 = new Point2D.Double(r.x + r.width  , r.y + (r.height/2));
    Point2D.Double p3 = new Point2D.Double(r.x      , r.y + (r.height/2));
    Point2D.Double rp = null; // This will be returned
    
    // Get the intersection with edges
    if (ang > 0 && ang < 1.57) {
      rp = Geom.intersect(p1.x, p1.y, p2.x, p2.y, c1.x, c1.y, from.x, from.y);
    } else if (ang > 1.575 && ang < 3.14) {
      rp = Geom.intersect(p2.x, p2.y, p3.x, p3.y, c1.x, c1.y, from.x, from.y);
    } else if (ang > -3.14 && ang < -1.575) {
      rp = Geom.intersect(p3.x, p3.y, p4.x, p4.y, c1.x, c1.y, from.x, from.y);
    } else if (ang > -1.57 && ang < 0) {
      rp = Geom.intersect(p4.x, p4.y, p1.x, p1.y, c1.x, c1.y, from.x, from.y);
    }
    
    // No proper edge found, we should send one of four corners
    if (rp == null) {
      rp = Geom.angleToPoint(r, ang);
    }
    
    return rp;
###
529, configureJCheckBoxMenuItem, ActionUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/ActionUtil.java, 59, 69
3
/**
   * Configures a JCheckBoxMenuItem for an Action.
   */
11
  public static void configureJCheckBoxMenuItem(final JCheckBoxMenuItem mi, final Action a) {
    mi.setSelected((Boolean) a.getValue(ActionUtil.SELECTED_KEY));
    PropertyChangeListener propertyHandler = new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getPropertyName().equals(ActionUtil.SELECTED_KEY)) {
          mi.setSelected((Boolean) a.getValue(ActionUtil.SELECTED_KEY));
        }
      }
    };
    a.addPropertyChangeListener(propertyHandler);
    mi.putClientProperty("actionPropertyHandler", propertyHandler);
###
530, PrintApplicationFileAction, PrintApplicationFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/app/PrintApplicationFileAction.java, 52, 54
1
/** Creates a new instance. */
3
  public PrintApplicationFileAction(Application app) {
    super(app, null);
    putValue(Action.NAME, "OSX Print File");
###
531, ExitAction, ExitAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/app/ExitAction.java, 52, 55
1
/** Creates a new instance. */
4
  public ExitAction(Application app) {
    super(app);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
532, actionPerformed, OpenApplicationFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/app/OpenApplicationFileAction.java, 65, 88
6
/**
   * Opens a new view.
   * <p>
   * The file name is passed in the action command of the action event.
   *
   */
22
  @Override
  public void actionPerformed(ActionEvent evt) {
    final Application app = getApplication();
    final String filename = evt.getActionCommand();
    if (app.isEnabled()) {
      app.setEnabled(false);
      // Search for an empty view
      View emptyView = app.getActiveView();
      if (emptyView == null
          || emptyView.getURI() != null
          || emptyView.hasUnsavedChanges()) {
        emptyView = null;
      }
      final View p;
      if (emptyView == null) {
        p = app.createView();
        app.add(p);
        app.show(p);
      } else {
        p = emptyView;
      }
      openView(p, new File(filename).toURI());
###
533, OpenApplicationFileAction, OpenApplicationFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/app/OpenApplicationFileAction.java, 54, 56
1
/** Creates a new instance. */
3
  public OpenApplicationFileAction(Application app) {
    super(app);
    putValue(Action.NAME, "OSX Open File");
###
534, installViewListeners, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 122, 123
3
/**
   * Installs listeners on the view object.
   */
2
  protected void installViewListeners(View p) {
    p.addPropertyChangeListener(viewListener);
###
535, isEnabled, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 157, 161
8
/**
   * Returns true if the action is enabled.
   * The enabled state of the action depends on the state that has been set
   * using setEnabled() and on the enabled state of the application.
   *
   * @return true if the action is enabled, false otherwise
   * @see Action#isEnabled
   */
5
  @Override
  public boolean isEnabled() {
    return getActiveView() != null
        && getActiveView().isEnabled()
        && this.enabled;
###
536, updateView, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 79, 91
4
/**
   * Updates the listeners of this action depending on the current view
   * of the application.
   */
13
  protected void updateView(View oldValue, View newValue) {
    // We only need to do this, if the view has not been explicitly set
    if (view == null) {
      if (oldValue != null) {
        uninstallViewListeners(oldValue);
      }
      if (newValue != null) {
        installViewListeners(newValue);
      }
      firePropertyChange(VIEW_PROPERTY, oldValue, newValue);
      updateEnabled(oldValue != null && oldValue.isEnabled(),
          newValue != null && newValue.isEnabled());
      updateView();
###
537, setPropertyName, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 98, 101
3
/**
   * Sets the property name.
   */
4
  protected void setPropertyName(String name) {
    this.propertyName = name;
    if (name != null) {
      updateView();
###
538, getPropertyName, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 108, 109
3
/**
   * Gets the property name.
   */
2
  protected String getPropertyName() {
    return propertyName;
###
539, uninstallViewListeners, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 129, 130
3
/**
   * Uninstalls listeners on the view object.
   */
2
  protected void uninstallViewListeners(View p) {
    p.removePropertyChangeListener(viewListener);
###
540, AbstractViewAction, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 63, 72
1
/** Creates a new instance which acts on the specified view of the application. */
10
  public AbstractViewAction(Application app, View view) {
    this.app = app;
    this.view = view;
    this.enabled = true;
    if (view == null) {
      app.addPropertyChangeListener(applicationListener);
    } else {
      view.addPropertyChangeListener(viewListener);
    }
    updateView(null, getActiveView());
###
541, updateEnabled, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 137, 138
4
/**
   * Updates the enabled state of this action depending on the new enabled
   * state of the view.
   */
2
  protected void updateEnabled(boolean oldValue, boolean newValue) {
    firePropertyChange("enabled", oldValue, newValue && isEnabled());
###
543, AboutAction, AboutAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/app/AboutAction.java, 43, 46
1
/** Creates a new instance. */
4
  public AboutAction(Application app) {
    super(app);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
544, AttributeChangeEdit, AttributeChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/AttributeChangeEdit.java, 34, 38
1
/** Creates a new instance. */
5
  public AttributeChangeEdit(Figure owner, AttributeKey<T> name, T oldValue, T newValue) {
    this.owner = owner;
    this.name = name;
    this.oldValue = oldValue;
    this.newValue = newValue;
###
545, CompositeFigureEdit, CompositeFigureEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEdit.java, 57, 59
5
/**
   * Creates new CompositeFigureEdit which uses the specified presentation name.
   *
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
3
  public CompositeFigureEdit(Figure figure, String presentationName) {
    super(presentationName);
    this.figure = figure;
###
546, CompositeFigureEdit, CompositeFigureEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEdit.java, 47, 49
5
/**
   * Creates new CompositeFigureEdit which uses the specified significance.
   *
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
3
  public CompositeFigureEdit(Figure figure, boolean isSignificant) {
    super(isSignificant);
    this.figure = figure;
###
547, CompositeFigureEdit, CompositeFigureEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEdit.java, 38, 39
6
/**
   * Creates a new {@code CompositeFigureEdit} which uses
   * CompoundEdit.getPresentatioName and is significant.
   *
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
2
  public CompositeFigureEdit(Figure figure) {
    this.figure = figure;
###
548, ArrowTip, ArrowTip, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/ArrowTip.java, 47, 48
4
/**
   * Constructs an arrow tip with the specified angle and outer and inner 
   * radius.
   */
2
  public ArrowTip(double angle, double outerRadius, double innerRadius) {
    this(angle, outerRadius, innerRadius, true, false, true);
###
549, ArrowTip, ArrowTip, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/ArrowTip.java, 54, 58
3
/**
   * Constructs an arrow tip with the specified parameters.
   */
5
  public ArrowTip(double angle, double outerRadius, double innerRadius, boolean isFilled, boolean isStroked, boolean isSolid) {
    super(isFilled, isStroked, isSolid);
    this.angle = angle;
    this.outerRadius = outerRadius;
    this.innerRadius = innerRadius;
###
550, AbstractLineDecoration, AbstractLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/AbstractLineDecoration.java, 46, 49
3
/**
   * Constructs an arrow tip with the given angle and radius.
   */
4
  public AbstractLineDecoration(boolean isFilled, boolean isStroked, boolean isSolid) {
    this.isFilled = isFilled;
    this.isStroked = isStroked;
    this.isSolid = isSolid;
###
551, draw, AbstractLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/AbstractLineDecoration.java, 66, 85
4
/**
   * Draws the arrow tip in the direction specified by the given two
   * Points. (template method)
   */
20
  public void draw(Graphics2D g, Figure f, Point2D.Double p1, Point2D.Double p2) {
    Path2D.Double path = getTransformedDecoratorPath(f, p1, p2);
    Color color;
    if (isFilled) {
      if (isSolid) {
        color = f.get(STROKE_COLOR);
      } else {
        color = f.get(FILL_COLOR);
      }
      if (color != null) {
        g.setColor(color);
        g.fill(path);
      }
    }
    if (isStroked) {
      color = f.get(STROKE_COLOR);
      if (color != null) {
        g.setColor(color);
        g.setStroke(AttributeKeys.getStroke(f));
        g.draw(path);
###
552, getDrawingArea, AbstractLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/AbstractLineDecoration.java, 93, 114
3
/**
   * Returns the drawing area of the decorator.
   */
22
  public Rectangle2D.Double getDrawingArea(Figure f, Point2D.Double p1, Point2D.Double p2) {
    Path2D.Double path = getTransformedDecoratorPath(f, p1, p2);
    Rectangle2D b = path.getBounds2D();
    Rectangle2D.Double area = new Rectangle2D.Double(b.getX(), b.getY(), b.getWidth(), b.getHeight());
    
    if (isStroked) {
      double strokeWidth = f.get(STROKE_WIDTH);
      int strokeJoin = f.get(STROKE_JOIN);
      double miterLimit = (f.get(STROKE_MITER_LIMIT) * strokeWidth);
      
      double grow;
      if (strokeJoin == BasicStroke.JOIN_MITER) {
        grow  = (int) (1 + strokeWidth / 2 * miterLimit);
      } else {
        grow  = (int) (1 + strokeWidth / 2);
      }
      Geom.grow(area, grow, grow);
    } else {
      Geom.grow(area, 1, 1); // grow due to antialiasing
    }
    
    return area;
###
554, PerpendicularBar, PerpendicularBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/PerpendicularBar.java, 36, 37
3
/**
   * Constructs a perpendicular line with a height of 10.
   */
2
  public PerpendicularBar() {
    this(10);
###
555, PerpendicularBar, PerpendicularBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/PerpendicularBar.java, 43, 46
3
/**
   * Constructs a perpendicular line with the given height.
   */
3
  public PerpendicularBar(double height) {
    super(false, true, false);
    this.height = height;
###
556, getDecoratorPath, PerpendicularBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/PerpendicularBar.java, 53, 60
4
/**
   * Calculates the path of the decorator...a simple line
   * perpendicular to the figure.
   */
6
  protected Path2D.Double getDecoratorPath(Figure f) {
    Path2D.Double path = new Path2D.Double();
    double halfHeight = height / 2;
    path.moveTo(+halfHeight, 0);
    path.lineTo(-halfHeight, 0);
    return path;
###
560, CompositeLineDecoration, CompositeLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java, 51, 53
3
/**
   * Constructs a composite line decoration with the two supplied decorations.
   */
3
  public CompositeLineDecoration(LineDecoration decoration1, LineDecoration decoration2) {
    addDecoration(decoration1);
    addDecoration(decoration2);
###
561, addDecoration, CompositeLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java, 61, 63
5
/**
   * Add another line decoration into the composite line decoration.
   * The new decoration will be appended to the existing decorations
   * and is also the last drawn.
   */
3
  public void addDecoration(LineDecoration decoration) {
    if (decoration != null) {
      decorations.add(decoration);
###
562, draw, CompositeLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java, 71, 73
4
/**
   * Draws the arrow tip in the direction specified by the given two
   * Points.. (template method)
   */
3
  public void draw(Graphics2D g, Figure f, Point2D.Double p1, Point2D.Double p2) {
    for (LineDecoration decoration : decorations) {
      decoration.draw(g, f, p1, p2);
###
563, getDrawingArea, CompositeLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java, 80, 91
3
/**
   * Returns the drawing area of the decorator.
   */
12
  public Rectangle2D.Double getDrawingArea(Figure f, Point2D.Double p1, Point2D.Double p2) {
    Rectangle2D.Double r = null;
    
    for (LineDecoration decoration : decorations) {
      Rectangle2D.Double aR = decoration.getDrawingArea(f, p1, p2);
      if (r == null)
        r = aR;
      else
        r.add(aR);
    }
    
    return r;
###
564, HandleMulticaster, HandleMulticaster, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/HandleMulticaster.java, 35, 37
1
/** Creates a new instance. */
3
  public HandleMulticaster(Handle handle) {
    this.handles = new LinkedList<Handle>();
    this.handles.add(handle);
###
571, getFigure, FigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/FigureEvent.java, 67, 68
3
/**
   *  Gets the changed figure
   */
2
  public Figure getFigure() {
    return (Figure) getSource();
###
572, FigureEvent, FigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/FigureEvent.java, 57, 61
3
/**
   * Constructs an event for the given source Figure.
   */
5
  public FigureEvent(Figure source, AttributeKey attribute, Object oldValue, Object newValue) {
    super(source);
    this.attribute = attribute;
    this.oldValue = oldValue;
    this.newValue = newValue;
###
573, FigureEvent, FigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/FigureEvent.java, 49, 51
4
/**
   * Constructs an event for the given source Figure.
   * @param invalidatedArea The bounds of the invalidated area on the drawing.
   */
3
  public FigureEvent(Figure source, Rectangle2D.Double invalidatedArea) {
    super(source);
    this.invalidatedArea = invalidatedArea;
###
574, HandleEvent, HandleEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/HandleEvent.java, 42, 44
1
/** Creates a new instance. */
3
  public HandleEvent(Handle src, Rectangle invalidatedArea) {
    super(src);
    this.invalidatedArea = invalidatedArea;
###
575, CompositeFigureEvent, CompositeFigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java, 47, 51
6
/**
   * Constructs an event for the provided CompositeFigure.
   * @param source The composite figure.
   * @param child The changed figure.
   * @param invalidatedArea The bounds of the invalidated area on the drawing.
   */
5
  public CompositeFigureEvent(CompositeFigure source, Figure child, Rectangle2D.Double invalidatedArea, int zIndex) {
    super(source);
    this.child = child;
    this.invalidatedArea = invalidatedArea;
    this.index = 0;
###
576, getInvalidatedArea, CompositeFigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java, 71, 72
3
/**
   *  Gets the bounds of the invalidated area on the drawing.
   */
2
  public Rectangle2D.Double getInvalidatedArea() {
    return invalidatedArea;
###
577, getChildFigure, CompositeFigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java, 64, 65
3
/**
   *  Gets the changed child figure.
   */
2
  public Figure getChildFigure() {
    return child;
###
578, getCompositeFigure, CompositeFigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java, 58, 59
3
/**
   *  Gets the changed drawing.
   */
2
  public CompositeFigure getCompositeFigure() {
    return (CompositeFigure) getSource();
###
582, OpenFileAction, OpenFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenFileAction.java, 56, 59
1
/** Creates a new instance. */
4
  public OpenFileAction(Application app) {
    super(app);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
583, createDialog, OpenFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenFileAction.java, 222, 261
3
/** We implement JFileChooser.showDialog by ourselves, so that we can center
   * dialogs properly on screen on Mac OS X.
   */
35
  protected JDialog createDialog(URIChooser chooser, Component parent) throws HeadlessException {
    String title = chooser.getDialogTitle();
    if (chooser instanceof JFileChooser) {
      ((JFileChooser) chooser).getAccessibleContext().setAccessibleDescription(title);
    }
    JDialog dialog;
    Window window = (parent instanceof Window) ? (Window) parent : SwingUtilities.getWindowAncestor(parent);
    if (window instanceof Frame) {
      dialog = new JDialog((Frame) window, title, true);
    } else {
      dialog = new JDialog((Dialog) window, title, true);
    }
    dialog.setComponentOrientation(chooser.getComponent().getComponentOrientation());
    Container contentPane = dialog.getContentPane();
    contentPane.setLayout(new BorderLayout());
    contentPane.add(chooser.getComponent(), BorderLayout.CENTER);
    if (JDialog.isDefaultLookAndFeelDecorated()) {
      boolean supportsWindowDecorations =
          UIManager.getLookAndFeel().getSupportsWindowDecorations();
      if (supportsWindowDecorations) {
        dialog.getRootPane().setWindowDecorationStyle(JRootPane.FILE_CHOOSER_DIALOG);
      }
    }
    //dialog.pack();
    Preferences prefs = PreferencesUtil.userNodeForPackage(getApplication().getModel().getClass());
    PreferencesUtil.installFramePrefsHandler(prefs, "openChooser", dialog);
    /*
    if (window.getBounds().isEmpty()) {
    Rectangle screenBounds = window.getGraphicsConfiguration().getBounds();
    dialog.setLocation(screenBounds.x + (screenBounds.width - dialog.getWidth()) / 2, //
    screenBounds.y + (screenBounds.height - dialog.getHeight()) / 3);
    } else {
    dialog.setLocationRelativeTo(parent);
    }*/
    return dialog;
###
584, showDialog, OpenFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenFileAction.java, 185, 216
3
/** We implement JFileChooser.showDialog by ourselves, so that we can center
   * dialogs properly on screen on Mac OS X.
   */
29
  public int showDialog(URIChooser chooser, Component parent) {
    final Component finalParent = parent;
    final int[] returnValue = new int[1];
    final JDialog dialog = createDialog(chooser, finalParent);
    dialog.addWindowListener(new WindowAdapter() {
      @Override
      public void windowClosing(WindowEvent e) {
        returnValue[0] = JFileChooser.CANCEL_OPTION;
      }
    });
    chooser.addActionListener(new ActionListener() {
      @Override
      public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals("CancelSelection")) {
          returnValue[0] = JFileChooser.CANCEL_OPTION;
          dialog.setVisible(false);
        } else if (e.getActionCommand().equals("ApproveSelection")) {
          returnValue[0] = JFileChooser.APPROVE_OPTION;
          dialog.setVisible(false);
        }
      }
    });
    returnValue[0] = JFileChooser.ERROR_OPTION;
    chooser.rescanCurrentDirectory();
    dialog.setVisible(true);
    //chooser.firePropertyChange("JFileChooserDialogIsClosingProperty", dialog, null);
    dialog.removeAll();
    dialog.dispose();
    return returnValue[0];
###
585, LoadFileAction, LoadFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/LoadFileAction.java, 57, 60
1
/** Creates a new instance. */
4
  public LoadFileAction(Application app, View view) {
    super(app, view);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
586, ExportFileAction, ExportFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/ExportFileAction.java, 53, 56
1
/** Creates a new instance. */
4
  public ExportFileAction(Application app, View view) {
    super(app, view);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
587, ClearRecentFilesMenuAction, ClearRecentFilesMenuAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/ClearRecentFilesMenuAction.java, 42, 46
1
/** Creates a new instance. */
5
  public ClearRecentFilesMenuAction(Application app) {
    super(app);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
    updateEnabled();
###
588, installApplicationListeners, ClearRecentFilesMenuAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/ClearRecentFilesMenuAction.java, 52, 57
3
/**
   * Installs listeners on the application object.
   */
6
  @Override protected void installApplicationListeners(Application app) {
    super.installApplicationListeners(app);
    if (applicationListener == null) {
      applicationListener = createApplicationListener();
    }
    app.addPropertyChangeListener(applicationListener);
###
589, fireHandleRequestRemove, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 124, 137
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireHandleRequestRemove(Rectangle invalidatedArea) {
    HandleEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == HandleListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new HandleEvent(this, invalidatedArea);
        }
        ((HandleListener) listeners[i + 1]).handleRequestRemove(event);
###
591, areaInvalidated, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 275, 276
7
/**
   * Sent when a region used by the figure needs to be repainted.
   * The implementation of this method assumes that the handle
   * is located on the bounds of the figure or inside the figure.
   * If the handle is located elsewhere this method must be reimpleted
   * by the subclass.
   */
2
  public void areaInvalidated(FigureEvent evt) {
    updateBounds();
###
593, addHandleListener, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 63, 64
3
/**
   * Adds a listener for this handle.
   */
2
  public void addHandleListener(HandleListener l) {
    listenerList.add(HandleListener.class, l);
###
594, removeHandleListener, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 70, 71
3
/**
   * Removes a listener for this handle.
   */
2
  public void removeHandleListener(HandleListener l) {
    listenerList.remove(HandleListener.class, l);
###
595, AbstractHandle, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 48, 53
1
/** Creates a new instance. */
6
  public AbstractHandle(Figure owner) {
    if (owner == null) {
      throw new IllegalArgumentException("owner must not be null");
    }
    this.owner = owner;
    owner.addFigureListener(this);
###
596, getCursor, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 310, 311
3
/**
   * Returns a cursor for the handle.
   */
2
  public Cursor getCursor() {
    return Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);
###
597, LoadRecentFileAction, LoadRecentFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/LoadRecentFileAction.java, 47, 50
1
/** Creates a new instance. */
4
  public LoadRecentFileAction(Application app, View view, URI uri) {
    super(app, view);
    this.uri = uri;
    putValue(Action.NAME, URIUtil.getName(uri));
###
598, fireHandleRequestSecondaryHandles, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 146, 159
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireHandleRequestSecondaryHandles() {
    HandleEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == HandleListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new HandleEvent(this, null);
        }
        ((HandleListener) listeners[i + 1]).handleRequestSecondaryHandles(event);
###
599, getToolTipText, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 379, 380
4
/**
   * Returns a tooltip for the specified location.
   * By default, AbstractHandle returns null.
   */
2
  public String getToolTipText(Point p) {
    return toolTipText;
###
600, draw, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 167, 170
3
/**
   * Draws this handle.
   */
4
  public void draw(Graphics2D g) {
    drawCircle(g,
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.HANDLE_FILL_COLOR),
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.HANDLE_STROKE_COLOR));
###
601, fireUndoableEditHappened, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 116, 117
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
2
  protected void fireUndoableEditHappened(UndoableEdit edit) {
    view.getDrawing().fireUndoableEditHappened(edit);
###
602, figureChanged, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 303, 304
3
/**
   * Sent when the bounds or shape of a figure has changed.
   */
2
  public void figureChanged(FigureEvent evt) {
    updateBounds();
###
605, fireAreaInvalidated, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 94, 107
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireAreaInvalidated(Rectangle invalidatedArea) {
    HandleEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == HandleListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new HandleEvent(this, invalidatedArea);
        }
        ((HandleListener) listeners[i + 1]).areaInvalidated(event);
###
606, isCombinableWith, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 318, 319
4
/**
   * Returns true, if the given handle is an instance of the same
   * class or of a subclass of this handle,.
   */
2
  public boolean isCombinableWith(Handle handle) {
    return getClass().isAssignableFrom(handle.getClass());
###
607, trackStart, AbstractConnectionHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java, 113, 119
3
/**
   * Disconnects the connection.
   */
7
  public void trackStart(Point anchor, int modifiersEx) {
    savedTarget = getTarget();
    start = anchor;
    savedLiner = getOwner().getLiner();
    getOwner().setLiner(null);
    //disconnect();
    fireHandleRequestSecondaryHandles();
###
608, getSource, AbstractConnectionHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java, 103, 107
4
/**
   * Gets the side of the connection that is unaffected by
   * the change.
   */
5
  protected Connector getSource() {
    if (getTarget() == getOwner().getStartConnector()) {
      return getOwner().getEndConnector();
    }
    return getOwner().getStartConnector();
###
609, trackStep, AbstractConnectionHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java, 125, 138
3
/**
   * Finds a new connectableConnector of the connection.
   */
14
  public void trackStep(Point anchor, Point lead, int modifiersEx) {
    Point2D.Double p = view.viewToDrawing(lead);
    view.getConstrainer().constrainPoint(p);
    connectableFigure = findConnectableFigure(p, view.getDrawing());
    if (connectableFigure != null) {
      Connector aTarget = findConnectionTarget(p, view.getDrawing());
      if (aTarget != null) {
        p = aTarget.getAnchor();
      }
    }
    getOwner().willChange();
    setLocation(p);
    getOwner().changed();
    repaintConnectors();
###
614, draw, AbstractConnectionHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java, 209, 226
3
/**
   * Draws this handle.
   */
16
  @Override
  public void draw(Graphics2D g) {
    Graphics2D gg = (Graphics2D) g.create();
    gg.transform(view.getDrawingToViewTransform());
    for (Connector c : connectors) {
      c.draw(gg);
    }
    gg.dispose();
    if (getTarget() == null) {
      drawCircle(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.DISCONNECTED_CONNECTION_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.DISCONNECTED_CONNECTION_HANDLE_STROKE_COLOR));
    } else {
      drawCircle(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.CONNECTED_CONNECTION_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.CONNECTED_CONNECTION_HANDLE_STROKE_COLOR));
###
615, trackEnd, AbstractConnectionHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java, 145, 180
4
/**
   * Connects the figure to the new connectableConnector. If there is no
   * new connectableConnector the connection reverts to its original one.
   */
34
  public void trackEnd(Point anchor, Point lead, int modifiersEx) {
    ConnectionFigure f = getOwner();
    // Change node type
    if ((modifiersEx & (InputEvent.META_DOWN_MASK | InputEvent.CTRL_DOWN_MASK | InputEvent.ALT_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK)) != 0 &&
        (modifiersEx & InputEvent.BUTTON2_DOWN_MASK) == 0) {
      f.willChange();
      int index = getBezierNodeIndex();
      BezierPath.Node v = f.getNode(index);
      if (index > 0 && index < f.getNodeCount()) {
        v.mask = (v.mask + 3) % 4;
      } else if (index == 0) {
        v.mask = ((v.mask & BezierPath.C2_MASK) == 0) ? BezierPath.C2_MASK : 0;
      } else {
        v.mask = ((v.mask & BezierPath.C1_MASK) == 0) ? BezierPath.C1_MASK : 0;
      }
      f.setNode(index, v);
      f.changed();
      fireHandleRequestSecondaryHandles();
    }
    Point2D.Double p = view.viewToDrawing(lead);
    view.getConstrainer().constrainPoint(p);
    Connector target = findConnectionTarget(p, view.getDrawing());
    if (target == null) {
      target = savedTarget;
    }
    setLocation(p);
    if (target != savedTarget) {
      disconnect();
      connect(target);
    }
    getOwner().setLiner(savedLiner);
    getOwner().updateConnection();
    connectableConnector = null;
    connectors = Collections.emptyList();
###
618, getTool, ToolEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/ToolEvent.java, 52, 53
3
/**
   * Gets the tool which is the source of the event.
   */
2
  public Tool getTool() {
    return (Tool) getSource();
###
619, getView, ToolEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/ToolEvent.java, 58, 59
3
/**
   * Gets the drawing view of the tool.
   */
2
  public DrawingView getView() {
    return view;
###
620, ToolEvent, ToolEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/ToolEvent.java, 43, 46
1
/** Creates a new instance. */
4
  public ToolEvent(Tool src, DrawingView view, Rectangle invalidatedArea) {
    super(src);
    this.view = view;
    this.invalidatedArea = invalidatedArea;
###
621, draw, BezierControlPointHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierControlPointHandle.java, 88, 139
3
/**
   * Draws this handle.
   */
51
  public void draw(Graphics2D g) {
    BezierFigure f = getBezierFigure();
    if (f.getNodeCount() > index) {
      BezierPath.Node v = f.getNode(index);
      Point2D.Double p0 = new Point2D.Double(v.x[0], v.y[0]);
      Point2D.Double pc = new Point2D.Double(v.x[controlPointIndex], v.y[controlPointIndex]);
      Figure tOwner = getTransformOwner();
      if (tOwner.get(TRANSFORM) != null) {
        tOwner.get(TRANSFORM).transform(p0, p0);
        tOwner.get(TRANSFORM).transform(pc, pc);
      }
      Color handleFillColor;
      Color handleStrokeColor;
      Stroke stroke1;
      Color strokeColor1;
      Stroke stroke2;
      Color strokeColor2;
      if (getEditor().getTool().supportsHandleInteraction()) {
        handleFillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_FILL_COLOR);
        handleStrokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_STROKE_COLOR);
        stroke1 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_1);
        strokeColor1 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_1);
        stroke2 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_2);
        strokeColor2 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_2);
      } else {
        handleFillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_FILL_COLOR_DISABLED);
        handleStrokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_STROKE_COLOR_DISABLED);
        stroke1 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_1_DISABLED);
        strokeColor1 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_1_DISABLED);
        stroke2 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_2_DISABLED);
        strokeColor2 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_2_DISABLED);
      }
      if (stroke1 != null && strokeColor1 != null) {
        g.setStroke(stroke1);
        g.setColor(strokeColor1);
        g.draw(new Line2D.Double(
            view.drawingToView(p0),
            view.drawingToView(pc)));
      }
      if (stroke2 != null && strokeColor2 != null) {
        g.setStroke(stroke2);
        g.setColor(strokeColor2);
        g.draw(new Line2D.Double(
            view.drawingToView(p0),
            view.drawingToView(pc)));
      }
      if (v.keepColinear && v.mask == BezierPath.C1C2_MASK &&
          (index > 0 && index < f.getNodeCount() - 1 || f.isClosed())) {
        drawCircle(g, handleStrokeColor, handleFillColor);
      } else {
        drawCircle(g, handleFillColor, handleStrokeColor);
###
622, BezierControlPointHandle, BezierControlPointHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierControlPointHandle.java, 43, 44
1
/** Creates a new instance. */
2
  public BezierControlPointHandle(BezierFigure owner, int index, int coord) {
    this(owner, index, coord, owner);
###
626, AbstractRotateHandle, AbstractRotateHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractRotateHandle.java, 45, 46
1
/** Creates a new instance. */
2
  public AbstractRotateHandle(Figure owner) {
    super(owner);
###
628, ColorWheelImageProducer, ColorWheelImageProducer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorWheelImageProducer.java, 49, 57
1
/** Creates a new instance. */
9
  public ColorWheelImageProducer(ColorSystem sys, int w, int h) {
    super(w, h, null, 0, w);
    pixels = new int[w * h];
    this.w = w;
    this.h = h;
    this.colorSystem = sys;
    setAnimated(true);
    
    newPixels(pixels, ColorModel.getRGBdefault(), 0, w);
###
630, getBoundedRangeModel, DefaultColorSliderModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java, 101, 102
3
/**
   * Returns the bounded range model of the specified color componentIndex.
   */
2
  public DefaultBoundedRangeModel getBoundedRangeModel(int componentIndex) {
    return componentModels[componentIndex];
###
631, unconfigureSlider, DefaultColorSliderModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java, 87, 94
3
/**
   * Unconfigures a JSlider from this AbstractColorSystem.
   */
8
  public void unconfigureSlider(JSlider slider) {
    if (slider.getClientProperty("colorSliderModel") == this) {
      // XXX - This creates a NullPointerException ??
      //slider.setUI((SliderUI) UIManager.getUI(slider));
      slider.setModel(new DefaultBoundedRangeModel());
      slider.putClientProperty("colorSliderModel", null);
      slider.putClientProperty("colorComponentIndex", null);
      removeColorSlider(slider);
###
632, getSliderValue, DefaultColorSliderModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java, 108, 109
3
/**
   * Returns the value of the specified color componentIndex.
   */
2
  public int getSliderValue(int componentIndex) {
    return componentModels[componentIndex].getValue();
###
633, configureSlider, DefaultColorSliderModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java, 71, 81
5
/**
   * Configures a JSlider for this AbstractColorSystem.
   * If the JSlider is already configured for another AbstractColorSystem,
   * it is unconfigured first.
   */
11
  public void configureSlider(int componentIndex, JSlider slider) {
    if (slider.getClientProperty("colorSliderModel") != null) {
      ((DefaultColorSliderModel) slider.getClientProperty("colorSliderModel")).unconfigureSlider(slider);
    }
    if (!(slider.getUI() instanceof ColorSliderUI)) {
      slider.setUI((ColorSliderUI) ColorSliderUI.createUI(slider));
    }
    slider.setModel(getBoundedRangeModel(componentIndex));
    slider.putClientProperty("colorSliderModel", this);
    slider.putClientProperty("colorComponentIndex", new Integer(componentIndex));
    addColorSlider(slider);
###
634, SaveFileAction, SaveFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/SaveFileAction.java, 52, 53
1
/** Creates a new instance. */
2
  public SaveFileAction(Application app, View view) {
    this(app, view, false);
###
635, printQuartz, PrintFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java, 147, 218
4
/**
   * On Mac OS X with the Quartz rendering engine, the following code achieves
   * the best results.
   */
66
  public void printQuartz(PrintableView v) {
    Frame frame = (Frame) SwingUtilities.getWindowAncestor(v.getComponent());
    final Pageable pageable = v.createPageable();
    final double resolution = 300d;
    JobAttributes jobAttr = new JobAttributes();
    // FIXME - PageAttributes should be retrieved from View
    PageAttributes pageAttr = new PageAttributes();
    pageAttr.setMedia(PageAttributes.MediaType.A4);
    pageAttr.setPrinterResolution((int) resolution);
    final PrintJob pj = frame.getToolkit().getPrintJob(
        frame,
        "Job Title",
        jobAttr,
        pageAttr);
    getActiveView().setEnabled(false);
    new Worker() {
      protected Object construct() throws PrinterException {
        // Compute page format from settings of the print job
        Paper paper = new Paper();
        paper.setSize(
            pj.getPageDimension().width / resolution * 72d,
            pj.getPageDimension().height / resolution * 72d);
        paper.setImageableArea(64d, 32d, paper.getWidth() - 96d, paper.getHeight() - 64);
        PageFormat pageFormat = new PageFormat();
        pageFormat.setPaper(paper);
        // Print the job
        try {
          for (int i = 0,  n = pageable.getNumberOfPages(); i < n; i++) {
            PageFormat pf = pageable.getPageFormat(i);
            pf = pageFormat;
            Graphics g = pj.getGraphics();
            if (g instanceof Graphics2D) {
              pageable.getPrintable(i).print(g, pf, i);
            } else {
              BufferedImage buf = new BufferedImage(
                  (int) (pf.getImageableWidth() * resolution / 72d),
                  (int) (pf.getImageableHeight() * resolution / 72d),
                  BufferedImage.TYPE_INT_RGB);
              Graphics2D bufG = buf.createGraphics();

              bufG.setBackground(Color.WHITE);
              bufG.fillRect(0, 0, buf.getWidth(), buf.getHeight());
              bufG.scale(resolution / 72d, resolution / 72d);
              bufG.translate(-pf.getImageableX(), -pf.getImageableY());
              pageable.getPrintable(i).print(bufG, pf, i);
              bufG.dispose();
              g.drawImage(buf,
                  (int) (pf.getImageableX() * resolution / 72d),
                  (int) (pf.getImageableY() * resolution / 72d),
                  null);
              buf.flush();
            }
            g.dispose();
          }
        } finally {
          pj.end();
        }
        return null;
      }
      protected void failed(Throwable error) {
         error.printStackTrace();
      }
      protected void finished() {
        getActiveView().setEnabled(true);
      }
    }.start();
###
636, printJava2D, PrintFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java, 81, 109
3
/*
   * This prints at 72 DPI only. We might need this for some JVM versions on
   * Mac OS X.*/
28
  public void printJava2D(PrintableView v) {
    Pageable pageable = v.createPageable();
    if (pageable == null) {
      throw new InternalError("View does not have a method named java.awt.Pageable createPageable()");
    }
    try {
      PrinterJob job = PrinterJob.getPrinterJob();
      // FIXME - PrintRequestAttributeSet should be retrieved from View
      PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();
      attr.add(new PrinterResolution(300, 300, PrinterResolution.DPI));
      job.setPageable(pageable);
      if (job.printDialog()) {
        try {
          job.print();
        } catch (PrinterException e) {
          String message = (e.getMessage() == null) ? e.toString() : e.getMessage();
          View view = getActiveView();
          ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
          JSheet.showMessageSheet(view.getComponent(),
              "<html>" + UIManager.getString("OptionPane.css") +
              "<b>" + labels.getString("couldntPrint") + "</b><br>" +
              ((message == null) ? "" : message));
        }
      } else {
        System.out.println("JOB ABORTED!");
      }
    } catch (Throwable t) {
      t.printStackTrace();
###
637, printJava2DAlternative, PrintFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java, 116, 139
3
/*
   * This prints at 72 DPI only. We might need this for some JVM versions on
   * Mac OS X.*/
23
  public void printJava2DAlternative(PrintableView v) {
    Pageable pageable = v.createPageable();
    if (pageable == null) {
      throw new InternalError("View does not have a method named java.awt.Pageable createPageable()");
    }
    try {
      final PrinterJob job = PrinterJob.getPrinterJob();
      PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();
      attr.add(new PrinterResolution(300, 300, PrinterResolution.DPI));
      job.setPageable(pageable);
      if (job.printDialog(attr)) {
        try {
          job.print();
        } catch (PrinterException e) {
          ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
          JSheet.showMessageSheet(getActiveView().getComponent(),
              labels.getFormatted("couldntPrint", e));
        }
      } else {
        System.out.println("JOB ABORTED!");
      }
    } catch (Throwable t) {
      t.printStackTrace();
###
638, PrintFileAction, PrintFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java, 61, 64
1
/** Creates a new instance. */
4
  public PrintFileAction(Application app, View view) {
    super(app, view);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
639, ViewPropertyAction, ViewPropertyAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/view/ViewPropertyAction.java, 46, 47
1
/** Creates a new instance. */
2
  public ViewPropertyAction(Application app, View view, String propertyName, Object propertyValue) {
    this(app, view, propertyName, propertyValue.getClass(), propertyValue);
###
640, FocusWindowAction, FocusWindowAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/window/FocusWindowAction.java, 40, 53
1
/** Creates a new instance. */
14
  public FocusWindowAction(View view) {
    this.view = view;
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
    //setEnabled(false);
    setEnabled(view != null);
    
    view.addPropertyChangeListener(ppc = new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
        String name = evt.getPropertyName();
        if (name.equals(View.TITLE_PROPERTY)) {
          putValue(Action.NAME,
              evt.getNewValue()
###
641, OpenRecentFileAction, OpenRecentFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenRecentFileAction.java, 49, 52
1
/** Creates a new instance. */
4
  public OpenRecentFileAction(Application app, URI uri) {
    super(app);
    this.uri = uri;
    putValue(Action.NAME, URIUtil.getName(uri));
###
642, ToggleViewPropertyAction, ToggleViewPropertyAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/view/ToggleViewPropertyAction.java, 47, 48
1
/** Creates a new instance. */
2
  public ToggleViewPropertyAction(Application app, View view, String propertyName) {
    this(app, view, propertyName, Boolean.TYPE, true, false);
###
645, get, AbstractAttributedFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedFigure.java, 95, 96
3
/**
   * Gets an attribute from the figure.
   */
2
  public <T> T get(AttributeKey<T> key) {
    return key.get(attributes);
###
647, set, AbstractAttributedFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedFigure.java, 85, 89
5
/**
   * Sets an attribute of the figure.
   * AttributeKey name and semantics are defined by the class implementing
   * the figure interface.
   */
5
  public <T> void set(AttributeKey<T> key, T newValue) {
    if (forbiddenAttributes == null
        || ! forbiddenAttributes.contains(key)) {
      T oldValue = (T) key.put(attributes, newValue);
      fireAttributeChanged(key, oldValue, newValue);
###
649, get, AbstractAttributedCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedCompositeFigure.java, 96, 98
3
/**
   * Gets an attribute from the figure.
   */
3
  @Override
  public <T> T get(AttributeKey<T> key) {
    return key.get(attributes);
###
652, set, AbstractAttributedCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedCompositeFigure.java, 78, 83
5
/**
   * Sets an attribute of the figure.
   * AttributeKey name and semantics are defined by the class implementing
   * the figure interface.
   */
6
  @Override
  public <T> void set(AttributeKey<T> key, T newValue) {
    if (forbiddenAttributes == null || !forbiddenAttributes.contains(key)) {
      Object oldValue = attributes.put(key, newValue);
      setAttributeOnChildren(key, newValue);
      fireAttributeChanged(key, oldValue, newValue);
###
655, transform, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 290, 294
3
/**
   * Transforms the figure.
   */
5
  public void transform(AffineTransform tx) {
    for (Figure f : getChildren()) {
      f.transform(tx);
    }
    invalidate();
###
656, getLayouter, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 431, 432
9
/**
   * Get a Layouter object which encapsulated a layout
   * algorithm for this figure. Typically, a Layouter
   * accesses the child components of this figure and arranges
   * their graphical presentation.
   *
   *
   * @return layout strategy used by this figure
   */
2
  public Layouter getLayouter() {
    return layouter;
###
657, fireFigureRemoved, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 673, 686
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireFigureRemoved(Figure f, int zIndex) {
    CompositeFigureEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == CompositeFigureListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);
        }
        ((CompositeFigureListener) listeners[i + 1]).figureRemoved(event);
###
658, bringToFront, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 280, 283
5
/**
   * Brings a figure to the front of the drawing.
   *
   * @param figure that is part of the drawing
   */
4
  public synchronized void bringToFront(Figure figure) {
    if (basicRemove(figure) != -1) {
      basicAdd(figure);
      fireAreaInvalidated(figure.getDrawingArea());
###
659, fireFigureAdded, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 651, 664
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireFigureAdded(Figure f, int zIndex) {
    CompositeFigureEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == CompositeFigureListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);
        }
        ((CompositeFigureListener) listeners[i + 1]).figureAdded(event);
###
660, setLayouter, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 464, 465
12
/**
   * Set a Layouter object which encapsulated a layout
   * algorithm for this figure. Typically, a Layouter
   * accesses the child components of this figure and arranges
   * their graphical presentation. It is a good idea to set
   * the Layouter in the protected initialize() method
   * so it can be recreated if a GraphicalCompositeFigure is
   * read and restored from a StorableInput stream.
   *
   *
   * @param newLayouter  encapsulation of a layout algorithm.
   */
2
  public void setLayouter(Layouter newLayouter) {
    this.layouter = newLayouter;
###
661, removeAll, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 219, 221
5
/**
   * Removes all specified children.
   *
   * @see #add
   */
3
  public void removeAll(Collection<? extends Figure> figures) {
    for (Figure f : figures) {
      remove(f);
###
662, sendToBack, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 268, 271
5
/**
   * Sends a figure to the back of the composite figure.
   *
   * @param figure that is part of this composite figure
   */
4
  public synchronized void sendToBack(Figure figure) {
    if (basicRemove(figure) != -1) {
      basicAdd(0, figure);
      fireAreaInvalidated(figure.getDrawingArea());
###
664, basicRemoveAllChildren, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 246, 248
5
/**
   * Removes all children.
   *
   * @see #add
   */
3
  public void basicRemoveAllChildren() {
    for (Figure f : new LinkedList<Figure>(getChildren())) {
      basicRemove(f);
###
665, layout, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 441, 448
6
/**
   * A layout algorithm is used to define how the child components
   * should be laid out in relation to each other. The task for
   * layouting the child components for presentation is delegated
   * to a Layouter which can be plugged in at runtime.
   */
8
  public void layout() {
    if (getLayouter() != null) {
      Rectangle2D.Double bounds = getBounds();
      Point2D.Double p = new Point2D.Double(bounds.x, bounds.y);
      Rectangle2D.Double r = getLayouter().layout(
          this, p, p);
      setBounds(new Point2D.Double(r.x, r.y), new Point2D.Double(r.x + r.width, r.y + r.height));
      invalidate();
###
666, removeAllChildren, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 230, 238
5
/**
   * Removes all children.
   *
   * @see #add
   */
9
  public void removeAllChildren() {
    willChange();
    for (Figure f : new LinkedList<Figure>(getChildren())) {
      if (getDrawing() != null) {
        f.removeNotify(getDrawing());
      }
      int index = basicRemove(f);
    }
    changed();
###
667, getChildrenFrontToBack, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 330, 331
4
/**
   * Returns an iterator to iterate in
   * Z-order front to back over the children.
   */
2
  public java.util.List<Figure> getChildrenFrontToBack() {
    return children.size() == 0 ? new LinkedList<Figure>() : new ReversedList<Figure>(getChildren());
###
668, basicRemoveAll, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 257, 259
5
/**
   * Removes all children.
   *
   * @see #add
   */
3
  public void basicRemoveAll(Collection<? extends Figure> figures) {
    for (Figure f : figures) {
      basicRemove(f);
###
670, JColorWheel, JColorWheel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/JColorWheel.java, 84, 85
3
/**
   * Creates a new instance.
   */
2
  public JColorWheel() {
    this(new HSVRGBColorSystem());
###
671, JHarmonicColorWheel, JHarmonicColorWheel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/JHarmonicColorWheel.java, 128, 141
1
/** Creates new form. */
11
  public JHarmonicColorWheel() {
    super(new HSLRYBColorSystem());
    initComponents();
    setRadialComponentIndex(2);
    setVerticalComponentIndex(1);
    getModel().setComponentValue(1, 1f);
    setWheelInsets(new Insets(5, 5, 5, 5));
    modelHandler = new ModelHandler();
    DefaultHarmonicColorModel p = new DefaultHarmonicColorModel();
    setHarmonicColorModel(p);
    setToolTipText("");
###
675, draw, BezierNodeHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierNodeHandle.java, 67, 93
3
/**
   * Draws this handle.
   */
27
  @Override
  public void draw(Graphics2D g) {
    BezierFigure f = getOwner();
    int size = f.getNodeCount();
    boolean isClosed = f.isClosed();
    Color fillColor;
    Color strokeColor;
    if (getEditor().getTool().supportsHandleInteraction()) {
      fillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_FILL_COLOR);
      strokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_STROKE_COLOR);
    } else {
      fillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_FILL_COLOR_DISABLED);
      strokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_STROKE_COLOR_DISABLED);
    }
    if (size > index) {
      BezierPath.Node v = f.getNode(index);
      if (v.mask == 0 ||
          index == 0 && v.mask == BezierPath.C1_MASK && !isClosed ||
          index == size - 1 && v.mask == BezierPath.C2_MASK && !isClosed) {
        drawRectangle(g, fillColor, strokeColor);
      } else if (v.mask == BezierPath.C1_MASK ||
          v.mask == BezierPath.C2_MASK ||
          index == 0 && !isClosed ||
          index == size - 1 && !isClosed) {
        drawDiamond(g, fillColor, strokeColor);
      } else {
        drawCircle(g, fillColor, strokeColor);
###
676, BezierNodeHandle, BezierNodeHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierNodeHandle.java, 46, 47
1
/** Creates a new instance. */
2
  public BezierNodeHandle(BezierFigure owner, int index) {
    this(owner, index, owner);
###
677, ConnectorHandle, ConnectorHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectorHandle.java, 63, 66
1
/** Creates a new instance. */
4
  public ConnectorHandle(Connector connector, ConnectionFigure prototype) {
    super(connector.getOwner());
    this.connector = connector;
    this.prototype = prototype;
###
678, createConnection, ConnectorHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectorHandle.java, 193, 194
4
/**
   * Creates the ConnectionFigure. By default the figure prototype is
   * cloned.
   */
2
  protected ConnectionFigure createConnection() {
    return (ConnectionFigure) prototype.clone();
###
679, findConnectableConnector, ConnectorHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectorHandle.java, 228, 234
3
/**
   * Finds a connection end figure.
   */
6
  protected Connector findConnectableConnector(Figure connectableFigure, Point2D.Double p) {
    Connector target = (connectableFigure == null) ? null : connectableFigure.findConnector(p, getConnection());
    if ((connectableFigure != null) && connectableFigure.isConnectable() && !connectableFigure.includes(getOwner()) && getConnection().canConnect(connector, target)) {
      return target;
    }
    return null;
###
680, draw, CloseHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/CloseHandle.java, 47, 51
3
/**
   * Draws this handle.
   */
5
  public void draw(Graphics2D g) {
    drawRectangle(g, (pressed) ? Color.orange : Color.white, Color.black);
    Rectangle r = getBounds();
    g.drawLine(r.x, r.y, r.x+r.width, r.y+r.height);
    g.drawLine(r.x+r.width, r.y, r.x, r.y+r.height);
###
681, CloseHandle, CloseHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/CloseHandle.java, 32, 33
1
/** Creates a new instance. */
2
  public CloseHandle(Figure owner) {
    this(owner, new RelativeLocator(1.0, 0.0));
###
682, CloseHandle, CloseHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/CloseHandle.java, 36, 37
1
/** Creates a new instance. */
2
  public CloseHandle(Figure owner, Locator locator) {
    super(owner, locator);
###
683, FontSizeHandle, FontSizeHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/FontSizeHandle.java, 40, 41
1
/** Creates a new instance. */
2
  public FontSizeHandle(TextHolderFigure owner) {
    super(owner, new FontSizeLocator());
###
684, draw, BezierScaleHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierScaleHandle.java, 55, 58
3
/**
   * Draws this handle.
   */
4
  public void draw(Graphics2D g) {
    drawCircle(g, 
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.SCALE_HANDLE_FILL_COLOR),
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.SCALE_HANDLE_STROKE_COLOR)
###
685, BezierScaleHandle, BezierScaleHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierScaleHandle.java, 43, 44
1
/** Creates a new instance. */
2
  public BezierScaleHandle(BezierFigure owner) {
    super(owner);
###
687, DragHandle, DragHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/DragHandle.java, 44, 45
1
/** Creates a new instance. */
2
  public DragHandle(Figure owner) {
    super(owner);
###
688, setLocation, ConnectionEndHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java, 59, 62
3
/**
   * Sets the start point of the connection.
   */
4
  protected void setLocation(Point2D.Double p) {
    getOwner().willChange();
    getOwner().setEndPoint(p);
    getOwner().changed();
###
689, disconnect, ConnectionEndHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java, 47, 48
3
/**
   * Disconnects the start figure.
   */
2
  protected void disconnect() {
    getOwner().setEndConnector(null);
###
690, ConnectionEndHandle, ConnectionEndHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java, 33, 34
3
/**
   * Constructs the connection handle for the given start figure.
   */
2
  public ConnectionEndHandle(ConnectionFigure owner) {
    super(owner);
###
691, connect, ConnectionEndHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java, 40, 41
3
/**
   * Sets the start of the connection.
   */
2
  protected void connect(Connector c) {
    getOwner().setEndConnector(c);
###
692, BoundsOutlineHandle, BoundsOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BoundsOutlineHandle.java, 53, 86
5
/**
   * Creates a bounds outline handle for resizing or transforming a component.
   * 
   * @param owner
   */
34
  public BoundsOutlineHandle(Figure owner, boolean isTransformHandle, boolean isHoverHandle) {
    super(owner);
    if (isTransformHandle) {
      if (isHoverHandle) {
        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_HOVER;
        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_HOVER;
        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_HOVER;
        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_HOVER;
      } else {
        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1;
        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1;
        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2;
        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2;
      }
      stroke1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_DISABLED;
      strokeColor1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_DISABLED;
      stroke2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_DISABLED;
      strokeColor2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_DISABLED;
    } else {
      if (isHoverHandle) {
        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_HOVER;
        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_HOVER;
        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_HOVER;
        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_HOVER;
      } else {
        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1;
        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1;
        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2;
        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2;
      }
      stroke1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_DISABLED;
      strokeColor1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_DISABLED;
      stroke2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_DISABLED;
      strokeColor2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_DISABLED;
###
693, BoundsOutlineHandle, BoundsOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BoundsOutlineHandle.java, 95, 109
5
/**
   * Creates a bounds outline handle for resizing or transforming a component.
   *
   * @param owner
   */
15
  public BoundsOutlineHandle(Figure owner, //
      AttributeKey<Stroke> stroke1Enabled, AttributeKey<Color> strokeColor1Enabled,//
      AttributeKey<Stroke> stroke2Enabled, AttributeKey<Color> strokeColor2Enabled,//
      AttributeKey<Stroke> stroke1Disabled, AttributeKey<Color> strokeColor1Disabled,//
      AttributeKey<Stroke> stroke2Disabled, AttributeKey<Color> strokeColor2Disabled
      ) {
    super(owner);
    this.stroke1Enabled = stroke1Enabled;
    this.strokeColor1Enabled = strokeColor1Enabled;
    this.stroke2Enabled = stroke2Enabled;
    this.strokeColor2Enabled = strokeColor2Enabled;
    this.stroke1Disabled = stroke1Disabled;
    this.strokeColor1Disabled = strokeColor1Disabled;
    this.stroke2Disabled = stroke2Disabled;
    this.strokeColor2Disabled = strokeColor2Disabled;
###
694, BoundsOutlineHandle, BoundsOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BoundsOutlineHandle.java, 44, 45
5
/**
   * Creates a bounds outline handle for resizing a component.
   * 
   * @param owner
   */
2
  public BoundsOutlineHandle(Figure owner) {
    this(owner, false, false);
###
695, disconnect, ConnectionStartHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java, 47, 48
3
/**
   * Disconnects the start figure.
   */
2
  protected void disconnect() {
    getOwner().setStartConnector(null);
###
696, setLocation, ConnectionStartHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java, 59, 62
3
/**
   * Sets the start point of the connection.
   */
4
  protected void setLocation(Point2D.Double p) {
    getOwner().willChange();
    getOwner().setStartPoint(p);
    getOwner().changed();
###
697, removeFromSource, WeakPropertyChangeListener, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/WeakPropertyChangeListener.java, 76, 84
4
/**
   *  Method that can be subclassed to provide additional remove
   *  support.  Default implementation only supports StandardBeans.
   */
9
  protected void removeFromSource(PropertyChangeEvent event) {
    // Remove ourselves from the source
    Object src = event.getSource();
    try {
      src.getClass().getMethod("removePropertyChangeListener", new Class[] {PropertyChangeListener.class}).invoke(src, this);
    } catch (Exception ex) {
      InternalError ie = new InternalError("Could not remove WeakPropertyChangeListener from "+src+".");
      ie.initCause(ex);
      throw ie;
###
698, connect, ConnectionStartHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java, 40, 41
3
/**
   * Sets the start of the connection.
   */
2
  protected void connect(Connector c) {
    getOwner().setStartConnector(c);
###
699, ConnectionStartHandle, ConnectionStartHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java, 33, 34
3
/**
   * Constructs the connection handle for the given start figure.
   */
2
  public ConnectionStartHandle(ConnectionFigure owner) {
    super(owner);
###
700, setOpenFileHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 190, 205
8
/**
   * Pass this method an {@code ActionListener} equipped to
   * handle document events from the Finder.
   * Documents are registered with the Finder via the
   * CFBundleDocumentTypes dictionary in the application bundle's Info.plist.
   * <p>
   * The filename is passed as the {@code actionCommand}.
   */
15
  public static void setOpenFileHandler(ActionListener fileHandler) {
    setHandler(new OSXAdapter("handleOpenFile", fileHandler) {
      // Override OSXAdapter.callTarget to send information on the
      // file to be opened
      @Override
      public boolean callTarget(Object appleEvent) {
        if (appleEvent != null) {
          try {
            Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[]) null);
            String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);
            targetAction.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, filename));
          } catch (Exception ex) {
          }
        }
        return true;
###
701, setHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 241, 257
4
/** 
   * {@code setHandler} creates a Proxy object from the passed
   * {@code OSXAdapter} and adds it as an {@code ApplicationListener}.
   */
17
  @SuppressWarnings("unchecked")
  public static void setHandler(OSXAdapter adapter) {
    try {
      Class applicationClass = Class.forName("com.apple.eawt.Application");
      if (macOSXApplication == null) {
        macOSXApplication = applicationClass.getConstructor((Class[]) null).newInstance((Object[]) null);
      }
      Class applicationListenerClass = Class.forName("com.apple.eawt.ApplicationListener");
      Method addListenerMethod = applicationClass.getDeclaredMethod("addApplicationListener", new Class[]{applicationListenerClass});
      // Create a proxy object around this handler that can be reflectively added as an Apple ApplicationListener
      Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(), new Class[]{applicationListenerClass}, adapter);
      addListenerMethod.invoke(macOSXApplication, new Object[]{osxAdapterProxy});
    } catch (ClassNotFoundException cnfe) {
      System.err.println("This version of Mac OS X does not support the Apple EAWT.  ApplicationEvent handling has been disabled (" + cnfe + ")");
    } catch (Exception ex) {  // Likely a NoSuchMethodException or an IllegalAccessException loading/invoking eawt.Application methods
      System.err.println("Mac OS X Adapter could not talk to EAWT:");
      ex.printStackTrace();
###
702, callTarget, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 286, 295
4
/** Override this method to perform any operations on the event
   * that comes with the various callbacks.
   * See setOpenFileHandler above for an example.
   */
10
  public boolean callTarget(Object appleEvent) throws InvocationTargetException, IllegalAccessException {
    if (targetAction != null) {
      targetAction.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, proxySignature));
      return true;
    } else {
      Object result = targetMethod.invoke(targetObject, (Object[]) null);
      if (result == null) {
        return true;
      }
      return Boolean.valueOf(result.toString()).booleanValue();
###
703, setAboutHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 144, 156
4
/**
   * The action listener will be called when the user selects the About item
   * in the application menu.
   */
13
  public static void setAboutHandler(ActionListener aboutHandler) {
    boolean enableAboutMenu = (aboutHandler != null);
    if (enableAboutMenu) {
      setHandler(new OSXAdapter("handleAbout", aboutHandler));
    }
    // If we're setting a handler, enable the About menu item by calling
    // com.apple.eawt.Application reflectively
    try {
      Method enableAboutMethod = macOSXApplication.getClass().getDeclaredMethod("setEnabledAboutMenu", new Class[]{boolean.class});
      enableAboutMethod.invoke(macOSXApplication, new Object[]{Boolean.valueOf(enableAboutMenu)});
    } catch (Exception ex) {
      System.err.println("OSXAdapter could not access the About Menu");
      ex.printStackTrace();
###
704, setPreferencesHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 166, 178
6
/**
   * Pass this method an {@code ActionListener} equipped to
   * display application options.
   * They will be called when the Preferences menu item is selected from the
   * application menu.
   */
13
  public static void setPreferencesHandler(ActionListener prefsHandler) {
    boolean enablePrefsMenu = (prefsHandler != null);
    if (enablePrefsMenu) {
      setHandler(new OSXAdapter("handlePreferences", prefsHandler));
    }
    // If we're setting a handler, enable the Preferences menu item by calling
    // com.apple.eawt.Application reflectively
    try {
      Method enablePrefsMethod = macOSXApplication.getClass().getDeclaredMethod("setEnabledPreferencesMenu", new Class[]{boolean.class});
      enablePrefsMethod.invoke(macOSXApplication, new Object[]{Boolean.valueOf(enablePrefsMenu)});
    } catch (Exception ex) {
      System.err.println("OSXAdapter could not access the Preferences Menu");
      ex.printStackTrace();
###
705, isCorrectMethod, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 320, 321
5
/**
   * Compare the method that was called to the intended method when the
   * OSXAdapter instance was created (e.g. handleAbout, handleQuit,
   * handleOpenFile, etc.).
   */
2
  protected boolean isCorrectMethod(Method method, Object[] args) {
    return (proxySignature.equals(method.getName()) && args.length == 1);
###
706, setReOpenApplicationHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 121, 122
8
/**
   * Called when the application receives a Reopen Application event from the
   * Finder or another application. Usually this will come when a user clicks
   * on your application icon in the Dock. If there is any special code that
   * needs to run when your user clicks on your application icon in the Dock
   * or when a Reopen Application event is sent from another application,
   * include that code as part of this handler.
   */
2
  public static void setReOpenApplicationHandler(ActionListener reopenHandler) {
    setHandler(new OSXAdapter("handleReOpenApplication", reopenHandler));
###
707, setQuitHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 128, 135
4
/**
   * The action listener will be called when the Quit menu item is selected
   * from the application menu.
   */
7
  public static void setQuitHandler(ActionListener aboutHandler) {
    setHandler(new OSXAdapter("handleQuit", aboutHandler) {
      // Override OSXAdapter.callTarget to always return false.
      @Override
      public boolean callTarget(Object appleEvent)  throws InvocationTargetException, IllegalAccessException {
        super.callTarget(appleEvent);
        return false;
###
708, OSXAdapter, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 266, 269
5
/** 
   * Each OSXAdapter has the name of the EAWT method it intends to listen for
   * (handleAbout, for example), the Object that will ultimately perform the
   * task, and the Method to be called on that Object.
   */
4
  protected OSXAdapter(String proxySignature, Object target, Method handler) {
    this.proxySignature = proxySignature;
    this.targetObject = target;
    this.targetMethod = handler;
###
709, setApplicationEventHandled, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 330, 338
6
/** 
   * It is important to mark the ApplicationEvent as handled and cancel the
   * default behavior.
   * This method checks for a boolean result from the proxy method and sets 
   * the event accordingly.
   */
9
  protected void setApplicationEventHandled(Object event, boolean handled) {
    if (event != null) {
      try {
        Method setHandledMethod = event.getClass().getDeclaredMethod("setHandled", new Class[]{boolean.class});
        // If the target method returns a boolean, use that as a hint
        setHandledMethod.invoke(event, new Object[]{Boolean.valueOf(handled)});
      } catch (Exception ex) {
        System.err.println("OSXAdapter was unable to handle an ApplicationEvent: " + event);
        ex.printStackTrace();
###
710, setPrintFileHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 217, 232
8
/**
   * Pass this method an {@code ActionListener} equipped to
   * handle document events from the Finder.
   * Documents are registered with the Finder via the
   * CFBundleDocumentTypes dictionary in the application bundle's Info.plist.
   * <p>
   * The filename is passed as the {@code actionCommand}.
   */
15
  public static void setPrintFileHandler(ActionListener fileHandler) {
    setHandler(new OSXAdapter("handlePrintFile", fileHandler) {
      // Override OSXAdapter.callTarget to send information on the
      // file to be opened
      @Override
      public boolean callTarget(Object appleEvent) {
        if (appleEvent != null) {
          try {
            Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[]) null);
            String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);
            targetAction.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, filename));
          } catch (Exception ex) {
          }
        }
        return true;
###
711, setOpenApplicationHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 110, 111
9
/**
   * The action listener will be called when the application receives an Open
   * Application event from the Finder or another application. Usually this
   * will come from the Finder when a user double-clicks your application
   * icon. If there is any special code that you want to run when you user
   * launches your application from the Finder or by sending an Open
   * Application event from another application, include that code as part of
   * this handler. The Open Application event is sent after AWT has been loaded.
   */
2
  public static void setOpenApplicationHandler(ActionListener openHandler) {
    setHandler(new OSXAdapter("handleOpenApplication", openHandler));
###
712, OSXAdapter, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 277, 279
5
/**
   * Each OSXAdapter has the name of the EAWT method it intends to listen for
   * (handleAbout, for example), the Object that will ultimately perform the
   * task, and the Method to be called on that Object.
   */
3
  protected OSXAdapter(String proxySignature, ActionListener handler) {
    this.proxySignature = proxySignature;
    this.targetAction = handler;
###
713, invoke, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 304, 312
5
/**
   * InvocationHandler implementation.
   * This is the entry point for our proxy object; it is called every time an 
   * ApplicationListener method is invoked.
   */
9
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (isCorrectMethod(method, args)) {
      boolean handled = callTarget(args[0]);
      setApplicationEventHandled(args[0], handled);
    }
    // All of the ApplicationListener methods are void;
    // return null regardless of what happens
    return null;
###
714, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 65, 66
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, int oldValue, int newValue) {
    this(source, propertyName, Integer.TYPE, oldValue, newValue);
###
715, addEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 156, 166
6
/** Adds the specified edit to this one, if it is a {@code PropertyChangeEdit}
   * from the same owner and the same property.
   *
   * @param anEdit Edit to be added.
   * @return True if added.
   */
10
  @Override
  public boolean addEdit(UndoableEdit anEdit) {
    if (anEdit instanceof PropertyChangeEdit) {
      PropertyChangeEdit that = (PropertyChangeEdit) anEdit;
      if (that.source == this.source && that.propertyName.equals(this.propertyName)) {
        this.newValue = that.newValue;
        return true;
      }
    }
    return false;
###
716, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 85, 86
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, char oldValue, char newValue) {
    this(source, propertyName, Character.TYPE, oldValue, newValue);
###
717, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 75, 76
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, float oldValue, float newValue) {
    this(source, propertyName, Float.TYPE, oldValue, newValue);
###
718, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 60, 61
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, boolean oldValue, boolean newValue) {
    this(source, propertyName, Boolean.TYPE, oldValue, newValue);
###
719, undo, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 110, 118
1
/** Undoes the change. */
9
  @Override
  public void undo() throws CannotRedoException {
    super.undo();
    try {
      getSetter().invoke(source, oldValue);
    } catch (Exception e) {
      InternalError ie = new InternalError("Couldn't invoke setter for property \"" + propertyName + "\" in " + source);
      ie.initCause(e);
      throw ie;
###
720, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 70, 71
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, long oldValue, long newValue) {
    this(source, propertyName, Long.TYPE, oldValue, newValue);
###
721, redo, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 123, 131
1
/** Redoes the change. */
9
  @Override
  public void redo() throws CannotRedoException {
    super.redo();
    try {
      getSetter().invoke(source, newValue);
    } catch (Exception e) {
      InternalError ie = new InternalError("Couldn't invoke setter for property \"" + propertyName + "\" in " + source);
      ie.initCause(e);
      throw ie;
###
722, getSetter, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 99, 105
5
/**
   * Returns the setter for the property.
   *
   * @return the setter method.
   */
7
  protected Method getSetter() {
    try {
      return source.getClass().getMethod("set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1), type);
    } catch (Exception e) {
      InternalError ie = new InternalError("Couldn't find setter for property \"" + propertyName + "\" in " + source);
      ie.initCause(e);
      throw ie;
###
723, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 80, 81
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, double oldValue, double newValue) {
    this(source, propertyName, Double.TYPE, oldValue, newValue);
###
724, getPresentationName, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 139, 141
4
/** Returns the presentation name of the undoable edit.
   * This is the same as the property name, unless you have set a different
   * presentation name.
   */
3
  @Override
  public String getPresentationName() {
    return presentationName;
###
725, setPresentationName, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 146, 147
2
/** Sets the presentation name of the undoable edit.
   */
2
  public void setPresentationName(String presentationName) {
    this.presentationName = presentationName;
###
726, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 90, 91
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, String oldValue, String newValue) {
    this(source, propertyName, String.class, oldValue, newValue);
###
727, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 50, 55
1
/** Creates a new PropertyChangeEdit. */
6
  public <T> PropertyChangeEdit(Object source, String propertyName, Class<T> type, T oldValue, T newValue) {
    this.source = source;
    this.propertyName = this.presentationName = propertyName;
    this.type = type;
    this.oldValue = oldValue;
    this.newValue = newValue;
###
728, removePropertyChangeListener, AbstractBean, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java, 79, 93
6
/** Removes a {@code PropertyChangeListener}. If the listener was added
   * wrapped into a {@code WeakPropertyChangeListener}, the
   * {@code WeakPropertyChangeListener} is removed.
   *
   * @param listener
   */
15
  public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {
    // Removes a property change listener from our list.
    // We need a somewhat complex procedure here in case a listener
    // has been registered using addPropertyChangeListener(propertyName, new WeakPropertyChangeListener(listener));
    for (PropertyChangeListener l : propertySupport.getPropertyChangeListeners(propertyName)) {
      if (l == listener) {
        propertySupport.removePropertyChangeListener(propertyName, l);
        break;
      }
      if (l instanceof WeakPropertyChangeListener) {
        WeakPropertyChangeListener wl = (WeakPropertyChangeListener) l;
        PropertyChangeListener target = wl.getTarget();
        if (target == listener) {
          propertySupport.removePropertyChangeListener(propertyName, l);
          break;
###
729, addPropertyChangeListener, AbstractBean, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java, 43, 44
4
/** Adds a {@code PropertyChangeListener} which can optionally be wrapped
   * into a {@code WeakPropertyChangeListener}.
   * @param listener
   */
2
  public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {
    propertySupport.addPropertyChangeListener(propertyName, listener);
###
730, addPropertyChangeListener, AbstractBean, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java, 35, 36
4
/** Adds a {@code PropertyChangeListener} which can optionally be wrapped
   * into a {@code WeakPropertyChangeListener}.
   * @param listener
   */
2
  public void addPropertyChangeListener(PropertyChangeListener listener) {
    propertySupport.addPropertyChangeListener(listener);
###
731, removePropertyChangeListener, AbstractBean, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java, 53, 67
6
/** Removes a {@code PropertyChangeListener}. If the listener was added
   * wrapped into a {@code WeakPropertyChangeListener}, the
   * {@code WeakPropertyChangeListener} is removed.
   *
   * @param listener
   */
15
  public void removePropertyChangeListener(PropertyChangeListener listener) {
    // Removes a property change listener from our list.
    // We need a somewhat complex procedure here in case a listener
    // has been registered using addPropertyChangeListener(new WeakPropertyChangeListener(listener));
    for (PropertyChangeListener l : propertySupport.getPropertyChangeListeners()) {
      if (l == listener) {
        propertySupport.removePropertyChangeListener(l);
        break;
      }
      if (l instanceof WeakPropertyChangeListener) {
        WeakPropertyChangeListener wl = (WeakPropertyChangeListener) l;
        PropertyChangeListener target = wl.getTarget();
        if (target == listener) {
          propertySupport.removePropertyChangeListener(l);
          break;
###
732, addEdgeResizeHandles, ResizeHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ResizeHandleKit.java, 58, 62
4
/**
   * Fills the given Vector with handles at each
   * the north, south, east, and west of the figure.
   */
5
  static public void addEdgeResizeHandles(Figure f, Collection<Handle> handles) {
    handles.add(south(f));
    handles.add(north(f));
    handles.add(east(f));
    handles.add(west(f));
###
734, addCornerResizeHandles, ResizeHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ResizeHandleKit.java, 47, 51
4
/**
   * Creates handles for each corner of a
   * figure and adds them to the provided collection.
   */
5
  static public void addCornerResizeHandles(Figure f, Collection<Handle> handles) {
    handles.add(southEast(f));
    handles.add(southWest(f));
    handles.add(northEast(f));
    handles.add(northWest(f));
###
753, NullHandle, NullHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/NullHandle.java, 34, 35
1
/** Creates a new instance. */
2
  public NullHandle(Figure owner, Locator locator) {
    super(owner, locator);
###
754, addLeadHandles, NullHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/NullHandle.java, 56, 60
4
/**
   * Creates handles for each lead of a
   * figure and adds them to the provided collection.
   */
5
  static public void addLeadHandles(Figure f, Collection<Handle> handles) {
    handles.add(new NullHandle(f, new RelativeLocator(0f,0f)));
    handles.add(new NullHandle(f, new RelativeLocator(0f,1f)));
    handles.add(new NullHandle(f, new RelativeLocator(1f,0f)));
    handles.add(new NullHandle(f, new RelativeLocator(1f,1f)));
###
755, RotateHandle, RotateHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/RotateHandle.java, 30, 31
1
/** Creates a new instance. */
2
  public RotateHandle(Figure owner) {
    super(owner);
###
756, draw, MoveHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/MoveHandle.java, 63, 72
7
/**
   * Draws this handle.
   * <p>
   * If the figure is transformable, the handle is drawn as a filled rectangle.
   * If the figure is not transformable, the handle is drawn as an unfilled
   * rectangle.
   */
10
  @Override
  public void draw(Graphics2D g) {
    if (getOwner().isTransformable()) {
      drawRectangle(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.MOVE_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.MOVE_HANDLE_STROKE_COLOR));
    } else {
      drawRectangle(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.NULL_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.NULL_HANDLE_STROKE_COLOR));
###
757, addMoveHandles, MoveHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/MoveHandle.java, 49, 53
4
/**
   * Creates handles for each corner of a
   * figure and adds them to the provided collection.
   */
5
  static public void addMoveHandles(Figure f, Collection<Handle> handles) {
    handles.add(southEast(f));
    handles.add(southWest(f));
    handles.add(northEast(f));
    handles.add(northWest(f));
###
758, MoveHandle, MoveHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/MoveHandle.java, 41, 42
1
/** Creates a new instance. */
2
  public MoveHandle(Figure owner, Locator locator) {
    super(owner, locator);
###
759, TextOverflowHandle, TextOverflowHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TextOverflowHandle.java, 35, 36
1
/** Creates a new instance. */
2
  public TextOverflowHandle(TextHolderFigure owner) {
    super(owner);
###
760, draw, TextOverflowHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TextOverflowHandle.java, 50, 59
3
/**
   * Draws this handle.
   */
10
  @Override public void draw(Graphics2D g) {
    if (getOwner().isTextOverflow()) {
    drawRectangle(g, 
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_FILL_COLOR),
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR)
        );
      g.setColor((Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR));
      Rectangle r = basicGetBounds();
      g.drawLine(r.x+1, r.y+1, r.x+r.width-2, r.y+r.height-2);
      g.drawLine(r.x+r.width-2, r.y+1, r.x+1, r.y+r.height-2);
###
763, CMYKICCColorSystem, CMYKICCColorSystem, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/CMYKICCColorSystem.java, 39, 45
3
/**
   * Creates a new instance.
   */
7
  public CMYKICCColorSystem() {
    try {
      read(getClass().getResourceAsStream("Generic CMYK Profile.icc"));
    } catch (IOException e) {
      InternalError err = new InternalError("Couldn't load \"Generic CMYK Profile.icc\".");
      err.initCause(e);
      throw err;
###
764, RoundRectangleRadiusHandle, RoundRectangleRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/RoundRectangleRadiusHandle.java, 41, 42
1
/** Creates a new instance. */
2
  public RoundRectangleRadiusHandle(Figure owner) {
    super(owner);
###
765, draw, RoundRectangleRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/RoundRectangleRadiusHandle.java, 48, 57
3
/**
   * Draws this handle.
   */
10
  @Override
  public void draw(Graphics2D g) {
    if (getEditor().getTool().supportsHandleInteraction()) {
      drawDiamond(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR));
    } else {
      drawDiamond(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR_DISABLED),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR_DISABLED));
###
766, ColorTrackImageProducer, ColorTrackImageProducer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorTrackImageProducer.java, 41, 56
1
/** Creates a new instance. */
16
  public ColorTrackImageProducer(int w, int h, int trackBuffer, boolean isHorizontal) {
    super(w, h, null, 0, w);
    pixels = new int[w*h];
    this.w = w;
    this.h = h;
    // trackBuffer must be even
    this.trackBuffer = (trackBuffer % 2 == 1) ? trackBuffer - 1 : trackBuffer;
    this.componentIndex = componentIndex;
    this.isHorizontal = isHorizontal;
    newPixels(pixels, new DirectColorModel(24,
              0x00ff0000,  // Red
              0x0000ff00,  // Green
              0x000000ff  // Blue
              )
              , 0, w);
    setAnimated(true);
###
770, getTickLength, ColorSliderUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorSliderUI.java, 361, 362
6
/**
   * Gets the height of the tick area for horizontal sliders and the width of the
   * tick area for vertical sliders.  BasicSliderUI uses the returned value to
   * determine the tick area rectangle.  If you want to give your ticks some room,
   * make this larger than you need and paint your ticks away from the sides in paintTicks().
   */
2
  protected int getTickLength() {
    return 4;
###
771, ColorSliderUI, ColorSliderUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorSliderUI.java, 47, 48
1
/** Creates a new instance. */
2
  public ColorSliderUI(JSlider b)   {
    super(b);
###
772, mousePressed, QuaquaTrackListener, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorSliderUI.java, 438, 462
7
/**
     * If the mouse is pressed above the "thumb" component
     * then reduce the scrollbars value by one page ("page up"),
     * otherwise increase it by one page.  If there is no
     * thumb then page up if the mouse is in the upper half
     * of the track.
     */
25
    public void mousePressed(MouseEvent e) {
      if ( !slider.isEnabled() )
        return;
      
      currentMouseX = e.getX();
      currentMouseY = e.getY();
      
      if (slider.isRequestFocusEnabled()) {
        slider.requestFocus();
      }
      
      // Clicked inside the Thumb area?
      if (thumbRect.contains(currentMouseX, currentMouseY) ) {
        super.mousePressed(e);
      } else {
        Dimension sbSize = slider.getSize();
        int direction = POSITIVE_SCROLL;
        
        switch ( slider.getOrientation() ) {
          case JSlider.VERTICAL:
            slider.setValue(valueForYPosition(currentMouseY));
            break;
          case JSlider.HORIZONTAL:
            slider.setValue(valueForXPosition(currentMouseX));
            break;
###
773, ColorWheelChooser, ColorWheelChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorWheelChooser.java, 39, 56
3
/**
   * Creates a new instance.
   */
18
  public ColorWheelChooser() {
    initComponents();
    
        int textSliderGap = UIManager.getInt("ColorChooser.textSliderGap");
    if (textSliderGap != 0) {
      BorderLayout layout = (BorderLayout) getLayout();
      layout.setHgap(textSliderGap);
}
    
    colorWheel = new JColorWheel();
    add(colorWheel);
    
    ccModel.configureSlider(2, brightnessSlider);
    colorWheel.setModel(ccModel);
    
    ccModel.addChangeListener(new ChangeListener() {
      public void stateChanged(ChangeEvent evt) {
        setColorToModel(ccModel.getColor());
###
774, initComponents, ColorWheelChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorWheelChooser.java, 66, 74
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
7
  private void initComponents() {//GEN-BEGIN:initComponents
    brightnessSlider = new javax.swing.JSlider();
    setLayout(new java.awt.BorderLayout());
    brightnessSlider.setMajorTickSpacing(50);
    brightnessSlider.setOrientation(javax.swing.JSlider.VERTICAL);
    brightnessSlider.setPaintTicks(true);
    add(brightnessSlider, java.awt.BorderLayout.EAST);
###
788, SerializationInputOutputFormat, SerializationInputOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/SerializationInputOutputFormat.java, 73, 74
3
/** Creates a new instance with format name "Drawing", file extension "xml"
   * and mime type "image/x-jhotdraw".
   */
2
  public SerializationInputOutputFormat() {
    this("Drawing", "ser", new DefaultDrawing());
###
789, ImageInputFormat, ImageInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageInputFormat.java, 93, 95
8
/** Creates a new image input format for the specified image format.
   *
   * @param formatName The format name for the javax.imageio.ImageIO object.
   * @param description The format description to be used for the file filter.
   * @param fileExtension The file extension to be used for the file filter.
   * @param mimeType The mime type used for filtering data flavors from
   * Transferable objects.
   */
3
  public ImageInputFormat(ImageHolderFigure prototype, String formatName, String description, String fileExtension,
      String mimeType) {
    this(prototype, formatName, description, new String[]{fileExtension}, new String[]{mimeType});
###
790, ImageInputFormat, ImageInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageInputFormat.java, 81, 82
2
/** Creates a new image input format for all formats supported by
   * {@code javax.imageio.ImageIO}. */
2
  public ImageInputFormat(ImageHolderFigure prototype) {
    this(prototype, "Image", "Image", ImageIO.getReaderFileSuffixes(), ImageIO.getReaderMIMETypes());
###
803, north, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 81, 82
3
/**
   * North.
   */
2
  static public Locator north() {
    return new RelativeDecoratorLocator(0.5, 0.0);
###
804, addCornerTransformHandles, TransformHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 47, 51
4
/**
   * Creates handles for each corner of a
   * figure and adds them to the provided collection.
   */
5
  static public void addCornerTransformHandles(Figure f, Collection<Handle> handles) {
    handles.add(southEast(f));
    handles.add(southWest(f));
    handles.add(northEast(f));
    handles.add(northWest(f));
###
805, RelativeDecoratorLocator, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 46, 47
1
/** Creates a new instance. */
2
  public RelativeDecoratorLocator(double relativeX, double relativeY) {
    super(relativeX, relativeY);
###
806, addScaleMoveTransformHandles, TransformHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 68, 70
3
/**
   * Adds handles for scaling and moving a Figure.
   */
3
  static public void addScaleMoveTransformHandles(Figure f, Collection<Handle> handles) {
    addCornerTransformHandles(f, handles);
    addEdgeTransformHandles(f, handles);
###
807, northWest, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 102, 103
3
/**
   * North west.
   */
2
  static public Locator northWest() {
    return new RelativeDecoratorLocator(0.0, 0.0);
###
808, addEdgeTransformHandles, TransformHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 58, 62
4
/**
   * Fills the given Vector with handles at each
   * the north, south, east, and west of the figure.
   */
5
  static public void addEdgeTransformHandles(Figure f, Collection<Handle> handles) {
    handles.add(south(f));
    handles.add(north(f));
    handles.add(east(f));
    handles.add(west(f));
###
809, west, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 88, 89
3
/**
   * West.
   */
2
  static public Locator west() {
    return new RelativeDecoratorLocator(0.0, 0.5);
###
810, northEast, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 95, 96
3
/**
   * North east.
   */
2
  static public Locator northEast() {
    return new RelativeDecoratorLocator(1.0, 0.0);
###
811, addGroupTransformHandles, TransformHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 86, 95
3
/**
   * Adds handles for scaling, moving, rotating and shearing a Figure.
   */
10
  static public void addGroupTransformHandles(Figure f, Collection<Handle> handles) {
    handles.add(new BoundsOutlineHandle(f,
        GROUP_BOUNDS_STROKE_1, GROUP_BOUNDS_COLOR_1,
        GROUP_BOUNDS_STROKE_2, GROUP_BOUNDS_COLOR_2,
        GROUP_BOUNDS_STROKE_1_DISABLED, GROUP_BOUNDS_COLOR_1_DISABLED,
        GROUP_BOUNDS_STROKE_2_DISABLED, GROUP_BOUNDS_COLOR_2_DISABLED
        ));
    addCornerTransformHandles(f, handles);
    addEdgeTransformHandles(f, handles);
    handles.add(new RotateHandle(f));
###
812, south, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 109, 110
3
/**
   * South.
   */
2
  static public Locator south() {
    return new RelativeDecoratorLocator(0.5, 1.0);
###
813, addTransformHandles, TransformHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 76, 80
3
/**
   * Adds handles for scaling, moving, rotating and shearing a Figure.
   */
5
  static public void addTransformHandles(Figure f, Collection<Handle> handles) {
    handles.add(new BoundsOutlineHandle(f, true, false));
    addCornerTransformHandles(f, handles);
    addEdgeTransformHandles(f, handles);
    handles.add(new RotateHandle(f));
###
814, southWest, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 123, 124
3
/**
   * South west.
   */
2
  static public Locator southWest() {
    return new RelativeDecoratorLocator(0.0, 1.0);
###
815, southEast, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 116, 117
3
/**
   * South east.
   */
2
  static public Locator southEast() {
    return new RelativeDecoratorLocator(1.0, 1.0);
###
817, draw, TransformHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 159, 170
3
/**
     * Draws this handle.
     */
12
    public void draw(Graphics2D g) {
      if (getEditor().getTool().supportsHandleInteraction()) {
        //drawArc(g);
        
        drawDiamond(g,
            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_FILL_COLOR),
            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_STROKE_COLOR));
        
        } else {
        drawDiamond(g,
            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_FILL_COLOR_DISABLED),
            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_STROKE_COLOR_DISABLED));        
###
818, BezierTool, BezierTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/BezierTool.java, 60, 61
1
/** Creates a new instance. */
2
  public BezierTool(BezierFigure prototype) {
    this(prototype, null);
###
819, BezierTool, BezierTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/BezierTool.java, 65, 66
1
/** Creates a new instance. */
2
  public BezierTool(BezierFigure prototype, Map<AttributeKey, Object> attributes) {
    this(prototype, attributes, null);
###
820, AbstractTool, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 74, 77
1
/** Creates a new instance. */
4
  public AbstractTool() {
    editorProxy = new DrawingEditorProxy();
    setInputMap(createInputMap());
    setActionMap(createActionMap());
###
821, fireToolStarted, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 316, 329
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireToolStarted(DrawingView view) {
    ToolEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == ToolListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new ToolEvent(this, view, new Rectangle(0, 0, -1, -1));
        }
        ((ToolListener) listeners[i + 1]).toolStarted(event);
###
822, createInputMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 264, 265
5
/** Override this method to create a tool-specific input map, which
   * overrides the input map of the drawing edtior.
   * <p>
   * The implementation of this class returns null.
   */
2
  protected InputMap createInputMap() {
    return null;
###
823, createActionMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 273, 274
5
/** Override this method to create a tool-specific action map, which
   * overrides the action map of the drawing edtior.
   * <p>
   * The implementation of this class returns null.
   */
2
  protected ActionMap createActionMap() {
    return null;
###
825, editDelete, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 170, 171
5
/**
   * Deletes the selection.
   * Depending on the tool, this could be selected figures, selected points
   * or selected text.
   */
2
  public void editDelete() {
    getView().getDrawing().removeAll(getView().getSelectedFigures());
###
826, fireToolDone, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 338, 351
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireToolDone() {
    ToolEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == ToolListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new ToolEvent(this, getView(), new Rectangle(0, 0, -1, -1));
        }
        ((ToolListener) listeners[i + 1]).toolDone(event);
###
827, DOMStorableInputOutputFormat, DOMStorableInputOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/DOMStorableInputOutputFormat.java, 81, 92
7
/** Creates a new instance using the specified parameters.
   *
   * @param factory The factory for creating Figures from XML elements.
   * @param description The format description to be used for the file filter.
   * @param fileExtension The file extension to be used for file filter.
   * @param mimeType The Mime Type is used for clipboard access.
   */
12
  public DOMStorableInputOutputFormat(
      DOMFactory factory,
      String description, String fileExtension, String mimeType) {
    this.factory = factory;
    this.fileExtension = fileExtension;
    this.mimeType = mimeType;
    try {
      this.dataFlavor = new DataFlavor(mimeType);
    } catch (ClassNotFoundException ex) {
      InternalError error = new InternalError("Unable to create data flavor for mime type:" + mimeType);
      error.initCause(ex);
      throw error;
###
828, fireAreaInvalidated, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 371, 384
4
/**
   * Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireAreaInvalidated(Rectangle invalidatedArea) {
    ToolEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == ToolListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new ToolEvent(this, getView(), invalidatedArea);
        }
        ((ToolListener) listeners[i + 1]).areaInvalidated(event);
###
829, DOMStorableInputOutputFormat, DOMStorableInputOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/DOMStorableInputOutputFormat.java, 70, 71
3
/** Creates a new instance with format name "Drawing", file extension "xml"
   * and mime type "image/x-jhotdraw".
   */
2
  public DOMStorableInputOutputFormat(DOMFactory factory) {
    this(factory, "Drawing", "xml", "image/x-jhotdraw");
###
830, getInputMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 146, 147
3
/**
   * Gets the input map of the Tool
   */
2
  public InputMap getInputMap() {
    return inputMap;
###
832, fireBoundsInvalidated, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 414, 428
4
/**
   * Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireBoundsInvalidated(Rectangle invalidatedArea) {
    ToolEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == ToolListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new ToolEvent(this, getView(), invalidatedArea);
        }
        ((ToolListener) listeners[i + 1]).boundsInvalidated(event);
###
834, setActionMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 154, 155
4
/**
   * Sets the ActionMap for the Tool.
   * @see #keyPressed
   */
2
  public void setActionMap(ActionMap newValue) {
    actionMap = newValue;
###
836, keyPressed, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 220, 254
7
/**
   * The Tool uses the InputMap to determine what to do, when a key is pressed.
   * If the corresponding value of the InputMap is a String, the ActionMap
   * of the tool is used, to find the action to be performed.
   * If the corresponding value of the InputMap is a ActionListener, the
   * actionPerformed method of the ActionListener is performed.
   */
34
  public void keyPressed(KeyEvent evt) {
    if (!evt.isConsumed()) {
      if (evt.getSource() instanceof Container) {
        editor.setActiveView(editor.findView((Container) evt.getSource()));
      }
      Object obj = null;
      if (inputMap != null) {
        // Lookup the input map of the tool
        obj = inputMap.get(KeyStroke.getKeyStroke(evt.getKeyCode(), evt.getModifiers(), false));
      }
      if (obj == null) {
        // Fall back to the input map of the drawing editor
        InputMap im = editor.getInputMap();
        if (im != null) {
          obj = im.get(KeyStroke.getKeyStroke(evt.getKeyCode(), evt.getModifiers(), false));
        }
      }
      ActionListener al = null;
      if (obj instanceof ActionListener) {
        al = (ActionListener) obj;
      } else if (obj != null) {
        // Lookup the action map of the tool
        if (actionMap != null) {
          al = actionMap.get(obj);
        }
        if (al == null) {
          // Fall back to the action map of the drawing editor
          al = editor.getActionMap().get(obj);
        }
      }
      if (al != null) {
        evt.consume();
        al.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, "tool", evt.getWhen(), evt.getModifiers()));
        fireToolDone();
###
838, fireAreaInvalidated, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 360, 364
4
/**
   * Notify all listenerList that have registered interest for
   * notification on this event type.
   */
5
  protected void fireAreaInvalidated(Rectangle2D.Double r) {
    Point p1 = getView().drawingToView(new Point2D.Double(r.x, r.y));
    Point p2 = getView().drawingToView(new Point2D.Double(r.x + r.width, r.y + r.height));
    fireAreaInvalidated(
        new Rectangle(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y));
###
839, getActionMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 161, 162
3
/**
   * Gets the action map of the Tool
   */
2
  public ActionMap getActionMap() {
    return actionMap;
###
840, maybeFireBoundsInvalidated, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 396, 406
7
/**
   * Notify all listenerList that have registered interest for
   * notification on this event type.
   *
   * Note: This method only fires an event, if the invalidated area
   * is outside of the canvas bounds.
   */
11
  protected void maybeFireBoundsInvalidated(Rectangle invalidatedArea) {
    Drawing d = getDrawing();
    Rectangle2D.Double canvasBounds = new Rectangle2D.Double(0, 0, 0, 0);
    if (d.get(CANVAS_WIDTH) != null) {
      canvasBounds.width += d.get(CANVAS_WIDTH);
    }
    if (d.get(CANVAS_HEIGHT) != null) {
      canvasBounds.height += d.get(CANVAS_HEIGHT);
    }
    if (!canvasBounds.contains(invalidatedArea)) {
       fireBoundsInvalidated(invalidatedArea);
###
841, setInputMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 139, 140
6
/**
   * Sets the InputMap for the Tool.
   *
   * @see #keyPressed
   * @see #setActionMap
   */
2
  public void setInputMap(InputMap newValue) {
    inputMap = newValue;
###
842, ImageOutputFormat, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 56, 57
1
/** Creates a new image output format for Portable Network Graphics PNG. */
2
  public ImageOutputFormat() {
    this("PNG", "Portable Network Graphics (PNG)", "png", BufferedImage.TYPE_INT_ARGB);
###
843, write, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 115, 117
5
/**
   * Writes the drawing to the specified output stream.
   * This method applies the specified transform to the drawing, and draws
   * it on an image of the specified size.
   */
3
  public void write(OutputStream out, Drawing drawing,
      AffineTransform drawingTransform, Dimension imageSize) throws IOException {
    write(out, drawing, drawing.getChildren(), drawingTransform, imageSize);
###
844, createTransferable, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 125, 126
5
/**
   * Writes the drawing to the specified output stream.
   * This method ensures that all figures of the drawing are visible on
   * the image.
   */
2
  public Transferable createTransferable(Drawing drawing, java.util.List<Figure> figures, double scaleFactor) throws IOException {
    return new ImageTransferable(toImage(drawing, figures, scaleFactor, true));
###
845, ImageOutputFormat, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 68, 73
8
/** Creates a new image output format for the specified image format.
   *
   * @param formatName The format name for the javax.imageio.ImageIO object.
   * @param description The format description to be used for the file filter.
   * @param fileExtension The file extension to be used for file filter.
   * @param bufferedImageType The BufferedImage type used to produce the image.
   *      The value of this parameter must match with the format name.
   */
6
  public ImageOutputFormat(String formatName, String description, String fileExtension,
      int bufferedImageType) {
    this.formatName = formatName;
    this.description = description;
    this.fileExtension = fileExtension;
    this.imageType = bufferedImageType;
###
846, write, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 107, 108
5
/**
   * Writes the drawing to the specified output stream.
   * This method ensures that all figures of the drawing are visible on
   * the image.
   */
2
  public void write(OutputStream out, Drawing drawing) throws IOException {
    write(out, drawing, drawing.getChildren(), null, null);
###
847, toImage, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 221, 272
9
/**
   * Creates a BufferedImage from the specified list of figures.
   *
   * @param drawing The drawing.
   * @param figures A list of figures of the drawing.
   * @param transform The AffineTransform to be used when drawing
   * the figures.
   * @param imageSize The width and height of the image.
   */
51
  public BufferedImage toImage(
      Drawing drawing,
      java.util.List<Figure> figures,
      AffineTransform transform,
      Dimension imageSize) {
    
    // Create the buffered image and clear it
    Color background = drawing.get(CANVAS_FILL_COLOR);
    double opacity = drawing.get(CANVAS_FILL_OPACITY);
    if (background == null) {
      background = new Color(0xff, 0xff, 0xff, 0x0);
    } else {
      background = new Color(background.getRed(), background.getGreen(), background.getBlue(), (int)(background.getAlpha() * opacity));
    }
    BufferedImage buf = new BufferedImage(
        Math.max(1,imageSize.width), Math.max(1,imageSize.height),
        (background.getAlpha() == 255) ? BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB
        );
    Graphics2D g = buf.createGraphics();
    
    // Clear the buffered image with the background color
    Composite savedComposite = g.getComposite();
    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));
    g.setColor(background);
    g.fillRect(0,0,buf.getWidth(),buf.getHeight());
    g.setComposite(savedComposite);
    
    // Draw the figures onto the buffered image
    setRenderingHints(g);
    g.transform(transform);
    for (Figure f : figures) {
      f.draw(g);
    }
    g.dispose();
    
    // Convert the image, if it does not have the specified image type
    if (imageType != BufferedImage.TYPE_INT_ARGB) {
      BufferedImage buf2 = new BufferedImage(
          buf.getWidth(), buf.getHeight(),
          imageType
          );
      g = buf2.createGraphics();
      setRenderingHints(g);
      g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));
      g.drawImage(buf, 0, 0, null);
      g.dispose();
      buf.flush();
      buf = buf2;
    }
    
    return buf;
###
848, north, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 135, 136
5
/**
   * North.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator north(boolean isTransform) {
    return new RelativeLocator(0.5, 0.0, isTransform);
###
849, RelativeLocator, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 56, 57
1
/** Creates a new instance. */
2
  public RelativeLocator(double relativeX, double relativeY) {
    this(relativeX, relativeY, false);
###
850, east, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 112, 113
3
/**
   * Non-transforming East.
   */
2
  static public Locator east() {
    return east(false);
###
851, toImage, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 168, 206
14
/**
   * Creates a BufferedImage from the specified list of figures.
   * <p>
   * The images are drawn using the specified scale factor. If some figures
   * have a drawing area located at negative coordinates, then the drawing
   * coordinates are translated, so that all figures are visible on the
   * image.
   *
   * @param drawing The drawing.
   * @param figures A list of figures of the drawing.
   * @param scaleFactor The scale factor used when drawing the figures.
   * @param clipToFigures If this is true, the image is clipped to the figures.
   * If this is false, the image includes the drawing area,  
   */
37
  public BufferedImage toImage(Drawing drawing,
      java.util.List<Figure> figures,
      double scaleFactor, boolean clipToFigures) {
    
    // Determine the draw bounds of the figures
    Rectangle2D.Double drawBounds = null;
    for (Figure f : figures) {
      if (drawBounds == null) {
        drawBounds = f.getDrawingArea();
      } else {
        drawBounds.add(f.getDrawingArea());
      }
    }
    if (clipToFigures) {
    AffineTransform transform = new AffineTransform();
      transform.translate(-drawBounds.x * scaleFactor, 
          -drawBounds.y * scaleFactor);
    transform.scale(scaleFactor, scaleFactor);
    return toImage(drawing, figures, transform,
        new Dimension(
        (int) (drawBounds.width * scaleFactor),
        (int) (drawBounds.height * scaleFactor)
        )
        );
    } else {
    AffineTransform transform = new AffineTransform();
    if (drawBounds.x < 0) {
      transform.translate(-drawBounds.x * scaleFactor, 0);
    }
    if (drawBounds.y < 0) {
      transform.translate(0, -drawBounds.y * scaleFactor);
    }
    transform.scale(scaleFactor, scaleFactor);
     return toImage(drawing, figures, transform,
        new Dimension(
        (int) ((Math.max(0, drawBounds.x)+drawBounds.width) * scaleFactor),
        (int) ((Math.max(0, drawBounds.y)+drawBounds.height) * scaleFactor)
###
852, southWest, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 217, 218
3
/**
   * Non-transforming South west.
   */
2
  static public Locator southWest() {
    return southWest(false);
###
853, center, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 233, 234
3
/**
   * Non-transforming Center.
   */
2
  static public Locator center() {
    return center(false);
###
854, write, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 93, 98
5
/**
   * Writes the drawing to the specified file.
   * This method ensures that all figures of the drawing are visible on
   * the image.
   */
6
  public void write(File file, Drawing drawing) throws IOException {
    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));
    try {
      write(out, drawing);
    } finally {
        out.close();
###
855, south, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 195, 196
5
/**
   * South.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator south(boolean isTransform) {
    return new RelativeLocator(0.5, 1.0, isTransform);
###
856, north, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 127, 128
3
/**
   * Non-transforming North.
   */
2
  static public Locator north() {
    return north(false);
###
857, write, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 134, 135
5
/**
   * Writes the figures to the specified output stream.
   * This method ensures that all figures of the drawing are visible on
   * the image.
   */
2
  public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures) throws IOException {
    write(out, drawing, figures, null, null);
###
858, southEast, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 202, 203
3
/**
   * Non-transforming South east.
   */
2
  static public Locator southEast() {
    return southEast(false);
###
859, RelativeLocator, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 51, 52
1
/** Creates a new instance. */
2
  public RelativeLocator() {
    this(0, 0, false);
###
860, write, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 142, 151
5
/**
   * Writes the figures to the specified output stream.
   * This method applies the specified transform to the drawing, and draws
   * it on an image of the specified size.
   */
10
  public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures,
      AffineTransform drawingTransform, Dimension imageSize) throws IOException {
    BufferedImage img;
    if (drawingTransform == null || imageSize == null) {
      img = toImage(drawing, figures, 1d, false);
    } else {
      img = toImage(drawing, figures, drawingTransform, imageSize);
    }
    ImageIO.write(img, formatName, out);
    img.flush();
###
861, southEast, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 210, 211
5
/**
   * South East.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator southEast(boolean isTransform) {
    return new RelativeLocator(1.0, 1.0, isTransform);
###
862, west, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 142, 143
3
/**
   * Non-transforming West.
   */
2
  static public Locator west() {
    return west(false);
###
863, northEast, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 157, 158
3
/**
   * Non-transforming North east.
   */
2
  static public Locator northEast() {
    return northEast(false);
###
864, east, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 120, 121
5
/**
   * East.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator east(boolean isTransform) {
    return new RelativeLocator(1.0, 0.5, isTransform);
###
865, west, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 150, 151
5
/**
   * West.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator west(boolean isTransform) {
    return new RelativeLocator(0.0, 0.5, isTransform);
###
866, RelativeLocator, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 67, 70
8
/**
   * @param relativeX x-position relative to bounds expressed as a value
   * between 0 and 1.
   * @param relativeY y-position relative to bounds expressed as a value
   * between 0 and 1.
   * @param isTransform Set this to true, if the locator shall honor the
   * TRANSFORM attribute of the Figure.
   */
4
  public RelativeLocator(double relativeX, double relativeY, boolean isTransform) {
    this.relativeX = relativeX;
    this.relativeY = relativeY;
    this.isTransform = isTransform;
###
867, south, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 187, 188
3
/**
   * Non-transforming South.
   */
2
  static public Locator south() {
    return south(false);
###
868, northWest, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 180, 181
5
/**
   * North West.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator northWest(boolean isTransform) {
    return new RelativeLocator(0.0, 0.0, isTransform);
###
869, northWest, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 172, 173
3
/**
   * Non-transforming North west.
   */
2
  static public Locator northWest() {
    return northWest(false);
###
870, northEast, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 165, 166
5
/**
   * Norht East.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator northEast(boolean isTransform) {
    return new RelativeLocator(1.0, 0.0, isTransform);
###
871, southWest, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 226, 227
6
/**
   * South West.
   *
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator southWest(boolean isTransform) {
    return new RelativeLocator(0.0, 1.0, isTransform);
###
872, TextInputFormat, TextInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/TextInputFormat.java, 77, 78
3
/** Creates a new image output format for text, for a figure that can not.
   * hold multiple lines of text.
   */
2
  public TextInputFormat(TextHolderFigure prototype) {
    this(prototype, "Text", "Text", "txt", false);
###
873, mouseDragged, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 236, 254
3
/**
   * Adjust the created connection.
   */
17
  public void mouseDragged(java.awt.event.MouseEvent e) {
    repaintConnectors(e);
    if (createdFigure != null) {
      createdFigure.willChange();
      Point2D.Double endPoint = viewToDrawing(new Point(e.getX(), e.getY()));
      getView().getConstrainer().constrainPoint(endPoint);
      Figure endFigure = getDrawing().findFigureExcept(endPoint, createdFigure);
      endConnector = (endFigure == null) ? null : endFigure.findConnector(endPoint, prototype);
      if (endConnector != null && canConnect(createdFigure, startConnector, endConnector)) {
        endPoint = endConnector.getAnchor();
      }
      Rectangle r = new Rectangle(getView().drawingToView(createdFigure.getEndPoint()));
      createdFigure.setEndPoint(endPoint);
      r.add(getView().drawingToView(endPoint));
      r.grow(ANCHOR_WIDTH + 2, ANCHOR_WIDTH + 2);
      getView().getComponent().repaint(r);
      createdFigure.changed();
###
874, repaintConnectors, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 170, 199
4
/**
   * Updates the list of connectors that we draw when the user
   * moves or drags the mouse over a figure to which can connect.
   */
30
  public void repaintConnectors(MouseEvent evt) {
    Rectangle2D.Double invalidArea = null;
    Point2D.Double targetPoint = viewToDrawing(new Point(evt.getX(), evt.getY()));
    Figure aFigure = getDrawing().findFigureExcept(targetPoint, createdFigure);
    if (aFigure != null && !aFigure.isConnectable()) {
      aFigure = null;
    }
    if (targetFigure != aFigure) {
      for (Connector c : connectors) {
        if (invalidArea == null) {
          invalidArea = c.getDrawingArea();
        } else {
          invalidArea.add(c.getDrawingArea());
        }
      }
      targetFigure = aFigure;
      if (targetFigure != null) {
        connectors = targetFigure.getConnectors(getPrototype());
        for (Connector c : connectors) {
          if (invalidArea == null) {
            invalidArea = c.getDrawingArea();
          } else {
            invalidArea.add(c.getDrawingArea());
          }
        }
      }
    }
    if (invalidArea != null) {
      getView().getComponent().repaint(
          getView().drawingToView(invalidArea));
###
875, mouseReleased, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 262, 305
4
/**
   * Connects the figures if the mouse is released over another
   * figure.
   */
40
  @Override
  public void mouseReleased(MouseEvent e) {
    if (createdFigure != null &&
        startConnector != null && endConnector != null &&
        createdFigure.canConnect(startConnector, endConnector)) {
      createdFigure.willChange();
      createdFigure.setStartConnector(startConnector);
      createdFigure.setEndConnector(endConnector);
      createdFigure.updateConnection();
      createdFigure.changed();
      final Figure addedFigure = createdFigure;
      final Drawing addedDrawing = getDrawing();
      getDrawing().fireUndoableEditHappened(new AbstractUndoableEdit() {
        public String getPresentationName() {
          return presentationName;
        }
        public void undo() throws CannotUndoException {
          super.undo();
          addedDrawing.remove(addedFigure);
        }
        public void redo() throws CannotRedoException {
          super.redo();
          addedDrawing.add(addedFigure);
        }
      });
      targetFigure = null;
      Point2D.Double anchor = startConnector.getAnchor();
      Rectangle r = new Rectangle(getView().drawingToView(anchor));
      r.grow(ANCHOR_WIDTH, ANCHOR_WIDTH);
      fireAreaInvalidated(r);
      anchor = endConnector.getAnchor();
      r = new Rectangle(getView().drawingToView(anchor));
      r.grow(ANCHOR_WIDTH, ANCHOR_WIDTH);
      fireAreaInvalidated(r);
      startConnector = endConnector = null;
      createdFigure = null;
      creationFinished(createdFigure);
    } else {
      if (isToolDoneAfterCreation()) {
        fireToolDone();
###
876, mousePressed, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 208, 230
5
/**
   * Manipulates connections in a context dependent way. If the
   * mouse down hits a figure start a new connection. If the mousedown
   * hits a connection split a segment or join two segments.
   */
20
  public void mousePressed(MouseEvent evt) {
    super.mousePressed(evt);
    getView().clearSelection();
    Point2D.Double startPoint = viewToDrawing(anchor);
    Figure startFigure = getDrawing().findFigure(startPoint);
    startConnector = (startFigure == null) ? null : startFigure.findConnector(startPoint, prototype);
    if (startConnector != null && canConnect(prototype, startConnector)) {
      Point2D.Double anchor = startConnector.getAnchor();
      createdFigure = createFigure();
      createdFigure.setStartPoint(anchor);
      createdFigure.setEndPoint(anchor);
      getDrawing().add(createdFigure);
      Rectangle r = new Rectangle(getView().drawingToView(anchor));
      r.grow(ANCHOR_WIDTH, ANCHOR_WIDTH);
      fireAreaInvalidated(r);
    } else {
      startConnector = null;
      createdFigure = null;
    }
    endConnector = null;
###
877, setToolDoneAfterCreation, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 389, 391
5
/**
   * If this is set to false, the CreationTool does not fire toolDone
   * after a new Figure has been created. This allows to create multiple
   * figures consecutively.
   */
3
  public void setToolDoneAfterCreation(boolean newValue) {
    boolean oldValue = isToolDoneAfterCreation;
    isToolDoneAfterCreation = newValue;
###
878, canConnect, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 158, 159
9
/**
   * This method is called on the Figure, onto which the user wants
   * to end a new connection.
   * 
   * @param f The ConnectionFigure.
   * @param startConnector The Connector of the start Figure.
   * @param endConnector The Connector of the end Figure.
   * @return True, if a connection can be made.
   */
2
  protected boolean canConnect(ConnectionFigure f, Connector startConnector, Connector endConnector) {
    return f.canConnect(startConnector, endConnector);
###
879, ConnectionTool, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 91, 92
2
/** Creates a new instance.
   */
2
  public ConnectionTool(ConnectionFigure prototype) {
    this(prototype, null, null);
###
880, createFigure, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 329, 338
4
/**
   * Creates the ConnectionFigure. By default the figure prototype is
   * cloned.
   */
10
  @SuppressWarnings("unchecked")
  protected ConnectionFigure createFigure() {
    ConnectionFigure f = (ConnectionFigure) prototype.clone();
    getEditor().applyDefaultAttributesTo(f);
    if (prototypeAttributes != null) {
      for (Map.Entry<AttributeKey, Object> entry : prototypeAttributes.entrySet()) {
        f.set(entry.getKey(), entry.getValue());
      }
    }
    return f;
###
881, creationFinished, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 378, 380
5
/**
   * This method allows subclasses to do perform additonal user interactions
   * after the new figure has been created.
   * The implementation of this class just invokes fireToolDone.
   */
3
  protected void creationFinished(Figure createdFigure) {
    if (isToolDoneAfterCreation()) {
      fireToolDone();
###
882, canConnect, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 145, 146
8
/**
   * This method is called on the Figure, onto which the user wants
   * to start a new connection.
   * 
   * @param f The ConnectionFigure.
   * @param startConnector The Connector of the start Figure.
   * @return True, if a connection can be made.
   */
2
  protected boolean canConnect(ConnectionFigure f, Connector startConnector) {
    return f.canConnect(startConnector);
###
883, DrawingPageable, DrawingPageable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/print/DrawingPageable.java, 50, 54
1
/** Creates a new instance. */
5
  public DrawingPageable(Drawing drawing) {
    this.drawing = drawing;
    Paper paper = new Paper();
    pageFormat = new PageFormat();
    pageFormat.setPaper(paper);
###
884, createOverlay, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 88, 89
4
/**
   * Creates the overlay within the given container.
   * @param view the DrawingView
   */
2
  public void createOverlay(DrawingView view) {
    createOverlay(view, null);
###
885, getText, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 139, 140
4
/**
   * Gets the text contents of the overlay.
   * @return The text value
   */
2
  public String getText() {
    return textArea.getText();
###
886, FloatingTextArea, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 73, 81
3
/**
   * Constructor for the FloatingTextArea object
   */
9
  public FloatingTextArea() {
    textArea = new JTextArea();
    textArea.setWrapStyleWord(true);
    textArea.setLineWrap(true);
    editScrollContainer = new JScrollPane(textArea,
        JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
        JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
    editScrollContainer.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
    editScrollContainer.setBorder(BorderFactory.createLineBorder(Color.black));
###
887, getPreferredSize, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 148, 149
5
/**
   * Gets the preferred size of the overlay.
   * @param cols Description of the Parameter
   * @return The preferredSize value
   */
2
  public Dimension getPreferredSize(int cols) {
    return new Dimension(textArea.getWidth(), textArea.getHeight());
###
888, createOverlay, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 102, 108
6
/**
   * Creates the overlay for the given Container using a
   * specific font.
   * @param view the DrawingView
   * @param figure the figure holding the text
   */
7
  public void createOverlay(DrawingView view, TextHolderFigure figure) {
    view.getComponent().add(editScrollContainer, 0);
    editedFigure = figure;
    this.view = view;
    if (editedFigure != null) {
      editedFigure.addFigureListener(figureHandler);
      updateWidget();
###
889, setBounds, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 127, 132
5
/**
   * Positions and sizes the overlay.
   * @param r the bounding Rectangle2D.Double for the overlay
   * @param text the text to edit
   */
6
  public void setBounds(Rectangle2D.Double r, String text) {
    textArea.setText(text);
    editScrollContainer.setBounds(view.drawingToView(r));
    editScrollContainer.setVisible(true);
    textArea.setCaretPosition(0);
    textArea.requestFocus();
###
891, createOverlay, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 70, 71
3
/**
   * Creates the overlay for the given Component.
   */
2
  public void createOverlay(DrawingView view) {
    createOverlay(view, null);
###
892, getText, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 144, 145
3
/**
   * Gets the text contents of the overlay.
   */
2
  public String getText() {
    return textField.getText();
###
893, createOverlay, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 82, 91
4
/**
   * Creates the overlay for the given Container using a
   * specific font.
   */
10
  public void createOverlay(DrawingView view, TextHolderFigure figure) {
    view.getComponent().add(textField, 0);
    textField.setText(figure.getText());
    textField.setColumns(figure.getTextColumns());
    textField.selectAll();
    textField.setVisible(true);
    editedFigure = figure;
    editedFigure.addFigureListener(figureHandler);
    this.view = view;
    updateWidget();
###
894, removeActionListener, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 136, 137
3
/**
   * Remove an action listener
   */
2
  public void removeActionListener(ActionListener listener) {
    textField.removeActionListener(listener);
###
895, getPreferredSize, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 151, 153
3
/**
   * Gets the preferred size of the overlay.
   */
3
  public Dimension getPreferredSize(int cols) {
    textField.setColumns(cols);
    return textField.getPreferredSize();
###
896, addActionListener, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 129, 130
3
/**
   * Adds an action listener
   */
2
  public void addActionListener(ActionListener listener) {
    textField.addActionListener(listener);
###
897, ElbowLiner, ElbowLiner, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/liner/ElbowLiner.java, 41, 42
1
/** Creates a new instance. */
2
  public ElbowLiner() {
    this(20);
###
898, CurvedLiner, CurvedLiner, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/liner/CurvedLiner.java, 40, 41
1
/** Creates a new instance. */
2
  public CurvedLiner() {
    this(20);
###
900, BezierLabelLocator, BezierLabelLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/BezierLabelLocator.java, 55, 58
9
/** Creates a new locator.
   *
   * @param relativePosition The relative position of the label on the polyline.
   * 0.0 specifies the start of the bezier path, 1.0 the
   * end of the polyline. Values between 0.0 and 1.0 are relative positions
   * on the bezier path.
   * @param angle The angle of the distance vector.
   * @param distance The length of the distance vector.
   */
4
  public BezierLabelLocator(double relativePosition, double angle, double distance) {
    this.relativePosition = relativePosition;
    this.angle = angle;
    this.distance = distance;
###
901, getRelativePoint, BezierLabelLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/BezierLabelLocator.java, 73, 92
4
/**
   * Returns the coordinates of the relative point on the path
   * of the specified bezier figure.
   */
20
  public Point2D.Double getRelativePoint(BezierFigure owner) {
    Point2D.Double point = owner.getPointOnPath((float) relativePosition, 3);
    Point2D.Double nextPoint = owner.getPointOnPath(
        (relativePosition < 0.5) ? (float) relativePosition + 0.1f : (float) relativePosition - 0.1f,
        3);
    
    double dir = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);
    if (relativePosition >= 0.5) {
      dir += Math.PI;
    }
    double alpha = dir + angle;
    
    Point2D.Double p = new Point2D.Double(
        point.x + distance * Math.cos(alpha),
        point.y + distance * Math.sin(alpha)
        );
    
    if (Double.isNaN(p.x)) p = point;
    
    return p;
###
903, getRelativeLabelPoint, BezierLabelLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/BezierLabelLocator.java, 100, 148
4
/**
   * Returns a Point2D.Double on the polyline that is at the provided relative position.
   * XXX - Implement this and move it to BezierPath
   */
49
  public Point2D.Double getRelativeLabelPoint(BezierFigure owner, Figure label) {
    // Get a point on the path an the next point on the path
    Point2D.Double point = owner.getPointOnPath((float) relativePosition, 3);
    if (point == null) {
      return new Point2D.Double(0,0);
    }
    Point2D.Double nextPoint = owner.getPointOnPath(
        (relativePosition < 0.5) ? (float) relativePosition + 0.1f : (float) relativePosition - 0.1f,
        3);
    
    double dir = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);
    if (relativePosition >= 0.5) {
      dir += Math.PI;
    }
    double alpha = dir + angle;
    
    Point2D.Double p = new Point2D.Double(
        point.x + distance * Math.cos(alpha),
        point.y + distance * Math.sin(alpha)
        );
    if (Double.isNaN(p.x)) p = point;
    
    Dimension2DDouble labelDim = label.getPreferredSize();
    if (relativePosition == 0.5 && 
        p.x >= point.x - distance / 2 && 
        p.x <= point.x + distance / 2) {
      if (p.y >= point.y) {
        // South East
        return new Point2D.Double(p.x - labelDim.width / 2, p.y);
      } else {
        // North East
        return new Point2D.Double(p.x - labelDim.width / 2, p.y - labelDim.height);
      }
    } else {
      if (p.x >= point.x) {
        if (p.y >= point.y) {
          // South East
          return new Point2D.Double(p.x, p.y);
        } else {
          // North East
          return new Point2D.Double(p.x, p.y - labelDim.height);
        }
      } else {
        if (p.y >= point.y) {
          // South West
          return new Point2D.Double(p.x - labelDim.width,  p.y);
        } else {
          // North West
          return new Point2D.Double(p.x - labelDim.width, p.y - labelDim.height);
###
905, SlantedLiner, SlantedLiner, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/liner/SlantedLiner.java, 41, 42
1
/** Creates a new instance. */
2
  public SlantedLiner() {
    this(20);
###
906, getBeanDescriptor, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 81, 82
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
908, getPropertyDescriptors, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 97, 98
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
909, getMethodDescriptors, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 119, 120
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
911, getDefaultEventIndex, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 142, 143
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
913, getDefaultPropertyIndex, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 131, 132
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
914, getEventSetDescriptors, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 108, 109
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
916, getBeanDescriptor, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 81, 82
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
917, getEventSetDescriptors, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 108, 109
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
919, getDefaultEventIndex, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 142, 143
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
920, getPropertyDescriptors, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 97, 98
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
921, getDefaultPropertyIndex, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 131, 132
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
922, getMethodDescriptors, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 119, 120
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
927, getPropertyDescriptors, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 97, 98
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
928, getDefaultPropertyIndex, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 131, 132
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
929, getEventSetDescriptors, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 108, 109
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
931, getDefaultEventIndex, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 142, 143
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
932, getMethodDescriptors, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 119, 120
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
934, getBeanDescriptor, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 81, 82
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
935, JAttributeSlider, JAttributeSlider, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSlider.java, 30, 31
1
/** Creates new instance. */
2
  public JAttributeSlider() {
    this(JSlider.VERTICAL, 0, 100, 50);
###
939, getDefaultEventIndex, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 150, 151
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
940, getBeanDescriptor, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 89, 90
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
941, getPropertyDescriptors, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 105, 106
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
942, getDefaultPropertyIndex, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 139, 140
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
943, getMethodDescriptors, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 127, 128
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
945, getEventSetDescriptors, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 116, 117
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
948, outcode, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 173, 188
16
/**
   * This method computes a binary OR of the appropriate mask values
   * indicating, for each side of Rectangle r1, whether or not the
   * Rectangle r2 is on the same side of the edge as the rest
   * of this Rectangle.
   *
   *
   *
   *
   *
   *
   *
   *
   * @return the logical OR of all appropriate out codes OUT_RIGHT, OUT_LEFT, OUT_BOTTOM,
   * OUT_TOP.
   */
13
  public static int outcode(Rectangle r1, Rectangle r2) {
    int outcode = 0;
    if (r2.x > r1.x + r1.width) {
      outcode = OUT_RIGHT;
    } else if (r2.x + r2.width < r1.x) {
      outcode = OUT_LEFT;
    }
    if (r2.y > r1.y + r1.height) {
      outcode |= OUT_BOTTOM;
    } else if (r2.y + r2.height < r1.y) {
      outcode |= OUT_TOP;
    }
    return outcode;
###
949, range, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 360, 367
4
/**
   * Constains a value to the given range.
   * @return the constrained value
   */
8
  public static int range(int min, int max, int value) {
    if (value < min) {
      value = min;
    }
    if (value > max) {
      value = max;
    }
    return value;
###
950, length, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 408, 409
3
/**
   * Gets the distance between to points
   */
2
  public static double length(double x1, double y1, double x2, double y2) {
    return sqrt(length2(x1, y1, x2, y2));
###
951, length2, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 401, 402
3
/**
   * Gets the square distance between two points.
   */
2
  public static double length2(double x1, double y1, double x2, double y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
###
952, ovalAngleToPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 535, 538
3
/**
   * Gets the point on an oval that corresponds to the given angle.
   */
4
  public static Point2D.Double ovalAngleToPoint(Rectangle2D.Double r, double angle) {
    Point2D.Double center = Geom.center(r);
    Point2D.Double p = Geom.polarToPoint2D(angle, r.width / 2, r.height / 2);
    return new Point2D.Double(center.x + p.x, center.y + p.y);
###
953, ovalAngleToPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 526, 529
3
/**
   * Gets the point on an oval that corresponds to the given angle.
   */
4
  public static Point ovalAngleToPoint(Rectangle r, double angle) {
    Point center = Geom.center(r);
    Point p = Geom.polarToPoint(angle, r.width / 2, r.height / 2);
    return new Point(center.x + p.x, center.y + p.y);
###
954, length, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 415, 416
3
/**
   * Gets the distance between to points
   */
2
  public static double length(Point2D.Double p1, Point2D.Double p2) {
    return sqrt(length2(p1.x, p1.y, p2.x, p2.y));
###
955, lineContainsPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 43, 68
4
/**
   * Tests if a point is on a line.
   * <p>changed Werner Randelshofer 2003-11-26
   */
21
  public static boolean lineContainsPoint(int x1, int y1,
      int x2, int y2,
      int px, int py, double tolerance) {
    Rectangle r = new Rectangle(new Point(x1, y1));
    r.add(x2, y2);
    r.grow(max(2, (int) ceil(tolerance)), max(2, (int) ceil(tolerance)));
    if (!r.contains(px, py)) {
      return false;
    }
    double a, b, x, y;
    if (x1 == x2) {
      return (abs(px - x1) <= tolerance);
    }
    if (y1 == y2) {
      return (abs(py - y1) <= tolerance);
    }
    a = (double) (y1 - y2) / (double) (x1 - x2);
    b = (double) y1 - a * (double) x1;
    x = (py - b) / a;
    y = a * px + b;
    return (min(abs(x - px), abs(y - py)) <= tolerance);
###
956, polarToPoint2D, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 517, 520
3
/**
   * Converts a polar to a point
   */
4
  public static Point2D.Double polarToPoint2D(double angle, double fx, double fy) {
    double si = sin(angle);
    double co = cos(angle);
    return new Point2D.Double(fx * co + 0.5, fy * si + 0.5);
###
957, pointToAngle, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 435, 438
3
/**
   * Gets the angle of a point relative to a rectangle.
   */
4
  public static double pointToAngle(Rectangle r, Point p) {
    int px = p.x - (r.x + r.width / 2);
    int py = p.y - (r.y + r.height / 2);
    return atan2(py * r.width, px * r.height);
###
958, contains, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 833, 837
11
/**
   * Returns true, if rectangle 1 contains rectangle 2.
   * <p>
   * This method is similar to Rectangle2D.contains, but also returns true,
   * when rectangle1 contains rectangle2 and either or both of them
   * are empty.
   *
   * @param r1 Rectangle 1.
   * @param r2 Rectangle 2.
   * @return true if r1 contains r2.
   */
5
  public static boolean contains(Rectangle2D.Double r1, Rectangle2D.Double r2) {
    return (r2.x >= r1.x &&
        r2.y >= r1.y &&
        (r2.x + max(0, r2.width)) <= r1.x + max(0, r1.width) &&
        (r2.y + max(0, r2.height)) <= r1.y + max(0, r1.height));
###
959, angleToPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 484, 502
3
/**
   * Gets the point on a rectangle that corresponds to the given angle.
   */
18
  public static Point2D.Double angleToPoint(Rectangle2D.Double r, double angle) {
    double si = sin(angle);
    double co = cos(angle);
    double e = 0.0001;
    double x = 0, y = 0;
    if (abs(si) > e) {
      x = (1.0 + co / abs(si)) / 2.0 * r.width;
      x = range(0, r.width, x);
    } else if (co >= 0.0) {
      x = r.width;
    }
    if (abs(co) > e) {
      y = (1.0 + si / abs(co)) / 2.0 * r.height;
      y = range(0, r.height, y);
    } else if (si >= 0.0) {
      y = r.height;
    }
    return new Point2D.Double(r.x + x, r.y + y);
###
960, direction, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 140, 154
4
/**
   * Returns the direction OUT_TOP, OUT_BOTTOM, OUT_LEFT, OUT_RIGHT from
   * one point to another one.
   */
14
  public static int direction(double x1, double y1, double x2, double y2) {
    int direction = 0;
    double vx = x2 - x1;
    double vy = y2 - y1;
    if (vy < vx && vx > -vy) {
      direction = OUT_RIGHT;
    } else if (vy > vx && vy > -vx) {
      direction = OUT_TOP;
    } else if (vx < vy && vx < -vy) {
      direction = OUT_LEFT;
    } else {
      direction = OUT_BOTTOM;
    }
    return direction;
###
961, angleToPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 460, 478
3
/**
   * Gets the point on a rectangle that corresponds to the given angle.
   */
18
  public static Point angleToPoint(Rectangle r, double angle) {
    double si = sin(angle);
    double co = cos(angle);
    double e = 0.0001;
    int x = 0, y = 0;
    if (abs(si) > e) {
      x = (int) ((1.0 + co / abs(si)) / 2.0 * r.width);
      x = range(0, r.width, x);
    } else if (co >= 0.0) {
      x = r.width;
    }
    if (abs(co) > e) {
      y = (int) ((1.0 + si / abs(co)) / 2.0 * r.height);
      y = range(0, r.height, y);
    } else if (si >= 0.0) {
      y = r.height;
    }
    return new Point(r.x + x, r.y + y);
###
962, chop, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 246, 329
5
/**
   * Returns a point on the edge of the bezier path which crosses the line
   * from the center of the bezier path to the specified point.
   * If no edge crosses the line, the nearest C0 control point is returned.
   */
77
  public static Point2D.Double chop(Shape shape, Point2D.Double p) {
    Rectangle2D bounds = shape.getBounds2D();
    Point2D.Double ctr = new Point2D.Double(bounds.getCenterX(), bounds.getCenterY());
    // Chopped point
    double cx = -1;
    double cy = -1;
    double len = Double.MAX_VALUE;
    // Try for points along edge
    PathIterator i = shape.getPathIterator(new AffineTransform(), 1);
    double[] coords = new double[6];
    int type = i.currentSegment(coords);
    double prevX = coords[0];
    double prevY = coords[1];
    double moveToX = prevX;
    double moveToY = prevY;
    i.next();
    for (; !i.isDone(); i.next()) {
      switch (i.currentSegment(coords)) {
        case PathIterator.SEG_MOVETO:
          moveToX = coords[0];
          moveToY = coords[1];
          break;
        case PathIterator.SEG_CLOSE:
          coords[0] = moveToX;
          coords[1] = moveToY;
          break;
      }
      Point2D.Double chop = Geom.intersect(
          prevX, prevY,
          coords[0], coords[1],
          p.x, p.y,
          ctr.x, ctr.y);
      if (chop != null) {
        double cl = Geom.length2(chop.x, chop.y, p.x, p.y);
        if (cl < len) {
          len = cl;
          cx = chop.x;
          cy = chop.y;
        }
      }
      prevX = coords[0];
      prevY = coords[1];
    }
    /*
    if (isClosed() && size() > 1) {
    Node first = get(0);
    Node last = get(size() - 1);
    Point2D.Double chop = Geom.intersect(
    first.x[0], first.y[0],
    last.x[0], last.y[0],
    p.x, p.y,
    ctr.x, ctr.y
    );
    if (chop != null) {
    double cl = Geom.length2(chop.x, chop.y, p.x, p.y);
    if (cl < len) {
    len = cl;
    cx = chop.x;
    cy = chop.y;
    }
    }
    }*/

    // if none found, pick closest vertex
    if (len == Double.MAX_VALUE) {
      i = shape.getPathIterator(new AffineTransform(), 1);
      for (; !i.isDone(); i.next()) {
        i.currentSegment(coords);
        double l = Geom.length2(ctr.x, ctr.y, coords[0], coords[1]);
        if (l < len) {
          len = l;
          cx = coords[0];
          cy = coords[1];
        }
      }
    }
    return new Point2D.Double(cx, cy);
###
963, length, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 394, 395
3
/**
   * Gets the distance between to points
   */
2
  public static long length(int x1, int y1, int x2, int y2) {
    return (long) sqrt(length2(x1, y1, x2, y2));
###
964, grow, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 815, 819
23
/**
   * Resizes the <code>Rectangle2D.Double</code> both horizontally and vertically.
   * <p>
   * This method modifies the <code>Rectangle2D.Double</code> so that it is
   * <code>h</code> units larger on both the left and right side,
   * and <code>v</code> units larger at both the top and bottom.
   * <p>
   * The new <code>Rectangle2D.Double</code> has (<code>x&nbsp;-&nbsp;h</code>,
   * <code>y&nbsp;-&nbsp;v</code>) as its top-left corner, a
   * width of
   * <code>width</code>&nbsp;<code>+</code>&nbsp;<code>2h</code>,
   * and a height of
   * <code>height</code>&nbsp;<code>+</code>&nbsp;<code>2v</code>.
   * <p>
   * If negative values are supplied for <code>h</code> and
   * <code>v</code>, the size of the <code>Rectangle2D.Double</code>
   * decreases accordingly.
   * The <code>grow</code> method does not check whether the resulting
   * values of <code>width</code> and <code>height</code> are
   * non-negative.
   * @param h the horizontal expansion
   * @param v the vertical expansion
   */
5
  public static void grow(Rectangle2D.Double r, double h, double v) {
    r.x -= h;
    r.y -= v;
    r.width += h * 2d;
    r.height += v * 2d;
###
965, outcode, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 207, 222
16
/**
   * This method computes a binary OR of the appropriate mask values
   * indicating, for each side of Rectangle r1, whether or not the
   * Rectangle r2 is on the same side of the edge as the rest
   * of this Rectangle.
   *
   *
   *
   *
   *
   *
   *
   *
   * @return the logical OR of all appropriate out codes OUT_RIGHT, OUT_LEFT, OUT_BOTTOM,
   * OUT_TOP.
   */
13
  public static int outcode(Rectangle2D.Double r1, Rectangle2D.Double r2) {
    int outcode = 0;
    if (r2.x > r1.x + r1.width) {
      outcode = OUT_RIGHT;
    } else if (r2.x + r2.width < r1.x) {
      outcode = OUT_LEFT;
    }
    if (r2.y > r1.y + r1.height) {
      outcode |= OUT_BOTTOM;
    } else if (r2.y + r2.height < r1.y) {
      outcode |= OUT_TOP;
    }
    return outcode;
###
966, direction, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 119, 133
4
/**
   * Returns the direction OUT_TOP, OUT_BOTTOM, OUT_LEFT, OUT_RIGHT from
   * one point to another one.
   */
14
  public static int direction(int x1, int y1, int x2, int y2) {
    int direction = 0;
    int vx = x2 - x1;
    int vy = y2 - y1;
    if (vy < vx && vx > -vy) {
      direction = OUT_RIGHT;
    } else if (vy > vx && vy > -vx) {
      direction = OUT_TOP;
    } else if (vx < vy && vx < -vy) {
      direction = OUT_LEFT;
    } else {
      direction = OUT_BOTTOM;
    }
    return direction;
###
968, range, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 374, 381
4
/**
   * Constains a value to the given range.
   * @return the constrained value
   */
8
  public static double range(double min, double max, double value) {
    if (value < min) {
      value = min;
    }
    if (value > max) {
      value = max;
    }
    return value;
###
969, angle, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 453, 454
3
/**
   * Gets the angle of the specified line.
   */
2
  public static double angle(double x1, double y1, double x2, double y2) {
    return atan2(y2 - y1, x2 - x1);
###
970, lineContainsPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 75, 104
4
/**
   * Tests if a point is on a line.
   * <p>changed Werner Randelshofer 2003-11-26
   */
25
  public static boolean lineContainsPoint(double x1, double y1,
      double x2, double y2,
      double px, double py, double tolerance) {
    Rectangle2D.Double r = new Rectangle2D.Double(x1, y1, 0, 0);
    r.add(x2, y2);
    double grow = max(2, (int) ceil(tolerance));
    r.x -= grow;
    r.y -= grow;
    r.width += grow * 2;
    r.height += grow * 2;
    if (!r.contains(px, py)) {
      return false;
    }
    double a, b, x, y;
    if (x1 == x2) {
      return (abs(px - x1) <= tolerance);
    }
    if (y1 == y2) {
      return (abs(py - y1) <= tolerance);
    }
    a = (double) (y1 - y2) / (double) (x1 - x2);
    b = (double) y1 - a * (double) x1;
    x = (py - b) / a;
    y = a * px + b;
    return (min(abs(x - px), abs(y - py)) <= tolerance);
###
971, lineContainsPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 33, 36
3
/**
   * Tests if a point is on a line.
   */
4
  public static boolean lineContainsPoint(int x1, int y1,
      int x2, int y2,
      int px, int py) {
    return lineContainsPoint(x1, y1, x2, y2, px, py, 3d);
###
972, polarToPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 508, 511
3
/**
   * Converts a polar to a point
   */
4
  public static Point polarToPoint(double angle, double fx, double fy) {
    double si = sin(angle);
    double co = cos(angle);
    return new Point((int) (fx * co + 0.5), (int) (fy * si + 0.5));
###
973, pointToAngle, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 444, 447
3
/**
   * Gets the angle of a point relative to a rectangle.
   */
4
  public static double pointToAngle(Rectangle2D.Double r, Point2D.Double p) {
    double px = p.x - (r.x + r.width / 2);
    double py = p.y - (r.y + r.height / 2);
    return atan2(py * r.width, px * r.height);
###
975, cap, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 424, 429
5
/**
   * Caps the line defined by p1 and p2 by the number of units
   * specified by radius.
   * @return A new end point for the line.
   */
6
  public static Point2D.Double cap(Point2D.Double p1, Point2D.Double p2, double radius) {
    double angle = PI / 2 - atan2(p2.x - p1.x, p2.y - p1.y);
    Point2D.Double p3 = new Point2D.Double(
        p2.x + radius * cos(angle),
        p2.y + radius * sin(angle));
    return p3;
###
976, length2, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 387, 388
3
/**
   * Gets the square distance between two points.
   */
2
  public static long length2(int x1, int y1, int x2, int y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
###
991, reset, Polygon2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 79, 81
17
/**
   * Resets this <code>Polygon</code> object to an empty polygon.
   * The coordinate arrays and the data in them are left untouched
   * but the number of points is reset to zero to mark the old
   * vertex data as invalid and to start accumulating new vertex
   * data at the beginning.
   * All internally-cached data relating to the old vertices
   * are discarded.
   * Note that since the coordinate arrays from before the reset
   * are reused, creating a new empty <code>Polygon</code> might
   * be more memory efficient than resetting the current one if
   * the number of vertices in the new polygon data is significantly
   * smaller than the number of vertices in the data from before the
   * reset.
   * @see     java.awt.Polygon#invalidate
   * 
   */
3
  public void reset() {
    npoints = 0;
    invalidate();
###
993, contains, Polygon2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 149, 150
9
/**
   * Determines whether the specified {@link Point} is inside this 
   * <code>Polygon</code>.
   * @param p the specified <code>Point</code> to be tested
   * @return <code>true</code> if the <code>Polygon</code> contains the
   *       <code>Point</code>; <code>false</code> otherwise.
   * @see #contains(double, double)
   * 
   */
2
  public boolean contains(Point p) {
    return contains(p.x, p.y);
###
994, getBounds, Polygon2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 136, 137
9
/**
   * Gets the bounding box of this <code>Polygon</code>. 
   * The bounding box is the smallest {@link Rectangle} whose
   * sides are parallel to the x and y axes of the 
   * coordinate space, and can completely contain the <code>Polygon</code>.
   * @return a <code>Rectangle</code> that defines the bounds of this 
   * <code>Polygon</code>.
   * 
   */
2
  public Rectangle getBounds() {
    return getBounds2D().getBounds();
###
998, inside, Polygon2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 182, 184
13
/**
   * Determines whether the specified coordinates are contained in this 
   * <code>Polygon</code>.
   * @param x the specified X coordinate to be tested
   * @param y the specified Y coordinate to be tested
   * @return {@code true} if this {@code Polygon} contains
   *     the specified coordinates {@code (x,y)};
   *     {@code false} otherwise.
   * @see #contains(double, double)
   * @deprecated As of JDK version 1.1,
   * replaced by <code>contains(int, int)</code>.
   * 
   */
3
  @Deprecated
  public boolean inside(int x, int y) {
    return contains((double) x, (double) y);
###
1001, contains, Polygon2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 165, 166
12
/**
   * Determines whether the specified coordinates are inside this 
   * <code>Polygon</code>.   
   * <p>
   * @param x the specified X coordinate to be tested
   * @param y the specified Y coordinate to be tested
   * @return {@code true} if this {@code Polygon} contains
   *     the specified coordinates {@code (x,y)};
   *     {@code false} otherwise.
   * @see #contains(double, double)
   * 
   */
2
  public boolean contains(int x, int y) {
    return contains((double) x, (double) y);
###
1004, translate, Double, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 362, 370
8
/**
     * Translates the vertices of the <code>Polygon</code> by
     * <code>deltaX</code> along the x axis and by
     * <code>deltaY</code> along the y axis.
     * @param deltaX the amount to translate along the X axis
     * @param deltaY the amount to translate along the Y axis
     * 
     */
9
    @Override
    public void translate(double deltaX, double deltaY) {
      for (int i = 0; i < npoints; i++) {
        xpoints[i] += deltaX;
        ypoints[i] += deltaY;
      }
      if (bounds != null) {
        bounds.x += deltaX;
        bounds.y += deltaY;
###
1005, calculateBounds, Double, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 385, 401
7
/*
     * Calculates the bounding box of the points passed to the constructor.
     * Sets <code>bounds</code> to the result.
     * @param xpoints[] array of <i>x</i> coordinates
     * @param ypoints[] array of <i>y</i> coordinates
     * @param npoints the total number of points
     */
16
    void calculateBounds(double xpoints[], double ypoints[], int npoints) {
      double boundsMinX = java.lang.Double.MAX_VALUE;
      double boundsMinY = java.lang.Double.MAX_VALUE;
      double boundsMaxX = -java.lang.Double.MAX_VALUE;
      double boundsMaxY = -java.lang.Double.MAX_VALUE;
      for (int i = 0; i < npoints; i++) {
        double x = xpoints[i];
        boundsMinX = Math.min(boundsMinX, x);
        boundsMaxX = Math.max(boundsMaxX, x);
        double y = ypoints[i];
        boundsMinY = Math.min(boundsMinY, y);
        boundsMaxY = Math.max(boundsMaxY, y);
      }
      bounds = new Rectangle2D.Double(boundsMinX, boundsMinY,
          boundsMaxX - boundsMinX,
          boundsMaxY - boundsMinY);
###
1006, updateBounds, Double, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 408, 421
4
/*
     * Resizes the bounding box to accomodate the specified coordinates.
     * @param x the specified coordinates
     */
13
    void updateBounds(double x, double y) {
      if (x < bounds.x) {
        bounds.width = bounds.width + (bounds.x - x);
        bounds.x = x;
      } else {
        bounds.width = Math.max(bounds.width, x - bounds.x);
      // bounds.x = bounds.x;
      }
      if (y < bounds.y) {
        bounds.height = bounds.height + (bounds.y - y);
        bounds.y = y;
      } else {
        bounds.height = Math.max(bounds.height, y - bounds.y);
###
1007, updateBounds, Float, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 717, 730
4
/*
     * Resizes the bounding box to accomodate the specified coordinates.
     * @param x the specified coordinates
     */
13
    void updateBounds(float x, float y) {
      if (x < bounds.x) {
        bounds.width = bounds.width + (bounds.x - x);
        bounds.x = x;
      } else {
        bounds.width = Math.max(bounds.width, x - bounds.x);
      // bounds.x = bounds.x;
      }
      if (y < bounds.y) {
        bounds.height = bounds.height + (bounds.y - y);
        bounds.y = y;
      } else {
        bounds.height = Math.max(bounds.height, y - bounds.y);
###
1009, Float, Float, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 635, 656
16
/**
     * Constructs and initializes a <code>Polygon</code> from the specified
     * parameters.
     * @param xpoints an array of X coordinates
     * @param ypoints an array of Y coordinates
     * @param npoints the total number of points in the
     *        <code>Polygon</code>
     * @exception  NegativeArraySizeException if the value of
     *             <code>npoints</code> is negative.
     * @exception  IndexOutOfBoundsException if <code>npoints</code> is
     *       greater than the length of <code>xpoints</code>
     *       or the length of <code>ypoints</code>.
     * @exception  NullPointerException if <code>xpoints</code> or
     *       <code>ypoints</code> is <code>null</code>.
     * 
     */
21
    public Float(float xpoints[], float ypoints[], int npoints) {
      // Fix 4489009: should throw IndexOutofBoundsException instead
      // of OutofMemoryException if npoints is huge and > {x,y}points.length
      if (npoints > xpoints.length || npoints > ypoints.length) {
        throw new IndexOutOfBoundsException("npoints > xpoints.length || " +
            "npoints > ypoints.length");
      }
      // Fix 6191114: should throw NegativeArraySizeException with
      // negative npoints
      if (npoints < 0) {
        throw new NegativeArraySizeException("npoints < 0");
      }
      // Fix 6343431: Applet compatibility problems if arrays are not
      // exactly npoints in length
      this.npoints = npoints;
      this.xpoints = new float[npoints];
      System.arraycopy(xpoints, 0, this.xpoints, 0,
          npoints);
      this.ypoints = new float[npoints];
      System.arraycopy(ypoints, 0, this.ypoints, 0,
          npoints);
###
1010, calculateBounds, Float, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 694, 710
7
/*
     * Calculates the bounding box of the points passed to the constructor.
     * Sets <code>bounds</code> to the result.
     * @param xpoints[] array of <i>x</i> coordinates
     * @param ypoints[] array of <i>y</i> coordinates
     * @param npoints the total number of points
     */
16
    void calculateBounds(float xpoints[], float ypoints[], int npoints) {
      float boundsMinX = java.lang.Float.MAX_VALUE;
      float boundsMinY = java.lang.Float.MAX_VALUE;
      float boundsMaxX = -java.lang.Float.MAX_VALUE;
      float boundsMaxY = -java.lang.Float.MAX_VALUE;
      for (int i = 0; i < npoints; i++) {
        float x = xpoints[i];
        boundsMinX = Math.min(boundsMinX, x);
        boundsMaxX = Math.max(boundsMaxX, x);
        float y = ypoints[i];
        boundsMinY = Math.min(boundsMinY, y);
        boundsMaxY = Math.max(boundsMaxY, y);
      }
      bounds = new Rectangle2D.Float(boundsMinX, boundsMinY,
          boundsMaxX - boundsMinX,
          boundsMaxY - boundsMinY);
###
1011, translate, Float, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 667, 669
8
/**
     * Translates the vertices of the <code>Polygon</code> by
     * <code>deltaX</code> along the x axis and by
     * <code>deltaY</code> along the y axis.
     * @param deltaX the amount to translate along the X axis
     * @param deltaY the amount to translate along the Y axis
     * 
     */
3
    @Override
    public void translate(double deltaX, double deltaY) {
      translate((float) deltaX, (float) deltaY);
###
1012, getWindingRule, PolygonPathIteratorDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 926, 927
6
/**
     * Returns the winding rule for determining the interior of the
     * path.
     * @return an integer representing the current winding rule.
     * @see PathIterator#WIND_NON_ZERO
     */
2
    public int getWindingRule() {
      return WIND_EVEN_ODD;
###
1013, next, PolygonPathIteratorDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 944, 945
5
/**
     * Moves the iterator forwards, along the primary direction of
     * traversal, to the next segment of the path when there are
     * more points in that direction.
     */
2
    public void next() {
      index++;
###
1014, isDone, PolygonPathIteratorDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 935, 936
5
/**
     * Tests if there are more points to read.
     * @return <code>true</code> if there are more points to read;
     *      <code>false</code> otherwise.
     */
2
    public boolean isDone() {
      return index > poly.npoints;
###
1015, currentSegment, PolygonPathIteratorDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 966, 975
18
/**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.
     * A <code>float</code> array of length 2 must be passed in and
     * can be used to store the coordinates of the point(s).
     * Each point is stored as a pair of <code>float</code> x,&nbsp;y
     * coordinates.  SEG_MOVETO and SEG_LINETO types return one
     * point, and SEG_CLOSE does not return any points.
     * @param coords a <code>float</code> array that specifies the
     * coordinates of the point(s)
     * @return an integer representing the type and coordinates of the
     *     current path segment.
     * @see PathIterator#SEG_MOVETO
     * @see PathIterator#SEG_LINETO
     * @see PathIterator#SEG_CLOSE
     */
10
    public int currentSegment(float[] coords) {
      if (index >= poly.npoints) {
        return SEG_CLOSE;
      }
      coords[0] = (float) poly.xpoints[index];
      coords[1] = (float) poly.ypoints[index];
      if (transform != null) {
        transform.transform(coords, 0, coords, 0, 1);
      }
      return (index == 0 ? SEG_MOVETO : SEG_LINETO);
###
1016, getWindingRule, PolygonPathIteratorFloat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 1031, 1032
6
/**
     * Returns the winding rule for determining the interior of the
     * path.
     * @return an integer representing the current winding rule.
     * @see PathIterator#WIND_NON_ZERO
     */
2
    public int getWindingRule() {
      return WIND_EVEN_ODD;
###
1017, currentSegment, PolygonPathIteratorFloat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 1071, 1080
18
/**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.
     * A <code>float</code> array of length 2 must be passed in and
     * can be used to store the coordinates of the point(s).
     * Each point is stored as a pair of <code>float</code> x,&nbsp;y
     * coordinates.  SEG_MOVETO and SEG_LINETO types return one
     * point, and SEG_CLOSE does not return any points.
     * @param coords a <code>float</code> array that specifies the
     * coordinates of the point(s)
     * @return an integer representing the type and coordinates of the
     *     current path segment.
     * @see PathIterator#SEG_MOVETO
     * @see PathIterator#SEG_LINETO
     * @see PathIterator#SEG_CLOSE
     */
10
    public int currentSegment(float[] coords) {
      if (index >= poly.npoints) {
        return SEG_CLOSE;
      }
      coords[0] = (float) poly.xpoints[index];
      coords[1] = (float) poly.ypoints[index];
      if (transform != null) {
        transform.transform(coords, 0, coords, 0, 1);
      }
      return (index == 0 ? SEG_MOVETO : SEG_LINETO);
###
1018, isDone, PolygonPathIteratorFloat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 1040, 1041
5
/**
     * Tests if there are more points to read.
     * @return <code>true</code> if there are more points to read;
     *      <code>false</code> otherwise.
     */
2
    public boolean isDone() {
      return index > poly.npoints;
###
1019, next, PolygonPathIteratorFloat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 1049, 1050
5
/**
     * Moves the iterator forwards, along the primary direction of
     * traversal, to the next segment of the path when there are
     * more points in that direction.
     */
2
    public void next() {
      index++;
###
1021, hashCode, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 188, 194
5
/**
   * Returns the hash code for this Insets2DDouble.
   *
   * @return  a hash code for this Insets2DDouble.
   */
7
  public int hashCode() {
    double sum1 = getLeft() + getBottom();
    double sum2 = getRight() + getTop();
    double val1 = sum1 * (sum1 + 1)/2 + getLeft();
    double val2 = sum2 * (sum2 + 1)/2 + getTop();
    double sum3 = val1 + val2;
    return java.lang.Float.floatToIntBits((float) (sum3 * (sum3 + 1)/2 + val2));
###
1023, clone, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 199, 204
3
/**
   * Creates a new object of the same class as this object.
   */
6
  public Object clone() {
    try {
      return super.clone();
    } catch (CloneNotSupportedException e) {
      // this shouldn't happen, since we are Cloneable
      throw new InternalError();
###
1024, add, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 97, 102
5
/**
   * Adds the specified insets to the current insets.
   *
   * @param i The insets to be added.
   */
6
  public void add(Insets2D i) {
    set(
        getTop() + i.getTop(),
        getLeft() + i.getLeft(),
        getBottom() + i.getBottom(),
        getRight() + i.getRight()
###
1027, subtractTo, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 155, 160
6
/**
   * Subtracts the current insets to the specified Rectangle2D making the
   * rectangle smaller.
   *
   * @param r The Rectangle2D.
   */
6
  public void subtractTo(Rectangle2D r) {
    r.setRect(
        r.getX() + getLeft(),
        r.getY() + getTop(),
        r.getWidth() - getLeft() - getRight(),
        r.getHeight() - getTop() - getBottom()
###
1029, subtract, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 141, 146
5
/**
   * Subtracts the specified insets from the current insets.
   *
   * @param i The insets to be subtracted.
   */
6
  public void subtract(Insets2D i) {
    set(
        getTop() - i.getTop(),
        getLeft() - i.getLeft(),
        getBottom() - i.getBottom(),
        getRight() - i.getRight()
###
1030, subtract, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 128, 133
8
/**
   * Subtracts the specified insets from the current insets.
   *
   * @param top The top insets.
   * @param left The left insets.
   * @param bottom The bottom insets.
   * @param right The right insets.
   */
6
  public void subtract(double top, double left, double bottom, double right) {
    set(
        getTop() - top,
        getLeft() - left,
        getBottom() - bottom,
        getRight() - right
###
1031, add, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 84, 89
8
/**
   * Adds the specified insets to the current insets.
   *
   * @param top The top insets.
   * @param left The left insets.
   * @param bottom The bottom insets.
   * @param right The right insets.
   */
6
  public void add(double top, double left, double bottom, double right) {
    set(
        getTop() + top,
        getLeft() + left,
        getBottom() + bottom,
        getRight() + right
###
1032, set, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 72, 73
5
/**
   * Sets the insets.
   *
   * @param i The new insets.
   */
2
  public void set(Insets2D i) {
    set(i.getTop(), i.getLeft(), i.getBottom(), i.getRight());
###
1033, addTo, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 112, 117
6
/**
   * Adds the current insets to the specified Rectangle2D making the
   * rectangle larger.
   *
   * @param r The Rectangle2D.
   */
6
  public void addTo(Rectangle2D r) {
    r.setRect(
        r.getX() - getLeft(),
        r.getY() - getTop(),
        r.getWidth() + getLeft() + getRight(),
        r.getHeight() + getTop() + getBottom()
###
1035, equals, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 172, 180
9
/**
   * Checks whether two insets objects are equal. Two instances
   * of <code>Insets2DDouble</code> are equal if the four integer values
   * of the fields <code>top</code>, <code>left</code>,
   * <code>bottom</code>, and <code>right</code> are all equal.
   * @return    <code>true</code> if the two insets are equal;
   *              otherwise <code>false</code>.
   * @since     JDK1.1
   */
9
  public boolean equals(Object obj) {
    if (obj instanceof Insets2D) {
      Insets2D that = (Insets2D)obj;
      return ((getTop() == that.getTop()) &&
          (getLeft() == that.getLeft()) &&
          (getBottom() == that.getBottom()) &&
          (getRight() == that.getRight()));
    }
    return false;
###
1038, Dimension2DDouble, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 72, 74
7
/** 
   * Constructs a <code>Dimension2DDouble</code> and initializes
   * it to the specified width and specified height.
   *
   * @param width the specified width 
   * @param height the specified height
   */
3
  public Dimension2DDouble(double width, double height) {
  this.width = width;
  this.height = height;
###
1039, Dimension2DDouble, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 61, 62
8
/** 
   * Creates an instance of <code>Dimension2DDouble</code> whose width  
   * and height are the same as for the specified dimension. 
   *
   * @param  d   the specified dimension for the 
   *         <code>width</code> and 
   *         <code>height</code> values
   */
2
  public Dimension2DDouble(Dimension2DDouble d) {
  this(d.width, d.height);
###
1040, hashCode, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 152, 154
5
/**
   * Returns the hash code for this <code>Dimension2DDouble</code>.
   *
   * @return  a hash code for this <code>Dimension2DDouble</code>
   */
3
  public int hashCode() {
    float sum = (float) (width + height);
    return Float.floatToIntBits(sum * (sum + 1)/2 + (float) width);
###
1041, setSize, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 103, 105
10
/**
   * Sets the size of this <code>Dimension2DDouble</code> object to
   * the specified width and height in double precision.
   * Note that if <code>width</code> or <code>height</code>
   * are larger than <code>Integer.MAX_VALUE</code>, they will
   * be reset to <code>Integer.MAX_VALUE</code>.
   *
   * @param width  the new width for the <code>Dimension2DDouble</code> object
   * @param height the new height for the <code>Dimension2DDouble</code> object
   */
3
  public void setSize(double width, double height) {
    this.width = width;
    this.height = height;
###
1042, Dimension2DDouble, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 49, 50
4
/** 
   * Creates an instance of <code>Dimension2DDouble</code> with a width 
   * of zero and a height of zero. 
   */
2
  public Dimension2DDouble() {
  this(0, 0);
###
1043, setSize, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 132, 133
9
/**
   * Sets the size of this <code>Dimension2DDouble</code> object to the specified size.
   * This method is included for completeness, to parallel the
   * <code>setSize</code> method defined by <code>Component</code>.
   * @param  d  the new size for this <code>Dimension2DDouble</code> object
   * @see    Dimension2DDouble#getSize
   * @see    java.awt.Component#setSize
   * @since  JDK1.1
   */
2
  public void setSize(Dimension2DDouble d) {
  setSize(d.width, d.height);
###
1044, getWidth, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 81, 82
4
/**
   * Returns the width of this dimension in double precision.
   * @return the width of this dimension in double precision
   */
2
  public double getWidth() {
  return width;
###
1045, getHeight, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 89, 90
4
/**
   * Returns the height of this dimension in double precision.
   * @return the height of this dimension in double precision
   */
2
  public double getHeight() {
  return height;
###
1046, getSize, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 119, 120
11
/**
   * Gets the size of this <code>Dimension2DDouble</code> object.
   * This method is included for completeness, to parallel the
   * <code>getSize</code> method defined by <code>Component</code>.
   *
   * @return   the size of this dimension, a new instance of 
   *       <code>Dimension2DDouble</code> with the same width and height
   * @see    Dimension2DDouble#setSize
   * @see    java.awt.Component#getSize
   * @since  JDK1.1
   */
2
  public Dimension2DDouble getSize() {
  return new Dimension2DDouble(width, height);
###
1047, equals, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 139, 144
3
/**
   * Checks whether two dimension objects have equal values.
   */
6
  public boolean equals(Object obj) {
  if (obj instanceof Dimension2DDouble) {
    Dimension2DDouble d = (Dimension2DDouble)obj;
    return (width == d.width) && (height == d.height);
  }
  return false;
###
1049, isSelectable, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 536, 538
4
/**
   * Checks whether this figure is selectable. By default
   * {@code AbstractFigure} can be selected.
   */
3
  @Override
  public boolean isSelectable() {
    return isSelectable;
###
1050, fireFigureRemoved, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 204, 218
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  protected void fireFigureRemoved() {
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, getBounds());
          }
          ((FigureListener) listeners[i + 1]).figureRemoved(event);
###
1051, willChange, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 409, 415
4
/**
   * Informs that a figure is about to change something that
   * affects the contents of its display box.
   */
7
  @Override
  public void willChange() {
    if (changingDepth == 0) {
      fireAreaInvalidated();
      invalidate();
    }
    changingDepth++;
###
1052, getTool, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 477, 479
4
/**
   * Returns a specialized tool for the given coordinate.
   * <p>Returns null, if no specialized tool is available.
   */
3
  @Override
  public Tool getTool(Point2D.Double p) {
    return null;
###
1053, handleMouseClick, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 485, 487
3
/**
   * Handles a mouse click.
   */
3
  @Override
  public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {
    return false;
###
1054, changed, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 424, 432
3
/**
   * Informs that a figure changed the area of its display box.
   */
9
  @Override
  public void changed() {
    if (changingDepth == 1) {
      validate();
      fireFigureChanged(getDrawingArea());
    } else if (changingDepth < 0) {
      throw new InternalError("changed was called without a prior call to willChange. "+changingDepth);
    }
    changingDepth--;
###
1055, isTransformable, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 566, 568
4
/**
   * Checks whether this figure is transformable. By default
   * {@code AbstractFigure} can be transformed.
   */
3
  @Override
  public boolean isTransformable() {
    return isTransformable;
###
1057, fireFigureAdded, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 180, 194
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  protected void fireFigureAdded() {
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, getBounds());
          }
          ((FigureListener) listeners[i + 1]).figureAdded(event);
###
1058, findConnector, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 442, 444
7
/**
   * Returns the Figures connector for the specified location.
   * By default a ChopBoxConnector is returned.
   *
   *
   * @see ChopRectangleConnector
   */
3
  @Override
  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {
    return new ChopRectangleConnector(this);
###
1059, fireFigureHandlesChanged, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 297, 312
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
16
  protected void fireFigureHandlesChanged() {
    Rectangle2D.Double changedArea = getDrawingArea();
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, changedArea);
          }
          ((FigureListener) listeners[i + 1]).figureHandlesChanged(event);
###
1060, fireAttributeChanged, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 272, 287
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
16
  protected void fireAttributeChanged(AttributeKey attribute, Object oldValue, Object newValue) {
    if (listenerList.getListenerCount() > 0 &&
        (oldValue == null || newValue == null || !oldValue.equals(newValue))) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, attribute, oldValue, newValue);
          }
          ((FigureListener) listeners[i + 1]).attributeChanged(event);
###
1061, fireAreaInvalidated, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 115, 129
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  protected void fireAreaInvalidated(Rectangle2D.Double invalidatedArea) {
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, invalidatedArea);
          }
          ((FigureListener) listeners[i + 1]).areaInvalidated(event);
###
1062, fireFigureRequestRemove, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 156, 170
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  protected void fireFigureRequestRemove() {
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, getBounds());
          }
          ((FigureListener) listeners[i + 1]).figureRequestRemove(event);
###
1063, fireAreaInvalidated, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 107, 108
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
2
  public void fireAreaInvalidated() {
    fireAreaInvalidated(getDrawingArea());
###
1066, getActions, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 468, 470
6
/**
   * Returns a collection of actions which are presented to the user
   * in a popup menu.
   * <p>The collection may contain null entries. These entries are used
   * interpreted as separators in the popup menu.
   */
3
  @Override
  public Collection<Action> getActions(Point2D.Double p) {
    return Collections.emptyList();
###
1067, fireFigureChanged, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 232, 246
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  protected void fireFigureChanged(Rectangle2D.Double changedArea) {
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, changedArea);
          }
          ((FigureListener) listeners[i + 1]).figureChanged(event);
###
1068, isConnectable, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 521, 523
4
/**
   * Checks whether this figure is connectable. By default
   * {@code AbstractFigure} can be connected.
   */
3
  @Override
  public boolean isConnectable() {
    return isConnectable;
###
1069, fireUndoableEditHappened, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 323, 325
5
/**
   * Notify all UndoableEditListener of the Drawing, to which this Figure has
   * been added to. If this Figure is not part of a Drawing, the event is
   * lost.
   */
3
  protected void fireUndoableEditHappened(UndoableEdit edit) {
    if (getDrawing() != null) {
      getDrawing().fireUndoableEditHappened(edit);
###
1071, isRemovable, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 551, 553
4
/**
   * Checks whether this figure is removable. By default
   * {@code AbstractFigure} can be removed.
   */
3
  @Override
  public boolean isRemovable() {
    return isRemovable;
###
1072, fireAreaInvalidated, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 139, 147
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
9
  protected void fireAreaInvalidated(FigureEvent event) {
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == FigureListener.class) {
        ((FigureListener) listeners[i + 1]).areaInvalidated(event);
###
1094, getKey, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 104, 105
4
/**
   * Returns the key string.
   * @return key string.
   */
2
  public String getKey() {
    return key;
###
1095, setUndoable, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 188, 219
8
/**
   * Sets the attribute and returns an UndoableEditEvent which can be used
   * to undo it.
   * <p>
   * Note: Unlike in previous versions of JHotDraw 7, this method does
   * not call {@code f.willChange()} before setting the value, and
   * {@code f.changed()} afterwards.
   */
27
  public UndoableEdit setUndoable(final Figure f, final T value) {
    if (value == null && !isNullValueAllowed) {
      throw new NullPointerException("Null value not allowed for AttributeKey " + key);
    }
    final Object restoreData = f.getAttributesRestoreData();
    f.set(this, value);
    UndoableEdit edit = new AbstractUndoableEdit() {
      @Override
      public String getPresentationName() {
        return AttributeKey.this.getPresentationName();
      }
      @Override
      public void undo() {
        super.undo();
        f.willChange();
        f.restoreAttributesTo(restoreData);
        f.changed();
      }
      @Override
      public void redo() {
        super.redo();
        f.willChange();
        f.set(AttributeKey.this, value);
        f.changed();
      }
    };
    return edit;
###
1096, getDefaultValue, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 121, 122
5
/**
   * Returns the default value of the attribute.
   *
   * @return the default value.
   */
2
  public T getDefaultValue() {
    return defaultValue;
###
1097, put, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 269, 274
8
/**
   * Use this method to perform a type-safe put operation of an attribute
   * into a Map.
   *
   * @param a An attribute map.
   * @param value The new value.
   * @return The old value.
   */
6
  @SuppressWarnings("unchecked")
  public T put(Map<AttributeKey, Object> a, T value) {
    if (value == null && !isNullValueAllowed) {
      throw new NullPointerException("Null value not allowed for AttributeKey " + key);
    }
    return (T) a.put(this, value);
###
1098, get, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 158, 160
7
/**
   * Gets the value of the attribute denoted by this AttributeKey from
   * a Map.
   * 
   * @param a A Map.
   * @return The value of the attribute.
   */
3
  @SuppressWarnings("unchecked")
  public T get(Map<AttributeKey, Object> a) {
    return a.containsKey(this) ? (T) a.get(this) : defaultValue;
###
1099, AttributeKey, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 77, 78
2
/** Creates a new instance with the specified attribute key, type token class,
   * default value, and allowing or disallowing null values. */
2
  public AttributeKey(String key, Class<T> clazz, T defaultValue, boolean isNullValueAllowed) {
    this(key, clazz, defaultValue, isNullValueAllowed, null);
###
1100, putClone, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 250, 257
6
/**
   * Convenience method for putting a clone of a value on a map.
   *
   * @param a the map
   * @param value the attribute value
   */
7
  public void putClone(Map<AttributeKey, Object> a, T value) {
    try {
       put(a, value == null ? null : clazz.cast(Methods.invoke(value, "clone")));
    } catch (NoSuchMethodException ex) {
      InternalError e = new InternalError();
      e.initCause(ex);
      throw e;
###
1101, getClone, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 128, 136
3
/**
   * Gets a clone of the value from the Figure.
   */
9
  @SuppressWarnings("unchecked")
  public T getClone(Figure f) {
    T value = f.get(this);
    try {
      return value == null ? null : clazz.cast(Methods.invoke(value, "clone"));
    } catch (NoSuchMethodException ex) {
      InternalError e = new InternalError();
      e.initCause(ex);
      throw e;
###
1102, setClone, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 233, 240
10
/**
   * Convenience method for setting a clone of a value on a figure.
   * <p>
   * Note: Unlike in previous versions of JHotDraw 7, this method does
   * not call {@code f.willChange()} before setting the value, and
   * {@code f.changed()} afterwards.
   *
   * @param f the Figure
   * @param value the attribute value
   */
7
  public void setClone(Figure f, T value) {
    try {
       f.set(this, value == null ? null : clazz.cast(Methods.invoke(value, "clone")));
    } catch (NoSuchMethodException ex) {
      InternalError e = new InternalError();
      e.initCause(ex);
      throw e;
###
1103, getPresentationName, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 112, 113
4
/**
   * Returns a localized human friendly presentation of the key.
   * @return the presentation name of the key.
   */
2
  public String getPresentationName() {
    return (labels == null) ? key : labels.getString("attribute." + key + ".text");
###
1104, get, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 147, 148
7
/**
   * Gets the value of the attribute denoted by this AttributeKey from
   * a Figure.
   * 
   * @param f A figure.
   * @return The value of the attribute.
   */
2
  public T get(Figure f) {
    return f.get(this);
###
1105, isAssignable, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 291, 296
6
/**
   * Returns true if the specified value is assignable with this key.
   *
   * @param value
   * @return True if assignable.
   */
5
  public boolean isAssignable(Object value) {
    if (value == null) {
      return isNullValueAllowed();
    }
    return clazz.isInstance(value);
###
1106, AttributeKey, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 65, 66
2
/** Creates a new instance with the specified attribute key, type token class,
   * default value null, and allowing null values. */
2
  public AttributeKey(String key, Class<T> clazz) {
    this(key, clazz, null, true);
###
1107, set, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 173, 177
10
/**
   * Convenience method for setting a value on a Figure.
   * <p>
   * Note: Unlike in previous versions of JHotDraw 7, this method does
   * not call {@code f.willChange()} before setting the value, and
   * {@code f.changed()} afterwards.
   *
   * @param f the Figure
   * @param value the attribute value
   */
5
  public void set(Figure f, T value) {
    if (value == null && !isNullValueAllowed) {
      throw new NullPointerException("Null value not allowed for AttributeKey " + key);
    }
    f.set(this, value);
###
1108, AttributeKey, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 71, 72
2
/** Creates a new instance with the specified attribute key, type token class,
   * and default value, and allowing null values. */
2
  public AttributeKey(String key, Class<T> clazz, T defaultValue) {
    this(key, clazz, defaultValue, true);
###
1109, AttributeKey, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 92, 97
11
/** Creates a new instance with the specified attribute key, type token class,
   * default value, and allowing or disallowing null values. 
   * 
   * @param key The key string. 
   * @param clazz This is used as a "type token" for assignability checks
   * at runtime.
   * @param isNullValueAllowed whether null values are allowed.
   * @param labels ResourceBundle for human friendly representation of this
   * attribute key. The ResourceBundle must have a property named
   * {@code "attribute." + key + ".text"}.
   */
6
  public AttributeKey(String key, Class<T> clazz, T defaultValue, boolean isNullValueAllowed, ResourceBundleUtil labels) {
    this.key = key;
    this.clazz = clazz;
    this.defaultValue = defaultValue;
    this.isNullValueAllowed = isNullValueAllowed;
    this.labels = (labels == null) ? ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels") : labels;
###
1110, isNullValueAllowed, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 281, 282
4
/**
   * Returns true if null values are allowed.
   * @return true if null values are allowed.
   */
2
  public boolean isNullValueAllowed() {
    return isNullValueAllowed;
###
1111, getPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 425, 426
4
/**
   * Convenience method for getting the point coordinate of
   * the first control point of the specified node.
   */
2
  public Point2D.Double getPoint(int index) {
    return path.get(index).getControlPoint(0);
###
1112, BezierFigure, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 97, 99
9
/**
   * Creates an empty BezierFigure, for example without any
   * <code>BezierPath.Node</code>s.
   * The BezierFigure will not draw anything, unless at least two nodes
   * are added to it.
   *
   * @param isClosed Specifies whether the <code>BezierPath</code> shall
   * be closed.
   */
3
  public BezierFigure(boolean isClosed) {
    path = new BezierPath();
    set(PATH_CLOSED, isClosed);
###
1113, getNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 418, 419
3
/**
   * Gets a control point.
   */
2
  public BezierPath.Node getNode(int index) {
    return (BezierPath.Node) path.get(index).clone();
###
1114, setStartPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 460, 465
5
/**
   * Convenience method for setting the point coordinate of the start point.
   * If the BezierFigure has not at least two nodes, nodes are added
   * to the figure until the BezierFigure has at least two nodes.
   */
6
  public void setStartPoint(Point2D.Double p) {
    // Add two nodes if we haven't at least two nodes
    for (int i=getNodeCount(); i < 2; i++) {
      addNode(0, new BezierPath.Node(p.x, p.y));
    }
    setPoint(0, p);
###
1115, findNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 498, 506
5
/**
   * Finds a control point index.
   * Returns -1 if no control point could be found.
   * FIXME - Move this to BezierPath
   */
9
  public int findNode(Point2D.Double p) {
    BezierPath tp = path;
    for (int i=0; i < tp.size(); i++) {
      BezierPath.Node p2 = tp.get(i);
      if (p2.x[0] == p.x && p2.y[0] == p.y) {
        return i;
      }
    }
    return -1;
###
1116, getEndPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 489, 491
3
/**
   * Convenience method for getting the end point.
   */
3
  @Override
  public Point2D.Double getEndPoint() {
    return getPoint(getNodeCount() - 1, 0);
###
1117, setPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 450, 453
3
/**
   * Sets the point coordinate of a control point.
   */
4
  public void setPoint(int index, int coord, Point2D.Double p) {
    BezierPath.Node cp = new BezierPath.Node(path.get(index));
    cp.setControlPoint(coord, p);
    setNode(index, cp);
###
1118, getStartPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 482, 484
3
/**
   * Convenience method for getting the start point.
   */
3
  @Override
  public Point2D.Double getStartPoint() {
    return getPoint(0, 0);
###
1119, splitSegment, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 624, 625
4
/**
   * Splits the segment at the given Point2D.Double if a segment was hit.
   * @return the index of the segment or -1 if no segment was hit.
   */
2
  public int splitSegment(Point2D.Double split, float tolerance) {
    return path.splitSegment(split, tolerance);
###
1120, getCappedPath, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 344, 388
7
/**
   * Returns a path which is cappedPath at the ends, to prevent
   * it from drawing under the end caps.
   */
 --------------
// EDITING
 --------------
45
  protected BezierPath getCappedPath() {
    if (cappedPath == null) {
      cappedPath = (BezierPath) path.clone();
      if (isClosed()) {
        cappedPath.setClosed(true);
      } else {
        if (cappedPath.size() > 1) {
          if (get(START_DECORATION) != null) {
            BezierPath.Node p0 = cappedPath.get(0);
            BezierPath.Node p1 = cappedPath.get(1);
            Point2D.Double pp;
            if ((p0.getMask() & BezierPath.C2_MASK) != 0) {
              pp = p0.getControlPoint(2);
            } else if ((p1.getMask() & BezierPath.C1_MASK) != 0) {
              pp = p1.getControlPoint(1);
            } else {
              pp = p1.getControlPoint(0);
            }
            double radius = get(START_DECORATION).getDecorationRadius(this);
            double lineLength = Geom.length(p0.getControlPoint(0), pp);
            cappedPath.set(0,0, Geom.cap(pp, p0.getControlPoint(0), - Math.min(radius, lineLength)));
          }
          if (get(END_DECORATION) != null) {
            BezierPath.Node p0 = cappedPath.get(cappedPath.size() - 1);
            BezierPath.Node p1 = cappedPath.get(cappedPath.size() - 2);
            
            Point2D.Double pp;
            if ((p0.getMask() & BezierPath.C1_MASK) != 0) {
              pp = p0.getControlPoint(1);
            } else if ((p1.getMask() & BezierPath.C2_MASK) != 0) {
              pp = p1.getControlPoint(2);
            } else {
              pp = p1.getControlPoint(0);
            }
            
            
            double radius = get(END_DECORATION).getDecorationRadius(this);
            double lineLength = Geom.length(p0.getControlPoint(0), pp);
            cappedPath.set(cappedPath.size() - 1, 0, Geom.cap(pp, p0.getControlPoint(0), -Math.min(radius, lineLength)));
          }
          cappedPath.invalidatePath();
        }
      }
    }
    return cappedPath;
###
1121, joinSegments, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 617, 618
5
/**
   * Joins two segments into one if the given Point2D.Double hits a node
   * of the polyline.
   * @return true if the two segments were joined.
   */
2
  public int joinSegments(Point2D.Double join, float tolerance) {
    return path.joinSegments(join, tolerance);
###
1122, BezierFigure, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 85, 86
7
/**
   * Creates an empty <code>BezierFigure</code>, for example without any
   * <code>BezierPath.Node</code>s.
   * The BezierFigure will not draw anything, if at least two nodes
   * are added to it. The <code>BezierPath</code> created by this constructor
   * is not closed.
   */
2
  public BezierFigure() {
    this(false);
###
1123, getNodeCount, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 567, 568
3
/**
   * Gets the node count.
   */
2
  public int getNodeCount() {
    return path.size();
###
1124, setPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 437, 445
3
/**
   * Sets the point coordinate of control point 0 at the specified node.
   */
9
  public void setPoint(int index, Point2D.Double p) {
    BezierPath.Node node = path.get(index);
    double dx = p.x - node.x[0];
    double dy = p.y - node.y[0];
    for (int i=0; i < node.x.length; i++) {
      node.x[i] += dx;
      node.y[i] += dy;
    }
    invalidate();
###
1125, findConnector, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 112, 114
4
/**
   * Returns the Figures connector for the specified location.
   * By default a {@link ChopBezierConnector} is returned.
   */
3
  @Override
  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {
    return new ChopBezierConnector(this);
###
1126, removeNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 555, 556
3
/**
   * Removes the Node at the specified index.
   */
2
  public BezierPath.Node removeNode(int index) {
     return path.remove(index);
###
1127, findSegment, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 517, 518
9
/**
   * Gets the segment of the polyline that is hit by
   * the given Point2D.Double.
   * 
   * @param find a Point on the bezier path
   * @param tolerance a tolerance, tolerance should take into account
   * the line width, plus 2 divided by the zoom factor. 
   * @return the index of the segment or -1 if no segment was hit.
   */
2
  public int findSegment(Point2D.Double find, double tolerance) {
    return getBezierPath().findSegment(find, tolerance);
###
1128, setBounds, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 322, 326
6
/**
   * Sets the location of the first and the last <code>BezierPath.Node</code>
   * of the BezierFigure.
   * If the BezierFigure has not at least two nodes, nodes are added
   * to the figure until the BezierFigure has at least two nodes.
   */
5
  @Override
  public void setBounds(Point2D.Double anchor, Point2D.Double lead) {
    setStartPoint(anchor);
    setEndPoint(lead);
    invalidate();
###
1129, addNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 402, 405
6
/**
   * Adds a node to the list of points.
   */
 --------------
// COMPOSITE FIGURES
 --------------
4
  public void addNode(final int index, BezierPath.Node p) {
    final BezierPath.Node newPoint = new BezierPath.Node(p);
    path.add(index, p);
    invalidate();
###
1130, getBezierPath, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 286, 287
6
/**
   * Returns a clone of the bezier path of this figure.
   */
 --------------
// SHAPE AND BOUNDS
 --------------
2
  public BezierPath getBezierPath() {
    return (BezierPath) path.clone();
###
1131, getPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 431, 432
3
/**
   * Gets the point coordinate of a control point.
   */
2
  public Point2D.Double getPoint(int index, int coord) {
    return path.get(index).getControlPoint(coord);
###
1132, setNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 410, 412
6
/**
   * Sets a control point.
   */
 --------------
// CLONING
 --------------
3
  public void setNode(int index, BezierPath.Node p) {
    path.set(index, p);
    invalidate();
###
1133, addNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 396, 397
6
/**
   * Adds a control point.
   */
 --------------
// CONNECTING
 --------------
2
  public void addNode(BezierPath.Node p) {
    addNode(getNodeCount(), p);
###
1134, joinSegments, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 529, 535
9
/**
   * Joins two segments into one if the given Point2D.Double hits a node
   * of the polyline.
   * @return true if the two segments were joined.
   *
   * @param join a Point at a node on the bezier path
   * @param tolerance a tolerance, tolerance should take into account
   * the line width, plus 2 divided by the zoom factor. 
   */
7
  public boolean joinSegments(Point2D.Double join, double tolerance) {
    int i = findSegment(join, tolerance);
    if (i != -1 && i > 1) {
      removeNode(i);
      return true;
    }
    return false;
###
1135, splitSegment, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 545, 550
8
/**
   * Splits the segment at the given Point2D.Double if a segment was hit.
   * @return the index of the segment or -1 if no segment was hit.
   *
   * @param split a Point on (or near) a line segment on the bezier path
   * @param tolerance a tolerance, tolerance should take into account
   * the line width, plus 2 divided by the zoom factor. 
   */
6
  public int splitSegment(Point2D.Double split, double tolerance) {
    int i = findSegment(split, tolerance);
    if (i != -1) {
      addNode(i + 1, new BezierPath.Node(split));
    }
    return i+1;
###
1136, removeAllNodes, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 561, 562
3
/**
   * Removes the Point2D.Double at the specified index.
   */
2
  protected void removeAllNodes() {
    path.clear();
###
1138, setEndPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 472, 477
5
/**
   * Convenience method for setting the point coordinate of the end point.
   * If the BezierFigure has not at least two nodes, nodes are added
   * to the figure until the BezierFigure has at least two nodes.
   */
6
  public void setEndPoint(Point2D.Double p) {
    // Add two nodes if we haven't at least two nodes
    for (int i=getNodeCount(); i < 2; i++) {
      addNode(0, new BezierPath.Node(p.x, p.y));
    }
    setPoint(getNodeCount() - 1, p);
###
1139, addChangeListener, AbstractConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractConstrainer.java, 44, 45
3
/**
   * Adds a <code>ChangeListener</code>.
   */
2
  public void addChangeListener(ChangeListener l) {
    listenerList.add(ChangeListener.class, l);
###
1140, removeChangeListener, AbstractConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractConstrainer.java, 51, 52
3
/**
   * Removes a <code>ChangeListener</code>.
   */
2
  public void removeChangeListener(ChangeListener l) {
    listenerList.remove(ChangeListener.class, l);
###
1169, fireUndoableEditHappened, AbstractDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractDrawing.java, 55, 69
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  @Override
  public void fireUndoableEditHappened(UndoableEdit edit) {
    UndoableEditEvent event = null;
    if (listenerList.getListenerCount() > 0) {
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (event == null) {
          event = new UndoableEditEvent(this, edit);
        }
        if (listeners[i] == UndoableEditListener.class) {
          ((UndoableEditListener) listeners[i + 1]).undoableEditHappened(event);
###
1171, getLock, AbstractDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractDrawing.java, 105, 107
3
/**
   * The drawing view synchronizes on the lock when drawing a drawing.
   */
3
  @Override
  public Object getLock() {
    return lock;
###
1174, invalidateSortOrder, DefaultDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawing.java, 202, 203
3
/**
   * Invalidates the sort order.
   */
2
  private void invalidateSortOrder() {
    needsSorting = true;
###
1175, ensureSorted, DefaultDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawing.java, 210, 213
4
/**
   * Ensures that the children are sorted in z-order sequence from back to
   * front.
   */
4
  private void ensureSorted() {
    if (needsSorting) {
      Collections.sort(children, FigureLayerComparator.INSTANCE);
      needsSorting = false;
###
1176, getFiguresFrontToBack, DefaultDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawing.java, 194, 196
4
/**
   * Returns an iterator to iterate in
   * Z-order front to back over the children.
   */
3
  public java.util.List<Figure> getFiguresFrontToBack() {
    ensureSorted();
    return new ReversedList<Figure>(getChildren());
###
1177, createInputMap, DefaultDrawingEditor, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingEditor.java, 303, 341
16
/** Override this method to create a tool-specific input map, which
   * overrides the input map of the drawing edtior.
   * <p>
   * The implementation of this class creates an input map for the following
   * action ID's:
   * <ul>
   * <li>DeleteAction</li>
   * <li>SelectAllAction/li>
   * <li>IncreaseHandleDetailLevelAction</li>
   * <li>MoveConstrainedAction.West, .East, .North, .South</li>
   * <li>MoveAction.West, .East, .North, .South</li>
   * <li>CutAction</li>
   * <li>CopyAction</li>
   * <li>PasteAction</li>
   * </ul>
   */
32
  protected InputMap createInputMap() {
    InputMap m = new InputMap();
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0), DeleteAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_BACK_SPACE, 0), DeleteAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, 0), SelectAllAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, InputEvent.CTRL_DOWN_MASK), SelectAllAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, InputEvent.META_DOWN_MASK), SelectAllAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), IncreaseHandleDetailLevelAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0), MoveConstrainedAction.West.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0), MoveConstrainedAction.East.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0), MoveConstrainedAction.North.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), MoveConstrainedAction.South.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, InputEvent.ALT_DOWN_MASK), MoveAction.West.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, InputEvent.ALT_DOWN_MASK), MoveAction.East.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.ALT_DOWN_MASK), MoveAction.North.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, InputEvent.ALT_DOWN_MASK), MoveAction.South.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, InputEvent.SHIFT_DOWN_MASK), MoveAction.West.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, InputEvent.SHIFT_DOWN_MASK), MoveAction.East.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.SHIFT_DOWN_MASK), MoveAction.North.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, InputEvent.SHIFT_DOWN_MASK), MoveAction.South.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, InputEvent.CTRL_DOWN_MASK), MoveAction.West.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, InputEvent.CTRL_DOWN_MASK), MoveAction.East.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.CTRL_DOWN_MASK), MoveAction.North.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, InputEvent.CTRL_DOWN_MASK), MoveAction.South.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_DOWN_MASK), CopyAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.META_DOWN_MASK), CopyAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_DOWN_MASK), PasteAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.META_DOWN_MASK), PasteAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.CTRL_DOWN_MASK), CutAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.META_DOWN_MASK), CutAction.ID);

    return m;
###
1178, DefaultDrawingEditor, DefaultDrawingEditor, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingEditor.java, 108, 116
1
/** Creates a new instance. */
8
  public DefaultDrawingEditor() {
    toolHandler = new ToolHandler();
    setDefaultAttribute(FILL_COLOR, Color.white);
    setDefaultAttribute(STROKE_COLOR, Color.black);
    setDefaultAttribute(TEXT_COLOR, Color.black);
    views = new HashSet<DrawingView>();
    inputMap = createInputMap();
    actionMap = createActionMap();
###
1179, setTarget, DrawingEditorProxy, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DrawingEditorProxy.java, 62, 68
3
/**
   * Sets the target of the proxy.
   */
7
  public void setTarget(DrawingEditor newValue) {
    if (target != null) {
      target.removePropertyChangeListener(forwarder);
    }
    this.target = newValue;
    if (target != null) {
      target.addPropertyChangeListener(forwarder);
###
1180, DrawingEditorProxy, DrawingEditorProxy, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DrawingEditorProxy.java, 55, 56
1
/** Creates a new instance. */
2
  public DrawingEditorProxy() {
    forwarder = new Forwarder();
###
1203, getDefaultEventIndex, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 145, 146
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1204, getDefaultPropertyIndex, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 134, 135
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1207, getEventSetDescriptors, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 111, 112
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1208, getPropertyDescriptors, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 100, 101
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1210, getMethodDescriptors, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 122, 123
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1211, getBeanDescriptor, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 84, 85
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1228, createEditorColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 559, 637
31
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Microsoft Office:
   * <ul>
   * <li>When the user clicks on the action region, the default color of the
   * DrawingEditor is applied to the selected figures.</li>
   * <li>When the user opens the popup menu, a color palette is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A shape on the color button displays the current default color of the
   * DrawingEditor.</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   * @param colorShape This shape is superimposed on the icon of the button.
   * The shape is drawn with the default color of the DrawingEditor.
   */
73
  public static JPopupButton createEditorColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes,
      Shape colorShape) {
    final JPopupButton popupButton = new JPopupButton();
    popupButton.setPopupAlpha(1f);
    if (defaultAttributes == null) {
      defaultAttributes = new HashMap<AttributeKey, Object>();
    }
    popupButton.setAction(
        new DefaultAttributeAction(editor, attributeKey, defaultAttributes),
        new Rectangle(0, 0, 22, 22));
    popupButton.setColumnCount(columnCount, false);
    boolean hasNullColor = false;
    for (ColorIcon swatch : swatches) {
      AttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, swatch.getColor());
      if (swatch.getColor() == null) {
        hasNullColor = true;
      }
      popupButton.add(a =
          new AttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty(labelKey),
          swatch));
      a.putValue(Action.SHORT_DESCRIPTION, swatch.getName());
      a.setUpdateEnabledState(false);
    }
    // No color
    if (!hasNullColor) {
      AttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, null);
      popupButton.add(a =
          new AttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty("attribute.color.noColor"),
          new ColorIcon(null, labels.getToolTipTextProperty("attribute.color.noColor"), swatches.get(0).getIconWidth(), swatches.get(0).getIconHeight())));
      a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.noColor"));
      a.setUpdateEnabledState(false);
    }
    // Color chooser
    ImageIcon chooserIcon = new ImageIcon(
        Images.createImage(
        ButtonFactory.class, "/org/jhotdraw/draw/action/images/attribute.color.colorChooser.png"));
    Action a;
    popupButton.add(
        a = new EditorColorChooserAction(
        editor,
        attributeKey,
        "color",
        chooserIcon,
        defaultAttributes));
    labels.configureToolBarButton(popupButton, labelKey);
    a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.colorChooser"));
    Icon icon = new EditorColorIcon(editor,
        attributeKey,
        labels.getIconProperty(labelKey, ButtonFactory.class).getImage(),
        colorShape);
    popupButton.setIcon(icon);
    popupButton.setDisabledIcon(icon);
    popupButton.setFocusable(false);
    editor.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        popupButton.repaint();
      }
    });
    return popupButton;
###
1235, createSelectionColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 748, 756
31
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Adobe Fireworks:
   * <ul>
   * <li>When the user clicks at the button a popup menu with a color palette
   * is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A shape on the color button displays the color of the selected
   * figures. If no figures are selected, the default color of the
   * DrawingEditor is displayed.</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   * @param colorShape This shape is superimposed on the icon of the button.
   * The shape is drawn with the default color of the DrawingEditor.
   */
9
  public static JPopupButton createSelectionColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes,
      Shape colorShape) {
    return createSelectionColorButton(editor, attributeKey,
        swatches, columnCount, labelKey, labels, defaultAttributes,
        colorShape, new LinkedList<Disposable>());
###
1238, createDrawingColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 879, 887
16
/**
   * Creates a color button, with an action region and a popup menu. The
   * button acts on attributes of the Drawing object in the current DrawingView
   * of the DrawingEditor.
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   */
9
  public static JPopupButton createDrawingColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels) {
    return createDrawingColorButton(
        editor, attributeKey,
        swatches, columnCount,
        labelKey, labels,
        null);
###
1245, addAlignmentButtonsTo, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 1499, 1528
3
/**
   * Creates toolbar buttons and adds them to the specified JToolBar.
   */
29
  public static void addAlignmentButtonsTo(JToolBar bar, final DrawingEditor editor, java.util.List<Disposable> dsp) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    AbstractSelectedAction d;
    bar.add(d = new AlignAction.West(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new AlignAction.East(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new AlignAction.Horizontal(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new AlignAction.North(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new AlignAction.South(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new AlignAction.Vertical(editor)).setFocusable(false);
    dsp.add(d);
    bar.addSeparator();
    bar.add(d = new MoveAction.West(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new MoveAction.East(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new MoveAction.North(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new MoveAction.South(editor)).setFocusable(false);
    dsp.add(d);
    bar.addSeparator();
    bar.add(new BringToFrontAction(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(new SendToBackAction(editor)).setFocusable(false);
    dsp.add(d);
###
1249, createSelectionColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 667, 675
27
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Adobe Fireworks:
   * <ul>
   * <li>When the user clicks at the button a popup menu with a color palette
   * is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A shape on the color button displays the color of the selected
   * figures. If no figures are selected, the default color of the
   * DrawingEditor is displayed.</li>
   * <li>A rectangle on the color button displays the current default color of
   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,
   * width, height).</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   */
9
  public static JPopupButton createSelectionColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels) {
    return createSelectionColorButton(
        editor, attributeKey,
        swatches, columnCount,
        labelKey, labels,
        null);
###
1252, createDrawingColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 911, 918
21
/**
   * Creates a color button, with an action region and a popup menu. The
   * button acts on attributes of the Drawing object in the current DrawingView
   * of the DrawingEditor.
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   */
8
  public static JPopupButton createDrawingColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes) {
    return createDrawingColorButton(editor, attributeKey,
        swatches, columnCount, labelKey, labels, defaultAttributes,
        new Rectangle(1, 17, 20, 4));
###
1253, createDrawingColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 944, 952
23
/**
   * Creates a color button, with an action region and a popup menu. The
   * button acts on attributes of the Drawing object in the current DrawingView
   * of the DrawingEditor.
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   * @param colorShape This shape is superimposed on the icon of the button.
   * The shape is drawn with the default color of the DrawingEditor.
   */
9
  public static JPopupButton createDrawingColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes,
      Shape colorShape) {
    return createDrawingColorButton(editor, attributeKey,
        swatches, columnCount, labelKey, labels, defaultAttributes,
        colorShape, new LinkedList<Disposable>());
###
1254, addAttributesButtonsTo, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 422, 436
3
/**
   * Creates toolbar buttons and adds them to the specified JToolBar
   */
13
  public static void addAttributesButtonsTo(JToolBar bar, DrawingEditor editor) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    JButton b;
    b = bar.add(new PickAttributesAction(editor));
    b.setFocusable(false);
    b = bar.add(new ApplyAttributesAction(editor));
    b.setFocusable(false);
    bar.addSeparator();
    addColorButtonsTo(bar, editor);
    bar.addSeparator();
    addStrokeButtonsTo(bar, editor);
    bar.addSeparator();
    addFontButtonsTo(bar, editor);
###
1255, addAlignmentButtonsTo, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 1492, 1493
3
/**
   * Creates toolbar buttons and adds them to the specified JToolBar
   */
2
  public static void addAlignmentButtonsTo(JToolBar bar, final DrawingEditor editor) {
    addAlignmentButtonsTo(bar, editor, new LinkedList<Disposable>());
###
1256, createSelectionColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 707, 714
29
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Adobe Fireworks:
   * <ul>
   * <li>When the user clicks at the button a popup menu with a color palette
   * is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A rectangle on the color button displays the current default color of
   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,
   * width, height).</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   */
8
  public static JPopupButton createSelectionColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes) {
    return createSelectionColorButton(editor, attributeKey,
        swatches, columnCount, labelKey, labels, defaultAttributes,
        new Rectangle(1, 17, 20, 4));
###
1257, createEditorColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 477, 485
25
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Microsoft Office:
   * <ul>
   * <li>When the user clicks on the action region, the default color of the
   * DrawingEditor is applied to the selected figures.</li>
   * <li>When the user opens the popup menu, a color palette is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A rectangle on the color button displays the current default color of
   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,
   * width, height).</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   */
9
  public static JPopupButton createEditorColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels) {
    return createEditorColorButton(
        editor, attributeKey,
        swatches, columnCount,
        labelKey, labels,
        null);
###
1258, addToolTo, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 313, 328
5
/**
   * Method addSelectionToolTo must have been invoked prior to this on the
   * JToolBar.
   *
   */
13
  public static JToggleButton addToolTo(JToolBar tb, DrawingEditor editor,
      Tool tool, String labelKey,
      ResourceBundleUtil labels) {
    ButtonGroup group = (ButtonGroup) tb.getClientProperty("toolButtonGroup");
    ToolListener toolHandler = (ToolListener) tb.getClientProperty("toolHandler");
    JToggleButton t = new JToggleButton();
    labels.configureToolBarButton(t, labelKey);
    t.addItemListener(new ToolButtonListener(tool, editor));
    t.setFocusable(false);
    tool.addToolListener(toolHandler);
    group.add(t);
    tb.add(t);
    return t;
###
1259, createDrawingColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 978, 1052
23
/**
   * Creates a color button, with an action region and a popup menu. The
   * button acts on attributes of the Drawing object in the current DrawingView
   * of the DrawingEditor.
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   * @param colorShape This shape is superimposed on the icon of the button.
   * The shape is drawn with the default color of the DrawingEditor.
   */
70
  public static JPopupButton createDrawingColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes,
      Shape colorShape, java.util.List<Disposable> dsp) {
    final JPopupButton popupButton = new JPopupButton();
    popupButton.setPopupAlpha(1f);
    if (defaultAttributes == null) {
      defaultAttributes = new HashMap<AttributeKey, Object>();
    }
    popupButton.setColumnCount(columnCount, false);
    boolean hasNullColor = false;
    for (ColorIcon swatch : swatches) {
      DrawingAttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, swatch.getColor());
      if (swatch.getColor() == null) {
        hasNullColor = true;
      }
      popupButton.add(a =
          new DrawingAttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty(labelKey),
          swatch));
      dsp.add(a);
      a.putValue(Action.SHORT_DESCRIPTION, swatch.getName());
      a.setUpdateEnabledState(false);
    }
    // No color
    if (!hasNullColor) {
      DrawingAttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, null);
      popupButton.add(a =
          new DrawingAttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty("attribute.color.noColor"),
          new ColorIcon(null, labels.getToolTipTextProperty("attribute.color.noColor"))));
      dsp.add(a);
      a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.noColor"));
      a.setUpdateEnabledState(false);
    }
    // Color chooser
    ImageIcon chooserIcon = new ImageIcon(
        Images.createImage(ButtonFactory.class, "/org/jhotdraw/draw/action/images/attribute.color.colorChooser.png"));
    DrawingColorChooserAction a;
    popupButton.add(
        a = new DrawingColorChooserAction(
        editor,
        attributeKey,
        "color",
        chooserIcon,
        defaultAttributes));
    dsp.add(a);
    labels.configureToolBarButton(popupButton, labelKey);
    a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.colorChooser"));
    Icon icon = new DrawingColorIcon(editor,
        attributeKey,
        labels.getIconProperty(labelKey, ButtonFactory.class).getImage(),
        colorShape);
    popupButton.setIcon(icon);
    popupButton.setDisabledIcon(icon);
    popupButton.setFocusable(false);
    if (editor != null) {
      dsp.add(new SelectionComponentRepainter(editor, popupButton));
    }
    return popupButton;
###
1260, createEditorColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 518, 525
30
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Microsoft Office:
   * <ul>
   * <li>When the user clicks on the action region, the default color of the
   * DrawingEditor is applied to the selected figures.</li>
   * <li>When the user opens the popup menu, a color palette is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A rectangle on the color button displays the current default color of
   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,
   * width, height).</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   */
8
  public static JPopupButton createEditorColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes) {
    return createEditorColorButton(editor, attributeKey,
        swatches, columnCount, labelKey, labels, defaultAttributes,
        new Rectangle(1, 17, 20, 4));
###
1261, createToggleGridButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 1536, 1560
4
/**
   * Creates a button which toggles between two GridConstrainer for
   * a DrawingView.
   */
21
  public static AbstractButton createToggleGridButton(final DrawingView view) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    final JToggleButton toggleButton;
    toggleButton = new JToggleButton();
    labels.configureToolBarButton(toggleButton, "view.toggleGrid");
    toggleButton.setFocusable(false);
    toggleButton.addItemListener(new ItemListener() {
      public void itemStateChanged(ItemEvent event) {
        view.setConstrainerVisible(toggleButton.isSelected());
      //view.getComponent().repaint();
      }
    });
    view.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        // String constants are interned
        if (evt.getPropertyName() == DrawingView.CONSTRAINER_VISIBLE_PROPERTY) {
          toggleButton.setSelected(view.isConstrainerVisible());
        }
      }
    });
    return toggleButton;
###
1262, createSelectionColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 790, 860
31
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Adobe Fireworks:
   * <ul>
   * <li>When the user clicks at the button a popup menu with a color palette
   * is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A shape on the color button displays the color of the selected
   * figures. If no figures are selected, the default color of the
   * DrawingEditor is displayed.</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   * @param colorShape This shape is superimposed on the icon of the button.
   * The shape is drawn with the default color of the DrawingEditor.
   */
68
  public static JPopupButton createSelectionColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes,
      Shape colorShape, java.util.List<Disposable> dsp) {
    final JPopupButton popupButton = new JPopupButton();
    popupButton.setPopupAlpha(1f);
    if (defaultAttributes == null) {
      defaultAttributes = new HashMap<AttributeKey, Object>();
    }
    popupButton.setColumnCount(columnCount, false);
    boolean hasNullColor = false;
    for (ColorIcon swatch : swatches) {
      AttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, swatch.getColor());
      if (swatch.getColor() == null) {
        hasNullColor = true;
      }
      popupButton.add(a =
          new AttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty(labelKey),
          swatch));
      a.putValue(Action.SHORT_DESCRIPTION, swatch.getName());
      a.setUpdateEnabledState(false);
      dsp.add(a);
    }
    // No color
    if (!hasNullColor) {
      AttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, null);
      popupButton.add(a =
          new AttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty("attribute.color.noColor"),
          new ColorIcon(null, labels.getToolTipTextProperty("attribute.color.noColor"))));
      a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.noColor"));
      a.setUpdateEnabledState(false);
      dsp.add(a);
    }
    // Color chooser
    ImageIcon chooserIcon = new ImageIcon(
        Images.createImage(ButtonFactory.class, "/org/jhotdraw/draw/action/images/attribute.color.colorChooser.png"));
    AttributeAction a;
    popupButton.add(
        a = new SelectionColorChooserAction(
        editor,
        attributeKey,
        labels.getToolTipTextProperty("attribute.color.colorChooser"),
        chooserIcon,
        defaultAttributes));
    a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.colorChooser"));
    dsp.add(a);
    labels.configureToolBarButton(popupButton, labelKey);
    Icon icon = new SelectionColorIcon(editor,
        attributeKey,
        labels.getIconProperty(labelKey, ButtonFactory.class).getImage(),
        colorShape);
    popupButton.setIcon(icon);
    popupButton.setDisabledIcon(icon);
    popupButton.setFocusable(false);
    dsp.add(new SelectionComponentRepainter(editor, popupButton));
    return popupButton;
###
1264, DefaultAttributeAction, DefaultAttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DefaultAttributeAction.java, 38, 39
1
/** Creates a new instance. */
2
  public DefaultAttributeAction(DrawingEditor editor, AttributeKey key) {
    this(editor, key, null, null);
###
1265, DefaultAttributeAction, DefaultAttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DefaultAttributeAction.java, 48, 49
1
/** Creates a new instance. */
2
  public DefaultAttributeAction(DrawingEditor editor, AttributeKey key, Icon icon) {
    this(editor, key, null, icon);
###
1266, setDrawing, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 71, 76
5
/**
   * Sets the GridConstrainer to be edited by this panel.
   * 
   * @param newValue The GridConstrainer.
   */
6
  public void setDrawing(Drawing newValue) {
    drawing = newValue;
    // XXX - This does not work, we must pass the drawing editor here!
    opacitySliderHandler.setDrawing(drawing);
    opacityFieldHandler.setDrawing(drawing);
    updatePanel();
###
1268, updateDrawing, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 82, 88
3
/**
   * Updates the drawing due to changes made on this panel.
   */
7
  private void updateDrawing() {
    if (drawing != null) {
      drawing.willChange();
      drawing.fireUndoableEditHappened(
          CANVAS_FILL_COLOR.setUndoable(drawing, colorButton.getBackground())
          );
      drawing.changed();
###
1269, EditCanvasPanel, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 44, 57
1
/** Creates new form. */
14
  public EditCanvasPanel() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    colorButton.putClientProperty("Quaqua.Button.style", "colorWell");
    opacitySlider = new JAttributeSlider(JSlider.VERTICAL, 0, 100, 100);
    opacityPopupButton.add(opacitySlider);
    opacityPopupButton.putClientProperty("JButton.buttonType", "toolbar");
    add(opacityPopupButton);
    NumberFormatter nf = new NumberFormatter();
    nf.setMaximum(1d);
    nf.setMinimum(0d);
    opacityField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0d, 1d, 100d));
    opacityFieldHandler=new DrawingAttributeEditorHandler<Double>(CANVAS_FILL_OPACITY, opacityField, null);
    opacitySliderHandler=new DrawingAttributeEditorHandler<Double>(CANVAS_FILL_OPACITY, opacitySlider, null);
###
1270, initComponents, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 129, 165
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
30
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    bgColorButtonGroup = new javax.swing.ButtonGroup();
    colorLabel = new javax.swing.JLabel();
    colorButton = new javax.swing.JButton();
    opacityLabel = new javax.swing.JLabel();
    opacityField = new org.jhotdraw.gui.JAttributeTextField<Double>();
    opacityPopupButton = new org.jhotdraw.gui.JPopupButton();
    setLayout(new java.awt.GridBagLayout());
    colorLabel.setText(labels.getString("attribute.canvasFillColor.text")); // NOI18N
    colorLabel.setToolTipText(labels.getString("attribute.backgroundColor.toolTipText")); // NOI18N
    add(colorLabel, new java.awt.GridBagConstraints());
    colorButton.setText(" ");
    colorButton.setToolTipText(labels.getString("attribute.backgroundColor.toolTipText")); // NOI18N
    colorButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        colorButtonPerformed(evt);
      }
    });
    add(colorButton, new java.awt.GridBagConstraints());
    opacityLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jhotdraw/draw/action/images/attributeOpacity.png"))); // NOI18N
    opacityLabel.setToolTipText(labels.getString("attribute.opacity.toolTipText")); // NOI18N
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
    add(opacityLabel, gridBagConstraints);
    opacityField.setColumns(3);
    add(opacityField, new java.awt.GridBagConstraints());
    opacityPopupButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jhotdraw/draw/action/images/popupIcon.png"))); // NOI18N
    opacityPopupButton.setToolTipText(labels.getString("attribute.opacity.toolTipText")); // NOI18N
    add(opacityPopupButton, new java.awt.GridBagConstraints());
###
1271, getDrawing, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 106, 107
5
/**
   * Returns the GridConstrainer currently being edited by this panel.
   * 
   * @return The GridConstrainer.
   */
2
  public Drawing getDrawing() {
    return drawing;
###
1272, updatePanel, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 95, 97
3
/**
   * Updates the panel due to changes made on the drawing.
   */
3
  private void updatePanel() {
    if (drawing != null) {
      colorButton.setBackground(drawing.get(CANVAS_FILL_COLOR));
###
1273, DrawingAttributeAction, DrawingAttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingAttributeAction.java, 40, 41
1
/** Creates a new instance. */
2
  public DrawingAttributeAction(DrawingEditor editor, AttributeKey key, Object value, Icon icon) {
    this(editor, key, value, null, icon);
###
1274, DrawingAttributeAction, DrawingAttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingAttributeAction.java, 35, 36
1
/** Creates a new instance. */
2
  public DrawingAttributeAction(DrawingEditor editor, AttributeKey key, Object value) {
    this(editor, key, value, null, null);
###
1275, ColorIcon, ColorIcon, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ColorIcon.java, 36, 37
1
/** Creates a new instance. */
2
  public ColorIcon(int rgb) {
    this(new Color(rgb));
###
1276, DrawingColorChooserAction, DrawingColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingColorChooserAction.java, 34, 35
1
/** Creates a new instance. */
2
  public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {
    this(editor, key, null, null);
###
1277, DrawingColorChooserAction, DrawingColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingColorChooserAction.java, 42, 43
1
/** Creates a new instance. */
2
  public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, String name) {
    this(editor, key, name, null);
###
1278, DrawingColorChooserAction, DrawingColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingColorChooserAction.java, 38, 39
1
/** Creates a new instance. */
2
  public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {
    this(editor, key, null, icon);
###
1279, initComponents, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 271, 273
7
/** This method is called from within the constructor to
   * initialize the form.<p>
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.<p>
   * NOTE: To prevent undesired layout effects when using floating
   * text fields, the DefaultDrawingView must not use a layout manager.
   */
2
  private void initComponents() {
    setLayout(null);
###
1280, toggleSelection, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 833, 838
4
/**
   * If a figure isn't selected it is added to the selection.
   * Otherwise it is removed from the selection.
   */
6
  @Override
  public void toggleSelection(Figure figure) {
    if (selectedFigures.contains(figure)) {
      removeFromSelection(figure);
    } else {
      addToSelection(figure);
###
1281, getBackgroundPaint, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1547, 1561
4
/**
   * Returns a paint for drawing the background of the drawing area.
   * @return Paint.
   */
14
  protected Paint getBackgroundPaint(
      int x, int y) {
    if (backgroundTile == null) {
      backgroundTile = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
      Graphics2D g = backgroundTile.createGraphics();
      g.setColor(Color.white);
      g.fillRect(0, 0, 16, 16);
      g.setColor(new Color(0xdfdfdf));
      g.fillRect(0, 0, 8, 8);
      g.fillRect(8, 8, 8, 8);
      g.dispose();
    }
    return new TexturePaint(backgroundTile,
        new Rectangle(x, y, backgroundTile.getWidth(), backgroundTile.getHeight()));
###
1282, invalidateHandles, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 931, 962
3
/**
   * Invalidates the handles.
   */
27
  private void invalidateHandles() {
    if (handlesAreValid) {
      handlesAreValid = false;
      Rectangle invalidatedArea = null;
      for (Handle handle : selectionHandles) {
        handle.removeHandleListener(eventHandler);
        if (invalidatedArea == null) {
          invalidatedArea = handle.getDrawingArea();
        } else {
          invalidatedArea.add(handle.getDrawingArea());
        }
        handle.dispose();
      }
      for (Handle handle : secondaryHandles) {
        handle.removeHandleListener(eventHandler);
        if (invalidatedArea == null) {
          invalidatedArea = handle.getDrawingArea();
        } else {
          invalidatedArea.add(handle.getDrawingArea());
        }
        handle.dispose();
      }
      selectionHandles.clear();
      secondaryHandles.clear();
      setActiveHandle(null);
      if (invalidatedArea != null) {
        repaint(invalidatedArea);
###
1284, selectAll, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 852, 868
3
/**
   * Selects all selectable figures.
   */
13
  @Override
  public void selectAll() {
    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);
    selectedFigures.clear();
    for (Figure figure : drawing.getChildren()) {
      if (figure.isSelectable()) {
        selectedFigures.add(figure);
      }
    }
    Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);
    invalidateHandles();
    fireSelectionChanged(oldSelection, newSelection);
    repaint();
###
1285, drawCanvas, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 589, 611
4
/** Draws the canvas. If the {@code AttributeKeys.CANVAS_FILL_OPACITY} is
   * not fully opaque, the canvas area is filled with the background paint
   * before the {@code AttributeKeys.CANVAS_FILL_COLOR} is drawn.
   */
19
  protected void drawCanvas(Graphics2D g) {
    Rectangle cb = getCanvasViewBounds();
    // Retrieve the canvasColor color from the drawing
    Color canvasColor;
    if (drawing == null) {
      canvasColor = CANVAS_FILL_COLOR.getDefaultValue();
    } else {
      canvasColor = drawing.get(CANVAS_FILL_COLOR);
      if (canvasColor != null) {
        canvasColor = new Color((canvasColor.getRGB() & 0xffffff) | ((int) (drawing.get(CANVAS_FILL_OPACITY) * 255) << 24), true);
      }
    }
    if (canvasColor == null || canvasColor.getAlpha() != 255) {
      g.setPaint(getBackgroundPaint(cb.x, cb.y));
      g.fillRect(cb.x, cb.y, cb.width, cb.height);
    }
    if (canvasColor != null) {
      g.setColor(canvasColor);
      g.fillRect(cb.x, cb.y, cb.width, cb.height);
###
1286, drawDrawingNonvolatileBuffered, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 435, 522
1
/** Draws the drawing double buffered using a buffered image. */
78
  protected void drawDrawingNonvolatileBuffered(Graphics2D g) {
    Rectangle vr = getVisibleRect();
    Point shift = new Point(0, 0);
    if (bufferedArea.contains(vr) ||
        bufferedArea.width >= vr.width && bufferedArea.height >= vr.height) {
      // The visible rect fits into the buffered area, but may be shifted; shift the buffered area.
      shift.x = bufferedArea.x - vr.x;
      shift.y = bufferedArea.y - vr.y;
      if (shift.x > 0) {
        dirtyArea.add(new Rectangle(bufferedArea.x - shift.x, vr.y, shift.x + bufferedArea.width - vr.width, bufferedArea.height));
      } else if (shift.x < 0) {
        dirtyArea.add(new Rectangle(bufferedArea.x + vr.width, vr.y, -shift.x + bufferedArea.width - vr.width, bufferedArea.height));
      }
      if (shift.y > 0) {
        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y - shift.y, bufferedArea.width, shift.y + bufferedArea.height - vr.height));
      } else if (shift.y < 0) {
        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y + vr.height, bufferedArea.width, -shift.y + bufferedArea.height - vr.height));
      }
      bufferedArea.x = vr.x;
      bufferedArea.y = vr.y;
    } else {
      // The buffered drawing area does not match the visible rect;
      // resize it, and mark everything as dirty.
      bufferedArea.setBounds(vr);
      dirtyArea.setBounds(vr);
      if (drawingBufferNV != null && //
          (drawingBufferNV.getWidth() != vr.width ||
          drawingBufferNV.getHeight() != vr.height)) {
        // The dimension of the drawing buffer does not fit into the visible rect;
        // throw the buffer away.
        drawingBufferNV.flush();
        drawingBufferNV = null;
      }
    }
    // Update the contents of the buffer if necessary
    int valid = (drawingBufferNV == null) ? //
        VolatileImage.IMAGE_INCOMPATIBLE : VolatileImage.IMAGE_OK;
    switch (valid) {
      case VolatileImage.IMAGE_INCOMPATIBLE:
        // old buffer doesn't work with new GraphicsConfig; (re-)create it
        try {
          drawingBufferNV = getGraphicsConfiguration().createCompatibleImage(vr.width, vr.height, Transparency.TRANSLUCENT);
        } catch (OutOfMemoryError e) {
          drawingBufferNV = null;
        }
        dirtyArea.setBounds(bufferedArea);
        break;
    }
    if (drawingBufferNV == null) {
      // There is not enough memory available for a drawing buffer;
      // draw without buffering.
      drawDrawing(g);
      return;
    }
    if (!dirtyArea.isEmpty()) {
      // An area of the drawing buffer is dirty; repaint it
      Graphics2D gBuf = drawingBufferNV.createGraphics();
      setViewRenderingHints(gBuf);
      // For shifting and cleaning, we need to erase everything underneath
      gBuf.setComposite(AlphaComposite.Src);
      // Perform shifting if needed
      if (shift.x != 0 || shift.y != 0) {
        gBuf.copyArea(Math.max(0, -shift.x), Math.max(0, -shift.y), drawingBufferNV.getWidth() - Math.abs(shift.x), drawingBufferNV.getHeight() - Math.abs(shift.y), shift.x, shift.y);
        shift.x = shift.y = 0;
      }
      // Clip the dirty area
      gBuf.translate(-bufferedArea.x, -bufferedArea.y);
      gBuf.clip(dirtyArea);
      // Clear the dirty area
      gBuf.setBackground(new Color(0x0, true));
      gBuf.clearRect(dirtyArea.x, dirtyArea.y, dirtyArea.width, dirtyArea.height);
      gBuf.setComposite(AlphaComposite.SrcOver);
      // Repaint the dirty area
      drawDrawing(gBuf);
      gBuf.dispose();
    }
    g.drawImage(drawingBufferNV, bufferedArea.x, bufferedArea.y, null);
    dirtyArea.setSize(-1, -1);
###
1287, printComponent, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 530, 543
5
/**
   * Prints the drawing view.
   * Uses high quality rendering hints for printing. Only prints the drawing.
   * Doesn't print the canvasColor, the grid, the handles and the tool.
   */
12
  @Override
  public void printComponent(Graphics gr) {
    Graphics2D g = (Graphics2D) gr;
    // Set rendering hints for quality
    g.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);
    g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
    g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
    g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    drawDrawing(g);
###
1288, isDrawingDoubleBuffered, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1539, 1540
2
/** Returns true, if the the drawing is double buffered.
   */
2
  public boolean isDrawingDoubleBuffered() {
    return isDrawingDoubleBuffered;
###
1289, viewToDrawing, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1266, 1270
3
/**
   * Converts view coordinates to drawing coordinates.
   */
5
  @Override
  public Point2D.Double viewToDrawing(Point p) {
    return new Point2D.Double(
        (p.x + translation.x) / scaleFactor,
        (p.y + translation.y) / scaleFactor);
###
1290, addToSelection, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 737, 762
3
/**
   * Adds a figure to the current selection.
   */
24
  public void addToSelection(Figure figure) {
    if (DEBUG) {
      System.out.println("DefaultDrawingView" + ".addToSelection(" + figure + ")");
    }
    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);
    if (selectedFigures.add(figure)) {
      figure.addFigureListener(handleInvalidator);
      Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);
      Rectangle invalidatedArea = null;
      if (handlesAreValid && getEditor() != null) {
        for (Handle h : figure.createHandles(detailLevel)) {
          h.setView(this);
          selectionHandles.add(h);
          h.addHandleListener(eventHandler);
          if (invalidatedArea == null) {
            invalidatedArea = h.getDrawingArea();
          } else {
            invalidatedArea.add(h.getDrawingArea());
          }
        }
      }
      fireSelectionChanged(oldSelection, newSelection);
      if (invalidatedArea != null) {
        repaint(invalidatedArea);
###
1291, paintComponent, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 309, 327
5
/**
   * Paints the drawing view.
   * Uses rendering hints for fast painting. Paints the canvasColor, the
   * grid, the drawing, the handles and the current tool.
   */
19
  @Override
  public void paintComponent(Graphics gr) {
    long start = System.currentTimeMillis();
    Graphics2D g = (Graphics2D) gr;
    setViewRenderingHints(g);
    drawBackground(g);
    drawCanvas(g);
    drawConstrainer(g);
    if (isDrawingDoubleBuffered()) {
      if (isWindows) {
        drawDrawingNonvolatileBuffered(g);
      } else {
        drawDrawingVolatileBuffered(g);
      }
    } else {
      drawDrawing(g);
    }
    drawHandles(g);
    drawTool(g);
###
1292, drawBackground, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 135, 137
1
/** Draws the background of the drawing view. */
3
  protected void drawBackground(Graphics2D g) {
    g.setColor(getBackground());
    g.fillRect(0, 0, getWidth(), getHeight());
###
1293, setBounds, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1167, 1170
3
/**
   * Side effect: Changes view Translation.
   */
4
  @Override
  public void setBounds(int x, int y, int width, int height) {
    super.setBounds(x, y, width, height);
    validateViewTranslation();
###
1294, removeFromSelection, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 808, 816
3
/**
   * Removes a figure from the selection.
   */
8
  public void removeFromSelection(Figure figure) {
    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);
    if (selectedFigures.remove(figure)) {
      Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);
      invalidateHandles();
      figure.removeFigureListener(handleInvalidator);
      fireSelectionChanged(oldSelection, newSelection);
      repaint();
###
1295, drawDrawingVolatileBuffered, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 331, 429
1
/** Draws the drawing double buffered using a volatile image. */
90
  protected void drawDrawingVolatileBuffered(Graphics2D g) {
    Rectangle vr = getVisibleRect();
    Point shift = new Point(0, 0);
    if (bufferedArea.contains(vr) ||
        bufferedArea.width >= vr.width && bufferedArea.height >= vr.height) {
      // The visible rect fits into the buffered area, but may be shifted; shift the buffered area.
      shift.x = bufferedArea.x - vr.x;
      shift.y = bufferedArea.y - vr.y;
      if (shift.x > 0) {
        dirtyArea.add(new Rectangle(bufferedArea.x - shift.x, vr.y, shift.x + bufferedArea.width - vr.width, bufferedArea.height));
      } else if (shift.x < 0) {
        dirtyArea.add(new Rectangle(bufferedArea.x + vr.width, vr.y, -shift.x + bufferedArea.width - vr.width, bufferedArea.height));
      }
      if (shift.y > 0) {
        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y - shift.y, bufferedArea.width, shift.y + bufferedArea.height - vr.height));
      } else if (shift.y < 0) {
        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y + vr.height, bufferedArea.width, -shift.y + bufferedArea.height - vr.height));
      }
      bufferedArea.x = vr.x;
      bufferedArea.y = vr.y;
    } else {
      // The buffered drawing area does not match the visible rect;
      // resize it, and mark everything as dirty.
      bufferedArea.setBounds(vr);
      dirtyArea.setBounds(vr);
      if (drawingBufferV != null && //
          (drawingBufferV.getWidth() != vr.width ||
          drawingBufferV.getHeight() != vr.height)) {
        // The dimension of the drawing buffer does not fit into the visible rect;
        // throw the buffer away.
        drawingBufferV.flush();
        drawingBufferV = null;
      }
    }
    // Update the contents of the buffer if necessary
    while (true) {
      int valid = (drawingBufferV == null) ? //
          VolatileImage.IMAGE_INCOMPATIBLE : //
          drawingBufferV.validate(getGraphicsConfiguration());
      switch (valid) {
        case VolatileImage.IMAGE_INCOMPATIBLE:
          // old buffer doesn't work with new GraphicsConfig; (re-)create it
          try {
            drawingBufferV = getGraphicsConfiguration().createCompatibleVolatileImage(vr.width, vr.height, Transparency.TRANSLUCENT);
          } catch (OutOfMemoryError e) {
            drawingBufferV = null;
          }
          dirtyArea.setBounds(bufferedArea);
          break;
        case VolatileImage.IMAGE_RESTORED:
          // image was restored, but buffer lost; redraw everything
          dirtyArea.setBounds(bufferedArea);
          break;
      }
      if (drawingBufferV == null) {
        // There is not enough memory available for a drawing buffer;
        // draw without buffering.
        drawDrawing(g);
        break;
      }
      if (!dirtyArea.isEmpty()) {
        // An area of the drawing buffer is dirty; repaint it
        Graphics2D gBuf = drawingBufferV.createGraphics();
        setViewRenderingHints(gBuf);
        // For shifting and cleaning, we need to erase everything underneath
        gBuf.setComposite(AlphaComposite.Src);
        // Perform shifting if needed
        if (shift.x != 0 || shift.y != 0) {
          gBuf.copyArea(Math.max(0, -shift.x), Math.max(0, -shift.y), drawingBufferV.getWidth() - Math.abs(shift.x), drawingBufferV.getHeight() - Math.abs(shift.y), shift.x, shift.y);
          shift.x = shift.y = 0;
        }
        // Clip the dirty area
        gBuf.translate(-bufferedArea.x, -bufferedArea.y);
        gBuf.clip(dirtyArea);
        // Clear the dirty area
        gBuf.setBackground(new Color(0x0, true));
        gBuf.clearRect(dirtyArea.x, dirtyArea.y, dirtyArea.width, dirtyArea.height);
        gBuf.setComposite(AlphaComposite.SrcOver);
        // Repaint the dirty area
        drawDrawing(gBuf);
        gBuf.dispose();
      }
      if (!drawingBufferV.contentsLost()) {
        g.drawImage(drawingBufferV, bufferedArea.x, bufferedArea.y, null);
      }
      if (drawingBufferV.contentsLost()) {
        dirtyArea.setBounds(bufferedArea);
      } else {
        dirtyArea.setSize(-1, -1);
        break;
###
1296, getCanvasViewBounds, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 562, 582
5
/**
   * Returns the bounds of the canvas on the drawing view.
   *
   * @return The current bounds of the canvas on the drawing view.
   */
17
  protected Rectangle getCanvasViewBounds() {
    // Position of the zero coordinate point on the view
    int x = -translation.x;
    int y = -translation.y;
    int w = getWidth();
    int h = getHeight();
    if (getDrawing() != null) {
      Double cw = getDrawing().get(CANVAS_WIDTH);
      Double ch = getDrawing().get(CANVAS_HEIGHT);
      if (cw != null && ch != null) {
        Point lowerRight = drawingToView(
            new Point2D.Double(cw, ch));
        w = lowerRight.x - x;
        h = lowerRight.y - y;
      }
    }
    return new Rectangle(x, y, w, h);
###
1297, isFigureSelected, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 890, 892
3
/**
   * Test whether a given figure is selected.
   */
3
  @Override
  public boolean isFigureSelected(Figure checkFigure) {
    return selectedFigures.contains(checkFigure);
###
1298, setDrawingDoubleBuffered, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1521, 1534
9
/** Sets whether the drawing is double buffered.
   * <p>
   * The default value is true.
   * <p>
   * This is a bound property.
   * <p>
   * If the drawing view is used for editing, you should leave this to true.
   * If the drawing view is used for viewing only, you should set this to false.
   */
13
  public void setDrawingDoubleBuffered(boolean newValue) {
    boolean oldValue = isDrawingDoubleBuffered;
    isDrawingDoubleBuffered =
        newValue;
    if (!isDrawingDoubleBuffered && drawingBufferV != null) {
      drawingBufferV.flush();
      drawingBufferV = null;
    }
    if (!isDrawingDoubleBuffered && drawingBufferNV != null) {
      drawingBufferNV.flush();
      drawingBufferNV = null;
    }
    firePropertyChange(DRAWING_DOUBLE_BUFFERED_PROPERTY, oldValue, newValue);
###
1299, getSecondaryHandles, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 923, 925
3
/**
   * Gets the currently active secondary handles.
   */
3
  private java.util.List<Handle> getSecondaryHandles() {
    validateHandles();
    return Collections.unmodifiableList(secondaryHandles);
###
1300, getSelectedFigures, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 899, 901
4
/**
   * Gets the current selection as a FigureSelection. A FigureSelection
   * can be cut, copied, pasted.
   */
3
  @Override
  public Set<Figure> getSelectedFigures() {
    return Collections.unmodifiableSet(selectedFigures);
###
1301, findHandle, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1014, 1031
4
/**
   * Finds a handle at a given coordinates.
   * @return A handle, null if no handle is found.
   */
15
  @Override
  public Handle findHandle(
      Point p) {
    validateHandles();
    for (Handle handle : new ReversedList<Handle>(getSecondaryHandles())) {
      if (handle.contains(p)) {
        return handle;
      }
    }
    for (Handle handle : new ReversedList<Handle>(getSelectionHandles())) {
      if (handle.contains(p)) {
        return handle;
      }
    }
    return null;
###
1302, addToSelection, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 771, 799
3
/**
   * Adds a collection of figures to the current selection.
   */
28
  public void addToSelection(Collection<Figure> figures) {
    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);
    Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);
    boolean selectionChanged = false;
    Rectangle invalidatedArea = null;
    for (Figure figure : figures) {
      if (selectedFigures.add(figure)) {
        selectionChanged = true;
        newSelection.add(figure);
        figure.addFigureListener(handleInvalidator);
        if (handlesAreValid && getEditor() != null) {
          for (Handle h : figure.createHandles(detailLevel)) {
            h.setView(this);
            selectionHandles.add(h);
            h.addHandleListener(eventHandler);
            if (invalidatedArea == null) {
              invalidatedArea = h.getDrawingArea();
            } else {
              invalidatedArea.add(h.getDrawingArea());
            }
          }
        }
      }
    }
    if (selectionChanged) {
      fireSelectionChanged(oldSelection, newSelection);
      if (invalidatedArea != null) {
        repaint(invalidatedArea);
###
1303, findFigure, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1062, 1065
4
/**
   * Finds a figure at a given coordinates.
   * @return A figure, null if no figure is found.
   */
4
  @Override
  public Figure findFigure(
      Point p) {
    return getDrawing().findFigure(viewToDrawing(p));
###
1304, drawingToView, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1245, 1250
3
/**
   * Converts drawing coordinates to view coordinates.
   */
6
  @Override
  public Point drawingToView(
      Point2D.Double p) {
    return new Point(
        (int) (p.x * scaleFactor) - translation.x,
        (int) (p.y * scaleFactor) - translation.y);
###
1305, clearSelection, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 875, 883
3
/**
   * Clears the current selection.
   */
8
  @Override
  public void clearSelection() {
    if (getSelectionCount() > 0) {
      Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);
      selectedFigures.clear();
      Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);
      invalidateHandles();
      fireSelectionChanged(oldSelection, newSelection);
###
1306, validateViewTranslation, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1177, 1238
4
/**
   * Updates the view translation taking into account the current dimension
   * of the view JComponent, the size of the drawing, and the scale factor.
   */
52
  private void validateViewTranslation() {
    if (getDrawing() == null) {
      translation.x = translation.y = 0;
      return;
    }
    Point oldTranslation = (Point) translation.clone();
    int width = getWidth();
    int height = getHeight();
    Insets insets = getInsets();
    Rectangle2D.Double da = getDrawingArea();
    Rectangle r = new Rectangle((int) (da.x * scaleFactor), (int) (da.y * scaleFactor), (int) (da.width * scaleFactor), (int) (da.height * scaleFactor));
    int cw, ch;
    Double cwd = getDrawing().get(CANVAS_WIDTH);
    Double chd = getDrawing().get(CANVAS_HEIGHT);
    if (cwd == null || chd == null) {
      // The canvas size is not explicitly specified.
      cw = Math.max(width - insets.left - insets.right, (int) ((Math.max(0, da.x) + da.width) * scaleFactor));
      ch = Math.max(height - insets.top - insets.bottom, (int) ((Math.max(0, da.y) + da.height) * scaleFactor));
      //Place the canvas at the top left
      translation.x = insets.top;
      translation.y = insets.left;
    } else {
      // The canvas size is explicitly specified.
      cw = (int) (cwd * scaleFactor);
      ch = (int) (chd * scaleFactor);
      //Place the canvas at the center
      if (cw < width) {
        translation.x = insets.left + (width - insets.left - insets.right - cw) / -2;
      }
      if (ch < height) {
        translation.y = insets.top + (height - insets.top - insets.bottom - ch) / -2;
      }
    }
    if (r.y + r.height - translation.y > (height - insets.bottom)) {
      // We cut off the lower part of the drawing -> shift the canvas up
      translation.y = r.y + r.height - (height - insets.bottom);
    }
    if (Math.min(0, r.y) - translation.y < insets.top) {
      // We cut off the upper part of the drawing -> shift the canvas down
      translation.y = Math.min(0, r.y) - insets.top;
    }
    if (r.x + r.width - translation.x > (width - insets.right)) {
      // We cut off the right part of the drawing -> shift the canvas left
      translation.x = r.x + r.width - (width - insets.right);
    }
    if (Math.min(0, r.x) - translation.x < insets.left) {
      // We cut off the left part of the drawing -> shift the canvas right
      translation.x = Math.min(0, r.x) - insets.left;
    }
    if (!oldTranslation.equals(translation)) {
      bufferedArea.translate(oldTranslation.x - translation.x, oldTranslation.y - translation.y);
      fireViewTransformChanged();
###
1307, fireSelectionChanged, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1094, 1118
6
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   * Also notify listeners who listen for
   * {@link EditableComponent#SELECTION_EMPTY_PROPERTY}.
   */
23
  protected void fireSelectionChanged(
      Set<Figure> oldValue,
      Set<Figure> newValue) {
    if (listenerList.getListenerCount() > 0) {
      FigureSelectionEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >=
          0; i -=
              2) {
        if (listeners[i] == FigureSelectionListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureSelectionEvent(this, oldValue, newValue);
          }
          ((FigureSelectionListener) listeners[i + 1]).selectionChanged(event);
        }
      }
    }
    firePropertyChange(EditableComponent.SELECTION_EMPTY_PROPERTY, oldValue.isEmpty(), newValue.isEmpty());
###
1308, getSelectionCount, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 907, 909
3
/**
   * Gets the number of selected figures.
   */
3
  @Override
  public int getSelectionCount() {
    return selectedFigures.size();
###
1309, DefaultDrawingView, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 240, 249
1
/** Creates new instance. */
9
  public DefaultDrawingView() {
    initComponents();
    eventHandler = createEventHandler();
    setToolTipText("dummy"); // Set a dummy tool tip text to turn tooltips on
    setFocusable(true);
    addFocusListener(eventHandler);
    setTransferHandler(new DefaultDrawingViewTransferHandler());
    setBackground(new Color(0xb0b0b0));
    setOpaque(true);
###
1310, getCompatibleHandles, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1038, 1054
4
/**
   * Gets compatible handles.
   * @return A collection containing the handle and all compatible handles.
   */
14
  @Override
  public Collection<Handle> getCompatibleHandles(Handle master) {
    validateHandles();
    HashSet<Figure> owners = new HashSet<Figure>();
    LinkedList<Handle> compatibleHandles = new LinkedList<Handle>();
    owners.add(master.getOwner());
    compatibleHandles.add(master);
    for (Handle handle : getSelectionHandles()) {
      if (!owners.contains(handle.getOwner()) && handle.isCombinableWith(master)) {
        owners.add(handle.getOwner());
        compatibleHandles.add(handle);
      }
    }
    return compatibleHandles;
###
1311, getSelectionHandles, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 915, 917
3
/**
   * Gets the currently active selection handles.
   */
3
  private java.util.List<Handle> getSelectionHandles() {
    validateHandles();
    return Collections.unmodifiableList(selectionHandles);
###
1312, validateHandles, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 971, 1003
3
/**
   * Validates the handles.
   */
30
  private void validateHandles() {
    // Validate handles only, if they are invalid, and if
    // the DrawingView has a DrawingEditor.
    if (!handlesAreValid && getEditor() != null) {
      handlesAreValid = true;
      selectionHandles.clear();
      Rectangle invalidatedArea = null;
      while (true) {
        for (Figure figure : getSelectedFigures()) {
          for (Handle handle : figure.createHandles(detailLevel)) {
            handle.setView(this);
            selectionHandles.add(handle);
            handle.addHandleListener(eventHandler);
            if (invalidatedArea == null) {
              invalidatedArea = handle.getDrawingArea();
            } else {
              invalidatedArea.add(handle.getDrawingArea());
            }
          }
        }
        if (selectionHandles.size() == 0 && detailLevel != 0) {
          // No handles are available at the desired detail level.
          // Retry with detail level 0.
          detailLevel = 0;
          continue;
        }
        break;
      }
      if (invalidatedArea != null) {
        repaint(invalidatedArea);
###
1365, importData, DefaultDrawingViewTransferHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewTransferHandler.java, 74, 295
1
/** Imports data and stores the transferred figures into the supplied transferFigures collection. */
204
  @SuppressWarnings("unchecked")
  protected boolean importData(final JComponent comp, Transferable t, final HashSet<Figure> transferFigures, final Point dropPoint) {
    if (DEBUG) {
      System.out.println("DefaultDrawingViewTransferHandler.importData(comp,t)");
    }
    boolean retValue;
    if (comp instanceof DrawingView) {
      final DrawingView view = (DrawingView) comp;
      final Drawing drawing = view.getDrawing();
      if (drawing.getInputFormats() == null ||
          drawing.getInputFormats().size() == 0) {
        if (DEBUG) {
          System.out.println("DefaultDrawingViewTransferHandler  import failed; drawing has no import formats");
        }
        retValue = false;
      } else {
        retValue = false;
        try {
          DataFlavor[] transferFlavors = t.getTransferDataFlavors();
          // Workaround for Mac OS X:
          // The Apple JVM messes up the sequence of the data flavors.
          if (System.getProperty("os.name").toLowerCase().startsWith("mac")) {
            // Search for a suitable input format
            SearchLoop:
            for (InputFormat format : drawing.getInputFormats()) {
              if (DEBUG) {
                System.out.println("DefaultDrawingViewTransferHandler  trying format:" + format);
              }
              for (DataFlavor flavor : transferFlavors) {
                if (DEBUG) {
                  System.out.println("DefaultDrawingViewTransferHandler  trying flavor:" + flavor.getMimeType());
                }
                if (format.isDataFlavorSupported(flavor)) {
                  LinkedList<Figure> existingFigures = new LinkedList<Figure>(drawing.getChildren());
                  try {
                    format.read(t, drawing, false);
                    if (DEBUG) {
                      System.out.println("DefaultDrawingViewTransferHandler  import succeeded");
                    }
                    final LinkedList<Figure> importedFigures = new LinkedList<Figure>(drawing.getChildren());
                    importedFigures.removeAll(existingFigures);
                    view.clearSelection();
                    view.addToSelection(importedFigures);
                    transferFigures.addAll(importedFigures);
                    moveToDropPoint(comp, transferFigures, dropPoint);
                    drawing.fireUndoableEditHappened(new AbstractUndoableEdit() {
                      @Override
                      public String getPresentationName() {
                        ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
                        return labels.getString("edit.paste.text");
                      }
                      @Override
                      public void undo() throws CannotUndoException {
                        super.undo();
                        drawing.removeAll(importedFigures);
                      }
                      @Override
                      public void redo() throws CannotRedoException {
                        super.redo();
                        drawing.addAll(importedFigures);
                      }
                    });
                    retValue = true;
                    break SearchLoop;
                  } catch (IOException e) {
                    if (DEBUG) {
                      System.out.println("  import failed");
                      e.printStackTrace();
                    }
                    // failed to read transferalbe, try with next InputFormat
                  }
                }
              }
            }
          } else {
            // Search for a suitable input format
            SearchLoop:
            for (DataFlavor flavor : transferFlavors) {
              if (DEBUG) {
                System.out.println("DefaultDrawingViewTransferHandler  trying flavor:" + flavor.getMimeType());
              }
              for (InputFormat format : drawing.getInputFormats()) {
                if (format.isDataFlavorSupported(flavor)) {
                  if (DEBUG) {
                    System.out.println("DefaultDrawingViewTransferHandler  trying format:" + format);
                  }
                  LinkedList<Figure> existingFigures = new LinkedList<Figure>(drawing.getChildren());
                  try {
                    format.read(t, drawing, false);
                    if (DEBUG) {
                      System.out.println("DefaultDrawingViewTransferHandler  import succeeded");
                    }
                    final LinkedList<Figure> importedFigures = new LinkedList<Figure>(drawing.getChildren());
                    importedFigures.removeAll(existingFigures);
                    view.clearSelection();
                    view.addToSelection(importedFigures);
                    transferFigures.addAll(importedFigures);
                    moveToDropPoint(comp, transferFigures, dropPoint);
                    drawing.fireUndoableEditHappened(new AbstractUndoableEdit() {
                      @Override
                      public String getPresentationName() {
                        ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
                        return labels.getString("edit.paste.text");
                      }
                      @Override
                      public void undo() throws CannotUndoException {
                        super.undo();
                        drawing.removeAll(importedFigures);
                      }
                      @Override
                      public void redo() throws CannotRedoException {
                        super.redo();
                        drawing.addAll(importedFigures);
                      }
                    });
                    retValue = true;
                    break SearchLoop;
                  } catch (IOException e) {
                    if (DEBUG) {
                      System.out.println("  import failed");
                      e.printStackTrace();
                    }
                    // failed to read transferalbe, try with next InputFormat
                  }
                }
              }
            }
          }
          // No input format found? Lets see if we got files - we
          // can handle these
          if (retValue == false && t.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
            final java.util.List<File> files = (java.util.List<File>) t.getTransferData(DataFlavor.javaFileListFlavor);
            retValue = true;
            final LinkedList<Figure> existingFigures = new LinkedList<Figure>(drawing.getChildren());
            view.getEditor().setEnabled(false);
            // FIXME - We should perform the following code in a
            // worker thread.
            new Worker<LinkedList<Figure>>() {
              @Override
              public LinkedList<Figure> construct() throws Exception {
                for (File file : files) {
                  FileFormatLoop:
                  for (InputFormat format : drawing.getInputFormats()) {
                    if (file.isFile() &&
                        format.getFileFilter().accept(file)) {
                      if (DEBUG) {
                        System.out.println("DefaultDrawingViewTransferHandler  importing file " + file);
                      }
                      format.read(file, drawing, false);
                    }
                  }
                }
                return new LinkedList<Figure>(drawing.getChildren());
              }
              @Override
              public void failed(Throwable error) {
                error.printStackTrace();
              }
              @Override
              public void done(final LinkedList<Figure> importedFigures) {
                importedFigures.removeAll(existingFigures);
                if (importedFigures.size() > 0) {
                  view.clearSelection();
                  view.addToSelection(importedFigures);
                  transferFigures.addAll(importedFigures);
                  moveToDropPoint(comp, transferFigures, dropPoint);
                  drawing.fireUndoableEditHappened(new AbstractUndoableEdit() {
                    @Override
                    public String getPresentationName() {
                      ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
                      return labels.getString("edit.paste.text");
                    }
                    @Override
                    public void undo() throws CannotUndoException {
                      super.undo();
                      drawing.removeAll(importedFigures);
                    }
                    @Override
                    public void redo() throws CannotRedoException {
                      super.redo();
                      drawing.addAll(importedFigures);
                    }
                  });
                }
              }
              @Override
              public void finished() {
                view.getEditor().setEnabled(true);
              }
            }.start();
          }
        } catch (Throwable e) {
          if (DEBUG) {
            e.printStackTrace();
          }
        }
      }
    } else {
      retValue = super.importData(comp, t);
    }
    if (DEBUG) {
      System.out.println("DefaultDrawingViewTransferHandler .importData(comp,t):" + retValue);
    }
    return retValue;
###
1367, dragGestureRecognized, DragHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewTransferHandler.java, 629, 655
3
/**
     * a Drag gesture has been recognized
     */
26
    public void dragGestureRecognized(DragGestureEvent dge) {
      JComponent c = (JComponent) dge.getComponent();
      DefaultDrawingViewTransferHandler th = (DefaultDrawingViewTransferHandler) c.getTransferHandler();
      Transferable t = transferable;
      if (t != null) {
        scrolls = c.getAutoscrolls();
        c.setAutoscrolls(false);
        try {
//          dge.startDrag(null, t, this);
          Icon icon = th.getVisualRepresentation(t);
          Image dragImage;
          if (icon instanceof ImageIcon) {
            dragImage = ((ImageIcon) icon).getImage();
          } else {
            dragImage = new BufferedImage(icon.getIconWidth(), icon.getIconHeight(), BufferedImage.TYPE_INT_ARGB);
            Graphics g = ((BufferedImage) dragImage).createGraphics();
            icon.paintIcon(c, g, 0, 0);
            g.dispose();
          }
          dge.startDrag(null, dragImage, imageOffset, t, this);
          return;
        } catch (RuntimeException re) {
          c.setAutoscrolls(scrolls);
        }
      }
      th.exportDone(c, t, NONE);
###
1372, findConnector, DiamondFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java, 245, 246
5
/**
   * Returns the Figures connector for the specified location.
   * By default a ChopDiamondConnector is returned.
   * @see ChopDiamondConnector
   */
2
  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {
    return new ChopDiamondConnector(this);
###
1374, DiamondFigure, DiamondFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java, 46, 47
1
/** Creates a new instance. */
2
  public DiamondFigure() {
    this(0, 0, 0, 0);
###
1375, transform, DiamondFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java, 217, 222
4
/**
   * Moves the Figure to a new location.
   * @param tx the transformation matrix.
   */
6
  public void transform(AffineTransform tx) {
    Point2D.Double anchor = getStartPoint();
    Point2D.Double lead = getEndPoint();
    setBounds(
        (Point2D.Double) tx.transform(anchor, anchor),
        (Point2D.Double) tx.transform(lead, lead));
###
1376, contains, DiamondFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java, 169, 203
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
31
  public boolean contains(Point2D.Double p) {
    Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();
    if (get(IS_QUADRATIC)) {
      double side = Math.max(r.width, r.height);
      r.x -= (side - r.width) / 2;
      r.y -= (side - r.height) / 2;
      r.width = r.height = side;
    }
    //   if (r.contains(p)) {
    double grow = AttributeKeys.getPerpendicularFillGrowth(this);
    double growx, growy;
    if (grow == 0d) {
      growx = growy = 0d;
    } else {
      double w = r.width / 2d;
      double h = r.height / 2d;
      double lineLength = Math.sqrt(w * w + h * h);
      double scale = grow / lineLength;
      double yb = scale * w;
      double xa = scale * h;
      growx = ((yb * yb) / xa + xa);
      growy = ((xa * xa) / yb + yb);
      Geom.grow(r, growx, growy);
    }
    Path2D.Double diamond = new Path2D.Double();
    diamond.moveTo((r.x + r.width / 2), r.y);
    diamond.lineTo((r.x + r.width), (r.y + r.height / 2));
    diamond.lineTo((r.x + r.width / 2), (r.y + r.height));
    diamond.lineTo(r.x, (r.y + r.height / 2));
    diamond.closePath();
    return diamond.contains(p);
###
1377, ToolBarLayout, ToolBarLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/ToolBarLayout.java, 46, 47
4
/**
   * Creates a layout manager that will lay out components along the
   * X-axis.  
   */
2
  public ToolBarLayout() {
    this(X_AXIS);
###
1378, AbstractTransferable, AbstractTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/AbstractTransferable.java, 29, 30
1
/** Creates a new instance. */
2
  public AbstractTransferable(DataFlavor flavor) {
    this.flavors = new DataFlavor[] {flavor};
###
1379, getDefaultPropertyIndex, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 131, 132
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1381, getBeanDescriptor, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 81, 82
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1382, getPropertyDescriptors, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 97, 98
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1385, getMethodDescriptors, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 119, 120
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1386, getDefaultEventIndex, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 142, 143
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1387, getEventSetDescriptors, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 108, 109
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1388, getColumns, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 135, 136
5
/**
   * Gets the number of columns in this layout.
   * @return   the number of columns in this layout
   * @since    JDK1.1
   */
2
  public int getColumns() {
    return cols;
###
1389, VerticalGridLayout, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 89, 97
24
/**
   * Creates a grid layout with the specified number of rows and
   * columns. All components in the layout are given equal size.
   * <p>
   * In addition, the horizontal and vertical gaps are set to the
   * specified values. Horizontal gaps are placed at the left and
   * right edges, and between each of the columns. Vertical gaps are
   * placed at the top and bottom edges, and between each of the rows.
   * <p>
   * One, but not both, of <code>rows</code> and <code>cols</code> can
   * be zero, which means that any number of objects can be placed in a
   * row or in a column.
   * <p>
   * All <code>VerticalGridLayout</code> constructors defer to this one.
   * @param   rows   the rows, with the value zero meaning
   *           any number of rows
   * @param   cols   the columns, with the value zero meaning
   *           any number of columns
   * @param   hgap   the horizontal gap
   * @param   vgap   the vertical gap
   * @exception   IllegalArgumentException  if the value of both
   *      <code>rows</code> and <code>cols</code> is
   *      set to zero
   */
9
  public VerticalGridLayout(int rows, int cols, int hgap, int vgap, boolean isVertical) {
    if ((rows == 0) && (cols == 0)) {
      throw new IllegalArgumentException("rows and cols cannot both be zero");
    }
    this.rows = rows;
    this.cols = cols;
    this.hgap = hgap;
    this.vgap = vgap;
    this.isVertical = isVertical;
###
1390, setRows, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 116, 120
7
/**
   * Sets the number of rows in this layout to the specified value.
   * @param    rows   the number of rows in this layout
   * @exception  IllegalArgumentException  if the value of both
   *         <code>rows</code> and <code>cols</code> is set to zero
   * @since    JDK1.1
   */
5
  public void setRows(int rows) {
    if ((rows == 0) && (this.cols == 0)) {
      throw new IllegalArgumentException("rows and cols cannot both be zero");
    }
    this.rows = rows;
###
1391, minimumLayoutSize, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 274, 299
18
/**
   * Determines the minimum size of the container argument using this
   * grid layout.
   * <p>
   * The minimum width of a grid layout is the largest minimum width
   * of any of the components in the container times the number of columns,
   * plus the horizontal padding times the number of columns plus one,
   * plus the left and right insets of the target container.
   * <p>
   * The minimum height of a grid layout is the largest minimum height
   * of any of the components in the container times the number of rows,
   * plus the vertical padding times the number of rows plus one, plus
   * the top and bottom insets of the target container.
   *
   * @param     parent   the container in which to do the layout
   * @return    the minimum dimensions needed to lay out the
   *            subcomponents of the specified container
   */
26
  public Dimension minimumLayoutSize(Container parent) {
    synchronized (parent.getTreeLock()) {
      Insets insets = parent.getInsets();
      int ncomponents = parent.getComponentCount();
      int nrows = rows;
      int ncols = cols;
      
      if (nrows > 0) {
        ncols = (ncomponents + nrows - 1) / nrows;
      } else {
        nrows = (ncomponents + ncols - 1) / ncols;
      }
      int w = 0;
      int h = 0;
      for (int i = 0 ; i < ncomponents ; i++) {
        Component comp = parent.getComponent(i);
        Dimension d = comp.getMinimumSize();
        if (w < d.width) {
          w = d.width;
        }
        if (h < d.height) {
          h = d.height;
        }
      }
      return new Dimension(insets.left + insets.right + ncols*w + (ncols-1)*hgap,
      insets.top + insets.bottom + nrows*h + (nrows-1)*vgap);
###
1393, getRows, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 105, 106
5
/**
   * Gets the number of rows in this layout.
   * @return  the number of rows in this layout
   * @since   JDK1.1
   */
2
  public int getRows() {
    return rows;
###
1394, setColumns, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 151, 155
12
/**
   * Sets the number of columns in this layout to the specified value.
   * Setting the number of columns has no affect on the layout
   * if the number of rows specified by a constructor or by
   * the <tt>setRows</tt> method is non-zero. In that case, the number
   * of columns displayed in the layout is determined by the total
   * number of components and the number of rows specified.
   * @param    cols   the number of columns in this layout
   * @exception  IllegalArgumentException  if the value of both
   *         <code>rows</code> and <code>cols</code> is set to zero
   * @since    JDK1.1
   */
5
  public void setColumns(int cols) {
    if ((cols == 0) && (this.rows == 0)) {
      throw new IllegalArgumentException("rows and cols cannot both be zero");
    }
    this.cols = cols;
###
1395, setVgap, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 190, 191
5
/**
   * Sets the vertical gap between components to the specified value.
   * @param     vgap  the vertical gap between components
   * @since    JDK1.1
   */
2
  public void setVgap(int vgap) {
    this.vgap = vgap;
###
1396, VerticalGridLayout, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 39, 40
4
/**
   * Creates a grid layout with a default of one column per component,
   * in a single row.
   */
2
  public VerticalGridLayout() {
    this(1, 0, 0, 0);
###
1397, getHgap, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 163, 164
5
/**
   * Gets the horizontal gap between components.
   * @return     the horizontal gap between components
   * @since    JDK1.1
   */
2
  public int getHgap() {
    return hgap;
###
1398, getVgap, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 181, 182
5
/**
   * Gets the vertical gap between components.
   * @return     the vertical gap between components
   * @since    JDK1.1
   */
2
  public int getVgap() {
    return vgap;
###
1400, layoutContainer, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 321, 365
18
/**
   * Lays out the specified container using this layout.
   * <p>
   * This method reshapes the components in the specified target
   * container in order to satisfy the constraints of the
   * <code>VerticalGridLayout</code> object.
   * <p>
   * The grid layout manager determines the size of individual
   * components by dividing the free space in the container into
   * equal-sized portions according to the number of rows and columns
   * in the layout. The container's free space equals the container's
   * size minus any insets and any specified horizontal or vertical
   * gap. All components in a grid layout are given the same size.
   *
   * @param    parent   the container in which to do the layout
   * @see    java.awt.Container
   * @see    java.awt.Container#doLayout
   */
45
  public void layoutContainer(Container parent) {
    synchronized (parent.getTreeLock()) {
      Insets insets = parent.getInsets();
      int ncomponents = parent.getComponentCount();
      int nrows = rows;
      int ncols = cols;
      boolean ltr = parent.getComponentOrientation().isLeftToRight();
      
      if (ncomponents == 0) {
        return;
      }
      if (nrows > 0) {
        ncols = (ncomponents + nrows - 1) / nrows;
      } else {
        nrows = (ncomponents + ncols - 1) / ncols;
      }
      int w = parent.getWidth() - (insets.left + insets.right);
      int h = parent.getHeight() - (insets.top + insets.bottom);
      w = (w - (ncols - 1) * hgap) / ncols;
      h = (h - (nrows - 1) * vgap) / nrows;
      
      int i;
      if (ltr) {
        for (int c = 0, x = insets.left ; c < ncols ; c++, x += w + hgap) {
          for (int r = 0, y = insets.top ; r < nrows ; r++, y += h + vgap) {
            if (isVertical) {
              i = r + c * nrows;
            } else {
              i = r * ncols + c;
            }
            if (i < ncomponents) {
              parent.getComponent(i).setBounds(x, y, w, h);
            }
          }
        }
      } else {
        for (int c = 0, x = parent.getWidth() - insets.right - w; c < ncols ; c++, x -= w + hgap) {
          for (int r = 0, y = insets.top ; r < nrows ; r++, y += h + vgap) {
            if (isVertical) {
              i = r + c * nrows;
            } else {
              i = r * ncols + c;
            }
            if (i < ncomponents) {
              parent.getComponent(i).setBounds(x, y, w, h);
###
1401, setHgap, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 172, 173
5
/**
   * Sets the horizontal gap between components to the specified value.
   * @param    hgap   the horizontal gap between components
   * @since    JDK1.1
   */
2
  public void setHgap(int hgap) {
    this.hgap = hgap;
###
1402, VerticalGridLayout, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 55, 56
12
/**
   * Creates a grid layout with the specified number of rows and
   * columns. All components in the layout are given equal size.
   * <p>
   * One, but not both, of <code>rows</code> and <code>cols</code> can
   * be zero, which means that any number of objects can be placed in a
   * row or in a column.
   * @param   rows   the rows, with the value zero meaning
   *           any number of rows.
   * @param   cols   the columns, with the value zero meaning
   *           any number of columns.
   */
2
  public VerticalGridLayout(int rows, int cols) {
    this(rows, cols, 0, 0);
###
1403, preferredLayoutSize, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 227, 252
18
/**
   * Determines the preferred size of the container argument using
   * this grid layout.
   * <p>
   * The preferred width of a grid layout is the largest preferred
   * width of any of the components in the container times the number of
   * columns, plus the horizontal padding times the number of columns
   * plus one, plus the left and right insets of the target container.
   * <p>
   * The preferred height of a grid layout is the largest preferred
   * height of any of the components in the container times the number of
   * rows, plus the vertical padding times the number of rows plus one,
   * plus the top and bottom insets of the target container.
   *
   * @param   parent   the container in which to do the layout
   * @return  the preferred dimensions to lay out the
   *            subcomponents of the specified container
   */
26
  public Dimension preferredLayoutSize(Container parent) {
    synchronized (parent.getTreeLock()) {
      Insets insets = parent.getInsets();
      int ncomponents = parent.getComponentCount();
      int nrows = rows;
      int ncols = cols;
      
      if (nrows > 0) {
        ncols = (ncomponents + nrows - 1) / nrows;
      } else {
        nrows = (ncomponents + ncols - 1) / ncols;
      }
      int w = 0;
      int h = 0;
      for (int i = 0 ; i < ncomponents ; i++) {
        Component comp = parent.getComponent(i);
        Dimension d = comp.getPreferredSize();
        if (w < d.width) {
          w = d.width;
        }
        if (h < d.height) {
          h = d.height;
        }
      }
      return new Dimension(insets.left + insets.right + ncols*w + (ncols-1)*hgap,
      insets.top + insets.bottom + nrows*h + (nrows-1)*vgap);
###
1404, getClipboard, ClipboardUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/ClipboardUtil.java, 36, 59
6
/** Returns the ClipboardService instance. If none is set, creates
   * a new one which tries to access the system clipboard. If this fails,
   * an instance with a JVM local clipboard is created.
   *
   * @return system clipboard or a proxy.
   */
20
  @SuppressWarnings("unchecked")
  public static Clipboard getClipboard() {
    if (instance != null) {
      return instance;
    }
    // Try to access the system clipboard
    try {
//      instance = new AWTClipboard(Toolkit.getDefaultToolkit().getSystemClipboard());
      instance = new OSXClipboard(Toolkit.getDefaultToolkit().getSystemClipboard());
    } catch (SecurityException e1) {
      // Fall back to JNLP ClipboardService
      try {
        Class serviceManager = Class.forName("javax.jnlp.ServiceManager");
        instance = new JNLPClipboard(serviceManager.getMethod("lookup", String.class).invoke(null, "javax.jnlp.ClipboardService"));
      } catch (Exception e2) {
        // Fall back to JVM local clipboard
        instance = new AWTClipboard(new Clipboard("JVM Local Clipboard"));
      }
    }
    return instance;
###
1422, getTarget, AWTClipboard, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/AWTClipboard.java, 50, 51
1
/** Returns the proxy target. */
2
  public Clipboard getTarget() {
    return target;
###
1423, AWTClipboard, AWTClipboard, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/AWTClipboard.java, 45, 46
5
/**
   * Creates a new proxy for the specified target object.
   *
   * @param target A Clipboard object.
   */
2
  public AWTClipboard(Clipboard target) {
    this.target = target;
###
1425, setError, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 127, 128
3
/**
   * Set the error thrown by constrct.
   */
2
  private synchronized void setError(Throwable x) {
    error = x;
###
1426, getError, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 120, 121
4
/**
   * Get the error produced by the worker thread, or null if it
   * hasn't thrown one.
   */
2
  protected synchronized Throwable getError() {
    return error;
###
1428, run, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 36, 54
4
/**
   * Calls #construct on the current thread and invokes
   * #done on the AWT event dispatcher thread.
   */
17
  public final void run() {
    try {
      setValue(construct());
    } catch (Throwable e) {
      setError(e);
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          failed(getError());
          finished();
        }
      });
      return;
    }
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        done(getValue());
        finished();
###
1429, getValue, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 105, 106
4
/**
   * Get the value produced by the worker thread, or null if it
   * hasn't been constructed yet.
   */
2
  protected synchronized T getValue() {
    return value;
###
1430, failed, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 86, 87
9
/**
   * Called on the event dispatching thread (not on the worker thread)
   * after the <code>construct</code> method has thrown an error.
   * <p>
   * The default implementation prints a stack trace. Subclasses may override
   * this method to perform failure actions on the Event Dispatch Thread.
   *
   * @param error The error thrown by construct.
   */
2
  protected void failed(Throwable error) {
    error.printStackTrace();
###
1432, setValue, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 112, 113
3
/**
   * Set the value produced by construct.
   */
2
  private synchronized void setValue(T x) {
    value = x;
###
1433, getTransferData, CompositeTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/CompositeTransferable.java, 53, 56
11
/**
   * Returns an object which represents the data to be transferred.  The class
   * of the object returned is defined by the representation class of the flavor.
   *
   * @param flavor the requested flavor for the data
   * @see DataFlavor#getRepresentationClass
   * @exception IOException        if the data is no longer available
   *       in the requested flavor.
   * @exception UnsupportedFlavorException if the requested data flavor is
   *       not supported.
   */
4
  public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {
    Transferable t = (Transferable) transferables.get(flavor);
    if (t == null) throw new UnsupportedFlavorException(flavor);
    return t.getTransferData(flavor);
###
1435, getTransferDataFlavors, CompositeTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/CompositeTransferable.java, 65, 66
6
/**
   * Returns an array of DataFlavor objects indicating the flavors the data
   * can be provided in.  The array should be ordered according to preference
   * for providing the data (from most richly descriptive to least descriptive).
   * @return an array of data flavors in which this data can be transferred
   */
2
  public DataFlavor[] getTransferDataFlavors() {
    return (DataFlavor[]) flavors.toArray(new DataFlavor[transferables.size()]);
###
1437, fireOptionSelected, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 530, 542
6
/**
   * Notify all listeners that have registered interest for
   *   notification on this event type.  The event instance
   *   is lazily created using the parameters passed into
   *   the fire method.
   */
13
  protected void fireOptionSelected(JOptionPane pane, int option, Object value, Object inputValue) {
    SheetEvent sheetEvent = null;
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == SheetListener.class) {
        // Lazily create the event:
        if (sheetEvent == null) {
          sheetEvent = new SheetEvent(this, pane, option, value, inputValue);
        }
        ((SheetListener) listeners[i + 1]).optionSelected(sheetEvent);
###
1438, JSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 117, 119
3
/**
   * Creates a new JSheet.
   */
3
  public JSheet(Dialog owner) {
    super(owner);
    init();
###
1439, isDocumentModalitySupported, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 297, 298
4
/**
   * If this returns true, the JSheet uses native support for
   * sheet display.
   */
2
  private static boolean isDocumentModalitySupported() {
    return isDocumentModalitySupported;
###
1440, showMessageSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 883, 885
17
/**
   * Brings up a sheet that displays a message using a default
   * icon determined by the <code>messageType</code> parameter.
   *
   * @param parentComponent determines the <code>Frame</code>
   *    in which the dialog is displayed; if <code>null</code>,
   *    or if the <code>parentComponent</code> has no
   *    <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param messageType the type of message to be displayed:
   *          <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *      <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param listener This listener is notified when the sheet is dismissed.
   */
3
  public static void showMessageSheet(Component parentComponent,
      Object message, int messageType, SheetListener listener) {
    showMessageSheet(parentComponent, message, messageType, null, listener);
###
1441, isNativeSheetSupported, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 289, 290
4
/**
   * If this returns true, the JSheet uses native support for
   * sheet display.
   */
2
  private static boolean isNativeSheetSupported() {
    return isNativeSheetSupported;
###
1442, showOptionSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 956, 972
44
/**
   * Brings up a sheet with a specified icon, where the initial
   * choice is determined by the <code>initialValue</code> parameter and
   * the number of choices is determined by the <code>optionType</code>
   * parameter.
   * <p>
   * If <code>optionType</code> is <code>YES_NO_OPTION</code>,
   * or <code>YES_NO_CANCEL_OPTION</code>
   * and the <code>options</code> parameter is <code>null</code>,
   * then the options are
   * supplied by the look and feel.
   * <p>
   * The <code>messageType</code> parameter is primarily used to supply
   * a default icon from the look and feel.
   *
   * @param parentComponent determines the <code>Frame</code>
   *      in which the dialog is displayed;  if
   *          <code>null</code>, or if the
   *      <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param optionType an integer designating the options available on the
   *      dialog: <code>YES_NO_OPTION</code>,
   *      or <code>YES_NO_CANCEL_OPTION</code>
   * @param messageType an integer designating the kind of message this is,
   *          primarily used to determine the icon from the
   *      pluggable Look and Feel: <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *          <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param icon    the icon to display in the dialog
   * @param options   an array of objects indicating the possible choices
   *          the user can make; if the objects are components, they
   *          are rendered properly; non-<code>String</code>
   *      objects are
   *          rendered using their <code>toString</code> methods;
   *          if this parameter is <code>null</code>,
   *      the options are determined by the Look and Feel
   * @param initialValue the object that represents the default selection
   *          for the dialog; only meaningful if <code>options</code>
   *      is used; can be <code>null</code>
   * @param listener The listener for SheetEvents.
   */
14
  public static void showOptionSheet(Component parentComponent,
      Object message, int optionType, int messageType,
      Icon icon, Object[] options, Object initialValue, SheetListener listener) {
    JOptionPane pane = new JOptionPane(message, messageType,
        optionType, icon,
        options, initialValue);
    pane.setInitialValue(initialValue);
    pane.setComponentOrientation(((parentComponent == null) ? JOptionPane.getRootFrame() : parentComponent).getComponentOrientation());
    int style = styleFromMessageType(messageType);
    JSheet sheet = createSheet(pane, parentComponent, style);
    pane.selectInitialValue();
    sheet.addSheetListener(listener);
    sheet.show();
    sheet.toFront();
###
1443, isAnimated, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 281, 282
4
/**
   * If this returns true, the JSheet uses a transition effect when shown
   * and when hidden.
   */
2
  public boolean isAnimated() {
    return isAnimated;
###
1444, showMessageSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 861, 863
16
/**
   * Brings up a sheet that displays a message using a default
   * icon determined by the <code>messageType</code> parameter.
   *
   * @param parentComponent determines the <code>Frame</code>
   *    in which the dialog is displayed; if <code>null</code>,
   *    or if the <code>parentComponent</code> has no
   *    <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param messageType the type of message to be displayed:
   *          <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *      <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   */
3
  public static void showMessageSheet(Component parentComponent,
      Object message, int messageType) {
    showMessageSheet(parentComponent, message, messageType, null, null);
###
1445, uninstallSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 237, 256
4
/**
   * Uninstalls the sheet on the owner.
   * This method is invoked immediately after the JSheet is hidden.
   */
19
  protected void uninstallSheet() {
    if (isInstalled) {
      Window owner = getOwner();
      if (owner != null) {
        // Note: We mustn't change the windows focusable state because
        // this also affects the focusable state of the JSheet.
        //owner.setFocusableWindowState(true);
        owner.setEnabled(true);
        //((JFrame) owner).setResizable(true);
        owner.removeComponentListener(ownerMovementHandler);
        if (shiftBackLocation != null) {
          owner.setLocation(shiftBackLocation);
        }
        if (oldFocusOwner != null) {
          owner.toFront();
          oldFocusOwner.requestFocus();
        }
      }
      isInstalled = false;
###
1446, showMessageSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 839, 842
10
/**
   * Brings up an information-message sheet.
   *
   * @param parentComponent determines the <code>Frame</code> in
   *    which the dialog is displayed; if <code>null</code>,
   *    or if the <code>parentComponent</code> has no
   *    <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param listener This listener is notified when the sheet is dismissed.
   */
4
  public static void showMessageSheet(Component parentComponent,
      Object message, SheetListener listener) {
    showMessageSheet(parentComponent, message,
        JOptionPane.INFORMATION_MESSAGE, listener);
###
1447, showConfirmSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 616, 618
11
/**
   * Brings up a sheet with the options <i>Yes</i>,
   * <i>No</i> and <i>Cancel</i>.
   *
   * @param parentComponent determines the <code>Frame</code> in which the
   *      sheet is displayed; if <code>null</code>,
   *      or if the <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param listener The listener for SheetEvents.
   */
3
  public static void showConfirmSheet(Component parentComponent, Object message, SheetListener listener) {
    showConfirmSheet(parentComponent, message,
        JOptionPane.YES_NO_CANCEL_OPTION, listener);
###
1448, showInputSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 750, 753
15
/**
   * Shows a sheet requesting input from the user parented to
   * <code>parentComponent</code> and message type <code>messageType</code>.
   *
   * @param parentComponent  the parent <code>Component</code> for the
   *      dialog
   * @param message  the <code>Object</code> to display
   * @param messageType the type of message that is to be displayed:
   *           <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *      <code>JOptionPane.WARNING_MESSAGE</code>,
   *           <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param listener The listener for SheetEvents.
   */
4
  public static void showInputSheet(Component parentComponent,
      Object message, int messageType, SheetListener listener) {
    showInputSheet(parentComponent, message,
        messageType, null, null, null, listener);
###
1449, fireOptionSelected, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 553, 565
6
/**
   * Notify all listeners that have registered interest for
   *   notification on this event type.  The event instance
   *   is lazily created using the parameters passed into
   *   the fire method.
   */
13
  protected void fireOptionSelected(JFileChooser pane, int option) {
    SheetEvent sheetEvent = null;
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == SheetListener.class) {
        // Lazily create the event:
        if (sheetEvent == null) {
          sheetEvent = new SheetEvent(this, pane, option, null);
        }
        ((SheetListener) listeners[i + 1]).optionSelected(sheetEvent);
###
1450, fireOptionSelected, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 493, 521
6
/**
   * Notify all listeners that have registered interest for
   *   notification on this event type.  The event instance
   *   is lazily created using the parameters passed into
   *   the fire method.
   */
27
  protected void fireOptionSelected(JOptionPane pane) {
    Object value = pane.getValue();
    int option;
    if (value == null) {
      option = JOptionPane.CLOSED_OPTION;
    } else {
      if (pane.getOptions() == null) {
        if (value instanceof Integer) {
          option = ((Integer) value).intValue();
        } else {
          option = JOptionPane.CLOSED_OPTION;
        }
      } else {
        option = JOptionPane.CLOSED_OPTION;
        Object[] options = pane.getOptions();
        for (int i = 0, n = options.length; i < n; i++) {
          if (options[i].equals(value)) {
            option = i;
            break;
          }
        }
        if (option == JOptionPane.CLOSED_OPTION) {
          value = null;
        }
      }
    }
    fireOptionSelected(pane, option, value, pane.getInputValue());
###
1451, showSaveSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1100, 1102
9
/**
   * Displays a "Save File" file chooser sheet. Note that the
   * text that appears in the approve button is determined by
   * the L&F.
   *
   * @param  parent  the parent component of the dialog,
   *      can be <code>null</code>.
   * @param listener The listener for SheetEvents.
   */
3
  public static void showSaveSheet(JFileChooser chooser, Component parent, SheetListener listener) {
    chooser.setDialogType(JFileChooser.SAVE_DIALOG);
    showSheet(chooser, parent, null, listener);
###
1452, showOpenSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1114, 1116
9
/**
   * Displays an "Open File" file chooser sheet. Note that the
   * text that appears in the approve button is determined by
   * the L&F.
   *
   * @param  parent  the parent component of the dialog,
   *      can be <code>null</code>.
   * @param listener The listener for SheetEvents.
   */
3
  public static void showOpenSheet(JFileChooser chooser, Component parent, SheetListener listener) {
    chooser.setDialogType(JFileChooser.OPEN_DIALOG);
    showSheet(chooser, parent, null, listener);
###
1453, installSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 165, 229
4
/**
   * Installs the sheet on the owner.
   * This method is invoked just before the JSheet is shown.
   */
61
  protected void installSheet() {
    if (!isNativeSheetSupported() && !isInstalled) {
      Window owner = getOwner();
      if (owner != null) {
        // Determine the location for the sheet and its owner while
        // the sheet will be visible.
        // In case we have to shift the owner to fully display the
        // dialog, we remember the shift back position.
        Point ownerLoc = owner.getLocation();
        Point sheetLoc;
        if (isShowAsSheet()) {
          if (owner instanceof JFrame) {
            sheetLoc = new Point(
                ownerLoc.x + (owner.getWidth() - getWidth()) / 2,
                ownerLoc.y + owner.getInsets().top + ((JFrame) owner).getRootPane().getContentPane().getY());
          } else if (owner instanceof JDialog) {
            sheetLoc = new Point(
                ownerLoc.x + (owner.getWidth() - getWidth()) / 2,
                ownerLoc.y + owner.getInsets().top + ((JDialog) owner).getRootPane().getContentPane().getY());
          } else {
            sheetLoc = new Point(
                ownerLoc.x + (owner.getWidth() - getWidth()) / 2,
                ownerLoc.y + owner.getInsets().top);
          }
          if (sheetLoc.x < 0) {
            owner.setLocation(ownerLoc.x - sheetLoc.x, ownerLoc.y);
            sheetLoc.x = 0;
            shiftBackLocation = ownerLoc;
            oldLocation = owner.getLocation();
          } else {
            shiftBackLocation = null;
            oldLocation = ownerLoc;
          }
        } else {
          sheetLoc = new Point(
              ownerLoc.x + (owner.getWidth() - getWidth()) / 2,
              ownerLoc.y + (owner.getHeight() - getHeight()) / 3);
        }
        setLocation(sheetLoc);
        oldFocusOwner = owner.getFocusOwner();
        // Note: We mustn't change the windows focusable state because
        // this also affects the focusable state of the JSheet.
        //owner.setFocusableWindowState(false);
        owner.setEnabled(false);
        // ((JFrame) owner).setResizable(false);
        if (isShowAsSheet()) {
          owner.addComponentListener(ownerMovementHandler);
        } else {
          if (owner instanceof Frame) {
            setTitle(((Frame) owner).getTitle());
          }
        }
      }
      isInstalled = true;
    } else {
      Window owner = getOwner();
      Point ownerLoc = owner.getLocation();
      Point sheetLoc = new Point(
          ownerLoc.x + (owner.getWidth() - getWidth()) / 2,
          ownerLoc.y + (owner.getHeight() - getHeight()) / 3);
        setLocation(sheetLoc);
###
1454, showSaveSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1128, 1130
9
/**
   * Displays a "Save File" file chooser sheet. Note that the
   * text that appears in the approve button is determined by
   * the L&F.
   *
   * @param  parent  the parent component of the dialog,
   *      can be <code>null</code>.
   * @param listener The listener for SheetEvents.
   */
3
  public static void showSaveSheet(URIChooser chooser, Component parent, SheetListener listener) {
    chooser.setDialogType(JFileChooser.SAVE_DIALOG);
    showSheet(chooser, parent, null, listener);
###
1455, showSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1212, 1261
8
/**
   * Displays a custom file chooser sheet with a custom approve button.
   *
   * @param   parent  the parent component of the dialog;
   *      can be <code>null</code>
   * @param   approveButtonText the text of the <code>ApproveButton</code>
   * @param listener The listener for SheetEvents.
   */
43
  public static void showSheet(final URIChooser chooser, Component parent,
      String approveButtonText, SheetListener listener) {
    if (approveButtonText != null) {
      chooser.setApproveButtonText(approveButtonText);
      chooser.setDialogType(URIChooser.CUSTOM_DIALOG);
    }
    // Begin Create Dialog
    Frame frame = parent instanceof Frame ? (Frame) parent
        : (Frame) SwingUtilities.getAncestorOfClass(Frame.class, parent);
    if (chooser instanceof JFileChooser) {
    String title = ((JFileChooser) chooser).getUI().getDialogTitle((JFileChooser) chooser);
    ((JFileChooser) chooser).getAccessibleContext().setAccessibleDescription(title);
    }
    final JSheet sheet = new JSheet(frame);
    sheet.addSheetListener(listener);
    Container contentPane = sheet.getContentPane();
    contentPane.setLayout(new BorderLayout());
    contentPane.add(chooser.getComponent(), BorderLayout.CENTER);
    // End Create Dialog
    final ActionListener actionListener = new ActionListener() {
      public void actionPerformed(ActionEvent evt) {
        int option;
        if (evt.getActionCommand().equals("ApproveSelection")) {
          option = JFileChooser.APPROVE_OPTION;
        } else {
          option = JFileChooser.CANCEL_OPTION;
        }
        sheet.hide();
        sheet.fireOptionSelected(chooser, option);
        chooser.removeActionListener(this);
      }
    };
    chooser.addActionListener(actionListener);
    sheet.addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        sheet.fireOptionSelected(chooser, JFileChooser.CANCEL_OPTION);
        chooser.removeActionListener(actionListener);
      }
    });
    chooser.rescanCurrentDirectory();
    sheet.pack();
    sheet.show();
    sheet.toFront();
###
1456, setAnimated, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 271, 274
7
/**
   * If this is set to true, the JSheet uses a transition effect when shown
   * and when hidden.
   */
 --------------
// QuaquaUtilities.setWindowAlpha(this, 240);
 --------------
4
  public void setAnimated(boolean newValue) {
    boolean oldValue = isAnimated;
    isAnimated = newValue;
    firePropertyChange("animated", oldValue, newValue);
###
1457, showConfirmSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 696, 700
24
/**
   * Brings up a sheet with a specified icon, where the number of
   * choices is determined by the <code>optionType</code> parameter.
   * The <code>messageType</code> parameter is primarily used to supply
   * a default icon from the look and feel.
   *
   * @param parentComponent determines the <code>Frame</code> in which the
   *      dialog is displayed; if <code>null</code>,
   *      or if the <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the Object to display
   * @param optionType an int designating the options available on the dialog:
   *          <code>YES_NO_OPTION</code>,
   *      or <code>YES_NO_CANCEL_OPTION</code>
   * @param messageType an int designating the kind of message this is,
   *          primarily used to determine the icon from the pluggable
   *          Look and Feel: <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *          <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param icon    the icon to display in the dialog
   * @param listener The listener for SheetEvents.
   */
5
  public static void showConfirmSheet(Component parentComponent,
      Object message, int optionType,
      int messageType, Icon icon, SheetListener listener) {
    showOptionSheet(parentComponent, message, optionType,
        messageType, icon, null, null, listener);
###
1458, showInputSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 711, 713
8
/**
   * Shows a question-message sheet requesting input from the user
   * parented to <code>parentComponent</code>.
   *
   * @param parentComponent  the parent <code>Component</code> for the
   *    dialog
   * @param listener The listener for SheetEvents.
   */
3
  public static void showInputSheet(Component parentComponent,
      Object message, SheetListener listener) {
    showInputSheet(parentComponent, message, JOptionPane.QUESTION_MESSAGE, listener);
###
1459, fireOptionSelected, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 575, 587
6
/**
   * Notify all listeners that have registered interest for
   *   notification on this event type.  The event instance
   *   is lazily created using the parameters passed into
   *   the fire method.
   */
13
  protected void fireOptionSelected(URIChooser pane, int option) {
    SheetEvent sheetEvent = null;
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == SheetListener.class) {
        // Lazily create the event:
        if (sheetEvent == null) {
          sheetEvent = new SheetEvent(this, pane, option, null);
        }
        ((SheetListener) listeners[i + 1]).optionSelected(sheetEvent);
###
1460, removeSheetListener, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 483, 484
3
/**
   * Removes a sheet listener.
   */
2
  public void removeSheetListener(SheetListener l) {
    listenerList.remove(SheetListener.class, l);
###
1461, showConfirmSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 635, 638
14
/**
   * Brings up a sheet where the number of choices is determined
   * by the <code>optionType</code> parameter.
   *
   * @param parentComponent determines the <code>Frame</code> in which the
   *      sheet is displayed; if <code>null</code>,
   *      or if the <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param optionType an int designating the options available on the dialog:
   *          <code>YES_NO_OPTION</code>, or
   *      <code>YES_NO_CANCEL_OPTION</code>
   * @param listener The listener for SheetEvents.
   */
4
  public static void showConfirmSheet(Component parentComponent,
      Object message, int optionType, SheetListener listener) {
    showConfirmSheet(parentComponent, message, optionType,
        JOptionPane.QUESTION_MESSAGE, listener);
###
1462, JSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 109, 111
3
/**
   * Creates a new JSheet.
   */
3
  public JSheet(Frame owner) {
    super(owner);
    init();
###
1464, showConfirmSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 666, 669
25
/**
   * Brings up a sheet where the number of choices is determined
   * by the <code>optionType</code> parameter, where the
   * <code>messageType</code>
   * parameter determines the icon to display.
   * The <code>messageType</code> parameter is primarily used to supply
   * a default icon from the Look and Feel.
   *
   * @param parentComponent determines the <code>Frame</code> in
   *      which the dialog is displayed; if <code>null</code>,
   *      or if the <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param optionType an integer designating the options available
   *      on the dialog: <code>YES_NO_OPTION</code>,
   *      or <code>YES_NO_CANCEL_OPTION</code>
   * @param messageType an integer designating the kind of message this is;
   *          primarily used to determine the icon from the pluggable
   *          Look and Feel: <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *          <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param listener The listener for SheetEvents.
   */
4
  public static void showConfirmSheet(Component parentComponent,
      Object message, int optionType, int messageType, SheetListener listener) {
    showConfirmSheet(parentComponent, message, optionType,
        messageType, null, listener);
###
1465, showSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1155, 1202
8
/**
   * Displays a custom file chooser sheet with a custom approve button.
   *
   * @param   parent  the parent component of the dialog;
   *      can be <code>null</code>
   * @param   approveButtonText the text of the <code>ApproveButton</code>
   * @param listener The listener for SheetEvents.
   */
41
  public static void showSheet(final JFileChooser chooser, Component parent,
      String approveButtonText, SheetListener listener) {
    if (approveButtonText != null) {
      chooser.setApproveButtonText(approveButtonText);
      chooser.setDialogType(JFileChooser.CUSTOM_DIALOG);
    }
    // Begin Create Dialog
    Frame frame = parent instanceof Frame ? (Frame) parent
        : (Frame) SwingUtilities.getAncestorOfClass(Frame.class, parent);
    String title = chooser.getUI().getDialogTitle(chooser);
    chooser.getAccessibleContext().setAccessibleDescription(title);
    final JSheet sheet = new JSheet(frame);
    sheet.addSheetListener(listener);
    Container contentPane = sheet.getContentPane();
    contentPane.setLayout(new BorderLayout());
    contentPane.add(chooser, BorderLayout.CENTER);
    // End Create Dialog
    final ActionListener actionListener = new ActionListener() {
      public void actionPerformed(ActionEvent evt) {
        int option;
        if (evt.getActionCommand().equals("ApproveSelection")) {
          option = JFileChooser.APPROVE_OPTION;
        } else {
          option = JFileChooser.CANCEL_OPTION;
        }
        sheet.hide();
        sheet.fireOptionSelected(chooser, option);
        chooser.removeActionListener(this);
      }
    };
    chooser.addActionListener(actionListener);
    sheet.addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        sheet.fireOptionSelected(chooser, JFileChooser.CANCEL_OPTION);
        chooser.removeActionListener(actionListener);
      }
    });
    chooser.rescanCurrentDirectory();
    sheet.pack();
    sheet.show();
    sheet.toFront();
###
1466, showSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 599, 602
7
/**
   * Displays an option pane as a sheet on its parent window.
   *
   * @param pane The option pane.
   * @param parentComponent The parent of the option pane.
   * @param listener The listener for SheetEvents.
   */
4
  public static void showSheet(JOptionPane pane, Component parentComponent, SheetListener listener) {
    final JSheet sheet = createSheet(pane, parentComponent, styleFromMessageType(pane.getMessageType()));
    sheet.addSheetListener(listener);
    sheet.show();
###
1467, showMessageSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 906, 909
18
/**
   * Brings up a sheet displaying a message, specifying all parameters.
   *
   * @param parentComponent determines the <code>Frame</code> in which the
   *      sheet is displayed; if <code>null</code>,
   *      or if the <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param messageType the type of message to be displayed:
   *          <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *      <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param icon    an icon to display in the sheet that helps the user
   *          identify the kind of message that is being displayed
   * @param listener This listener is notified when the sheet is dismissed.
   */
4
  public static void showMessageSheet(Component parentComponent,
      Object message, int messageType, Icon icon, SheetListener listener) {
    showOptionSheet(parentComponent, message, JOptionPane.DEFAULT_OPTION,
        messageType, icon, null, null, listener);
###
1468, getWindowForComponent, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1081, 1088
12
/**
   * Returns the specified component's toplevel <code>Frame</code> or
   * <code>Dialog</code>.
   *
   * @param parentComponent the <code>Component</code> to check for a
   *    <code>Frame</code> or <code>Dialog</code>
   * @return the <code>Frame</code> or <code>Dialog</code> that
   *    contains the component, or the default
   *       frame if the component is <code>null</code>,
   *    or does not have a valid
   *       <code>Frame</code> or <code>Dialog</code> parent
   */
8
  static Window getWindowForComponent(Component parentComponent) {
    if (parentComponent == null) {
      return JOptionPane.getRootFrame();
    }
    if (parentComponent instanceof Frame || parentComponent instanceof Dialog) {
      return (Window) parentComponent;
    }
    return getWindowForComponent(parentComponent.getParent());
###
1469, showOpenSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1142, 1144
9
/**
   * Displays an "Open File" file chooser sheet. Note that the
   * text that appears in the approve button is determined by
   * the L&F.
   *
   * @param  parent  the parent component of the dialog,
   *      can be <code>null</code>.
   * @param listener The listener for SheetEvents.
   */
3
  public static void showOpenSheet(URIChooser chooser, Component parent, SheetListener listener) {
    chooser.setDialogType(JFileChooser.OPEN_DIALOG);
    showSheet(chooser, parent, null, listener);
###
1470, addSheetListener, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 476, 477
3
/**
   * Adds a sheet listener.
   */
2
  public void addSheetListener(SheetListener l) {
    listenerList.add(SheetListener.class, l);
###
1471, showMessageSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 823, 826
9
/**
   * Brings up an information-message sheet.
   *
   * @param parentComponent determines the <code>Frame</code> in
   *    which the dialog is displayed; if <code>null</code>,
   *    or if the <code>parentComponent</code> has no
   *    <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   */
4
  public static void showMessageSheet(Component parentComponent,
      Object message) {
    showMessageSheet(parentComponent, message,
        JOptionPane.INFORMATION_MESSAGE);
###
1472, showInputSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 728, 732
12
/**
   * Shows a question-message sheet requesting input from the user and
   * parented to <code>parentComponent</code>. The input value will be
   * initialized to <code>initialSelectionValue</code>.
   *
   * @param parentComponent  the parent <code>Component</code> for the
   *    dialog
   * @param message the <code>Object</code> to display
   * @param initialSelectionValue the value used to initialize the input
   *         field
   * @param listener The listener for SheetEvents.
   */
5
  public static void showInputSheet(Component parentComponent, Object message,
      Object initialSelectionValue, SheetListener listener) {
    showInputSheet(parentComponent, message,
        JOptionPane.QUESTION_MESSAGE, null, null,
        initialSelectionValue, listener);
###
1473, showInputSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 785, 811
29
/**
   * Prompts the user for input in a sheet where the
   * initial selection, possible selections, and all other options can
   * be specified. The user will able to choose from
   * <code>selectionValues</code>, where <code>null</code> implies the
   * user can input
   * whatever they wish, usually by means of a <code>JTextField</code>.
   * <code>initialSelectionValue</code> is the initial value to prompt
   * the user with. It is up to the UI to decide how best to represent
   * the <code>selectionValues</code>, but usually a
   * <code>JComboBox</code>, <code>JList</code>, or
   * <code>JTextField</code> will be used.
   *
   * @param parentComponent  the parent <code>Component</code> for the
   *      dialog
   * @param message  the <code>Object</code> to display
   * @param messageType the type of message to be displayed:
   *          <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *      <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param icon   the <code>Icon</code> image to display
   * @param selectionValues an array of <code>Object</code>s that
   *      gives the possible selections
   * @param initialSelectionValue the value used to initialize the input
   *         field
   * @param listener The listener for SheetEvents.
   */
22
  public static void showInputSheet(Component parentComponent,
      Object message, int messageType, Icon icon,
      Object[] selectionValues, Object initialSelectionValue, SheetListener listener) {
    JOptionPane pane = new JOptionPane(message, messageType,
        JOptionPane.OK_CANCEL_OPTION, icon,
        null, null);
    pane.setWantsInput(true);
    pane.setSelectionValues(selectionValues);
    pane.setInitialSelectionValue(initialSelectionValue);
    pane.setComponentOrientation(((parentComponent == null) ? JOptionPane.getRootFrame() : parentComponent).getComponentOrientation());
    int style = styleFromMessageType(messageType);
    JSheet sheet = createSheet(pane, parentComponent, style);
    pane.selectInitialValue();
    /*
    sheet.addWindowListener(new WindowAdapter() {
    public void windowClosed(WindowEvent evt) {
    sheet.dispose();
    }
    });*/
    sheet.addSheetListener(listener);
    sheet.show();
    sheet.toFront();
###
1477, updateText, JLifeFormattedTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextField.java, 125, 144
3
/**
   * Updates the text of the field from the value.
   */
20
  protected void updateText() {
    if (updatingDepth++ == 0) {
      if (getFormatter() != null) {
        try {
          String newText = getFormatter().valueToString(getValue());
          setText(newText);
          if (!isFocusOwner()) {
            // This is like selectAll(), but we set the
            // cursor at the start of the field, because
            // the start of the field contains the most
            // significant part of the field content.
            setCaretPosition(getDocument().getLength());
            moveCaretPosition(0);
          }
        } catch (ParseException ex) {
          //ex.printStackTrace(); do nothing
        }
      }
    }
    updatingDepth--;
###
1478, updateValue, JLifeFormattedTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextField.java, 108, 119
3
/**
   * Updates the value from the text of the field.
   */
12
  protected void updateValue() {
    if (updatingDepth++ == 0) {
      if (getFormatter() != null) {
        try {
          Object newValue = getFormatter().stringToValue(getText());
          setValue(newValue);
        } catch (ParseException ex) {
          //ex.printStackTrace();// do nothing
        }
      }
    }
    updatingDepth--;
###
1479, getDefaultFormatterFactory, JLifeFormattedTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextField.java, 151, 181
4
/**
   * Returns an AbstractFormatterFactory suitable for the passed in
   * Object type.
   */
25
  private AbstractFormatterFactory getDefaultFormatterFactory(Object type) {
    if (type instanceof DateFormat) {
      return new DefaultFormatterFactory(new DateFormatter((DateFormat) type));
    }
    if (type instanceof NumberFormat) {
      return new DefaultFormatterFactory(new NumberFormatter(
          (NumberFormat) type));
    }
    if (type instanceof Format) {
      return new DefaultFormatterFactory(new InternationalFormatter(
          (Format) type));
    }
    if (type instanceof Date) {
      return new DefaultFormatterFactory(new DateFormatter());
    }
    if (type instanceof Number) {
      AbstractFormatter displayFormatter = new NumberFormatter();
      ((NumberFormatter) displayFormatter).setValueClass(type.getClass());
      AbstractFormatter editFormatter = new NumberFormatter(
          new DecimalFormat("#.#"));
      ((NumberFormatter) editFormatter).setValueClass(type.getClass());
      return new DefaultFormatterFactory(displayFormatter,
          displayFormatter, editFormatter);
    }
    return new DefaultFormatterFactory(new DefaultFormatter());
###
1480, arrangeFramesVertically, JMDIDesktopPane, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java, 163, 212
5
/**
   * Arranges the frames as efficiently as possibly with preference for
   * keeping vertical size maximal.<br>
   *
   */
50
  public void arrangeFramesVertically() {
    Component[] allFrames = getAllFrames();
    // do nothing if no frames to work with
    if (allFrames.length == 0) {
      return;
    }
    
    manager.setNormalSize();
    
    int vertFrames = (int)Math.floor(Math.sqrt(allFrames.length));
    int horFrames = (int)Math.ceil(Math.sqrt(allFrames.length));
    
    // first arrange the windows that have equal size
    int frameWidth = getBounds().width / horFrames;
    int frameHeight = getBounds().height / vertFrames;
    int x = 0;
    int y = 0;
    int frameIdx = 0;
    for (int horCnt = 0; horCnt < horFrames-1; horCnt++) {
      y = 0;
      for (int vertCnt = 0; vertCnt < vertFrames; vertCnt++) {
        try {
          ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
        } catch (PropertyVetoException e) {
          e.printStackTrace();
        }
        
        allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
        frameIdx++;
        y = y + frameHeight;
      }
      x = x + frameWidth;
    }
    
    // the rest of the frames are tiled down on the last column with equal
    // height
    frameHeight = getBounds().height / (allFrames.length - frameIdx);
    y = 0;
    for (; frameIdx < allFrames.length; frameIdx++) {
      try {
        ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
      } catch (PropertyVetoException e) {
        e.printStackTrace();
      }
      
      allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
      y = y + frameHeight;
    }
    
    checkDesktopSize();
###
1481, arrangeFramesHorizontally, JMDIDesktopPane, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java, 220, 269
5
/**
   * Arranges the frames as efficiently as possibly with preference for
   * keeping horizontal size maximal.<br>
   *
   */
50
  public void arrangeFramesHorizontally() {
    Component[] allFrames = getAllFrames();
    // do nothing if no frames to work with
    if (allFrames.length == 0) {
      return;
    }
    
    manager.setNormalSize();
    
    int vertFrames = (int)Math.ceil(Math.sqrt(allFrames.length));
    int horFrames = (int)Math.floor(Math.sqrt(allFrames.length));
    
    // first arrange the windows that have equal size
    int frameWidth = getBounds().width / horFrames;
    int frameHeight = getBounds().height / vertFrames;
    int x = 0;
    int y = 0;
    int frameIdx = 0;
    for (int vertCnt = 0; vertCnt < vertFrames-1; vertCnt++) {
      x = 0;
      for (int horCnt = 0; horCnt < horFrames; horCnt++) {
        try {
          ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
        } catch (PropertyVetoException e) {
          e.printStackTrace();
        }
        
        allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
        frameIdx++;
        x = x + frameWidth;
      }
      y = y + frameHeight;
    }
    
    // the rest of the frames are tiled down on the last column with equal
    // height
    frameWidth = getBounds().width / (allFrames.length - frameIdx);
    x = 0;
    for (; frameIdx < allFrames.length; frameIdx++) {
      try {
        ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
      } catch (PropertyVetoException e) {
        e.printStackTrace();
      }
      
      allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
      x = x + frameWidth;
    }
    
    checkDesktopSize();
###
1482, setAllSize, JMDIDesktopPane, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java, 276, 280
4
/**
   * Sets all component size properties ( maximum, minimum, preferred)
   * to the given dimension.
   */
5
  public void setAllSize(Dimension d) {
    setMinimumSize(d);
    setMaximumSize(d);
    setPreferredSize(d);
    setBounds(0, 0, d.width, d.height);
###
1483, arrangeFramesCascading, JMDIDesktopPane, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java, 73, 104
3
/**
   * Cascade all internal frames
   */
32
  private void arrangeFramesCascading() {
    JInternalFrame[] allFrames = getAllFrames();
    
    // do nothing if no frames to work with
    if (allFrames.length == 0) {
      return;
    }
    
    manager.setNormalSize();
    Insets insets = getInsets();
    int x = insets.left;
    int y = insets.top;
    int frameOffset=0;
    for (int i = allFrames.length - 1; i >= 0; i--) {
      Point p=SwingUtilities.convertPoint(allFrames[i].getContentPane(),0,0,allFrames[i]);
      frameOffset=Math.max(frameOffset,Math.max(p.x,p.y));
    }
    int frameHeight = (getBounds().height-insets.top-insets.bottom) - allFrames.length * frameOffset;
    int frameWidth = (getBounds().width-insets.left-insets.right) - allFrames.length * frameOffset;
    for (int i = allFrames.length - 1; i >= 0; i--) {
      try {
        allFrames[i].setMaximum(false);
      } catch (PropertyVetoException e) {
        e.printStackTrace();
      }
      
      allFrames[i].setBounds(x, y, frameWidth, frameHeight);
      x = x + frameOffset;
      y = y + frameOffset;
    }
    
    checkDesktopSize();
###
1501, JPopupButton, JPopupButton, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java, 51, 54
1
/** Creates new form JToolBarMenu */
4
  public JPopupButton() {
    initComponents();
    setFocusable(false);
    itemFont = ITEM_FONT;
###
1503, setPopupAnchor, JPopupButton, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java, 164, 165
12
/**
   * Sets the popup anchor.
   * <p>
   * <ul>
   * <li>SOUTH_WEST places the popup below the button and aligns it with its 
   * left bound.</li>
   * <li>SOUTH_EAST places the popup below the button and aligns it with its 
   * right bound.</li>
   * </ul> 
   * 
   * @param newValue SwingConstants.SOUTH_WEST or SOUTH_EAST.
   */
2
  public void setPopupAnchor(int newValue) {
    popupAnchor = newValue;
###
1505, getPopupAnchor, JPopupButton, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java, 148, 149
5
/**
   * Gets the popup anchor.
   * 
   * @return SwingConstants.SOUTH_WEST or SOUTH_EAST.
   */
2
  public int getPopupAnchor() {
    return popupAnchor;
###
1510, initComponents, JPopupButton, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java, 212, 219
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
7
  private void initComponents() {
    addMouseListener(new java.awt.event.MouseAdapter() {
      public void mousePressed(java.awt.event.MouseEvent evt) {
        handleMousePressed(evt);
      }
      public void mouseReleased(java.awt.event.MouseEvent evt) {
        performAction(evt);
###
1534, getSelectionPath, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 282, 283
6
/**
   * Gets the selected Font.
   * This is a bound property.
   * 
   * @return The selected font, or null, if no font is selected.
   */
2
  public TreePath getSelectionPath() {
    return selectionPath;
###
1535, addActionListener, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 229, 230
8
/**
   * Adds an <code>ActionListener</code> to the font chooser.
   *
   * @param l  the listener to be added
   * 
   * @see #approveSelection
   * @see #cancelSelection
   */
2
  public void addActionListener(ActionListener l) {
    listenerList.add(ActionListener.class, l);
###
1536, setSelectedFont, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 377, 381
12
/**
   * Sets the selected Font.
   * <p>
   * Changing the selected font, causes a change of the
   * selection path, if the selected font is not the last
   * path segment of the selection path.
   * 
   * This is a bound property.
   * 
   * @param newValue The new selected font, or null if no font is to be
   * selected.
   */
5
  public void setSelectedFont(Font newValue) {
    Font oldValue = selectedFont;
    this.selectedFont = newValue;
    firePropertyChange(SELECTED_FONT_PROPERTY, oldValue, newValue);
    updateSelectionPath(newValue);
###
1537, setSelectionPath, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 297, 302
11
/**
   * Sets the selected Font.
   * This is a bound property.
   * <p>
   * Changing the selection path, causes a change of the
   * selected font, if the selected font is not the last
   * path segment of the selection path.
   * 
   * @param newValue The new selected font, or null if no font is to be
   * selected..
   */
6
  public void setSelectionPath(TreePath newValue) {
    TreePath oldValue = selectionPath;
    this.selectionPath = newValue;
    firePropertyChange(SELECTION_PATH_PROPERTY, oldValue, newValue);
    if (selectionPath != null && selectionPath.getPathCount() == 4) {
      setSelectedFont(((FontFaceNode) selectionPath.getLastPathComponent()).getFont());
###
1538, LabelFigure, LabelFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabelFigure.java, 40, 41
1
/** Creates a new instance. */
2
  public LabelFigure() {
    this("Label");
###
1539, cancelSelection, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 213, 218
9
/**
   * Called by the UI when the user chooses the Cancel button.
   * This can also be called by the programmer.
   * This method causes an action event to fire
   * with the command string equal to
   * <code>CANCEL_SELECTION</code>.
   *
   * @see #CANCEL_SELECTION
   */
6
  public void cancelSelection() {
    returnValue = CANCEL_OPTION;
    if (dialog != null) {
      dialog.setVisible(false);
    }
    fireActionPerformed(CANCEL_SELECTION);
###
1540, getUIClassID, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 181, 183
8
/**
   * Returns a string that specifies the name of the L&F class
   * that renders this component.
   *
   * @return "FontChooserUI"
   * @see JComponent#getUIClassID
   * @see UIDefaults#getUI
   */
3
  @Override
  public String getUIClassID() {
    return uiClassID;
###
1541, getSelectedFont, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 361, 362
6
/**
   * Gets the selected Font.
   * This is a bound property.
   * 
   * @return The selected font, or null, if no font is selected.
   */
2
  public Font getSelectedFont() {
    return selectedFont;
###
1542, getUI, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 159, 160
6
/**
   * Returns the look and feel (L&F) object that renders this component.
   *
   * @return the PanelUI object that renders this component
   * @since 1.4
   */
2
  public FontChooserUI getUI() {
    return (FontChooserUI) ui;
###
1543, loadAllFonts, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 310, 332
4
/**
   * Starts loading all fonts from the local graphics environment 
   * using a worker thread.
   */
21
  public synchronized static void loadAllFonts() {
    if (future == null) {
      future = new FutureTask<Font[]>(new Callable<Font[]>() {
        public Font[] call() throws Exception {
          long start = System.currentTimeMillis();
          Font[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();
          long end = System.currentTimeMillis();
          //System.out.println("JFontChooser has loaded all fonts. Elapsed:"+(end-start));
          // get rid of bogus fonts
          ArrayList<Font> goodFonts = new ArrayList<Font>(fonts.length);
          for (Font f : fonts) {
            Font decoded = Font.decode(f.getFontName());
            if (decoded.getFontName().equals(f.getFontName()) || decoded.getFontName().endsWith("-Derived")) {
              goodFonts.add(f);
            }
          }
          return goodFonts.toArray(new Font[goodFonts.size()]);
        // return fonts;
        }
      });
      new Thread(future).start();
###
1544, getAllFonts, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 344, 351
8
/**
   * Gets all fonts from the graphics environment. This may take a long
   * time. It is recommended to call loadAllFonts during the startup 
   * of an application. If you do this, you can retrieve the fonts from
   * this method from the AWT Event Dispatcher Thread.
   * 
   * @return All fonts.
   */
8
  public static synchronized Font[] getAllFonts() {
    loadAllFonts();
    try {
      return future.get().clone();
    } catch (InterruptedException ex) {
      return new Font[0];
    } catch (ExecutionException ex) {
      return new Font[0];
###
1545, updateUI, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 142, 149
5
/**
   * Resets the UI property with a value from the current look and feel.
   *
   * @see JComponent#updateUI
   */
8
  @Override
  public void updateUI() {
    // Try to get a browser UI from the UIManager.
    // Fall back to BasicBrowserUI, if none is available.
    if (UIManager.get(getUIClassID()) != null) {
      setUI((FontChooserUI) UIManager.getUI(this));
    } else {
      setUI(PaletteFontChooserUI.createUI(this));
###
1546, removeActionListener, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 240, 241
7
/**
   * Removes an <code>ActionListener</code> from the font chooser.
   *
   * @param l  the listener to be removed
   *
   * @see #addActionListener
   */
2
  public void removeActionListener(ActionListener l) {
    listenerList.remove(ActionListener.class, l);
###
1547, setUI, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 169, 170
6
/**
   * Sets the look and feel (L&F) object that renders this component.
   *
   * @param ui  the PanelUI L&F object
   * @see UIDefaults#getUI
   */
2
  public void setUI(FontChooserUI ui) {
    super.setUI(ui);
###
1548, approveSelection, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 196, 201
10
/**
   * Called by the UI when the user hits the Approve button
   * (labeled "Open" or "Save", by default). This can also be
   * called by the programmer.
   * This method causes an action event to fire
   * with the command string equal to
   * <code>APPROVE_SELECTION</code>.
   *
   * @see #APPROVE_SELECTION
   */
6
  public void approveSelection() {
    returnValue = APPROVE_OPTION;
    if (dialog != null) {
      dialog.setVisible(false);
    }
    fireActionPerformed(APPROVE_SELECTION);
###
1549, getModel, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 464, 465
6
/**
   * Gets the selected Font.
   * This is a bound property.
   * 
   * @return The selected font, or null, if no font is selected.
   */
2
  public FontChooserModel getModel() {
    return model;
###
1550, updateSelectionPath, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 392, 452
8
/**
   * Updates the selection path to the selected font.
   * <p>
   * This method is invoked, when a font is selected, and when then
   * structure of the model has changed.
   * 
   * @param newValue
   */
58
  protected void updateSelectionPath(Font newValue) {
    if (newValue == null || selectionPath == null || selectionPath.getPathCount() != 4 ||
        !((FontFaceNode) selectionPath.getLastPathComponent()).getFont().getFontName().equals(newValue.getFontName())) {
      if (newValue == null) {
        setSelectionPath(null);
      } else {
        TreePath path = selectionPath;
        FontCollectionNode oldCollection = (path != null && path.getPathCount() > 1) ? (FontCollectionNode) path.getPathComponent(1) : null;
        FontFamilyNode oldFamily = (path != null && path.getPathCount() > 2) ? (FontFamilyNode) path.getPathComponent(2) : null;
        FontFaceNode oldFace = (path != null && path.getPathCount() > 3) ? (FontFaceNode) path.getPathComponent(3) : null;
        FontCollectionNode newCollection = oldCollection;
        FontFamilyNode newFamily = oldFamily;
        FontFaceNode newFace = null;
        // search in the current family
        if (newFace == null && newFamily != null) {
          for (FontFaceNode face : newFamily.faces()) {
            if (face.getFont().getFontName().equals(newValue.getFontName())) {
              newFace = face;
              break;
            }
          }
        }
        // search in the current collection
        if (newFace == null && newCollection != null) {
          for (FontFamilyNode family : newCollection.families()) {
            for (FontFaceNode face : family.faces()) {
              if (face.getFont().getFontName().equals(newValue.getFontName())) {
                newFamily = family;
                newFace = face;
                break;
              }
            }
          }
        }
        // search in all collections
        if (newFace == null) {
          TreeNode root = (TreeNode) getModel().getRoot();
          OuterLoop:
          for (int i = 0, n = root.getChildCount(); i < n; i++) {
            FontCollectionNode collection = (FontCollectionNode) root.getChildAt(i);
            for (FontFamilyNode family : collection.families()) {
              for (FontFaceNode face : family.faces()) {
                if (face.getFont().getFontName().equals(newValue.getFontName())) {
                  newCollection = collection;
                  newFamily = family;
                  newFace = face;
                  break OuterLoop;
                }
              }
            }
          }
        }
        if (newFace != null) {
          setSelectionPath(new TreePath(new Object[]{
                getModel().getRoot(), newCollection, newFamily, newFace
              }));
        } else {
          setSelectionPath(null);
###
1551, JFontChooser, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 115, 131
1
/** Creates new form JFontChooser */
15
  public JFontChooser() {
    loadAllFonts();
    model = new DefaultFontChooserModel.UIResource();
    model.addTreeModelListener(modelHandler);
    updateUI();
    addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getPropertyName() == "ancestor" && evt.getNewValue() != null) {
          Component ancestor = (Component) evt.getNewValue();
          try {
            ((DefaultFontChooserModel) model).setFonts(getAllFonts());
          } catch (Exception ex) {
            ex.printStackTrace();
          }
          JFontChooser.this.removePropertyChangeListener(this);
###
1552, fireActionPerformed, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 249, 271
5
/**
   * Notifies all listeners that have registered interest for
   * notification on this event type. The event instance
   * is lazily created using the <code>command</code> parameter.
   */
23
  protected void fireActionPerformed(String command) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    long mostRecentEventTime = EventQueue.getMostRecentEventTime();
    int modifiers = 0;
    AWTEvent currentEvent = EventQueue.getCurrentEvent();
    if (currentEvent instanceof InputEvent) {
      modifiers = ((InputEvent) currentEvent).getModifiers();
    } else if (currentEvent instanceof ActionEvent) {
      modifiers = ((ActionEvent) currentEvent).getModifiers();
    }
    ActionEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == ActionListener.class) {
        // Lazily create the event:
        if (e == null) {
          e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED,
              command, mostRecentEventTime,
              modifiers);
        }
        ((ActionListener) listeners[i + 1]).actionPerformed(e);
###
1553, setImageData, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 240, 244
4
/**
   * Sets the image data.
   * This clears the buffered image.
   */
5
  public void setImageData(byte[] imageData) {
    willChange();
    this.imageData = imageData;
    this.bufferedImage = null;
    changed();
###
1554, getBufferedImage, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 262, 274
4
/**
   * Gets the buffered image. If necessary, this method creates the buffered
   * image from the image data.
   */
13
  public BufferedImage getBufferedImage() {
    if (bufferedImage == null && imageData != null) {
      try {
        bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));
      } catch (IOException e) {
        e.printStackTrace();
        // If we can't create a buffered image from the image data,
        // there is no use to keep the image data and try again, so
        // we drop the image data.
        imageData = null;
      }
    }
    return bufferedImage;
###
1557, PickAttributesAction, PickAttributesAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/PickAttributesAction.java, 35, 38
1
/** Creates a new instance. */
4
  public PickAttributesAction(DrawingEditor editor) {
    super(editor);
    labels.configureAction(this, "edit.pickAttributes");
    setEnabled(true);
###
1561, ImageFigure, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 57, 58
1
/** Creates a new instance. */
2
  public ImageFigure() {
    this(0, 0, 0, 0);
###
1563, setImage, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 229, 233
8
/**
   * Sets the image.
   *
   * @param imageData The image data. If this is null, a buffered image must
   * be provided.
   * @param bufferedImage An image constructed from the imageData. If this
   * is null, imageData must be provided.
   */
5
  public void setImage(byte[] imageData, BufferedImage bufferedImage) {
    willChange();
    this.imageData = imageData;
    this.bufferedImage = bufferedImage;
    changed();
###
1566, getEventSetDescriptors, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 116, 117
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1567, setBufferedImage, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 251, 255
4
/**
   * Sets the buffered image.
   * This clears the image data.
   */
5
  public void setBufferedImage(BufferedImage image) {
    willChange();
    this.imageData = null;
    this.bufferedImage = image;
    changed();
###
1568, getDefaultEventIndex, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 150, 151
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1569, getImageData, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 281, 296
4
/**
   * Gets the image data. If necessary, this method creates the image
   * data from the buffered image.
   */
16
  public byte[] getImageData() {
    if (bufferedImage != null && imageData == null) {
      try {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        ImageIO.write(bufferedImage, "PNG", bout);
        bout.close();
        imageData = bout.toByteArray();
      } catch (IOException e) {
        e.printStackTrace();
        // If we can't create image data from the buffered image,
        // there is no use to keep the buffered image and try again, so
        // we drop the buffered image.
        bufferedImage = null;
      }
    }
    return imageData;
###
1570, getDefaultPropertyIndex, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 139, 140
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1572, transform, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 156, 161
4
/**
   * Transforms the figure.
   * @param tx The transformation.
   */
6
  public void transform(AffineTransform tx) {
    Point2D.Double anchor = getStartPoint();
    Point2D.Double lead = getEndPoint();
    setBounds(
        (Point2D.Double) tx.transform(anchor, anchor),
        (Point2D.Double) tx.transform(lead, lead));
###
1573, getPropertyDescriptors, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 105, 106
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1574, getBeanDescriptor, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 89, 90
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1575, figureContains, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 138, 142
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
5
  public boolean figureContains(Point2D.Double p) {
    Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();
    double grow = AttributeKeys.getPerpendicularHitGrowth(this) + 1d;
    Geom.grow(r, grow, grow);
    return r.contains(p);
###
1576, getMethodDescriptors, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 127, 128
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1577, GroupFigure, GroupFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GroupFigure.java, 28, 29
1
/** Creates a new instance. */
2
  public GroupFigure() {
    setConnectable(false);
###
1578, getMethodDescriptors, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 119, 120
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1579, getDefaultPropertyIndex, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 131, 132
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1580, getEventSetDescriptors, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 108, 109
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1581, getBeanDescriptor, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 81, 82
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1582, ZoomAction, ZoomAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ZoomAction.java, 34, 36
3
/**
   * Creates a new instance.
   */
3
  public ZoomAction(DrawingEditor editor, double scaleFactor, AbstractButton button) {
    this((DrawingView) null, scaleFactor, button);
    setEditor(editor);
###
1583, getDefaultEventIndex, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 142, 143
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1585, getPropertyDescriptors, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 97, 98
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1588, GraphicalCompositeFigure, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 105, 106
4
/**
   * Default constructor which uses nothing as presentation
   * figure. This constructor is needed by the Storable mechanism.
   */
2
  public GraphicalCompositeFigure() {
    this(null);
###
1589, getDrawingArea, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 152, 157
4
/**
   * Return the draw area. This method is delegated to the
   * encapsulated presentation figure.
   */
6
  public Rectangle2D.Double getDrawingArea() {
    Rectangle2D.Double r = super.getDrawingArea();
    if (getPresentationFigure() != null) {
      r.add(getPresentationFigure().getDrawingArea());
    }
    return r;
###
1590, GraphicalCompositeFigure, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 114, 116
6
/**
   * Constructor which creates a GraphicalCompositeFigure with
   * a given graphical figure for presenting it.
   *
   * @param  newPresentationFigure  figure which renders the container
   */
3
  public GraphicalCompositeFigure(Figure newPresentationFigure) {
    super();
    setPresentationFigure(newPresentationFigure);
###
1591, setPresentationFigure, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 236, 247
11
/**
   * Set a figure which renders this BasicCompositeFigure. The presentation
   * tasks for the BasicCompositeFigure are delegated to this presentation
   * figure.
   * 
   * 
   * 
   * 
   * 
   * @param newPresentationFigure  figure takes over the presentation tasks
   */
12
  public void setPresentationFigure(Figure newPresentationFigure) {
    if (this.presentationFigure != null) {
      this.presentationFigure.removeFigureListener(presentationFigureHandler);
      if (getDrawing() != null) {
        this.presentationFigure.removeNotify(getDrawing());
      }
    }
    this.presentationFigure = newPresentationFigure;
    if (this.presentationFigure != null) {
      this.presentationFigure.addFigureListener(presentationFigureHandler);
      if (getDrawing() != null) {
        this.presentationFigure.addNotify(getDrawing());
###
1592, SelectionColorChooserAction, SelectionColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/SelectionColorChooserAction.java, 39, 40
1
/** Creates a new instance. */
2
  public SelectionColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {
    this(editor, key, null, icon);
###
1593, SelectionColorChooserAction, SelectionColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/SelectionColorChooserAction.java, 35, 36
1
/** Creates a new instance. */
2
  public SelectionColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {
    this(editor, key, null, null);
###
1594, setBounds, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 164, 176
5
/**
   * Moves the figure. This is the
   * method that subclassers override. Clients usually
   * call displayBox.
   */
13
  public void setBounds(Point2D.Double anchor, Point2D.Double lead) {
    if (getLayouter() == null) {
      super.setBounds(anchor, lead);
      basicSetPresentationFigureBounds(anchor, lead);
    } else {
      Rectangle2D.Double r = getLayouter().layout(this, anchor, lead);
      basicSetPresentationFigureBounds(new Point2D.Double(r.getX(), r.getY()),
          new Point2D.Double(
          Math.max(lead.x, (int) r.getMaxX()),
          Math.max(lead.y, (int) r.getMaxY())
          )
          );
      invalidate();
###
1595, get, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 313, 320
3
/**
   * Gets an attribute from the figure.
   */
8
  @Override
  public <T> T get(AttributeKey<T> key) {
    if (getPresentationFigure() != null) {
      return getPresentationFigure().get(key);
    } else {
      return (! attributes.containsKey(key)) ?
        key.getDefaultValue() :
        key.get(attributes);
###
1596, transform, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 193, 196
4
/**
   * Standard presentation method which is delegated to the encapsulated presentation figure.
   * The presentation figure is moved as well as all contained figures.
   */
4
  public void transform(AffineTransform tx) {
    super.transform(tx);
    if (getPresentationFigure() != null) {
      getPresentationFigure().transform(tx);
###
1597, getBounds, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 123, 125
4
/**
   * Return the logcal display area. This method is delegated to the encapsulated
   * presentation figure.
   */
3
  public Rectangle2D.Double getBounds() {
    if (getPresentationFigure() == null) return super.getBounds();
    return getPresentationFigure().getBounds();
###
1598, applyAttributesTo, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 326, 329
3
/**
   * Applies all attributes of this figure to that figure.
   */
4
  @SuppressWarnings("unchecked")
  protected void applyAttributesTo(Figure that) {
    for (Map.Entry<AttributeKey, Object> entry : attributes.entrySet()) {
      that.set(entry.getKey(), entry.getValue());
###
1599, createHandles, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 217, 222
3
/**
   * Return default handles from the presentation figure.
   */
6
  public Collection<Handle> createHandles(int detailLevel) {
    LinkedList<Handle> handles = new LinkedList<Handle>();
    if (detailLevel == 0) {
    MoveHandle.addMoveHandles(this, handles);
    }
    return handles;
###
1600, getPresentationFigure, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 264, 265
11
/**
   * Get a figure which renders this BasicCompositeFigure. The presentation
   * tasks for the BasicCompositeFigure are delegated to this presentation
   * figure.
   * 
   * 
   * 
   * 
   * 
   * @return figure takes over the presentation tasks
   */
2
  public Figure getPresentationFigure() {
    return presentationFigure;
###
1601, draw, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 203, 205
3
/**
   * Draw the figure. This method is delegated to the encapsulated presentation figure.
   */
3
  public void draw(Graphics2D g) {
    drawPresentationFigure(g);
    super.draw(g);
###
1602, set, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 289, 297
5
/**
   * Sets an attribute of the figure.
   * AttributeKey name and semantics are defined by the class implementing
   * the figure interface.
   */
9
  @Override
  public <T> void set(AttributeKey<T> key, T newValue) {
    if (forbiddenAttributes == null
        || ! forbiddenAttributes.contains(key)) {
      if (getPresentationFigure() != null) {
        getPresentationFigure().set(key, newValue);
      }
      super.set(key, newValue);
      Object oldValue = attributes.put(key, newValue);
###
1603, GridConstrainer, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 77, 78
8
/**
   * Creates a new instance with the specified grid size, 
   * and by 11.25° (in degrees) for rotations.
   * The grid is visible.
   *
   * @param width The width of a grid cell.
   * @param height The height of a grid cell.
   */
2
  public GridConstrainer(double width, double height) {
    this(width, height, Math.PI / 8d, true);
###
1604, getMajorGridSpacing, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 366, 367
3
/**
   * Spacing between major grid lines.
   */
2
  public int getMajorGridSpacing() {
    return majorGridSpacing;
###
1605, GridConstrainer, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 65, 66
3
/**
   * Creates a new instance with a grid of 1x1.
   */
2
  public GridConstrainer() {
    this(1d, 1d, 0d, false);
###
1606, translatePoint, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 211, 239
3
/**
   * Moves a point to the closest grid point in a direction.
   */
27
  public Point2D.Double translatePoint(Point2D.Double p, TranslationDirection dir) {
    Point2D.Double p0 = constrainPoint((Point2D.Double) p.clone());
    switch (dir) {
      case NORTH:
      case NORTH_WEST:
      case NORTH_EAST:
        p.y = p0.y - height;
        break;
      case SOUTH:
      case SOUTH_WEST:
      case SOUTH_EAST:
        p.y = p0.y + height;
        break;
    }
    switch (dir) {
      case WEST:
      case NORTH_WEST:
      case SOUTH_WEST:
        p.x = p0.x - width;
        break;
      case EAST:
      case NORTH_EAST:
      case SOUTH_EAST:
        p.x = p0.x + width;
        break;
    }
    return p;
###
1607, GridConstrainer, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 100, 107
8
/**
   * Creates a new instance with the specified grid size.
   *
   * @param width The width of a grid cell.
   * @param height The height of a grid cell.
   * @param theta The theta for rotations in radians.
   * @param visible Wether the grid is visible or not.
   */
8
  public GridConstrainer(double width, double height, double theta, boolean visible) {
    if (width <= 0 || height <= 0) {
      throw new IllegalArgumentException("Width or height is <= 0");
    }
    this.width = width;
    this.height = height;
    this.theta = theta;
    this.isVisible = visible;
###
1608, constrainPoint, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 161, 205
9
/**
   * Constrains the placement of a point towards a direction.
   * <p>
   * This method changes the point which is passed as a parameter.
   *
   * @param p A point on the drawing.
   * @param dir A direction.
   * @return Returns the constrained point.
   */
43
  protected Point2D.Double constrainPoint(Point2D.Double p, TranslationDirection dir) {
    Point2D.Double p0 = constrainPoint((Point2D.Double) p.clone());
    switch (dir) {
      case NORTH:
      case NORTH_WEST:
      case NORTH_EAST:
        if (p0.y < p.y) {
          p.y = p0.y;
        } else if (p0.y > p.y) {
          p.y = p0.y - height;
        }
        break;
      case SOUTH:
      case SOUTH_WEST:
      case SOUTH_EAST:
        if (p0.y < p.y) {
          p.y = p0.y + height;
        } else if (p0.y > p.y) {
          p.y = p0.y;
        }
        break;
    }
    switch (dir) {
      case WEST:
      case NORTH_WEST:
      case SOUTH_WEST:
        if (p0.x < p.x) {
          p.x = p0.x;
        } else if (p0.x > p.x) {
          p.x = p0.x - width;
        }
        break;
      case EAST:
      case NORTH_EAST:
      case SOUTH_EAST:
        if (p0.x < p.x) {
          p.x = p0.x + width;
        } else if (p0.x > p.x) {
          p.x = p0.x;
        }
        break;
    }
    return p;
###
1609, constrainRectangle, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 270, 303
10
/**
   * Constrains the placement of a rectangle towards a direction.
   * <p>
   * This method changes the location of the rectangle which is passed as a
   * parameter. This method does not change the size of the rectangle.
   *
   * @param r A rectangle on the drawing.
   * @param dir A direction.
   * @return Returns the constrained rectangle.
   */
31
  protected Rectangle2D.Double constrainRectangle(Rectangle2D.Double r, TranslationDirection dir) {
    Point2D.Double p0 = new Point2D.Double(r.x, r.y);
    switch (dir) {
      case NORTH:
      case NORTH_WEST:
      case WEST:
        constrainPoint(p0, dir);
        break;
      case EAST:
      case NORTH_EAST:
        p0.x += r.width;
        constrainPoint(p0, dir);
        p0.x -= r.width;
        break;
      case SOUTH:
      case SOUTH_WEST:
        p0.y += r.height;
        constrainPoint(p0, dir);
        p0.y -= r.height;
        break;
      case SOUTH_EAST:
        p0.y += r.height;
        p0.x += r.width;
        constrainPoint(p0, dir);
        p0.y -= r.height;
        p0.x -= r.width;
        break;
    }
    r.x = p0.x;
    r.y = p0.y;
    return r;
###
1610, GridConstrainer, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 89, 90
8
/**
   * Creates a new instance with the specified grid size.
   * and by 11.25° (in degrees) for rotations.
   *
   * @param width The width of a grid cell.
   * @param height The height of a grid cell.
   * @param visible Wether the grid is visible or not.
   */
2
  public GridConstrainer(double width, double height, boolean visible) {
    this(width, height, Math.PI / 8d, visible);
###
1611, setMajorGridSpacing, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 373, 377
3
/**
   * Spacing between major grid lines.
   */
5
  public void setMajorGridSpacing(int newValue) {
    int oldValue = majorGridSpacing;
    majorGridSpacing = newValue;
    firePropertyChange("majorGridSpacing", oldValue, newValue);
    fireStateChanged();
###
1612, constrainPoint, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 146, 149
3
/**
   * Constrains a point to the closest grid point in any direction.
   */
4
  public Point2D.Double constrainPoint(Point2D.Double p) {
    p.x = Math.round(p.x / width) * width;
    p.y = Math.round(p.y / height) * height;
    return p;
###
1613, getChildrenFrontToBack, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 183, 186
4
/**
   * Returns an iterator to iterate in
   * Z-order front to back over the children.
   */
4
  public java.util.List<Figure> getChildrenFrontToBack() {
    return children ==  null ?
      new LinkedList<Figure>() :
      new ReversedList<Figure>(children);
###
1616, transform, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 102, 107
3
/**
   * Transforms the figure.
   */
6
  public void transform(AffineTransform tx) {
    super.transform(tx);
    for (Figure f : children) {
      f.transform(tx);
    }
    invalidate();
###
1617, fireFigureAdded, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 328, 340
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
13
  protected void fireFigureAdded(Figure f, int zIndex) {
    CompositeFigureEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i] == CompositeFigureListener.class) {
        // Lazily create the event:
        if (event == null)
          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);
        ((CompositeFigureListener)listeners[i+1]).figureAdded(event);
###
1618, set, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 138, 143
8
/**
   * Sets an attribute of the figure.
   * AttributeKey name and semantics are defined by the class implementing
   * the figure interface.
   */
 --------------
// ATTRIBUTES
 --------------
6
  public <T> void set(AttributeKey<T> key, T newValue) {
    super.set(key, newValue);
    if (isAttributeEnabled(key)) {
      if (children != null) {
        for (Figure child : children) {
          child.set(key, newValue);
###
1619, fireFigureRemoved, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 349, 361
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
13
  protected void fireFigureRemoved(Figure f, int zIndex) {
    CompositeFigureEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i] == CompositeFigureListener.class) {
        // Lazily create the event:
        if (event == null)
          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);
        ((CompositeFigureListener)listeners[i+1]).figureRemoved(event);
###
1622, getLayouter, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 271, 272
12
/**
   * Get a Layouter object which encapsulated a layout
   * algorithm for this figure. Typically, a Layouter
   * accesses the child components of this figure and arranges
   * their graphical presentation.
   *
   *
   * @return layout strategy used by this figure
   */
 --------------
// LAYOUT
 --------------
2
  public Layouter getLayouter() {
    return layouter;
###
1623, layout, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 284, 291
6
/**
   * A layout algorithm is used to define how the child components
   * should be laid out in relation to each other. The task for
   * layouting the child components for presentation is delegated
   * to a Layouter which can be plugged in at runtime.
   */
8
  public void layout() {
    if (getLayouter() != null) {
      Rectangle2D.Double bounds = getBounds();
      Point2D.Double p = new Point2D.Double(bounds.x, bounds.y);
      Rectangle2D.Double r = getLayouter().layout(
          this, p, p
          );
      invalidate();
###
1625, draw, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 89, 93
3
/**
   * Draw the figure. This method is delegated to the encapsulated presentation figure.
   */
5
  public void draw(Graphics2D g) {
    super.draw(g);
    for (Figure child : children) {
      if (child.isVisible()) {
        child.draw(g);
###
1631, contains, EllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/EllipseFigure.java, 111, 119
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
8
  public boolean contains(Point2D.Double p) {
    Ellipse2D.Double r = (Ellipse2D.Double) ellipse.clone();
    double grow = AttributeKeys.getPerpendicularHitGrowth(this);
    r.x -= grow;
    r.y -= grow;
    r.width += grow * 2;
    r.height += grow * 2;
    return r.contains(p);
###
1632, EllipseFigure, EllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/EllipseFigure.java, 37, 38
4
/**
   * Constructs a new {@code EllipseFigure}, initialized to
   * location (0,&nbsp;0) and size (0,&nbsp;0).
   */
2
  public EllipseFigure() {
    this(0, 0, 0, 0);
###
1634, EllipseFigure, EllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/EllipseFigure.java, 50, 51
9
/**
   * Constructs and initializes an {@code EllipseFigure} from the
   * specified coordinates.
   *
   * @param x the x coordinate of the bounding rectangle
   * @param y the y coordinate of the bounding rectangle
   * @param width the width of the rectangle
   * @param height the height of the rectangle
   */
2
  public EllipseFigure(double x, double y, double width, double height) {
    ellipse = new Ellipse2D.Double(x, y, width, height);
###
1637, mouseReleased, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 125, 137
4
/**
   * MouseListener method for mouseReleased events. If the popup trigger has
   * been activated, then the appropriate hook method is called.
   */
12
  public void mouseReleased(MouseEvent evt) {
    if (popupTimer != null) {
      popupTimer.stop();
      popupTimer = null;
    }
    if (isMousePressedPopupTrigger) {
      isMousePressedPopupTrigger = false;
    } else {
      if (evt.isPopupTrigger()) {
        handlePopupMenu(evt);
      } else {
        super.mouseReleased(evt);
###
1638, handlePopupMenu, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 179, 185
4
/**
   * Hook method which can be overriden by subclasses to provide
   * specialised behaviour in the event of a popup trigger.
   */
7
  protected void handlePopupMenu(MouseEvent evt) {
    Point p = new Point(evt.getX(), evt.getY());
    Figure figure = getView().findFigure(p);
    if (figure != null || drawingActions.size() > 0) {
      showPopupMenu(figure, p, evt.getComponent());
    } else {
      popupMenu = null;
###
1639, DelegationSelectionTool, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 72, 73
1
/** Creates a new instance. */
2
  public DelegationSelectionTool() {
    this(new LinkedList<Action>(), new LinkedList<Action>());
###
1640, DelegationSelectionTool, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 77, 79
1
/** Creates a new instance. */
3
  public DelegationSelectionTool(Collection<Action> drawingActions, Collection<Action> selectionActions) {
    this.drawingActions = drawingActions;
    this.selectionActions = selectionActions;
###
1641, mousePressed, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 94, 117
4
/**
   * MouseListener method for mousePressed events. If the popup trigger has
   * been activated, then the appropriate hook method is called.
   */
22
  public void mousePressed(final MouseEvent evt) {
    if (popupTimer != null) {
      popupTimer.stop();
      popupTimer = null;
    }
    // XXX - When we want to support multiple views, we have to
    //     implement this:
    //setView((DrawingView)e.getSource());
    isMousePressedPopupTrigger = evt.isPopupTrigger();
    if (isMousePressedPopupTrigger) {
      getView().requestFocus();
      handlePopupMenu(evt);
    } else {
      super.mousePressed(evt);
      popupTimer = new javax.swing.Timer(1000, new ActionListener() {
        public void actionPerformed(ActionEvent aevt) {
          handlePopupMenu(evt);
          popupTimer = null;
        }
      });
      popupTimer.setRepeats(false);
      popupTimer.start();
###
1642, handleDoubleClick, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 266, 328
4
/**
   * Hook method which can be overriden by subclasses to provide
   * specialised behaviour in the event of a double click.
   */
60
  protected void handleDoubleClick(MouseEvent evt) {
    if (DEBUG) {
      System.out.println("DelegationSelectionTool.handleDoubleClick " + evt);
    }
    DrawingView v = getView();
    Point pos = new Point(evt.getX(), evt.getY());
    Handle handle = v.findHandle(pos);
    if (handle != null) {
      if (DEBUG) {
        System.out.println("DelegationSelectionTool.handleDoubleClick by handle");
      }
      handle.trackDoubleClick(pos, evt.getModifiersEx());
    } else {
      Point2D.Double p = viewToDrawing(pos);
      // Note: The search sequence used here, must be
      // consistent with the search sequence used by the
      // HandleTracker, the SelectAreaTracker and SelectionTool.
      // If possible, continue to work with the current selection
      Figure figure = null;
      if (isSelectBehindEnabled()) {
        for (Figure f : v.getSelectedFigures()) {
          if (f.contains(p)) {
            figure = f;
            break;
          }
        }
      }
      // If the point is not contained in the current selection,
      // search for a figure in the drawing.
      if (figure == null) {
        figure = v.findFigure(pos);
      }
      Figure outerFigure = figure;
      if (figure != null && figure.isSelectable()) {
        if (DEBUG) {
          System.out.println("DelegationSelectionTool.handleDoubleClick by figure");
        }
        Tool figureTool = figure.getTool(p);
        if (figureTool == null) {
          figure = getDrawing().findFigureInside(p);
          if (figure != null) {
            figureTool = figure.getTool(p);
          }
        }
        if (figureTool != null) {
          setTracker(figureTool);
          figureTool.mousePressed(evt);
        } else {
          if (outerFigure.handleMouseClick(p, evt, getView())) {
            v.clearSelection();
            v.addToSelection(outerFigure);
          } else {
            v.clearSelection();
            v.addToSelection(outerFigure);
            v.setHandleDetailLevel(v.getHandleDetailLevel() + 1);
          }
        }
      }
    }
    evt.consume();
###
1644, DefaultHandleTracker, DefaultHandleTracker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DefaultHandleTracker.java, 64, 66
1
/** Creates a new instance. */
3
  public DefaultHandleTracker(Handle handle) {
    masterHandle = handle;
    multicaster = new HandleMulticaster(handle);
###
1645, ImageTool, ImageTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ImageTool.java, 57, 58
1
/** Creates a new instance. */
2
  public ImageTool(ImageHolderFigure prototype) {
    super(prototype);
###
1646, ImageTool, ImageTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ImageTool.java, 62, 63
1
/** Creates a new instance. */
2
  public ImageTool(ImageHolderFigure prototype, Map<AttributeKey, Object> attributes) {
    super(prototype, attributes);
###
1647, CreationTool, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 144, 145
11
/** Creates a new instance with the specified prototype but without an
   * attribute set. The CreationTool clones this prototype each time a new
   * Figure needs to be created. When a new Figure is created, the
   * CreationTool applies the default attributes from the DrawingEditor to it,
   * and then it applies the attributes to it, that have been supplied in
   * this constructor.
   *
   * @param prototype The prototype used to create a new Figure.
   * @param attributes The CreationTool applies these attributes to the
   * prototype after having applied the default attributes from the DrawingEditor.
   */
2
  public CreationTool(Figure prototype, Map<AttributeKey, Object> attributes) {
    this(prototype, attributes, null);
###
1648, CreationTool, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 158, 165
10
/**
   * Creates a new instance with the specified prototype and attribute set.
   *
   * @param prototype The prototype used to create a new Figure.
   * @param attributes The CreationTool applies these attributes to the
   * prototype after having applied the default attributes from the DrawingEditor.
   * @param name The name parameter is currently not used.
   * @deprecated This constructor might go away, because the name parameter
   * is not used.
   */
8
  public CreationTool(Figure prototype, Map<AttributeKey, Object> attributes, String name) {
    this.prototype = prototype;
    this.prototypeAttributes = attributes;
    if (name == null) {
      ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
      name = labels.getString("edit.createFigure.text");
    }
    this.presentationName = name;
###
1649, CreationTool, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 129, 130
7
/** Creates a new instance with the specified prototype but without an
   * attribute set. The CreationTool clones this prototype each time a new
   *  Figure needs to be created. When a new Figure is created, the
   * CreationTool applies the default attributes from the DrawingEditor to it.
   *
   * @param prototype The prototype used to create a new Figure.
   */
2
  public CreationTool(Figure prototype) {
    this(prototype, null, null);
###
1650, CreationTool, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 98, 99
1
/** Creates a new instance. */
2
  public CreationTool(String prototypeClassName) {
    this(prototypeClassName, null, null);
###
1651, setToolDoneAfterCreation, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 310, 312
5
/**
   * If this is set to false, the CreationTool does not fire toolDone
   * after a new Figure has been created. This allows to create multiple
   * figures consecutively.
   */
3
  public void setToolDoneAfterCreation(boolean newValue) {
    boolean oldValue = isToolDoneAfterCreation;
    isToolDoneAfterCreation = newValue;
###
1652, creationFinished, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 296, 301
5
/**
   * This method allows subclasses to do perform additonal user interactions
   * after the new figure has been created.
   * The implementation of this class just invokes fireToolDone.
   */
6
  protected void creationFinished(Figure createdFigure) {
    if (createdFigure.isSelectable()) {
      getView().addToSelection(createdFigure);
    }
    if (isToolDoneAfterCreation()) {
      fireToolDone();
###
1653, ImageTransferable, ImageTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/ImageTransferable.java, 44, 45
1
/** Creates a new instance. */
2
  public ImageTransferable(Image image) {
    this.image = image;
###
1654, setUpdateDrawingEditorDefaults, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 242, 243
6
/**
   * Set this to true if you want the attribute editor to update the
   * default values of the drawing editor.
   * 
   * @param newValue
   */
2
  public void setUpdateDrawingEditorDefaults(boolean newValue) {
    isUpdateDrawingEditorDefaults = newValue;
###
1655, setView, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 222, 224
9
/**
   * Attaches the FigureAttributeEditorHandler to the specified DrawingView.
   * <p>
   * If a non-null value is provided, the FigureAttributeEditorHandler listens only
   * to selection changes of the specified view. If a null value is provided,
   * the FigureAttributeEditorHandler listens to all views of the drawing editor.
   *
   * @param newValue a drawing view.
   */
3
  public void setView(DrawingView newValue) {
    this.view = newValue;
    updateActiveView();
###
1656, setDrawingEditor, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 193, 202
9
/**
   * Attaches the FigureAttributeEditorHandler to the specified DrawingEditor.
   * <p>
   * The FigureAttributeEditorHandler listens to view changes and selection
   * changes of the drawing editor and calls setEnabled(boolean) and
   * updateField(Set&lt;Figure&gt;) on the field accordingly.
   *
   * @param newValue a drawing editor.
   */
10
  public void setDrawingEditor(DrawingEditor newValue) {
    DrawingEditor oldValue = drawingEditor;
    if (drawingEditor != null) {
      drawingEditor.removePropertyChangeListener(eventHandler);
    }
    this.drawingEditor = newValue;
    if (drawingEditor != null) {
      drawingEditor.addPropertyChangeListener(new WeakPropertyChangeListener(eventHandler));
    }
    updateActiveView();
###
1657, setAttributeEditor, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 265, 271
3
/**
   * Attaches the FigureAttributeEditorHandler to the specified AttributeEditor.
   */
7
  public void setAttributeEditor(AttributeEditor<T> newValue) {
    if (attributeEditor != null) {
      attributeEditor.removePropertyChangeListener(eventHandler);
    }
    this.attributeEditor = newValue;
    if (attributeEditor != null) {
      attributeEditor.addPropertyChangeListener(eventHandler);
###
1658, getAttributeEditor, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 279, 280
4
/**
   * Returns the AttributeEditor to which this FigureAttributeEditorHandler is
   * attached. 
   */
2
  public AttributeEditor<T> getAttributeEditor() {
    return attributeEditor;
###
1659, getView, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 232, 233
5
/**
   * Returns the DrawingView to which this FigureAttributeEditorHandler is
   * attached. Returns null, if the FigureAttributeEditorHandler is attached
   * to all views of the DrawingEditor.
   */
2
  public DrawingView getView() {
    return view;
###
1660, isUpdateDrawingEditorDefaults, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 250, 251
4
/**
   * Returns true if the attribute editor updates the
   * default values of the drawing editor.
   */
2
  public boolean isUpdateDrawingEditorDefaults() {
    return isUpdateDrawingEditorDefaults;
###
1661, getDrawingEditor, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 209, 210
4
/**
   * Returns the DrawingEditor to which this FigureAttributeEditorHandler is
   * attached.
   */
2
  public DrawingEditor getDrawingEditor() {
    return drawingEditor;
###
1662, create, GenericListener, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/GenericListener.java, 104, 138
6
/**
   * Return an instance of a class that implements the interface that contains
   * the declaration for <code>listenerMethod</code>.  In this new class,
   * <code>listenerMethod</code> will apply <code>target.targetMethod</code>
   * to the incoming Event.
   */
35
  public static Object create(
  final Method listenerMethod,
  final Object target,
  final Method targetMethod) {
    /**
     * The implementation of the create method uses the Dynamic Proxy API
     * introduced in JDK 1.3.
     *
     * Create an instance of the DefaultInvoker and override the invoke
     * method to handle the invoking the targetMethod on the target.
     */
    InvocationHandler handler = new DefaultInvoker() {
      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        
        // Send all methods except for the targetMethod to
        // the superclass for handling.
        if (listenerMethod.equals(method)) {
          if (targetMethod.getParameterTypes().length == 0) {
            // Special treatment for parameterless target methods:
            return targetMethod.invoke(target, new Object[0]);
          } else {
            // Regular treatment for target methods having the same
            // argument list as the listener method.
            return targetMethod.invoke(target, args);
          }
        } else {
          return super.invoke(proxy, method, args);
        }
      }
    };
    
    Class cls = listenerMethod.getDeclaringClass();
    ClassLoader cl = cls.getClassLoader();
    return Proxy.newProxyInstance(cl, new Class[]{cls}, handler);
###
1663, getListenerMethod, GenericListener, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/GenericListener.java, 202, 218
7
/* Helper methods for "EZ" version of create(): */
 --------------
/**
   * Implementation of the InvocationHandler which handles the basic
   * object methods.
   */
 --------------
17
  private static Method getListenerMethod(Class listenerInterface,
  String listenerMethodName) {
    // given the arguments to create(), find out which listener is desired:
    Method[] m = listenerInterface.getMethods();
    Method result = null;
    for (int i = 0; i < m.length; i++) {
      if (listenerMethodName.equals(m[i].getName())) {
        if (result != null) {
          throw new RuntimeException("ambiguous method: "+m[i]+" vs. "+result);
        }
        result = m[i];
      }
    }
    if (result == null) {
      throw new RuntimeException("no such method "+listenerMethodName+" in "+listenerInterface);
    }
    return result;
###
1664, create, GenericListener, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/GenericListener.java, 73, 94
4
/**
   * A convenient version of <code>create(listenerMethod, targetObject, targetMethod)</code>.
   * This version looks up the listener and target Methods, so you don't have to.
   */
22
  public static Object create(
  Class listenerInterface,
  String listenerMethodName,
  Object target,
  String targetMethodName) {
    Method listenerMethod = getListenerMethod(listenerInterface, listenerMethodName);
    
    // Search a target method with the same parameter types as the listener method.
    Method targetMethod =
    getTargetMethod(target, targetMethodName, listenerMethod.getParameterTypes());
    
    // Nothing found? Search a target method with no parameters
    if (targetMethod == null) {
      targetMethod = getTargetMethod(target, targetMethodName, new Class[0]);
    }
    
    // Still nothing found? We give up.
    if (targetMethod == null) {
      throw new RuntimeException("no such method "+targetMethodName+" in "+target.getClass());
    }
    
    return create(listenerMethod, target, targetMethod);
###
1665, JNLPClipboard, JNLPClipboard, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/JNLPClipboard.java, 49, 50
7
/**
   * Creates a new proxy for the specified target object.
   * The target object must have a getContent and a setContent method
   * as specified by the {@code javax.jnlp.ClipboardService} interface.
   *
   * @param target A Clipboard object.
   */
2
  public JNLPClipboard(Object target) {
    this.target = target;
###
1666, NetPanel, NetPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetPanel.java, 50, 115
1
/** Creates new instance. */
66
  public NetPanel() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    undoManager = new UndoRedoManager();
    editor = new DefaultDrawingEditor();
    editor.add(view);
    
    addCreationButtonsTo(creationToolbar, editor);
    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);
    
    JPopupButton pb = new JPopupButton();
    pb.setItemFont(UIManager.getFont("MenuItem.font"));
    labels.configureToolBarButton(pb, "actions");
    pb.add(new DuplicateAction());
    pb.addSeparator();
    pb.add(new GroupAction(editor));
    pb.add(new UngroupAction(editor));
    pb.addSeparator();
    pb.add(new BringToFrontAction(editor));
    pb.add(new SendToBackAction(editor));
    pb.addSeparator();
    pb.add(new CutAction());
    pb.add(new CopyAction());
    pb.add(new PasteAction());
    pb.add(new SelectAllAction());
    pb.add(new SelectSameAction(editor));
    pb.addSeparator();
    pb.add(undoManager.getUndoAction());
    pb.add(undoManager.getRedoAction());
     // FIXME - We need a toggle grid action
     // pb.addSeparator();
     // pb.add(new ToggleGridAction(editor));
    
    JMenu m = new JMenu(labels.getString("view.zoomFactor.text"));
    JRadioButtonMenuItem rbmi;
    ButtonGroup group = new ButtonGroup();
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));
    rbmi.setSelected(true);
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));
    group.add(rbmi);
    pb.add(m);
    pb.setFocusable(false);
    creationToolbar.addSeparator();
    creationToolbar.add(pb);
    
    
    DefaultDrawing drawing = new DefaultDrawing();
    view.setDrawing(drawing);
    drawing.addUndoableEditListener(undoManager);
###
1667, initComponents, NetPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetPanel.java, 140, 174
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
27
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    toolButtonGroup = new javax.swing.ButtonGroup();
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    jPanel1 = new javax.swing.JPanel();
    creationToolbar = new javax.swing.JToolBar();
    attributesToolbar = new javax.swing.JToolBar();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    jPanel1.setLayout(new java.awt.GridBagLayout());
    creationToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(creationToolbar, gridBagConstraints);
    attributesToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(attributesToolbar, gridBagConstraints);
    add(jPanel1, java.awt.BorderLayout.SOUTH);
###
1670, createToolBars, NetApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplicationModel.java, 130, 156
5
/**
   * Creates toolbars for the application.
   * This class always returns an empty list. Subclasses may return other
   * values.
   */
25
  public java.util.List<JToolBar> createToolBars(Application a, View pr) {
    ResourceBundleUtil drawLabels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.net.Labels");
    NetView p = (NetView) pr;
    DrawingEditor editor;
    if (p == null) {
      editor = getSharedEditor();
    } else {
      editor = p.getDrawingEditor();
    }
    LinkedList<JToolBar> list = new LinkedList<JToolBar>();
    JToolBar tb;
    tb = new JToolBar();
    addCreationButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.drawToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    ButtonFactory.addAttributesButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.attributesToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    ButtonFactory.addAlignmentButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.alignmentToolBar.title"));
    list.add(tb);
    return list;
###
1671, initDrawing, NetApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java, 170, 183
3
/**
   * Configure Drawing object to support copy and paste.
   */
11
  @SuppressWarnings("unchecked")
  private void initDrawing(Drawing d) {
    d.setInputFormats((java.util.List<InputFormat>) Collections.EMPTY_LIST);
    d.setOutputFormats((java.util.List<OutputFormat>) Collections.EMPTY_LIST);
    DOMStorableInputOutputFormat ioFormat = new DOMStorableInputOutputFormat(
        new NetFactory());
    d.addInputFormat(ioFormat);
    d.addInputFormat(new ImageInputFormat(new ImageFigure()));
    d.addInputFormat(new TextInputFormat(new TextFigure()));
    d.addOutputFormat(ioFormat);
    d.addOutputFormat(new ImageOutputFormat());
###
1673, getParameter, NetApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java, 55, 59
4
/**
   * We override getParameter() to make it work even if we have no Applet
   * context.
   */
5
  public String getParameter(String name) {
    try {
      return super.getParameter(name);
    } catch (NullPointerException e) {
      return null;
###
1674, init, NetApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java, 70, 156
3
/**
   * Initializes the applet NetApplet
   */
78
  public void init() {
    // Set look and feel
    // -----------------
    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Throwable e) {
      // Do nothing.
      // If we can't set the desired look and feel, UIManager does
      // automaticaly the right thing for us.
    }
    // Set our own popup factory, because the one that comes with Mac OS X
    // creates translucent popups which is not useful for color selection
    // using pop menus.
    try {
      PopupFactory.setSharedInstance(new PopupFactory());
    } catch (Throwable e) {
      // If we can't set the popup factory, we have to use what is there.
    }

    // Display copyright info while we are loading the data
    // ----------------------------------------------------
    Container c = getContentPane();
    c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));
    String[] labels = getAppletInfo().split("\n");//Strings.split(getAppletInfo(), '\n');
    for (int i = 0; i < labels.length; i++) {
      c.add(new JLabel((labels[i].length() == 0) ? " " : labels[i]));
    }
    // We load the data using a worker thread
    // --------------------------------------
    new Worker<Drawing>() {
      protected Drawing construct() throws IOException {
        Drawing result;
        System.out.println("getParameter.datafile:" + getParameter("datafile"));
        if (getParameter("data") != null) {
          NanoXMLDOMInput domi = new NanoXMLDOMInput(new NetFactory(), new StringReader(getParameter("data")));
          result = (Drawing) domi.readObject(0);
        } else if (getParameter("datafile") != null) {
          URL url = new URL(getDocumentBase(), getParameter("datafile"));
          InputStream in = url.openConnection().getInputStream();
          try {
            NanoXMLDOMInput domi = new NanoXMLDOMInput(new NetFactory(), in);
            result = (Drawing) domi.readObject(0);
          } finally {
            in.close();
          }
        } else {
          result = null;
        }
        return result;
      }
      @Override
      protected void done(Drawing result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        c.add(drawingPanel = new NetPanel());
        if (result != null) {
          Drawing drawing = (Drawing) result;
          setDrawing(drawing);
        }
      }
      @Override
      protected void failed(Throwable value) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        c.add(drawingPanel = new NetPanel());
        value.printStackTrace();
        getDrawing().add(new TextFigure(value.toString()));
        value.printStackTrace();
      }
      @Override
      protected void finished() {
        Container c = getContentPane();
        initDrawing(getDrawing());
        c.validate();
      }
    }.start();
###
1675, initComponents, NetApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java, 247, 248
5
/** This method is called from within the init() method to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
2
  private void initComponents() {
    toolButtonGroup = new javax.swing.ButtonGroup();
###
1676, getOpenChooser, SVGDrawingPanelSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java, 203, 228
4
/** Lazily creates a JFileChooser and returns it. */
 --------------
/** Opens a drawing from a file. */
 --------------
25
  private JFileChooser getOpenChooser() {
    if (openChooser == null) {
      openChooser = new JFileChooser();
      Drawing d = svgPanel.getDrawing();
      fileFilterInputFormatMap = new HashMap<javax.swing.filechooser.FileFilter, InputFormat>();
      javax.swing.filechooser.FileFilter firstFF = null;
      for (InputFormat format : d.getInputFormats()) {
        javax.swing.filechooser.FileFilter ff = format.getFileFilter();
        if (firstFF == null) {
          firstFF = ff;
        }
        fileFilterInputFormatMap.put(ff, format);
        openChooser.addChoosableFileFilter(ff);
      }
      openChooser.setFileFilter(firstFF);
      openChooser.addPropertyChangeListener(new PropertyChangeListener() {
        public void propertyChange(PropertyChangeEvent evt) {
          if (evt.getPropertyName().equals("fileFilterChanged")) {
            InputFormat inputFormat = fileFilterInputFormatMap.get(evt.getNewValue());
            openChooser.setAccessory((inputFormat == null) ? null : inputFormat.getInputFormatAccessory());
          }
        }
      });
    }
    return openChooser;
###
1677, getSaveChooser, SVGDrawingPanelSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java, 232, 257
4
/** Lazily creates a JFileChooser and returns it. */
 --------------
//GEN-LAST:event_open
 --------------
25
  private JFileChooser getSaveChooser() {
    if (saveChooser == null) {
      saveChooser = new JFileChooser();
      Drawing d = svgPanel.getDrawing();
      fileFilterOutputFormatMap = new HashMap<javax.swing.filechooser.FileFilter, OutputFormat>();
      javax.swing.filechooser.FileFilter firstFF = null;
      for (OutputFormat format : d.getOutputFormats()) {
        javax.swing.filechooser.FileFilter ff = format.getFileFilter();
        if (firstFF == null) {
          firstFF = ff;
        }
        fileFilterOutputFormatMap.put(ff, format);
        saveChooser.addChoosableFileFilter(ff);
      }
      saveChooser.setFileFilter(firstFF);
      saveChooser.addPropertyChangeListener(new PropertyChangeListener() {
        public void propertyChange(PropertyChangeEvent evt) {
          if (evt.getPropertyName().equals("fileFilterChanged")) {
            OutputFormat outputFormat = fileFilterOutputFormatMap.get(evt.getNewValue());
            saveChooser.setAccessory((outputFormat == null) ? null : outputFormat.getOutputFormatAccessory());
          }
        }
      });
    }
    return saveChooser;
###
1679, main, SVGDrawingPanelSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java, 263, 267
6
/**
   * @param args the command line arguments
   */
 --------------
/** Saves a drawing to a file. */
 --------------
4
  public static void main(String args[]) {
    java.awt.EventQueue.invokeLater(new Runnable() {
      public void run() {
        new SVGDrawingPanelSample().setVisible(true);
###
1680, SVGDrawingPanelSample, SVGDrawingPanelSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java, 59, 61
1
/** Creates new form SVGDrawingPanelSample */
3
  public SVGDrawingPanelSample() {
    initComponents();
    setSize(new Dimension(600, 400));
###
1682, initComponents, SVGDrawingPanelSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java, 69, 98
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
21
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    svgPanel = new org.jhotdraw.samples.svg.SVGDrawingPanel();
    menuBar = new javax.swing.JMenuBar();
    fileMenu = new javax.swing.JMenu();
    openMenuItem = new javax.swing.JMenuItem();
    saveAsMenuItem = new javax.swing.JMenuItem();
    FormListener formListener = new FormListener();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    getContentPane().add(svgPanel, java.awt.BorderLayout.CENTER);
    fileMenu.setText("File");
    openMenuItem.setText("Open...");
    openMenuItem.addActionListener(formListener);
    fileMenu.add(openMenuItem);
    saveAsMenuItem.setText("Save As...");
    saveAsMenuItem.addActionListener(formListener);
    fileMenu.add(saveAsMenuItem);
    menuBar.add(fileMenu);
    setJMenuBar(menuBar);
    pack();
###
1683, main, Main, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/Main.java, 27, 47
1
/** Creates a new instance. */
21
  public static void main(String[] args) {
    Application app;
    String os = System.getProperty("os.name").toLowerCase();
    if (os.startsWith("mac")) {
      app = new OSXApplication();
    } else if (os.startsWith("win")) {
      //  app = new DefaultMDIApplication();
      app = new SDIApplication();
    } else {
      app = new SDIApplication();
    }
    
    
    DefaultApplicationModel model = new NetApplicationModel();
    model.setName("JHotDraw Net");
    model.setVersion(Main.class.getPackage().getImplementationVersion());
    model.setCopyright("Copyright 2006-2009 (c) by the authors of JHotDraw and all its contributors.\n" +
        "This software is licensed under LGPL and Creative Commons 3.0 Attribution.");
    model.setViewClassName("org.jhotdraw.samples.net.NetView");
    app.setModel(model);
    app.launch(args);
###
1684, main, QuickAndDirtyDOMStorableSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/QuickAndDirtyDOMStorableSample.java, 62, 85
1
/** DOM Storable objects must have a non-argument constructor. */
19
  public static void main(String[] args) {
    try {
      // Create a DOMStorable object
      MyObject obj = new MyObject("Hello World");
      System.out.println("The name of the original object is:" + obj.getName());
      // Write the object into a DOM, and then serialize the DOM into a String
      NanoXMLDOMOutput out = new NanoXMLDOMOutput(new QuickAndDirtyDOMFactory());
      out.writeObject(obj);
      StringWriter writer = new StringWriter();
      out.save(writer);
      String serializedString = writer.toString();
      System.out.println("\nThe serialized representation of the object is:\n" + serializedString);
      // Deserialize a DOM from a String, and then read the object from the DOM
      StringReader reader = new StringReader(serializedString);
      NanoXMLDOMInput in = new NanoXMLDOMInput(new QuickAndDirtyDOMFactory(), reader);
      MyObject obj2 = (MyObject) in.readObject();
      System.out.println("\nThe name of the restored object is:" + obj2.getName());
    } catch (IOException ex) {
      Logger.getLogger(QuickAndDirtyDOMStorableSample.class.getName()).log(Level.SEVERE, null, ex);
###
1685, SelectionToolSample, SelectionToolSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SelectionToolSample.java, 57, 98
3
/**
   * Creates a new instance of SelectionToolSample
   */
36
    public SelectionToolSample() {
      LineFigure lf = new LineFigure();
      lf.setBounds(new Point2D.Double(40,40), new Point2D.Double(200,
40));
      // Add all figures to a drawing 
      Drawing drawing = new DefaultDrawing(); 
      drawing.add(lf);
      // Show the drawing 
      JFrame f = new JFrame("UltraMini"); 
      f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
      f.setSize(600,300); 
      DrawingView view = new DefaultDrawingView(); 
      view.setDrawing(drawing);
      f.getContentPane().add(view.getComponent()); 
      // set up the drawing editor
      DrawingEditor editor = new DefaultDrawingEditor();
      editor.add(view);
      
      
      // Activate the following line to see the SelectionTool in full
      // action.
      editor.setTool(new SelectionTool());
      // Activate the following line to only see the SelectAreaTracker in 
      // action.
      //editor.setTool(new SelectAreaTracker());
      
      // Activate the following line to only see the DragTracker in 
      // action.
      //editor.setTool(new DragTracker(lf));
      
      // Activate the following lines to only see the HandleTracker in 
      // action.
      //view.selectAll();
      //editor.setTool(new HandleTracker(view.findHandle(view.drawingToView(lf.getStartPoint()))));
      
      f.show(); 
###
1686, getChooser, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 85, 86
3
/**
   * Returns the URIChooser pane on the sheet.
   */
2
  public URIChooser getChooser() {
    return (URIChooser) pane;
###
1687, getOption, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 97, 98
3
/**
   * Returns the option that the JFileChooser or JOptionPane returned.
   */
2
  public int getOption() {
    return option;
###
1688, SheetEvent, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 61, 66
3
/**
   * Creates a new instance.
   */
6
  public SheetEvent(JSheet source, JOptionPane optionPane, int option, Object value, Object inputValue) {
    super(source);
    this.pane = optionPane;
    this.option = option;
    this.value = value;
    this.inputValue = inputValue;
###
1689, SheetEvent, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 52, 56
3
/**
   * Creates a new instance.
   */
5
  public SheetEvent(JSheet source, URIChooser chooser, int option, Object value) {
    super(source);
    this.pane = chooser;
    this.option = option;
    this.value = value;
###
1690, getPane, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 73, 74
4
/**
   * Returns the pane on the sheet. This is either a JFileChooser, a URIChooser or a
   * JOptionPane.
   */
2
  public Object getPane() {
    return pane;
###
1691, getFileChooser, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 79, 80
3
/**
   * Returns the JFileChooser pane on the sheet.
   */
2
  public JFileChooser getFileChooser() {
    return (JFileChooser) pane;
###
1692, SheetEvent, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 37, 38
3
/**
   * Creates a new instance.
   */
2
  public SheetEvent(JSheet source) {
    super(source);
###
1693, SheetEvent, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 43, 47
3
/**
   * Creates a new instance.
   */
5
  public SheetEvent(JSheet source, JFileChooser fileChooser, int option, Object value) {
    super(source);
    this.pane = fileChooser;
    this.option = option;
    this.value = value;
###
1694, getValue, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 103, 104
3
/**
   * Returns the value that the JFileChooser or JOptionPane returned.
   */
2
  public Object getValue() {
    return value;
###
1695, getOptionPane, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 91, 92
3
/**
   * Returns the JOptionPane pane on the sheet.
   */
2
  public JOptionPane getOptionPane() {
    return (JOptionPane) pane;
###
1696, setFonts, DefaultFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/DefaultFontChooserModel.java, 66, 509
7
/**
   * Sets the fonts of the DefaultFontChooserModel.
   * <p>
   * Fires treeStructureChanged event on the root node.
   * 
   * @param fonts
   */
434
  @SuppressWarnings("unchecked")
  public void setFonts(Font[] fonts) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.gui.Labels");
    // collect families and sort them alphabetically
    ArrayList<FontFamilyNode> families = new ArrayList<FontFamilyNode>();
    HashMap<String, FontFamilyNode> familyMap = new HashMap<String, FontFamilyNode>();
    for (Font f : fonts) {
      String familyName = f.getFamily();
      FontFamilyNode family;
      if (familyMap.containsKey(familyName)) {
        family = familyMap.get(familyName);
      } else {
        family = new FontFamilyNode(familyName);
        familyMap.put(familyName, family);
      }
      family.add(new FontFaceNode(f));
    }
    families.addAll(familyMap.values());
    Collections.sort(families);
    // group families into collections
    root.removeAllChildren();
    root.add(new FontCollectionNode(labels.getString("FontCollection.allFonts"), (ArrayList<FontFamilyNode>) families.clone()));
    // Web-save fonts
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.web"), collectFamiliesNamed(families,
        "Arial",
        "Arial Black",
        "Comic Sans MS",
        "Georgia",
        "Impact",
        "Times New Roman",
        "Trebuchet MS",
        "Verdana",
        "Webdings")));
    /*
    // PDF Fonts
    root.add(
    new FontCollectionNode(labels.getString("FontCollection.pdf"), collectFamiliesNamed(families,
    "Andale Mono",
    "Courier",
    "Helvetica",
    "Symbol",
    "Times",
    "Zapf Dingbats")));
     */
    // Java System fonts
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.system"), collectFamiliesNamed(families,
        "Dialog",
        "DialogInput",
        "Monospaced",
        "SansSerif",
        "Serif")));
    // Serif fonts
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.serif"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Adobe Caslon Pro",
        "Adobe Garamond Pro",
        "American Typewriter",
        "Arno Pro",
        "Baskerville",
        "Baskerville Old Face",
        "Bell MT",
        "Big Caslon",
        "Bodoni SvtyTwo ITC TT",
        "Bodoni SvtyTwo OS ITC TT",
        "Bodoni SvtyTwo SC ITC TT",
        "Book Antiqua",
        "Bookman Old Style",
        "Calisto MT",
        "Chaparral Pro",
        "Century",
        "Century Schoolbook",
        "Cochin",
        "Footlight MT Light",
        "Garamond",
        "Garamond Premier Pro",
        "Georgia",
        "Goudy Old Style",
        "Hoefler Text",
        "Lucida Bright",
        "Lucida Fax",
        "Minion Pro",
        "Palatino",
        "Times",
        "Times New Roman",
        // Fonts on Windows XP:
        "Palatino Linotype",
        "Bitstream Vera Serif Bold",
        "Bodoni MT",
        "Bodoni MT Black",
        "Bodoni MT Condensed",
        "Californian FB",
        "Cambria",
        "Cambria Math",
        "Centaur",
        "Constantia",
        "High Tower Text",
        "Perpetua",
        "Poor Richard",
        "Rockwell Condensed",
        "Slimbach-Black",
        "Slimbach-BlackItalic",
        "Slimbach-Bold",
        "Slimbach-BoldItalic",
        "Slimbach-Book",
        "Slimbach-BookItalic",
        "Slimbach-Medium",
        "Slimbach-MediumItalic",
        "Sylfaen",
        // Fonts on Windows Vista
        "Andalus",
        "Angsana New",
        "AngsanaUPC",
        "Arabic Typesetting",
        "Cambria",
        "Cambria Math",
        "Constantia",
        "DaunPenh",
        "David",
        "DilleniaUPC",
        "EucrosiaUPC",
        "Frank Ruehl",
        "IrisUPC",
        "Iskoola Pota",
        "JasmineUPC",
        "KodchiangUPC",
        "Narkisim")));
    // Sans Serif
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.sansSerif"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Abadi MT Condensed Extra Bold",
        "Abadi MT Condensed Light",
        "Al Bayan",
        "AppleGothic",
        "Arial",
        "Arial Black",
        "Arial Narrow",
        "Arial Rounded MT Bold",
        "Arial Unicode MS",
        "Bell Gothic Std",
        "Blair MdITC TT",
        "Century Gothic",
        "Frutiger",
        "Futura",
        "Geneva",
        "Gill Sans",
        "Gulim",
        "Helvetica",
        "Helvetica Neue",
        "Lucida Grande",
        "Lucida Sans",
        "Microsoft Sans Serif",
        "Myriad Pro",
        "News Gothic",
        "Tahoma",
        "Trebuchet MS",
        "Verdana",
        // Fonts on Windows XP:
        "Franklin Gothic Medium",
        "Lucida Sans Unicode",
        "Agency FB",
        "Berlin Sans FB",
        "Berlin Sans FB Demi Bold",
        "Bitstream Vera Sans Bold",
        "Calibri",
        "Candara",
        "Corbel",
        "Estrangelo Edessa",
        "Eras Bold ITC",
        "Eras Demi ITC",
        "Eras Light ITC",
        "Eras Medium ITC",
        "Franklin Gothic Book",
        "Franklin Gothic Demi",
        "Franklin Gothic Demi Cond",
        "Franklin Gothic Heavy",
        "Franklin Gothic Medium Cond",
        "Gill Sans MT",
        "Gill Sans MT Condensed",
        "Gill Sans MT Ext Condensed Bold",
        "Maiandra GD",
        "MS Reference Sans...",
        "Tw Cen MT",
        "Tw Cen MT Condensed",
        "Tw Cen MT Condensed Extra Bold",
        // Fonts on Windows Vista:
        "Aharoni",
        "Browallia New",
        "BrowalliaUPC",
        "Calibri",
        "Candara",
        "Corbel",
        "Cordia New",
        "CordiaUPC",
        "DokChampa",
        "Dotum",
        "Estrangelo Edessa",
        "Euphemia",
        "Freesia UPC",
        "Gautami",
        "Gisha",
        "Kalinga",
        "Kartika",
        "Levenim MT",
        "LilyUPC",
        "Malgun Gothic",
        "Meiryo",
        "Miriam",
        "Segoe UI")));
    // Scripts 
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.script"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Apple Chancery",
        "Bickham Script Pro",
        "Blackmoor LET",
        "Bradley Hand ITC TT",
        "Brush Script MT",
        "Brush Script Std",
        "Chalkboard",
        "Charlemagne Std",
        "Comic Sans MS",
        "Curlz MT",
        "Edwardian Script ITC",
        "Footlight MT Light",
        "Giddyup Std",
        "Handwriting - Dakota",
        "Harrington",
        "Herculanum",
        "Kokonor",
        "Lithos Pro",
        "Lucida Blackletter",
        "Lucida Calligraphy",
        "Lucida Handwriting",
        "Marker Felt",
        "Matura MT Script Capitals",
        "Mistral",
        "Monotype Corsiva",
        "Party LET",
        "Papyrus",
        "Santa Fe LET",
        "Savoye LET",
        "SchoolHouse Cursive B",
        "SchoolHouse Printed A",
        "Skia",
        "Snell Roundhand",
        "Tekton Pro",
        "Trajan Pro",
        "Zapfino",
        // Fonts on Windows XP
        "Blackadder ITC",
        "Bradley Hand ITC",
        "Chiller",
        "Freestyle Script",
        "French Script MT",
        "Gigi",
        "Harlow Solid Italic",
        "Informal Roman",
        "Juice ITC",
        "Kristen ITC",
        "Kunstler Script",
        "Magneto Bold",
        "Maiandra GD",
        "Old English Text",
        "Palace Script MT",
        "Parchment",
        "Pristina",
        "Rage Italic",
        "Ravie",
        "Script MT Bold",
        "Tempus Sans ITC",
        "Viner Hand ITC",
        "Vivaldi Italic",
        "Vladimir Script",
        // Fonts on Windows Vista
        "Segoe Print",
        "Segoe Script")));
    
    // Monospaced
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.monospaced"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Andale Mono",
        "Courier",
        "Courier New",
        "Letter Gothic Std",
        "Lucida Sans Typewriter",
        "Monaco",
        "OCR A Std",
        "Orator Std",
        "Prestige Elite Std",
        // Fonts on Windows XP:
        "Lucida Console",
        "Bitstream Vera S...",
        "Consolas",
        "OCR A Extended",
        "OCR B",
        // Fonts on Windows Vista
        "Consolas",
        "DotumChe",
        "Miriam Fixed",
        "Rod")));
    
    // Decorative
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.decorative"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Academy Engraved LET",
        "Arial Black",
        "Bank Gothic",
        "Bauhaus 93",
        "Bernard MT Condensed",
        "Birch Std",
        "Blackoak Std",
        "BlairMdITC TT",
        "Bordeaux Roman Bold LET",
        "Braggadocio",
        "Britannic Bold",
        "Capitals",
        "Colonna MT",
        "Cooper Black",
        "Cooper Std",
        "Copperplate",
        "Copperplate Gothic Bold",
        "Copperplate Gothic Light",
        "Cracked",
        "Desdemona",
        "Didot",
        "Eccentric Std",
        "Engravers MT",
        "Eurostile",
        "Gill Sans Ultra Bold",
        "Gloucester MT Extra Condensed",
        "Haettenschweiler",
        "Hobo Std",
        "Impact",
        "Imprint MT Shadow",
        "Jazz LET",
        "Kino MT",
        "Matura MT Script Capitals",
        "Mesquite Std",
        "Modern No. 20",
        "Mona Lisa Solid ITC TT",
        "MS Gothic",
        "Nueva Std",
        "Onyx",
        "Optima",
        "Perpetua Titling MT",
        "Playbill",
        "Poplar Std",
        "PortagoITC TT",
        "Princetown LET",
        "Rockwell",
        "Rockwell Extra Bold",
        "Rosewood Std",
        "Santa Fe LET",
        "Stencil",
        "Stencil Std",
        "Stone Sans ITC TT",
        "Stone Sans OS ITC TT",
        "Stone Sans Sem ITC TT",
        "Stone Sans Sem OS ITCTT",
        "Stone Sans Sem OS ITC TT",
        "Synchro LET",
        "Wide Latin",
        // Fonts on Windows XP
        "Algerian",
        "Bodoni MT Black",
        "Bodoni MT Poster Compressed",
        "Broadway",
        "Castellar",
        "Elephant",
        "Felix Titling",
        "Franklin Gothic Heavy",
        "Gill Sans MT Ext Condensed Bold",
        "Gill Sans Ultra Bold Condensed",
        "Goudy Stout",
        "Jokerman",
        "Juice ITC",
        "Magneto",
        "Magneto Bold",
        "Niagara Engraved",
        "Niagara Solid",
        "Poor Richard",
        "Ravie",
        "Rockwell Condensed",
        "Showcard Gothic",
        "Slimbach-Black",
        "Slimbach-BlackItalic",
        "Snap ITC"
        // Fonts on Windows Vista:
        )));
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.symbols"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Apple Symbols",
        "Blackoack Std",
        "Bodoni Ornaments ITC TT",
        "EuropeanPi",
        "Monotype Sorts",
        "MT Extra",
        "Symbol",
        "Type Embellishments One LET",
        "Webdings",
        "Wingdings",
        "Wingdings 2",
        "Wingdings 3",
        "Zapf Dingbats",
        // Fonts on Windows XP
        "Bookshelf Symbol"
        // Fonts on Windows Vista
        )));
    // Collect font families, which are not in one of the other collections
    // (except the collection AllFonts).
    FontCollectionNode others = new FontCollectionNode(labels.getString("FontCollection.other"));
    HashSet<FontFamilyNode> otherFamilySet = new HashSet<FontFamilyNode>();
    otherFamilySet.addAll(families);
    for (int i = 1, n = root.getChildCount(); i < n; i++) {
      FontCollectionNode fcn = (FontCollectionNode) root.getChildAt(i);
      for (FontFamilyNode ffn : fcn.families()) {
        otherFamilySet.remove(ffn);
      }
    }
    ArrayList<FontFamilyNode> otherFamilies = new ArrayList<FontFamilyNode>();
    for (FontFamilyNode ffn : otherFamilySet) {
      otherFamilies.add(ffn.clone());
    }
    Collections.sort(otherFamilies);
    others.addAll(otherFamilies);
    root.add(others);
    fireTreeStructureChanged(this, new TreePath(root));
###
1697, fireTreeNodesChanged, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 85, 99
12
/**
   * Notifies all listeners that have registered interest for
   * notification on this event type.  The event instance 
   * is lazily created using the parameters passed into 
   * the fire method.
   *
   * @param source the node being changed
   * @param path the path to the root node
   * @param childIndices the indices of the changed elements
   * @param children the changed elements
   * @see EventListenerList
   */
15
  protected void fireTreeNodesChanged(Object source, Object[] path, 
                    int[] childIndices, 
                    Object[] children) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    TreeModelEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==TreeModelListener.class) {
        // Lazily create the event:
        if (e == null)
          e = new TreeModelEvent(source, path, 
                       childIndices, children);
        ((TreeModelListener)listeners[i+1]).treeNodesChanged(e);
###
1698, fireTreeNodesRemoved, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 147, 161
12
/**
   * Notifies all listeners that have registered interest for
   * notification on this event type.  The event instance 
   * is lazily created using the parameters passed into 
   * the fire method.
   *
   * @param source the node where elements are being removed
   * @param path the path to the root node
   * @param childIndices the indices of the removed elements
   * @param children the removed elements
   * @see EventListenerList
   */
15
  protected void fireTreeNodesRemoved(Object source, Object[] path, 
                    int[] childIndices, 
                    Object[] children) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    TreeModelEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==TreeModelListener.class) {
        // Lazily create the event:
        if (e == null)
          e = new TreeModelEvent(source, path, 
                       childIndices, children);
        ((TreeModelListener)listeners[i+1]).treeNodesRemoved(e);
###
1699, fireTreeNodesInserted, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 116, 130
12
/**
   * Notifies all listeners that have registered interest for
   * notification on this event type.  The event instance 
   * is lazily created using the parameters passed into 
   * the fire method.
   *
   * @param source the node where new elements are being inserted
   * @param path the path to the root node
   * @param childIndices the indices of the new elements
   * @param children the new elements
   * @see EventListenerList
   */
15
  protected void fireTreeNodesInserted(Object source, Object[] path, 
                    int[] childIndices, 
                    Object[] children) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    TreeModelEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==TreeModelListener.class) {
        // Lazily create the event:
        if (e == null)
          e = new TreeModelEvent(source, path, 
                       childIndices, children);
        ((TreeModelListener)listeners[i+1]).treeNodesInserted(e);
###
1700, fireTreeStructureChanged, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 178, 192
12
/**
   * Notifies all listeners that have registered interest for
   * notification on this event type.  The event instance 
   * is lazily created using the parameters passed into 
   * the fire method.
   *
   * @param source the node where the tree model has changed
   * @param path the path to the root node
   * @param childIndices the indices of the affected elements
   * @param children the affected elements
   * @see EventListenerList
   */
15
  protected void fireTreeStructureChanged(Object source, Object[] path, 
                    int[] childIndices, 
                    Object[] children) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    TreeModelEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==TreeModelListener.class) {
        // Lazily create the event:
        if (e == null)
          e = new TreeModelEvent(source, path, 
                       childIndices, children);
        ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);
###
1701, getTreeModelListeners, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 68, 70
13
/**
   * Returns an array of all the tree model listeners
   * registered on this model.
   *
   * @return all of this model's <code>TreeModelListener</code>s
   *   or an empty
   *   array if no tree model listeners are currently registered
   *
   * @see #addTreeModelListener
   * @see #removeTreeModelListener
   *
   * @since 1.4
   */
3
  public TreeModelListener[] getTreeModelListeners() {
    return (TreeModelListener[])listenerList.getListeners(
        TreeModelListener.class);
###
1702, removeTreeModelListener, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 51, 52
9
/**
   * Removes a listener previously added with <B>addTreeModelListener()</B>.
   *
   * @see   #addTreeModelListener
   * @param   l     the listener to remove
   */
 --------------
//  Events
 --------------
2
  public void removeTreeModelListener(TreeModelListener l) {
    listenerList.remove(TreeModelListener.class, l);
###
1703, addTreeModelListener, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 41, 42
6
/**
   * Adds a listener for the TreeModelEvent posted after the tree changes.
   *
   * @see   #removeTreeModelListener
   * @param   l   the listener to add
   */
2
  public void addTreeModelListener(TreeModelListener l) {
    listenerList.add(TreeModelListener.class, l);
###
1704, fireTreeStructureChanged, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 207, 218
10
/*
   * Notifies all listeners that have registered interest for
   * notification on this event type.  The event instance 
   * is lazily created using the parameters passed into 
   * the fire method.
   *
   * @param source the node where the tree model has changed
   * @param path the path to the root node
   * @see EventListenerList
   */
12
  protected void fireTreeStructureChanged(Object source, TreePath path) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    TreeModelEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==TreeModelListener.class) {
        // Lazily create the event:
        if (e == null)
          e = new TreeModelEvent(source, path);
        ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);
###
1705, PathTool, PathTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/PathTool.java, 46, 47
1
/** Creates a new instance. */
2
  public PathTool(SVGPathFigure pathPrototype, SVGBezierFigure bezierPrototype) {
    this(pathPrototype, bezierPrototype, null);
###
1706, TogglePropertiesPanelAction, TogglePropertiesPanelAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/action/TogglePropertiesPanelAction.java, 33, 37
1
/** Creates a new instance. */
5
  public TogglePropertiesPanelAction(Application app, View view) {
    super(app, view);
    setPropertyName("propertiesPanelVisible");
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.odg.Labels");
    putValue(AbstractAction.NAME, labels.getString("propertiesPanel"));
###
1708, getPropertyDescriptors, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 105, 106
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1710, getMethodDescriptors, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 127, 128
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1711, getDefaultEventIndex, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 150, 151
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1712, getEventSetDescriptors, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 116, 117
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1713, getDefaultPropertyIndex, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 139, 140
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1716, getBeanDescriptor, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 89, 90
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1717, initComponents, ODGPropertiesPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanel.java, 83, 113
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
25
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    linkLabel = new javax.swing.JLabel();
    linkField = new org.jhotdraw.gui.JAttributeTextField();
    opacityLabel = new javax.swing.JLabel();
    opacityField = new org.jhotdraw.gui.JAttributeTextField();
    opacityPopupButton = new org.jhotdraw.gui.JPopupButton();
    setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));
    setLayout(new java.awt.GridBagLayout());
    linkLabel.setLabelFor(linkField);
    linkLabel.setText(labels.getString("link")); // NOI18N
    add(linkLabel, new java.awt.GridBagConstraints());
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.weightx = 1.0;
    add(linkField, gridBagConstraints);
    opacityLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jhotdraw/draw/action/images/attributeOpacity.png"))); // NOI18N
    opacityLabel.setToolTipText(labels.getString("opacity")); // NOI18N
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
    add(opacityLabel, gridBagConstraints);
    opacityField.setColumns(3);
    add(opacityField, new java.awt.GridBagConstraints());
    opacityPopupButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jhotdraw/draw/action/images/popupIcon.png"))); // NOI18N
    add(opacityPopupButton, new java.awt.GridBagConstraints());
###
1718, ODGPropertiesPanel, ODGPropertiesPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanel.java, 42, 61
1
/** Creates new instance. */
19
  @SuppressWarnings("unchecked")
  public ODGPropertiesPanel() {
    initComponents();
    
    opacitySlider = new JAttributeSlider(JSlider.VERTICAL, 0, 100, 100);
    opacityPopupButton.add(opacitySlider);
    opacityPopupButton.putClientProperty("JButton.buttonType","toolbar");
    add(opacityPopupButton);
    opacityField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0d, 1d, 100d));
    opacityFieldHandler = new FigureAttributeEditorHandler<Double>(OPACITY, opacityField, editor);
    opacitySliderHandler = new FigureAttributeEditorHandler<Double>(OPACITY, opacitySlider, editor);
    linkFieldHandler = new FigureAttributeEditorHandler<String>(LINK, linkField, editor);
    
    // set fonts
    Font font = getFont().deriveFont(11f);
    for (Component c : getComponents()) {
      c.setFont(font);
    }
    opacitySlider.setFont(font);
###
1719, ODGBezierFigure, ODGBezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGBezierFigure.java, 40, 41
1
/** Creates a new instance. */
2
  public ODGBezierFigure() {
    this(false);
###
1720, write, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 185, 186
3
/**
   * Writes the view to the specified uri.
   */
2
  public void write(URI f, URIChooser fc) throws IOException {
    new SVGOutputFormat().write(new File(f), view.getDrawing());
###
1721, createDrawing, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 126, 141
3
/**
   * Creates a new Drawing for this view.
   */
16
  protected Drawing createDrawing() {
    Drawing drawing = new ODGDrawing();
    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();
    inputFormats.add(new ODGInputFormat());
    inputFormats.add(new ImageInputFormat(new SVGImageFigure()));
    inputFormats.add(new TextInputFormat(new SVGTextFigure()));
    drawing.setInputFormats(inputFormats);
    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();
    outputFormats.add(new SVGOutputFormat());
    outputFormats.add(new SVGZOutputFormat());
    outputFormats.add(new ImageOutputFormat());
    outputFormats.add(new ImageOutputFormat("JPG", "Joint Photographics Experts Group (JPEG)", "jpg", BufferedImage.TYPE_INT_RGB));
    outputFormats.add(new ImageOutputFormat("BMP", "Windows Bitmap (BMP)", "bmp", BufferedImage.TYPE_BYTE_INDEXED));
    outputFormats.add(new ImageMapOutputFormat());
    drawing.setOutputFormats(outputFormats);
    return drawing;
###
1722, clear, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 271, 286
3
/**
   * Clears the view.
   */
15
  public void clear() {
    final Drawing newDrawing = createDrawing();
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(newDrawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InvocationTargetException ex) {
      ex.printStackTrace();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
###
1723, read, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 192, 223
3
/**
   * Reads the view from the specified uri.
   */
28
  @SuppressWarnings("unchecked")
  @Override
  public void read(URI f, URIChooser fc) throws IOException {
    try {
      final Drawing drawing = createDrawing();
      HashMap<FileFilter, InputFormat> fileFilterInputFormatMap = (HashMap<FileFilter, InputFormat>)((JFileURIChooser) fc).getClientProperty("ffInputFormatMap");
      InputFormat sf = fileFilterInputFormatMap.get(((JFileURIChooser) fc).getFileFilter());
      if (sf == null) {
        sf = drawing.getInputFormats().get(0);
      }
      sf.read(new File(f), drawing, true);
      System.out.println("ODCView read(" + f + ") drawing.childCount=" + drawing.getChildCount());
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(drawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InterruptedException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
    } catch (InvocationTargetException e) {
      InternalError error = new InternalError();
      error.initCause(e);
      throw error;
###
1724, createPageable, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 147, 148
3
/**
   * Creates a Pageable object for printing the view.
   */
2
  public Pageable createPageable() {
    return new DrawingPageable(view.getDrawing());
###
1726, initComponents, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 302, 315
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
10
  private void initComponents() {
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    propertiesPanel = new org.jhotdraw.samples.odg.ODGPropertiesPanel();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    add(propertiesPanel, java.awt.BorderLayout.SOUTH);
###
1727, init, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 81, 120
3
/**
   * Initializes the view.
   */
33
  public void init() {
    super.init();
    initComponents();
    JPanel zoomButtonPanel = new JPanel(new BorderLayout());
    scrollPane.setLayout(new PlacardScrollPaneLayout());
    scrollPane.setBorder(new EmptyBorder(0, 0, 0, 0));
    setEditor(new DefaultDrawingEditor());
    undo = new UndoRedoManager();
    view.setDrawing(createDrawing());
    view.getDrawing().addUndoableEditListener(undo);
    initActions();
    undo.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        setHasUnsavedChanges(undo.hasSignificantEdits());
      }
    });
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    JPanel placardPanel = new JPanel(new BorderLayout());
    javax.swing.AbstractButton pButton;
    pButton = ButtonFactory.createZoomButton(view);
    pButton.putClientProperty("Quaqua.Button.style", "placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin", new Insets(0, 0, 0, 0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    placardPanel.add(pButton, BorderLayout.WEST);
    pButton = ButtonFactory.createToggleGridButton(view);
    pButton.putClientProperty("Quaqua.Button.style", "placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin", new Insets(0, 0, 0, 0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    labels.configureToolBarButton(pButton, "view.toggleGrid.placard");
    placardPanel.add(pButton, BorderLayout.EAST);
    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);
    propertiesPanel.setVisible(preferences.getBoolean("propertiesPanelVisible", false));
    propertiesPanel.setView(view);
###
1728, initActions, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 171, 173
3
/**
   * Initializes view specific actions.
   */
3
  private void initActions() {
    getActionMap().put(UndoAction.ID, undo.getUndoAction());
    getActionMap().put(RedoAction.ID, undo.getRedoAction());
###
1730, contains, ODGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGEllipseFigure.java, 118, 120
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
3
  public boolean contains(Point2D.Double p) {
    // XXX - This does not take the stroke width into account!
    return getTransformedShape().contains(p);
###
1731, ODGEllipseFigure, ODGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGEllipseFigure.java, 50, 51
1
/** Creates a new instance. */
2
  public ODGEllipseFigure() {
    this(0, 0, 0, 0);
###
1737, transform, ODGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGEllipseFigure.java, 146, 175
5
/**
   * Transforms the figure.
   *
   * @param tx the transformation.
   */
30
  public void transform(AffineTransform tx) {
    if (get(TRANSFORM) != null ||
        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {
      if (get(TRANSFORM) == null) {
        TRANSFORM.setClone(this, tx);
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM, t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
      if (get(FILL_GRADIENT) != null &&
          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT, g);
      }
      if (get(STROKE_GRADIENT) != null &&
          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT, g);
      }
    }
    invalidate();
###
1738, CombineAction, CombineAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/action/CombineAction.java, 34, 38
1
/** Creates a new instance. */
4
  public CombineAction(DrawingEditor editor) {
    super(editor, new ODGPathFigure());
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.odg.Labels");
    labels.configureAction(this, ID);
###
1739, createUI, PaletteFormattedTextFieldUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFormattedTextFieldUI.java, 39, 40
6
/**
   * Creates a UI for a JTextField.
   *
   * @param c the text field
   * @return the UI
   */
2
  public static ComponentUI createUI(JComponent c) {
    return new PaletteFormattedTextFieldUI();
###
1740, create, PaletteFormattedTextFieldUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFormattedTextFieldUI.java, 49, 147
6
/**
   * Creates a view (FieldView) based on an element.
   *
   * @param elem the element
   * @return the view
   */
94
  @Override
  public View create(Element elem) {
    /* We create our own view here. This view always uses the
     * text alignment that was specified by the text component. Even
     * then, when the text is longer than in the text component.
     *
     * Draws a wavy line if the value of the field is not valid.
     */
    return new FieldView(elem) {
      /**
       * Adjusts the allocation given to the view
       * to be a suitable allocation for a text field.
       * If the view has been allocated more than the
       * preferred span vertically, the allocation is
       * changed to be centered vertically.  Horizontally
       * the view is adjusted according to the horizontal
       * alignment property set on the associated JTextField
       * (if that is the type of the hosting component).
       *
       * @param a the allocation given to the view, which may need
       *  to be adjusted.
       * @return the allocation that the superclass should use.
       */
      protected Shape adjustAllocationXX(Shape a) {
        if (a != null) {
          Rectangle bounds = a.getBounds();
          int vspan = (int) getPreferredSpan(Y_AXIS);
          int hspan = (int) getPreferredSpan(X_AXIS);
          if (bounds.height != vspan) {
            int slop = bounds.height - vspan;
            bounds.y += slop / 2;
            bounds.height -= slop;
          }
          // horizontal adjustments
          Component c = getContainer();
          if (c instanceof JTextField) {
            JTextField field = (JTextField) c;
            BoundedRangeModel vis = field.getHorizontalVisibility();
            int max = Math.max(hspan, bounds.width);
            int value = vis.getValue();
            int extent = Math.min(max, bounds.width - 1);
            if ((value + extent) > max) {
              value = max - extent;
            }
            vis.setRangeProperties(value, extent, vis.getMinimum(),
                max, false);
            if (hspan < bounds.width) {
              // horizontally align the interior
              int slop = bounds.width - 1 - hspan;
              int align = ((JTextField) c).getHorizontalAlignment();
              if (true /*((JComponent) c).isLeftToRight()*/) {
                if (align == LEADING) {
                  align = LEFT;
                } else if (align == TRAILING) {
                  align = RIGHT;
                }
              } else {
                if (align == LEADING) {
                  align = RIGHT;
                } else if (align == TRAILING) {
                  align = LEFT;
                }
              }
              switch (align) {
                case SwingConstants.CENTER:
                  bounds.x += slop / 2;
                  bounds.width -= slop;
                  break;
                case SwingConstants.RIGHT:
                  bounds.x += slop;
                  bounds.width -= slop;
                  break;
              }
            } else {
              // adjust the allocation to match the bounded range.
              bounds.width = hspan;
              bounds.x -= vis.getValue();
            }
          }
          return bounds;
        }
        return null;
      }
      @Override
      public void paint(Graphics gr, Shape a) {
        Graphics2D g = (Graphics2D) gr;
        JFormattedTextField editor = (JFormattedTextField) getComponent();
        if (!editor.isEditValid()) {
          Rectangle r = (Rectangle) a;
          g.setColor(errorIndicatorForeground);
          g.setStroke(new BasicStroke(2.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{3f,3f},0.5f));
          g.draw(new Line2D.Float(r.x, r.y+r.height-0.5f, r.x+r.width-1,r.y+r.height-0.5f));
          }
          super.paint(g, a);
###
1742, PaletteFontChooserPreviewPanel, PaletteFontChooserPreviewPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserPreviewPanel.java, 28, 37
1
/** Creates new form PaletteFontChooserPreviewPanel */
10
  public PaletteFontChooserPreviewPanel() {
    initComponents();
    
    previewLabel.setUI((LabelUI) PaletteLabelUI.createUI(previewLabel));
    previewLabel.setBackground(Color.WHITE);
    previewLabel.setForeground(Color.BLACK);
    previewLabel.setOpaque(true);
    
    setPreferredSize(new Dimension(100,50));
    setMinimumSize(new Dimension(100,50));
###
1743, initComponents, PaletteFontChooserPreviewPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserPreviewPanel.java, 76, 85
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
7
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    previewLabel = new javax.swing.JLabel();
    setLayout(new java.awt.BorderLayout());
    previewLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    add(previewLabel, java.awt.BorderLayout.CENTER);
###
1744, installUI, PaletteFontChooserUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserUI.java, 95, 98
25
/**
   * Configures the specified component appropriate for the look and feel.
   * This method is invoked when the <code>ComponentUI</code> instance is being installed
   * as the UI delegate on the specified component.  This method should
   * completely configure the component for the look and feel,
   * including the following:
   * <ol>
   * <li>Install any default property values for color, fonts, borders,
   *   icons, opacity, etc. on the component.  Whenever possible, 
   *   property values initialized by the client program should <i>not</i> 
   *   be overridden.
   * <li>Install a <code>LayoutManager</code> on the component if necessary.
   * <li>Create/add any required sub-components to the component.
   * <li>Create/install event listeners on the component.
   * <li>Create/install a <code>PropertyChangeListener</code> on the component in order
   *   to detect and respond to component property changes appropriately.
   * <li>Install keyboard UI (mnemonics, traversal, etc.) on the component.
   * <li>Initialize any appropriate instance data.
   * </ol>
   * @param c the component where this UI delegate is being installed
   *
   * @see #uninstallUI
   * @see javax.swing.JComponent#setUI
   * @see javax.swing.JComponent#updateUI
   */
4
  @Override
  public void installUI(JComponent c) {
    installComponents(fontChooser);
    installListeners(fontChooser);
###
1745, createUI, PaletteFontChooserUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserUI.java, 65, 67
10
/**
   * Returns an instance of the UI delegate for the specified component.
   * Each subclass must provide its own static <code>createUI</code>
   * method that returns an instance of that UI delegate subclass.
   * If the UI delegate subclass is stateless, it may return an instance
   * that is shared by multiple components.  If the UI delegate is
   * stateful, then it should return a new instance per component.
   * The default implementation of this method throws an error, as it
   * should never be invoked.
   */
3
  public static ComponentUI createUI(JComponent c) {
    PaletteFontChooserUI ui = new PaletteFontChooserUI((JFontChooser) c);
    return ui;
###
1746, uninstallUI, PaletteFontChooserUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserUI.java, 160, 162
25
/**
   * Reverses configuration which was done on the specified component during
   * <code>installUI</code>.  This method is invoked when this 
   * <code>UIComponent</code> instance is being removed as the UI delegate 
   * for the specified component.  This method should undo the
   * configuration performed in <code>installUI</code>, being careful to 
   * leave the <code>JComponent</code> instance in a clean state (no 
   * extraneous listeners, look-and-feel-specific property objects, etc.).
   * This should include the following:
   * <ol>
   * <li>Remove any UI-set borders from the component.
   * <li>Remove any UI-set layout managers on the component.
   * <li>Remove any UI-added sub-components from the component.
   * <li>Remove any UI-added event/property listeners from the component.
   * <li>Remove any UI-installed keyboard UI from the component.
   * <li>Nullify any allocated instance data objects to allow for GC.
   * </ol>
   * @param c the component from which this UI delegate is being removed;
   *      this argument is often ignored,
   *      but might be used if the UI object is stateless
   *      and shared by multiple components
   *
   * @see #installUI
   * @see javax.swing.JComponent#updateUI
   */
3
  public void uninstallUI(JComponent c) {
    uninstallListeners(fontChooser);
    uninstallComponents(fontChooser);
###
1747, TextCreationTool, TextCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextCreationTool.java, 73, 74
1
/** Creates a new instance. */
2
  public TextCreationTool(TextHolderFigure prototype, Map<AttributeKey,Object> attributes) {
    super(prototype, attributes);
###
1748, TextCreationTool, TextCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextCreationTool.java, 69, 70
1
/** Creates a new instance. */
2
  public TextCreationTool(TextHolderFigure prototype) {
    super(prototype);
###
1749, mousePressed, TextCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextCreationTool.java, 85, 133
3
/**
   * Creates a new figure at the location where the mouse was pressed.
   */
46
  @Override
  public void mousePressed(MouseEvent e) {
    TextHolderFigure textHolder = null;
    // Note: The search sequence used here, must be
    // consistent with the search sequence used by the
    // HandleTracker, SelectAreaTracker, DelegationSelectionTool, SelectionTool.
    // If possible, continue to work with the current selection
    DrawingView v = getView();
    Point2D.Double p = v.viewToDrawing(e.getPoint());
    Figure pressedFigure = null;
    if (true /*isSelectBehindEnabled()*/) {
      for (Figure f : v.getSelectedFigures()) {
        if (f.contains(p)) {
          pressedFigure = f;
          break;
        }
      }
    }
    // If the point is not contained in the current selection,
    // search for a figure in the drawing.
    if (pressedFigure == null) {
      pressedFigure = getDrawing().findFigureInside(p);
    }
    if (pressedFigure instanceof TextHolderFigure) {
      textHolder = ((TextHolderFigure) pressedFigure).getLabelFor();
        textHolder = null;
    }
    if (textHolder != null) {
      beginEdit(textHolder);
      updateCursor(getView(), e.getPoint());
          return;
    }
    if (typingTarget != null) {
      endEdit();
      if (isToolDoneAfterCreation()) {
        fireToolDone();
      }
    } else {
      super.mousePressed(e);
      // update view so the created figure is drawn before the floating text
      // figure is overlaid. 
      textHolder = (TextHolderFigure)getCreatedFigure();
      getView().clearSelection();
      getView().addToSelection(textHolder);
      beginEdit(textHolder);
      updateCursor(getView(), e.getPoint());
###
1750, setRubberbandColor, TextAreaCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java, 106, 107
6
/**
   * Sets the rubberband color for the tool. Setting this to null, disables
   * the rubberband.
   *
   * @param c Rubberband color or null.
   */
2
  public void setRubberbandColor(Color c) {
    rubberbandColor = c;
###
1751, mousePressed, TextAreaCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java, 120, 164
4
/**
   * Creates a new figure at the mouse location.
   * If editing is in progress, this finishes editing.
   */
40
  @Override
  public void mousePressed(MouseEvent e) {
    TextHolderFigure textHolder = null;
    // Note: The search sequence used here, must be
    // consistent with the search sequence used by the
    // HandleTracker, SelectAreaTracker, DelegationSelectionTool, SelectionTool.
    // If possible, continue to work with the current selection
    DrawingView v = getView();
    Point2D.Double p = v.viewToDrawing(e.getPoint());
    Figure pressedFigure = null;
    if (true /*isSelectBehindEnabled()*/) {
      for (Figure f : v.getSelectedFigures()) {
        if (f.contains(p)) {
          pressedFigure = f;
          break;
        }
      }
    }
    // If the point is not contained in the current selection,
    // search for a figure in the drawing.
    if (pressedFigure == null) {
      pressedFigure = getDrawing().findFigureInside(p);
    }
    // 
    if (pressedFigure instanceof TextHolderFigure) {
      textHolder = (TextHolderFigure) pressedFigure;
        textHolder = null;
    }
    if (textHolder != null) {
      createdFigure = null;
      beginEdit(textHolder);
      return;
    }
    if (typingTarget != null) {
      endEdit();
      if (isToolDoneAfterCreation()) {
        fireToolDone();
      }
    } else {
      super.mousePressed(e);
###
1752, creationFinished, TextAreaCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java, 173, 177
5
/**
   * This method allows subclasses to do perform additonal user interactions
   * after the new figure has been created.
   * The implementation of this class just invokes fireToolDone.
   */
5
  @Override
  protected void creationFinished(Figure createdFigure) {
    getView().clearSelection();
    getView().addToSelection(createdFigure);
    beginEdit((TextHolderFigure) createdFigure);
###
1753, TextAreaCreationTool, TextAreaCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java, 92, 93
1
/** Creates a new instance. */
2
  public TextAreaCreationTool(TextHolderFigure prototype) {
    super(prototype);
###
1755, PaletteFontChooserSelectionPanel, PaletteFontChooserSelectionPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserSelectionPanel.java, 30, 41
1
/** Creates new form FontChooserPanel */
12
  public PaletteFontChooserSelectionPanel() {
     labels = ResourceBundleUtil.getBundle("org.jhotdraw.gui.Labels");
    initComponents();
    collectionList.setModel(new DefaultListModel());
    familyList.setModel(new DefaultListModel());
    faceList.setModel(new DefaultListModel());
    
    // Customiziation of Quaqua Look and Feel: Set small scroll bars
    Font smallSystemFont = new Font("Dialog", Font.PLAIN, 11);
    collectionsScrollPane.setFont(smallSystemFont);
    familiesScrollPane.setFont(smallSystemFont);
    facesScrollPane.setFont(smallSystemFont);
###
1756, initComponents, PaletteFontChooserSelectionPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserSelectionPanel.java, 59, 141
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
63
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    collectionsPanel = new javax.swing.JPanel();
    collectionsScrollPane = new javax.swing.JScrollPane();
    collectionList = new javax.swing.JList();
    collectionsLabel = new javax.swing.JLabel();
    familiesPanel = new javax.swing.JPanel();
    familiesScrollPane = new javax.swing.JScrollPane();
    familyList = new javax.swing.JList();
    familyLabel = new javax.swing.JLabel();
    facesPanel = new javax.swing.JPanel();
    facesScrollPane = new javax.swing.JScrollPane();
    faceList = new javax.swing.JList();
    faceLabel = new javax.swing.JLabel();
    setBorder(javax.swing.BorderFactory.createEmptyBorder(3, 3, 3, 3));
    setLayout(new java.awt.GridBagLayout());
    collectionsPanel.setPreferredSize(new java.awt.Dimension(80, 200));
    collectionsPanel.setLayout(new java.awt.BorderLayout());
    collectionsScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    collectionList.setFont(collectionList.getFont().deriveFont((float)11));
    collectionsScrollPane.setViewportView(collectionList);
    collectionsPanel.add(collectionsScrollPane, java.awt.BorderLayout.CENTER);
    collectionsLabel.setFont(collectionsLabel.getFont().deriveFont((float)11));
    collectionsLabel.setText(labels.getString("FontCollection.collections")); // NOI18N
    collectionsPanel.add(collectionsLabel, java.awt.BorderLayout.PAGE_START);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weightx = 0.3;
    gridBagConstraints.weighty = 1.0;
    add(collectionsPanel, gridBagConstraints);
    familiesPanel.setPreferredSize(new java.awt.Dimension(140, 200));
    familiesPanel.setLayout(new java.awt.BorderLayout());
    familiesScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    familyList.setFont(familyList.getFont().deriveFont((float)11));
    familiesScrollPane.setViewportView(familyList);
    familiesPanel.add(familiesScrollPane, java.awt.BorderLayout.CENTER);
    familyLabel.setFont(familyLabel.getFont().deriveFont((float)11));
    familyLabel.setText(labels.getString("FontCollection.family")); // NOI18N
    familiesPanel.add(familyLabel, java.awt.BorderLayout.PAGE_START);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weightx = 0.4;
    gridBagConstraints.weighty = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
    add(familiesPanel, gridBagConstraints);
    facesPanel.setPreferredSize(new java.awt.Dimension(80, 200));
    facesPanel.setLayout(new java.awt.BorderLayout());
    facesScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    facesScrollPane.setPreferredSize(new java.awt.Dimension(130, 240));
    faceList.setFont(faceList.getFont().deriveFont((float)11));
    facesScrollPane.setViewportView(faceList);
    facesPanel.add(facesScrollPane, java.awt.BorderLayout.CENTER);
    faceLabel.setFont(faceLabel.getFont().deriveFont((float)11));
    faceLabel.setText(labels.getString("FontCollection.typeface")); // NOI18N
    facesPanel.add(faceLabel, java.awt.BorderLayout.PAGE_START);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weightx = 0.3;
    gridBagConstraints.weighty = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
    add(facesPanel, gridBagConstraints);
###
1757, layoutCL, PaletteLabelUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteLabelUI.java, 137, 157
7
/**
   * Forwards the call to SwingUtilities.layoutCompoundLabel().
   * This method is here so that a subclass could do Label specific
   * layout and to shorten the method name a little.
   *
   * @see SwingUtilities#layoutCompoundLabel
   */
21
  protected String layoutCL(
      JLabel label,
      FontMetrics fontMetrics,
      String text,
      Icon icon,
      Rectangle viewR,
      Rectangle iconR,
      Rectangle textR) {
    return SwingUtilities.layoutCompoundLabel(
        (JComponent) label,
        fontMetrics,
        text,
        icon,
        label.getVerticalAlignment(),
        label.getHorizontalAlignment(),
        label.getVerticalTextPosition(),
        label.getHorizontalTextPosition(),
        viewR,
        iconR,
        textR,
        label.getIconTextGap());
###
1758, createUI, PaletteLabelUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteLabelUI.java, 49, 50
9
/**
   * Preferred spacing between labels and other components.
   * Pixels from colon and associated controls (RadioButton,
   * CheckBox)
   * /
   * private final static Insets associatedRegularSpacing = new Insets(8,8,8,8);
   * private final static Insets associatedSmallSpacing = new Insets(6,6,6,6);
   * private final static Insets associatedMiniSpacing = new Insets(5,5,5,5);
   */
2
  public static ComponentUI createUI(JComponent c) {
    return labelUI;
###
1759, paintDisabledText, PaletteLabelUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteLabelUI.java, 97, 104
6
/**
   * Paint label with disabled text color.
   *
   * @see #paint
   * @see #paintEnabledText
   */
6
  protected void paintDisabledText(JLabel l, Graphics g, String s, int textX, int textY) {
    Color c = UIManager.getColor("Label.disabledForeground");
    g.setColor((c != null) ? c : l.getForeground());
    int accChar = -1; //l.getDisplayedMnemonicIndex();
    PaletteUtilities.drawString(g, s, accChar,
        textX, textY);
###
1760, MultiIcon, MultiIcon, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/MultiIcon.java, 57, 59
6
/**
   * Creates a new instance from an array of icons.
   * All icons must have the same dimensions.
   * If an icon is null, an icon is derived for the state from the
   * other icons.
   */
3
  public MultiIcon(Icon[] icons) {
    this.icons = icons;
    generateMissingIcons();
###
1761, MultiIcon, MultiIcon, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/MultiIcon.java, 68, 75
6
/**
   * Creates a new instance from an array of images.
   * All icons must have the same dimensions.
   * If an icon is null, an icon is derived for the state from the
   * other icons.
   */
8
  public MultiIcon(Image[] images) {
    this.icons = new Icon[images.length];
    for (int i=0, n = icons.length; i < n; i++) {
      if (images[i] != null) {
        icons[i] = new ImageIcon(images[i]);
      }
    }
    generateMissingIcons();
###
1762, add, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 247, 248
10
/**
   * Convenience method for adding a control point with a single
   * coordinate C0.
   */
 --------------
/**
     * This mask is used to describe which control points in addition to
     * C0 are in effect.
     */
 --------------
2
  public void add(Point2D.Double c0) {
    add(new Node(0, c0, c0, c0));
###
1763, toGeneralPath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 311, 383
1
/** Converts the BezierPath into a Path2D.Double. */
70
  public Path2D.Double toGeneralPath() {
    Path2D.Double gp = new Path2D.Double();
    gp.setWindingRule(windingRule);
    if (size() == 0) {
      gp.moveTo(0, 0);
      gp.lineTo(0, 0 + 1);
    } else if (size() == 1) {
      Node current = get(0);
      gp.moveTo(current.x[0], current.y[0]);
      gp.lineTo(current.x[0], current.y[0] + 1);
    } else {
      Node previous;
      Node current;
      previous = current = get(0);
      gp.moveTo(current.x[0], current.y[0]);
      for (int i = 1, n = size(); i < n; i++) {
        previous = current;
        current = get(i);
        if ((previous.mask & C2_MASK) == 0) {
          if ((current.mask & C1_MASK) == 0) {
            gp.lineTo(
                current.x[0], current.y[0]);
          } else {
            gp.quadTo(
                current.x[1], current.y[1],
                current.x[0], current.y[0]);
          }
        } else {
          if ((current.mask & C1_MASK) == 0) {
            gp.quadTo(
                previous.x[2], previous.y[2],
                current.x[0], current.y[0]);
          } else {
            gp.curveTo(
                previous.x[2], previous.y[2],
                current.x[1], current.y[1],
                current.x[0], current.y[0]);
          }
        }
      }
      if (isClosed) {
        if (size() > 1) {
          previous = get(size() - 1);
          current = get(0);
          if ((previous.mask & C2_MASK) == 0) {
            if ((current.mask & C1_MASK) == 0) {
              gp.lineTo(
                  current.x[0], current.y[0]);
            } else {
              gp.quadTo(
                  current.x[1], current.y[1],
                  current.x[0], current.y[0]);
            }
          } else {
            if ((current.mask & C1_MASK) == 0) {
              gp.quadTo(
                  previous.x[2], previous.y[2],
                  current.x[0], current.y[0]);
            } else {
              gp.curveTo(
                  previous.x[2], previous.y[2],
                  current.x[1], current.y[1],
                  current.x[0], current.y[0]);
            }
          }
        }
        gp.closePath();
      }
    }
    return gp;
###
1764, toPolygonArray, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 1259, 1264
4
/**
   * Creates a polygon array of the bezier path.
   * @return Point array.
   */
6
  public Point2D.Double[] toPolygonArray() {
    Point2D.Double[] points = new Point2D.Double[size()];
    for (int i = 0, n = size(); i < n; i++) {
      points[i] = new Point2D.Double(get(i).x[0], get(i).y[0]);
    }
    return points;
###
1765, indexOfOutermostNode, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 790, 807
72
/**
   * Return the index of the control point that is furthest from the center
   **/
 --------------
/*
    Point2D.Double ctr = getCenter();
    // Chopped point
    double cx = -1;
    double cy = -1;
    double len = Double.MAX_VALUE;
    // Try for points along edge
    validatePath();
    PathIterator i = generalPath.getPathIterator(new AffineTransform(), 1);
    double[] coords = new double[6];
    int type = i.currentSegment(coords);
    double prevX = coords[0];
    double prevY = coords[1];
    i.next();
    for (; ! i.isDone(); i.next()) {
    i.currentSegment(coords);
    Point2D.Double chop = Geom.intersect(
    prevX, prevY,
    coords[0], coords[1],
    p.x, p.y,
    ctr.x, ctr.y
    );
    if (chop != null) {
    double cl = Geom.length2(chop.x, chop.y, p.x, p.y);
    if (cl < len) {
    len = cl;
    cx = chop.x;
    cy = chop.y;
    }
    }
    prevX = coords[0];
    prevY = coords[1];
    }
    //
    if (isClosed() && size() > 1) {
    Node first = get(0);
    Node last = get(size() - 1);
    Point2D.Double chop = Geom.intersect(
    first.x[0], first.y[0],
    last.x[0], last.y[0],
    p.x, p.y,
    ctr.x, ctr.y
    );
    if (chop != null) {
    double cl = Geom.length2(chop.x, chop.y, p.x, p.y);
    if (cl < len) {
    len = cl;
    cx = chop.x;
    cy = chop.y;
    }
    }
    }

    // if none found, pick closest vertex
    if (len == Double.MAX_VALUE) {
    for (int j = 0, n = size(); j < n; j++) {
    Node cp = get(j);
    double l = Geom.length2(cp.x[0], cp.y[0], p.x, p.y);
    if (l < len) {
    len = l;
    cx = cp.x[0];
    cy = cp.y[0];
    }
    }
    }
    return new Point2D.Double(cx, cy);
     */
 --------------
17
  public int indexOfOutermostNode() {
    if (outer == -1) {
      Point2D.Double ctr = getCenter();
      outer = 0;
      double dist = 0;
      for (int i = 0, n = size(); i < n; i++) {
        Node cp = get(i);
        double d = Geom.length2(ctr.x, ctr.y,
            cp.x[0],
            cp.y[0]);
        if (d > dist) {
          dist = d;
          outer = i;
        }
      }
    }
    return outer;
###
1766, get, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 285, 289
3
/**
   * Convenience method for getting a single coordinate of a control point.
   */
5
  public Point2D.Double get(int index, int coord) {
    Node c = get(index);
    return new Point2D.Double(
        c.x[coord],
        c.y[coord]);
###
1767, getLengthOfPath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 870, 884
5
/**
   * Returns the length of the path.
   *
   * @param flatness the flatness used to approximate the length.
   */
15
  public double getLengthOfPath(double flatness) {
    double len = 0;
    PathIterator i = generalPath.getPathIterator(new AffineTransform(), flatness);
    double[] coords = new double[6];
    int type = i.currentSegment(coords);
    double prevX = coords[0];
    double prevY = coords[1];
    i.next();
    for (; !i.isDone(); i.next()) {
      i.currentSegment(coords);
      len += Geom.length(prevX, prevY, coords[0], coords[1]);
      prevX = coords[0];
      prevY = coords[1];
    }
    return len;
###
1768, transform, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 663, 674
4
/**
   * Transforms the BezierPath.
   * @param tx the transformation.
   */
12
  public void transform(AffineTransform tx) {
    Point2D.Double p = new Point2D.Double();
    for (Node cp : this) {
      for (int i = 0; i < 3; i++) {
        p.x = cp.x[i];
        p.y = cp.y[i];
        tx.transform(p, p);
        cp.x[i] = p.x;
        cp.y[i] = p.y;
      }
    }
    invalidatePath();
###
1769, set, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 276, 279
9
/**
   * Convenience method for changing a single coordinate of a control point.
   */
 --------------
/** This is a hint for editing tools. If this is set to true,
     * the editing tools shall keep all control points on the same
     * line.
     */
 --------------
4
  public void set(int index, int coord, Point2D.Double p) {
    Node c = get(index);
    c.x[coord] = p.x;
    c.y[coord] = p.y;
###
1770, add, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 259, 260
7
/**
   * Convenience method for adding a control point with three
   * coordinates C0, C1 and C2 with a mask.
   */
 --------------
/** Control point x coordinates. */
 --------------
2
  public void add(int mask, Point2D.Double c0, Point2D.Double c1, Point2D.Double c2) {
    add(new Node(mask, c0, c1, c2));
###
1771, getRelativePositionOnPath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 895, 945
8
/**
   * Returns the relative position of the specified point on the path.
   *
   * @param flatness the flatness used to approximate the length.
   *
   * @return relative position on path, this is a number between 0 and 1.
   * Returns -1, if the point is not on the path.
   */
50
  public double getRelativePositionOnPath(Point2D.Double find, double flatness) {
    // XXX - This method works only for straight lines!
    double len = getLengthOfPath(flatness);
    double relativeLen = 0d;
    Node v1, v2;
    BezierPath tempPath = new BezierPath();
    Node t1, t2;
    tempPath.add(t1 = new Node());
    tempPath.add(t2 = new Node());
    for (int i = 0, n = size() - 1; i < n; i++) {
      v1 = get(i);
      v2 = get(i + 1);
      if (v1.mask == 0 && v2.mask == 0) {
        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, flatness)) {
          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
          return relativeLen / len;
        } else {
          relativeLen += Geom.length(v1.x[0], v1.y[0], v2.x[0], v2.y[0]);
        }
      } else {
        t1.setTo(v1);
        t2.setTo(v2);
        tempPath.invalidatePath();
        if (tempPath.outlineContains(find, flatness)) {
          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
          return relativeLen / len;
        } else {
          relativeLen += Geom.length(v1.x[0], v1.y[0], v2.x[0], v2.y[0]);
        }
      }
    }
    if (isClosed && size() > 1) {
      v1 = get(size() - 1);
      v2 = get(0);
      if (v1.mask == 0 && v2.mask == 0) {
        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, flatness)) {
          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
          return relativeLen / len;
        }
      } else {
        t1.setTo(v1);
        t2.setTo(v2);
        tempPath.invalidatePath();
        if (tempPath.outlineContains(find, flatness)) {
          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
          return relativeLen / len;
        }
      }
    }
    return -1;
###
1772, clone, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 651, 656
1
/** Creates a deep copy of the BezierPath. */
6
  public BezierPath clone() {
    BezierPath that = (BezierPath) super.clone();
    for (int i = 0, n = this.size(); i < n; i++) {
      that.set(i, (Node) this.get(i).clone());
    }
    return that;
###
1774, arcTo, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 1117, 1251
28
/**
   * Adds an elliptical arc, defined by two radii, an angle from the
   * x-axis, a flag to choose the large arc or not, a flag to
   * indicate if we increase or decrease the angles and the final
   * point of the arc.
   * <p>
   * As specified in http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
   * <p>
   * The implementation of this method has been derived from
   * Apache Batik class org.apache.batik.ext.awt.geom.ExtendedGeneralPath#computArc
   *
   * @param rx the x radius of the ellipse
   * @param ry the y radius of the ellipse
   *
   * @param xAxisRotation the angle from the x-axis of the current
   * coordinate system to the x-axis of the ellipse in degrees.
   *
   * @param largeArcFlag the large arc flag. If true the arc
   * spanning less than or equal to 180 degrees is chosen, otherwise
   * the arc spanning greater than 180 degrees is chosen
   *
   * @param sweepFlag the sweep flag. If true the line joining
   * center to arc sweeps through decreasing angles otherwise it
   * sweeps through increasing angles
   *
   * @param x the absolute x coordinate of the final point of the arc.
   * @param y the absolute y coordinate of the final point of the arc.
   */
122
  public void arcTo(double rx, double ry,
      double xAxisRotation,
      boolean largeArcFlag, boolean sweepFlag,
      double x, double y) {

    // Ensure radii are valid
    if (rx == 0 || ry == 0) {
      lineTo(x, y);
      return;
    }
    // Get the current (x, y) coordinates of the path
    Node lastPoint = get(size() - 1);
    double x0 = ((lastPoint.mask & C2_MASK) == C2_MASK) ? lastPoint.x[2] : lastPoint.x[0];
    double y0 = ((lastPoint.mask & C2_MASK) == C2_MASK) ? lastPoint.y[2] : lastPoint.y[0];
    if (x0 == x && y0 == y) {
      // If the endpoints (x, y) and (x0, y0) are identical, then this
      // is equivalent to omitting the elliptical arc segment entirely.
      return;
    }
    // Compute the half distance between the current and the final point
    double dx2 = (x0 - x) / 2d;
    double dy2 = (y0 - y) / 2d;
    // Convert angle from degrees to radians
    double angle = Math.toRadians(xAxisRotation);
    double cosAngle = Math.cos(angle);
    double sinAngle = Math.sin(angle);
    //
    // Step 1 : Compute (x1, y1)
    //
    double x1 = (cosAngle * dx2 + sinAngle * dy2);
    double y1 = (-sinAngle * dx2 + cosAngle * dy2);
    // Ensure radii are large enough
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    double Prx = rx * rx;
    double Pry = ry * ry;
    double Px1 = x1 * x1;
    double Py1 = y1 * y1;
    // check that radii are large enough
    double radiiCheck = Px1 / Prx + Py1 / Pry;
    if (radiiCheck > 1) {
      rx = Math.sqrt(radiiCheck) * rx;
      ry = Math.sqrt(radiiCheck) * ry;
      Prx = rx * rx;
      Pry = ry * ry;
    }
    //
    // Step 2 : Compute (cx1, cy1)
    //
    double sign = (largeArcFlag == sweepFlag) ? -1 : 1;
    double sq = ((Prx * Pry) - (Prx * Py1) - (Pry * Px1)) / ((Prx * Py1) + (Pry * Px1));
    sq = (sq < 0) ? 0 : sq;
    double coef = (sign * Math.sqrt(sq));
    double cx1 = coef * ((rx * y1) / ry);
    double cy1 = coef * -((ry * x1) / rx);
    //
    // Step 3 : Compute (cx, cy) from (cx1, cy1)
    //
    double sx2 = (x0 + x) / 2.0;
    double sy2 = (y0 + y) / 2.0;
    double cx = sx2 + (cosAngle * cx1 - sinAngle * cy1);
    double cy = sy2 + (sinAngle * cx1 + cosAngle * cy1);
    //
    // Step 4 : Compute the angleStart (angle1) and the angleExtent (dangle)
    //
    double ux = (x1 - cx1) / rx;
    double uy = (y1 - cy1) / ry;
    double vx = (-x1 - cx1) / rx;
    double vy = (-y1 - cy1) / ry;
    double p, n;
    // Compute the angle start
    n = Math.sqrt((ux * ux) + (uy * uy));
    p = ux; // (1 * ux) + (0 * uy)
    sign = (uy < 0) ? -1d : 1d;
    double angleStart = Math.toDegrees(sign * Math.acos(p / n));
    // Compute the angle extent
    n = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
    p = ux * vx + uy * vy;
    sign = (ux * vy - uy * vx < 0) ? -1d : 1d;
    double angleExtent = Math.toDegrees(sign * Math.acos(p / n));
    if (!sweepFlag && angleExtent > 0) {
      angleExtent -= 360f;
    } else if (sweepFlag && angleExtent < 0) {
      angleExtent += 360f;
    }
    angleExtent %= 360f;
    angleStart %= 360f;
    //
    // We can now build the resulting Arc2D in double precision
    //
    Arc2D.Double arc = new Arc2D.Double(
        cx - rx, cy - ry,
        rx * 2d, ry * 2d,
        -angleStart, -angleExtent,
        Arc2D.OPEN);
    // Create a path iterator of the rotated arc
    PathIterator i = arc.getPathIterator(
        AffineTransform.getRotateInstance(
        angle, arc.getCenterX(), arc.getCenterY()));
    // Add the segments to the bezier path
    double[] coords = new double[6];
    i.next(); // skip first moveto
    while (!i.isDone()) {
      int type = i.currentSegment(coords);
      switch (type) {
        case PathIterator.SEG_CLOSE:
          // ignore
          break;
        case PathIterator.SEG_CUBICTO:
          curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
          break;
        case PathIterator.SEG_LINETO:
          lineTo(coords[0], coords[1]);
          break;
        case PathIterator.SEG_MOVETO:
          // ignore
          break;
        case PathIterator.SEG_QUADTO:
          quadTo(coords[0], coords[1], coords[2], coords[3]);
          break;
      }
      i.next();
###
1775, chop, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 709, 711
5
/**
   * Returns a point on the edge of the bezier path which crosses the line
   * from the center of the bezier path to the specified point.
   * If no edge crosses the line, the nearest C0 control point is returned.
   */
3
  public Point2D.Double chop(Point2D.Double p) {
    validatePath();
    return Geom.chop(generalPath, p);
###
1776, setWindingRule, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 1271, 1275
4
/**
   * Sets winding rule for filling the bezier path.
   * @param newValue Must be Path2D.Double.WIND_EVEN_ODD or Path2D.Double.WIND_NON_ZERO.
   */
5
  public void setWindingRule(int newValue) {
    if (newValue != windingRule) {
      invalidatePath();
      int oldValue = windingRule;
      this.windingRule = newValue;
###
1777, validatePath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 304, 306
3
/**
   * Recomputes the BezierPath, if it is invalid.
   */
3
  public void validatePath() {
    if (generalPath == null) {
      generalPath = toGeneralPath();
###
1778, findSegment, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 953, 993
5
/**
   * Gets the segment of the polyline that is hit by
   * the given Point2D.Double.
   * @return the index of the segment or -1 if no segment was hit.
   */
40
  public int findSegment(Point2D.Double find, double tolerance) {
    // XXX - This works only for straight lines!
    Node v1, v2;
    BezierPath tempPath = new BezierPath();
    Node t1, t2;
    tempPath.add(t1 = new Node());
    tempPath.add(t2 = new Node());
    for (int i = 0, n = size() - 1; i < n; i++) {
      v1 = get(i);
      v2 = get(i + 1);
      if (v1.mask == 0 && v2.mask == 0) {
        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, tolerance)) {
          return i;
        }
      } else {
        t1.setTo(v1);
        t2.setTo(v2);
        tempPath.invalidatePath();
        if (tempPath.outlineContains(find, tolerance)) {
          return i;
        }
      }
    }
    if (isClosed && size() > 1) {
      v1 = get(size() - 1);
      v2 = get(0);
      if (v1.mask == 0 && v2.mask == 0) {
        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, tolerance)) {
          return size() - 1;
        }
      } else {
        t1.setTo(v1);
        t2.setTo(v2);
        tempPath.invalidatePath();
        if (tempPath.outlineContains(find, tolerance)) {
          return size() - 1;
        }
      }
    }
    return -1;
###
1779, getPointOnPath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 817, 862
7
/**
   * Returns a relative point on the path.
   * Where 0 is the start point of the path and 1 is the end point of the
   * path.
   *
   * @param relative a value between 0 and 1.
   */
44
  public Point2D.Double getPointOnPath(double relative, double flatness) {
    // This method works only for straight lines
    if (size() == 0) {
      return null;
    } else if (size() == 1) {
      return get(0).getControlPoint(0);
    }
    if (relative <= 0) {
      return get(0).getControlPoint(0);
    } else if (relative >= 1) {
      return get(size() - 1).getControlPoint(0);
    }
    validatePath();
    // Compute the relative point on the path
    double len = getLengthOfPath(flatness);
    double relativeLen = len * relative;
    double pos = 0;
    double[] coords = new double[6];
    PathIterator i = generalPath.getPathIterator(new AffineTransform(), flatness);
    int type = i.currentSegment(coords);
    double prevX = coords[0];
    double prevY = coords[1];
    i.next();
    for (; !i.isDone(); i.next()) {
      i.currentSegment(coords);
      double segLen = Geom.length(prevX, prevY, coords[0], coords[1]);
      if (pos + segLen >= relativeLen) {
        //if (true) return new Point2D.Double(coords[0], coords[1]);
        // Compute the relative Point2D.Double on the line
        /*
        return new Point2D.Double(
        prevX * pos / len + coords[0] * (pos + segLen) / len,
        prevY * pos / len + coords[1] * (pos + segLen) / len
        );*/
        double factor = (relativeLen - pos) / segLen;
        return new Point2D.Double(
            prevX * (1 - factor) + coords[0] * factor,
            prevY * (1 - factor) + coords[1] * factor);
      }
      pos += segLen;
      prevX = coords[0];
      prevY = coords[1];
    }
    throw new InternalError("We should never get here");
###
1780, joinSegments, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 1001, 1009
5
/**
   * Joins two segments into one if the given Point2D.Double hits a node
   * of the bezier path.
   * @return the index of the joined segment or -1 if no segment was joined.
   */
9
  public int joinSegments(Point2D.Double join, double tolerance) {
    for (int i = 0; i < size(); i++) {
      Node p = get(i);
      if (Geom.length(p.x[0], p.y[0], join.x, join.y) < tolerance) {
        remove(i);
        return i;
      }
    }
    return -1;
###
1781, outlineContains, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 400, 401
7
/**
   * Returns true, if the outline of this bezier path contains the specified
   * point.
   *
   * @param p The point to be tested.
   * @param tolerance The tolerance for the test.
   */
2
  public boolean outlineContains(Point2D.Double p, double tolerance) {
    return Shapes.outlineContains(this, p, tolerance);
###
1782, getCenter, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 692, 701
3
/**
   * Returns the point at the center of the bezier path.
   */
9
  public Point2D.Double getCenter() {
    double sx = 0;
    double sy = 0;
    for (Node p : this) {
      sx += p.x[0];
      sy += p.y[0];
    }
    int n = size();
    return new Point2D.Double(sx / n, sy / n);
###
1783, splitSegment, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 1016, 1037
4
/**
   * Splits the segment at the given Point2D.Double if a segment was hit.
   * @return the index of the segment or -1 if no segment was hit.
   */
22
  public int splitSegment(Point2D.Double split, double tolerance) {
    int i = findSegment(split, tolerance);
    int nextI = (i + 1) % size();
    if (i != -1) {
      if ((get(i).mask & C2_MASK) == C2_MASK
          && (get(nextI).mask & C1_MASK) == 0) {
        // quadto
        add(i + 1, new Node(C2_MASK, split, split, split));
      } else if ((get(i).mask & C2_MASK) == 0
          && (get(nextI).mask & C1_MASK) == C1_MASK) {
        // quadto
        add(i + 1, new Node(C1_MASK, split, split, split));
      } else if ((get(i).mask & C2_MASK) == C2_MASK
          && (get(nextI).mask & C1_MASK) == C1_MASK) {
        // cubicto
        add(i + 1, new Node(C1_MASK | C2_MASK, split, split, split));
      } else {
        // lineto
        add(i + 1, new Node(split));
      }
    }
    return i + 1;
###
1785, addAll, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 267, 269
7
/**
   * Convenience method for adding multiple control points with a single
   * coordinate C0.
   */
 --------------
/** Control point y coordinates. */
 --------------
3
  public void addAll(Collection<Point2D.Double> points) {
    for (Point2D.Double c0 : points) {
      add(new Node(0, c0, c0, c0));
###
1786, invalidatePath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 295, 298
3
/**
   * This must be called after the BezierPath has been changed.
   */
4
  public void invalidatePath() {
    generalPath = null;
    bounds = null;
    outer = -1;
###
1787, mousePressed, TextAreaEditingTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaEditingTool.java, 81, 85
4
/**
   * Creates a new figure at the mouse location.
   * If editing is in progress, this finishes editing.
   */
5
  @Override
  public void mousePressed(MouseEvent e) {
    if (typingTarget != null) {
      beginEdit(typingTarget);
      updateCursor(getView(), e.getPoint());
###
1788, TextAreaEditingTool, TextAreaEditingTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaEditingTool.java, 67, 68
1
/** Creates a new instance. */
2
  public TextAreaEditingTool(TextHolderFigure typingTarget) {
    this.typingTarget = typingTarget;
###
1789, mousePressed, TextEditingTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextEditingTool.java, 70, 74
3
/**
   * If the pressed figure is a TextHolderFigure it can be edited.
   */
5
  @Override
  public void mousePressed(MouseEvent e) {
    if (typingTarget != null) {
      beginEdit(typingTarget);
      updateCursor(getView(), e.getPoint());
###
1790, TextEditingTool, TextEditingTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextEditingTool.java, 57, 58
1
/** Creates a new instance. */
2
  public TextEditingTool(TextHolderFigure typingTarget) {
    this.typingTarget = typingTarget;
###
1791, reparameterize, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 559, 568
10
/**
   * Given set of points and their parameterization, try to find
   * a better parameterization.
   *
   * @param d  Array of digitized points.
   * @param first Indice of first point of region in d.
   * @param last Indice of last point of region in d.
   * @param u Current parameter values.
   * @param bezCurve Current fitted curve.
   */
9
  private static double[] reparameterize(ArrayList<Point2D.Double> d, int first, int last, double[] u, Point2D.Double[] bezCurve) {
    int nPts = last - first + 1;
    int i;
    double[] uPrime; /*  New parameter values  */
    uPrime = new double[nPts];
    for (i = first; i <= last; i++) {
      uPrime[i - first] = newtonRaphsonRootFind(bezCurve, d.get(i), u[i - first]);
    }
    return (uPrime);
###
1792, fitBezierPath, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 65, 66
9
/**
   * Fits a bezier path to the specified list of digitized points.
   * <p>
   * This is a convenience method for calling fitCubicSegments(List<Point2D.Double>, double);
   * 
   * @param digitizedPoints digited points.
   * @param error the maximal allowed error between the bezier path and the
   * digitized points. 
   */
2
  public static BezierPath fitBezierPath(Point2D.Double[] digitizedPoints, double error) {
    return fitBezierPath(Arrays.asList(digitizedPoints), error);
###
1793, fitBezierPath, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 146, 151
9
/**
   * Fits a bezier path to the specified list of digitized points.
   * <p>
   * This is a convenience method for calling fitCubicSegments(List<Point2D.Double>, double);
   * 
   * @param digitizedPoints digited points.
   * @param error the maximal allowed error between the bezier path and the
   * digitized points. 
   */
6
  public static BezierPath fitBezierPath(BezierPath digitizedPoints, double error) {
    ArrayList<Point2D.Double> d = new ArrayList<Point2D.Double>(digitizedPoints.size());
    for (BezierPath.Node n : digitizedPoints) {
      d.add(new Point2D.Double(n.x[0], n.y[0]));
    }
    return fitBezierPath(d, error);
###
1794, v2Length, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 762, 763
3
/**
   * Returns length of input vector.
   */
2
  private static double v2Length(Point2D.Double a) {
    return Math.sqrt(v2SquaredLength(a));
###
1795, reduceNoise, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 332, 350
15
/**
   * Reduces noise from the digitized points, by applying an approximation
   * of a gaussian filter to the data.
   * <p>
   * The filter does the following for each point P, with weight 0.5:
   * <p>
   * x[i] = 0.5*x[i] + 0.25*x[i-1] + 0.25*x[i+1];
   * y[i] = 0.5*y[i] + 0.25*y[i-1] + 0.25*y[i+1];
   * 
   * 
   * 
   * @param digitizedPoints Digitized points
   * @param weight Weight of the current point
   * @return Digitized points with reduced noise.
   */
19
  public static ArrayList<Point2D.Double> reduceNoise(java.util.List<Point2D.Double> digitizedPoints, double weight) {
    java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();
    if (digitizedPoints.size() > 0) {
      Point2D.Double prev = digitizedPoints.get(0);
      cleaned.add(prev);
      double pnWeight = (1d - weight) / 2d; // weight of previous and next
      for (int i = 1, n = digitizedPoints.size() - 1; i < n; i++) {
        Point2D.Double cur = digitizedPoints.get(i);
        Point2D.Double next = digitizedPoints.get(i + 1);
        cleaned.add(new Point2D.Double(
            cur.x * weight + pnWeight * prev.x + pnWeight * next.x,
            cur.y * weight + pnWeight * prev.y + pnWeight * next.y));
        prev = cur;
      }
      if (digitizedPoints.size() > 1) {
        cleaned.add(digitizedPoints.get(digitizedPoints.size() - 1));
      }
    }
    return cleaned;
###
1796, chordLengthParameterize, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 530, 546
8
/**
   * Assign parameter values to digitized points
   * using relative distances between points.
   *
   * @param d Digitized points.
   * @param first Indice of first point of region in d.
   * @param last Indice of last point of region in d.
   */
13
  private static double[] chordLengthParameterize(ArrayList<Point2D.Double> d, int first, int last) {
    int i;
    double[] u;  /*  Parameterization    */
    u = new double[last - first + 1];
    u[0] = 0.0;
    for (i = first + 1; i <= last; i++) {
      u[i - first] = u[i - first - 1] +
          v2DistanceBetween2Points(d.get(i), d.get(i - 1));
    }
    for (i = first + 1; i <= last; i++) {
      u[i - first] = u[i - first] / u[last - first];
    }
    return (u);
###
1797, fitCubic, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 367, 451
14
/**
   * Fit one or multiple subsequent cubic bezier curves to a (sub)set of 
   * digitized points. The digitized points represent a smooth curve without
   * corners.
   *
   * @param d  Array of digitized points. Must not contain subsequent 
   * coincident points.
   * @param first Indice of first point in d.
   * @param last Indice of last point in d.
   * @param tHat1 Unit tangent vectors at start point.
   * @param tHat2 Unit tanget vector at end point.
   * @param errorSquared User-defined errorSquared squared.
   * @param bezierPath Path to which the bezier curve segments are added.
   */
75
  private static void fitCubic(ArrayList<Point2D.Double> d, int first, int last,
      Point2D.Double tHat1, Point2D.Double tHat2,
      double errorSquared, BezierPath bezierPath) {
    Point2D.Double[] bezCurve; /*Control points of fitted Bezier curve*/
    double[] u;    /*  Parameter values for point  */
    double maxError;  /*  Maximum fitting errorSquared   */
    int[] splitPoint = new int[1]; /*  Point to split point set at.
    This is an array of size one, because we need it as an input/output parameter.
     */
    int nPts;    /*  Number of points in subset  */
    double iterationError; /* Error below which you try iterating  */
    int maxIterations = 4; /*  Max times to try iterating  */
    Point2D.Double tHatCenter = new Point2D.Double(); /* Unit tangent vector at splitPoint */
    int i;
    // clone unit tangent vectors, so that we can alter their coordinates
    // without affecting the input values.
    tHat1 = (Point2D.Double) tHat1.clone();
    tHat2 = (Point2D.Double) tHat2.clone();
    iterationError = errorSquared * errorSquared;
    nPts = last - first + 1;
    /*  Use heuristic if region only has two points in it */
    if (nPts == 2) {
      double dist = v2DistanceBetween2Points(d.get(last), d.get(first)) / 3.0;
      bezCurve = new Point2D.Double[4];
      for (i = 0; i < bezCurve.length; i++) {
        bezCurve[i] = new Point2D.Double();
      }
      bezCurve[0] = d.get(first);
      bezCurve[3] = d.get(last);
      v2Add(bezCurve[0], v2Scale(tHat1, dist), bezCurve[1]);
      v2Add(bezCurve[3], v2Scale(tHat2, dist), bezCurve[2]);
      bezierPath.curveTo(
          bezCurve[1].x, bezCurve[1].y,
          bezCurve[2].x, bezCurve[2].y,
          bezCurve[3].x, bezCurve[3].y);
      return;
    }
    /*  Parameterize points, and attempt to fit curve */
    u = chordLengthParameterize(d, first, last);
    bezCurve = generateBezier(d, first, last, u, tHat1, tHat2);
    /*  Find max deviation of points to fitted curve */
    maxError = computeMaxError(d, first, last, bezCurve, u, splitPoint);
    if (maxError < errorSquared) {
      addCurveTo(bezCurve, bezierPath, errorSquared, first == 0 && last == d.size() - 1);
      return;
    }

    /*  If errorSquared not too large, try some reparameterization  */
    /*  and iteration */
    if (maxError < iterationError) {
      double[] uPrime;  /*  Improved parameter values */
      for (i = 0; i < maxIterations; i++) {
        uPrime = reparameterize(d, first, last, u, bezCurve);
        bezCurve = generateBezier(d, first, last, uPrime, tHat1, tHat2);
        maxError = computeMaxError(d, first, last, bezCurve, uPrime, splitPoint);
        if (maxError < errorSquared) {
          addCurveTo(bezCurve, bezierPath, errorSquared, first == 0 && last == d.size() - 1);
          return;
        }
        u = uPrime;
      }
    }
    /* Fitting failed -- split at max errorSquared point and fit recursively */
    tHatCenter = computeCenterTangent(d, splitPoint[0]);
    if (first < splitPoint[0]) {
      fitCubic(d, first, splitPoint[0], tHat1, tHatCenter, errorSquared, bezierPath);
    } else {
      bezierPath.lineTo(d.get(splitPoint[0]).x, d.get(splitPoint[0]).y);
     //   System.err.println("Can't split any further " + first + ".." + splitPoint[0]);
    }
    v2Negate(tHatCenter);
    if (splitPoint[0] < last) {
      fitCubic(d, splitPoint[0], last, tHatCenter, tHat2, errorSquared, bezierPath);
    } else {
      bezierPath.lineTo(d.get(last).x, d.get(last).y);
###
1798, computeCenterTangent, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 510, 519
6
/**
   * Approximate unit tangents at "center" of digitized curve.
   *
   * @param d Digitized points.
   * @param center Index to "center" end of region.
   */
9
  private static Point2D.Double computeCenterTangent(ArrayList<Point2D.Double> d, int center) {
    Point2D.Double V1 = new Point2D.Double(), V2 = new Point2D.Double(),
        tHatCenter = new Point2D.Double();
    V1 = v2SubII(d.get(center - 1), d.get(center));
    V2 = v2SubII(d.get(center), d.get(center + 1));
    tHatCenter.x = (V1.x + V2.x) / 2.0;
    tHatCenter.y = (V1.y + V2.y) / 2.0;
    tHatCenter = v2Normalize(tHatCenter);
    return tHatCenter;
###
1799, v2SubII, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 830, 834
7
/**
   * Subtract Vector a from Vector b.
   * 
   * @param a Vector a - the value is not changed by this method
   * @param b Vector b - the value is not changed by this method
   * @return Vector a subtracted by Vector v.
   */
5
  private static Point2D.Double v2SubII(Point2D.Double a, Point2D.Double b) {
    Point2D.Double c = new Point2D.Double();
    c.x = a.x - b.x;
    c.y = a.y - b.y;
    return (c);
###
1800, v2Normalize, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 813, 820
3
/**
   * Normalizes the input vector and returns it.
   */
7
  private static Point2D.Double v2Normalize(Point2D.Double v) {
    double len = v2Length(v);
    if (len != 0.0) {
      v.x /= len;
      v.y /= len;
    }
    return v;
###
1801, bezierII, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 686, 706
7
/**
   * Evaluate a Bezier curve at a particular parameter value.
   *
   * @param degree  The degree of the bezier curve.
   * @param V  Array of control points.
   * @param t  Parametric value to find point for.
   */
18
  private static Point2D.Double bezierII(int degree, Point2D.Double[] V, double t) {
    int i, j;
    Point2D.Double q; /* Point on curve at parameter t  */
    Point2D.Double[] vTemp; /* Local copy of control points    */
    /* Copy array  */
    vTemp = new Point2D.Double[degree + 1];
    for (i = 0; i <= degree; i++) {
      vTemp[i] = (Point2D.Double) V[i].clone();
    }
    /* Triangle computation  */
    for (i = 1; i <= degree; i++) {
      for (j = 0; j <= degree - i; j++) {
        vTemp[j].x = (1.0 - t) * vTemp[j].x + t * vTemp[j + 1].x;
        vTemp[j].y = (1.0 - t) * vTemp[j].y + t * vTemp[j + 1].y;
      }
    }
    q = vTemp[0];
    return q;
###
1802, v2DistanceBetween2Points, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 719, 720
3
/**
   * Return the distance between two points
   */
2
  private static double v2DistanceBetween2Points(Point2D.Double a, Point2D.Double b) {
    return Math.sqrt(v2SquaredDistanceBetween2Points(a, b));
###
1804, v2Scale, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 737, 744
5
/**
   * Scales the input vector to the new length and returns it.
   * <p>
   * This method alters the value of the input point!
   */
7
  private static Point2D.Double v2Scale(Point2D.Double v, double newlen) {
    double len = v2Length(v);
    if (len != 0.0) {
      v.x *= newlen / len;
      v.y *= newlen / len;
    }
    return v;
###
1805, findCorners, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 264, 314
9
/**
   * Finds corners in the provided point list, and returns their indices.
   * 
   * @param digitizedPoints List of digitized points.
   * @param minAngle Minimal angle for corner points
   * @param minDistance Minimal distance between a point and adjacent points
   * for corner detection
   * @return list of corner indices.
   */
45
  public static ArrayList<Integer> findCorners(java.util.List<Point2D.Double> digitizedPoints, double minAngle, double minDistance) {
    ArrayList<Integer> cornerIndices = new ArrayList<Integer>();
    double squaredDistance = minDistance * minDistance;
    int previousCorner = -1;
    double previousCornerAngle = 0;
    for (int i = 1, n = digitizedPoints.size(); i < n - 1; i++) {
      Point2D.Double p = digitizedPoints.get(i);
      // search for a preceding point for corner detection
      Point2D.Double prev = null;
      boolean intersectsPreviousCorner = false;
      for (int j = i - 1; j >= 0; j--) {
        if (j == previousCorner || v2SquaredDistanceBetween2Points(digitizedPoints.get(j), p) >= squaredDistance) {
          prev = digitizedPoints.get(j);
          intersectsPreviousCorner = j < previousCorner;
          break;
        }
      }
      if (prev == null) {
        continue;
      }
      // search for a succeeding point for corner detection
      Point2D.Double next = null;
      for (int j = i + 1; j < n; j++) {
        if (v2SquaredDistanceBetween2Points(digitizedPoints.get(j), p) >= squaredDistance) {
          next = digitizedPoints.get(j);
          break;
        }
      }
      if (next == null) {
        continue;
      }
      double aPrev = Math.atan2(prev.y - p.y, prev.x - p.x);
      double aNext = Math.atan2(next.y - p.y, next.x - p.x);
      double angle = Math.abs(aPrev - aNext);
      if (angle < Math.PI - minAngle || angle > Math.PI + minAngle) {
        if (intersectsPreviousCorner) {
          cornerIndices.set(cornerIndices.size() - 1, i);
        } else {
          cornerIndices.add(i);
        }
        previousCorner = i;
        previousCornerAngle = angle;
      }
    }
    return cornerIndices;
###
1806, v2SquaredDistanceBetween2Points, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 726, 729
3
/**
   * Return the distance between two points
   */
4
  private static double v2SquaredDistanceBetween2Points(Point2D.Double a, Point2D.Double b) {
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return (dx * dx) + (dy * dy);
###
1807, computeRightTangent, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 497, 501
6
/**
   * Approximate unit tangents at "right" endpoint of digitized curve.
   *
   * @param d Digitized points.
   * @param end Index to "right" end of region.
   */
5
  private static Point2D.Double computeRightTangent(ArrayList<Point2D.Double> d, int end) {
    Point2D.Double tHat2 = new Point2D.Double();
    tHat2 = v2SubII(d.get(end - 1), d.get(end));
    tHat2 = v2Normalize(tHat2);
    return tHat2;
###
1808, v2Negate, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 797, 800
3
/**
   * Negates the input vector and returns it.
   */
4
  private static Point2D.Double v2Negate(Point2D.Double v) {
    v.x = -v.x;
    v.y = -v.y;
    return v;
###
1809, addCurveTo, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 462, 474
6
/**
   * Adds the curve to the bezier path.
   * 
   * @param bezCurve
   * @param bezierPath
   */
12
  private static void addCurveTo(Point2D.Double[] bezCurve, BezierPath bezierPath, double errorSquared, boolean connectsCorners) {
    BezierPath.Node lastNode = bezierPath.get(bezierPath.size() - 1);
    double error = Math.sqrt(errorSquared);
    if (connectsCorners && Geom.lineContainsPoint(lastNode.x[0], lastNode.y[0], bezCurve[3].x, bezCurve[3].y, bezCurve[1].x, bezCurve[1].y, error) &&
        Geom.lineContainsPoint(lastNode.x[0], lastNode.y[0], bezCurve[3].x, bezCurve[3].y, bezCurve[2].x, bezCurve[2].y, error)) {
      bezierPath.lineTo(
          bezCurve[3].x, bezCurve[3].y);
    } else {
      bezierPath.curveTo(
          bezCurve[1].x, bezCurve[1].y,
          bezCurve[2].x, bezCurve[2].y,
          bezCurve[3].x, bezCurve[3].y);
###
1810, splitAtCorners, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 238, 252
13
/**
   * Splits the digitized points into multiple segments at each corner point.
   * <p>
   * Corner points are both contained as the last point of a segment and
   * the first point of a subsequent segment.
   * 
   * @param digitizedPoints Digitized points 
   * @param maxAngle maximal angle in radians between the current point and its
   * predecessor and successor up to which the point does not break the
   * digitized list into segments. Recommended value 44° = 44 * 180d / Math.PI
   * @return Segments of digitized points, each segment having less than maximal
   * angle between points.
   */
13
  public static ArrayList<ArrayList<Point2D.Double>> splitAtCorners(java.util.List<Point2D.Double> digitizedPoints, double maxAngle, double minDistance) {
    ArrayList<Integer> cornerIndices = findCorners(digitizedPoints, maxAngle, minDistance);
    ArrayList<ArrayList<Point2D.Double>> segments = new ArrayList<ArrayList<Point2D.Double>>(cornerIndices.size() + 1);
    if (cornerIndices.size() == 0) {
      segments.add(new ArrayList<Point2D.Double>(digitizedPoints));
    } else {
      segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(0, cornerIndices.get(0) + 1)));
      for (int i = 1; i < cornerIndices.size(); i++) {
        segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(cornerIndices.get(i - 1), cornerIndices.get(i) + 1)));
      }
      segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(cornerIndices.get(cornerIndices.size() - 1), digitizedPoints.size())));
    }
    return segments;
###
1811, v2Dot, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 806, 807
3
/**
   * Return the dot product of vectors a and b.
   */
2
  private static double v2Dot(Point2D.Double a, Point2D.Double b) {
    return (a.x * b.x) + (a.y * b.y);
###
1812, computeLeftTangent, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 484, 488
6
/**
   * Approximate unit tangents at "left" endpoint of digitized curve.
   *
   * @param d Digitized points.
   * @param end Index to "left" end of region.
   */
5
  private static Point2D.Double computeLeftTangent(ArrayList<Point2D.Double> d, int end) {
    Point2D.Double tHat1 = new Point2D.Double();
    tHat1 = v2SubII(d.get(end + 1), d.get(end));
    tHat1 = v2Normalize(tHat1);
    return tHat1;
###
1813, v2AddII, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 787, 791
3
/**
   * Return vector sum = a+b.
   */
5
  private static Point2D.Double v2AddII(Point2D.Double a, Point2D.Double b) {
    Point2D.Double c = new Point2D.Double();
    c.x = a.x + b.x;
    c.y = a.y + b.y;
    return c;
###
1814, generateBezier, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 660, 676
11
/**
   * Use least-squares method to find Bezier control points for region.
   *
   * @param d  Array of digitized points.
   * @param first Indice of first point in d.
   * @param last Indice of last point in d.
   * @param uPrime Parameter values for region .
   * @param tHat1 Unit tangent vectors at start point.
   * @param tHat2 Unit tanget vector at end point.
   * @return A cubic bezier curve consisting of 4 control points.
   */
14
  private static Point2D.Double[] generateBezier(ArrayList<Point2D.Double> d, int first, int last, double[] uPrime, Point2D.Double tHat1, Point2D.Double tHat2) {
    Point2D.Double[] bezCurve;
    bezCurve = new Point2D.Double[4];
    for (int i = 0; i < bezCurve.length; i++) {
      bezCurve[i] = new Point2D.Double();
    }

    /*  Use the Wu/Barsky heuristic*/
    double dist = v2DistanceBetween2Points(d.get(last), d.get(first)) / 3.0;
    bezCurve[0] = d.get(first);
    bezCurve[3] = d.get(last);
    v2Add(bezCurve[0], v2Scale(tHat1, dist), bezCurve[1]);
    v2Add(bezCurve[3], v2Scale(tHat2, dist), bezCurve[2]);
    return (bezCurve);
###
1815, removeCoincidentPoints, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 210, 222
13
/**
   * Removes sequences of coincident points.
   * <p>
   * The purpose of this method, is to clean up a list of digitized points
   * for later processing using method {@link #splitAtCorners}.
   * <p>
   * Use this method only, if you know that the digitized points contain no
   * quantization errors - which is never the case, unless you want to debug
   * the curve fitting algorithm of this class.
   * 
   * @param digitizedPoints Digitized points
   * @return Digitized points without subsequent duplicates.
   */
13
  private static ArrayList<Point2D.Double> removeCoincidentPoints(java.util.List<Point2D.Double> digitizedPoints) {
    java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();
    if (digitizedPoints.size() > 0) {
      Point2D.Double prev = digitizedPoints.get(0);
      cleaned.add(prev);
      for (Point2D.Double p : digitizedPoints) {
        if (!prev.equals(p)) {
          cleaned.add(p);
          prev = p;
        }
      }
    }
    return cleaned;
###
1816, v2SquaredLength, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 769, 770
3
/**
   * Returns squared length of input vector.
   */
2
  private static double v2SquaredLength(Point2D.Double a) {
    return (a.x * a.x) + (a.y * a.y);
###
1817, fitBezierPath, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 76, 134
7
/**
   * Fits a bezier path to the specified list of digitized points.
   * 
   * @param digitizedPoints digited points.
   * @param error the maximal allowed error between the bezier path and the
   * digitized points. 
   */
55
  public static BezierPath fitBezierPath(java.util.List<Point2D.Double> digitizedPoints, double error) {
    // Split into segments at corners
    ArrayList<ArrayList<Point2D.Double>> segments = new ArrayList<ArrayList<Point2D.Double>>();
    segments = splitAtCorners(digitizedPoints, 77 / 180d * Math.PI, error * error);
    
    // Clean up the data in the segments
    for (int i = 0, n = segments.size(); i < n; i++) {
      ArrayList<Point2D.Double> seg = segments.get(i);
      seg = removeClosePoints(seg, error * 2);
      seg = reduceNoise(seg, 0.8);
      segments.set(i, seg);
    }

    // Create fitted bezier path
    BezierPath fittedPath = new BezierPath();

    // Quickly deal with empty dataset
    boolean isEmpty = false;
    for (ArrayList<Point2D.Double> seg : segments) {
      if (seg.isEmpty()) {
        isEmpty = false;
        break;
      }
    }
    if (!isEmpty) {
      // Process each segment of digitized points
      double errorSquared = error * error;
      for (ArrayList<Point2D.Double> seg : segments) {
        switch (seg.size()) {
          case 0:
            break;
          case 1:
            fittedPath.add(new BezierPath.Node(seg.get(0)));
            break;
          case 2:
            if (fittedPath.isEmpty()) {
              fittedPath.add(new BezierPath.Node(seg.get(0)));
            }
            fittedPath.lineTo(seg.get(1).x, seg.get(1).y);
            break;
          default:
            if (fittedPath.isEmpty()) {
              fittedPath.add(new BezierPath.Node(seg.get(0)));
            }
            /*  Unit tangent vectors at endpoints */
            Point2D.Double tHat1 = new Point2D.Double();
            Point2D.Double tHat2 = new Point2D.Double();
            tHat1 = computeLeftTangent(seg, 0);
            tHat2 = computeRightTangent(seg, seg.size() - 1);
            fitCubic(seg, 0, seg.size() - 1, tHat1, tHat2, errorSquared, fittedPath);
            break;
        }
      }
    }
    return fittedPath;
###
1818, v2ScaleIII, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 752, 756
5
/**
   * Scales the input vector by the specified factor and returns it.
   * <p>
   * This method alters the value of the input point!
   */
5
  private static Point2D.Double v2ScaleIII(Point2D.Double v, double s) {
    Point2D.Double result = new Point2D.Double();
    result.x = v.x * s;
    result.y = v.y * s;
    return result;
###
1819, computeMaxError, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 628, 646
12
/**
   * Find the maximum squared distance of digitized points
   * to fitted curve.
   *
   * @param d Digitized points.
   * @param first Indice of first point of region in d.
   * @param last Indice of last point of region in d.
   * @param bezCurve Fitted Bezier curve
   * @param u Parameterization of points*
   * @param splitPoint Point of maximum error (input/output parameter, must be
   * an array of 1)
   */
18
  private static double computeMaxError(ArrayList<Point2D.Double> d, int first, int last, Point2D.Double[] bezCurve, double[] u, int[] splitPoint) {
    int i;
    double maxDist;    /*  Maximum error */
    double dist;    /*  Current error */
    Point2D.Double P = new Point2D.Double(); /*  Point on curve */
    Point2D.Double v = new Point2D.Double(); /*  Vector from point to curve */
    splitPoint[0] = (last - first + 1) / 2;
    maxDist = 0.0;
    for (i = first + 1; i < last; i++) {
      P = bezierII(3, bezCurve, u[i - first]);
      v = v2SubII(P, d.get(i));
      dist = v2SquaredLength(v);
      if (dist >= maxDist) {
        maxDist = dist;
        splitPoint[0] = i;
      }
    }
    return (maxDist);
###
1820, removeClosePoints, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 173, 193
19
/**
   * Removes points which are closer together than the specified minimal 
   * distance.
   * <p>
   * The minimal distance should be chosen dependent on the size and resolution of the
   * display device, and on the sampling rate. A good value for mouse input
   * on a display with 100% Zoom factor is 2.
   * <p>
   * The purpose of this method, is to remove points, which add no additional
   * information about the shape of the curve from the list of digitized points.
   * <p>
   * The cleaned up set of digitized points gives better results, when used
   * as input for method {@link #splitAtCorners}.
   * 
   * @param digitizedPoints Digitized points
   * @param minDistance minimal distance between two points. If minDistance is
   * 0, this method only removes sequences of coincident points. 
   * @return Digitized points with a minimal distance.
   */
20
  public static ArrayList<Point2D.Double> removeClosePoints(java.util.List<Point2D.Double> digitizedPoints, double minDistance) {
    if (minDistance == 0) {
      return removeCoincidentPoints(digitizedPoints);
    } else {
      double squaredDistance = minDistance * minDistance;
      java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();
      if (digitizedPoints.size() > 0) {
        Point2D.Double prev = digitizedPoints.get(0);
        cleaned.add(prev);
        for (Point2D.Double p : digitizedPoints) {
          if (v2SquaredDistanceBetween2Points(prev, p) > squaredDistance) {
            cleaned.add(p);
            prev = p;
          }
        }
        if (!prev.equals(digitizedPoints.get(digitizedPoints.size() - 1))) {
          cleaned.set(cleaned.size() - 1, digitizedPoints.get(digitizedPoints.size() - 1));
        }
      }
      return cleaned;
###
1821, v2Add, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 778, 781
5
/**
   * Return vector sum c = a+b.
   * <p>
   * This method alters the value of c.
   */
4
  private static Point2D.Double v2Add(Point2D.Double a, Point2D.Double b, Point2D.Double c) {
    c.x = a.x + b.x;
    c.y = a.y + b.y;
    return c;
###
1822, newtonRaphsonRootFind, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 578, 613
7
/**
   * Use Newton-Raphson iteration to find better root.
   *
   * @param Q  Current fitted bezier curve.
   * @param P  Digitized point.
   * @param u  Parameter value vor P.
   */
30
  private static double newtonRaphsonRootFind(Point2D.Double[] Q, Point2D.Double P, double u) {
    double numerator, denominator;
    Point2D.Double[] Q1 = new Point2D.Double[3], Q2 = new Point2D.Double[2];  /*  Q' and Q''      */
    Point2D.Double Q_u = new Point2D.Double(), Q1_u = new Point2D.Double(), Q2_u = new Point2D.Double(); /*u evaluated at Q, Q', & Q''  */
    double uPrime;    /*  Improved u  */
    int i;
    /* Compute Q(u)  */
    Q_u = bezierII(3, Q, u);
    /* Generate control vertices for Q'  */
    for (i = 0; i <= 2; i++) {
      Q1[i] = new Point2D.Double(
          (Q[i + 1].x - Q[i].x) * 3.0,
          (Q[i + 1].y - Q[i].y) * 3.0);
    }
    /* Generate control vertices for Q'' */
    for (i = 0; i <= 1; i++) {
      Q2[i] = new Point2D.Double(
          (Q1[i + 1].x - Q1[i].x) * 2.0,
          (Q1[i + 1].y - Q1[i].y) * 2.0);
    }
    /* Compute Q'(u) and Q''(u)  */
    Q1_u = bezierII(2, Q1, u);
    Q2_u = bezierII(1, Q2, u);
    /* Compute f(u)/f'(u) */
    numerator = (Q_u.x - P.x) * (Q1_u.x) + (Q_u.y - P.y) * (Q1_u.y);
    denominator = (Q1_u.x) * (Q1_u.x) + (Q1_u.y) * (Q1_u.y) +
        (Q_u.x - P.x) * (Q2_u.x) + (Q_u.y - P.y) * (Q2_u.y);
    /* u = u - f(u)/f'(u) */
    uPrime = u - (numerator / denominator);
    return (uPrime);
###
1823, isDone, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 80, 81
4
/**
   * Tests if there are more points to read.
   * @return true if there are more points to read
   */
2
  public boolean isDone() {
    return (index >= path.size() + (path.isClosed() ? 2 : 0));
###
1824, getWindingRule, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 72, 73
6
/**
   * Return the winding rule for determining the interior of the
   * path.
   * @see PathIterator#WIND_EVEN_ODD
   * @see PathIterator#WIND_NON_ZERO
   */
2
  public int getWindingRule() {
    return path.getWindingRule();
###
1825, currentSegment, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 113, 210
18
/**
   * Returns the coordinates and type of the current path segment in
   * the iteration.
   * The return value is the path segment type:
   * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
   * A float array of length 6 must be passed in and may be used to
   * store the coordinates of the point(s).
   * Each point is stored as a pair of float x,y coordinates.
   * SEG_MOVETO and SEG_LINETO types will return one point,
   * SEG_QUADTO will return two points,
   * SEG_CUBICTO will return 3 points
   * and SEG_CLOSE will not return any points.
   * @see PathIterator#SEG_MOVETO
   * @see PathIterator#SEG_LINETO
   * @see PathIterator#SEG_QUADTO
   * @see PathIterator#SEG_CUBICTO
   * @see PathIterator#SEG_CLOSE
   */
98
  public int currentSegment(float[] coords) {
    int numCoords = 0;
    int type = 0;
    if (index == path.size()) {
      // We only get here for closed paths
      if (path.size() > 1) {
        BezierPath.Node previous = path.get(path.size() - 1);
        BezierPath.Node current = path.get(0);
        
        if ((previous.mask & BezierPath.C2_MASK) == 0) {
          if ((current.mask & BezierPath.C1_MASK) == 0) {
            numCoords = 1;
            type = SEG_LINETO;
            coords[0] = (float) current.x[0];
            coords[1] = (float) current.y[0];
          } else {
            numCoords = 2;
            type = SEG_QUADTO;
            coords[0] = (float) current.x[1];
            coords[1] = (float) current.y[1];
            coords[2] = (float) current.x[0];
            coords[3] = (float) current.y[0];
          }
        } else {
          if ((current.mask & BezierPath.C1_MASK) == 0) {
            numCoords = 2;
            type = SEG_QUADTO;
            coords[0] = (float) previous.x[2];
            coords[1] = (float) previous.y[2];
            coords[2] = (float) current.x[0];
            coords[3] = (float) current.y[0];
          } else {
            numCoords = 3;
            type = SEG_CUBICTO;
            coords[0] = (float) previous.x[2];
            coords[1] = (float) previous.y[2];
            coords[2] = (float) current.x[1];
            coords[3] = (float) current.y[1];
            coords[4] = (float) current.x[0];
            coords[5] = (float) current.y[0];
          }
        }
      }
    } else if (index > path.size()) {
      // We only get here for closed paths
      return SEG_CLOSE;
    } else if (index == 0) {
      BezierPath.Node current = path.get(index);
      coords[0] = (float) current.x[0];
      coords[1] = (float) current.y[0];
      numCoords = 1;
      type = SEG_MOVETO;
      
    } else if (index < path.size()) {
      BezierPath.Node current = path.get(index);
      BezierPath.Node previous = path.get(index - 1);
      
      if ((previous.mask & BezierPath.C2_MASK) == 0) {
        if ((current.mask & BezierPath.C1_MASK) == 0) {
          numCoords = 1;
          type = SEG_LINETO;
          coords[0] = (float) current.x[0];
          coords[1] = (float) current.y[0];
          
        } else {
          numCoords = 2;
          type = SEG_QUADTO;
          coords[0] = (float) current.x[1];
          coords[1] = (float) current.y[1];
          coords[2] = (float) current.x[0];
          coords[3] = (float) current.y[0];
        }
      } else {
        if ((current.mask & BezierPath.C1_MASK) == 0) {
          numCoords = 2;
          type = SEG_QUADTO;
          coords[0] = (float) previous.x[2];
          coords[1] = (float) previous.y[2];
          coords[2] = (float) current.x[0];
          coords[3] = (float) current.y[0];
        } else {
          numCoords = 3;
          type = SEG_CUBICTO;
          coords[0] = (float) previous.x[2];
          coords[1] = (float) previous.y[2];
          coords[2] = (float) current.x[1];
          coords[3] = (float) current.y[1];
          coords[4] = (float) current.x[0];
          coords[5] = (float) current.y[0];
        }
      }
    }
    
    
    if (affine != null) {
      affine.transform(coords, 0, coords, 0, numCoords);
    }
    return type;
###
1826, next, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 89, 91
5
/**
   * Moves the iterator to the next segment of the path forwards
   * along the primary direction of traversal as long as there are
   * more points in that direction.
   */
3
  public void next() {
    if (! isDone()) {
      index++;
###
1827, BezierPathIterator, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 61, 63
5
/**
   * Constructs an iterator given a BezierPath and an optional
   * AffineTransform.
   * @see BezierPath#getPathIterator
   */
3
  public BezierPathIterator(BezierPath path, AffineTransform at) {
    this.path = path;
    this.affine = at;
###
1828, currentSegment, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 231, 330
18
/**
   * Returns the coordinates and type of the current path segment in
   * the iteration.
   * The return value is the path segment type:
   * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
   * A double array of length 6 must be passed in and may be used to
   * store the coordinates of the point(s).
   * Each point is stored as a pair of double x,y coordinates.
   * SEG_MOVETO and SEG_LINETO types will return one point,
   * SEG_QUADTO will return two points,
   * SEG_CUBICTO will return 3 points
   * and SEG_CLOSE will not return any points.
   * @see PathIterator#SEG_MOVETO
   * @see PathIterator#SEG_LINETO
   * @see PathIterator#SEG_QUADTO
   * @see PathIterator#SEG_CUBICTO
   * @see PathIterator#SEG_CLOSE
   */
100
  public int currentSegment(double[] coords) {
    int numCoords = 0;
    int type = 0;
    if (index == path.size()) {
      // We only get here for closed paths
      if (path.size() > 1) {
        BezierPath.Node previous = path.get(path.size() - 1);
        BezierPath.Node current = path.get(0);
        
        if ((previous.mask & BezierPath.C2_MASK) == 0) {
          if ((current.mask & BezierPath.C1_MASK) == 0) {
            numCoords = 1;
            type = SEG_LINETO;
            coords[0] = current.x[0];
            coords[1] = current.y[0];
          } else {
            numCoords = 2;
            type = SEG_QUADTO;
            coords[0] = current.x[1];
            coords[1] = current.y[1];
            coords[2] = current.x[0];
            coords[3] = current.y[0];
          }
        } else {
          if ((current.mask & BezierPath.C1_MASK) == 0) {
            numCoords = 2;
            type = SEG_QUADTO;
            coords[0] = previous.x[2];
            coords[1] = previous.y[2];
            coords[2] = current.x[0];
            coords[3] = current.y[0];
          } else {
            numCoords = 3;
            type = SEG_CUBICTO;
            coords[0] = previous.x[2];
            coords[1] = previous.y[2];
            coords[2] = current.x[1];
            coords[3] = current.y[1];
            coords[4] = current.x[0];
            coords[5] = current.y[0];
          }
        }
      }
    } else if (index > path.size()) {
      // We only get here for closed paths
      return SEG_CLOSE;
    } else if (index == 0) {
      BezierPath.Node current = path.get(index);
      coords[0] = current.x[0];
      coords[1] = current.y[0];
      numCoords = 1;
      type = SEG_MOVETO;
      
    } else if (index < path.size()) {
      BezierPath.Node current = path.get(index);
      BezierPath.Node previous = path.get(index - 1);
      
      if ((previous.mask & BezierPath.C2_MASK) == 0) {
        if ((current.mask & BezierPath.C1_MASK) == 0) {
          numCoords = 1;
          type = SEG_LINETO;
          coords[0] = current.x[0];
          coords[1] = current.y[0];
          
        } else {
          numCoords = 2;
          type = SEG_QUADTO;
          coords[0] = current.x[1];
          coords[1] = current.y[1];
          coords[2] = current.x[0];
          coords[3] = current.y[0];
        }
      } else {
        if ((current.mask & BezierPath.C1_MASK) == 0) {
          numCoords = 2;
          type = SEG_QUADTO;
          coords[0] = previous.x[2];
          coords[1] = previous.y[2];
          coords[2] = current.x[0];
          coords[3] = current.y[0];
        } else {
          numCoords = 3;
          type = SEG_CUBICTO;
          coords[0] = previous.x[2];
          coords[1] = previous.y[2];
          coords[2] = current.x[1];
          coords[3] = current.y[1];
          coords[4] = current.x[0];
          coords[5] = current.y[0];
        }
      }
    }
    
    
    if (affine != null) {
      affine.transform(coords, 0, coords, 0, numCoords);
    } else {
      System.arraycopy(coords, 0, coords, 0, numCoords);
    }
    return type;
###
1829, BezierPathIterator, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 52, 53
4
/**
   * Constructs an iterator given a BezierPath.
   * @see BezierPath#getPathIterator
   */
2
  public BezierPathIterator(BezierPath path) {
    this(path, null);
###
1830, getConvexHullPolygon, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 40, 45
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points as a polygon object.
   */
6
  public static Polygon getConvexHullPolygon(List<Point> points) {
    Polygon convexHull = new Polygon();
    for (Point p : getConvexHull(points.toArray(new Point[points.size()]))) {
      convexHull.addPoint(p.x, p.y);
    }
    return convexHull;
###
1831, getConvexHullPath2D, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 54, 59
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points as a Polygon2D object.
   */
6
  public static Polygon2D.Double getConvexHullPath2D(List<Point2D.Double> points) {
    Polygon2D.Double convexHull = new Polygon2D.Double();
    for (Point p : getConvexHull(points.toArray(new Point[points.size()]))) {
      convexHull.add(p);
    }
    return convexHull;
###
1832, getConvexHull2D, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 114, 115
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points
   */
2
  public static List<Point2D.Double> getConvexHull2D(List<Point2D.Double> points) {
    return Arrays.asList(getConvexHull2D(points.toArray(new Point2D.Double[points.size()])));
###
1833, getConvexHull, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 124, 169
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points
   */
40
  public static Point[] getConvexHull(Point[] points) {
    // Quickly return if no work is needed
    if (points.length < 3) {
      return points.clone();
    }
    // Sort points from left to right O(n log n)
    Point[] sorted = points.clone();
    Arrays.sort(sorted, new Comparator<Point>() {
      public int compare(Point o1, Point o2) {
        int v = o1.x - o2.x;
        return (v == 0) ? o1.y - o2.y : v;
      }
    });
    Point[] hull = new Point[sorted.length + 2];
    // Process upper part of convex hull O(n)
    int upper = 0; // Number of points in upper part of convex hull
    hull[upper++] = sorted[0];
    hull[upper++] = sorted[1];
    for (int i = 2; i < sorted.length; i++) {
      hull[upper++] = sorted[i];
      while (upper > 2 && !isRightTurn(hull[upper - 3], hull[upper - 2], hull[upper - 1])) {
        hull[upper - 2] = hull[upper - 1];
        upper--;
      }
    }
    // Process lower part of convex hull O(n)
    int lower = upper; // (lower - number + 1) = number of points in the lower part of the convex hull
    hull[lower++] = sorted[sorted.length - 2];
    for (int i = sorted.length - 3; i >= 0; i--) {
      hull[lower++] = sorted[i];
      while (lower - upper > 1 && !isRightTurn(hull[lower - 3], hull[lower - 2], hull[lower - 1])) {
        hull[lower - 2] = hull[lower - 1];
        lower--;
      }
    }
    lower -= 1;
    // Reduce array
    Point[] convexHull = new Point[lower];
    System.arraycopy(hull, 0, convexHull, 0, lower);
    return convexHull;
###
1834, getConvexHull2D, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 195, 242
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points
   */
43
  public static Point2D.Double[] getConvexHull2D(Point2D.Double[] points) {
    // Quickly return if no work is needed
    if (points.length < 3) {
      return points.clone();
    }
    // Sort points from left to right O(n log n)
    Point2D.Double[] sorted = points.clone();
    Arrays.sort(sorted, new Comparator<Point2D.Double>() {
      public int compare(Point2D.Double o1, Point2D.Double o2) {
        double v = o1.x - o2.x;
        if (v == 0) {
          v = o1.y - o2.y;
        }
        return (v > 0) ? 1 : ((v < 0) ? -1 : 0);
      }
    });
    Point2D.Double[] hull = new Point2D.Double[sorted.length + 2];
    // Process upper part of convex hull O(n)
    int upper = 0; // Number of points in upper part of convex hull
    hull[upper++] = sorted[0];
    hull[upper++] = sorted[1];
    for (int i = 2; i < sorted.length; i++) {
      hull[upper++] = sorted[i];
      while (upper > 2 && !isRightTurn2D(hull[upper - 3], hull[upper - 2], hull[upper - 1])) {
        hull[upper - 2] = hull[upper - 1];
        upper--;
      }
    }
    // Process lower part of convex hull O(n)
    int lower = upper; // (lower - number + 1) = number of points in the lower part of the convex hull
    hull[lower++] = sorted[sorted.length - 2];
    for (int i = sorted.length - 3; i >= 0; i--) {
      hull[lower++] = sorted[i];
      while (lower - upper > 1 && !isRightTurn2D(hull[lower - 3], hull[lower - 2], hull[lower - 1])) {
        hull[lower - 2] = hull[lower - 1];
        lower--;
      }
    }
    lower -= 1;
    // Reduce array
    Point2D.Double[] convexHull = new Point2D.Double[lower];
    System.arraycopy(hull, 0, convexHull, 0, lower);
    return convexHull;
###
1835, getConvexHull, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 104, 105
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points
   */
2
  public static List<Point> getConvexHull(List<Point> points) {
    return Arrays.asList(getConvexHull(points.toArray(new Point[points.size()])));
###
1836, isRightTurn2D, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 253, 260
8
/**
   * Returns true, if the three given points make a right turn.
   *
   * @param p1 first point
   * @param p2 second point
   * @param p3 third point
   * @return true if right turn.
   */
8
  public static boolean isRightTurn2D(Point.Double p1, Point.Double p2, Point.Double p3) {
    if (p1.equals(p2)||p2.equals(p3)) {
      // no right turn if points are at same location
      return false;
    }
    
    double val = (p2.x * p3.y + p1.x * p2.y + p3.x * p1.y) - (p2.x * p1.y + p3.x * p2.y + p1.x * p3.y);
    return val > 0;
###
1837, isRightTurn, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 180, 186
8
/**
   * Returns true, if the three given points make a right turn.
   * 
   * @param p1 first point
   * @param p2 second point
   * @param p3 third point
   * @return true if right turn.
   */
7
  public static boolean isRightTurn(Point p1, Point p2, Point p3) {
    if (p1.equals(p2)||p2.equals(p3)) {
      // no right turn if points are at same location
      return false;
    }
    double val = (p2.x * p3.y + p1.x * p2.y + p3.x * p1.y) - (p2.x * p1.y + p3.x * p2.y + p1.x * p3.y);
    return val > 0;
###
1838, getConvexHullPath2D, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 68, 95
6
/**
   * Computes the convex hull from a shape.
   *
   * @param shape an arbitray shape
   * @return convex hull of the points as a Polygon2D object.
   */
27
  public static Polygon2D.Double getConvexHullPath2D(Shape shape) {
    List<Point2D.Double> points = new LinkedList<Point2D.Double>();
    double[] coords = new double[6];
    for (PathIterator i = shape.getPathIterator(null); !i.isDone(); i.next()) {
      switch (i.currentSegment(coords)) {
        case PathIterator.SEG_CLOSE:
          break;
        case PathIterator.SEG_MOVETO:
        case PathIterator.SEG_LINETO:
          points.add(new Point2D.Double(coords[0], coords[1]));
          break;
        case PathIterator.SEG_QUADTO:
          points.add(new Point2D.Double(coords[0], coords[1]));
          points.add(new Point2D.Double(coords[2], coords[3]));
          break;
        case PathIterator.SEG_CUBICTO:
          points.add(new Point2D.Double(coords[0], coords[1]));
          points.add(new Point2D.Double(coords[2], coords[3]));
          points.add(new Point2D.Double(coords[4], coords[5]));
          break;
      }
    }
    Polygon2D.Double convexHull = new Polygon2D.Double();
    for (Point2D.Double p : getConvexHull2D(points.toArray(new Point2D.Double[points.size()]))) {
      convexHull.add(p);
    }
    return convexHull;
###
1839, setDragTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 364, 365
4
/**
   * Method to set a {@code DragTracker}. If you specify null, the
   * {@code SelectionTool} uses the {@code DefaultDragTracker}.
   */
2
  public void setDragTracker(DragTracker newValue) {
    dragTracker = newValue;
###
1840, setHandleTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 348, 349
4
/**
   * Method to set a {@code HandleTracker}. If you specify null, the
   * {@code SelectionTool} uses the {@code DefaultHandleTracker}.
   */
2
  public void setHandleTracker(HandleTracker newValue) {
    handleTracker = newValue;
###
1841, setSelectAreaTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 356, 357
4
/**
   * Method to set a {@code SelectAreaTracker}. If you specify null, the
   * {@code SelectionTool} uses the {@code DefaultSelectAreaTracker}.
   */
2
  public void setSelectAreaTracker(SelectAreaTracker newValue) {
    selectAreaTracker = newValue;
###
1842, setSelectBehindEnabled, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 142, 145
6
/**
   * Sets the selectBehindEnabled property.
   * This is a bound property.
   *
   * @param newValue The new value.
   */
4
  public void setSelectBehindEnabled(boolean newValue) {
    boolean oldValue = isSelectBehindEnabled;
    isSelectBehindEnabled = newValue;
    firePropertyChange(SELECT_BEHIND_ENABLED_PROPERTY, oldValue, newValue);
###
1843, getHandleTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 313, 318
4
/**
   * Method to get a {@code HandleTracker} which handles user interaction
   * for the specified handle.
   */
6
  protected HandleTracker getHandleTracker(Handle handle) {
    if (handleTracker == null) {
      handleTracker = new DefaultHandleTracker();
    }
    handleTracker.setHandles(handle, getView().getCompatibleHandles(handle));
    return handleTracker;
###
1844, getDragTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 325, 330
4
/**
   * Method to get a {@code DragTracker} which handles user interaction
   * for dragging the specified figure.
   */
6
  protected DragTracker getDragTracker(Figure f) {
    if (dragTracker == null) {
      dragTracker = new DefaultDragTracker();
    }
    dragTracker.setDraggedFigure(f);
    return dragTracker;
###
1845, SelectionTool, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 130, 133
1
/** Creates a new instance. */
4
  public SelectionTool() {
    tracker = getSelectAreaTracker();
    trackerHandler = new TrackerHandler();
    tracker.addToolListener(trackerHandler);
###
1846, isSelectBehindEnabled, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 154, 155
6
/**
   * Returns the value of the selectBehindEnabled property.
   * This is a bound property.
   *
   * @return The property value.
   */
2
  public boolean isSelectBehindEnabled() {
    return isSelectBehindEnabled;
###
1847, getSelectAreaTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 337, 341
4
/**
   * Method to get a {@code SelectAreaTracker} which handles user interaction
   * for selecting an area on the drawing.
   */
5
  protected SelectAreaTracker getSelectAreaTracker() {
    if (selectAreaTracker == null) {
      selectAreaTracker = new DefaultSelectAreaTracker();
    }
    return selectAreaTracker;
###
1861, main, DefaultDOMStorableSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/DefaultDOMStorableSample.java, 62, 89
1
/** DOM Storable objects must have a non-argument constructor. */
22
  public static void main(String[] args) {
    try {
      // Set up the DefaultDOMFactory
      DefaultDOMFactory factory = new DefaultDOMFactory();
      factory.addStorableClass("MyElementName", MyObject.class);
      // Create a DOMStorable object
      MyObject obj = new MyObject("Hello World");
      System.out.println("The name of the original object is:" + obj.getName());
      // Write the object into a DOM, and then serialize the DOM into a String
      NanoXMLDOMOutput out = new NanoXMLDOMOutput(factory);
      out.writeObject(obj);
      StringWriter writer = new StringWriter();
      out.save(writer);
      String serializedString = writer.toString();
      System.out.println("\nThe serialized representation of the object is:\n" + serializedString);
      // Deserialize a DOM from a String, and then read the object from the DOM
      StringReader reader = new StringReader(serializedString);
      NanoXMLDOMInput in = new NanoXMLDOMInput(factory, reader);
      MyObject obj2 = (MyObject) in.readObject();
      System.out.println("\nThe name of the restored object is:" + obj2.getName());
    } catch (IOException ex) {
      Logger.getLogger(DefaultDOMStorableSample.class.getName()).log(Level.SEVERE, null, ex);
###
1862, main, MovableChildFiguresSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/MovableChildFiguresSample.java, 73, 102
3
/**
     * Return default handles from the presentation figure.
     */
27
  public static void main(String[] args) {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        // Create a simple drawing consisting of three
        // text areas and an elbow connection.
        LabeledEllipseFigure ta = new LabeledEllipseFigure();
        ta.setBounds(new Point2D.Double(10, 10), new Point2D.Double(100, 100));
        LabeledEllipseFigure tb = new LabeledEllipseFigure();
        tb.setBounds(new Point2D.Double(220, 120), new Point2D.Double(310, 210));
        LabeledEllipseFigure tc = new LabeledEllipseFigure();
        tc.setBounds(new Point2D.Double(220, 10), new Point2D.Double(310, 100));
        Drawing drawing = new DefaultDrawing();
        drawing.add(ta);
        drawing.add(tb);
        drawing.add(tc);
        // Create a frame with a drawing view and a drawing editor
        JFrame f = new JFrame("My Drawing");
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        f.setSize(400, 300);
        DrawingView view = new DefaultDrawingView();
        view.setDrawing(drawing);
        f.add(view.getComponent());
        f.add(new JLabel("Press space bar to toggle handles."), BorderLayout.SOUTH);
        DrawingEditor editor = new DefaultDrawingEditor();
        editor.add(view);
        editor.setTool(new DelegationSelectionTool());
        f.setVisible(true);
###
1863, createDrawing, MultiEditorSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/MultiEditorSample.java, 103, 109
6
/**
   * Creates a drawing with input and output formats, so that drawing figures
   * can be copied and pasted between drawing views.
   * 
   * @return a drawing
   */
7
  private static Drawing createDrawing() {
    // Create a default drawing with
    // input/output formats for basic clipboard support.
    DefaultDrawing drawing = new DefaultDrawing();
    drawing.addInputFormat(new SerializationInputOutputFormat());
    drawing.addOutputFormat(new SerializationInputOutputFormat());
    return drawing;
###
1864, createDrawing, DnDMultiEditorSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/DnDMultiEditorSample.java, 110, 117
6
/**
   * Creates a drawing with input and output formats, so that drawing figures
   * can be copied and pasted between drawing views.
   * 
   * @return a drawing
   */
8
  private static Drawing createDrawing() {
    // Create a default drawing with
    // input/output formats for basic clipboard support.
    DefaultDrawing drawing = new DefaultDrawing();
    drawing.addInputFormat(new SerializationInputOutputFormat());
    drawing.addOutputFormat(new SerializationInputOutputFormat());
    drawing.addOutputFormat(new ImageOutputFormat());
    return drawing;
###
1865, read, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 172, 207
3
/**
   * Reads the view from the specified uri.
   */
33
  public void read(URI f, URIChooser fc) throws IOException {
    try {
      final Drawing drawing = createDrawing();
      boolean success = false;
        for (InputFormat sfi : drawing.getInputFormats()) {
            try {
              sfi.read(new File(f), drawing, true);
              success = true;
              break;
            } catch (Exception e) {
            // try with the next input format
            }
          }
      if (!success) {
        ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
        throw new IOException(labels.getFormatted("file.open.unsupportedFileFormat.message", URIUtil.getName(f)));
      }
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(drawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InterruptedException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
    } catch (InvocationTargetException e) {
      InternalError error = new InternalError();
      error.initCause(e);
      throw error;
###
1866, write, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 163, 166
3
/**
   * Writes the view to the specified uri.
   */
4
  public void write(URI f, URIChooser fc) throws IOException {
    Drawing drawing = view.getDrawing();
    OutputFormat outputFormat = drawing.getOutputFormats().get(0);
    outputFormat.write(new File(f), drawing);
###
1868, getEditor, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 228, 229
3
/**
   * Gets the drawing editor of the view.
   */
2
  public DrawingEditor getEditor() {
    return editor;
###
1869, setEditor, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 215, 221
3
/**
   * Sets a drawing editor for the view.
   */
7
  public void setEditor(DrawingEditor newValue) {
    if (editor != null) {
      editor.remove(view);
    }
    editor = newValue;
    if (editor != null) {
      editor.add(view);
###
1870, initComponents, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 264, 275
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
8
  private void initComponents() {
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
###
1871, init, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 79, 114
3
/**
   * Initializes the view.
   */
36
  public void init() {
    super.init();
    
    initComponents();
    
    JPanel zoomButtonPanel = new JPanel(new BorderLayout());
    scrollPane.setLayout(new PlacardScrollPaneLayout());
    scrollPane.setBorder(new EmptyBorder(0,0,0,0));
    
    setEditor(new DefaultDrawingEditor());
    undo = new UndoRedoManager();
    view.setDrawing(createDrawing());
    view.getDrawing().addUndoableEditListener(undo);
    initActions();
    undo.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        setHasUnsavedChanges(undo.hasSignificantEdits());
      }
    });
    
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    
    JPanel placardPanel = new JPanel(new BorderLayout());
    javax.swing.AbstractButton pButton;
    pButton = ButtonFactory.createZoomButton(view);
    pButton.putClientProperty("Quaqua.Button.style","placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin",new Insets(0,0,0,0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    placardPanel.add(pButton, BorderLayout.WEST);
    pButton = ButtonFactory.createToggleGridButton(view);
    pButton.putClientProperty("Quaqua.Button.style","placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin",new Insets(0,0,0,0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    labels.configureToolBarButton(pButton, "view.toggleGrid.placard");
    placardPanel.add(pButton, BorderLayout.EAST);
    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);
###
1872, initActions, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 151, 153
3
/**
   * Initializes view specific actions.
   */
3
  private void initActions() {
    getActionMap().put(UndoAction.ID, undo.getUndoAction());
    getActionMap().put(RedoAction.ID, undo.getRedoAction());
###
1873, createPageable, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 142, 143
3
/**
   * Creates a Pageable object for printing the view.
   */
2
  public Pageable createPageable() {
    return new DrawingPageable(view.getDrawing());
###
1874, clear, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 235, 249
3
/**
   * Clears the view.
   */
15
  public void clear() {
    final Drawing newDrawing = createDrawing();
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(newDrawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InvocationTargetException ex) {
      ex.printStackTrace();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
###
1875, createDrawing, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 120, 135
3
/**
   * Creates a new Drawing for this view.
   */
16
  protected Drawing createDrawing() {
    Drawing drawing = new QuadTreeDrawing();
    DOMStorableInputOutputFormat ioFormat =
        new DOMStorableInputOutputFormat(new DrawFigureFactory());
    
    drawing.addInputFormat(ioFormat);
    ImageFigure prototype = new ImageFigure();
    drawing.addInputFormat(new ImageInputFormat(prototype));
    drawing.addInputFormat(new TextInputFormat(new TextFigure()));
    TextAreaFigure taf = new TextAreaFigure();
    taf.setBounds(new Point2D.Double(10,10), new Point2D.Double(60,40));
    drawing.addInputFormat(new TextInputFormat(taf));
    
    drawing.addOutputFormat(ioFormat);
    drawing.addOutputFormat(new ImageOutputFormat());
    return drawing;
###
1876, main, Main, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/Main.java, 28, 49
1
/** Creates a new instance. */
21
  public static void main(String[] args) {
    ResourceBundleUtil.setVerbose(true);
    Application app;
    String os = System.getProperty("os.name").toLowerCase();
    if (os.startsWith("mac")) {
      app = new OSXApplication();
    } else if (os.startsWith("win")) {
      //app = new DefaultMDIApplication();
      app = new SDIApplication();
    } else {
      app = new SDIApplication();
    }
    
    DrawApplicationModel model = new DrawApplicationModel();
    model.setName("JHotDraw Draw");
    model.setVersion(Main.class.getPackage().getImplementationVersion());
    model.setCopyright("Copyright 2006-2009 (c) by the authors of JHotDraw and all its contributors.\n" +
        "This software is licensed under LGPL or Creative Commons 3.0 Attribution.");
    model.setViewClassName("org.jhotdraw.samples.draw.DrawView");
    app.setModel(model);
    app.launch(args);
###
1877, AnimationSample, AnimationSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/AnimationSample.java, 33, 56
1
/** Creates new form AnimationSample */
22
  public AnimationSample() {
    initComponents();
    DefaultDrawingView view = new DefaultDrawingView();
    view.setDrawingDoubleBuffered(false);
    add(view);
    setSize(400, 400);
    Drawing d = new DefaultDrawing();
    d.set(CANVAS_FILL_COLOR, new Color(0x76a9d2));
    final EllipseFigure ellipse = new EllipseFigure(160, 160, 80, 80);
    ellipse.set(STROKE_WIDTH, 7d);
    d.add(ellipse);
    view.setDrawing(d);
    Timer t = new Timer(10, new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        double alpha = 2d * Math.PI * (System.currentTimeMillis() % 1000) / 1000d;
        ellipse.willChange();
        ellipse.setBounds(new Rectangle2D.Double(160 + Math.sin(alpha) * 100, 160 + Math.cos(alpha) * 100, 80, 80));
        ellipse.changed();
      }
    });
    t.setRepeats(true);
    t.start();
###
1878, initComponents, AnimationSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/AnimationSample.java, 64, 70
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
5
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    pack();
###
1879, FontChooserMain, FontChooserMain, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/font/FontChooserMain.java, 29, 31
1
/** Creates new form FontChooserMain */
3
  public FontChooserMain() {
    initComponents();
    add(new JFontChooser());
###
1880, initComponents, FontChooserMain, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/font/FontChooserMain.java, 56, 60
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
4
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    setLayout(new java.awt.BorderLayout());
###
1881, getEventSetDescriptors, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 116, 117
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1882, getPropertyDescriptors, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 105, 106
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1883, getDefaultPropertyIndex, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 139, 140
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1886, getBeanDescriptor, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 89, 90
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1888, getDefaultEventIndex, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 150, 151
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1889, getMethodDescriptors, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 127, 128
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1891, initComponents, DrawLiveConnectApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawLiveConnectApplet.java, 206, 228
5
/** This method is called from within the init() method to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
16
  private void initComponents() {//GEN-BEGIN:initComponents
    toolButtonGroup = new javax.swing.ButtonGroup();
    drawingPanel = new org.jhotdraw.samples.draw.DrawingPanel();
    jToolBar1 = new javax.swing.JToolBar();
    loadButton = new javax.swing.JButton();
    saveButton = new javax.swing.JButton();
    FormListener formListener = new FormListener();
    getContentPane().add(drawingPanel, java.awt.BorderLayout.CENTER);
    jToolBar1.setFloatable(false);
    loadButton.setText("Laden");
    loadButton.addActionListener(formListener);
    jToolBar1.add(loadButton);
    saveButton.setText("Speichern");
    saveButton.addActionListener(formListener);
    jToolBar1.add(saveButton);
    getContentPane().add(jToolBar1, java.awt.BorderLayout.SOUTH);
###
1893, init, DrawLiveConnectApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawLiveConnectApplet.java, 41, 136
1
/** Initializes the applet DrawApplet */
86
  public void init() {
    // Set look and feel
    // -----------------
    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Throwable e) {
      // Do nothing.
      // If we can't set the desired look and feel, UIManager does
      // automaticaly the right thing for us.
    }
    // Display copyright info while we are loading the data
    // ----------------------------------------------------
    Container c = getContentPane();
    c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));
    String[] lines = getAppletInfo().split("\n");//Strings.split(getAppletInfo(), '\n');
    for (int i = 0; i < lines.length; i++) {
      c.add(new JLabel(lines[i]));
    }
    // We load the data using a worker thread
    // --------------------------------------
    new Worker<Drawing>() {
      protected Drawing construct() throws IOException {
        Drawing result;
        if (getParameter("data") != null && getParameter("data").length() > 0) {
          NanoXMLDOMInput domi = new NanoXMLDOMInput(new DrawFigureFactory(), new StringReader(getParameter("data")));
          result = (Drawing) domi.readObject(0);
        } else if (getParameter("datafile") != null) {
          InputStream in = null;
          try {
            URL url = new URL(getDocumentBase(), getParameter("datafile"));
            in = url.openConnection().getInputStream();
            NanoXMLDOMInput domi = new NanoXMLDOMInput(new DrawFigureFactory(), in);
            result = (Drawing) domi.readObject(0);
          } finally {
            if (in != null) {
              in.close();
            }
          }
        } else {
          result = null;
        }
        return result;
      }
      protected void done(Drawing result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        initComponents();
        if (result != null) {
          setDrawing(result);
        }
      }
      @Override
      protected void failed(Throwable result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        initComponents();
        getDrawing().add(new TextFigure(result.toString()));
        result.printStackTrace();
      }
      protected void finished() {
        Container c = getContentPane();
        boolean isLiveConnect;
        try {
          Class.forName("netscape.javascript.JSObject");
          isLiveConnect = true;
        } catch (Throwable t) {
          isLiveConnect = false;
        }
        loadButton.setEnabled(isLiveConnect && getParameter("dataread") != null);
        saveButton.setEnabled(isLiveConnect && getParameter("datawrite") != null);
        if (isLiveConnect) {
          String methodName = getParameter("dataread");
          if (methodName.indexOf('(') > 0) {
            methodName = methodName.substring(0, methodName.indexOf('(') - 1);
          }
          JSObject win = JSObject.getWindow(DrawLiveConnectApplet.this);
          Object data = win.call(methodName, new Object[0]);
          if (data instanceof String) {
            setData((String) data);
          }
        }
        c.validate();
      }
    }.start();
###
1894, initComponents, BezierDemo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/BezierDemo.java, 286, 417
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
119
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    jPanel1 = new javax.swing.JPanel();
    toleranceLabel = new javax.swing.JLabel();
    zoomSlider = new javax.swing.JSlider();
    showDigitizedCheck = new javax.swing.JCheckBox();
    showPreprocessedCheck = new javax.swing.JCheckBox();
    showPolylineCheck = new javax.swing.JCheckBox();
    showBezierCheck = new javax.swing.JCheckBox();
    showControlsCheck = new javax.swing.JCheckBox();
    eraseButton = new javax.swing.JButton();
    dumpButton = new javax.swing.JButton();
    setLayout(new java.awt.BorderLayout());
    jPanel1.setBorder(javax.swing.BorderFactory.createEmptyBorder(12, 20, 20, 20));
    jPanel1.setLayout(new java.awt.GridBagLayout());
    toleranceLabel.setText("Zoom:");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(toleranceLabel, gridBagConstraints);
    zoomSlider.setMaximum(800);
    zoomSlider.setMinimum(100);
    zoomSlider.addChangeListener(new javax.swing.event.ChangeListener() {
      public void stateChanged(javax.swing.event.ChangeEvent evt) {
        zoomChanged(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.weightx = 1.0;
    jPanel1.add(zoomSlider, gridBagConstraints);
    showDigitizedCheck.setText("Show Source Points");
    showDigitizedCheck.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        checkboxPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(showDigitizedCheck, gridBagConstraints);
    showPreprocessedCheck.setText("Show Preprocessed Points");
    showPreprocessedCheck.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        checkboxPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(showPreprocessedCheck, gridBagConstraints);
    showPolylineCheck.setSelected(true);
    showPolylineCheck.setText("Show Polyline");
    showPolylineCheck.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        checkboxPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 2;
    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.insets = new java.awt.Insets(0, 20, 0, 0);
    jPanel1.add(showPolylineCheck, gridBagConstraints);
    showBezierCheck.setSelected(true);
    showBezierCheck.setText("Show Bezier Path");
    showBezierCheck.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        checkboxPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 2;
    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.insets = new java.awt.Insets(0, 20, 0, 0);
    jPanel1.add(showBezierCheck, gridBagConstraints);
    showControlsCheck.setText("Show Bezier Controls");
    showControlsCheck.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        checkboxPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(showControlsCheck, gridBagConstraints);
    eraseButton.setText("Erase");
    eraseButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        eraseButtonActionPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 2;
    gridBagConstraints.gridy = 4;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    jPanel1.add(eraseButton, gridBagConstraints);
    dumpButton.setText("Dump");
    dumpButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        dumpButtonActionPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 3;
    gridBagConstraints.gridy = 4;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    jPanel1.add(dumpButton, gridBagConstraints);
    add(jPanel1, java.awt.BorderLayout.NORTH);
###
1897, BezierDemo, BezierDemo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/BezierDemo.java, 233, 249
1
/** Creates new form BezierDemo */
16
  public BezierDemo() {
    initComponents();
    canvas = new Canvas();
    canvas.setOpaque(true);
    canvas.setBackground(Color.WHITE);
    canvas.addMouseListener(handler);
    canvas.addMouseMotionListener(handler);
    add(canvas, BorderLayout.CENTER);
    Point2D.Double[] d = { //  Digitized points 
    };   
    BezierPath digi = new BezierPath();
    digi.addAll(Arrays.asList(d));
    Example ex = new Example();
    examples.add(ex);
    ex.digitized = digi;
    ex.error = 2d;
###
1900, initComponents, DrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanel.java, 157, 191
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
27
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    toolButtonGroup = new javax.swing.ButtonGroup();
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    jPanel1 = new javax.swing.JPanel();
    creationToolbar = new javax.swing.JToolBar();
    attributesToolbar = new javax.swing.JToolBar();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    jPanel1.setLayout(new java.awt.GridBagLayout());
    creationToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(creationToolbar, gridBagConstraints);
    attributesToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(attributesToolbar, gridBagConstraints);
    add(jPanel1, java.awt.BorderLayout.SOUTH);
###
1901, DrawingPanel, DrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanel.java, 64, 129
1
/** Creates new instance. */
62
  public DrawingPanel() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    undoManager = new UndoRedoManager();
    editor = new DefaultDrawingEditor();
    editor.add(view);
    addCreationButtonsTo(creationToolbar, editor);
    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);
    JPopupButton pb = new JPopupButton();
    pb.setItemFont(UIManager.getFont("MenuItem.font"));
    labels.configureToolBarButton(pb, "actions");
    pb.add(new DuplicateAction());
    pb.addSeparator();
    pb.add(new GroupAction(editor));
    pb.add(new UngroupAction(editor));
    pb.addSeparator();
    pb.add(new BringToFrontAction(editor));
    pb.add(new SendToBackAction(editor));
    pb.addSeparator();
    pb.add(new CutAction());
    pb.add(new CopyAction());
    pb.add(new PasteAction());
    pb.add(new SelectAllAction());
    pb.add(new SelectSameAction(editor));
    pb.addSeparator();
    pb.add(undoManager.getUndoAction());
    pb.add(undoManager.getRedoAction());
    // FIXME - We need a toggle grid action!
    // pb.addSeparator();
    // pb.add(new ToggleGridAction(editor));
    JMenu m = new JMenu(labels.getString("view.zoomFactor.text"));
    JRadioButtonMenuItem rbmi;
    ButtonGroup group = new ButtonGroup();
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));
    rbmi.setSelected(true);
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));
    group.add(rbmi);
    pb.add(m);
    pb.setFocusable(false);
    creationToolbar.addSeparator();
    creationToolbar.add(pb);

    DefaultDrawing drawing = new DefaultDrawing();
    view.setDrawing(drawing);
    drawing.addUndoableEditListener(undoManager);
###
1903, initComponents, MessagePanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/MessagePanel.java, 77, 106
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
27
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    iconLabel = new javax.swing.JLabel();
    messageLabel = new javax.swing.JLabel();
    closeButton = new javax.swing.JButton();
    setBackground(new java.awt.Color(255, 255, 255));
    setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));
    setLayout(new java.awt.GridBagLayout());
    add(iconLabel, new java.awt.GridBagConstraints());
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
    add(messageLabel, gridBagConstraints);
    closeButton.setText(labels.getString("messagePanel.close.text")); // NOI18N
    closeButton.setActionCommand("close");
    closeButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        closePerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHEAST;
    gridBagConstraints.insets = new java.awt.Insets(10, 10, 0, 0);
    add(closeButton, gridBagConstraints);
###
1904, MessagePanel, MessagePanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/MessagePanel.java, 38, 39
1
/** Creates new instance. */
2
  public MessagePanel() {
    this(null, null);
###
1906, getPropertyDescriptors, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1907, getDefaultEventIndex, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1908, getEventSetDescriptors, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1909, getDefaultPropertyIndex, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1913, getMethodDescriptors, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1914, getBeanDescriptor, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1915, initComponents, SummaryToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBar.java, 71, 85
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
11
  private void initComponents() {
    summaryLabel = new javax.swing.JLabel();
    summaryField = new javax.swing.JTextField();
    setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
    setFloatable(false);
    setOpaque(false);
    summaryLabel.setFont(new java.awt.Font("Dialog", 0, 11));
    summaryLabel.setText(labels.getString("summary")); // NOI18N
    add(summaryLabel);
    summaryField.setFont(new java.awt.Font("DialogInput", 0, 11));
    add(summaryField);
###
1916, SummaryToolBar, SummaryToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBar.java, 46, 58
1
/** Creates new instance. */
13
  public SummaryToolBar() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    initComponents();
    
    GridBagLayout layout = new GridBagLayout();
    setLayout(layout);
    
    GridBagConstraints gbc;
    gbc = new GridBagConstraints();
    gbc.insets = new Insets(0,10,0,0);
    gbc.weightx = 1d;
    gbc.fill = GridBagConstraints.HORIZONTAL;
    layout.setConstraints(summaryField, gbc);
###
1917, getBeanDescriptor, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1920, getPropertyDescriptors, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1921, getDefaultPropertyIndex, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1922, getEventSetDescriptors, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1923, getMethodDescriptors, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1924, getDefaultEventIndex, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1926, ProgressIndicator, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 31, 32
1
/** Creates new instance. */
2
  public ProgressIndicator() {
    this(null, null);
###
1927, getMinimum, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 95, 96
6
/**
   * Returns the minimum value -- the lower end of the progress value.
   *
   * @return an int representing the minimum value
   * @see #setMinimum
   */
2
  public int getMinimum() {
    return progressModel.getMinimum();
###
1928, setMaximum, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 136, 137
6
/**
   * Specifies the maximum value.
   *
   * @param m  an int specifying the maximum value
   * @see #getMaximum
   */
2
  public void setMaximum(int m) {
    progressModel.setMaximum(m);
###
1929, getMaximum, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 125, 126
6
/**
   * Returns the maximum value -- the higher end of the progress value.
   *
   * @return an int representing the maximum value
   * @see #setMaximum
   */
2
  public int getMaximum() {
    return progressModel.getMaximum();
###
1930, setMinimum, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 106, 107
6
/**
   * Specifies the minimum value.
   *
   * @param m  an int specifying the minimum value
   * @see #getMinimum
   */
2
  public void setMinimum(int m) {
    progressModel.setMinimum(m);
###
1931, ProgressIndicator, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 41, 54
1
/** Creates new instance. */
14
  public ProgressIndicator(
      String message,
      String note,
      int min,
      int max,
      boolean indeterminate) {
    initComponents();
    
    messageLabel.setFont(messageLabel.getFont().deriveFont(Font.BOLD));
    progressModel = new DefaultBoundedRangeModel(0, 0, min, max);
    progressBar.setModel(progressModel);
    setMessage(message);
    setNote(note);
    setIndeterminate(indeterminate);
###
1932, initComponents, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 154, 178
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
21
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    messageLabel = new javax.swing.JLabel();
    noteLabel = new javax.swing.JLabel();
    progressBar = new javax.swing.JProgressBar();
    setBackground(new java.awt.Color(255, 255, 255));
    setLayout(new java.awt.GridBagLayout());
    messageLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    add(messageLabel, gridBagConstraints);
    noteLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
    add(noteLabel, gridBagConstraints);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
    add(progressBar, gridBagConstraints);
###
1933, setProgress, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 115, 116
5
/**
   * Indicate the progress of the operation being monitored.
   * @param nv an int specifying the current value, between the
   *    maximum and minimum specified for this component
   */
2
  public void setProgress(int nv) {
    progressModel.setValue(nv);
###
1934, ProgressIndicator, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 35, 38
1
/** Creates new instance. */
4
  public ProgressIndicator(
      String message,
      String note) {
    this(message, note, 0, 100, true);
###
1936, getDefaultEventIndex, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1939, getMethodDescriptors, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1940, getDefaultPropertyIndex, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1941, getPropertyDescriptors, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1942, getEventSetDescriptors, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1943, getBeanDescriptor, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1945, ODGRectRadiusHandle, ODGRectRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectRadiusHandle.java, 40, 41
1
/** Creates a new instance. */
2
  public ODGRectRadiusHandle(Figure owner) {
    super(owner);
###
1946, draw, ODGRectRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectRadiusHandle.java, 47, 48
3
/**
   * Draws this handle.
   */
2
  public void draw(Graphics2D g) {
    drawDiamond(g, Color.yellow, Color.black);
###
1947, StrokeToolBar, StrokeToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBar.java, 45, 48
1
/** Creates new instance. */
4
  public StrokeToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString("stroke.toolbar"));
    setDisclosureStateCount(3);
###
1948, ToolsToolBar, ToolsToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBar.java, 45, 47
1
/** Creates new instance. */
3
  public ToolsToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString("tools.toolbar"));
###
1949, getInsets, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 338, 341
3
/**
   * Returns the insets used to draw text.
   */
4
  public Insets2D.Double getInsets() {
    double sw = Math.ceil(get(STROKE_WIDTH) / 2);
    Insets2D.Double insets = new Insets2D.Double(4, 4, 4, 4);
    return new Insets2D.Double(insets.top + sw, insets.left + sw, insets.bottom + sw, insets.right + sw);
###
1950, drawParagraph, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 151, 280
16
/**
   * Draws or measures a paragraph of text at the specified y location and
   * the bounds of the paragraph.
   *
   * @param g Graphics object. This parameter is null, if we want to
   *  measure the size of the paragraph.
   * @param styledText the text of the paragraph.
   * @param verticalPos the top bound of the paragraph
   * @param maxVerticalPos the bottom bound of the paragraph
   * @param leftMargin the left bound of the paragraph
   * @param rightMargin the right bound of the paragraph
   * @param tabStops an array with tab stops
   * @param tabCount the number of entries in tabStops which contain actual
   *    values
   * @return Returns the actual bounds of the paragraph.
   */
109
  private Rectangle2D.Double drawParagraph(Graphics2D g, AttributedCharacterIterator styledText,
      float verticalPos, float maxVerticalPos, float leftMargin, float rightMargin, float[] tabStops, int tabCount) {
    // This method is based on the code sample given
    // in the class comment of java.awt.font.LineBreakMeasurer, 
    // assume styledText is an AttributedCharacterIterator, and the number
    // of tabs in styledText is tabCount
    Rectangle2D.Double paragraphBounds = new Rectangle2D.Double(leftMargin, verticalPos, 0, 0);
    int[] tabLocations = new int[tabCount + 1];
    int i = 0;
    for (char c = styledText.first(); c != styledText.DONE; c = styledText.next()) {
      if (c == '\t') {
        tabLocations[i++] = styledText.getIndex();
      }
    }
    tabLocations[tabCount] = styledText.getEndIndex() - 1;
    // Now tabLocations has an entry for every tab's offset in
    // the text.  For convenience, the last entry is tabLocations
    // is the offset of the last character in the text.
    LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, getFontRenderContext());
    int currentTab = 0;
    while (measurer.getPosition() < styledText.getEndIndex() &&
        verticalPos <= maxVerticalPos) {
      // Lay out and draw each line.  All segments on a line
      // must be computed before any drawing can occur, since
      // we must know the largest ascent on the line.
      // TextLayouts are computed and stored in a List;
      // their horizontal positions are stored in a parallel
      // List.
      // lineContainsText is true after first segment is drawn
      boolean lineContainsText = false;
      boolean lineComplete = false;
      float maxAscent = 0, maxDescent = 0;
      float horizontalPos = leftMargin;
      LinkedList<TextLayout> layouts = new LinkedList<TextLayout>();
      LinkedList<Float> penPositions = new LinkedList<Float>();
      int first = layouts.size();
      while (!lineComplete && verticalPos <= maxVerticalPos) {
        float wrappingWidth = rightMargin - horizontalPos;
        TextLayout layout = null;
        layout =
            measurer.nextLayout(wrappingWidth,
            tabLocations[currentTab] + 1,
            lineContainsText);
        // layout can be null if lineContainsText is true
        if (layout != null) {
          layouts.add(layout);
          penPositions.add(horizontalPos);
          horizontalPos += layout.getAdvance();
          maxAscent = Math.max(maxAscent, layout.getAscent());
          maxDescent = Math.max(maxDescent,
              layout.getDescent() + layout.getLeading());
        } else {
          lineComplete = true;
        }
        lineContainsText = true;
        if (measurer.getPosition() == tabLocations[currentTab] + 1) {
          currentTab++;
        }
        if (measurer.getPosition() == styledText.getEndIndex()) {
          lineComplete = true;
        } else if (tabStops.length == 0 || horizontalPos >= tabStops[tabStops.length - 1]) {
          lineComplete = true;
        }
        if (!lineComplete) {
          // move to next tab stop
          int j;
          for (j = 0; horizontalPos >= tabStops[j]; j++) {
          }
          horizontalPos = tabStops[j];
        }
      }
      // If there is only one layout element on the line, and we are
      // drawing, then honor alignemnt
      if (first == layouts.size() - 1 && g != null) {
        switch (get(TEXT_ALIGNMENT)) {
          case TRAILING:
            penPositions.set(first, rightMargin - layouts.get(first).getVisibleAdvance() - 1);
            break;
          case CENTER:
            penPositions.set(first, (rightMargin - 1 - leftMargin - layouts.get(first).getVisibleAdvance()) / 2 + leftMargin);
            break;
          case BLOCK:
            // not supported
            break;
          case LEADING:
          default:
            break;
        }
      }

      verticalPos += maxAscent;
      Iterator<TextLayout> layoutEnum = layouts.iterator();
      Iterator<Float> positionEnum = penPositions.iterator();
      // now iterate through layouts and draw them
      while (layoutEnum.hasNext()) {
        TextLayout nextLayout = layoutEnum.next();
        float nextPosition = positionEnum.next();
        if (g != null) {
          nextLayout.draw(g, nextPosition, verticalPos);
        }
        Rectangle2D layoutBounds = nextLayout.getBounds();
        paragraphBounds.add(new Rectangle2D.Double(layoutBounds.getX() + nextPosition,
            layoutBounds.getY() + verticalPos,
            layoutBounds.getWidth(),
            layoutBounds.getHeight()));
      }
      verticalPos += maxDescent;
    }
    return paragraphBounds;
###
1951, TextAreaFigure, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 74, 76
1
/** Creates a new instance. */
3
  public TextAreaFigure() {
    this(ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels").
        getString("TextFigure.defaultText"));
###
1952, getText, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 331, 332
3
/**
   * Gets the text shown by the text figure.
   */
2
  public String getText() {
    return (String) get(TEXT);
###
1953, setText, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 355, 356
3
/**
   * Sets the text shown by the text figure.
   */
2
  public void setText(String newText) {
    set(TEXT, newText);
###
1954, getTool, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 396, 401
4
/**
   * Returns a specialized tool for the given coordinate.
   * <p>Returns null, if no specialized tool is available.
   */
6
  public Tool getTool(Point2D.Double p) {
    if (isEditable() && contains(p)) {
      TextAreaEditingTool tool = new TextAreaEditingTool(this);
      return tool;
    }
    return null;
###
1961, getPreferredTextSize, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 474, 508
10
/**
   * Returns the preferred text size of the TextAreaFigure.
   * <p>
   * If you want to use this method to determine the bounds of the TextAreaFigure,
   * you need to add the insets of the TextAreaFigure to the size.
   * 
   * @param maxWidth the maximal width to use. Specify Double.MAX_VALUE
   * if you want the width to be unlimited.
   * @return width and height needed to lay out the text.
   */
33
  public Dimension2DDouble getPreferredTextSize(double maxWidth) {
    Rectangle2D.Double textRect = new Rectangle2D.Double();
    if (getText() != null) {
      Font font = getFont();
      boolean isUnderlined = get(FONT_UNDERLINE);
      float leftMargin = 0;
      float rightMargin = (float) maxWidth - 1;
      float verticalPos = 0;
      float maxVerticalPos = Float.MAX_VALUE;
      if (leftMargin < rightMargin) {
        float tabWidth = (float) (getTabSize() * font.getStringBounds("m", getFontRenderContext()).getWidth());
        float[] tabStops = new float[(int) (textRect.width / tabWidth)];
        for (int i = 0; i < tabStops.length; i++) {
          tabStops[i] = (float) (textRect.x + (int) (tabWidth * (i + 1)));
        }
        String[] paragraphs = getText().split("\n");//Strings.split(getText(), '\n');
        for (int i = 0; i < paragraphs.length; i++) {
          if (paragraphs[i].length() == 0) {
            paragraphs[i] = " ";
          }
          AttributedString as = new AttributedString(paragraphs[i]);
          as.addAttribute(TextAttribute.FONT, font);
          if (isUnderlined) {
            as.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_LOW_ONE_PIXEL);
          }
          int tabCount = paragraphs[i].split("\t").length - 1;
          Rectangle2D.Double paragraphBounds = drawParagraph(null, as.getIterator(), verticalPos, maxVerticalPos, leftMargin, rightMargin, tabStops, tabCount);
          verticalPos = (float) (paragraphBounds.y + paragraphBounds.height);
          textRect.add(paragraphBounds);
        }
      }
    }
    return new Dimension2DDouble(-Math.min(textRect.x, 0) + textRect.width, -Math.min(textRect.y, 0) + textRect.height);
###
1962, readCustomShapeElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 445, 461
7
/** A <draw:custom-shape> represents a shape that is capable of rendering
   * complex figures. It is offering font work and extrusion functiona-
   * lity. A custom shape may have a geometry that influences its shape.
   * This geometry may be visualized in office application user
   * interfaces, for instance by displaying interaction handles, that
   * provide a simple way to modify the geometry.
   */
14
  private ODGFigure readCustomShapeElement(IXMLElement elem)
      throws IOException {
    String styleName = elem.getAttribute("style-name", DRAWING_NAMESPACE, null);
    Map<AttributeKey, Object> a = styles.getAttributes(styleName, "graphic");
    Rectangle2D.Double figureBounds = new Rectangle2D.Double(
        toLength(elem.getAttribute("x", SVG_NAMESPACE, "0"), 1),
        toLength(elem.getAttribute("y", SVG_NAMESPACE, "0"), 1),
        toLength(elem.getAttribute("width", SVG_NAMESPACE, "0"), 1),
        toLength(elem.getAttribute("height", SVG_NAMESPACE, "0"), 1));
    ODGFigure figure = null;
    for (IXMLElement child : elem.getChildrenNamed("enhanced-geometry", DRAWING_NAMESPACE)) {
      figure = readEnhancedGeometryElement(child, a, figureBounds);
    }
    return figure;
###
1963, createPolylineFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 579, 591
3
/**
   * Creates a Polyline figure.
   */
13
  private ODGFigure createPolylineFigure(
      Point2D.Double[] points,
      Map<AttributeKey, Object> a)
      throws IOException {
    ODGPathFigure figure = new ODGPathFigure();
    ODGBezierFigure bezier = new ODGBezierFigure();
    for (Point2D.Double p : points) {
      bezier.addNode(new BezierPath.Node(p.x, p.y));
    }
    figure.removeAllChildren();
    figure.add(bezier);
    figure.setAttributes(a);
    return figure;
###
1964, toLength, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 892, 922
4
/**
   * Returns a value as a length.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength
   */
29
  private double toLength(String str, double percentFactor) throws IOException {
    double scaleFactor = 1d;
    if (str == null || str.length() == 0) {
      return 0d;
    }
    if (str.endsWith("%")) {
      str = str.substring(0, str.length() - 1);
      scaleFactor = percentFactor;
    } else if (str.endsWith("px")) {
      str = str.substring(0, str.length() - 2);
    } else if (str.endsWith("pt")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 1.25;
    } else if (str.endsWith("pc")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 15;
    } else if (str.endsWith("mm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 3.543307;
    } else if (str.endsWith("cm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 35.43307;
    } else if (str.endsWith("in")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 90;
    } else {
      scaleFactor = 1d;
    }
    return Double.parseDouble(str) * scaleFactor;
###
1965, readAllBytes, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 100, 107
3
/**
   * Reads all bytes from the InputStreams until EOF is reached.
   */
8
  private byte[] readAllBytes(InputStream in) throws IOException {
    ByteArrayOutputStream tmp = new ByteArrayOutputStream();
    byte[] buf = new byte[512];
    for (int len; -1 != (len = in.read(buf));) {
      tmp.write(buf, 0, len);
    }
    tmp.close();
    return tmp.toByteArray();
###
1966, createPolygonFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 597, 610
3
/**
   * Creates a Polygon figure.
   */
14
  private ODGFigure createPolygonFigure(
      Point2D.Double[] points,
      Map<AttributeKey, Object> a)
      throws IOException {
    ODGPathFigure figure = new ODGPathFigure();
    ODGBezierFigure bezier = new ODGBezierFigure();
    for (Point2D.Double p : points) {
      bezier.addNode(new BezierPath.Node(p.x, p.y));
    }
    bezier.setClosed(true);
    figure.removeAllChildren();
    figure.add(bezier);
    figure.setAttributes(a);
    return figure;
###
1967, readPolygonElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 784, 801
20
/**
   * The &lt;draw:polygon&gt; element represents a polygon. A polygon is a
   * closed put of straight lines.
   * Some implementations may ignore the size attribute, and instead determine
   * the size of a shape exclusively from the shape data (i.e., polygon vertices).
   * <p>
   * The attributes that may be associated with the &lt;draw:polygon&gt; element
   * are:
   * • Position, Size, View box, Style, Layer, Z-Index, ID, Caption ID and
   * Transformation – see section 9.2.15
   * • Text anchor, table background, draw end position – see section 9.2.16
   * • Points – see section 9.2.3
   * The elements that may be contained in the &lt;draw:polygon&gt; element are:
   * • Title (short accessible name) – see section 9.2.20.
   * • Long description (in support of accessibility) – see section 9.2.20.
   * • Event listeners – see section 9.2.21.
   * • Glue points – see section 9.2.19.
   * • Text – see section 9.2.17.
   *
   */
15
  private ODGFigure readPolygonElement(IXMLElement elem)
      throws IOException {
    AffineTransform viewBoxTransform = readViewBoxTransform(elem);
    String[] coords = toWSOrCommaSeparatedArray(elem.getAttribute("points", DRAWING_NAMESPACE, null));
    Point2D.Double[] points = new Point2D.Double[coords.length / 2];
    for (int i = 0; i < coords.length; i += 2) {
      Point2D.Double p = new Point2D.Double(toNumber(coords[i]), toNumber(coords[i + 1]));
      points[i / 2] = (Point2D.Double) viewBoxTransform.transform(p, p);
    }
    String styleName = elem.getAttribute("style-name", DRAWING_NAMESPACE, null);
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    a.putAll(styles.getAttributes(styleName, "graphic"));
    readCommonDrawingShapeAttributes(elem, a);
    ODGFigure f = createPolygonFigure(points, a);
    return f;
###
1968, sort, QuadTreeCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeCompositeFigure.java, 87, 95
3
/**
   * Implementation note: Sorting can not be done for orphaned children.
   */
9
  public java.util.List<Figure> sort(Collection<Figure> c) {
    ensureSorted();
    ArrayList<Figure> sorted = new ArrayList<Figure>(c.size());
    for (Figure f : children) {
      if (c.contains(f)) {
        sorted.add(f);
      }
    }
    return sorted;
###
1969, QuadTreeCompositeFigure, QuadTreeCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeCompositeFigure.java, 46, 47
1
/** Creates a new instance. */
2
  public QuadTreeCompositeFigure() {
    figureHandler = createFigureHandler();
###
1970, getFiguresFrontToBack, QuadTreeCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeCompositeFigure.java, 131, 133
4
/**
   * Returns an iterator to iterate in
   * Z-order front to back over the children.
   */
3
  public java.util.List<Figure> getFiguresFrontToBack() {
    ensureSorted();
    return new ReversedList<Figure>(children);
###
1971, toEnhancedPath, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 968, 1199
23
/**
   * Returns a value as a EnhancedPath array.
   *
   * The draw:enhanced-path attribute specifies a path similar to the svg:d attribute of the
   * <svg:path> element. Instructions such as moveto, lineto, arcto and other instructions
   * together with its parameter are describing the geometry of a shape which can be filled and or
   * stroked. Relative commands are not supported.
   * The syntax of draw:enhanced-path attribute is as follows:
   * • Instructions are expressed as one character (e.g., a moveto is expressed as an M).
   * • A prefix notation is being used, that means that each command is followed by its parameter.
   * • Superfluous white space and separators such as commas can be eliminated. (e.g., “M 10 10
   * L 20 20 L 30 20” can also be written: “M10 10L20 20L30 20”
   * • If the command is repeated multiple times, only the first command is required. (e.g., “M 10 10
   * L 20 20 L 30 20” can also be expressed as followed “M 10 10 L 20 20 30 20”
   * • Floats can be used, therefore the only allowable decimal point is a dot (“.”)
   * The above mentioned rules are the same as specified for the <svg:path> element.
   * A parameter can also have one of the following enhancements:
   * • A “?” is used to mark the beginning of a formula name. The result of the element's
   * draw:formula attribute is used as parameter value in this case.
   * • If “$” is preceding a integer value, the value is indexing a draw:modifiers attribute. The
   * corresponding modifier value is used as parameter value then.
   *
   */
216
  private EnhancedPath toEnhancedPath(String str) throws IOException {
    if (DEBUG) {
      System.out.println("ODGInputFormat toEnhancedPath " + str);
    }
    EnhancedPath path = null;
    Object x, y;
    Object x1, y1, x2, y2, x3, y3;
    StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));
    tt.resetSyntax();
    tt.parseNumbers();
    tt.parseExponents();
    tt.parsePlusAsNumber();
    tt.whitespaceChars(0, ' ');
    tt.whitespaceChars(',', ',');

    char nextCommand = 'M';
    char command = 'M';
    Commands:
    while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
      if (tt.ttype > 0) {
        command = (char) tt.ttype;
      } else {
        command = nextCommand;
        tt.pushBack();
      }
      nextCommand = command;
      switch (command) {
        case 'M':
          // moveto (x y)+
          // Start a new sub-path at the given (x,y)
          // coordinate. If a moveto is followed by multiple
          // pairs of coordinates, they are treated as lineto.
          if (path == null) {
            path = new EnhancedPath();
          }
          // path.setFilled(isFilled);
          //path.setStroked(isStroked);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.moveTo(x, y);
          nextCommand = 'L';
          break;
        case 'L':
          // lineto (x y)+
          // Draws a line from the current point to (x, y). If
          // multiple coordinate pairs are following, they
          // are all interpreted as lineto.
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.lineTo(x, y);
          break;
        case 'C':
          // curveto (x1 y1 x2 y2 x y)+
          // Draws a cubic Bézier curve from the current
          // point to (x,y) using (x1,y1) as the control point
          // at the beginning of the curve and (x2,y2) as
          // the control point at the end of the curve.
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.curveTo(x1, y1, x2, y2, x, y);
          break;
        case 'Z':
          // closepath
          // Close the current sub-path by drawing a
          // straight line from the current point to current
          // sub-path's initial point.
          path.close();
          break;
        case 'N':
          // endpath
          // Ends the current put of sub-paths. The sub-
          // paths will be filled by using the “even-odd”
          // filling rule. Other following subpaths will be
          // filled independently.
          break;
        case 'F':
          // nofill
          // Specifies that the current put of sub-paths
          // won't be filled.
          break;
        case 'S':
          // nostroke
          // Specifies that the current put of sub-paths
          // won't be stroked.
          break;
        case 'T':
          // angle-ellipseto (x y w h t0 t1) +
          // Draws a segment of an ellipse. The ellipse is specified
          // by the center(x, y), the size(w, h) and the start-angle
          // t0 and end-angle t1.
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          path.ellipseTo(x, y, x1, y1, x2, y2);
          break;
        case 'U':
          // angle-ellipse (x y w h t0 t1) +
          // The same as the “T” command, except that a implied moveto
          // to the starting point is done.
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          path.moveTo(x1, y1);
          path.ellipseTo(x, y, x1, y1, x2, y2);
          break;
        case 'A':
          // arcto (x1 y1 x2 y2 x3 y3 x y) +
          // (x1, y1) and (x2, y2) is defining the bounding
          // box of a ellipse. A line is then drawn from the
          // current point to the start angle of the arc that is
          // specified by the radial vector of point (x3, y3)
          // and then counter clockwise to the end-angle
          // that is specified by point (x4, y4).
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          x3 = nextEnhancedCoordinate(tt, str);
          y3 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.arcTo(x1, y1, x2, y2, x3, y3, x, y);
          break;
        case 'B':
          // arc (x1 y1 x2 y2 x3 y3 x y) +
          // The same as the “A” command, except that a
          // implied moveto to the starting point is done.
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          x3 = nextEnhancedCoordinate(tt, str);
          y3 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.moveTo(x1, y1);
          path.arcTo(x1, y1, x2, y2, x3, y3, x, y);
          break;
        case 'W':
          // clockwisearcto (x1 y1 x2 y2 x3 y3 x y) +
          // The same as the “A” command except, that the arc is drawn
          // clockwise.
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          x3 = nextEnhancedCoordinate(tt, str);
          y3 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.clockwiseArcTo(x1, y1, x2, y2, x3, y3, x, y);
          break;
        case 'V':
          // clockwisearc (x1 y1 x2 y2 x3 y3 x y)+
          // The same as the “A” command, except that a implied moveto
          // to the starting point is done and the arc is drawn
          // clockwise.
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          x3 = nextEnhancedCoordinate(tt, str);
          y3 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.moveTo(x1, y1);
          path.clockwiseArcTo(x1, y1, x2, y2, x3, y3, x, y);
          break;
        case 'X':
          // elliptical-quadrantx (x y) +
          // Draws a quarter ellipse, whose initial segment is
          // tangential to the x-axis, is drawn from the
          // current point to (x, y).
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.quadrantXTo(x, y);
          break;
        case 'Y':
          // elliptical-quadranty (x y) +
          // Draws a quarter ellipse, whose initial segment is
          // tangential to the y-axis, is drawn from the
          // current point to(x, y).
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.quadrantYTo(x, y);
          break;
        case 'Q':
          // quadratic-curveto(x1 y1 x y)+
          // Draws a quadratic Bézier curve from the current point
          // to(x, y) using(x1, y1) as the control point. (x, y)
          // becomes the new current point at the end of the command.
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.quadTo(x1, y1, x, y);
          break;
        default:
          if (DEBUG) {
            System.out.println("ODGInputFormat.toEnhancedPath aborting after illegal path command: " + command + " found in path " + str);
          }
          break Commands;
        //throw new IOException("Illegal command: "+command);
      }
    }
    return path;
###
1972, createLineFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 566, 573
3
/**
   * Creates a Line figure.
   */
8
  private ODGFigure createLineFigure(
      Point2D.Double p1, Point2D.Double p2,
      Map<AttributeKey, Object> a)
      throws IOException {
    ODGPathFigure figure = new ODGPathFigure();
    figure.setBounds(p1, p2);
    figure.setAttributes(a);
    return figure;
###
1973, readPolylineElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 822, 839
18
/**
   * The &lt;draw:polyline&gt; element represents a polyline drawing shape.
   * Some implementations may ignore the size attribute, and instead determine the size of a shape
   * exclusively from the shape data (i.e., polygon vertices).
   * <p>
   * The attributes that may be associated with the &lt;draw:polyline&gt;
   * element are:
   * • Position, Size, View box, Style, Layer, Z-Index, ID, Caption ID and Transformation – see
   * section 9.2.15
   * • Text anchor, table background, draw end position – see section 9.2.16
   * • Points
   * The elements that may be contained in the &lt;draw:polyline&gt; element are:
   * • Title (short accessible name) – see section 9.2.20.
   * • Long description (in support of accessibility) – see section 9.2.20.
   * • Event listeners – see section 9.2.21.
   * • Glue points – see section 9.2.19.
   * • Text – see section 9.2.17.
   */
15
  private ODGFigure readPolylineElement(IXMLElement elem)
      throws IOException {
    AffineTransform viewBoxTransform = readViewBoxTransform(elem);
    String[] coords = toWSOrCommaSeparatedArray(elem.getAttribute("points", DRAWING_NAMESPACE, null));
    Point2D.Double[] points = new Point2D.Double[coords.length / 2];
    for (int i = 0; i < coords.length; i += 2) {
      Point2D.Double p = new Point2D.Double(toNumber(coords[i]), toNumber(coords[i + 1]));
      points[i / 2] = (Point2D.Double) viewBoxTransform.transform(p, p);
    }
    String styleName = elem.getAttribute("style-name", DRAWING_NAMESPACE, null);
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    a.putAll(styles.getAttributes(styleName, "graphic"));
    readCommonDrawingShapeAttributes(elem, a);
    ODGFigure f = createPolylineFigure(points, a);
    return f;
###
1974, readLineElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 729, 743
18
/**
   * The &lt;draw:line&gt; element represents a line.
   * <p>
   * The attributes that may be associated with the &lt;draw:line&gt; element
   * are:
   * • Style, Layer, Z-Index, ID, Caption ID and Transformation – see section
   * 9.2.15.
   * • Text anchor, table background, draw end position– see section 9.2.16.
   * • Start point
   * • End point
   * <p>
   * The elements that may be contained in the &lt;draw:line&gt; element are:
   * • Title (short accessible name) – see section 9.2.20.
   * • Long description (in support of accessibility) – see section 9.2.20.
   * • Event listeners – see section 9.2.21.
   * • Glue points – see section 9.2.19.
   * • Text – see section 9.2.17.
   */
12
  private ODGFigure readLineElement(IXMLElement elem)
      throws IOException {
    Point2D.Double p1 = new Point2D.Double(
        toLength(elem.getAttribute("x1", SVG_NAMESPACE, "0"), 1),
        toLength(elem.getAttribute("y1", SVG_NAMESPACE, "0"), 1));
    Point2D.Double p2 = new Point2D.Double(
        toLength(elem.getAttribute("x2", SVG_NAMESPACE, "0"), 1),
        toLength(elem.getAttribute("y2", SVG_NAMESPACE, "0"), 1));
    String styleName = elem.getAttribute("style-name", DRAWING_NAMESPACE, null);
    Map<AttributeKey, Object> a = styles.getAttributes(styleName, "graphic");
    ODGFigure f = createLineFigure(p1, p2, a);
    return f;
###
1975, toNumber, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 884, 885
4
/**
   * Returns a value as a number.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeNumber
   */
2
  private double toNumber(String str) throws IOException {
    return toLength(str, 100);
###
1976, createPathFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 616, 628
3
/**
   * Creates a Path figure.
   */
13
  private ODGFigure createPathFigure(
      BezierPath[] paths,
      Map<AttributeKey, Object> a)
      throws IOException {
    ODGPathFigure figure = new ODGPathFigure();
    figure.removeAllChildren();
    for (BezierPath p : paths) {
      ODGBezierFigure bezier = new ODGBezierFigure();
      bezier.setBezierPath(p);
      figure.add(bezier);
    }
    figure.setAttributes(a);
    return figure;
###
1977, createGroupFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 684, 687
3
/**
   * Creates a ODGGroupFigure.
   */
4
  private CompositeFigure createGroupFigure()
      throws IOException {
    ODGGroupFigure figure = new ODGGroupFigure();
    return figure;
###
1978, readDrawingElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 226, 273
3
/**
   * Reads an ODG "office:drawing" element.
   */
44
  private void readDrawingElement(IXMLElement elem)
      throws IOException {
    /*
    2.3.2Drawing Documents
    The content of drawing document consists of a sequence of draw pages.
    <define name="office-body-content" combine="choice">
    <element name="office:drawing">
    <ref name="office-drawing-attlist"/>
    <ref name="office-drawing-content-prelude"/>
    <ref name="office-drawing-content-main"/>
    <ref name="office-drawing-content-epilogue"/>
    </element>
    </define>
    <define name="office-drawing-attlist">
    <empty/>
    </define>
    Drawing Document Content Model
    The drawing document prelude may contain text declarations only. To allow office applications to
    implement functionality that usually is available in spreadsheets for drawing documents, it may
    also contain elements that implement enhanced table features. See also section 2.3.4.
    <define name="office-drawing-content-prelude">
    <ref name="text-decls"/>
    <ref name="table-decls"/>
    </define>
    The main document content contains a sequence of draw pages.
    <define name="office-drawing-content-main">
    <zeroOrMore>
    <ref name="draw-page"/>
    </zeroOrMore>
    </define>
    There are no drawing documents specific epilogue elements, but the epilogue may contain
    elements that implement enhanced table features. See also section 2.3.4.
    <define name="office-drawing-content-epilogue">
    <ref name="table-functions"/>
    </define>
     */
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        if (child.getNamespace() == null ||
            child.getNamespace().equals(DRAWING_NAMESPACE)) {
          String name = child.getName();
          if (name.equals("page")) {
            readPageElement(child);
###
1979, createEnhancedGeometryEllipseFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 542, 548
3
/**
   * Creates a Ellipse figure.
   */
7
  private ODGFigure createEnhancedGeometryEllipseFigure(
      Rectangle2D.Double bounds, Map<AttributeKey, Object> a)
      throws IOException {
    ODGEllipseFigure figure = new ODGEllipseFigure();
    figure.setBounds(bounds);
    figure.setAttributes(a);
    return figure;
###
1981, createEnhancedGeometryRectangleFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 554, 560
3
/**
   * Creates a Rect figure.
   */
7
  private ODGFigure createEnhancedGeometryRectangleFigure(
      Rectangle2D.Double bounds, Map<AttributeKey, Object> a)
      throws IOException {
    ODGRectFigure figure = new ODGRectFigure();
    figure.setBounds(bounds);
    figure.setAttributes(a);
    return figure;
###
1982, readPageElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 283, 340
3
/**
   * Reads an ODG "draw:page" element.
   */
58
  private void readPageElement(IXMLElement elem)
      throws IOException {
    /* 9.1.4Drawing Pages
     *
    The element <draw:page> is a container for content in a drawing or presentation document.
    Drawing pages are used for the following:
    • Forms (see section 11.1)
    • Drawings (see section 9.2)
    • Frames (see section 9.3)
    • Presentation Animations (see section 9.7)
    • Presentation Notes (see section 9.1.5)
     *
    A master page must be assigned to each drawing page.
     *
    <define name="draw-page">
    <element name="draw:page">
    <ref name="common-presentation-header-footer-attlist"/>
    <ref name="draw-page-attlist"/>
    <optional>
    <ref name="office-forms"/>
    </optional>
    <zeroOrMore>
    <ref name="shape"/>
    </zeroOrMore>
    <optional>
    <choice>
    <ref name="presentation-animations"/>
    <ref name="animation-element"/>
    </choice>
    </optional>
    <optional>
    <ref name="presentation-notes"/>
    </optional>
    </element>
    </define>
     *
    The attributes that may be associated with the <draw:page> element are:
    • Page name
    • Page style
    • Master page
    • Presentation page layout
    • Header declaration
    • Footer declaration
    • Date and time declaration
    • ID
     *
    The elements that my be included in the <draw:page> element are:
    • Forms
    • Shapes
    • Animations
    • Presentation notes
     */
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        ODGFigure figure = readElement(child);
        if (figure != null) {
          figures.add(figure);
###
1983, getFigureDrawingArea, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 131, 148
3
/**
   * Gets the drawing area without taking the decorator into account.
   */
18
  protected Rectangle2D.Double getFigureDrawingArea() {
    if (getText() == null) {
      return getBounds();
    } else {
      TextLayout layout = getTextLayout();
      Rectangle2D.Double r = new Rectangle2D.Double(
          origin.x, origin.y, layout.getAdvance(), layout.getAscent());
      Rectangle2D lBounds = layout.getBounds();
      if (!lBounds.isEmpty() && !Double.isNaN(lBounds.getX())) {
        r.add(new Rectangle2D.Double(
            lBounds.getX() + origin.x,
            (lBounds.getY() + origin.y + layout.getAscent()),
            lBounds.getWidth(),
            lBounds.getHeight()));
      }
      // grow by two pixels to take antialiasing into account
      Geom.grow(r, 2d, 2d);
      return r;
###
1984, setText, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 175, 176
5
/**
   * Sets the text shown by the text figure.
   * This is a convenience method for calling willChange,
   * AttribuTEXT.basicSet, changed.
   */
2
  public void setText(String newText) {
    set(TEXT, newText);
###
1985, readElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 349, 425
3
/**
   * Reads an ODG element.
   */
77
  private ODGFigure readElement(IXMLElement elem)
      throws IOException {
    /*
    Drawing Shapes
    This section describes drawing shapes that might occur within all kind of applications.
    <define name="shape">
    <choice>
    <ref name="draw-rect"/>
    <ref name="draw-line"/>
    <ref name="draw-polyline"/>
    <ref name="draw-polygon"/>
    <ref name="draw-regular-polygon"/>
    <ref name="draw-path"/>
    <ref name="draw-circle"/>
    <ref name="draw-ellipse"/>
    <ref name="draw-g"/>
    <ref name="draw-page-thumbnail"/>
    <ref name="draw-frame"/>
    <ref name="draw-measure"/>
    <ref name="draw-caption"/>
    <ref name="draw-connector"/>
    <ref name="draw-control"/>
    <ref name="dr3d-scene"/>
    <ref name="draw-custom-shape"/>
    </choice>
    </define>
     */
    ODGFigure f = null;
    if (elem.getNamespace() == null ||
        elem.getNamespace().equals(DRAWING_NAMESPACE)) {
      String name = elem.getName();
      if (name.equals("caption")) {
        f = readCaptionElement(elem);
      } else if (name.equals("circle")) {
        f = readCircleElement(elem);
      } else if (name.equals("connector")) {
        f = readCircleElement(elem);
      } else if (name.equals("custom-shape")) {
        f = readCustomShapeElement(elem);
      } else if (name.equals("ellipse")) {
        f = readEllipseElement(elem);
      } else if (name.equals("frame")) {
        f = readFrameElement(elem);
      } else if (name.equals("g")) {
        f = readGElement(elem);
      } else if (name.equals("line")) {
        f = readLineElement(elem);
      } else if (name.equals("measure")) {
        f = readMeasureElement(elem);
      } else if (name.equals("path")) {
        f = readPathElement(elem);
      } else if (name.equals("polygon")) {
        f = readPolygonElement(elem);
      } else if (name.equals("polyline")) {
        f = readPolylineElement(elem);
      } else if (name.equals("rect")) {
        f = readRectElement(elem);
      } else if (name.equals("regularPolygon")) {
        f = readRegularPolygonElement(elem);
      } else {
        if (DEBUG) {
          System.out.println("ODGInputFormat.readElement(" + elem + ") not implemented.");
        }
      }
    }
    if (f != null) {
      if (f.isEmpty()) {
        if (DEBUG) {
          System.out.println("ODGInputFormat.readElement():null - discarded empty figure " + f);
        }
        return null;
      }
      if (DEBUG) {
        System.out.println("ODGInputFormat.readElement():" + f + ".");
      }
    }
    return f;
###
1988, TextFigure, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 53, 55
1
/** Creates a new instance. */
3
  public TextFigure() {
    this(ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels").
        getString("TextFigure.defaultText"));
###
1989, getTabSize, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 187, 188
3
/**
   * Gets the number of characters used to expand tabs.
   */
2
  public int getTabSize() {
    return 8;
###
1990, getTool, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 251, 257
4
/**
   * Returns a specialized tool for the given coordinate.
   * <p>Returns null, if no specialized tool is available.
   */
7
  @Override
  public Tool getTool(Point2D.Double p) {
    if (isEditable() && contains(p)) {
      TextEditingTool t = new TextEditingTool(this);
      return t;
    }
    return null;
###
1991, getText, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 166, 167
3
/**
   * Gets the text shown by the text figure.
   */
2
  public String getText() {
    return get(TEXT);
###
1993, contains, RectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RectangleFigure.java, 70, 74
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
5
  public boolean contains(Point2D.Double p) {
    Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();
    double grow = AttributeKeys.getPerpendicularHitGrowth(this) + 1d;
    Geom.grow(r, grow, grow);
    return r.contains(p);
###
1995, RectangleFigure, RectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RectangleFigure.java, 32, 33
1
/** Creates a new instance. */
2
  public RectangleFigure() {
    this(0, 0, 0, 0);
###
1997, LineFigure, LineFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineFigure.java, 35, 38
1
/** Creates a new instance. */
4
  public LineFigure() {
    addNode(new BezierPath.Node(new Point2D.Double(0,0)));
    addNode(new BezierPath.Node(new Point2D.Double(0,0)));
    setConnectable(false);
###
1998, toPath, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 1424, 1863
7
/**
   * Returns a value as a BezierPath array.
   * as specified in http://www.w3.org/TR/SVGMobile12/shapes.html#PointsBNF
   *
   * Also supports elliptical arc commands 'a' and 'A' as specified in
   * http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
   */
409
  private BezierPath[] toPath(String str) throws IOException {
    LinkedList<BezierPath> paths = new LinkedList<BezierPath>();
    BezierPath path = null;
    Point2D.Double p = new Point2D.Double();
    Point2D.Double c1 = new Point2D.Double();
    Point2D.Double c2 = new Point2D.Double();
    StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));
    tt.resetSyntax();
    tt.parseNumbers();
    tt.parseExponents();
    tt.parsePlusAsNumber();
    tt.whitespaceChars(0, ' ');
    tt.whitespaceChars(',', ',');

    char nextCommand = 'M';
    char command = 'M';
    Commands:
    while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
      if (tt.ttype > 0) {
        command = (char) tt.ttype;
      } else {
        command = nextCommand;
        tt.pushBack();
      }
      BezierPath.Node node;
      switch (command) {
        case 'M':
          // absolute-moveto x y
          if (path != null) {
            paths.add(path);
          }
          path = new BezierPath();
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'M' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'M' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.moveTo(p.x, p.y);
          nextCommand = 'L';
          break;
        case 'm':
          // relative-moveto dx dy
          if (path != null) {
            paths.add(path);
          }
          path = new BezierPath();
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'm' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'm' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.moveTo(p.x, p.y);
          nextCommand = 'l';
          break;
        case 'Z':
        case 'z':
          // close path
          p.x = path.get(0).x[0];
          p.y = path.get(0).y[0];
          // If the last point and the first point are the same, we
          // can merge them
          if (path.size() > 1) {
            BezierPath.Node first = path.get(0);
            BezierPath.Node last = path.get(path.size() - 1);
            if (first.x[0] == last.x[0] &&
                first.y[0] == last.y[0]) {
              if ((last.mask & BezierPath.C1_MASK) != 0) {
                first.mask |= BezierPath.C1_MASK;
                first.x[1] = last.x[1];
                first.y[1] = last.y[1];
              }
              path.remove(path.size() - 1);
            }
          }
          path.setClosed(true);
          break;
        case 'L':
          // absolute-lineto x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'L' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'L' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'L';
          break;
        case 'l':
          // relative-lineto dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'l' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'l' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'l';
          break;
        case 'H':
          // absolute-horizontal-lineto x
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'H' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'H';
          break;
        case 'h':
          // relative-horizontal-lineto dx
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'h' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'h';
          break;
        case 'V':
          // absolute-vertical-lineto y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'V' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'V';
          break;
        case 'v':
          // relative-vertical-lineto dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'v' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'v';
          break;
        case 'C':
          // absolute-curveto x1 y1 x2 y2 x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x1 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y1 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x2 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y2 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'C';
          break;
        case 'c':
          // relative-curveto dx1 dy1 dx2 dy2 dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx1 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy1 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx2 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy2 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'c';
          break;
        case 'S':
          // absolute-shorthand-curveto x2 y2 x y
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x2 coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y2 coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'S';
          break;
        case 's':
          // relative-shorthand-curveto dx2 dy2 dx dy
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx2 coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy2 coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 's';
          break;
        case 'Q':
          // absolute-quadto x1 y1 x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x1 coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y1 coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'Q';
          break;
        case 'q':
          // relative-quadto dx1 dy1 dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx1 coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy1 coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'q';
          break;
        case 'T':
          // absolute-shorthand-quadto x y
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'T' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'T' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'T';
          break;
        case 't':
          // relative-shorthand-quadto dx dy
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 't' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 't' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 's';
          break;

        case 'A': {
          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("rx coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          // If rX or rY have negative signs, these are dropped;
          // the absolute value is used instead.
          double rx = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("ry coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double ry = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x-axis-rotation missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double xAxisRotation = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("large-arc-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean largeArcFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("sweep-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean sweepFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
          nextCommand = 'A';
          break;
        }
        case 'a': {
          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("rx coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          // If rX or rY have negative signs, these are dropped;
          // the absolute value is used instead.
          double rx = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("ry coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double ry = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x-axis-rotation missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double xAxisRotation = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("large-arc-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean largeArcFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("sweep-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean sweepFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
          nextCommand = 'a';
          break;
        }
        default:
          if (DEBUG) {
            System.out.println("SVGInputFormat.toPath aborting after illegal path command: " + command + " found in path " + str);
          }
          break Commands;
        //throw new IOException("Illegal command: "+command);
      }
    }
    if (path != null) {
      paths.add(path);
    }
    return paths.toArray(new BezierPath[paths.size()]);
###
1999, setArc, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 126, 128
1
/** Convenience method for setting both the arc width and the arc height. */
3
  public void setArc(double width, double height) {
    setArcWidth(width);
    setArcHeight(height);
###
2000, contains, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 134, 143
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
10
  public boolean contains(Point2D.Double p) {
    RoundRectangle2D.Double r = (RoundRectangle2D.Double) roundrect.clone();
    double grow = AttributeKeys.getPerpendicularHitGrowth(this);
    r.x -= grow;
    r.y -= grow;
    r.width += grow * 2;
    r.height += grow * 2;
    r.arcwidth += grow * 2;
    r.archeight += grow * 2;
    return r.contains(p);
###
2001, setArcHeight, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 119, 122
1
/** Sets the arc height. */
4
  public void setArcHeight(double newValue) {
    double oldValue = roundrect.archeight;
    roundrect.archeight = newValue;
    firePropertyChange(ARC_HEIGHT_PROPERTY, oldValue, newValue);
###
2002, setArcWidth, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 113, 116
1
/** Sets the arc width. */
4
  public void setArcWidth(double newValue) {
    double oldValue = roundrect.arcwidth;
    roundrect.arcwidth = newValue;
    firePropertyChange(ARC_WIDTH_PROPERTY, oldValue, newValue);
###
2004, RoundRectangleFigure, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 50, 51
1
/** Creates a new instance. */
2
  public RoundRectangleFigure() {
    this(0, 0, 0, 0);
###
2005, readFiguresFromDocumentContent, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 154, 220
4
/**
   * Reads figures from the content.xml file of an ODG open document drawing
   * document.
   */
61
  @SuppressWarnings("unchecked")
  public void readFiguresFromDocumentContent(InputStream in, Drawing drawing, boolean replace) throws IOException {
    this.figures = new LinkedList<Figure>();
    IXMLParser parser;
    try {
      parser = XMLParserFactory.createDefaultXMLParser();
    } catch (Exception ex) {
      InternalError e = new InternalError("Unable to instantiate NanoXML Parser");
      e.initCause(ex);
      throw e;
    }
    IXMLReader reader = new StdXMLReader(in);
    parser.setReader(reader);
    try {
      document = (IXMLElement) parser.parse();
    } catch (XMLException ex) {
      IOException e = new IOException(ex.getMessage());
      e.initCause(ex);
      throw e;
    }
    if (styles == null) {
      styles = new ODGStylesReader();
    }
    styles.read(document);

    // Search for the first 'office:drawing' element in the XML document
    // in preorder sequence
    IXMLElement drawingElem = document;
    Stack<Iterator> stack = new Stack<Iterator>();
    LinkedList<IXMLElement> ll = new LinkedList<IXMLElement>();
    ll.add(document);
    stack.push(ll.iterator());
    while (!stack.empty() && stack.peek().hasNext()) {
      Iterator<IXMLElement> iter = stack.peek();
      IXMLElement node = iter.next();
      Iterator<IXMLElement> children = node.getChildren().iterator();
      if (!iter.hasNext()) {
        stack.pop();
      }
      if (children.hasNext()) {
        stack.push(children);
      }
      if (node.getName() != null &&
          node.getName().equals("drawing") &&
          (node.getNamespace() == null ||
          node.getNamespace().equals(OFFICE_NAMESPACE))) {
        drawingElem = node;
        break;
      }
    }
    if (drawingElem.getName() == null ||
        !drawingElem.getName().equals("drawing") ||
        (drawingElem.getNamespace() != null &&
        !drawingElem.getNamespace().equals(OFFICE_NAMESPACE))) {
      throw new IOException("'office:drawing' element expected: " + drawingElem.getName());
    }
    readDrawingElement(drawingElem);
    if (replace) {
      drawing.removeAllChildren();
    }
    drawing.addAll(figures);
###
2006, transform, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 157, 162
4
/**
   * Transforms the figure.
   * @param tx The transformation.
   */
6
  public void transform(AffineTransform tx) {
    Point2D.Double anchor = getStartPoint();
    Point2D.Double lead = getEndPoint();
    setBounds(
        (Point2D.Double) tx.transform(anchor, anchor),
        (Point2D.Double) tx.transform(lead, lead));
###
2007, getArcWidth, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 103, 104
1
/** Gets the arc width. */
2
  public double getArcWidth() {
    return roundrect.arcwidth;
###
2008, readFrameElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 674, 678
43
/**
   * Reads a &lt;draw:frame&gt; element from the specified
   * XML element.
   * <p>
   * A frame is a rectangular container where that contains enhanced content
   * like text boxes, images or objects. Frames are very similar to regular
   * drawing shapes, but support some features that are not available for
   * regular drawing shapes, like contours, image maps and hyperlinks. In
   * particular, a frame allows to have multiple renditions of an object. That
   * is, a frame may for instance contain an object as well as an image. In
   * this case, the application may choose the content that it supports best.
   * If the application supports the object type contained in the frame, it
   * probably will render the object. If it does not support the object, it
   * will render the image.
   * <p>
   * In general, an application must not render more than one of the content
   * elements contained in a frame. The order of content elements dictates
   * the document author's preference for rendering, with the first child
   * being the most preferred. This means that applications should render the
   * first child element that it supports. A frame must contain at least one
   * content element. The inclusion of multiple content elements is optional.
   * Application may preserve the content elements they don't render, but
   * don't have to.
   * <p>
   * Within text documents, frames are also used to position content outside
   * the default text flow of a document.
   * <p>
   * Frames can contain:
   * • Text boxes
   * • Objects represented either in the OpenDocument format or in a object
   *    specific binary format
   * • Images
   * • Applets
   * • Plug-ins
   * • Floating frames
   * <p>
   * Like the formatting properties of drawing shapes, frame formatting
   * properties are stored in styles belonging to the graphic family. The way
   * a frame is contained in a document also is the same as for drawing shapes.
   *
   *
   * @param elem A &lt;frame&gt; element.
   */
5
  private ODGFigure readFrameElement(IXMLElement elem) throws IOException {
    if (DEBUG) {
      System.out.println("ODGInputFormat.readFrameElement(" + elem + ") not implemented.");
    }
    return null;
###
2010, toWSOrCommaSeparatedArray, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 871, 876
5
/**
   * Returns a value as a String array.
   * The values are separated by whitespace or by commas with optional white
   * space.
   */
6
  public static String[] toWSOrCommaSeparatedArray(String str) throws IOException {
    String[] result = str.split("(\\s*,\\s*|\\s+)");
    if (result.length == 1 && result[0].equals("")) {
      return new String[0];
    } else {
      return result;
###
2014, getArcHeight, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 108, 109
1
/** Gets the arc height. */
2
  public double getArcHeight() {
    return roundrect.archeight;
###
2015, toTransform, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 1300, 1414
18
/** Converts an ODG draw:transform attribute value into an AffineTransform.
   * <p>
   * The draw:transform attribute specifies a list of transformations that can be applied to a
   * drawing shape.
   * The value of this attribute is a list of transform definitions, which are applied to the drawing shape
   * in the order in which they are listed. The transform definitions in the list must be separated by a
   * white space and/or a comma. The types of transform definitions available include:
   * • matrix(<a> <b> <c> <d> <e> <f>), which specifies a transformation in the form of a
   * transformation matrix of six values. matrix(a,b,c,d,e,f) is the equivalent of applying the
   * transformation matrix [a b c d e f].
   * • translate(<tx> [<ty>]), which specifies a translation by tx and ty.
   * • scale(<sx> [<sy>]), which specifies a scale operation by sx and sy. If <sy> is not
   * provided, it is assumed to be equal to <sx>.
   * • rotate(<rotate-angle>), which specifies a rotation by <rotate-angle> about the
   * origin of the shapes coordinate system.
   * • skewX(<skew-angle>), which specifies a skew transformation along the X axis.
   * • skewY(<skew-angle>), which specifies a skew transformation along the Y axis.
   */
105
  public static AffineTransform toTransform(String str) throws IOException {
    AffineTransform t = new AffineTransform();
    AffineTransform t2 = new AffineTransform();
    if (str != null) {
      StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));
      tt.resetSyntax();
      tt.wordChars('a', 'z');
      tt.wordChars('A', 'Z');
      tt.wordChars(128 + 32, 255);
      tt.whitespaceChars(0, ' ');
      tt.whitespaceChars(',', ',');
      tt.parseNumbers();
      tt.parseExponents();
      while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
        if (tt.ttype != StreamPosTokenizer.TT_WORD) {
          throw new IOException("Illegal transform " + str);
        }
        String type = tt.sval;
        if (tt.nextToken() != '(') {
          throw new IOException("'(' not found in transform " + str);
        }
        if (type.equals("matrix")) {
          double[] m = new double[6];
          for (int i = 0; i < 6; i++) {
            if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
              throw new IOException("Matrix value " + i + " not found in transform " + str + " token:" + tt.ttype + " " + tt.sval);
            }
            m[i] = tt.nval;
          }
          t.preConcatenate(new AffineTransform(m));
        } else if (type.equals("translate")) {
          double tx, ty;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("X-translation value not found in transform " + str);
          }
          tx = tt.nval;
          if (tt.nextToken() == StreamPosTokenizer.TT_WORD) {
            tx *= toUnitFactor(tt.sval);
          } else {
            tt.pushBack();
          }
          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
            ty = tt.nval;
            if (tt.nextToken() == StreamPosTokenizer.TT_WORD) {
              ty *= toUnitFactor(tt.sval);
            } else {
              tt.pushBack();
            }
          } else {
            tt.pushBack();
            ty = 0;
          }
          t2.setToIdentity();
          t2.translate(tx, ty);
          t.preConcatenate(t2);
        } else if (type.equals("scale")) {
          double sx, sy;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("X-scale value not found in transform " + str);
          }
          sx = tt.nval;
          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
            sy = tt.nval;
          } else {
            tt.pushBack();
            sy = sx;
          }
          t2.setToIdentity();
          t2.scale(sx, sy);
          t.preConcatenate(t2);
        } else if (type.equals("rotate")) {
          double angle, cx, cy;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Angle value not found in transform " + str);
          }
          angle = tt.nval;
          t2.setToIdentity();
          t2.rotate(-angle);
          t.preConcatenate(t2);

        } else if (type.equals("skewX")) {
          double angle;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Skew angle not found in transform " + str);
          }
          angle = tt.nval;
          t.preConcatenate(new AffineTransform(
              1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0));
        } else if (type.equals("skewY")) {
          double angle;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Skew angle not found in transform " + str);
          }
          angle = tt.nval;
          t.preConcatenate(new AffineTransform(
              1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0));
        } else {
          throw new IOException("Unknown transform " + type + " in " + str);
        }
        if (tt.nextToken() != ')') {
          throw new IOException("')' not found in transform " + str);
        }
      }
    }
    return t;
###
2016, nextEnhancedCoordinate, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 1207, 1234
5
/**
   * Retrieves an enhanced coordinate from the specified tokenizer.
   * An enhanced coordinate can be a double, or a '?' followed by a
   * formula name, or a '$' followed by an index to a modifier.
   */
28
  private Object nextEnhancedCoordinate(StreamPosTokenizer tt, String str) throws IOException {
    switch (tt.nextToken()) {
      case '?': {
        StringBuilder buf = new StringBuilder();
        buf.append('?');
        int ch = tt.nextChar();
        for (; ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9';
            ch = tt.nextChar()) {
          buf.append((char) ch);
        }
        tt.pushCharBack(ch);
        return buf.toString();
      }
      case '$': {
        StringBuilder buf = new StringBuilder();
        buf.append('$');
        int ch = tt.nextChar();
        for (; ch >= '0' && ch <= '9';
            ch = tt.nextChar()) {
          buf.append((char) ch);
        }
        tt.pushCharBack(ch);
        return buf.toString();
      }
      case StreamPosTokenizer.TT_NUMBER:
        return tt.nval;
      default:
        throw new IOException("coordinate missing at position" + tt.getStartPosition() + " in " + str);
###
2017, handleMouseClick, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 405, 435
3
/**
   * Handles a mouse click.
   */
29
  @Override
  public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {
    if (getLiner() == null &&
        evt.getClickCount() == 2) {
      willChange();
      final int index = splitSegment(p, (float) (5f / view.getScaleFactor()));
      if (index != -1) {
        final BezierPath.Node newNode = getNode(index);
        fireUndoableEditHappened(new AbstractUndoableEdit() {
          @Override
          public void redo() throws CannotRedoException {
            super.redo();
            willChange();
            addNode(index, newNode);
            changed();
          }
          @Override
          public void undo() throws CannotUndoException {
            super.undo();
            willChange();
            removeNode(index);
            changed();
          }
        });
        changed();
        return true;
      }
    }
    return false;
###
2019, addNotify, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 277, 283
6
/**
   * This method is invoked, when the Figure is being removed from a Drawing.
   * This method invokes handleConnect, if the Figure is connected.
   *
   * @see #handleConnect
   */
6
  @Override
  public void addNotify(Drawing drawing) {
    super.addNotify(drawing);
    if (getStartConnector() != null && getEndConnector() != null) {
      handleConnect(getStartConnector(), getEndConnector());
      updateConnection();
###
2021, transform, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 101, 104
4
/**
   * Ensures that a connection is updated if the connection
   * was moved.
   */
4
  @Override
  public void transform(AffineTransform tx) {
    super.transform(tx);
    updateConnection(); // make sure that we are still connected
###
2022, createHandles, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 114, 132
5
/**
   * Gets the handles of the figure. It returns the normal
   * PolylineHandles but adds ChangeConnectionHandles at the
   * start and end.
   */
19
  @Override
  public Collection<Handle> createHandles(int detailLevel) {
    ArrayList<Handle> handles = new ArrayList<Handle>(getNodeCount());
    switch (detailLevel) {
      case -1: // Mouse hover handles
        handles.add(new BezierOutlineHandle(this, true));
        break;
      case 0:
        handles.add(new BezierOutlineHandle(this));
        if (getLiner() == null) {
          for (int i = 1, n = getNodeCount() - 1; i < n; i++) {
            handles.add(new BezierNodeHandle(this, i));
          }
        }
        handles.add(new ConnectionStartHandle(this));
        handles.add(new ConnectionEndHandle(this));
        break;
    }
    return handles;
###
2024, removeNotify, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 293, 306
9
/**
   * This method is invoked, when the Figure is being removed from a Drawing.
   * This method invokes handleDisconnect, if the Figure is connected.
   *
   * @see #handleDisconnect
   */
 --------------
// SHAPE AND BOUNDS
 --------------
14
  @Override
  public void removeNotify(Drawing drawing) {
    if (getStartConnector() != null && getEndConnector() != null) {
      handleDisconnect(getStartConnector(), getEndConnector());
    }
    // Note: we do not set the connectors to null here, because we
    // need them when we are added back to a drawing again. For example,
    // when an undo is performed, after the LineConnection has been
    // deleted.
    /*
    setStartConnector(null);
    setEndConnector(null);
     */
    super.removeNotify(drawing);
###
2027, setConnectable, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 140, 142
4
/**
   * 
   * ConnectionFigures cannot be connected and always sets connectable to false.
   */
3
  @Override
  public void setConnectable(boolean newValue) {
    super.setConnectable(false);
###
2028, transform, ODGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectFigure.java, 176, 204
4
/**
   * Transforms the figure.
   * @param tx The transformation.
   */
29
  public void transform(AffineTransform tx) {
    invalidateTransformedShape();
    if (get(TRANSFORM) != null ||
        //        (tx.getType() & (AffineTransform.TYPE_TRANSLATION | AffineTransform.TYPE_MASK_SCALE)) != tx.getType()) {
        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {
      if (get(TRANSFORM) == null) {
        set(TRANSFORM, (AffineTransform) tx.clone());
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM, t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
      if (get(FILL_GRADIENT) != null &&
          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT, g);
      }
      if (get(STROKE_GRADIENT) != null &&
          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT, g);
###
2029, ODGRectFigure, ODGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectFigure.java, 48, 49
1
/** Creates a new instance. */
2
  public ODGRectFigure() {
    this(0, 0, 0, 0);
###
2030, contains, ODGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectFigure.java, 132, 133
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
2
  public boolean contains(Point2D.Double p) {
    return getHitShape().contains(p);
###
2036, sort, QuadTreeDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeDrawing.java, 74, 82
3
/**
   * Implementation note: Sorting can not be done for orphaned children.
   */
9
  public java.util.List<Figure> sort(Collection<? extends Figure> c) {
    ensureSorted();
    ArrayList<Figure> sorted = new ArrayList<Figure>(c.size());
    for (Figure f : children) {
      if (c.contains(f)) {
        sorted.add(f);
      }
    }
    return sorted;
###
2037, ensureSorted, QuadTreeDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeDrawing.java, 268, 271
3
/**
   * Ensures that the children are sorted in z-order sequence.
   */
4
  private void ensureSorted() {
    if (needsSorting) {
      Collections.sort(children, FigureLayerComparator.INSTANCE);
      needsSorting = false;
###
2040, getFiguresFrontToBack, QuadTreeDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeDrawing.java, 118, 120
4
/**
   * Returns an iterator to iterate in
   * Z-order front to back over the children.
   */
3
  public java.util.List<Figure> getFiguresFrontToBack() {
    ensureSorted();
    return new ReversedList<Figure>(children);
###
2041, ODGPathFigure, ODGPathFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGPathFigure.java, 57, 59
1
/** Creates a new instance. */
3
  public ODGPathFigure() {
    add(new ODGBezierFigure());
    ODGAttributeKeys.setDefaults(this);
###
2044, AlignAction, AlignAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AlignAction.java, 36, 37
1
/** Creates a new instance. */
2
  public AlignAction(DrawingEditor editor) {
    super(editor);
###
2058, AbstractDrawingViewAction, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 79, 80
3
/**
   * Creates a view action which acts on the current view of the editor.
   */
2
  public AbstractDrawingViewAction(DrawingEditor editor) {
    setEditor(editor);
###
2059, dispose, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 139, 140
3
/** Frees all resources held by this object, so that it can be garbage
   * collected.
   */
2
  public void dispose() {
    setEditor(null);
###
2060, setUpdateEnabledState, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 152, 165
9
/** By default, the enabled state of this action is updated to reflect
   * the enabled state of the active {@code DrawingView}.
   * Since this is not always necessary, and since many listening actions
   * may considerably slow down the drawing editor, you can switch this
   * behavior off here.
   *
   * @param newValue Specify false to prevent automatic updating of the
   * enabled state.
   */
14
  public void setUpdateEnabledState(boolean newValue) {
    // Note: eventHandler != null yields true, if we are currently updating
    // the enabled state.
    if (eventHandler != null != newValue) {
      if (newValue) {
        eventHandler = new EventHandler();
        registerEventHandler();
      } else {
        unregisterEventHandler();
        eventHandler = null;
      }
    }
    if (newValue) {
      updateEnabledState();
###
2062, unregisterEventHandler, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 179, 188
3
/** Unregisters the event handler from the drawing editor and the
   * active drawing view.
   */
10
  private void unregisterEventHandler() {
    if (editor != null) {
      editor.removePropertyChangeListener(eventHandler);
    }
    if (activeView != null) {
      activeView.removePropertyChangeListener(eventHandler);
      activeView = null;
    }
    if (specificView != null) {
      specificView.removePropertyChangeListener(eventHandler);
###
2063, AbstractDrawingViewAction, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 86, 88
3
/**
   * Creates a view action which acts on the specified view.
   */
3
  public AbstractDrawingViewAction(DrawingView view) {
    this.specificView = view;
    registerEventHandler();
###
2064, isUpdatEnabledState, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 172, 173
3
/** Returns true, if this action automatically updates its enabled
   * state to reflect the enabled state of the active {@code DrawingView}.
   */
2
  public boolean isUpdatEnabledState() {
    return eventHandler != null;
###
2065, updateEnabledState, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 122, 126
4
/** Updates the enabled state of this action to reflect the enabled state
   * of the active {@code DrawingView}. If no drawing view is active, this
   * action is disabled.
   */
5
  public void updateEnabledState() {
    if (getView() != null) {
      setEnabled(getView().isEnabled());
    } else {
      setEnabled(false);
###
2066, AttributeToggler, AttributeToggler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeToggler.java, 45, 46
1
/** Creates a new instance. */
2
  public AttributeToggler(DrawingEditor editor, AttributeKey<T> key, T value1, T value2) {
    this(editor, key, value1, value2, null);
###
2068, TriangleFigure, TriangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java, 50, 51
1
/** Creates a new instance. */
2
  public TriangleFigure() {
    this(0, 0, 0, 0);
###
2069, contains, TriangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java, 183, 194
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
12
  public boolean contains(Point2D.Double p) {
    Shape triangle = getBezierPath();
    
    double grow = AttributeKeys.getPerpendicularHitGrowth(this);
    if (grow != 0d) {
      GrowStroke gs = new GrowStroke((float) grow,
          (float) (AttributeKeys.getStrokeTotalWidth(this) *
          get(STROKE_MITER_LIMIT))
          );
      triangle =gs.createStrokedShape(triangle);
    }
    return triangle.contains(p);
###
2070, findCompatibleConnector, TriangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java, 81, 82
7
/**
   * Returns a compatible connector.
   * By default a {@link org.jhotdraw.draw.connector.ChopTriangleConnector} is returned.
   */
 --------------
// SHAPE AND BOUNDS
 --------------
2
  public Connector findCompatibleConnector(Connector c, boolean isStartConnector) {
    return new ChopTriangleConnector(this);
###
2071, findConnector, TriangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java, 74, 75
4
/**
   * Returns the Figures connector for the specified location.
   * By default a {@link org.jhotdraw.draw.connector.ChopTriangleConnector} is returned.
   */
2
  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {
    return new ChopTriangleConnector(this);
###
2072, ApplyAttributesAction, ApplyAttributesAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ApplyAttributesAction.java, 36, 39
1
/** Creates a new instance. */
4
  public ApplyAttributesAction(DrawingEditor editor) {
    super(editor);
    labels.configureAction(this, "edit.applyAttributes");
    setEnabled(true);
###
2073, AttributeAction, AttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeAction.java, 41, 42
1
/** Creates a new instance. */
2
  public AttributeAction(DrawingEditor editor, AttributeKey key, Object value, Icon icon) {
    this(editor, key, value, null, icon);
###
2074, AttributeAction, AttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeAction.java, 36, 37
1
/** Creates a new instance. */
2
  public AttributeAction(DrawingEditor editor, AttributeKey key, Object value) {
    this(editor, key, value, null, null);
###
2075, AttributeAction, AttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeAction.java, 46, 47
1
/** Creates a new instance. */
2
  public AttributeAction(DrawingEditor editor, AttributeKey key, Object value, String name) {
    this(editor, key, value, name, null);
###
2076, updateEnabledState, AbstractSelectedAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java, 99, 104
4
/** Updates the enabled state of this action to reflect the enabled state
   * of the active {@code DrawingView}. If no drawing view is active, this
   * action is disabled.
   */
6
  protected void updateEnabledState() {
    if (getView() != null) {
      setEnabled(getView().isEnabled() &&
          getView().getSelectionCount() > 0);
    } else {
      setEnabled(false);
###
2077, setUpdateEnabledState, AbstractSelectedAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java, 148, 161
9
/** By default, the enabled state of this action is updated to reflect
   * the enabled state of the active {@code DrawingView}.
   * Since this is not always necessary, and since many listening actions
   * may considerably slow down the drawing editor, you can switch this
   * behavior off here.
   *
   * @param newValue Specify false to prevent automatic updating of the
   * enabled state.
   */
14
  public void setUpdateEnabledState(boolean newValue) {
    // Note: eventHandler != null yields true, if we are currently updating
    // the enabled state.
    if (eventHandler != null != newValue) {
      if (newValue) {
        eventHandler = new EventHandler();
        registerEventHandler();
      } else {
        unregisterEventHandler();
        eventHandler = null;
      }
    }
    if (newValue) {
      updateEnabledState();
###
2078, isUpdatEnabledState, AbstractSelectedAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java, 168, 169
3
/** Returns true, if this action automatically updates its enabled
   * state to reflect the enabled state of the active {@code DrawingView}.
   */
2
  public boolean isUpdatEnabledState() {
    return eventHandler != null;
###
2079, AbstractSelectedAction, AbstractSelectedAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java, 90, 92
3
/** Creates an action which acts on the selected figures on the current view
   * of the specified editor.
   */
3
  public AbstractSelectedAction(DrawingEditor editor) {
    setEditor(editor);
    updateEnabledState();
###
2080, unregisterEventHandler, AbstractSelectedAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java, 175, 182
3
/** Unregisters the event handler from the drawing editor and the
   * active drawing view.
   */
8
  private void unregisterEventHandler() {
    if (editor != null) {
      editor.removePropertyChangeListener(eventHandler);
    }
    if (activeView != null) {
      activeView.removeFigureSelectionListener(eventHandler);
      activeView.removePropertyChangeListener(eventHandler);
      activeView = null;
###
2081, unregisterEventHandler, AbstractDrawingEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java, 131, 133
3
/** Unregisters the event handler from the drawing editor and the
   * active drawing view.
   */
3
  private void unregisterEventHandler() {
    if (editor != null) {
      editor.removePropertyChangeListener(eventHandler);
###
2082, AbstractDrawingEditorAction, AbstractDrawingEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java, 56, 57
1
/** Creates a new instance. */
2
  public AbstractDrawingEditorAction(DrawingEditor editor) {
    setEditor(editor);
###
2083, fireUndoableEditHappened, AbstractDrawingEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java, 91, 92
4
/** Updates the enabled state of this action to reflect the enabled state
   * of the active {@code DrawingView}. If no drawing view is active, this
   * action is disabled.
   */
2
  protected void fireUndoableEditHappened(UndoableEdit edit) {
    getDrawing().fireUndoableEditHappened(edit);
###
2084, setUpdateEnabledState, AbstractDrawingEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java, 104, 117
9
/** By default, the enabled state of this action is updated to reflect
   * the enabled state of the active {@code DrawingView}.
   * Since this is not always necessary, and since many listening actions
   * may considerably slow down the drawing editor, you can switch this
   * behavior off here.
   *
   * @param newValue Specify false to prevent automatic updating of the
   * enabled state.
   */
14
  public void setUpdateEnabledState(boolean newValue) {
    // Note: eventHandler != null yields true, if we are currently updating
    // the enabled state.
    if (eventHandler != null != newValue) {
      if (newValue) {
        eventHandler = new EventHandler();
        registerEventHandler();
      } else {
        unregisterEventHandler();
        eventHandler = null;
      }
    }
    if (newValue) {
      updateEnabledState();
###
2085, isUpdatEnabledState, AbstractDrawingEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java, 124, 125
3
/** Returns true, if this action automatically updates its enabled
   * state to reflect the enabled state of the active {@code DrawingView}.
   */
2
  public boolean isUpdatEnabledState() {
    return eventHandler != null;
###
2088, getEventSetDescriptors, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2089, getBeanDescriptor, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2090, getMethodDescriptors, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2091, getPropertyDescriptors, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2093, getDefaultPropertyIndex, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2094, getDefaultEventIndex, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2095, getID, AbstractToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBar.java, 54, 55
7
/** This should be an abstract method, but the NetBeans GUI builder
   * doesn't support abstract beans.
   * @return The ID used to retrieve labels and store user preferences.
   */
 --------------
// prefs is null, because we are not permitted to read preferences
 --------------
2
  protected String getID() {
    return "";
###
2096, AbstractToolBar, AbstractToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBar.java, 41, 45
1
/** Creates new form. */
5
  public AbstractToolBar() {
    initComponents();
    try {
      prefs = PreferencesUtil.userNodeForPackage(getClass());
    } catch (SecurityException e) {
###
2099, getDefaultPropertyIndex, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2100, getDefaultEventIndex, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2103, getPropertyDescriptors, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2104, getEventSetDescriptors, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2106, getMethodDescriptors, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2107, getBeanDescriptor, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2108, SVGImageFigure, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 70, 71
1
/** Creates a new instance. */
2
  public SVGImageFigure() {
    this(0, 0, 0, 0);
###
2109, AlignToolBar, AlignToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBar.java, 37, 39
1
/** Creates new instance. */
3
  public AlignToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
###
2111, initComponents, AlignToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBar.java, 144, 146
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
2
  private void initComponents() {
    setOpaque(false);
###
2114, transform, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 199, 215
4
/**
   * Transforms the figure.
   * @param tx The transformation.
   */
17
  public void transform(AffineTransform tx) {
    invalidateTransformedShape();
    if (get(TRANSFORM) != null ||
        (tx.getType() & (AffineTransform.TYPE_TRANSLATION | AffineTransform.TYPE_MASK_SCALE)) != tx.getType()) {
      if (get(TRANSFORM) == null) {
        set(TRANSFORM, (AffineTransform) tx.clone());
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM, t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
###
2115, contains, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 159, 160
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
2
  public boolean contains(Point2D.Double p) {
    return getHitShape().contains(p);
###
2117, getBufferedImage, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 389, 402
4
/**
   * Gets the buffered image. If necessary, this method creates the buffered
   * image from the image data.
   */
14
  public BufferedImage getBufferedImage() {
    if (bufferedImage == null && imageData != null) {
      //System.out.println("recreateing bufferedImage");
      try {
        bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));
      } catch (Throwable e) {
        e.printStackTrace();
        // If we can't create a buffered image from the image data,
        // there is no use to keep the image data and try again, so
        // we drop the image data.
        imageData = null;
      }
    }
    return bufferedImage;
###
2118, setImage, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 356, 360
11
/**
   * Sets the image.
   *
   * @param imageData The image data. If this is null, a buffered image must
   * be provided.
   * @param bufferedImage An image constructed from the imageData. If this
   * is null, imageData must be provided.
   */
 --------------
// COMPOSITE FIGURES
 --------------
5
  public void setImage(byte[] imageData, BufferedImage bufferedImage) {
    willChange();
    this.imageData = imageData;
    this.bufferedImage = bufferedImage;
    changed();
###
2119, getImageData, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 409, 424
4
/**
   * Gets the image data. If necessary, this method creates the image
   * data from the buffered image.
   */
16
  public byte[] getImageData() {
    if (bufferedImage != null && imageData == null) {
      try {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        ImageIO.write(bufferedImage, "PNG", bout);
        bout.close();
        imageData = bout.toByteArray();
      } catch (IOException e) {
        e.printStackTrace();
        // If we can't create image data from the buffered image,
        // there is no use to keep the buffered image and try again, so
        // we drop the buffered image.
        bufferedImage = null;
      }
    }
    return imageData;
###
2122, setImageData, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 367, 371
4
/**
   * Sets the image data.
   * This clears the buffered image.
   */
5
  public void setImageData(byte[] imageData) {
    willChange();
    this.imageData = imageData;
    this.bufferedImage = null;
    changed();
###
2125, getMethodDescriptors, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2126, setBufferedImage, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 378, 382
4
/**
   * Sets the buffered image.
   * This clears the image data.
   */
5
  public void setBufferedImage(BufferedImage image) {
    willChange();
    this.imageData = null;
    this.bufferedImage = image;
    changed();
###
2127, getBeanDescriptor, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2128, getPropertyDescriptors, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2129, getDefaultEventIndex, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2130, getEventSetDescriptors, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2131, getDefaultPropertyIndex, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2132, SVGEllipseFigure, SVGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGEllipseFigure.java, 49, 50
1
/** Creates a new instance. */
2
  public SVGEllipseFigure() {
    this(0, 0, 0, 0);
###
2134, contains, SVGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGEllipseFigure.java, 112, 113
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
2
  public boolean contains(Point2D.Double p) {
    return getHitShape().contains(p);
###
2137, transform, SVGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGEllipseFigure.java, 153, 182
5
/**
   * Transforms the figure.
   *
   * @param tx the transformation.
   */
30
  public void transform(AffineTransform tx) {
    if (get(TRANSFORM) != null ||
        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {
      if (get(TRANSFORM) == null) {
        TRANSFORM.setClone(this, tx);
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM,  t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
      if (get(FILL_GRADIENT) != null &&
          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT,  g);
      }
      if (get(STROKE_GRADIENT) != null &&
          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT,  g);
      }
    }
    invalidate();
###
2139, CanvasToolBar, CanvasToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBar.java, 41, 44
1
/** Creates new instance. */
4
  public CanvasToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
    setDisclosureStateCount(3);
###
2140, getDefaultPropertyIndex, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2141, getPropertyDescriptors, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2142, getDefaultEventIndex, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2143, getMethodDescriptors, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2146, getBeanDescriptor, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2148, contains, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 200, 201
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
2
  public boolean contains(Point2D.Double p) {
    return getHitShape().contains(p);
###
2149, getEventSetDescriptors, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 117, 118
8
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */

2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2150, getArcWidth, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 141, 142
1
/** Gets the arc width. */
2
  public double getArcWidth() {
    return roundrect.arcwidth;
###
2151, setArcHeight, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 158, 161
1
/** Sets the arc height. */
4
  public void setArcHeight(double newValue) {
    double oldValue = roundrect.archeight;
    roundrect.archeight = newValue;
    firePropertyChange(ARC_HEIGHT_PROPERTY, oldValue, newValue);
###
2152, SVGRectFigure, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 68, 69
1
/** Creates a new instance. */
2
  public SVGRectFigure() {
    this(0, 0, 0, 0);
###
2153, transform, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 250, 278
4
/**
   * Transforms the figure.
   * @param tx The transformation.
   */
29
  public void transform(AffineTransform tx) {
    invalidateTransformedShape();
    if (get(TRANSFORM) != null ||
        //        (tx.getType() & (AffineTransform.TYPE_TRANSLATION | AffineTransform.TYPE_MASK_SCALE)) != tx.getType()) {
        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {
      if (get(TRANSFORM) == null) {
        set(TRANSFORM,  (AffineTransform) tx.clone());
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM,  t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
      if (get(FILL_GRADIENT) != null &&
          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT,  g);
      }
      if (get(STROKE_GRADIENT) != null &&
          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT,  g);
###
2154, getArcHeight, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 146, 147
1
/** Gets the arc height. */
2
  public double getArcHeight() {
    return roundrect.archeight;
###
2155, getMethodDescriptors, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2156, setArc, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 165, 167
1
/** Convenience method for setting both the arc width and the arc height. */
3
  public void setArc(double width, double height) {
    setArcWidth(width);
    setArcHeight(height);
###
2157, getBeanDescriptor, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2159, getDefaultPropertyIndex, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2163, getPropertyDescriptors, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2165, getEventSetDescriptors, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2166, setArcWidth, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 152, 155
1
/** Sets the arc width. */
4
  public void setArcWidth(double newValue) {
    double oldValue = roundrect.arcwidth;
    roundrect.arcwidth = newValue;
    firePropertyChange(ARC_WIDTH_PROPERTY, oldValue, newValue);
###
2167, getDefaultEventIndex, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2169, ArrangeToolBar, ArrangeToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBar.java, 37, 39
1
/** Creates new instance. */
3
  public ArrangeToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
###
2170, initComponents, ArrangeToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBar.java, 117, 119
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
2
  private void initComponents() {
    setOpaque(false);
###
2172, ActionsToolBar, ActionsToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBar.java, 50, 52
1
/** Creates new instance. */
3
  public ActionsToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
###
2173, getTool, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 505, 510
4
/**
   * Returns a specialized tool for the given coordinate.
   * <p>Returns null, if no specialized tool is available.
   */
6
  public Tool getTool(Point2D.Double p) {
    if (isEditable() && contains(p)) {
      TextAreaEditingTool tool = new TextAreaEditingTool(this);
      return tool;
    }
    return null;
###
2174, appendParagraph, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 191, 304
17
/**
   * Appends a paragraph of text at the specified y location and returns
   * the bounds of the paragraph.
   * 
   *
   * @param shape Shape to which to add the glyphs of the paragraph. This 
   * parameter is null, if we only want to measure the size of the paragraph.
   * @param styledText the text of the paragraph.
   * @param verticalPos the top bound of the paragraph
   * @param maxVerticalPos the bottom bound of the paragraph
   * @param leftMargin the left bound of the paragraph
   * @param rightMargin the right bound of the paragraph
   * @param tabStops an array with tab stops
   * @param tabCount the number of entries in tabStops which contain actual
   *    values
   * @return Returns the actual bounds of the paragraph.
   */
95
  private Rectangle2D.Double appendParagraph(Path2D.Double shape,
      AttributedCharacterIterator styledText,
      float verticalPos, float maxVerticalPos,
      float leftMargin, float rightMargin,
      float[] tabStops, int tabCount) {
    // assume styledText is an AttributedCharacterIterator, and the number
    // of tabs in styledText is tabCount
    Rectangle2D.Double paragraphBounds = new Rectangle2D.Double(leftMargin, verticalPos, 0, 0);
    int[] tabLocations = new int[tabCount + 1];
    int i = 0;
    for (char c = styledText.first(); c != styledText.DONE; c = styledText.next()) {
      if (c == '\t') {
        tabLocations[i++] = styledText.getIndex();
      }
    }
    tabLocations[tabCount] = styledText.getEndIndex() - 1;
    // Now tabLocations has an entry for every tab's offset in
    // the text.  For convenience, the last entry is tabLocations
    // is the offset of the last character in the text.
    LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, getFontRenderContext());
    int currentTab = 0;
    while (measurer.getPosition() < styledText.getEndIndex()) {
      // Lay out and draw each line.  All segments on a line
      // must be computed before any drawing can occur, since
      // we must know the largest ascent on the line.
      // TextLayouts are computed and stored in a List;
      // their horizontal positions are stored in a parallel
      // List.
      // lineContainsText is true after first segment is drawn
      boolean lineContainsText = false;
      boolean lineComplete = false;
      float maxAscent = 0, maxDescent = 0;
      float horizontalPos = leftMargin;
      LinkedList<TextLayout> layouts = new LinkedList<TextLayout>();
      LinkedList<Float> penPositions = new LinkedList<Float>();
      while (!lineComplete) {
        float wrappingWidth = rightMargin - horizontalPos;
        TextLayout layout = null;
        layout =
            measurer.nextLayout(wrappingWidth,
            tabLocations[currentTab] + 1,
            lineContainsText);
        // layout can be null if lineContainsText is true
        if (layout != null) {
          layouts.add(layout);
          penPositions.add(horizontalPos);
          horizontalPos += layout.getAdvance();
          maxAscent = Math.max(maxAscent, layout.getAscent());
          maxDescent = Math.max(maxDescent,
              layout.getDescent() + layout.getLeading());
        } else {
          lineComplete = true;
        }
        lineContainsText = true;
        if (measurer.getPosition() == tabLocations[currentTab] + 1) {
          currentTab++;
        }
        if (measurer.getPosition() == styledText.getEndIndex()) {
          lineComplete = true;
        } else if (tabStops.length == 0 || horizontalPos >= tabStops[tabStops.length - 1]) {
          lineComplete = true;
        }
        if (!lineComplete) {
          // move to next tab stop
          int j;
          for (j = 0; horizontalPos >= tabStops[j]; j++) {
          }
          horizontalPos = tabStops[j];
        }
      }
      verticalPos += maxAscent;
      if (verticalPos > maxVerticalPos) {
        break;
      }
      Iterator<TextLayout> layoutEnum = layouts.iterator();
      Iterator<Float> positionEnum = penPositions.iterator();
      // now iterate through layouts and draw them
      while (layoutEnum.hasNext()) {
        TextLayout nextLayout = layoutEnum.next();
        float nextPosition = positionEnum.next();
        AffineTransform tx = new AffineTransform();
        tx.translate(nextPosition, verticalPos);
        if (shape != null) {
          Shape outline = nextLayout.getOutline(tx);
          shape.append(outline, false);
        }
        Rectangle2D layoutBounds = nextLayout.getBounds();
        paragraphBounds.add(new Rectangle2D.Double(layoutBounds.getX() + nextPosition,
            layoutBounds.getY() + verticalPos,
            layoutBounds.getWidth(),
            layoutBounds.getHeight()));
      }
      verticalPos += maxDescent;
    }
    return paragraphBounds;
###
2176, contains, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 109, 119
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
10
  public boolean contains(Point2D.Double p) {
    if (get(TRANSFORM) != null) {
      try {
        p = (Point2D.Double) get(TRANSFORM).inverseTransform(p, new Point2D.Double());
      } catch (NoninvertibleTransformException ex) {
        ex.printStackTrace();
      }
    }
    Rectangle2D r = getTextShape().getBounds2D();
    return r.isEmpty() ? getBounds().contains(p) : r.contains(p);
###
2180, transform, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 320, 351
5
/**
   * Transforms the figure.
   *
   * @param tx the transformation.
   */
32
  public void transform(AffineTransform tx) {
    if (get(TRANSFORM) != null ||
        (tx.getType() &
        (AffineTransform.TYPE_TRANSLATION /*| AffineTransform.TYPE_MASK_SCALE*/)) !=
        tx.getType()) {
      if (get(TRANSFORM) == null) {
        set(TRANSFORM,  (AffineTransform) tx.clone());
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM,  t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
      if (get(FILL_GRADIENT) != null &&
          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT,  g);
      }
      if (get(STROKE_GRADIENT) != null &&
          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT,  g);
      }
    }
    invalidate();
###
2181, SVGTextAreaFigure, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 60, 61
1
/** Creates a new instance. */
2
  public SVGTextAreaFigure() {
    this("Text");
###
2182, getPreferredTextSize, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 550, 586
10
/**
   * Returns the preferred text size of the TextAreaFigure.
   * <p>
   * If you want to use this method to determine the bounds of the TextAreaFigure,
   * you need to add the insets of the TextAreaFigure to the size.
   * 
   * @param maxWidth the maximal width to use. Specify Double.MAX_VALUE
   * if you want the width to be unlimited.
   * @return width and height needed to lay out the text.
   */
35
  public Dimension2DDouble getPreferredTextSize(double maxWidth) {
    Rectangle2D.Double textRect = new Rectangle2D.Double();
    if (getText() != null) {
      Font font = getFont();
      boolean isUnderlined = get(FONT_UNDERLINE);
      float leftMargin = 0;
      float rightMargin = (float) maxWidth - 1;
      float verticalPos = 0;
      float maxVerticalPos = Float.MAX_VALUE;
      if (leftMargin < rightMargin) {
        float tabWidth = (float) (getTabSize() * font.getStringBounds("m", getFontRenderContext()).getWidth());
        float[] tabStops = new float[(int) (textRect.width / tabWidth)];
        for (int i = 0; i < tabStops.length; i++) {
          tabStops[i] = (float) (textRect.x + (int) (tabWidth * (i + 1)));
        }
        if (getText() != null) {
          String[] paragraphs = getText().split("\n");//Strings.split(getText(), '\n');
          for (int i = 0; i < paragraphs.length; i++) {
            if (paragraphs[i].length() == 0) {
              paragraphs[i] = " ";
            }
            AttributedString as = new AttributedString(paragraphs[i]);
            as.addAttribute(TextAttribute.FONT, font);
            if (isUnderlined) {
              as.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_LOW_ONE_PIXEL);
            }
            int tabCount = paragraphs[i].split("\t").length - 1;
            Rectangle2D.Double paragraphBounds = appendParagraph(null, as.getIterator(), verticalPos, maxVerticalPos, leftMargin, rightMargin, tabStops, tabCount);
            verticalPos = (float) (paragraphBounds.y + paragraphBounds.height);
            textRect.add(paragraphBounds);
          }
        }
      }
    }
    return new Dimension2DDouble(Math.abs(textRect.x) + textRect.width, Math.abs(textRect.y) + textRect.height);
###
2183, getInsets, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 404, 407
3
/**
   * Returns the insets used to draw text.
   */
4
  public Insets2D.Double getInsets() {
    double sw = (get(STROKE_COLOR) == null) ? 0 : Math.ceil(get(STROKE_WIDTH) / 2);
    Insets2D.Double insets = new Insets2D.Double(0, 0, 0, 0);
    return new Insets2D.Double(insets.top + sw, insets.left + sw, insets.bottom + sw, insets.right + sw);
###
2184, setText, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 397, 398
3
/**
   * Sets the text shown by the text figure.
   */
2
  public void setText(String newText) {
    set(TEXT, newText);
###
2185, isEmpty, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 520, 521
3
/**
   * Gets the text shown by the text figure.
   */
2
  public boolean isEmpty() {
    return getText() == null || getText().length() == 0;
###
2187, SVGPathOutlineHandle, SVGPathOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGPathOutlineHandle.java, 38, 39
1
/** Creates a new instance. */
2
  public SVGPathOutlineHandle(SVGPathFigure owner) {
    this(owner, false);
###
2188, SVGPathFigure, SVGPathFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGPathFigure.java, 57, 59
1
/** Creates a new instance. */
3
  public SVGPathFigure() {
    add(new SVGBezierFigure());
    SVGAttributeKeys.setDefaults(this);
###
2189, handleMouseClick, SVGPathFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGPathFigure.java, 455, 468
3
/**
   * Handles a mouse click.
   */
14
  @Override
  public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {
    if (evt.getClickCount() == 2 && view.getHandleDetailLevel() % 2 == 0) {
      for (Figure child : getChildren()) {
        SVGBezierFigure bf = (SVGBezierFigure) child;
        int index = bf.findSegment(p, 5f / view.getScaleFactor());
        if (index != -1) {
          bf.handleMouseClick(p, evt, view);
          evt.consume();
          return true;
        }
      }
    }
    return false;
###
2192, draw, SVGRectRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectRadiusHandle.java, 49, 58
3
/**
   * Draws this handle.
   */
10
  @Override
  public void draw(Graphics2D g) {
    if (getEditor().getTool().supportsHandleInteraction()) {
      drawDiamond(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR));
    } else {
      drawDiamond(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR_DISABLED),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR_DISABLED));
###
2193, SVGRectRadiusHandle, SVGRectRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectRadiusHandle.java, 42, 43
1
/** Creates a new instance. */
2
  public SVGRectRadiusHandle(Figure owner) {
    super(owner);
###
2195, contains, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 170, 178
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
9
  public boolean contains(Point2D.Double p) {
    if (get(TRANSFORM) != null) {
      try {
        p = (Point2D.Double) get(TRANSFORM).inverseTransform(p, new Point2D.Double());
      } catch (NoninvertibleTransformException ex) {
        ex.printStackTrace();
      }
    }
    return getTextShape().getBounds2D().contains(p);
###
2197, SVGTextFigure, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 71, 72
1
/** Creates a new instance. */
2
  public SVGTextFigure() {
    this("Text");
###
2199, setText, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 309, 310
3
/**
   * Sets the text shown by the text figure.
   */
2
  public void setText(String newText) {
    set(TEXT, newText);
###
2200, getTool, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 415, 421
7
/**
   * Returns a specialized tool for the given coordinate.
   * <p>Returns null, if no specialized tool is available.
   */
 --------------
// EDITING
 --------------
7
  @Override
  public Tool getTool(Point2D.Double p) {
    if (isEditable() && contains(p)) {
      TextEditingTool tool = new TextEditingTool(this);
      return tool;
    }
    return null;
###
2202, getText, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 291, 292
3
/**
   * Gets the text shown by the text figure.
   */
2
  public String getText() {
    return (String) get(TEXT);
###
2203, transform, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 233, 260
5
/**
   * Transforms the figure.
   *
   * @param tx the transformation.
   */
28
  public void transform(AffineTransform tx) {
    if (get(TRANSFORM) != null ||
        tx.getType() != (tx.getType() & AffineTransform.TYPE_TRANSLATION)) {
      if (get(TRANSFORM) == null) {
        set(TRANSFORM,  (AffineTransform) tx.clone());
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM,  t);
      }
    } else {
      for (int i=0; i < coordinates.length; i++) {
        tx.transform(coordinates[i], coordinates[i]);
      }
      if (get(FILL_GRADIENT) != null &&
          ! get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT,  g);
      }
      if (get(STROKE_GRADIENT) != null &&
          ! get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT,  g);
      }
    }
    invalidate();
###
2205, SVGGroupFigure, SVGGroupFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGGroupFigure.java, 40, 41
1
/** Creates a new instance. */
2
  public SVGGroupFigure() {
    SVGAttributeKeys.setDefaults(this);
###
2206, EditGridPanel, EditGridPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java, 36, 70
1
/** Creates new instance. */
33
  public EditGridPanel() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    widthField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0, 1000, 1));
    heightField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0, 1000, 1));
    thetaField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0, 180, 1));
    constrainer = new GridConstrainer(10, 10);
    
    widthField.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getPropertyName().equals("value")) {
          if (evt.getNewValue() != null) {
            constrainer.setWidth((Double) evt.getNewValue());
          }
        }
      }
    });
    
    heightField.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getPropertyName().equals("value")) {
          if (evt.getNewValue() != null) {
            constrainer.setHeight((Double) evt.getNewValue());
          }
        }
      }
    });
    
    thetaField.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getPropertyName().equals("value")) {
          if (evt.getNewValue() != null) {
            constrainer.setTheta((Double) evt.getNewValue() * Math.PI / 180d);
###
2207, getConstrainer, EditGridPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java, 95, 96
5
/**
   * Returns the GridConstrainer currently being edited by this panel.
   * 
   * @return The GridConstrainer.
   */
2
  public GridConstrainer getConstrainer() {
    return constrainer;
###
2208, initComponents, EditGridPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java, 105, 158
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
46
  private void initComponents() {
    widthLabel = new javax.swing.JLabel();
    heightLabel = new javax.swing.JLabel();
    widthField = new org.jhotdraw.gui.JLifeFormattedTextField();
    heightField = new org.jhotdraw.gui.JLifeFormattedTextField();
    thetaLabel = new javax.swing.JLabel();
    thetaField = new org.jhotdraw.gui.JLifeFormattedTextField();
    widthLabel.setText(labels.getString("view.grid.width.text")); // NOI18N
    heightLabel.setText(labels.getString("view.grid.height.text")); // NOI18N
    widthField.setColumns(5);
    heightField.setColumns(5);
    thetaLabel.setText(labels.getString("view.grid.theta.text")); // NOI18N
    thetaField.setColumns(5);
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(heightLabel, javax.swing.GroupLayout.Alignment.TRAILING)
          .addComponent(widthLabel, javax.swing.GroupLayout.Alignment.TRAILING)
          .addComponent(thetaLabel, javax.swing.GroupLayout.Alignment.TRAILING))
        .addGap(4, 4, 4)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(thetaField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(heightField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(widthField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addContainerGap(67, Short.MAX_VALUE))
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(widthLabel)
          .addComponent(widthField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(heightLabel)
          .addComponent(heightField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(thetaLabel)
          .addComponent(thetaField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
###
2209, setConstrainer, EditGridPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java, 83, 87
5
/**
   * Sets the GridConstrainer to be edited by this panel.
   * 
   * @param newValue The GridConstrainer.
   */
5
  public void setConstrainer(GridConstrainer newValue) {
    constrainer = newValue;
    widthField.setValue(constrainer.getWidth());
    heightField.setValue(constrainer.getHeight());
    thetaField.setValue(constrainer.getTheta() * 180d / Math.PI);
###
2210, IncreaseHandleDetailLevelAction, IncreaseHandleDetailLevelAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/IncreaseHandleDetailLevelAction.java, 28, 30
1
/** Creates a new instance. */
3
  public IncreaseHandleDetailLevelAction(DrawingEditor editor) {
    super(editor);
    labels.configureAction(this, ID);
###
2211, EditorColorChooserAction, EditorColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditorColorChooserAction.java, 42, 43
1
/** Creates a new instance. */
2
  public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {
    this(editor, key, null, icon);
###
2212, EditorColorChooserAction, EditorColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditorColorChooserAction.java, 37, 38
1
/** Creates a new instance. */
2
  public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {
    this(editor, key, null, null);
###
2213, EditorColorChooserAction, EditorColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditorColorChooserAction.java, 47, 48
1
/** Creates a new instance. */
2
  public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, String name) {
    this(editor, key, name, null);
###
2214, GroupAction, GroupAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/GroupAction.java, 39, 40
1
/** Creates a new instance. */
2
  public GroupAction(DrawingEditor editor) {
    this(editor, new GroupFigure(), true);
###
2215, FontChooserHandler, FontChooserHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/FontChooserHandler.java, 41, 49
1
/** Creates a new instance. */
8
  public FontChooserHandler(DrawingEditor editor, AttributeKey<Font> key, JFontChooser fontChooser, JPopupMenu popupMenu) {
    super(editor);
    this.key = key;
    this.fontChooser = fontChooser;
    this.popupMenu = popupMenu;
    fontChooser.addActionListener(this);
    fontChooser.addPropertyChangeListener(this);
    updateEnabledState();
###
2216, getBorderInsets, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 112, 113
4
/**
   * Returns the insets of the border.
   * @param c the component for which this border insets value applies
   */
2
  public Insets getBorderInsets(Component c) {
    return (Insets) borderInsets.clone();
###
2217, paintBorder, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 127, 246
10
/**
   * Paints the bevel image for the specified component with the
   * specified position and size.
   * @param c the component for which this border is being painted
   * @param gr the paint graphics
   * @param x the x position of the painted border
   * @param y the y position of the painted border
   * @param width the width of the painted border
   * @param height the height of the painted border
   */
120
  public void paintBorder(Component c, Graphics gr, int x, int y, int width, int height) {
    if (image == null) return;
    
    // Cast Graphics to Graphics2D
    Graphics2D g = (Graphics2D) gr;
    
    // Set some variables for easy access of insets and image size
    int top = imageInsets.top;
    int left = imageInsets.left;
    int bottom = imageInsets.bottom;
    int right = imageInsets.right;
    int imgWidth = image.getWidth();
    int imgHeight = image.getHeight();
    
    
    // Optimisation: Draw image directly if it fits into the component
    if (fillContentArea) {
      if (width == imgWidth && height == imgHeight) {
        g.drawImage(image, x, y, c);
        return;
      }
    }
    
    // Optimisation: Remove insets, if image width or image height fits
    if (width == imgWidth) {
      left = imgWidth;
      right = 0;
    }
    if (height == imgHeight) {
      top = imgHeight;
      bottom = 0;
    }
    
    // Adjust insets if component is too small
    if (width < left + right) {
      left = Math.min(left, width / 2); //Math.max(0, left + (width - left - right) / 2);
      right = width - left;
    }
    if (height < top + bottom) {
      top = Math.min(top, height / 2); //Math.max(0, top + (height - top - bottom) / 2);
      bottom = height - top;
    }
    
    // Draw the Leads
    if (top > 0 && left > 0) {
      g.drawImage(
      image,
      x, y, x + left, y + top,
      0, 0, left, top,
      c
      );
    }
    if (top > 0 && right > 0) {
      //g.fillRect(x+width-right, y, x+width, y+top);
      g.drawImage(
      image,
      x + width - right, y, x + width, y + top,
      imgWidth - right, 0, imgWidth, top,
      c
      );
    }
    if (bottom > 0 && left > 0) {
      g.drawImage(
      image,
      x, y + height - bottom, x + left, y + height,
      0, imgHeight - bottom, left, imgHeight,
      c
      );
    }
    if (bottom > 0 && right > 0) {
      g.drawImage(
      image,
      x + width - right, y + height - bottom, x + width, y + height,
      imgWidth - right, imgHeight - bottom, imgWidth, imgHeight,
      c
      );
    }
    
    // Draw the edges
    BufferedImage subImg = null;
    TexturePaint paint;
    
    // North
    if (top > 0 && left + right < width) {
      subImg = image.getSubimage(left, 0, imgWidth - right - left, top);
      paint = new TexturePaint(subImg, new Rectangle(x+left, y, imgWidth - left - right, top));
      g.setPaint(paint);
      g.fillRect(x+left, y, width - left - right, top);
    }
    // South
    if (bottom > 0 && left + right < width) {
      subImg = image.getSubimage(left, imgHeight - bottom, imgWidth - right - left, bottom);
      paint = new TexturePaint(subImg, new Rectangle(x+left, y + height - bottom, imgWidth - left - right, bottom));
      g.setPaint(paint);
      g.fillRect(x+left, y + height - bottom, width - left - right, bottom);
    }
    // West
    if (left > 0 && top + bottom < height) {
      subImg = image.getSubimage(0, top, left, imgHeight - top - bottom);
      paint = new TexturePaint(subImg, new Rectangle(x, y+top, left, imgHeight - top - bottom));
      g.setPaint(paint);
      g.fillRect(x, y+top, left, height - top - bottom);
    }
    // East
    if (right > 0 && top + bottom < height) {
      subImg = image.getSubimage(imgWidth - right, top, right, imgHeight - top - bottom);
      paint = new TexturePaint(subImg, new Rectangle(x+width-right, y + top, right, imgHeight - top - bottom));
      g.setPaint(paint);
      g.fillRect(x+width-right, y + top, right, height - top - bottom);
    }
    
    // Fill the center
    if (fillContentArea) {
      g.setColor(Color.yellow);
      if (left + right < width
      && top + bottom < height) {
        subImg = image.getSubimage(left, top, imgWidth - right - left, imgHeight - top - bottom);
        paint = new TexturePaint(subImg, new Rectangle(x + left, y + top, imgWidth - right - left, imgHeight - top - bottom));
        g.setPaint(paint);
        g.fillRect(x+left, y + top, width - right - left, height - top - bottom);
###
2218, ImageBevelBorder, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 73, 74
4
/**
   * Creates a new instance with the given image and insets.
   * The image has different insets than the border.
   */
2
  public ImageBevelBorder(Image img, Insets imageInsets, Insets borderInsets) {
    this(img, imageInsets, borderInsets, true);
###
2219, ImageBevelBorder, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 80, 97
4
/**
   * Creates a new instance with the given image and insets.
   * The image has different insets than the border.
   */
18
  public ImageBevelBorder(Image img, Insets imageInsets, Insets borderInsets, boolean fillContentArea) {
    if (img instanceof BufferedImage) {
      this.image = (BufferedImage) img;
    } else {
      Frame f = new Frame();
      f.pack();
      MediaTracker t = new MediaTracker(f);
      t.addImage(img, 0);
      try { t.waitForAll(); } catch (InterruptedException e) {}
      image = new BufferedImage(img.getWidth(f), img.getHeight(f), BufferedImage.TYPE_INT_ARGB);
      Graphics2D imgGraphics = image.createGraphics();
      imgGraphics.drawImage(img, 0, 0, f);
      imgGraphics.dispose();
      f.dispose();
    }
    this.imageInsets = imageInsets;
    this.borderInsets = borderInsets;
    this.fillContentArea = fillContentArea;
###
2220, ImageBevelBorder, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 65, 66
4
/**
   * Creates a new instance with the given image and insets.
   * The image has the same insets as the border.
   */
2
  public ImageBevelBorder(Image img, Insets borderInsets) {
    this(img, borderInsets, borderInsets, true);
###
2221, isBorderOpaque, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 104, 105
4
/**
   * Returns true if the border is opaque.
   * This implementation always returns false.
   */
2
  public boolean isBorderOpaque() {
    return false;
###
2222, getRedoAction, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 200, 201
3
/**
   * Gets the redo action for use as a Redo menu item.
   */
2
  public Action getRedoAction() {
    return redoAction;
###
2223, UndoRedoManager, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 128, 131
6
/** Creates new UndoRedoManager */
 --------------
/**
   * Redo Action for use in a menu bar.
   */
 --------------
4
  public UndoRedoManager() {
    getLabels();
    undoAction = new UndoAction();
    redoAction = new RedoAction();
###
2224, updateActions, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 209, 232
4
/**
   * Updates the properties of the UndoAction
   * and of the RedoAction.
   */
24
  private void updateActions() {
    String label;
    if (DEBUG) System.out.println("UndoRedoManager@"+hashCode()+".updateActions "+
        editToBeUndone()
        +" canUndo="+canUndo()+" canRedo="+canRedo());
    if (canUndo()) {
      undoAction.setEnabled(true);
      label = getUndoPresentationName();
    } else {
      undoAction.setEnabled(false);
      label = labels.getString("edit.undo.text");
    }
    undoAction.putValue(Action.NAME, label);
    undoAction.putValue(Action.SHORT_DESCRIPTION, label);
    
    if (canRedo()) {
      redoAction.setEnabled(true);
      label = getRedoPresentationName();
    } else {
      redoAction.setEnabled(false);
      label = labels.getString("edit.redo.text");
    }
    redoAction.putValue(Action.NAME, label);
    redoAction.putValue(Action.SHORT_DESCRIPTION, label);
###
2225, discardAllEdits, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 141, 144
8
/**
   * Discards all edits.
   */
 --------------
/**
     * Invoked when an action occurs.
     */
 --------------
4
  public void discardAllEdits() {
    super.discardAllEdits();
    updateActions();
    setHasSignificantEdits(false);
###
2226, addEdit, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 177, 188
16
/**
   * If inProgress, inserts anEdit at indexOfNextAdd, and removes
   * any old edits that were at indexOfNextAdd or later. The die
   * method is called on each edit that is removed is sent, in the
   * reverse of the order the edits were added. Updates
   * indexOfNextAdd.
   *
   * <p>If not inProgress, acts as a CompoundEdit</p>
   *
   * <p>Regardless of inProgress, if undoOrRedoInProgress,
   * calls die on each edit that is sent.</p>
   *
   *
   * @see CompoundEdit#end
   * @see CompoundEdit#addEdit
   */
12
  public boolean addEdit(UndoableEdit anEdit) {
    if (DEBUG) System.out.println("UndoRedoManager@"+hashCode()+".add "+anEdit);
    if (undoOrRedoInProgress) {
      anEdit.die();
      return true;
    }
    boolean success = super.addEdit(anEdit);
    updateActions();
    if (success && anEdit.isSignificant() && editToBeUndone() == anEdit) {
      setHasSignificantEdits(true);
    }
    return success;
###
2227, undo, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 240, 247
5
/**
   * Undoes the last edit event.
   * The UndoRedoManager ignores all incoming UndoableEdit events,
   * while undo is in progress.
   */
8
  public void undo()
  throws CannotUndoException {
    undoOrRedoInProgress = true;
    try {
      super.undo();
    } finally {
      undoOrRedoInProgress = false;
      updateActions();
###
2228, hasSignificantEdits, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 157, 158
4
/**
   * Returns true if at least one significant UndoableEdit
   * has been added since the last call to discardAllEdits.
   */
2
  public boolean hasSignificantEdits() {
    return hasSignificantEdits;
###
2229, getUndoAction, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 193, 194
3
/**
   * Gets the undo action for use as an Undo menu item.
   */
2
  public Action getUndoAction() {
    return undoAction;
###
2230, redo, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 256, 263
5
/**
   * Redoes the last undone edit event.
   * The UndoRedoManager ignores all incoming UndoableEdit events,
   * while redo is in progress.
   */
8
  public void redo()
  throws CannotUndoException {
    undoOrRedoInProgress = true;
    try {
      super.redo();
    } finally {
      undoOrRedoInProgress = false;
      updateActions();
###
2231, CompositeEdit, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 66, 67
7
/**
   * Creates a new {@code CompositeEdit} which uses the specified significance.
   * <p>
   * The presentation name is used from CompoundEdit#getPresentationName().
   *
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
2
  public CompositeEdit(boolean isSignificant) {
    this.isSignificant = isSignificant;
###
2232, addEdit, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 134, 141
12
/**
   * If this edit is inProgress, accepts anEdit and returns
   * true.
   *
   * <p>The last edit added to this CompositeEdit is given a
   * chance to addEdit(anEdit). If it refuses (returns false), anEdit is
   * given a chance to replaceEdit the last edit. If anEdit returns
   * false here, it is added to edits.</p>
   *
   * <p>If the CompositeEdit is added to itself, then method end()
   * is called, and true is returned.</p>
   */
8
  public boolean addEdit(UndoableEdit anEdit) {
    if (anEdit == this) {
        end();
      return true;
    } else if (isInProgress() && (anEdit instanceof CompositeEdit)) {
      return true;
    } else {
      return super.addEdit(anEdit);
###
2233, CompositeEdit, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 77, 79
8
/**
   * Creates a new {@code CompositeEdit} which uses the specified
   * presentation name.
   * <p>
   * If the presentation name is null, then CompoundEdit.getPresentatioName
   * is used.
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
3
  public CompositeEdit(String presentationName) {
    this.presentationName = presentationName;
    isSignificant = true;
###
2234, CompositeEdit, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 89, 91
8
/**
   * Creates a new {@code CompositeEdit} which uses the given presentation name
   * and significance.
   * <p>
   * If the presentation name is null, then CompoundEdit.getPresentatioName
   * is used.
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
3
  public CompositeEdit(String presentationName, boolean isSignificant) {
    this.presentationName = presentationName;
    this.isSignificant = isSignificant;
###
2235, getRedoPresentationName, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 118, 119
6
/**
   * Returns the redo presentation name.
   * If the presentation name is null, then CompoundEdit.getRedoPresentationName
   * is returned.
   * @see javax.swing.undo.CompoundEdit#getRedoPresentationName()
   */
2
  public String getRedoPresentationName() {
    return ((presentationName != null) ? UndoRedoManager.getLabels().getString("edit.redo.text")+" "+presentationName : super.getRedoPresentationName());
###
2236, getPresentationName, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 100, 101
6
/**
   * Returns the presentation name.
   * If the presentation name is null, then CompoundEdit.getPresentatioName
   * is returned.
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
2
  public String getPresentationName() {
    return (presentationName != null) ? presentationName : super.getPresentationName();
###
2237, getUndoPresentationName, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 109, 110
6
/**
   * Returns the undo presentation name.
   * If the presentation name is null, then CompoundEdit.getUndoPresentationName
   * is returned.
   * @see javax.swing.undo.CompoundEdit#getUndoPresentationName()
   */
2
  public String getUndoPresentationName() {
    return ((presentationName != null) ? UndoRedoManager.getLabels().getString("edit.undo.text")+" "+presentationName : super.getUndoPresentationName());
###
2238, CompositeEdit, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 56, 57
6
/**
   * Creates a new {@code CompositeEdit} which uses CompoundEdit#getPresentationName()
   * and is significant..
   *
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
2
  public CompositeEdit() {
    isSignificant = true;
###
2239, isSignificant, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 150, 151
5
/**
   * Returns false if this edit is insignificant - for example one
   * that maintains the user's selection, but does not change
   * any model state.
   */
2
  public boolean isSignificant() {
    return (isSignificant) ? super.isSignificant() : false;
###
2240, invokeGetter, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 188, 198
8
/**
   * Invokes the specified getter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param defaultValue This value is returned, if the method does not exist.
   * @return  The value returned by the getter method or the default value.
   */
11
  public static int invokeGetter(Object obj, String methodName, int defaultValue) {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);
      Object result = method.invoke(obj, new Object[0]);
      return ((Integer) result).intValue();
    } catch (NoSuchMethodException e) {
      return defaultValue;
    } catch (IllegalAccessException e) {
      return defaultValue;
    } catch (InvocationTargetException e) {
      return defaultValue;
###
2241, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 327, 336
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
10
  public static Object invoke(Object obj, String methodName, float newValue)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[] { Float.TYPE} );
      return method.invoke(obj, new Object[] { new Float(newValue)});
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2242, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 291, 300
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
10
  public static Object invoke(Object obj, String methodName, boolean newValue)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[] { Boolean.TYPE} );
       return method.invoke(obj, new Object[] { new Boolean(newValue)});
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2243, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 309, 318
6
/**
   * Invokes the specified method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
10
  public static Object invoke(Object obj, String methodName, int newValue)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[] { Integer.TYPE} );
      return method.invoke(obj, new Object[] { new Integer(newValue)});
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2244, invokeIfExists, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 409, 412
6
/**
   * Invokes the specified method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
4
  public static void invokeIfExists(Object obj, String methodName, boolean newValue) {
    try {
       invoke(obj, methodName, newValue);
    } catch (NoSuchMethodException e) {
###
2245, invokeIfExists, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 396, 399
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
4
  public static void invokeIfExists(Object obj, String methodName, float newValue) {
    try {
      invoke(obj, methodName, newValue);
    } catch (NoSuchMethodException e) {
###
2246, invokeIfExists, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 383, 386
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
4
  public static void invokeIfExists(Object obj, String methodName) {
    try {
       invoke(obj, methodName);
    } catch (NoSuchMethodException e) {
###
2247, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 363, 374
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
12
  public static Object invoke(Object obj, String methodName, Class[] clazz, Object... newValue)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  clazz );
      return method.invoke(obj, newValue);
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      InternalError error = new InternalError(e.getMessage());
      error.initCause((e.getCause() != null) ? e.getCause() : e);
      throw error;
###
2248, invokeStatic, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 169, 176
11
/**
   * Invokes the specified parameterless method if it exists.
   *
   * @param clazz The class on which to invoke the method.
   * @param methodName The name of the method.
   * @param types The parameter types.
   * @param values The parameter values.
   * @param defaultValue The default value.
   * @return The return value of the method or the default value if the method
   * does not exist or is not accessible.
   */
8
  public static Object invokeStatic(String clazz, String methodName,
  Class[] types, Object[] values, Object defaultValue) {
    try {
      return invokeStatic(Class.forName(clazz), methodName, types, values);
    } catch (ClassNotFoundException e) {
      return defaultValue;
    } catch (NoSuchMethodException e) {
      return defaultValue;
###
2249, invokeGetter, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 251, 261
8
/**
   * Invokes the specified getter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param defaultValue This value is returned, if the method does not exist.
   * @return The value returned by the getter method or the default value.
   */
11
  public static Object invokeGetter(Object obj, String methodName, Object defaultValue) {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);
      Object result = method.invoke(obj, new Object[0]);
      return result;
    } catch (NoSuchMethodException e) {
      return defaultValue;
    } catch (IllegalAccessException e) {
      return defaultValue;
    } catch (InvocationTargetException e) {
      return defaultValue;
###
2250, invokeStaticGetter, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 272, 282
8
/**
   * Invokes the specified getter method if it exists.
   *
   * @param clazz The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param defaultValue This value is returned, if the method does not exist.
   * @return The value returned by the getter method or the default value.
   */
11
  public static boolean invokeStaticGetter(Class clazz, String methodName, boolean defaultValue) {
    try {
      Method method =  clazz.getMethod(methodName,  new Class[0]);
      Object result = method.invoke(null, new Object[0]);
      return ((Boolean) result).booleanValue();
    } catch (NoSuchMethodException e) {
      return defaultValue;
    } catch (IllegalAccessException e) {
      return defaultValue;
    } catch (InvocationTargetException e) {
      return defaultValue;
###
2251, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 65, 75
9
/**
   * Invokes the specified accessible method with a string parameter if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param stringParameter The String parameter
   * @return The return value of the method or METHOD_NOT_FOUND.
   * @return NoSuchMethodException if the method does not exist or is not accessible.
   */
11
  public static Object invoke(Object obj, String methodName, String stringParameter)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[] { String.class });
      Object result = method.invoke(obj, new Object[] { stringParameter });
      return result;
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2252, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 43, 53
9
/**
   * Invokes the specified accessible parameterless method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @return The return value of the method.
   * @return NoSuchMethodException if the method does not exist or is not
   * accessible.
   */
11
  public static Object invoke(Object obj, String methodName)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);
      Object result = method.invoke(obj, new Object[0]);
      return result;
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2253, invokeGetter, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 209, 219
8
/**
   * Invokes the specified getter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param defaultValue This value is returned, if the method does not exist.
   * @return  The value returned by the getter method or the default value.
   */
11
  public static long invokeGetter(Object obj, String methodName, long defaultValue) {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);
      Object result = method.invoke(obj, new Object[0]);
      return ((Long) result).longValue();
    } catch (NoSuchMethodException e) {
      return defaultValue;
    } catch (IllegalAccessException e) {
      return defaultValue;
    } catch (InvocationTargetException e) {
      return defaultValue;
###
2254, invokeStatic, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 126, 136
10
/**
   * Invokes the specified parameterless method if it exists.
   *
   * @param clazz The class on which to invoke the method.
   * @param methodName The name of the method.
   * @param types The parameter types.
   * @param values The parameter values.
   * @return The return value of the method.
   * @return NoSuchMethodException if the method does not exist or is not accessible.
   */
11
  public static Object invokeStatic(Class clazz, String methodName, Class[] types, Object[] values)
  throws NoSuchMethodException {
    try {
      Method method =  clazz.getMethod(methodName,  types);
      Object result = method.invoke(null, values);
      return result;
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2256, invokeIfExists, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 422, 425
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
4
  public static void invokeIfExists(Object obj, String methodName, Class clazz, Object newValue) {
    try {
       invoke(obj, methodName, clazz, newValue);
    } catch (NoSuchMethodException e) {
###
2257, invokeStatic, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 108, 113
8
/**
   * Invokes the specified accessible parameterless method if it exists.
   *
   * @param clazz The class on which to invoke the method.
   * @param methodName The name of the method.
   * @return The return value of the method.
   * @return NoSuchMethodException if the method does not exist or is not accessible.
   */
6
  public static Object invokeStatic(String clazz, String methodName)
  throws NoSuchMethodException {
    try {
      return invokeStatic(Class.forName(clazz), methodName);
    } catch (ClassNotFoundException e) {
      throw new NoSuchMethodException("class "+clazz+" not found");
###
2258, invokeIfExistsWithEnum, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 436, 448
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
13
  public static void invokeIfExistsWithEnum(Object obj, String methodName, String enumClassName, String enumValueName) {
    try {
      Class enumClass = Class.forName(enumClassName);
      Object enumValue = invokeStatic("java.lang.Enum", "valueOf", new Class[] {Class.class, String.class},
          new Object[] {enumClass, enumValueName}
      );
      invoke(obj, methodName, enumClass, enumValue);
    } catch (ClassNotFoundException e) {
      // ignore
      e.printStackTrace();
    } catch (NoSuchMethodException e) {
      // ignore
      e.printStackTrace();
###
2259, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 345, 354
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
10
  public static Object invoke(Object obj, String methodName, Class clazz, Object newValue)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[] { clazz } );
      return method.invoke(obj, new Object[] { newValue});
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2260, invokeGetter, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 230, 240
8
/**
   * Invokes the specified getter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param defaultValue This value is returned, if the method does not exist.
   * @return The value returned by the getter method or the default value.
   */
11
  public static boolean invokeGetter(Object obj, String methodName, boolean defaultValue) {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);
      Object result = method.invoke(obj, new Object[0]);
      return ((Boolean) result).booleanValue();
    } catch (NoSuchMethodException e) {
      return defaultValue;
    } catch (IllegalAccessException e) {
      return defaultValue;
    } catch (InvocationTargetException e) {
      return defaultValue;
###
2261, invokeStatic, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 149, 155
10
/**
   * Invokes the specified parameterless method if it exists.
   *
   * @param clazz The class on which to invoke the method.
   * @param methodName The name of the method.
   * @param types The parameter types.
   * @param values The parameter values.
   * @return The return value of the method.
   * @return NoSuchMethodException if the method does not exist or is not accessible.
   */
7
  public static Object invokeStatic(String clazz, String methodName,
  Class[] types, Object[] values)
  throws NoSuchMethodException {
    try {
      return invokeStatic(Class.forName(clazz), methodName, types, values);
    } catch (ClassNotFoundException e) {
      throw new NoSuchMethodException("class "+clazz+" not found");
###
2262, invokeStatic, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 87, 97
8
/**
   * Invokes the specified accessible parameterless method if it exists.
   *
   * @param clazz The class on which to invoke the method.
   * @param methodName The name of the method.
   * @return The return value of the method or METHOD_NOT_FOUND.
   * @return NoSuchMethodException if the method does not exist or is not accessible.
   */
11
  public static Object invokeStatic(Class clazz, String methodName)
  throws NoSuchMethodException {
    try {
      Method method =  clazz.getMethod(methodName,  new Class[0]);
      Object result = method.invoke(null, new Object[0]);
      return result;
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2264, split, Images, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Images.java, 171, 189
3
/**
   * Splits an image into count subimages.
   */
18
  public static BufferedImage[] split(Image image, int count, boolean isHorizontal) {
    BufferedImage src = Images.toBufferedImage(image);
    if (count == 1) {
      return new BufferedImage[]{src};
    }
    BufferedImage[] parts = new BufferedImage[count];
    for (int i = 0; i < count; i++) {
      if (isHorizontal) {
        parts[i] = src.getSubimage(
            src.getWidth() / count * i, 0,
            src.getWidth() / count, src.getHeight());
      } else {
        parts[i] = src.getSubimage(
            0, src.getHeight() / count * i,
            src.getWidth(), src.getHeight() / count);
      }
    }
    return parts;
###
2265, toBufferedImage, Images, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Images.java, 55, 70
7
/**
   * Converts an Image to BufferedImage. If the Image is already a
   * BufferedImage, the same image is returned.
   * 
   * @param rImg An Image.
   * @return A BufferedImage.
   */
16
  public static BufferedImage toBufferedImage(RenderedImage rImg) {
    BufferedImage image;
    if (rImg instanceof BufferedImage) {
      image = (BufferedImage) rImg;
    } else {
      Raster r = rImg.getData();
      WritableRaster wr = WritableRaster.createWritableRaster(
          r.getSampleModel(), null);
      rImg.copyData(wr);
      image = new BufferedImage(
          rImg.getColorModel(),
          wr,
          rImg.getColorModel().isAlphaPremultiplied(),
          null);
    }
    return image;
###
2266, hasAlpha, Images, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Images.java, 148, 165
6
/**
   * This method returns true if the specified image has transparent pixels
   *
   * Code taken from the Java Developers Almanac 1.4
   * http://javaalmanac.com/egs/java.awt.image/HasAlpha.html
   */
16
  public static boolean hasAlpha(Image image) {
    // If buffered image, the color model is readily available
    if (image instanceof BufferedImage) {
      BufferedImage bimage = (BufferedImage) image;
      return bimage.getColorModel().hasAlpha();
    }
    // Use a pixel grabber to retrieve the image's color model;
    // grabbing a single pixel is usually sufficient
    PixelGrabber pg = new PixelGrabber(image, 0, 0, 1, 1, false);
    try {
      pg.grabPixels();
    } catch (InterruptedException e) {
    }
    // Get the image's color model
    ColorModel cm = pg.getColorModel();
    return cm.hasAlpha();
###
2270, ResourceBundleUtil, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 108, 111
4
/**
   * Creates a new ResouceBundleUtil which wraps
   * the provided resource bundle.
   */
4
  public ResourceBundleUtil(String baseName, Locale locale) {
    this.locale = locale;
    this.baseName = baseName;
    this.resource = ResourceBundle.getBundle(baseName, locale);
###
2271, getMnemonic, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 309, 311
8
/**
   * Get a Mnemonic from the ResourceBundle.
   * <br>Convenience method.
   *
   * @param key The key of the property.
   * @return The first char of the value of the property.
   *      Returns '\0' if the property is missing.
   */
3
  public char getMnemonic(String key) {
    String s = getStringRecursive(key);
    return (s == null || s.length() == 0) ? '\0' : s.charAt(0);
###
2272, getString, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 130, 141
8
/**
   * Get a String from the ResourceBundle.
   * <br>Convenience method to save casting.
   *
   * @param key The key of the property.
   * @return The value of the property. Returns the key
   *      if the property is missing.
   */
12
  public String getString(String key) {
    try {
      String value = getStringRecursive(key);
      // System.out.println("ResourceBundleUtil "+baseName+" get("+key+"):"+value);
      return value;
    } catch (MissingResourceException e) {
      // System.out.println("ResourceBundleUtil "+baseName+" get("+key+"):***MISSING***");
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + "\" not found.");
        //e.printStackTrace();
      }
      return key;
###
2273, getAcceleratorProperty, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 402, 415
8
/**
   * Gets a KeyStroke for a JavaBeans "accelerator" property from the ResourceBundle.
   * <BR>Convenience method.
   *
   * @param key The key of the property. This method adds ".accelerator" to the key.
   * @return <code>javax.swing.KeyStroke.getKeyStroke(value)</code>.
   *      Returns null if the property is missing.
   */
14
  public KeyStroke getAcceleratorProperty(String key) {
    KeyStroke ks = null;
    try {
      String s;
      s = getStringRecursive(key + ".accelerator");
      ks = (s == null) ? (KeyStroke) null : KeyStroke.getKeyStroke(s);
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + ".accelerator\" not found.");
        //e.printStackTrace();
      }
    } catch (NoSuchElementException e) {
    }
    return ks;
###
2274, removePropertyNameModifier, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 533, 534
3
/**
   * Removes a property name modifier.
   */
2
  public static void removePropertyNameModifier(String name) {
    propertyNameModifiers.remove(name);
###
2275, getMnemonicProperty, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 322, 333
8
/**
   * Gets a char for a JavaBeans "mnemonic" property from the ResourceBundle.
   * <br>Convenience method.
   *
   * @param key The key of the property. This method appends ".mnemonic" to the key.
   * @return The first char of the value of the property.
   *      Returns '\0' if the property is missing.
   */
12
  public char getMnemonicProperty(String key) {
    String s;
    try {
      s = getStringRecursive(key + ".mnemonic");
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + ".mnemonic\" not found.");
        //e.printStackTrace();
      }
      s = null;
    }
    return (s == null || s.length() == 0) ? '\0' : s.charAt(0);
###
2276, putPropertyNameModifier, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 526, 527
6
/**
   * Puts a property name modifier along with a fallback chain.
   *
   * @param name The name of the modifier.
   * @param fallbackChain The fallback chain of the modifier.
   */
2
  public static void putPropertyNameModifier(String name, String... fallbackChain) {
    propertyNameModifiers.put(name, fallbackChain);
###
2277, getIconProperty, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 279, 297
8
/**
   * Get an image icon from the ResourceBundle.
   * <br>Convenience method .
   *
   * @param key The key of the property. This method appends ".icon" to the key.
   * @return The value of the property. Returns null
   *      if the property is missing.
   */
17
  public ImageIcon getIconProperty(String key, Class baseClass) {
    try {
      String rsrcName = getStringRecursive(key + ".icon");
      if (rsrcName.equals("")) {
        return null;
      }
      URL url = baseClass.getResource(rsrcName);
      if (isVerbose && url == null) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "].getIconProperty \"" + key + ".icon\" resource:" + rsrcName + " not found.");
      }
      return (url == null) ? null : new ImageIcon(url);
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "].getIconProperty \"" + key + ".icon\" not found.");
        //e.printStackTrace();
      }
      return null;
###
2278, format, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 246, 248
6
/**
   * Returns a formatted string using java.util.Formatter().
   * @param key
   * @param arguments
   * @return formatted String
   */
3
  public String format(String key, Object... arguments) {
    //return String.format(resource.getLocale(), getString(key), arguments);
    return new Formatter(resource.getLocale()).format(getString(key), arguments).toString();
###
2279, getBundle, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 423, 425
5
/**
   * Get the appropriate ResourceBundle subclass.
   *
   * @see java.util.ResourceBundle
   */
3
  public static ResourceBundleUtil getBundle(String baseName)
      throws MissingResourceException {
    return getBundle(baseName, LocaleUtil.getDefault());
###
2280, getBundle, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 500, 504
5
/**
   * Get the appropriate ResourceBundle subclass.
   *
   * @see java.util.ResourceBundle
   */
5
  public static ResourceBundleUtil getBundle(String baseName, Locale locale)
      throws MissingResourceException {
    ResourceBundleUtil r;
    r = new ResourceBundleUtil(baseName, locale);
    return r;
###
2281, getWrappedBundle, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 118, 119
4
/**
   * Returns the wrapped resource bundle.
   * @return The wrapped resource bundle.
   */
2
  public ResourceBundle getWrappedBundle() {
    return resource;
###
2282, getToolTipTextProperty, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 343, 352
7
/**
   * Get a String for a JavaBeans "toolTipText" property from the ResourceBundle.
   * <br>Convenience method.
   *
   * @param key The key of the property. This method appends ".toolTipText" to the key.
   * @return The ToolTip. Returns null if no tooltip is defined.
   */
10
  public String getToolTipTextProperty(String key) {
    try {
      String value = getStringRecursive(key + ".toolTipText");
      return value;
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + ".toolTipText\" not found.");
        //e.printStackTrace();
      }
      return null;
###
2283, getTextProperty, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 363, 372
7
/**
   * Get a String for a JavaBeans "text" property from the ResourceBundle.
   * <br>Convenience method.
   *
   * @param key The key of the property. This method appends ".text" to the key.
   * @return The ToolTip. Returns null if no tooltip is defined.
   */
10
  public String getTextProperty(String key) {
    try {
      String value = getStringRecursive(key + ".text");
      return value;
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + ".text\" not found.");
        //e.printStackTrace();
      }
      return null;
###
2284, initComponents, ODGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanel.java, 190, 223
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
26
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    toolButtonGroup = new javax.swing.ButtonGroup();
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    jPanel1 = new javax.swing.JPanel();
    creationToolbar = new javax.swing.JToolBar();
    attributesToolbar = new javax.swing.JToolBar();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    jPanel1.setLayout(new java.awt.GridBagLayout());
    creationToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(creationToolbar, gridBagConstraints);
    attributesToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(attributesToolbar, gridBagConstraints);
    add(jPanel1, java.awt.BorderLayout.SOUTH);
###
2285, getStringRecursive, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 151, 203
6
/**
   * Recursive part of the getString method.
   *
   * @param key
   * @throws java.util.MissingResourceException
   */
47
  private String getStringRecursive(String key) throws MissingResourceException {
    String value = resource.getString(key);
    // Substitute placeholders in the value
    for (int p1 = value.indexOf("${"); p1 != -1; p1 = value.indexOf("${")) {
      int p2 = value.indexOf('}', p1 + 2);
      if (p2 == -1) {
        break;
      }
      String placeholderKey = value.substring(p1 + 2, p2);
      String placeholderFormat;
      int p3 = placeholderKey.indexOf(',');
      if (p3 != -1) {
        placeholderFormat = placeholderKey.substring(p3 + 1);
        placeholderKey = placeholderKey.substring(0, p3);
      } else {
        placeholderFormat = "string";
      }
      ArrayList<String> fallbackKeys = new ArrayList<String>();
      generateFallbackKeys(placeholderKey, fallbackKeys);
      String placeholderValue = null;
      for (String fk : fallbackKeys) {
        try {
          placeholderValue = getStringRecursive(fk);
          break;
        } catch (MissingResourceException e) {
        }
      }
      if (placeholderValue == null) {
        throw new MissingResourceException("\""+key+"\" not found in "+baseName, baseName, key);
      }
      // Do post-processing depending on placeholder format 
      if (placeholderFormat.equals("accelerator")) {
        // Localize the keywords shift, control, ctrl, meta, alt, altGraph
        StringBuilder b = new StringBuilder();
        for (String s : placeholderValue.split(" ")) {
          if (acceleratorKeys.contains(s)) {
            b.append(getString("accelerator." + s));
          } else {
            b.append(s);
          }
        }
        placeholderValue = b.toString();
      }
      // Insert placeholder value into value
      value = value.substring(0, p1) + placeholderValue + value.substring(p2 + 1);
    }
    return value;
###
2286, getKeyStroke, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 384, 391
8
/**
   * Get a KeyStroke from the ResourceBundle.
   * <BR>Convenience method.
   *
   * @param key The key of the property.
   * @return <code>javax.swing.KeyStroke.getKeyStroke(value)</code>.
   *      Returns null if the property is missing.
   */
8
  public KeyStroke getKeyStroke(String key) {
    KeyStroke ks = null;
    try {
      String s = getStringRecursive(key);
      ks = (s == null) ? (KeyStroke) null : KeyStroke.getKeyStroke(s);
    } catch (NoSuchElementException e) {
    }
    return ks;
###
2287, readObject, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 538, 542
1
/** Read object from ObjectInputStream and re-establish ResourceBundle. */
5
  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    // our "pseudo-constructor"
    in.defaultReadObject();
    // re-establish the "resource" variable
    this.resource = ResourceBundle.getBundle(baseName, locale);
###
2288, generateFallbackKeys, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 210, 225
4
/**
   * Generates fallback keys by processing all property name modifiers
   * in the key.
   */
16
  private void generateFallbackKeys(String key, ArrayList<String> fallbackKeys) {
    int p1 = key.indexOf("[$");
    if (p1 == -1) {
      fallbackKeys.add(key);
    } else {
      int p2 = key.indexOf(']', p1 + 2);
      if (p2 == -1) {
        return;
      }
      String modifierKey = key.substring(p1 + 2, p2);
      String[] modifierValues = propertyNameModifiers.get(modifierKey);
      if (modifierValues == null) {
        modifierValues = new String[]{"default"};
      }
      for (String mv : modifierValues) {
        generateFallbackKeys(key.substring(0, p1) + mv + key.substring(p2 + 1), fallbackKeys);
###
2289, ODGDrawingPanel, ODGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanel.java, 51, 116
1
/** Creates new instance. */
66
  public ODGDrawingPanel() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    undoManager = new UndoRedoManager();
    editor = new DefaultDrawingEditor();
    editor.add(view);
    
    addCreationButtonsTo(creationToolbar, editor);
    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);
    
    JPopupButton pb = new JPopupButton();
    pb.setItemFont(UIManager.getFont("MenuItem.font"));
    labels.configureToolBarButton(pb, "actions");
    pb.add(new DuplicateAction());
    pb.addSeparator();
    pb.add(new GroupAction(editor));
    pb.add(new UngroupAction(editor));
    pb.addSeparator();
    pb.add(new BringToFrontAction(editor));
    pb.add(new SendToBackAction(editor));
    pb.addSeparator();
    pb.add(new CutAction());
    pb.add(new CopyAction());
    pb.add(new PasteAction());
    pb.add(new SelectAllAction());
    pb.add(new SelectSameAction(editor));
    pb.addSeparator();
    pb.add(undoManager.getUndoAction());
    pb.add(undoManager.getRedoAction());
     // FIXME - We need a toggle grid action
     // pb.addSeparator();
     // pb.add(new ToggleGridAction(editor));
    
    JMenu m = new JMenu(labels.getString("view.zoomFactor.text"));
    JRadioButtonMenuItem rbmi;
    ButtonGroup group = new ButtonGroup();
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));
    rbmi.setSelected(true);
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));
    group.add(rbmi);
    pb.add(m);
    pb.setFocusable(false);
    creationToolbar.addSeparator();
    creationToolbar.add(pb);
    
    
    DefaultDrawing drawing = new DefaultDrawing();
    view.setDrawing(drawing);
    drawing.addUndoableEditListener(undoManager);
###
2290, getInteger, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 259, 267
8
/**
   * Get an Integer from the ResourceBundle.
   * <br>Convenience method to save casting.
   *
   * @param key The key of the property.
   * @return The value of the property. Returns -1
   *      if the property is missing.
   */
9
  public Integer getInteger(String key) {
    try {
      return Integer.valueOf(getStringRecursive(key));
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + "\" not found.");
        //e.printStackTrace();
      }
      return new Integer(-1);
###
2291, getFormatted, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 236, 237
6
/**
   * Returns a formatted string using javax.text.MessageFormat.
   * @param key
   * @param arguments
   * @return formatted String
   */
2
  public String getFormatted(String key, Object... arguments) {
    return MessageFormat.format(getString(key), arguments);
###
2293, createToolBars, ODGApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGApplicationModel.java, 175, 200
3
/**
   * Creates toolbars for the application.
   */
24
  public java.util.List<JToolBar> createToolBars(Application a, View pr) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    ODGView p = (ODGView) pr;
    DrawingEditor editor;
    if (p == null) {
      editor = getSharedEditor();
    } else {
      editor = p.getEditor();
    }
    LinkedList<JToolBar> list = new LinkedList<JToolBar>();
    JToolBar tb;
    tb = new JToolBar();
    addCreationButtonsTo(tb, editor);
    tb.setName(labels.getString("window.drawToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    addAttributesButtonsTo(tb, editor);
    tb.setName(labels.getString("window.attributesToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    ButtonFactory.addAlignmentButtonsTo(tb, editor);
    tb.setName(labels.getString("window.alignmentToolBar.title"));
    list.add(tb);
    return list;
###
2294, addAttributesButtonsTo, ODGApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGApplicationModel.java, 130, 144
3
/**
   * Creates toolbar buttons and adds them to the specified JToolBar
   */
13
  private void addAttributesButtonsTo(JToolBar bar, DrawingEditor editor) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    JButton b;
    b = bar.add(new PickAttributesAction(editor));
    b.setFocusable(false);
    b = bar.add(new ApplyAttributesAction(editor));
    b.setFocusable(false);
    bar.addSeparator();
    addColorButtonsTo(bar, editor);
    bar.addSeparator();
    addStrokeButtonsTo(bar, editor);
    bar.addSeparator();
    ButtonFactory.addFontButtonsTo(bar, editor);
###
2295, ODGApplicationModel, ODGApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGApplicationModel.java, 64, 65
1
/** Creates a new instance. */
2
  public ODGApplicationModel() {
    setViewClass(ODGView.class);
###
2296, NodeFigure, NodeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/figures/NodeFigure.java, 47, 54
1
/** Creates a new instance. */
8
  public NodeFigure() {
    RectangleFigure rf = new RectangleFigure();
    setDecorator(rf);
    createConnectors();
    set(DECORATOR_INSETS, new Insets2D.Double(6, 10, 6, 10));
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.net.Labels");
    setText(labels.getString("nodeDefaultName"));
    setAttributeEnabled(DECORATOR_INSETS, false);
###
2300, userNodeForPackage, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 245, 259
5
/** Gets the user node for the package of the class if
   * permitted, gets a proxy otherwise.
   *
   * @return user node or a proxy.
   */
14
  public static Preferences userNodeForPackage(Class<?> c) {
    if (userNodes != null) {
      if (!userNodes.containsKey(c.getPackage())) {
        userNodes.put(c.getPackage(), new PreferencesUtil(false));
      }
      return userNodes.get(c.getPackage());
    }
    try {
      return Preferences.userNodeForPackage(c);
    } catch (Throwable t) {
      if (userNodes == null) {
        userNodes = new HashMap<Package, Preferences>();
      }
      return userNodeForPackage(c);
###
2305, systemNodeForPackage, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 221, 236
5
/** Gets the system node for the package of the class if
   * permitted, gets a proxy otherwise.
   *
   * @return system node or a proxy.
   */
15
  public static Preferences systemNodeForPackage(Class<?> c) {
    if (systemNodes != null) {
      if (!systemNodes.containsKey(c.getPackage())) {
        systemNodes.put(c.getPackage(), new PreferencesUtil(false));
      }
      return systemNodes.get(c.getPackage());
    }

    try {
      return Preferences.systemNodeForPackage(c);
    } catch (Throwable t) {
      if (systemNodes == null) {
        systemNodes = new HashMap<Package, Preferences>();
      }
      return systemNodeForPackage(c);
###
2306, installToolBarPrefsHandler, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 482, 483
9
/**
   * Installs a toolbar preferences handler.
   * On first run, sets the toolbar to BorderLayout.TOP.
   * On subsequent runs, set the toolbar to the last BorderLayout location.
   *
   * @param prefs Preferences for storing/retrieving preferences values.
   * @param name Base name of the preference.
   * @param toolbar The JToolBar for which to track preferences.
   */
2
  public static void installToolBarPrefsHandler(final Preferences prefs, final String name, JToolBar toolbar) {
    new ToolBarPrefsHandler(toolbar, name, prefs);
###
2307, installPalettePrefsHandler, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 367, 368
11
/**
   * Installs a palette preferences handler.
   * On first run, sets the palette to its preferred location at the top left
   * corner of the screen.
   * On subsequent runs, sets the palette the last location where
   * the user had placed it before.
   *
   * @param prefs Preferences for storing/retrieving preferences values.
   * @param name Base name of the preference.
   * @param window The window for which to track preferences.
   */
2
  public static void installPalettePrefsHandler(final Preferences prefs, final String name, Window window) {
    installPalettePrefsHandler(prefs, name, window, 0);
###
2308, installInternalFramePrefsHandler, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 432, 467
11
/**
   * Installs an intenal frame preferences handler.
   * On first run, sets the frame to its preferred size at the top left
   * corner of the desktop pane.
   * On subsequent runs, sets the frame the last size and location where
   * the user had placed it before.
   *
   * @param prefs Preferences for storing/retrieving preferences values.
   * @param name Base name of the preference.
   * @param window The window for which to track preferences.
   */
29
  public static void installInternalFramePrefsHandler(final Preferences prefs, final String name, JInternalFrame window, JDesktopPane desktop) {
    Rectangle screenBounds = desktop.getBounds();
    screenBounds.setLocation(0, 0);
    Insets screenInsets = desktop.getInsets();
    screenBounds.x += screenInsets.left;
    screenBounds.y += screenInsets.top;
    screenBounds.width -= screenInsets.left + screenInsets.right;
    screenBounds.height -= screenInsets.top + screenInsets.bottom;
    Dimension preferredSize = window.getPreferredSize();
    Dimension minSize = window.getMinimumSize();
    Rectangle bounds = new Rectangle(
        prefs.getInt(name + ".x", 0),
        prefs.getInt(name + ".y", 0),
        Math.max(minSize.width, prefs.getInt(name + ".width", preferredSize.width)),
        Math.max(minSize.height, prefs.getInt(name + ".height", preferredSize.height)));
    if (!screenBounds.contains(bounds)) {
      bounds.x = screenBounds.x + (screenBounds.width - bounds.width) / 2;
      bounds.y = screenBounds.y + (screenBounds.height - bounds.height) / 2;
      Rectangle.intersect(screenBounds, bounds, bounds);
    }
    window.setBounds(bounds);
    window.addComponentListener(new ComponentAdapter() {
      public void componentMoved(ComponentEvent evt) {
        prefs.putInt(name + ".x", evt.getComponent().getX());
        prefs.putInt(name + ".y", evt.getComponent().getY());
      }
      public void componentResized(ComponentEvent evt) {
        prefs.putInt(name + ".width", evt.getComponent().getWidth());
        prefs.putInt(name + ".height", evt.getComponent().getHeight());
###
2311, installFramePrefsHandler, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 285, 286
14
/**
   * Installs a frame preferences handler.
   * On first run, sets the window to its preferred size at the top left
   * corner of the screen.
   * On subsequent runs, sets the window the last size and location where
   * the user had placed it before.
   * <p>
   * If no preferences are stored yet for this window, a default size
   * of 400 x 300 pixels is used.
   *
   * @param prefs Preferences for storing/retrieving preferences values.
   * @param name Base name of the preference.
   * @param window The window for which to track preferences.
   */
2
  public static void installFramePrefsHandler(final Preferences prefs, final String name, Window window) {
    installFramePrefsHandler(prefs, name, window, new Dimension(400, 300));
###
2312, clear, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 239, 253
3
/**
   * Clears the view.
   */
15
  public void clear() {
    final Drawing newDrawing = createDrawing();
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(newDrawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InvocationTargetException ex) {
      ex.printStackTrace();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
###
2313, initActions, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 173, 175
3
/**
   * Initializes view specific actions.
   */
3
  private void initActions() {
    getActionMap().put(UndoAction.ID, undo.getUndoAction());
    getActionMap().put(RedoAction.ID, undo.getRedoAction());
###
2314, installFramePrefsHandler, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 302, 350
13
/**
   * Installs a frame preferences handler.
   * On first run, sets the window to its preferred size at the top left
   * corner of the screen.
   * On subsequent runs, sets the window the last size and location where
   * the user had placed it before.
   *
   * @param prefs Preferences for storing/retrieving preferences values.
   * @param name Base name of the preference.
   * @param window The window for which to track preferences.
   * @param defaultSize This size is used when no prefences are stored yet for this window.
   *
   */
44
  public static void installFramePrefsHandler(final Preferences prefs, final String name, Window window, Dimension defaultSize) {
    GraphicsConfiguration conf = window.getGraphicsConfiguration();
    Rectangle screenBounds = conf.getBounds();
    Insets screenInsets = window.getToolkit().getScreenInsets(conf);
    screenBounds.x += screenInsets.left;
    screenBounds.y += screenInsets.top;
    screenBounds.width -= screenInsets.left + screenInsets.right;
    screenBounds.height -= screenInsets.top + screenInsets.bottom;
    window.pack();
    Dimension preferredSize = window.getPreferredSize();
    boolean resizable = true;
    if (window instanceof Frame) {
      resizable = ((Frame) window).isResizable();
    } else if (window instanceof Dialog) {
      resizable = ((Dialog) window).isResizable();
    }
    Rectangle bounds;
    if (resizable) {
      bounds = new Rectangle(
          prefs.getInt(name + ".x", 0),
          prefs.getInt(name + ".y", 0),
          Math.max(defaultSize.width, prefs.getInt(name + ".width", preferredSize.width)),
          Math.max(defaultSize.height, prefs.getInt(name + ".height", preferredSize.height)));
    } else {
      bounds = new Rectangle(
          prefs.getInt(name + ".x", 0),
          prefs.getInt(name + ".y", 0),
          window.getWidth(), window.getHeight());
    }
    if (!screenBounds.contains(bounds)) {
      bounds.x = screenBounds.x + (screenBounds.width - bounds.width) / 2;
      bounds.y = screenBounds.y + (screenBounds.height - bounds.height) / 2;
      Rectangle.intersect(screenBounds, bounds, bounds);
    }
    window.setBounds(bounds);
    window.addComponentListener(
        new ComponentAdapter() {
          public void componentMoved(ComponentEvent evt) {
            prefs.putInt(name + ".x", evt.getComponent().getX());
            prefs.putInt(name + ".y", evt.getComponent().getY());
          }
          public void componentResized(ComponentEvent evt) {
            prefs.putInt(name + ".width", evt.getComponent().getWidth());
            prefs.putInt(name + ".height", evt.getComponent().getHeight());
###
2315, read, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 194, 212
3
/**
   * Reads the view from the specified uri.
   */
19
  public void read(URI f, URIChooser chooser) throws IOException {
    try {
      final Drawing drawing = createDrawing();
      InputFormat inputFormat = drawing.getInputFormats().get(0);
      inputFormat.read(new File(f), drawing, true);
      SwingUtilities.invokeAndWait(new Runnable() { public void run() {
        view.getDrawing().removeUndoableEditListener(undo);
        view.setDrawing(drawing);
        view.getDrawing().addUndoableEditListener(undo);
        undo.discardAllEdits();
      }});
    } catch (InterruptedException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
    } catch (InvocationTargetException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
###
2316, write, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 185, 188
3
/**
   * Writes the view to the specified uri.
   */
4
  public void write(URI f, URIChooser chooser) throws IOException {
      Drawing drawing = view.getDrawing();
      OutputFormat outputFormat = drawing.getOutputFormats().get(0);
      outputFormat.write(new File(f), drawing);
###
2317, NetView, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 71, 114
3
/**
   * Creates a new view.
   */
44
  public NetView() {
    initComponents();
    
    JPanel zoomButtonPanel = new JPanel(new BorderLayout());
    scrollPane.setLayout(new PlacardScrollPaneLayout());
    scrollPane.setBorder(new EmptyBorder(0,0,0,0));
    
    setEditor(new DefaultDrawingEditor());
    undo = new UndoRedoManager();
    view.setDrawing(createDrawing());
    view.getDrawing().addUndoableEditListener(undo);
    initActions();
    undo.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        setHasUnsavedChanges(undo.hasSignificantEdits());
      }
    });
    
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    
    JPanel placardPanel = new JPanel(new BorderLayout());
    javax.swing.AbstractButton pButton;
    pButton = ButtonFactory.createZoomButton(view);
    pButton.putClientProperty("Quaqua.Button.style","placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin",new Insets(0,0,0,0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    placardPanel.add(pButton, BorderLayout.WEST);
    toggleGridButton = pButton = ButtonFactory.createToggleGridButton(view);
    pButton.putClientProperty("Quaqua.Button.style","placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin",new Insets(0,0,0,0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    labels.configureToolBarButton(pButton, "view.toggleGrid.placard");
    placardPanel.add(pButton, BorderLayout.EAST);
    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);
    
    toggleGridButton.setSelected(preferences.getBoolean("view.gridVisible", false));
    view.setScaleFactor(preferences.getDouble("view.scaleFactor", 1d));
    
    view.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        String name = evt.getPropertyName();
        if (name.equals("scaleFactor")) {
          preferences.putDouble("view.scaleFactor", (Double) evt.getNewValue());
          firePropertyChange("scaleFactor", evt.getOldValue(), evt.getNewValue());
###
2318, createPageable, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 145, 146
3
/**
   * Creates a Pageable object for printing the view.
   */
2
  public Pageable createPageable() {
    return new DrawingPageable(view.getDrawing());
###
2319, initComponents, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 268, 279
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
8
  private void initComponents() {
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
###
2320, setDrawingEditor, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 219, 225
3
/**
   * Sets a drawing editor for the view.
   */
7
  public void setDrawingEditor(DrawingEditor newValue) {
    if (editor != null) {
      editor.remove(view);
    }
    editor = newValue;
    if (editor != null) {
      editor.add(view);
###
2321, createDrawing, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 132, 140
3
/**
   * Creates a new Drawing for this view.
   */
9
  protected Drawing createDrawing() {
    DefaultDrawing drawing = new DefaultDrawing();
    DOMStorableInputOutputFormat ioFormat =
        new DOMStorableInputOutputFormat(new NetFactory());
    drawing.addInputFormat(ioFormat);
    drawing.addInputFormat(new TextInputFormat(new NodeFigure()));
    drawing.addOutputFormat(ioFormat);
    drawing.addOutputFormat(new ImageOutputFormat());
    return drawing;
###
2322, getDrawingEditor, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 232, 233
3
/**
   * Gets the drawing editor of the view.
   */
2
  public DrawingEditor getDrawingEditor() {
    return editor;
###
2324, getDefaultPropertyIndex, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2325, getMethodDescriptors, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2326, getPropertyDescriptors, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2327, getBeanDescriptor, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2329, getEventSetDescriptors, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2332, getDefaultEventIndex, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2333, getMethodDescriptors, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 121, 122
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2334, getPropertyDescriptors, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 99, 100
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2340, getBeanDescriptor, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 83, 84
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2343, getDefaultEventIndex, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 144, 145
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2344, getDefaultPropertyIndex, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 133, 134
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2345, getEventSetDescriptors, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 110, 111
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2346, getStrokePaint, ODGAttributeKeys, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGAttributeKeys.java, 119, 132
5
/**
   * Gets the stroke paint for the specified figure based on the attributes
   * STROKE_GRADIENT, STROKE_OPACITY, STROKE_PAINT and the bounds of the figure.
   * Returns null if the figure is not filled.
   */
14
  public static Paint getStrokePaint(Figure f) {
    double opacity = f.get(STROKE_OPACITY);
    if (f.get(STROKE_GRADIENT) != null) {
      return f.get(STROKE_GRADIENT).getPaint(f, opacity);
    }
    Color color = f.get(STROKE_COLOR);
    if (color != null) {
      if (opacity != 1) {
        color = new Color(
            (color.getRGB() & 0xffffff) | (int) (opacity * 255) << 24,
            true);
      }
    }
    return color;
###
2347, getFillPaint, ODGAttributeKeys, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGAttributeKeys.java, 99, 112
5
/**
   * Gets the fill paint for the specified figure based on the attributes
   * FILL_GRADIENT, FILL_OPACITY, FILL_PAINT and the bounds of the figure.
   * Returns null if the figure is not filled.
   */
14
  public static Paint getFillPaint(Figure f) {
    double opacity = f.get(FILL_OPACITY);
    if (f.get(FILL_GRADIENT) != null) {
      return f.get(FILL_GRADIENT).getPaint(f, opacity);
    }
    Color color = f.get(FILL_COLOR);
    if (color != null) {
      if (opacity != 1) {
        color = new Color(
            (color.getRGB() & 0xffffff) | (int) (opacity * 255) << 24,
            true);
      }
    }
    return color;
###
2348, setDefaults, ODGAttributeKeys, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGAttributeKeys.java, 143, 157
1
/** Sets ODG default values. */
15
  public static void setDefaults(Figure f) {
    // Fill properties
    f.set(FILL_COLOR, Color.black);
    f.set(WINDING_RULE, WindingRule.NON_ZERO);
    
    // Stroke properties
    f.set(STROKE_COLOR, null);
    f.set(STROKE_WIDTH, 1d);
    f.set(STROKE_CAP, BasicStroke.CAP_BUTT);
    f.set(STROKE_JOIN, BasicStroke.JOIN_MITER);
    f.set(STROKE_MITER_LIMIT, 4d);
    f.set(IS_STROKE_MITER_LIMIT_FACTOR, false);
    f.set(STROKE_DASHES, null);
    f.set(STROKE_DASH_PHASE, 0d);
    f.set(IS_STROKE_DASH_FACTOR, false);
###
2351, getDefaultEventIndex, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 156, 158
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
3
  @Override
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2352, getDefaultPropertyIndex, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 144, 146
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
3
  @Override
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2355, getPropertyDescriptors, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 107, 109
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
3
  @Override
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2356, getEventSetDescriptors, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 119, 121
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
3
  @Override
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2357, getMethodDescriptors, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 131, 133
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
3
  @Override
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2358, getBeanDescriptor, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 90, 92
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
3
  @Override
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2359, LinkToolBar, LinkToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBar.java, 44, 47
1
/** Creates new instance. */
4
  public LinkToolBar() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
    setDisclosureStateCount(3);
###
2360, getMethodDescriptors, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2361, getBeanDescriptor, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2363, getPropertyDescriptors, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2364, getEventSetDescriptors, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2366, getDefaultEventIndex, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2368, getDefaultPropertyIndex, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2369, getDefaultPropertyIndex, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 144, 146
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
3
  @Override
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2371, getPropertyDescriptors, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 107, 109
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
3
  @Override
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2373, getBeanDescriptor, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 90, 92
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
3
  @Override
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2375, getMethodDescriptors, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 131, 133
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
3
  @Override
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2376, getDefaultEventIndex, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 156, 158
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
3
  @Override
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2377, getEventSetDescriptors, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 119, 121
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
3
  @Override
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2378, FontToolBar, FontToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBar.java, 51, 55
1
/** Creates new instance. */
5
  public FontToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString("font.toolbar"));
    JFontChooser.loadAllFonts();
    setDisclosureStateCount(3);
###
2379, FillToolBar, FillToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBar.java, 45, 48
1
/** Creates new instance. */
4
  public FillToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
    setDisclosureStateCount(3);
###
2380, FigureToolBar, FigureToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBar.java, 43, 46
1
/** Creates new instance. */
4
  public FigureToolBar() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
    setDisclosureStateCount(3);
###
2381, save, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 89, 96
3
/**
   * Writes the contents of the DOMOutput into the specified writer.
   */
8
  public void save(Writer out) throws IOException {
    if (doctype != null) {
      out.write("<!DOCTYPE ");
      out.write(doctype);
      out.write(">\n");
    }
    XMLWriter writer = new XMLWriter(out);
    writer.write((XMLElement) document.getChildren().get(0));
###
2383, save, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 81, 84
3
/**
   * Writes the contents of the DOMOutput into the specified output stream.
   */
4
  public void save(OutputStream out) throws IOException {
    Writer w = new OutputStreamWriter(out, "UTF8");
    save(w);
    w.flush();
###
2384, NanoXMLDOMOutput, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 69, 75
1
/** Creates a new instance. */
7
  public NanoXMLDOMOutput(DOMFactory factory) {
    this.factory = factory;
    objectids = new HashMap<Object,String>();
    document = new XMLElement();//new HashMap(), false, false);
    current = document;
    stack = new Stack<XMLElement>();
    stack.push(current);
###
2385, addAttribute, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 158, 160
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
3
  public void addAttribute(String name, String value) {
    if (value != null) {
      current.setAttribute(name, value);
###
2386, addAttribute, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 187, 191
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
5
  public void addAttribute(String name, double value) {
    // Remove the awkard .0 at the end of each number
    String str = Double.toString(value);
    if (str.endsWith(".0")) str = str.substring(0, str.length() - 2);
    current.setAttribute(name, str);
###
2387, closeElement, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 134, 135
6
/**
   * Closes the current element of the DOM Document.
   * The parent of the current element becomes the current element.
   * @exception IllegalArgumentException if the provided tagName does
   * not match the tag name of the element.
   */
2
  public void closeElement() {
    current = (XMLElement) stack.pop();
###
2388, addText, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 147, 152
7
/**
   * Adds a text to current element of the DOM Document.
   * Note: Multiple consecutives texts will be merged.
   */
 --------------
// NanoXML does not support comments
 --------------
6
  public void addText(String text) {
    String old = current.getContent();
    if (old == null) {
      current.setContent(text);
    } else {
      current.setContent(old+text);
###
2389, openElement, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 121, 126
9
/**
   * Puts a new element into the DOM Document.
   * The new element is added as a child to the current element in the DOM
   * document. Then it becomes the current element.
   * The element must be closed using closeElement.
   */
 --------------
//((XMLElement) document.getChildren().get(0)).print(out);
 --------------
6
  public void openElement(String tagName) {
    XMLElement newElement = new XMLElement();//new HashMap(), false, false);
    newElement.setName(tagName);
    current.addChild(newElement);
    stack.push(current);
    current = newElement;
###
2390, addAttribute, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 166, 167
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
2
  public void addAttribute(String name, int value) {
    current.setAttribute(name, Integer.toString(value));
###
2391, print, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 101, 110
3
/**
   * Prints the contents of the DOMOutput into the specified print writer.
   */
10
  public void print(PrintWriter out) {
    XMLWriter writer = new XMLWriter(out);
    
    try {
      // writer.write(document);
      writer.write((XMLElement) document.getChildren().get(0), true);
    } catch (IOException e) {
      InternalError error = new InternalError();
      error.initCause(e);
      throw error;
###
2392, addAttribute, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 178, 182
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
5
  public void addAttribute(String name, float value) {
    // Remove the awkard .0 at the end of each number
    String str = Float.toString(value);
    if (str.endsWith(".0")) str = str.substring(0, str.length() - 2);
    current.setAttribute(name, str);
###
2393, addAttribute, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 172, 173
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
2
  public void addAttribute(String name, boolean value) {
    current.setAttribute(name, new Boolean(value).toString());
###
2411, addEnumClass, DefaultDOMFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java, 56, 58
3
/**
   * Adds an Enum class to the DOMFactory.
   */
3
  public void addEnumClass(String name, Class c) {
    enumClassToNameMap.put(c, name);
    nameToEnumClassMap.put(name, c);
###
2412, addEnum, DefaultDOMFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java, 63, 72
3
/**
   * Adds an Enum value to the DOMFactory.
   */
10
  public void addEnum(String value, Enum e) {
    enumToValueMap.put(e, value);
    Set<Enum> enums;
    if (valueToEnumMap.containsKey(value)) {
      enums = valueToEnumMap.get(value);
    } else {
      enums = new HashSet<Enum>();
      valueToEnumMap.put(value, enums);
    }
    enums.add(e);
###
2413, addStorableClass, DefaultDOMFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java, 41, 43
3
/**
   * Adds a DOMStorable class to the DOMFactory.
   */
3
  public void addStorableClass(String name, Class c) {
    nameToPrototypeMap.put(name, c);
    classToNameMap.put(c, name);
###
2414, addStorable, DefaultDOMFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java, 48, 50
3
/**
   * Adds a DOMStorable prototype to the DOMFactory.
   */
3
  public void addStorable(String name, DOMStorable prototype) {
    nameToPrototypeMap.put(name, prototype);
    classToNameMap.put(prototype.getClass(), name);
###
2415, getElementCount, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 197, 207
4
/**
   * Returns the number of child elements with the specified tag name
   * of the current element.
   */
11
  public int getElementCount(String tagName) {
    int count = 0;
    NodeList list = current.getChildNodes();
    for (int i=0; i < list.getLength(); i++) {
      Node node = list.item(i);
      if ((node instanceof Element)
      && ((Element) node).getTagName().equals(tagName)) {
        count++;
      }
    }
    return count;
###
2416, readObject, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 283, 284
3
/**
   * Reads an object from the current element.
   */
2
  public Object readObject() throws IOException {
    return readObject(0);
###
2417, getAttribute, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 173, 175
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public boolean getAttribute(String name, boolean defaultValue) {
    String value = ((Element) current).getAttribute(name);
    return (value.length() == 0) ? defaultValue : Boolean.valueOf(value).booleanValue();
###
2418, getElementCount, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 182, 191
3
/**
   * Returns the number of child elements of the current element.
   */
10
  public int getElementCount() {
    int count = 0;
    NodeList list = current.getChildNodes();
    for (int i=0; i < list.getLength(); i++) {
      Node node = list.item(i);
      if ((node instanceof Element)) {
        count++;
      }
    }
    return count;
###
2419, openElement, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 231, 243
3
/**
   * Opens the last element with the specified name and makes it the current node.
   */
13
  public void openElement(String tagName) {
    int count = 0;
    NodeList list = current.getChildNodes();
    int len = list.getLength();
    for (int i=0; i < len; i++) {
      Node node = list.item(i);
      if ((node instanceof Element)
      && ((Element) node).getTagName().equals(tagName)) {
        current = node;
        return;
      }
    }
    throw new IllegalArgumentException("element not found:"+tagName);
###
2420, getBuilder, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 64, 79
4
/**
   * Lazily create the document builder and keep a reference to it for
   * performance improvement.
   */
16
  protected static DocumentBuilder getBuilder() throws IOException {
    if (documentBuilder == null) {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      factory.setNamespaceAware(true);
      factory.setValidating(false);
      factory.setXIncludeAware(false);
      try {
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        documentBuilder = factory.newDocumentBuilder();
      } catch (Exception ex) {
        InternalError error = new InternalError("Unable to create DocumentBuilder");
        error.initCause(ex);
        throw error;
      }
    }
    return documentBuilder;
###
2421, openElement, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 213, 222
3
/**
   * Opens the element with the specified index and makes it the current node.
   */
10
  public void openElement(int index) {
    int count = 0;
    NodeList list = current.getChildNodes();
    int len = list.getLength();
    for (int i=0; i < len; i++) {
      Node node = list.item(i);
      if ((node instanceof Element)) {
        if (count++ == index) {
          current = node;
          return;
###
2422, getText, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 127, 133
3
/**
   * Gets the text of the current element of the DOM Document.
   */
7
  public String getText(String defaultValue) {
    if (current.getChildNodes().getLength() == 0) return defaultValue;
    
    StringBuilder buf = new StringBuilder();
    getText(current, buf);
    
    return buf.toString();
###
2423, getAttribute, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 166, 168
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public double getAttribute(String name, double defaultValue) {
    String value = ((Element) current).getAttribute(name);
    return (value.length() == 0) ? defaultValue : Double.parseDouble(value);
###
2424, getInheritedAttribute, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 146, 154
4
/**
   * Gets an attribute of the current element of the DOM Document and of
   * all parent DOM elements.
   */
9
  public java.util.List<String> getInheritedAttribute(String name) {
    LinkedList<String> values = new LinkedList<String>();
    Node node = current;
    while (node != null) {
      String value = (String) ((Element) node).getAttribute(name);
      values.addFirst(value);
      node = node.getParentNode();
    }
    return values;
###
2425, readObject, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 289, 353
3
/**
   * Reads an object from the current element.
   */
65
  public Object readObject(int index) throws IOException {
    openElement(index);
    Object o;
    
    String tagName = getTagName();
    if (tagName.equals("null")) {
      o =  null;
    } else if (tagName.equals("string")) {
      o = getText();
    } else if (tagName.equals("int")) {
      o = Integer.decode(getText());
    } else if (tagName.equals("long")) {
      o = Long.decode(getText());
    } else if (tagName.equals("float")) {
      o = new Float(Float.parseFloat(getText()));
    } else if (tagName.equals("double")) {
      o = new Double(Double.parseDouble(getText()));
    } else if (tagName.equals("boolean")) {
      o = Boolean.valueOf(getText());
    } else if (tagName.equals("color")) {
      o = new Color(getAttribute("rgba",0xff));
    } else if (tagName.equals("intArray")) {
      int[] a = new int[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Integer) readObject(i)).intValue();
      }
      o = a;
    } else if (tagName.equals("floatArray")) {
      float[] a = new float[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Float) readObject(i)).floatValue();
      }
      o = a;
    } else if (tagName.equals("doubleArray")) {
      double[] a = new double[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Double) readObject(i)).doubleValue();
      }
      o = a;
    } else if (tagName.equals("font")) {
      o = new Font(getAttribute("name", "Dialog"), getAttribute("style", 0), getAttribute("size", 0));
    } else if (tagName.equals("enum")) {
      o = factory.createEnum(getAttribute("type",(String)null), getText());
    } else {
      String ref = getAttribute("ref", null);
      String id = getAttribute("id", ref);
      
      // Keep track of objects which have an ID
      if (id == null) {
        o = factory.create(getTagName());
      } else if (idobjects.containsKey(id)) {
        o = idobjects.get(id);
      } else {
        o = factory.create(getTagName());
        idobjects.put(id, o);
      }
      if (ref == null) {
        if (o instanceof DOMStorable) {
          ((DOMStorable) o).read(this);
        }
      }
    }
    
    closeElement();
    return o;
###
2426, getText, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 121, 122
3
/**
   * Gets the text of the current element of the DOM Document.
   */
2
  public String getText() {
    return getText(null);
###
2427, getTagName, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 108, 109
3
/**
   * Returns the tag name of the current element.
   */
2
  public String getTagName() {
    return ((Element) current).getTagName();
###
2428, closeElement, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 272, 277
6
/**
   * Closes the current element of the DOM Document.
   * The parent of the current element becomes the current element.
   * @exception IllegalArgumentException if the provided tagName does
   * not match the tag name of the element.
   */
6
  public void closeElement() {
    /*
    if (! ((Element) current).getTagName().equals(tagName)) {
      throw new IllegalArgumentException("Attempt to close wrong element:"+tagName +"!="+((Element) current).getTagName());
    }*/
    current = current.getParentNode();
###
2429, openElement, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 249, 263
4
/**
   * Opens the element with the specified name and index and makes it the
   * current node.
   */
15
  public void openElement(String tagName, int index) {
    int count = 0;
    NodeList list = current.getChildNodes();
    int len = list.getLength();
    for (int i=0; i < len; i++) {
      Node node = list.item(i);
      if ((node instanceof Element)
      && ((Element) node).getTagName().equals(tagName)) {
        if (count++ == index) {
          current = node;
          return;
        }
      }
    }
    throw new IllegalArgumentException("no such child "+tagName+"["+index+"]");
###
2430, getAttribute, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 159, 161
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public int getAttribute(String name, int defaultValue) {
    String value = ((Element) current).getAttribute(name);
    return (value.length() == 0) ? defaultValue : (int) Long.decode(value).intValue();
###
2431, getAttribute, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 114, 116
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public String getAttribute(String name, String defaultValue) {
    String value = ((Element) current).getAttribute(name);
    return (value.length() == 0) ? defaultValue : value;
###
2432, JavaxDOMOutput, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 68, 69
1
/** Creates a new instance. */
2
  public JavaxDOMOutput(DOMFactory factory) throws IOException {
    this.factory = factory;
###
2433, addAttribute, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 178, 179
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
2
  public void addAttribute(String name, boolean value) {
    ((Element) current).setAttribute(name, Boolean.toString(value));
###
2434, addText, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 158, 159
4
/**
   * Adds a text to current element of the DOM Document.
   * Note: Multiple consecutives texts will be merged.
   */
2
  public void addText(String text) {
    current.appendChild(document.createTextNode(text));
###
2435, addComment, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 151, 152
3
/**
   * Adds a comment to the current element of the DOM Document.
   */
2
  public void addComment(String comment) {
    current.appendChild(document.createComment(comment));
###
2436, save, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 107, 120
3
/**
   * Writes the contents of the DOMOutput into the specified output stream.
   */
14
  public void save(Writer out) throws IOException {
    reset();
    try {
      if (doctype != null) {
        out.write("<!DOCTYPE ");
        out.write(doctype);
        out.write(">\n");
      }
      Transformer t = TransformerFactory.newInstance().newTransformer();
      t.transform(new DOMSource(document), new StreamResult(out));
    } catch (TransformerException e) {
      IOException error = new IOException(e.getMessage());
      error.initCause(e);
      throw error;
###
2437, addAttribute, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 193, 197
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
5
  public void addAttribute(String name, double value) {
    // Remove the awkard .0 at the end of each number
    String str = Double.toString(value);
    if (str.endsWith(".0")) str = str.substring(0, str.length() - 2);
    ((Element) current).setAttribute(name, str);
###
2438, closeElement, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 141, 146
6
/**
   * Closes the current element of the DOM Document.
   * The parent of the current element becomes the current element.
   * @exception IllegalArgumentException if the provided tagName does
   * not match the tag name of the element.
   */
6
  public void closeElement() {
    /*
    if (! ((Element) current).getName().equals(tagName)) {
      throw new IllegalArgumentException("Attempt to close wrong element:"+tagName +"!="+((Element) current).getName());
    }*/
    current = current.getParentNode();
###
2439, addAttribute, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 164, 166
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
3
  public void addAttribute(String name, String value) {
    if (value != null) {
      ((Element) current).setAttribute(name, value);
###
2440, openElement, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 130, 133
6
/**
   * Puts a new element into the DOM Document.
   * The new element is added as a child to the current element in the DOM
   * document. Then it becomes the current element.
   * The element must be closed using closeElement.
   */
4
  public void openElement(String tagName) {
    Element newElement = document.createElement(tagName);
    current.appendChild(newElement);
    current = newElement;
###
2441, addAttribute, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 172, 173
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
2
  public void addAttribute(String name, int value) {
    ((Element) current).setAttribute(name, Integer.toString(value));
###
2442, save, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 86, 101
3
/**
   * Writes the contents of the DOMOutput into the specified output stream.
   */
16
  public void save(OutputStream out) throws IOException {
    reset();
    try {
      if (doctype != null) {
        OutputStreamWriter w = new OutputStreamWriter(out, "UTF8");
        w.write("<!DOCTYPE ");
        w.write(doctype);
        w.write(">\n");
        w.flush();
      }
      Transformer t = TransformerFactory.newInstance().newTransformer();
      t.transform(new DOMSource(document), new StreamResult(out));
    } catch (TransformerException e) {
      IOException error = new IOException(e.getMessage());
      error.initCause(e);
      throw error;
###
2443, addAttribute, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 184, 188
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
5
  public void addAttribute(String name, float value) {
    // Remove the awkard .0 at the end of each number
    String str = Float.toString(value);
    if (str.endsWith(".0")) str = str.substring(0, str.length() - 2);
    ((Element) current).setAttribute(name, str);
###
2463, getText, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 114, 115
3
/**
   * Gets the text of the current element of the DOM Document.
   */
2
  public String getText() {
    return getText(null);
###
2464, getInheritedAttribute, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 101, 109
4
/**
   * Gets an attribute of the current element of the DOM Document and of
   * all parent DOM elements.
   */
9
  public java.util.List<String> getInheritedAttribute(String name) {
    LinkedList<String> values = new LinkedList<String>();
    for (XMLElement node: stack) {
      String value = (String) node.getAttribute(name);
      values.add(value);
    }
    String value = (String) current.getAttribute(name);
    values.add(value);
    return values;
###
2465, getAttribute, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 141, 143
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public boolean getAttribute(String name, boolean defaultValue) {
    String value = (String) current.getAttribute(name);
    return (value == null || value.length() == 0) ? defaultValue : Boolean.valueOf(value).booleanValue();
###
2466, openElement, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 197, 210
4
/**
   * Opens the element with the specified name and index and makes it the
   * current node.
   */
14
  public void openElement(String tagName, int index) throws IOException {
    int count = 0;
    ArrayList list = current.getChildren();
    for (int i=0; i < list.size(); i++) {
      XMLElement node = (XMLElement) list.get(i);
      if (node.getName().equals(tagName)) {
        if (count++ == index) {
          stack.push(current);
          current = node;
          return;
        }
      }
    }
    throw new IOException("no such element:"+tagName+" at index:"+index);
###
2467, getAttribute, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 127, 129
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public int getAttribute(String name, int defaultValue) {
    String value = (String) current.getAttribute(name);
    return (value == null || value.length() == 0) ? defaultValue : (int) Long.decode(value).intValue();
###
2468, openElement, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 181, 191
3
/**
   * Opens the last element with the specified name and makes it the current node.
   */
11
  public void openElement(String tagName) throws IOException {
    ArrayList list = current.getChildren();
    for (int i=0; i < list.size(); i++) {
      XMLElement node = (XMLElement) list.get(i);
      if (node.getName().equals(tagName)) {
        stack.push(current);
        current = node;
        return;
      }
    }
    throw new IOException("no such element:"+tagName);
###
2469, getTagName, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 87, 88
3
/**
   * Returns the tag name of the current element.
   */
2
  public String getTagName() {
    return current.getName();
###
2470, getAttribute, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 93, 95
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public String getAttribute(String name, String defaultValue) {
    String value = (String) current.getAttribute(name);
    return (value == null || value.length() == 0) ? defaultValue : value;
###
2471, getElementCount, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 157, 166
4
/**
   * Returns the number of child elements with the specified tag name
   * of the current element.
   */
10
  public int getElementCount(String tagName) {
    int count = 0;
    ArrayList list = current.getChildren();
    for (int i=0; i < list.size(); i++) {
      XMLElement node = (XMLElement) list.get(i);
      if (node.getName().equals(tagName)) {
        count++;
      }
    }
    return count;
###
2472, openElement, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 172, 175
3
/**
   * Opens the element with the specified index and makes it the current node.
   */
4
  public void openElement(int index) {
    stack.push(current);
    ArrayList list = current.getChildren();
    current = (XMLElement) list.get(index);
###
2473, getText, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 120, 122
3
/**
   * Gets the text of the current element of the DOM Document.
   */
3
  public String getText(String defaultValue) {
    String value = current.getContent();
    return (value == null) ? defaultValue : value;
###
2474, readObject, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 232, 297
3
/**
   * Reads an object from the current element.
   */
66
  public Object readObject(int index) throws IOException {
    openElement(index);
    Object o;
    
    String tagName = getTagName();
    if (tagName.equals("null")) {
      o =  null;
    } else if (tagName.equals("string")) {
      o = getText();
    } else if (tagName.equals("int")) {
      o = Integer.decode(getText());
    } else if (tagName.equals("long")) {
      o = Long.decode(getText());
    } else if (tagName.equals("float")) {
      o = new Float(Float.parseFloat(getText()));
    } else if (tagName.equals("double")) {
      o = new Double(Double.parseDouble(getText()));
    } else if (tagName.equals("boolean")) {
      o = Boolean.valueOf(getText());
    } else if (tagName.equals("color")) {
      o = new Color(getAttribute("rgba",0xff));
    } else if (tagName.equals("intArray")) {
      int[] a = new int[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Integer) readObject(i)).intValue();
      }
      o = a;
    } else if (tagName.equals("floatArray")) {
      float[] a = new float[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Float) readObject(i)).floatValue();
      }
      o = a;
    } else if (tagName.equals("doubleArray")) {
      double[] a = new double[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Double) readObject(i)).doubleValue();
      }
      o = a;
    } else if (tagName.equals("font")) {
      o = new Font(getAttribute("name", "Dialog"), getAttribute("style", 0), getAttribute("size", 0));
    } else if (tagName.equals("enum")) {
      o = factory.createEnum(getAttribute("type",(String)null), getText());
    } else {
      String ref = getAttribute("ref", null);
      String id = getAttribute("id", ref);
      
      // Keep track of objects which have an ID
      if (id == null) {
        o = factory.create(getTagName());
      } else if (idobjects.containsKey(id)) {
        o = idobjects.get(id);
      } else {
        o = factory.create(getTagName());
        idobjects.put(id, o);
      }
      
      if (ref == null) {
        if (o instanceof DOMStorable) {
          ((DOMStorable) o).read(this);
        }
      }
    }
    
    closeElement();
    return o;
###
2475, closeElement, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 219, 220
6
/**
   * Closes the current element of the DOM Document.
   * The parent of the current element becomes the current element.
   * @exception IllegalArgumentException if the provided tagName does
   * not match the tag name of the element.
   */
2
  public void closeElement() {
    current = (XMLElement) stack.pop();
###
2476, getElementCount, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 150, 151
3
/**
   * Returns the number of child elements of the current element.
   */
2
  public int getElementCount() {
    return current.getChildrenCount();
###
2477, getAttribute, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 134, 136
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public double getAttribute(String name, double defaultValue) {
    String value = (String) current.getAttribute(name);
    return (value == null || value.length() == 0) ? defaultValue : Double.parseDouble(value);
###
2478, readObject, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 226, 227
3
/**
   * Reads an object from the current element.
   */
2
  public Object readObject() throws IOException {
    return readObject(0);
###
2479, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 356, 360
9
/**
   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with cookies and parameters that are passed in the arguments
   * @param raw_cookies request cookies
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   * @see #setCookies
   */
5
  public InputStream post(String raw_cookies, Map parameters) throws IOException {
  setCookies(raw_cookies);
  postCookies();
  setParameters(parameters);
  return doPost();
###
2480, setParameter, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 215, 228
7
/**
   * adds a file parameter to the request
   * @param name parameter name
   * @param filename the name of the file
   * @param is input stream to read the contents of the file from
   * @throws IOException
   */
14
  public void setParameter(String name, String filename, InputStream is) throws IOException {
  boundary();
  writeName(name);
  write("; filename=\"");
  write(filename);
  write('"');
  newline();
  write("Content-Type: ");
  String type = URLConnection.guessContentTypeFromName(filename);
  if (type == null) type = "application/octet-stream";
  writeln(type);
  newline();
  pipe(is, _os);
  newline();
###
2481, ClientHttpRequest, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 80, 85
6
/**
   * Creates a new multipart POST HTTP request on a freshly opened URLConnection
   *
   * @param connection an already open URL connection
   * @throws IOException
   */
6
  public ClientHttpRequest(URLConnection connection) throws IOException {
  this._connection = connection;
  connection.setDoOutput(true);
  connection.setDoInput(true);
  connection.setRequestProperty("Content-Type",
                  "multipart/form-data; boundary=" + boundary);
###
2482, PertPanel, PertPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertPanel.java, 51, 116
1
/** Creates new instance. */
66
  public PertPanel() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    undoManager = new UndoRedoManager();
    editor = new DefaultDrawingEditor();
    editor.add(view);
    
    addCreationButtonsTo(creationToolbar, editor);
    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);
    
    JPopupButton pb = new JPopupButton();
    pb.setItemFont(UIManager.getFont("MenuItem.font"));
    labels.configureToolBarButton(pb, "actions");
    pb.add(new DuplicateAction());
    pb.addSeparator();
    pb.add(new GroupAction(editor));
    pb.add(new UngroupAction(editor));
    pb.addSeparator();
    pb.add(new BringToFrontAction(editor));
    pb.add(new SendToBackAction(editor));
    pb.addSeparator();
    pb.add(new CutAction());
    pb.add(new CopyAction());
    pb.add(new PasteAction());
    pb.add(new SelectAllAction());
    pb.add(new SelectSameAction(editor));
    pb.addSeparator();
    pb.add(undoManager.getUndoAction());
    pb.add(undoManager.getRedoAction());
     // FIXME - We need a toggle grid action
     // pb.addSeparator();
     // pb.add(new ToggleGridAction(editor));
    
    JMenu m = new JMenu(labels.getString("view.zoomFactor.text"));
    JRadioButtonMenuItem rbmi;
    ButtonGroup group = new ButtonGroup();
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));
    rbmi.setSelected(true);
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));
    group.add(rbmi);
    pb.add(m);
    pb.setFocusable(false);
    creationToolbar.addSeparator();
    creationToolbar.add(pb);
    
    
    DefaultDrawing drawing = new DefaultDrawing();
    view.setDrawing(drawing);
    drawing.addUndoableEditListener(undoManager);
###
2483, setParameters, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 274, 277
5
/**
   * adds parameters to the request
   * @param parameters array of parameter names and values (parameters[2*i] is a name, parameters[2*i + 1] is a value); if a value is a file, the file is uploaded, otherwise it is stringified and sent in the request
   * @throws IOException
   */
4
  public void setParameters(Object[] parameters) throws IOException {
  if (parameters != null) {
    for (int i = 0; i < parameters.length - 1; i += 2) {
    setParameter(parameters[i].toString(), parameters[i + 1]);
###
2484, setCookies, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 150, 152
5
/**
   * adds cookies to the request
   * @param cookies the cookie "name-to-value" map
   * @throws IOException
   */
3
  public void setCookies(Map<String,String> cookies) throws IOException {
  if (cookies == null) return;
  this._cookies.putAll(cookies);
###
2485, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 387, 390
8
/**
   * post the POST request to the server, with the specified parameter
   * @param name parameter name
   * @param value parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
4
  public InputStream post(String name, Object value) throws IOException {
  postCookies();
  setParameter(name, value);
  return doPost();
###
2487, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 444, 450
14
/**
   * post the POST request to the server, with the specified parameters
   * @param name1 first parameter name
   * @param value1 first parameter value
   * @param name2 second parameter name
   * @param value2 second parameter value
   * @param name3 third parameter name
   * @param value3 third parameter value
   * @param name4 fourth parameter name
   * @param value4 fourth parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
7
  public InputStream post(String name1, Object value1, String name2, Object value2, String name3, Object value3, String name4, Object value4) throws IOException {
  postCookies();
  setParameter(name1, value1);
  setParameter(name2, value2);
  setParameter(name3, value3);
  setParameter(name4, value4);
  return doPost();
###
2488, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 484, 485
9
/**
   * posts a new request to specified URL, with cookies and parameters that are passed in the argument
   * @param cookies request cookies
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setCookies
   * @see #setParameters
   */
2
  public static InputStream post(URL url, Map<String,String> cookies, Map parameters) throws IOException {
  return new ClientHttpRequest(url).post(cookies, parameters);
###
2489, initComponents, PertPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertPanel.java, 141, 175
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
27
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    toolButtonGroup = new javax.swing.ButtonGroup();
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    jPanel1 = new javax.swing.JPanel();
    creationToolbar = new javax.swing.JToolBar();
    attributesToolbar = new javax.swing.JToolBar();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    jPanel1.setLayout(new java.awt.GridBagLayout());
    creationToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(creationToolbar, gridBagConstraints);
    attributesToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(attributesToolbar, gridBagConstraints);
    add(jPanel1, java.awt.BorderLayout.SOUTH);
###
2490, setParameters, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 260, 264
5
/**
   * adds parameters to the request
   * @param parameters "name-to-value" map of parameters; if a value is a file, the file is uploaded, otherwise it is stringified and sent in the request
   * @throws IOException
   */
5
  public void setParameters(Map parameters) throws IOException {
  if (parameters != null) {
    for (Iterator i = parameters.entrySet().iterator(); i.hasNext();) {
    Map.Entry entry = (Map.Entry)i.next();
    setParameter(entry.getKey().toString(), entry.getValue());
###
2491, setParameter, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 237, 238
6
/**
   * adds a file parameter to the request
   * @param name parameter name
   * @param file the file to upload
   * @throws IOException
   */
2
  public void setParameter(String name, File file) throws IOException {
  setParameter(name, file.getPath(), new FileInputStream(file));
###
2492, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 460, 461
7
/**
   * posts a new request to specified URL, with parameters that are passed in the argument
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   */
2
  public static InputStream post(URL url, Map parameters) throws IOException {
  return new ClientHttpRequest(url).post(parameters);
###
2493, ClientHttpRequest, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 104, 105
6
/**
   * Creates a new multipart POST HTTP request for a specified URL string
   *
   * @param urlString the string representation of the URL to send request to
   * @throws IOException
   */
2
  public ClientHttpRequest(String urlString) throws IOException {
  this(new URL(urlString));
###
2494, setCookie, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 141, 142
6
/**
   * adds a cookie to the requst
   * @param name cookie name
   * @param value cookie value
   * @throws IOException
   */
2
  public void setCookie(String name, String value) throws IOException {
    _cookies.put(name, value);
###
2495, main, Main, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/Main.java, 30, 50
1
/** Creates a new instance. */
21
  public static void main(String[] args) {
    Application app;
    String os = System.getProperty("os.name").toLowerCase();
    if (os.startsWith("mac")) {
      app = new OSXApplication();
    } else if (os.startsWith("win")) {
      //  app = new DefaultMDIApplication();
      app = new SDIApplication();
    } else {
      app = new SDIApplication();
    }
    
    
    DefaultApplicationModel model = new PertApplicationModel();
    model.setName("JHotDraw Pert");
    model.setVersion(Main.class.getPackage().getImplementationVersion());
    model.setCopyright("Copyright 2006-2010 (c) by the authors of JHotDraw and all its contributors.\n" +
        "This software is licensed under LGPL and Creative Commons 3.0 Attribution.");
    model.setViewClassName("org.jhotdraw.samples.pert.PertView");
    app.setModel(model);
    app.launch(args);
###
2497, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 403, 407
10
/**
   * post the POST request to the server, with the specified parameters
   * @param name1 first parameter name
   * @param value1 first parameter value
   * @param name2 second parameter name
   * @param value2 second parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
5
  public InputStream post(String name1, Object value1, String name2, Object value2) throws IOException {
  postCookies();
  setParameter(name1, value1);
  setParameter(name2, value2);
  return doPost();
###
2498, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 312, 315
7
/**
   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with parameters that are passed in the argument
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   */
4
  public InputStream post(Map parameters) throws IOException {
  postCookies();
  setParameters(parameters);
  return doPost();
###
2499, setParameter, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 247, 251
6
/**
   * adds a parameter to the request; if the parameter is a File, the file is uploaded, otherwise the string value of the parameter is passed in the request
   * @param name parameter name
   * @param object parameter value, a File or anything else that can be stringified
   * @throws IOException
   */
5
  public void setParameter(String name, Object object) throws IOException {
  if (object instanceof File) {
    setParameter(name, (File) object);
  } else {
    setParameter(name, object.toString());
###
2500, doPost, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 287, 292
5
/**
   * posts the requests to the server, with all the cookies and parameters that were added
   * @return input stream with the server response
   * @throws IOException
   */
5
  private InputStream doPost() throws IOException {
  boundary();
  writeln("--");
  _os.close();
  return _connection.getInputStream();
###
2501, setCookies, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 130, 132
5
/**
   * adds a cookie to the requst
   * @param rawCookies A string with raw cookie data.
   * @throws IOException
   */
3
  public void setCookies(String rawCookies) throws IOException {
  this._rawCookies = (rawCookies == null) ? "" : rawCookies;
  _cookies.clear();
###
2502, DependencyFigure, DependencyFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/DependencyFigure.java, 32, 41
1
/** Creates a new instance. */
10
  public DependencyFigure() {
    set(STROKE_COLOR, new Color(0x000099));
    set(STROKE_WIDTH, 1d);
    set(END_DECORATION, new ArrowTip());
    
    setAttributeEnabled(END_DECORATION, false);
    setAttributeEnabled(START_DECORATION, false);
    setAttributeEnabled(STROKE_DASHES, false);
    setAttributeEnabled(FONT_ITALIC, false);
    setAttributeEnabled(FONT_UNDERLINE, false);
###
2503, setParameter, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 180, 190
6
/**
   * adds a string parameter to the request
   * @param name parameter name
   * @param value parameter value
   * @throws IOException
   */
11
  public void setParameter(String name, String value) throws IOException {
    if (name == null) {
      throw new InvalidParameterException("setParameter("+name+","+value+") name must not be null");
    }
    if (value == null) {
      throw new InvalidParameterException("setParameter("+name+","+value+") value must not be null");
    }
  boundary();
  writeName(name);
  newline(); newline();
  writeln(value);
###
2504, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 372, 376
9
/**
   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with cookies and parameters that are passed in the arguments
   * @param cookies request cookies
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   * @see #setCookies
   */
5
  public InputStream post(String[] cookies, Object[] parameters) throws IOException {
  setCookies(cookies);
  postCookies();
  setParameters(parameters);
  return doPost();
###
2505, canConnect, DependencyFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/DependencyFigure.java, 48, 64
4
/**
   * Checks if two figures can be connected. Implement this method
   * to constrain the allowed connections between figures.
   */
17
   @Override public boolean canConnect(Connector start, Connector end) {
    if ((start.getOwner() instanceof TaskFigure)
    && (end.getOwner() instanceof TaskFigure)) {
      
      TaskFigure sf = (TaskFigure) start.getOwner();
      TaskFigure ef = (TaskFigure) end.getOwner();
      
      // Disallow multiple connections to same dependent
      if (ef.getPredecessors().contains(sf)) {
        return false;
      }
      
      // Disallow cyclic connections
      return ! sf.isDependentOf(ef);
    }
    
    return false;
###
2506, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 300, 302
5
/**
   * posts the requests to the server, with all the cookies and parameters that were added
   * @return input stream with the server response
   * @throws IOException
   */
3
  public InputStream post() throws IOException {
      postCookies();
    return doPost();
###
2507, setCookies, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 160, 163
5
/**
   * adds cookies to the request
   * @param cookies array of cookie names and values (cookies[2*i] is a name, cookies[2*i + 1] is a value)
   * @throws IOException
   */
4
  public void setCookies(String[] cookies) throws IOException {
  if (cookies == null) return;
  for (int i = 0; i < cookies.length - 1; i+=2) {
    setCookie(cookies[i], cookies[i+1]);
###
2508, handleDisconnect, DependencyFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/DependencyFigure.java, 75, 80
4
/**
   * Handles the disconnection of a connection.
   * Override this method to handle this event.
   */
6
  @Override protected void handleDisconnect(Connector start, Connector end) {
    TaskFigure sf = (TaskFigure) start.getOwner();
    TaskFigure ef = (TaskFigure) end.getOwner();
    
    sf.removeDependency(this);
    ef.removeDependency(this);
###
2509, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 340, 344
9
/**
   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with cookies and parameters that are passed in the arguments
   * @param cookies request cookies
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   * @see #setCookies
   */
5
  public InputStream post(Map<String,String> cookies, Map parameters) throws IOException {
  setCookies(cookies);
  postCookies();
  setParameters(parameters);
  return doPost();
###
2510, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 422, 427
12
/**
   * post the POST request to the server, with the specified parameters
   * @param name1 first parameter name
   * @param value1 first parameter value
   * @param name2 second parameter name
   * @param value2 second parameter value
   * @param name3 third parameter name
   * @param value3 third parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
6
  public InputStream post(String name1, Object value1, String name2, Object value2, String name3, Object value3) throws IOException {
  postCookies();
  setParameter(name1, value1);
  setParameter(name2, value2);
  setParameter(name3, value3);
  return doPost();
###
2511, ClientHttpRequest, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 94, 95
6
/**
   * Creates a new multipart POST HTTP request for a specified URL
   *
   * @param url the URL to send request to
   * @throws IOException
   */
2
  public ClientHttpRequest(URL url) throws IOException {
  this(url.openConnection());
###
2512, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 498, 499
10
/**
   * posts a new request to specified URL, with cookies and parameters that are passed in the argument
   * @param url post URL
   * @param cookies request cookies
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setCookies
   * @see #setParameters
   */
2
  public static InputStream post(URL url, String[] cookies, Object[] parameters) throws IOException {
  return new ClientHttpRequest(url).post(cookies, parameters);
###
2513, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 471, 472
7
/**
   * posts a new request to specified URL, with parameters that are passed in the argument
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   */
2
  public static InputStream post(URL url, Object[] parameters) throws IOException {
  return new ClientHttpRequest(url).post(parameters);
###
2514, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 541, 542
12
/**
   * post the POST request to specified URL, with the specified parameters
   * @param name1 first parameter name
   * @param value1 first parameter value
   * @param name2 second parameter name
   * @param value2 second parameter value
   * @param name3 third parameter name
   * @param value3 third parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
2
  public static InputStream post(URL url, String name1, Object value1, String name2, Object value2, String name3, Object value3) throws IOException {
  return new ClientHttpRequest(url).post(name1, value1, name2, value2, name3, value3);
###
2515, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 325, 328
7
/**
   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with parameters that are passed in the argument
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   */
4
  public InputStream post(Object[] parameters) throws IOException {
  postCookies();
  setParameters(parameters);
  return doPost();
###
2516, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 511, 512
9
/**
   * post the POST request specified URL, with the specified parameter
   * @param url post URL
   * @param name1 parameter name
   * @param value1 parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
2
  public static InputStream post(URL url, String name1, Object value1) throws IOException {
  return new ClientHttpRequest(url).post(name1, value1);
###
2517, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 525, 526
10
/**
   * post the POST request to specified URL, with the specified parameters
   * @param name1 first parameter name
   * @param value1 first parameter value
   * @param name2 second parameter name
   * @param value2 second parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
2
  public static InputStream post(URL url, String name1, Object value1, String name2, Object value2) throws IOException {
  return new ClientHttpRequest(url).post(name1, value1, name2, value2);
###
2518, getParameter, PertApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java, 51, 55
4
/**
   * We override getParameter() to make it work even if we have no Applet
   * context.
   */
5
  public String getParameter(String name) {
    try {
      return super.getParameter(name);
    } catch (NullPointerException e) {
      return null;
###
2519, init, PertApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java, 66, 153
3
/**
   * Initializes the applet PertApplet
   */
79
  public void init() {
    // Set look and feel
    // -----------------
    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Throwable e) {
      // Do nothing.
      // If we can't set the desired look and feel, UIManager does
      // automaticaly the right thing for us.
    }
    // Set our own popup factory, because the one that comes with Mac OS X
    // creates translucent popups which is not useful for color selection
    // using pop menus.
    try {
      PopupFactory.setSharedInstance(new PopupFactory());
    } catch (Throwable e) {
      // If we can't set the popup factory, we have to use what is there.
    }

    // Display copyright info while we are loading the data
    // ----------------------------------------------------
    Container c = getContentPane();
    c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));
    String[] labels = getAppletInfo().split("\n");//Strings.split(getAppletInfo(), '\n');
    for (int i = 0; i < labels.length; i++) {
      c.add(new JLabel((labels[i].length() == 0) ? " " : labels[i]));
    }
    // We load the data using a worker thread
    // --------------------------------------
    new Worker<Drawing>() {
      public Drawing construct() throws IOException {
        Drawing result;
        System.out.println("getParameter.datafile:" + getParameter("datafile"));
        if (getParameter("data") != null) {
          NanoXMLDOMInput domi = new NanoXMLDOMInput(new PertFactory(), new StringReader(getParameter("data")));
          result = (Drawing) domi.readObject(0);
        } else if (getParameter("datafile") != null) {
          URL url = new URL(getDocumentBase(), getParameter("datafile"));
          InputStream in = url.openConnection().getInputStream();
          try {
            NanoXMLDOMInput domi = new NanoXMLDOMInput(new PertFactory(), in);
            result = (Drawing) domi.readObject(0);
          } finally {
            in.close();
          }
        } else {
          result = null;
        }
        return result;
      }
      @Override
      protected void done(Drawing result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        c.add(drawingPanel = new PertPanel());
        initComponents();
        if (result != null) {
          setDrawing(result);
        }
      }
      @Override
      protected void failed(Throwable value) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        c.add(drawingPanel = new PertPanel());
        value.printStackTrace();
        initComponents();
        getDrawing().add(new TextFigure(value.toString()));
        value.printStackTrace();
      }
      @Override
      protected void finished() {
        Container c = getContentPane();
        initDrawing(getDrawing());
        c.validate();
      }
    }.start();
###
2520, initDrawing, PertApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java, 167, 179
3
/**
   * Configure Drawing object to support copy and paste.
   */
10
  private void initDrawing(Drawing d) {
    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();
    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();
    DOMStorableInputOutputFormat ioFormat = new DOMStorableInputOutputFormat(
        new PertFactory());
    inputFormats.add(ioFormat);
    outputFormats.add(ioFormat);
    outputFormats.add(new ImageOutputFormat());
    d.setInputFormats(inputFormats);
    d.setOutputFormats(outputFormats);
###
2522, initComponents, PertApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java, 243, 244
5
/** This method is called from within the init() method to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
2
  private void initComponents() {
    toolButtonGroup = new javax.swing.ButtonGroup();
###
2523, TaskFigure, TaskFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/TaskFigure.java, 84, 136
1
/** Creates a new instance. */
41
  public TaskFigure() {
    super(new RectangleFigure());
    setLayouter(new VerticalLayouter());
    RectangleFigure nameCompartmentPF = new RectangleFigure();
    nameCompartmentPF.set(STROKE_COLOR, null);
    nameCompartmentPF.setAttributeEnabled(STROKE_COLOR, false);
    nameCompartmentPF.set(FILL_COLOR, null);
    nameCompartmentPF.setAttributeEnabled(FILL_COLOR, false);
    ListFigure nameCompartment = new ListFigure(nameCompartmentPF);
    ListFigure attributeCompartment = new ListFigure();
    SeparatorLineFigure separator1 = new SeparatorLineFigure();
    applyAttributes(getPresentationFigure());
    add(nameCompartment);
    add(separator1);
    add(attributeCompartment);
    Insets2D.Double insets = new Insets2D.Double(4, 8, 4, 8);
    nameCompartment.set(LAYOUT_INSETS, insets);
    attributeCompartment.set(LAYOUT_INSETS, insets);
    TextFigure nameFigure;
    nameCompartment.add(nameFigure = new TextFigure());
    nameFigure.set(FONT_BOLD, true);
    nameFigure.setAttributeEnabled(FONT_BOLD, false);
    TextFigure durationFigure;
    attributeCompartment.add(durationFigure = new TextFigure());
    durationFigure.set(FONT_BOLD, true);
    durationFigure.setText("0");
    durationFigure.setAttributeEnabled(FONT_BOLD, false);
    TextFigure startTimeFigure;
    attributeCompartment.add(startTimeFigure = new TextFigure());
    startTimeFigure.setEditable(false);
    startTimeFigure.setText("0");
    startTimeFigure.setAttributeEnabled(FONT_BOLD, false);
    applyAttributes(this);
    setAttributeEnabled(STROKE_DASHES, false);
    ResourceBundleUtil labels =
        ResourceBundleUtil.getBundle("org.jhotdraw.samples.pert.Labels");
    setName(labels.getString("pert.task.defaultName"));
    setDuration(0);
    dependencies = new HashSet<DependencyFigure>();
    nameFigure.addFigureListener(new NameAdapter(this));
    durationFigure.addFigureListener(new DurationAdapter(this));
###
2524, writeRectAttributes, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 268, 299
6
/**
   * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,
   * <code>nohref</code> Attribute for the specified figure and rectangle.
   *
   * @return Returns true, if the rect is inside of the image bounds.
   */
29
  private boolean writeRectAttributes(IXMLElement elem, SVGFigure f, Rectangle2D.Double rect) {
    AffineTransform t = TRANSFORM.getClone(f);
    if (t == null) {
      t = drawingTransform;
    } else {
      t.preConcatenate(drawingTransform);
    }
    if ((t.getType() &
        (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_TRANSLATION)) ==
        t.getType()) {
      Point2D.Double start = new Point2D.Double(rect.x, rect.y);
      Point2D.Double end = new Point2D.Double(rect.x + rect.width, rect.y + rect.height);
      t.transform(start, start);
      t.transform(end, end);
      Rectangle r = new Rectangle(
          (int) Math.min(start.x, end.x),
          (int) Math.min(start.y, end.y),
          (int) Math.abs(start.x - end.x),
          (int) Math.abs(start.y - end.y));
      elem.setAttribute("shape", "rect");
      elem.setAttribute("coords",
          r.x + "," +
          r.y + "," +
          (r.x + r.width) + "," +
          (r.y + r.height));
      writeHrefAttribute(elem, f);
      return bounds.intersects(r);
    } else {
      return writePolyAttributes(elem, f, (Shape) rect);
###
2525, getSuccessors, TaskFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/TaskFigure.java, 307, 315
4
/**
   * Returns dependent PertTasks which are directly connected via a
   * PertDependency to this TaskFigure.
   */
8
  public List<TaskFigure> getSuccessors() {
    LinkedList<TaskFigure> list = new LinkedList<TaskFigure>();
    for (DependencyFigure c : getDependencies()) {
      if (c.getStartFigure() == this) {
        list.add((TaskFigure) c.getEndFigure());
      }
    }
    return list;
###
2527, getPredecessors, TaskFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/TaskFigure.java, 322, 330
4
/**
   * Returns predecessor PertTasks which are directly connected via a
   * PertDependency to this TaskFigure.
   */
8
  public List<TaskFigure> getPredecessors() {
    LinkedList<TaskFigure> list = new LinkedList<TaskFigure>();
    for (DependencyFigure c : getDependencies()) {
      if (c.getEndFigure() == this) {
        list.add((TaskFigure) c.getStartFigure());
      }
    }
    return list;
###
2528, writePolyAttributes, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 324, 369
6
/**
   * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,
   * <code>nohref</code> Attribute for the specified figure and shape.
   *
   * @return Returns true, if the polygon is inside of the image bounds.
   */
45
  private boolean writePolyAttributes(IXMLElement elem, SVGFigure f, Shape shape) {
    AffineTransform t = TRANSFORM.getClone(f);
    if (t == null) {
      t = drawingTransform;
    } else {
      t.preConcatenate(drawingTransform);
    }
    StringBuilder buf = new StringBuilder();
    float[] coords = new float[6];
    Path2D.Double path = new Path2D.Double();
    for (PathIterator i = shape.getPathIterator(t, 1.5f);
        !i.isDone(); i.next()) {
      switch (i.currentSegment(coords)) {
        case PathIterator.SEG_MOVETO:
          if (buf.length() != 0) {
            throw new IllegalArgumentException("Illegal shape " + shape);
          }
          if (buf.length() != 0) {
            buf.append(',');
          }
          buf.append((int) coords[0]);
          buf.append(',');
          buf.append((int) coords[1]);
          path.moveTo(coords[0], coords[1]);
          break;
        case PathIterator.SEG_LINETO:
          if (buf.length() != 0) {
            buf.append(',');
          }
          buf.append((int) coords[0]);
          buf.append(',');
          buf.append((int) coords[1]);
          path.lineTo(coords[0], coords[1]);
          break;
        case PathIterator.SEG_CLOSE:
          path.closePath();
          break;
        default:
          throw new InternalError("Illegal segment type " + i.currentSegment(coords));
      }
    }
    elem.setAttribute("shape", "poly");
    elem.setAttribute("coords", buf.toString());
    writeHrefAttribute(elem, f);
    return path.intersects(new Rectangle2D.Float(bounds.x, bounds.y, bounds.width, bounds.height));
###
2529, write, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 108, 143
7
/**
   * Writes the figures to the specified output stream.
   * This method applies the specified drawingTransform to the drawing, and draws
   * it on an image of the specified getChildCount.
   * 
   * All other write methods delegate their work to here.
   */
30
  public void write(OutputStream out, java.util.List<Figure> figures,
      AffineTransform drawingTransform, Dimension imageSize) throws IOException {
    this.drawingTransform = (drawingTransform == null) ? new AffineTransform() : drawingTransform;
    this.bounds = (imageSize == null) ? new Rectangle(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE) : new Rectangle(0, 0, imageSize.width, imageSize.height);
    XMLElement document = new XMLElement("map");
    // Note: Image map elements need to be written from front to back
    for (Figure f : new ReversedList<Figure>(figures)) {
      writeElement(document, f);
    }
    // Strip AREA elements with "nohref" attributes from the end of the
    // map
    if (!isIncludeNohref) {
      for (int i = document.getChildrenCount() - 1; i >= 0; i--) {
        XMLElement child = (XMLElement) document.getChildAtIndex(i);
        if (child.hasAttribute("nohref")) {
          document.removeChildAtIndex(i);
        }
      }
    }

    // Write XML content
    PrintWriter writer = new PrintWriter(
        new OutputStreamWriter(out, "UTF-8"));
    //new XMLWriter(writer).write(document);
    for (Object o : document.getChildren()) {
      XMLElement child = (XMLElement) o;
      new XMLWriter(writer).write(child);
    }
    // Flush writer
    writer.flush();
###
2530, write, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 96, 98
5
/**
   * Writes the drawing to the specified output stream.
   * This method applies the specified drawingTransform to the drawing, and draws
   * it on an image of the specified getChildCount.
   */
3
  public void write(OutputStream out, Drawing drawing,
      AffineTransform drawingTransform, Dimension imageSize) throws IOException {
    write(out, drawing.getChildren(), drawingTransform, imageSize);
###
2531, writeCircleAttributes, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 228, 258
6
/**
   * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,
   * <code>nohref</code> Attribute for the specified figure and ellipse.
   *
   * @return Returns true, if the circle is inside of the image bounds.
   */
28
  private boolean writeCircleAttributes(IXMLElement elem, SVGFigure f, Ellipse2D.Double ellipse) {
    AffineTransform t = TRANSFORM.getClone(f);
    if (t == null) {
      t = drawingTransform;
    } else {
      t.preConcatenate(drawingTransform);
    }
    if ((t.getType() &
        (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_TRANSLATION)) ==
        t.getType() &&
        ellipse.width == ellipse.height) {
      Point2D.Double start = new Point2D.Double(ellipse.x, ellipse.y);
      Point2D.Double end = new Point2D.Double(ellipse.x + ellipse.width, ellipse.y + ellipse.height);
      t.transform(start, start);
      t.transform(end, end);
      ellipse.x = Math.min(start.x, end.x);
      ellipse.y = Math.min(start.y, end.y);
      ellipse.width = Math.abs(start.x - end.x);
      ellipse.height = Math.abs(start.y - end.y);
      elem.setAttribute("shape", "circle");
      elem.setAttribute("coords",
          (int) (ellipse.x + ellipse.width / 2d) + "," +
          (int) (ellipse.y + ellipse.height / 2d) + "," +
          (int) (ellipse.width / 2d));
      writeHrefAttribute(elem, f);
      return bounds.intersects(ellipse.getBounds());
    } else {
      return writePolyAttributes(elem, f, (Shape) ellipse);
###
2532, write, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 149, 168
3
/**
   * All other write methods delegate their work to here.
   */
17
  public void write(OutputStream out, java.util.List<Figure> figures) throws IOException {
    Rectangle2D.Double drawingRect = null;
    for (Figure f : figures) {
      if (drawingRect == null) {
        drawingRect = f.getBounds();
      } else {
        drawingRect.add(f.getBounds());
      }
    }
    AffineTransform drawingTransform = new AffineTransform();
    drawingTransform.translate(
        -Math.min(0, drawingRect.x),
        -Math.min(0, drawingRect.y));
    write(out, figures, drawingTransform,
        new Dimension(
        (int) (Math.abs(drawingRect.x) + drawingRect.width),
        (int) (Math.abs(drawingRect.y) + drawingRect.height)));
###
2534, getDefaultPropertyIndex, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2535, getPropertyDescriptors, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2536, getMethodDescriptors, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2537, getBeanDescriptor, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2538, readMasterPageElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 562, 564
11
/**
   * Reads a &lt;style:master-page&gt; element from the specified
   * XML element.
   * <p>
   *
   * @param elem A &lt;page-layout&gt; element.
   * @param styles Style attributes to be filled in by this method.
   */
 --------------
//if (DEBUG) System.out.println("ODGStylesReader unsupported <"+elem.getName()+"> element.");
 --------------
3
  private void readMasterPageElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> element.");
###
2540, getEventSetDescriptors, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2543, readStylesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 441, 442
9
/**
   * Reads a &lt;styles&gt; element from the specified
   * XML element.
   * <p>
   * The styles element contains common styles.
   *
   *
   * @param elem A &lt;styles&gt; element.
   */
2
  private void readStylesElement(IXMLElement elem) throws IOException {
    readStylesChildren(elem, commonStyles);
###
2544, getDefaultEventIndex, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2545, readMasterStylesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 534, 535
9
/**
   * Reads a &lt;master-styles&gt; element from the specified
   * XML element.
   * <p>
   * The master-styles element contains master styles.
   *
   *
   * @param elem A &lt;master-styles&gt; element.
   */
2
  private void readMasterStylesElement(IXMLElement elem) throws IOException {
    readStylesChildren(elem, masterStyles);
###
2546, read, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 165, 174
8
/**
   * Reads a &lt;document-styles&gt; element from the specified
   * XML element.
   *
   *
   * @param root A &lt;document&gt; element or a
   * &lt;document-styles&gt; element.
   */
10
  public void read(IXMLElement root) throws IOException {
    String name = root.getName();
    String ns = root.getNamespace();
    if (name.equals("document-content") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
      readDocumentContentElement(root);
    } else if (name.equals("document-styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
      readDocumentStylesElement(root);
    } else {
      if (DEBUG) {
        System.out.println("ODGStylesReader unsupported root element " + root);
###
2547, readGraphicPropertiesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 316, 368
7
/**
   * Reads a &lt;style:graphic-properties&gt; element from the specified
   * XML element.
   * <p>
   *
   * @param elem A &lt;style:graphic-properties&gt; element.
   */
50
  private void readGraphicPropertiesElement(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
    // The attribute draw:stroke specifies the style of the stroke on the current object. The value
    // none means that no stroke is drawn, and the value solid means that a solid stroke is drawn. If
    // the value is dash, the stroke referenced by the draw:stroke-dash property is drawn.
    if (elem.hasAttribute("stroke", DRAWING_NAMESPACE)) {
      STROKE_STYLE.put(a, (StrokeStyle) elem.getAttribute("stroke", DRAWING_NAMESPACE, STROKE_STYLES, null));
    }
    // The attribute svg:stroke-width specifies the width of the stroke on
    // the current object.
    if (elem.hasAttribute("stroke-width", SVG_NAMESPACE)) {
      STROKE_WIDTH.put(a, toLength(elem.getAttribute("stroke-width", SVG_NAMESPACE, null)));
    }
    // The attribute svg:stroke-color specifies the color of the stroke on
    // the current object.
    if (elem.hasAttribute("stroke-color", SVG_NAMESPACE)) {
      STROKE_COLOR.put(a, toColor(elem.getAttribute("stroke-color", SVG_NAMESPACE, null)));
    }
    // FIXME read draw:marker-start-width, draw:marker-start-center, draw:marker-end-width,
    // draw:marker-end-centre
    // The attribute draw:fill specifies the fill style for a graphic
    // object. Graphic objects that are not closed, such as a path without a
    // closepath at the end, will not be filled. The fill operation does not
    // automatically close all open subpaths by connecting the last point of
    // the subpath with the first point of the subpath before painting the
    // fill. The attribute has the following values:
    //  • none:   the drawing object is not filled.
    //  • solid:  the drawing object is filled with color specified by the
    //        draw:fill-color attribute.
    //  • bitmap:   the drawing object is filled with the bitmap specified
    //        by the draw:fill-image-name attribute.
    //  • gradient: the drawing object is filled with the gradient specified
    //        by the draw:fill-gradient-name attribute.
    //  • hatch:  the drawing object is filled with the hatch specified by
    //        the draw:fill-hatch-name attribute.
    if (elem.hasAttribute("fill", DRAWING_NAMESPACE)) {
      FILL_STYLE.put(a, (FillStyle) elem.getAttribute("fill", DRAWING_NAMESPACE, FILL_STYLES, null));
    }
    // The attribute draw:fill-color specifies the color of the fill for a
    // graphic object. It is used only if the draw:fill attribute has the
    // value solid.
    if (elem.hasAttribute("fill-color", DRAWING_NAMESPACE)) {
      FILL_COLOR.put(a, toColor(elem.getAttribute("fill-color", DRAWING_NAMESPACE, null)));
    }
    // FIXME read fo:padding-top, fo:padding-bottom, fo:padding-left,
    // fo:padding-right
    // FIXME read draw:shadow, draw:shadow-offset-x, draw:shadow-offset-y,
    // draw:shadow-color
    for (IXMLElement child : elem.getChildren()) {
      String ns = child.getNamespace();
      String name = child.getName();
###
2548, readListStyleElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 519, 521
8
/**
   * Reads a &lt;text:list-style&gt; element from the specified
   * XML element.
   * <p>
   *
   * @param elem A &lt;list-style&gt; element.
   * @param styles Style attributes to be filled in by this method.
   */
3
  private void readListStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> element.");
###
2549, read, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 112, 117
8
/**
   * Reads a &lt;document-styles&gt; element from the specified
   * XML file.
   *
   *
   * @param file A XML file with a &lt;document&gt; root element
   * or with a &lt;document-styles&gt; root element.
   */
6
  public void read(File file) throws IOException {
    BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));
    try {
      read(in);
    } finally {
      in.close();
###
2551, readLayerSetElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 505, 507
8
/**
   * Reads a &lt;draw:layer-put&gt; element from the specified
   * XML element.
   * <p>
   *
   * @param elem A &lt;layer-put&gt; element.
   * @param styles Style attributes to be filled in by this method.
   */
3
  private void readLayerSetElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> element.");
###
2552, ODGStylesReader, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 76, 77
1
/** Creates a new instance. */
2
  public ODGStylesReader() {
    reset();
###
2553, readDrawingPagePropertiesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 303, 305
7
/**
   * Reads a &lt;style:drawing-page-properties&gt; element from the specified
   * XML element.
   * <p>
   *
   * @param elem A &lt;style:drawing-page-properties&gt; element.
   */
3
  private void readDrawingPagePropertiesElement(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> element.");
###
2554, read, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 129, 148
8
/**
   * Reads a &lt;document-styles&gt; element from the specified
   * input stream.
   *
   *
   * @param in A input stream with a &lt;document&gt; root element
   * or with a &lt;document-styles&gt; root element.
   */
20
  public void read(InputStream in) throws IOException {
    IXMLParser parser;
    try {
      parser = XMLParserFactory.createDefaultXMLParser();
    } catch (Exception ex) {
      InternalError e = new InternalError("Unable to instantiate NanoXML Parser");
      e.initCause(ex);
      throw e;
    }
    IXMLReader reader = new StdXMLReader(in);
    parser.setReader(reader);
    IXMLElement document;
    try {
      document = (IXMLElement) parser.parse();
    } catch (XMLException ex) {
      IOException e = new IOException(ex.getMessage());
      e.initCause(ex);
      throw e;
    }
    read(document);
###
2555, toLength, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 627, 652
9
/**
   * Returns a value as a length.
   *
   * &lt;define name="length"&gt;
   * &lt;data type="string"&gt;
   * &lt;param name="pattern"&gt;-?([0-9]+(\.[0-9]*)?|\.[0-9]+)((cm)|(mm)|(in)|
   * (pt)|(pc)|(px))&lt;/param&gt;
   *
   */
24
  private double toLength(String str) throws IOException {
    double scaleFactor = 1d;
    if (str == null || str.length() == 0) {
      return 0d;
    }
    if (str.endsWith("cm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 35.43307;
    } else if (str.endsWith("mm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 3.543307;
    } else if (str.endsWith("in")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 90;
    } else if (str.endsWith("pt")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 1.25;
    } else if (str.endsWith("pc")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 15;
    } else if (str.endsWith("px")) {
      str = str.substring(0, str.length() - 2);
    }
    return Double.parseDouble(str) * scaleFactor;
###
2557, readDocumentContentElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 240, 257
6
/**
   * Reads a &lt;document-content&gt; element from the specified
   * XML element.
   *
   * @param elem A &lt;document-content&gt; element.
   */
17
  private void readDocumentContentElement(IXMLElement elem) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader <" + elem.getName() + " ...>");
    }
    for (IXMLElement child : elem.getChildren()) {
      String ns = child.getNamespace();
      String name = child.getName();
      if (name.equals("automatic-styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readAutomaticStylesElement(child);
      } else if (name.equals("master-styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readStylesElement(child);
      } else if (name.equals("styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readStylesElement(child);
      }
    }
    if (DEBUG) {
      System.out.println("ODGStylesReader </" + elem.getName() + ">");
###
2558, readDefaultStyleElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 197, 227
18
/**
   * Reads a &lt;default-style&gt; element from the specified
   * XML element.
   * <p>
   * A default style specifies default formatting properties for a certain
   * style family. These defaults are used if a formatting property is neither
   * specified by an automatic nor a common style. Default styles exist for
   * all style families that are represented by the &lt;style:style&gt;
   * element specified in section 14.1.
   * Default styles are represented by the &lt;style:default-style&gt;
   * element. The only attribute supported by this element is style:family.
   * Its meaning equals the one of the same attribute for the
   * &lt;style:style&gt; element, and the same properties child elements are
   * supported depending on the style family.
   *
   * @param elem A &lt;default-style&gt; element.
   * @param styles Style attributes to be filled in by this method.
   */
30
  private void readDefaultStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {
    String styleName = elem.getAttribute("family", STYLE_NAMESPACE, null);
    String family = elem.getAttribute("family", STYLE_NAMESPACE, null);
    String parentStyleName = elem.getAttribute("parent-style-name", STYLE_NAMESPACE, null);
    if (DEBUG) {
      System.out.println("ODGStylesReader <default-style family=" + styleName + " ...>...</>");
    }
    if (styleName != null) {
      Style a = styles.get(styleName);
      if (a == null) {
        a = new Style();
        a.name = styleName;
        a.family = family;
        a.parentName = parentStyleName;
        styles.put(styleName, a);
      }
      for (IXMLElement child : elem.getChildren()) {
        String ns = child.getNamespace();
        String name = child.getName();
        if (name.equals("drawing-page-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readDrawingPagePropertiesElement(child, a);
        } else if (name.equals("graphic-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readGraphicPropertiesElement(child, a);
        } else if (name.equals("paragraph-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readParagraphPropertiesElement(child, a);
        } else if (name.equals("text-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readTextPropertiesElement(child, a);
        } else {
          if (DEBUG) {
            System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> child " + child);
###
2559, readStylesChildren, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 453, 478
8
/**
   * Reads the children of a styles element.
   *
   *
   * @param elem A &lt;styles&gt;, &lt;automatic-styles&gt;,
   * &lt;document-styles&gt; or a &lt;master-styles&gt; element.
   * @param styles Styles to be filled in by this method.
   */
26
  private void readStylesChildren(IXMLElement elem,
      HashMap<String, Style> styles) throws IOException {
    for (IXMLElement child : elem.getChildren()) {
      String ns = child.getNamespace();
      String name = child.getName();
      if (name.equals("default-style") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        readDefaultStyleElement(child, styles);
      } else if (name.equals("layer-set") && (ns == null || ns.equals(DRAWING_NAMESPACE))) {
        readLayerSetElement(child, styles);
      } else if (name.equals("list-style") && (ns == null || ns.equals(TEXT_NAMESPACE))) {
        readListStyleElement(child, styles);
      } else if (name.equals("marker") && (ns == null || ns.equals(DRAWING_NAMESPACE))) {
        readMarkerElement(child, styles);
      } else if (name.equals("master-page") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        readMasterPageElement(child, styles);
      } else if (name.equals("page-layout") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        readPageLayoutElement(child, styles);
        //} else if (name.equals("paragraph-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        //  readParagraphPropertiesElement(child, styles);
      } else if (name.equals("style") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        readStyleElement(child, styles);
        //} else if (name.equals("text-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        //  readTextPropertiesElement(child, styles);
      } else {
        if (DEBUG) {
          System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> child: " + child);
###
2560, readAutomaticStylesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 493, 494
9
/**
   * Reads a &lt;automatic-styles&gt; element from the specified
   * XML element.
   * <p>
   * The automatic-styles element contains automatic styles.
   *
   *
   * @param elem A &lt;automatic-styles&gt; element.
   */
2
  private void readAutomaticStylesElement(IXMLElement elem) throws IOException {
    readStylesChildren(elem, automaticStyles);
###
2561, readDocumentStylesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 272, 292
11
/**
   * Reads a &lt;document-styles&gt; element from the specified
   * XML element.
   * <p>
   * The document-styles element contains all named styles of
   * a document, along with the automatic styles needed for the named
   * styles.
   *
   *
   * @param elem A &lt;document-styles&gt; element.
   */
21
  private void readDocumentStylesElement(IXMLElement elem) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader <" + elem.getName() + " ...>");
    }
    for (IXMLElement child : elem.getChildren()) {
      String ns = child.getNamespace();
      String name = child.getName();
      if (name.equals("styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readStylesElement(child);
      } else if (name.equals("automatic-styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readAutomaticStylesElement(child);
      } else if (name.equals("master-styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readMasterStylesElement(child);
      } else {
        if (DEBUG) {
          System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> child " + child);
        }
      }
    }
    if (DEBUG) {
      System.out.println("ODGStylesReader </" + elem.getName() + ">");
###
2562, readStyleElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 384, 425
11
/**
   * Reads a &lt;styles&gt; element from the specified
   * XML element.
   * <p>
   * The &lt;style:style&gt; element can represent paragraph, text, and
   * graphic styles.
   *
   *
   * @param elem A &lt;style&gt; element.
   * @param styles Style attributes to be filled in by this method.
   */
39
  private void readStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {
    // The style:name attribute identifies the name of the style. This attribute, combined with the
// style:family attribute, uniquely identifies a style. The <office:styles>,
// <office:automatic-styles> and <office:master-styles> elements each must not
// contain two styles with the same family and the same name.
// For automatic styles, a name is generated during document export. If the document is exported
// several times, it cannot be assumed that the same name is generated each time.
// In an XML document, the name of each style is a unique name that may be independent of the
// language selected for an office applications user interface. Usually these names are the ones used
// for the English version of the user interface.
    String styleName = elem.getAttribute("name", STYLE_NAMESPACE, null);
    String family = elem.getAttribute("family", STYLE_NAMESPACE, null);
    String parentStyleName = elem.getAttribute("parent-style-name", STYLE_NAMESPACE, null);
    if (DEBUG) {
      System.out.println("ODGStylesReader <style name=" + styleName + " ...>...</>");
    }
    if (styleName != null) {
      Style a = styles.get(styleName);
      if (a == null) {
        a = new Style();
        a.name = styleName;
        a.family = family;
        a.parentName = parentStyleName;
        styles.put(styleName, a);
      }
      for (IXMLElement child : elem.getChildren()) {
        String ns = child.getNamespace();
        String name = child.getName();
        if (name.equals("drawing-page-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readDrawingPagePropertiesElement(child, a);
        } else if (name.equals("graphic-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readGraphicPropertiesElement(child, a);
        } else if (name.equals("paragraph-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readParagraphPropertiesElement(child, a);
        } else if (name.equals("text-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readTextPropertiesElement(child, a);
        } else {
          if (DEBUG) {
            System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> child " + child);
###
2565, createToolBars, PertApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplicationModel.java, 134, 160
5
/**
   * Creates toolbars for the application.
   * This class always returns an empty list. Subclasses may return other
   * values.
   */
25
  public java.util.List<JToolBar> createToolBars(Application a, View pr) {
    ResourceBundleUtil drawLabels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.pert.Labels");
    PertView p = (PertView) pr;
    DrawingEditor editor;
    if (p == null) {
      editor = getSharedEditor();
    } else {
      editor = p.getEditor();
    }
    LinkedList<JToolBar> list = new LinkedList<JToolBar>();
    JToolBar tb;
    tb = new JToolBar();
    addCreationButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.drawToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    ButtonFactory.addAttributesButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.attributesToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    ButtonFactory.addAlignmentButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.alignmentToolBar.title"));
    list.add(tb);
    return list;
###
2566, Matcher, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 74, 87
8
/**
   * Creates a new instance of Matcher
   *
   * @param document The document to be examined
   * @param findString The string to be searched.
   * @param matchCase Set to true for case sensitive search.
   * @param matchType Sets the match type.
   */
14
  public Matcher(Document document, String findString, boolean matchCase, MatchType matchType) {
    this.document = document;
    this.findString = findString;
    startIndex = 0;
    
    // Convert to chars for efficiency
    if (matchCase) {
      matchLowerCase = matchUpperCase = findString.toCharArray();
    } else {
      matchUpperCase = findString.toUpperCase().toCharArray();
      matchLowerCase = findString.toLowerCase().toCharArray();
    }
    
    this.matchType = matchType;
###
2567, Matcher, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 62, 63
7
/**
   * Creates a new instance of Matcher which
   * performs a case sensitive search.
   *
   * @param document The document to be examined
   * @param findString The string to be searched.
   */
2
  public Matcher(Document document, String findString) {
    this(document, findString, true, MatchType.CONTAINS);
###
2568, findNext, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 117, 119
9
/**
   * Resets this matcher and then attempts to find the next
   * subsequence of the input sequence that matches the pattern,
   * starting at the specified index.
   *
   * @param startIndex the index from which to start the search.
   * @return the index of the first occurrence of the search string,
   * starting at the specified offset, or -1 if no occurrence was found.
   */
3
  public int findNext(int startIndex) {
    this.startIndex = startIndex;
    return findNext();
###
2569, findNext, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 134, 193
13
/**
   * Attempts to find the next subsequence of the
   * input sequence that matches the pattern.
   * <p>
   * This method starts at the beginning of
   * the input sequence or, if a previous invocation
   * of the method was successful and the matcher has not
   * since been reset, at the first character not matched by
   * the previous match.
   *
   * @return the index of the first occurrence of the search string,
   * starting at the specified offset, or -1 if no occurrence was found.
   */
60
  public int findNext() {
    // Don't match empty strings and don't match if we are at the end of the document.
    if (findString.length() == 0 ||
    document.getLength() - findString.length() < startIndex) {
      return -1;
    }
    
    try {
      int nextMatch = 0; // index of next matching character
      
      // Iterate through all segments of the document starting from offset
      Segment text = new Segment();
      text.setPartialReturn(true);
      int offset = startIndex;
      int nleft = document.getLength() - startIndex;
      while (nleft > 0) {
        document.getText(offset, nleft, text);
        
        // Iterate through the characters in the current segment
        char next = text.first();
        for (text.first(); next != Segment.DONE; next = text.next()) {
          
          // Check if the current character matches with the next
          // search character.
          char current = text.current();
          if (current == matchUpperCase[nextMatch] ||
          current == matchLowerCase[nextMatch]) {
            nextMatch++;
            
            // Did we match all search characters?
            if (nextMatch == matchLowerCase.length) {
              int foundIndex = text.getIndex() - text.getBeginIndex() + offset -
              matchLowerCase.length + 1;
              if (matchType == MatchType.CONTAINS) {
                return foundIndex;
                // break; <- never reached
              } else if (matchType == MatchType.STARTS_WITH) {
                if (! isWordChar(foundIndex - 1)) {
                  return foundIndex;
                }
              } else if (matchType == MatchType.FULL_WORD) {
                if (! isWordChar(foundIndex - 1) &&
                ! isWordChar(foundIndex + matchLowerCase.length)) {
                  return foundIndex;
                }
              }
              nextMatch = 0;
            }
          } else {
            nextMatch = 0;
          }
        }
        
        // Move forward to the next segment
        nleft -= text.count;
        offset += text.count;
      }
      return -1;
    } catch (BadLocationException e) {
      throw new IndexOutOfBoundsException();
###
2570, findPrevious, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 205, 207
9
/**
   * Resets this matcher and then attempts to find the previous
   * subsequence of the input sequence that matches the pattern,
   * starting at the specified index.
   *
   * @param startIndex the index from which to start the search.
   * @return the index of the first occurrence of the search string,
   * starting at the specified offset, or -1 if no occurrence was found.
   */
3
  public int findPrevious(int startIndex) {
    this.startIndex = startIndex;
    return findPrevious();
###
2571, createPageable, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 125, 126
3
/**
   * Creates a Pageable object for printing this view.
   */
2
  public Pageable createPageable() {
    return new DrawingPageable(view.getDrawing());
###
2572, initActions, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 171, 173
3
/**
   * Initializes view specific actions.
   */
3
  private void initActions() {
    getActionMap().put(UndoAction.ID, undo.getUndoAction());
    getActionMap().put(RedoAction.ID, undo.getRedoAction());
###
2573, findPrevious, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 222, 276
13
/**
   * Attempts to find the previous subsequence of the
   * input sequence that matches the pattern.
   * <p>
   * This method starts at the beginning of
   * the input sequence or, if a previous invocation
   * of the method was successful and the matcher has not
   * since been reset, at the first character not matched by
   * the previous match.
   *
   * @return the index of the first occurrence of the search string,
   * starting at the specified offset, or -1 if no occurrence was found.
   */
55
  public int findPrevious() {
    // Don't match empty strings and don't match if we are at the beginning of the document.
    if (findString.length() == 0 ||
    startIndex < findString.length() - 1) {
      //System.out.println("too close to start");
      return -1;
    }
    
    try {
      int nextMatch = matchLowerCase.length - 1; // index of next matching character
      
      // For simplicity, we request all text of the document in a single
      // segment.
      Segment text = new Segment();
      text.setPartialReturn(false);
      document.getText(0, startIndex + 1, text);
      
      // Iterate through the characters in the current segment
      char previous = text.last();
      //System.out.println("previus isch "+previous);
      for (text.last(); previous != Segment.DONE; previous = text.previous()) {
        
        // Check if the current character matches with the next
        // search character.
        char current = text.current();
        if (current == matchUpperCase[nextMatch] ||
        current == matchLowerCase[nextMatch]) {
          nextMatch--;
          //System.out.println("matched "+nextMatch);
          // Did we match all search characters?
          if (nextMatch == -1) {
            int foundIndex = text.getIndex() - text.getBeginIndex();
            //System.out.println("found index:"+foundIndex);
            if (matchType == MatchType.CONTAINS) {
              return foundIndex;
            } else if (matchType == MatchType.STARTS_WITH) {
              if (! isWordChar(foundIndex - 1)) {
                return foundIndex;
              }
            } else if (matchType == MatchType.FULL_WORD) {
              if (! isWordChar(foundIndex - 1) &&
              ! isWordChar(foundIndex + matchLowerCase.length)) {
                return foundIndex;
              }
            }
            nextMatch = matchLowerCase.length - 1;
          }
        } else {
          nextMatch = matchLowerCase.length - 1;
        }
      }
      
      return -1;
    } catch (BadLocationException e) {
      throw new IndexOutOfBoundsException();
###
2574, clear, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 225, 242
3
/**
   * Clears the view.
   */
17
  @Override
  public void clear() {
    final Drawing newDrawing = createDrawing();
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(newDrawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InvocationTargetException ex) {
      ex.printStackTrace();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
###
2575, setStartIndex, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 104, 105
3
/**
   * Sets the start index for the findNext(), findPrevious() methods.
   */
2
  public void setStartIndex(int newValue) {
    startIndex = newValue;
###
2576, read, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 195, 218
3
/**
   * Reads the view from the specified uri.
   */
23
  @Override
  public void read(URI f, URIChooser chooser) throws IOException {
    try {
      final Drawing drawing = createDrawing();
      InputFormat inputFormat = drawing.getInputFormats().get(0);
      inputFormat.read(new File(f), drawing, true);
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(drawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InterruptedException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
    } catch (InvocationTargetException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
###
2577, getLeftInset, NumberedParagraphView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/text/NumberedParagraphView.java, 41, 43
5
/**
   * Gets the left inset.
   *
   * @return the inset >= 0
   */
3
  protected short getLeftInset() {
    short left = super.getLeftInset();
    return (viewFactory.isLineNumbersVisible()) ? (short) (left + NUMBERS_WIDTH) : left;
###
2578, PertView, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 64, 102
3
/**
   * Creates a new view.
   */
33
  public PertView() {
    initComponents();
    JPanel zoomButtonPanel = new JPanel(new BorderLayout());
    scrollPane.setLayout(new PlacardScrollPaneLayout());
    scrollPane.setBorder(new EmptyBorder(0, 0, 0, 0));
    setEditor(new DefaultDrawingEditor());
    undo = new UndoRedoManager();
    view.setDrawing(createDrawing());
    view.getDrawing().addUndoableEditListener(undo);
    initActions();
    undo.addPropertyChangeListener(new PropertyChangeListener() {
      @Override
      public void propertyChange(PropertyChangeEvent evt) {
        setHasUnsavedChanges(undo.hasSignificantEdits());
      }
    });
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    JPanel placardPanel = new JPanel(new BorderLayout());
    javax.swing.AbstractButton pButton;
    pButton = ButtonFactory.createZoomButton(view);
    pButton.putClientProperty("Quaqua.Button.style", "placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin", new Insets(0, 0, 0, 0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    placardPanel.add(pButton, BorderLayout.WEST);
    pButton = ButtonFactory.createToggleGridButton(view);
    pButton.putClientProperty("Quaqua.Button.style", "placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin", new Insets(0, 0, 0, 0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    labels.configureToolBarButton(pButton, "view.toggleGrid.placard");
    placardPanel.add(pButton, BorderLayout.EAST);
    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);
    setGridVisible(preferences.getBoolean("view.gridVisible", false));
    setScaleFactor(preferences.getDouble("view.scaleFactor", 1d));
###
2579, write, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 185, 189
3
/**
   * Writes the view to the specified uri.
   */
5
  @Override
  public void write(URI f, URIChooser chooser) throws IOException {
    Drawing drawing = view.getDrawing();
    OutputFormat outputFormat = drawing.getOutputFormats().get(0);
    outputFormat.write(new File(f), drawing);
###
2580, initComponents, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 257, 268
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
8
  private void initComponents() {
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
###
2581, createDrawing, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 108, 119
3
/**
   * Creates a new Drawing for this view.
   */
12
  protected Drawing createDrawing() {
    DefaultDrawing drawing = new DefaultDrawing();
    DOMStorableInputOutputFormat ioFormat =
        new DOMStorableInputOutputFormat(new PertFactory());
    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();
    inputFormats.add(ioFormat);
    drawing.setInputFormats(inputFormats);
    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();
    outputFormats.add(ioFormat);
    outputFormats.add(new ImageOutputFormat());
    drawing.setOutputFormats(outputFormats);
    return drawing;
###
2582, getScaleFactor, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 130, 131
3
/**
   * Returns the scale factor of the number formatter.
   */
2
  public double getScaleFactor() {
    return scaleFactor;
###
2583, getMinimum, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 89, 90
5
/**
   * Returns the minimum permissible value.
   *
   * @return Minimum legal value that can be input
   */
2
  public Comparable getMinimum() {
    return min;
###
2584, setMinimum, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 77, 81
9
/**
   * Sets the minimum permissible value. If the <code>valueClass</code> has
   * not been specified, and <code>minimum</code> is non null, the
   * <code>valueClass</code> will be set to that of the class of
   * <code>minimum</code>.
   *
   * @param minimum Minimum legal value that can be input
   * @see #setValueClass
   */
5
  public void setMinimum(Comparable minimum) {
    if (getValueClass() == null && minimum != null) {
      setValueClass(minimum.getClass());
    }
    min = minimum;
###
2585, valueToString, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 175, 215
8
/**
   * Returns a String representation of the Object <code>value</code>.
   * This invokes <code>format</code> on the current <code>Format</code>.
   *
   * @throws ParseException if there is an error in the conversion
   * @param value Value to convert
   * @return String representation of value
   */
39
  @Override
  public String valueToString(Object value) throws ParseException {
    if (value == null && allowsNullValue) {
      return "";
    }
    if (value instanceof Double) {
      double v = ((Double) value).doubleValue();
      v *= scaleFactor;
      String str = Double.toString(v);
      if (!appendsDotZero && str.endsWith(".0")) {
        str = str.substring(0, str.length() - 2);
      }
      return str;
    } else if (value instanceof Float) {
      float v = ((Float) value).floatValue();
      v = (float) (v * scaleFactor);
      String str = Float.toString(v);
      if (appendsDotZero && str.endsWith(".0")) {
        str = str.substring(0, str.length() - 2);
      }
      return str;
    } else if (value instanceof Long) {
      long v = ((Long) value).longValue();
      v = (long) (v * scaleFactor);
      return Long.toString(v);
    } else if (value instanceof Integer) {
      int v = ((Integer) value).intValue();
      v = (int) (v * scaleFactor);
      return Integer.toString(v);
    } else if (value instanceof Byte) {
      byte v = ((Byte) value).byteValue();
      v = (byte) (v * scaleFactor);
      return Byte.toString(v);
    } else if (value instanceof Short) {
      short v = ((Short) value).shortValue();
      v = (short) (v * scaleFactor);
      return Short.toString(v);
    }
    throw new ParseException("Value is of unsupported class " + value, 0);
###
2586, setMaximum, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 102, 106
9
/**
   * Sets the maximum permissible value. If the <code>valueClass</code> has
   * not been specified, and <code>max</code> is non null, the
   * <code>valueClass</code> will be set to that of the class of
   * <code>max</code>.
   *
   * @param max Maximum legal value that can be input
   * @see #setValueClass
   */
5
  public void setMaximum(Comparable max) {
    if (getValueClass() == null && max != null) {
      setValueClass(max.getClass());
    }
    this.max = max;
###
2587, isValidValue, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 286, 312
7
/**
   * Returns true if <code>value</code> is between the min/max.
   *
   * @param wantsCCE If false, and a ClassCastException is thrown in
   *         comparing the values, the exception is consumed and
   *         false is returned.
   */
25
  @SuppressWarnings("unchecked")
  boolean isValidValue(Object value, boolean wantsCCE) {
    Comparable min = getMinimum();
    try {
      if (min != null && min.compareTo(value) > 0) {
        return false;
      }
    } catch (ClassCastException cce) {
      if (wantsCCE) {
        throw cce;
      }
      return false;
    }
    Comparable max = getMaximum();
    try {
      if (max != null && max.compareTo(value) < 0) {
        return false;
      }
    } catch (ClassCastException cce) {
      if (wantsCCE) {
        throw cce;
      }
      return false;
    }
    return true;
###
2588, getAllowsNullValue, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 146, 147
3
/**
   * Returns true if null values are allowed.
   */
2
  public boolean getAllowsNullValue() {
    return allowsNullValue;
###
2590, stringToValue, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 226, 276
8
/**
   * Returns the <code>Object</code> representation of the
   * <code>String</code> <code>text</code>.
   *
   * @param text <code>String</code> to convert
   * @return <code>Object</code> representation of text
   * @throws ParseException if there is an error in the conversion
   */
50
  @Override
  public Object stringToValue(String text) throws ParseException {
    if ((text == null || text.length() == 0) && getAllowsNullValue()) {
      return null;
    }
    Class valueClass = getValueClass();
    Object value;
    if (valueClass != null) {
      try {
        if (valueClass == Integer.class) {
          int v = Integer.parseInt(text);
          v = (int) (v / scaleFactor);
          value = new Integer(v);
        } else if (valueClass == Long.class) {
          long v = Long.parseLong(text);
          v = (long) (v / scaleFactor);
          value = new Long(v);
        } else if (valueClass == Float.class) {
          float v = Float.parseFloat(text);
          v = (float) (v / scaleFactor);
          value = new Float(v);
        } else if (valueClass == Double.class) {
          double v = Double.parseDouble(text);
          v = (double) (v / scaleFactor);
          value = new Double(v);
        } else if (valueClass == Byte.class) {
          byte v = Byte.parseByte(text);
          v = (byte) (v / scaleFactor);
          value = new Byte(v);
        } else if (valueClass == Short.class) {
          short v = Short.parseShort(text);
          v = (short) (v / scaleFactor);
          value = new Short(v);
        } else {
          throw new ParseException("Unsupported value class " + valueClass, 0);
        }
      } catch (NumberFormatException e) {
        throw new ParseException(e.getMessage(), 0);
      }
    } else {
      throw new ParseException("Unsupported value class " + valueClass, 0);
    }
    try {
      if (!isValidValue(value, true)) {
        throw new ParseException("Value not within min/max range", 0);
      }
    } catch (ClassCastException cce) {
      throw new ParseException("Class cast exception comparing values: " + cce, 0);
    }
    return value;
###
2591, JavaNumberFormatter, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 58, 65
3
/**
   * Creates a NumberFormatter with the specified Format instance.
   */
8
  public JavaNumberFormatter(double min, double max, double scaleFactor, boolean allowsNullValue, boolean appendsDotZero) {
    super();
    setMinimum(min);
    setMaximum(max);
    setScaleFactor(scaleFactor);
    setAllowsNullValue(allowsNullValue);
    setAppendsDotZero(appendsDotZero);
    setOverwriteMode(false);
###
2592, createFormatterFactory, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 320, 321
5
/**
   * Convenience method for creating a formatter factory with a
   * {@code ScalableNumberFormatter} and a Java-style DecimalFormat.
   * Doesn't allow null values and doesn't append ".0" to double and float values.
   */
2
  public static AbstractFormatterFactory createFormatterFactory(double min, double max, double scaleFactor) {
    return createFormatterFactory(min, max, scaleFactor, false, false);
###
2593, setAppendsDotZero, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 156, 157
6
/**
   * Specifies whether ".0" is appended to double and float
   * values. By default this is true.
   *
   * @param newValue
   */
2
  public void setAppendsDotZero(boolean newValue) {
    appendsDotZero = newValue;
###
2594, getMaximum, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 114, 115
5
/**
   * Returns the maximum permissible value.
   *
   * @return Maximum legal value that can be input
   */
2
  public Comparable getMaximum() {
    return max;
###
2595, JavaNumberFormatter, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 51, 52
3
/**
   * Creates a NumberFormatter with the specified Format instance.
   */
2
  public JavaNumberFormatter(double min, double max, double scaleFactor) {
    this(min, max, scaleFactor, false, true);
###
2596, setScaleFactor, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 123, 124
5
/**
   * Changes the scale factor of the number formatter.
   *
   * @param newValue
   */
2
  public void setScaleFactor(double newValue) {
    scaleFactor = newValue;
###
2597, getAppendsDotZero, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 163, 164
3
/**
   * Returns true if null values are allowed.
   */
2
  public boolean getAppendsDotZero() {
    return appendsDotZero;
###
2598, setAllowsNullValue, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 139, 140
5
/**
   * Allows/Disallows null values.
   *
   * @param newValue
   */
2
  public void setAllowsNullValue(boolean newValue) {
    allowsNullValue = newValue;
###
2599, write, LFWriter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java, 63, 76
5
/**
   * Write a single character.
   *
   * @exception  IOException  If an I/O error occurs
   */
14
  public void write(int c) throws IOException {
    switch (c) {
      case '\r':
        out.write(lineSeparator);
        skipLF = true;
        break;
      case '\n':
        if (!skipLF) out.write(lineSeparator);
        skipLF = false;
        break;
      default :
        out.write(c);
        skipLF = false;
        break;
###
2600, write, LFWriter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java, 89, 113
9
/**
   * Write a portion of an array of characters.
   *
   * @param  cbuf  Buffer of characters to be written
   * @param  off   Offset from which to start reading characters
   * @param  len   Number of characters to be written
   *
   * @exception  IOException  If an I/O error occurs
   */
25
  public void write(char cbuf[], int off, int len) throws IOException {
    int end = off + len;
    for (int i=off; i < end; i++) {
      switch (cbuf[i]) {
        case '\r':
          out.write(cbuf, off, i - off);
          off = i + 1;
          out.write(lineSeparator);
          skipLF = true;
          break;
        case '\n':
          out.write(cbuf, off, i - off);
          off = i + 1;
          if (skipLF) {
            skipLF = false;
          } else {
            out.write(lineSeparator);
          }
          break;
        default :
          skipLF = false;
          break;
      }
    }
    if (off < end) out.write(cbuf, off, end - off);
###
2601, setLineSeparator, LFWriter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java, 54, 55
3
/**
   * Sets the line separator for the println() methods.
   */
2
  public void setLineSeparator(String lineSeparator) {
    this.lineSeparator = lineSeparator;
###
2602, getLineSeparator, LFWriter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java, 47, 48
3
/**
   * Gets the line separator of the println() methods.
   */
2
  public String getLineSeparator() {
    return lineSeparator;
###
2603, LFWriter, LFWriter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java, 39, 41
3
/**
   * Create a new line-numbering writer.
   */
3
  public LFWriter(Writer out) {
    super(out);
    lineSeparator = (String) System.getProperty("line.separator");
###
2604, createFormatterFactory, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 166, 167
5
/**
   * Convenience method for creating a formatter factory with a
   * {@code FontFormatter}.
   * Uses the RGB_INTEGER format and disallows null values.
   */
2
  public static AbstractFormatterFactory createFormatterFactory() {
    return createFormatterFactory(false);
###
2605, getAllowsUnknownFont, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 92, 93
3
/**
   * Returns true, if unknown font names are allowed.
   */
2
  public boolean getAllowsUnknownFont() {
    return allowsUnknownFont;
###
2606, clearGenericFontFamilies, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 97, 98
1
/** Clears the generic font families map. */
2
  public void clearGenericFontFamilies() {
    genericFontFamilies = null;
###
2607, getAllowsNullValue, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 77, 78
3
/**
   * Returns true, if null value is allowed.
   */
2
  public boolean getAllowsNullValue() {
    return allowsNullValue;
###
2608, putGenericFontFamily, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 102, 103
1
/** Adds a generic font family. */
2
  public void putGenericFontFamily(String familyName, Font font) {
    genericFontFamilies.put(familyName.toLowerCase(), font);
###
2609, setAllowsNullValue, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 70, 71
4
/**
   * Sets whether a null value is allowed.
   * @param newValue
   */
2
  public void setAllowsNullValue(boolean newValue) {
    allowsNullValue = newValue;
###
2610, setAllowsUnknownFont, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 85, 86
4
/**
   * Sets whether unknown font names are allowed.
   * @param newValue
   */
2
  public void setAllowsUnknownFont(boolean newValue) {
    allowsUnknownFont = newValue;
###
2611, readSVGElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 507, 588
3
/**
   * Reads an SVG "svg" element.
   */
71
  private Figure readSVGElement(IXMLElement elem)
      throws IOException {
    // Establish a new viewport
    Viewport viewport = new Viewport();
    String widthValue = readAttribute(elem, "width", "100%");
    String heightValue = readAttribute(elem, "height", "100%");
    viewport.width = toWidth(elem, widthValue);
    viewport.height = toHeight(elem, heightValue);
    if (readAttribute(elem, "viewBox", "none").equals("none")) {
      viewport.viewBox.width = viewport.width;
      viewport.viewBox.height = viewport.height;
    } else {
      String[] viewBoxValues = toWSOrCommaSeparatedArray(readAttribute(elem, "viewBox", "none"));
      viewport.viewBox.x = toNumber(elem, viewBoxValues[0]);
      viewport.viewBox.y = toNumber(elem, viewBoxValues[1]);
      viewport.viewBox.width = toNumber(elem, viewBoxValues[2]);
      viewport.viewBox.height = toNumber(elem, viewBoxValues[3]);
      // FIXME - Calculate percentages
      if (widthValue.indexOf('%') > 0) {
        viewport.width = viewport.viewBox.width;
      }
      if (heightValue.indexOf('%') > 0) {
        viewport.height = viewport.viewBox.height;
      }
    }
    if (viewportStack.size() == 1) {
      // We always preserve the aspect ratio for to the topmost SVG element.
      // This is not compliant, but looks much better.
      viewport.isPreserveAspectRatio = true;
    } else {
      viewport.isPreserveAspectRatio = !readAttribute(elem, "preserveAspectRatio", "none").equals("none");
    }
    viewport.widthPercentFactor = viewport.viewBox.width / 100d;
    viewport.heightPercentFactor = viewport.viewBox.height / 100d;
    viewport.numberFactor = Math.min(
        viewport.width / viewport.viewBox.width,
        viewport.height / viewport.viewBox.height);
    AffineTransform viewBoxTransform = new AffineTransform();
    viewBoxTransform.translate(
        -viewport.viewBox.x * viewport.width / viewport.viewBox.width,
        -viewport.viewBox.y * viewport.height / viewport.viewBox.height);
    if (viewport.isPreserveAspectRatio) {
      double factor = Math.min(
          viewport.width / viewport.viewBox.width,
          viewport.height / viewport.viewBox.height);
      viewBoxTransform.scale(factor, factor);
    } else {
      viewBoxTransform.scale(
          viewport.width / viewport.viewBox.width,
          viewport.height / viewport.viewBox.height);
    }
    viewportStack.push(viewport);
    readViewportAttributes(elem, viewportStack.firstElement().attributes);

    // Read the figures
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        Figure childFigure = readElement(child);
        // skip invisible elements
        if (readAttribute(child, "visibility", "visible").equals("visible") &&
            !readAttribute(child, "display", "inline").equals("none")) {
          if (childFigure != null) {
            childFigure.transform(viewBoxTransform);
            figures.add(childFigure);
          }
        }
      }
    }
    viewportStack.pop();
    return null;
###
2612, toDouble, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3215, 3220
3
/**
   * Reads a double attribute.
   */
6
  private double toDouble(IXMLElement elem, String value, double defaultValue, double min, double max) throws IOException {
    try {
      double d = Double.valueOf(value);
      return Math.max(Math.min(d, max), min);
    } catch (NumberFormatException e) {
      return defaultValue;
###
2613, readFontAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2968, 3078
3
/* Reads font attributes as listed in
   * http://www.w3.org/TR/SVGMobile12/feature.html#Font
   */
104
  private void readFontAttributes(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    String value;
    double doubleValue;
    // 'font-family'
    // Value:    [[ <family-name> |
    // <generic-family> ],]* [<family-name> |
    // <generic-family>] | inherit
    // Initial:    depends on user agent
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "font-family", "Dialog");
    String[] familyNames = toQuotedAndCommaSeparatedArray(value);
    Font font = null;
    // Try to find a font with exactly matching name
    for (int i = 0; i < familyNames.length; i++) {
      try {
        font = (Font) fontFormatter.stringToValue(familyNames[i]);
        break;
      } catch (ParseException e) {
      }
    }
    if (font == null) {
      // Try to create a similar font using the first name in the list
      if (familyNames.length > 0) {
        fontFormatter.setAllowsUnknownFont(true);
        try {
          font = (Font) fontFormatter.stringToValue(familyNames[0]);
        } catch (ParseException e) {
        }
        fontFormatter.setAllowsUnknownFont(false);
      }
    }
    if (font == null) {
      // Fallback to the system Dialog font
      font = new Font("Dialog", Font.PLAIN, 12);
    }
    FONT_FACE.put(a, font);
    // 'font-getChildCount'
    // Value:    <absolute-getChildCount> | <relative-getChildCount> |
    // <length> | inherit
    // Initial:    medium
    // Applies to:    text content elements
    // Inherited:    yes, the computed value is inherited
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Absolute length
    doubleValue = readInheritFontSizeAttribute(elem, "font-size", "medium");
    FONT_SIZE.put(a, doubleValue);
    // 'font-style'
    // Value:    normal | italic | oblique | inherit
    // Initial:    normal
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "font-style", "normal");
    FONT_ITALIC.put(a, value.equals("italic"));

    //'font-variant'
    //Value:    normal | small-caps | inherit
    //Initial:    normal
    //Applies to:    text content elements
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    no
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "font-variant", "normal");
    // if (DEBUG) System.out.println("font-variant="+value);
    // 'font-weight'
    // Value:    normal | bold | bolder | lighter | 100 | 200 | 300
    // | 400 | 500 | 600 | 700 | 800 | 900 | inherit
    // Initial:    normal
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     one of the legal numeric values, non-numeric
    // values shall be converted to numeric values according to the rules
    // defined below.
    value = readInheritAttribute(elem, "font-weight", "normal");
    FONT_BOLD.put(a, value.equals("bold") || value.equals("bolder") ||
        value.equals("400") || value.equals("500") || value.equals("600") ||
        value.equals("700") || value.equals("800") || value.equals("900"));
    // Note: text-decoration is an SVG 1.1 feature
    //'text-decoration'
    //Value:    none | [ underline || overline || line-through || blink ] | inherit
    //Initial:    none
    //Applies to:    text content elements
    //Inherited:    no (see prose)
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    value = readAttribute(elem, "text-decoration", "none");
    FONT_UNDERLINE.put(a, value.equals("underline"));
###
2614, readCircleElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 626, 640
3
/**
   * Reads an SVG "circle" element.
   */
13
  private Figure readCircleElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    double cx = toWidth(elem, readAttribute(elem, "cx", "0"));
    double cy = toHeight(elem, readAttribute(elem, "cy", "0"));
    double r = toWidth(elem, readAttribute(elem, "r", "0"));
    Figure figure = factory.createCircle(cx, cy, r, a);
    elementObjects.put(elem, figure);
    return figure;
###
2615, readPathElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 826, 838
3
/**
   * Reads an SVG "path" element.
   */
11
  private Figure readPathElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    BezierPath[] beziers = toPath(elem, readAttribute(elem, "d", ""));
    Figure figure = factory.createPath(beziers, a);
    elementObjects.put(elem, figure);
    return figure;
###
2616, toQuotedAndCommaSeparatedArray, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1348, 1367
4
/**
   * Returns a value as a String array.
   * The values are separated by commas with optional quotes and white space.
   */
19
  public static String[] toQuotedAndCommaSeparatedArray(String str) throws IOException {
    LinkedList<String> values = new LinkedList<String>();
    StreamTokenizer tt = new StreamTokenizer(new StringReader(str));
    tt.wordChars('a', 'z');
    tt.wordChars('A', 'Z');
    tt.wordChars(128 + 32, 255);
    tt.whitespaceChars(0, ' ');
    tt.quoteChar('"');
    tt.quoteChar('\'');
    while (tt.nextToken() != StreamTokenizer.TT_EOF) {
      switch (tt.ttype) {
        case StreamTokenizer.TT_WORD:
        case '"':
        case '\'':
          values.add(tt.sval);
          break;
      }
    }
    return values.toArray(new String[values.size()]);
###
2617, readTextFlowAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1953, 1968
3
/* Reads text flow attributes as listed in
   * http://www.w3.org/TR/SVGMobile12/feature.html#TextFlow
   */
15
  private void readTextFlowAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    Object value;
    //'line-increment'
    //Value:    auto | <number> | inherit
    //Initial:    auto
    //Applies to:    'textArea'
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "line-increment", "auto");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented line-increment=" + value);
###
2618, readOpacityAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1875, 1892
3
/* Reads object/group opacity as described in
   * http://www.w3.org/TR/SVGMobile12/painting.html#groupOpacity
   */
18
  private void readOpacityAttribute(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    //'opacity'
    //Value:    <opacity-value> | inherit
    //Initial:    1
    //Applies to:     'image' element
    //Inherited:    no
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:     Specified value, except inherit
    //<opacity-value>
    //The uniform opacity setting must be applied across an entire object.
    //Any values outside the range 0.0 (fully transparent) to 1.0
    //(fully opaque) shall be clamped to this range.
    //(See Clamping values which are restricted to a particular range.)
    double value = toDouble(elem, readAttribute(elem, "opacity", "1"), 1, 0, 1);
    OPACITY.put(a, value);
###
2619, toWidth, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1257, 1260
7
/**
   * Returns a value as a width.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#Animation",
 --------------
4
  private double toWidth(IXMLElement elem, String str) throws IOException {
    // XXX - Compute xPercentFactor from viewport
    return toLength(elem, str,
        viewportStack.peek().widthPercentFactor);
###
2620, readUseElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1095, 1132
6
/**
   * Reads an SVG "use" element.
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#ExternalResourcesRequired",
 --------------
35
  @SuppressWarnings("unchecked")
  private Figure readUseElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    HashMap<AttributeKey, Object> a2 = new HashMap<AttributeKey, Object>();
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a2);
    readUseShapeAttributes(elem, a2);
    readFontAttributes(elem, a2);
    String href = readAttribute(elem, "xlink:href", null);
    if (href != null && href.startsWith("#")) {
      IXMLElement refElem = identifiedElements.get(href.substring(1));
      if (refElem == null) {
        if (DEBUG) {
          System.out.println("SVGInputFormat couldn't find href for <use> element:" + href);
        }
      } else {
        Object obj = readElement(refElem);
        if (obj instanceof Figure) {
          Figure figure = (Figure) ((Figure) obj).clone();
          for (Map.Entry<AttributeKey, Object> entry : a2.entrySet()) {
            figure.set(entry.getKey(), entry.getValue());
          }
          AffineTransform tx =
              (TRANSFORM.get(a) == null) ? new AffineTransform() : TRANSFORM.get(a);
          double x = toNumber(elem, readAttribute(elem, "x", "0"));
          double y = toNumber(elem, readAttribute(elem, "y", "0"));
          tx.translate(x, y);
          figure.transform(tx);
          return figure;
        }
      }
    }
    return null;
###
2621, readDefsElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 421, 426
3
/**
   * Reads an SVG "defs" element.
   */
6
  private void readDefsElement(IXMLElement elem)
      throws IOException {
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        Figure childFigure = readElement(child);
###
2622, readTransformAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1976, 1981
3
/* Reads the transform attribute as specified in
   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute
   */
6
  private void readTransformAttribute(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    String value;
    value = readAttribute(elem, "transform", "none");
    if (!value.equals("none")) {
      TRANSFORM.put(a, toTransform(elem, value));
###
2623, readPolylineElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 790, 802
3
/**
   * Reads an SVG "polyline" element.
   */
11
  private Figure readPolylineElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readLineAttributes(elem, a);
    Point2D.Double[] points = toPoints(elem, readAttribute(elem, "points", ""));
    Figure figure = factory.createPolyline(points, a);
    elementObjects.put(elem, figure);
    return figure;
###
2624, readViewportAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2639, 2683
2
/* Reads viewport attributes.
   */
43
  private void readViewportAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    Object value;
    Double doubleValue;
    // width of the viewport
    value = readAttribute(elem, "width", null);
    if (DEBUG) {
      System.out.println("SVGInputFormat READ viewport w/h factors:" + viewportStack.peek().widthPercentFactor + "," + viewportStack.peek().heightPercentFactor);
    }
    if (value != null) {
      doubleValue = toLength(elem, (String) value, viewportStack.peek().widthPercentFactor);
      VIEWPORT_WIDTH.put(a, doubleValue);
    }
    // height of the viewport
    value = readAttribute(elem, "height", null);
    if (value != null) {
      doubleValue = toLength(elem, (String) value, viewportStack.peek().heightPercentFactor);
      VIEWPORT_HEIGHT.put(a, doubleValue);
    }
    //'viewport-fill'
    //Value:   "none" | <color> | inherit
    //Initial:   none
    //Applies to:  viewport-creating elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     "none" or specified <color> value, except inherit
    value = toPaint(elem, readInheritColorAttribute(elem, "viewport-fill", "none"));
    if (value == null || (value instanceof Color)) {
      VIEWPORT_FILL.put(a, (Color) value);
    }
    //'viewport-fill-opacity'
    //Value:  <opacity-value> | inherit
    //Initial:   1.0
    //Applies to:  viewport-creating elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     Specified value, except inherit
    doubleValue = toDouble(elem, readAttribute(elem, "viewport-fill-opacity", "1.0"));
    VIEWPORT_FILL_OPACITY.put(a, doubleValue);
###
2625, readTSpanElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 969, 995
3
/**
   * Reads an SVG "tspan" element.
   */
27
  private void readTSpanElement(IXMLElement elem, DefaultStyledDocument doc)
      throws IOException {
    try {
      if (elem.getContent() != null) {
        doc.insertString(doc.getLength(), toText(elem, elem.getContent()), null);
      } else {
        for (IXMLElement node : elem.getChildren()) {
          if (node instanceof IXMLElement) {
            IXMLElement child = (IXMLElement) node;
            if (node.getName() != null && node.getName().equals("tspan")) {
              readTSpanElement((IXMLElement) node, doc);
            } else {
              if (DEBUG) {
                System.out.println("SVGInputFormat unknown text node " + node.getName());
              }
            }
          } else {
            if (node.getName() == null) {
              doc.insertString(doc.getLength(), toText(elem, node.getContent()), null);
            }
          }
        }
      }
    } catch (BadLocationException e) {
      InternalError ex = new InternalError(e.getMessage());
      ex.initCause(e);
      throw ex;
###
2626, readEllipseElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 646, 661
3
/**
   * Reads an SVG "ellipse" element.
   */
14
  private Figure readEllipseElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    double cx = toWidth(elem, readAttribute(elem, "cx", "0"));
    double cy = toHeight(elem, readAttribute(elem, "cy", "0"));
    double rx = toWidth(elem, readAttribute(elem, "rx", "0"));
    double ry = toHeight(elem, readAttribute(elem, "ry", "0"));
    Figure figure = factory.createEllipse(cx, cy, rx, ry, a);
    elementObjects.put(elem, figure);
    return figure;
###
2627, readInheritFontSizeAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1199, 1225
9
/**
   * Reads a font size attribute that is inherited.
   * As specified by
   * http://www.w3.org/TR/SVGMobile12/text.html#FontPropertiesUsedBySVG
   * http://www.w3.org/TR/2006/CR-xsl11-20060220/#font-getChildCount
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#Listener",
 --------------
26
  private double readInheritFontSizeAttribute(IXMLElement elem, String attributeName, String defaultValue)
      throws IOException {
    String value = null;
    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
      value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
    } else if (elem.hasAttribute(attributeName)) {
      value = elem.getAttribute(attributeName, null);
    } else if (elem.getParent() != null &&
        (elem.getParent().getNamespace() == null ||
        elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {
      return readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
    } else {
      value = defaultValue;
    }
    if (value.equals("inherit")) {
      return readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
    } else if (SVG_ABSOLUTE_FONT_SIZES.containsKey(value)) {
      return SVG_ABSOLUTE_FONT_SIZES.get(value);
    } else if (SVG_RELATIVE_FONT_SIZES.containsKey(value)) {
      return SVG_RELATIVE_FONT_SIZES.get(value) * readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
    } else if (value.endsWith("%")) {
      double factor = Double.valueOf(value.substring(0, value.length() - 1));
      return factor * readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
    } else {
      //return toScaledNumber(elem, value);
      return toNumber(elem, value);
###
2628, toPoints, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1374, 1384
4
/**
   * Returns a value as a Point2D.Double array.
   * as specified in http://www.w3.org/TR/SVGMobile12/shapes.html#PointsBNF
   */
9
  private Point2D.Double[] toPoints(IXMLElement elem, String str) throws IOException {
    StringTokenizer tt = new StringTokenizer(str, " ,");
    Point2D.Double[] points = new Point2D.Double[tt.countTokens() / 2];
    for (int i = 0; i < points.length; i++) {
      points[i] = new Point2D.Double(
          toNumber(elem, tt.nextToken()),
          toNumber(elem, tt.nextToken()));
    }
    return points;
###
2629, SVGInputFormat, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 155, 156
1
/** Creates a new instance. */
2
  public SVGInputFormat() {
    this(new DefaultSVGFigureFactory());
###
2630, readInheritAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1138, 1158
6
/**
   * Reads an attribute that is inherited.
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#Scripting",
 --------------
21
  private String readInheritAttribute(IXMLElement elem, String attributeName, String defaultValue) {
    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
      String value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
      if (value.equals("inherit")) {
        return readInheritAttribute(elem.getParent(), attributeName, defaultValue);
      } else {
        return value;
      }
    } else if (elem.hasAttribute(attributeName)) {
      String value = elem.getAttribute(attributeName);
      if (value.equals("inherit")) {
        return readInheritAttribute(elem.getParent(), attributeName, defaultValue);
      } else {
        return value;
      }
    } else if (elem.getParent() != null &&
        (elem.getParent().getNamespace() == null ||
        elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {
      return readInheritAttribute(elem.getParent(), attributeName, defaultValue);
    } else {
      return defaultValue;
###
2631, toPath, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1394, 1841
7
/**
   * Returns a value as a BezierPath array.
   * as specified in http://www.w3.org/TR/SVGMobile12/paths.html#PathDataBNF
   *
   * Also supports elliptical arc commands 'a' and 'A' as specified in
   * http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
   */
416
  private BezierPath[] toPath(IXMLElement elem, String str) throws IOException {
    LinkedList<BezierPath> paths = new LinkedList<BezierPath>();
    BezierPath path = null;
    Point2D.Double p = new Point2D.Double();
    Point2D.Double c1 = new Point2D.Double();
    Point2D.Double c2 = new Point2D.Double();
    StreamPosTokenizer tt;
    if (toPathTokenizer == null) {
      tt = new StreamPosTokenizer(new StringReader(str));
      tt.resetSyntax();
      tt.parseNumbers();
      tt.parseExponents();
      tt.parsePlusAsNumber();
      tt.whitespaceChars(0, ' ');
      tt.whitespaceChars(',', ',');
      toPathTokenizer = tt;
    } else {
      tt = toPathTokenizer;
      tt.setReader(new StringReader(str));
    }

    char nextCommand = 'M';
    char command = 'M';
    Commands:
    while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
      if (tt.ttype > 0) {
        command = (char) tt.ttype;
      } else {
        command = nextCommand;
        tt.pushBack();
      }
      BezierPath.Node node;
      switch (command) {
        case 'M':
          // absolute-moveto x y
          if (path != null) {
            paths.add(path);
          }
          path = new BezierPath();
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'M' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'M' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.moveTo(p.x, p.y);
          nextCommand = 'L';
          break;
        case 'm':
          // relative-moveto dx dy
          if (path != null) {
            paths.add(path);
          }
          path = new BezierPath();
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'm' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'm' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.moveTo(p.x, p.y);
          nextCommand = 'l';
          break;
        case 'Z':
        case 'z':
          // close path
          p.x = path.get(0).x[0];
          p.y = path.get(0).y[0];
          // If the last point and the first point are the same, we
          // can merge them
          if (path.size() > 1) {
            BezierPath.Node first = path.get(0);
            BezierPath.Node last = path.get(path.size() - 1);
            if (first.x[0] == last.x[0] &&
                first.y[0] == last.y[0]) {
              if ((last.mask & BezierPath.C1_MASK) != 0) {
                first.mask |= BezierPath.C1_MASK;
                first.x[1] = last.x[1];
                first.y[1] = last.y[1];
              }
              path.remove(path.size() - 1);
            }
          }
          path.setClosed(true);
          break;
        case 'L':
          // absolute-lineto x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'L' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'L' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'L';
          break;
        case 'l':
          // relative-lineto dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'l' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'l' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'l';
          break;
        case 'H':
          // absolute-horizontal-lineto x
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'H' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'H';
          break;
        case 'h':
          // relative-horizontal-lineto dx
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'h' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'h';
          break;
        case 'V':
          // absolute-vertical-lineto y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'V' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'V';
          break;
        case 'v':
          // relative-vertical-lineto dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'v' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'v';
          break;
        case 'C':
          // absolute-curveto x1 y1 x2 y2 x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x1 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y1 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x2 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y2 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'C';
          break;
        case 'c':
          // relative-curveto dx1 dy1 dx2 dy2 dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx1 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy1 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx2 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy2 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'c';
          break;
        case 'S':
          // absolute-shorthand-curveto x2 y2 x y
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x2 coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y2 coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'S';
          break;
        case 's':
          // relative-shorthand-curveto dx2 dy2 dx dy
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx2 coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy2 coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 's';
          break;
        case 'Q':
          // absolute-quadto x1 y1 x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x1 coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y1 coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'Q';
          break;
        case 'q':
          // relative-quadto dx1 dy1 dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx1 coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy1 coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'q';
          break;
        case 'T':
          // absolute-shorthand-quadto x y
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'T' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'T' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'T';
          break;
        case 't':
          // relative-shorthand-quadto dx dy
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 't' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 't' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 's';
          break;

        case 'A': {
          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("rx coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          // If rX or rY have negative signs, these are dropped;
          // the absolute value is used instead.
          double rx = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("ry coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double ry = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x-axis-rotation missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double xAxisRotation = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("large-arc-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean largeArcFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("sweep-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean sweepFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
          nextCommand = 'A';
          break;
        }
        case 'a': {
          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("rx coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          // If rX or rY have negative signs, these are dropped;
          // the absolute value is used instead.
          double rx = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("ry coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double ry = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x-axis-rotation missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double xAxisRotation = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("large-arc-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean largeArcFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("sweep-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean sweepFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
          nextCommand = 'a';
          break;
        }
        default:
          if (DEBUG) {
            System.out.println("SVGInputFormat.toPath aborting after illegal path command: " + command + " found in path " + str);
          }
          break Commands;
        //throw new IOException("Illegal command: "+command);
      }
    }
    if (path != null) {
      paths.add(path);
    }
    return paths.toArray(new BezierPath[paths.size()]);
###
2632, readAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1233, 1249
6
/**
   * Reads an attribute that is not inherited, unless its value is "inherit".
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#TimedAnimation",
 --------------
17
  private String readAttribute(IXMLElement elem, String attributeName, String defaultValue) {
    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
      String value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
      if (value.equals("inherit")) {
        return readAttribute(elem.getParent(), attributeName, defaultValue);
      } else {
        return value;
      }
    } else if (elem.hasAttribute(attributeName)) {
      String value = elem.getAttribute(attributeName, null);
      if (value.equals("inherit")) {
        return readAttribute(elem.getParent(), attributeName, defaultValue);
      } else {
        return value;
      }
    } else {
      return defaultValue;
###
2633, readAElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 464, 501
3
/**
   * Reads an SVG "a" element.
   */
35
  private Figure readAElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    CompositeFigure g = factory.createG(a);
    String href = readAttribute(elem, "xlink:href", null);
    if (href == null) {
      href = readAttribute(elem, "href", null);
    }
    String target = readAttribute(elem, "target", null);
    if (DEBUG) {
      System.out.println("SVGInputFormat.readAElement href=" + href);
    }
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        Figure childFigure = readElement(child);
        // skip invisible elements
        if (readAttribute(child, "visibility", "visible").equals("visible") &&
            !readAttribute(child, "display", "inline").equals("none")) {
          if (childFigure != null) {
            g.basicAdd(childFigure);
          }
        }
        if (childFigure != null) {
          childFigure.set(LINK, href);
          childFigure.set(LINK_TARGET, target);
        } else {
          if (DEBUG) {
            System.out.println("SVGInputFormat <a> has no child figure");
          }
        }
      }
    }
    return (g.getChildCount() == 1) ? g.getChild(0) : g;
###
2634, toNumber, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1277, 1278
4
/**
   * Returns a value as a number.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeNumber
   */
2
  private double toNumber(IXMLElement elem, String str) throws IOException {
    return toLength(elem, str, viewportStack.peek().numberFactor);
###
2635, readTextAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1898, 1946
3
/* Reads text attributes as listed in
   * http://www.w3.org/TR/SVGMobile12/feature.html#Text
   */
46
  private void readTextAttributes(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    Object value;
    //'text-anchor'
    //Value:    start | middle | end | inherit
    //Initial:    start
    //Applies to:    'text' IXMLElement
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "text-anchor", "start");
    if (SVG_TEXT_ANCHORS.get(value) != null) {
      TEXT_ANCHOR.put(a, SVG_TEXT_ANCHORS.get(value));
    }
    //'display-align'
    //Value:    auto | before | center | after | inherit
    //Initial:    auto
    //Applies to:    'textArea'
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "display-align", "auto");
    // XXX - Implement me properly
    if (!value.equals("auto")) {
      if (value.equals("center")) {
        TEXT_ANCHOR.put(a, TextAnchor.MIDDLE);
      } else if (value.equals("before")) {
        TEXT_ANCHOR.put(a, TextAnchor.END);
      }
    }
    //text-align
    //Value:   start | end | center | inherit
    //Initial:   start
    //Applies to:   textArea elements
    //Inherited:   yes
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    value = readInheritAttribute(elem, "text-align", "start");
    // XXX - Implement me properly
    if (!value.equals("start")) {
      TEXT_ALIGN.put(a, SVG_TEXT_ALIGNS.get(value));
###
2636, toText, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3233, 3238
5
/**
   * Reads a text attribute.
   * This method takes the "xml:space" attribute into account.
   * http://www.w3.org/TR/SVGMobile12/text.html#WhiteSpace
   */
6
  private String toText(IXMLElement elem, String value) throws IOException {
    String space = readInheritAttribute(elem, "xml:space", "default");
    if (space.equals("default")) {
      return value.trim().replaceAll("\\s++", " ");
    } else /*if (space.equals("preserve"))*/ {
      return value;
###
2637, readUseShapeAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2224, 2433
2
/* Reads shape attributes for the SVG "use" element.
   */
198
  private void readUseShapeAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    Object objectValue;
    String value;
    double doubleValue;
    //'color'
    // Value:    <color> | inherit
    // Initial:     depends on user agent
    // Applies to:    None. Indirectly affects other properties via currentColor
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified <color> value, except inherit
    //
    // value = readInheritAttribute(elem, "color", "black");
    // if (DEBUG) System.out.println("color="+value);
    //'color-rendering'
    // Value:     auto | optimizeSpeed | optimizeQuality | inherit
    // Initial:     auto
    // Applies to:     container elements , graphics elements and 'animateColor'
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    //
    // value = readInheritAttribute(elem, "color-rendering", "auto");
    // if (DEBUG) System.out.println("color-rendering="+value);
    // 'fill'
    // Value:    <paint> | inherit (See Specifying paint)
    // Initial:     black
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     "none", system paint, specified <color> value or absolute IRI
    objectValue = readInheritColorAttribute(elem, "fill", null);
    if (objectValue != null) {
      objectValue = toPaint(elem, (String) objectValue);
      if (objectValue instanceof Color) {
        FILL_COLOR.put(a, (Color) objectValue);
      } else if (objectValue instanceof Gradient) {
        FILL_GRADIENT.put(a, (Gradient) objectValue);
      } else if (objectValue == null) {
        FILL_COLOR.put(a, null);
      } else {
        FILL_COLOR.put(a, null);
        if (DEBUG) {
          System.out.println("SVGInputFormat not implemented  fill=" + objectValue);
        }
      }
    }
    //'fill-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "fill-opacity", null);
    if (objectValue != null) {
      FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    }
    // 'fill-rule'
    // Value:   nonzero | evenodd | inherit
    // Initial:    nonzero
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "fill-rule", null);
    if (value != null) {
      WINDING_RULE.put(a, SVG_FILL_RULES.get(value));
    }
    //'stroke'
    //Value:    <paint> | inherit (See Specifying paint)
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     "none", system paint, specified <color> value
    // or absolute IRI
    objectValue = toPaint(elem, readInheritColorAttribute(elem, "stroke", null));
    if (objectValue != null) {
      if (objectValue instanceof Color) {
        STROKE_COLOR.put(a, (Color) objectValue);
      } else if (objectValue instanceof Gradient) {
        STROKE_GRADIENT.put(a, (Gradient) objectValue);
      }
    }
    //'stroke-dasharray'
    //Value:     none | <dasharray> | inherit
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes (non-additive)
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-dasharray", null);
    if (value != null && !value.equals("none")) {
      String[] values = toCommaSeparatedArray(value);
      double[] dashes = new double[values.length];
      for (int i = 0; i < values.length; i++) {
        dashes[i] = toNumber(elem, values[i]);
      }
      STROKE_DASHES.put(a, dashes);
    }
    //'stroke-dashoffset'
    //Value:    <length> | inherit
    //Initial:     0
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-dashoffset", null);
    if (objectValue != null) {
      doubleValue = toNumber(elem, (String) objectValue);
      STROKE_DASH_PHASE.put(a, doubleValue);
      IS_STROKE_DASH_FACTOR.put(a, false);
    }
    //'stroke-linecap'
    //Value:     butt | round | square | inherit
    //Initial:     butt
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linecap", null);
    if (value != null) {
      STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));
    }
    //'stroke-linejoin'
    //Value:     miter | round | bevel | inherit
    //Initial:     miter
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linejoin", null);
    if (value != null) {
      STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));
    }
    //'stroke-miterlimit'
    //Value:     <miterlimit> | inherit
    //Initial:     4
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-miterlimit", null);
    if (objectValue != null) {
      doubleValue = toDouble(elem, (String) objectValue, 4d, 1d, Double.MAX_VALUE);
      STROKE_MITER_LIMIT.put(a, doubleValue);
      IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);
    }
    //'stroke-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-opacity", null);
    if (objectValue != null) {
      STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    }
    //'stroke-width'
    //Value:    <length> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-width", null);
    if (objectValue != null) {
      doubleValue = toNumber(elem, (String) objectValue);
      STROKE_WIDTH.put(a, doubleValue);
###
2638, toHeight, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1267, 1270
7
/**
   * Returns a value as a height.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#Audio",
 --------------
4
  private double toHeight(IXMLElement elem, String str) throws IOException {
    // XXX - Compute yPercentFactor from viewport
    return toLength(elem, str,
        viewportStack.peek().heightPercentFactor);
###
2639, flattenStyles, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 295, 324
11
/**
   * Flattens all CSS styles.
   * Styles defined in a "style" attribute and in CSS rules are converted
   * into attributes with the same name.
   */
 --------------
/**
     * Factor for number values in the user coordinate system.
     * This is the smaller value of width / viewBox.width and height / viewBox.height.
     */
 --------------
26
  private void flattenStyles(IXMLElement elem)
      throws IOException {
    if (elem.getName() != null && elem.getName().equals("style") &&
        readAttribute(elem, "type", "").equals("text/css") &&
        elem.getContent() != null) {
      CSSParser cssParser = new CSSParser();
      cssParser.parse(elem.getContent(), styleManager);
    } else {
      if (elem.getNamespace() == null ||
          elem.getNamespace().equals(SVG_NAMESPACE)) {
        String style = readAttribute(elem, "style", null);
        if (style != null) {
          for (String styleProperty : style.split(";")) {
            String[] stylePropertyElements = styleProperty.split(":");
            if (stylePropertyElements.length == 2 &&
                !elem.hasAttribute(stylePropertyElements[0].trim(), SVG_NAMESPACE)) {
              //if (DEBUG) System.out.println("flatten:"+Arrays.toString(stylePropertyElements));
              elem.setAttribute(stylePropertyElements[0].trim(), SVG_NAMESPACE, stylePropertyElements[1].trim());
            }
          }
        }
        styleManager.applyStylesTo(elem);
        for (IXMLElement node : elem.getChildren()) {
          if (node instanceof IXMLElement) {
            IXMLElement child = (IXMLElement) node;
            flattenStyles(child);
###
2640, toTransform, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3246, 3358
4
/* Converts an SVG transform attribute value into an AffineTransform
   * as specified in
   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute
   */
104
  public static AffineTransform toTransform(IXMLElement elem, String str) throws IOException {
    AffineTransform t = new AffineTransform();
    if (str != null && !str.equals("none")) {
      StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));
      tt.resetSyntax();
      tt.wordChars('a', 'z');
      tt.wordChars('A', 'Z');
      tt.wordChars(128 + 32, 255);
      tt.whitespaceChars(0, ' ');
      tt.whitespaceChars(',', ',');
      tt.parseNumbers();
      tt.parseExponents();
      while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
        if (tt.ttype != StreamPosTokenizer.TT_WORD) {
          throw new IOException("Illegal transform " + str);
        }
        String type = tt.sval;
        if (tt.nextToken() != '(') {
          throw new IOException("'(' not found in transform " + str);
        }
        if (type.equals("matrix")) {
          double[] m = new double[6];
          for (int i = 0; i < 6; i++) {
            if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
              throw new IOException("Matrix value " + i + " not found in transform " + str + " token:" + tt.ttype + " " + tt.sval);
            }
            m[i] = tt.nval;
          }
          t.concatenate(new AffineTransform(m));
        } else if (type.equals("translate")) {
          double tx, ty;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("X-translation value not found in transform " + str);
          }
          tx = tt.nval;
          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
            ty = tt.nval;
          } else {
            tt.pushBack();
            ty = 0;
          }
          t.translate(tx, ty);
        } else if (type.equals("scale")) {
          double sx, sy;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("X-scale value not found in transform " + str);
          }
          sx = tt.nval;
          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
            sy = tt.nval;
          } else {
            tt.pushBack();
            sy = sx;
          }
          t.scale(sx, sy);
        } else if (type.equals("rotate")) {
          double angle, cx, cy;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Angle value not found in transform " + str);
          }
          angle = tt.nval;
          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
            cx = tt.nval;
            if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
              throw new IOException("Y-center value not found in transform " + str);
            }
            cy = tt.nval;
          } else {
            tt.pushBack();
            cx = cy = 0;
          }
          t.rotate(angle * Math.PI / 180d, cx, cy);

        } else if (type.equals("skewX")) {
          double angle;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Skew angle not found in transform " + str);
          }
          angle = tt.nval;
          t.concatenate(new AffineTransform(
              1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0));
        } else if (type.equals("skewY")) {
          double angle;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Skew angle not found in transform " + str);
          }
          angle = tt.nval;
          t.concatenate(new AffineTransform(
              1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0));
        } else if (type.equals("ref")) {
          System.err.println("SVGInputFormat warning: ignored ref(...) transform attribute in element " + elem);
          while (tt.nextToken() != ')' && tt.ttype != StreamPosTokenizer.TT_EOF) {
            // ignore tokens between brackets
          }
          tt.pushBack();
        } else {
          throw new IOException("Unknown transform " + type + " in " + str + " in element " + elem);
        }
        if (tt.nextToken() != ')') {
          throw new IOException("')' not found in transform " + str);
        }
      }
    }
    return t;
###
2641, identifyElements, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1863, 1868
4
/**
   * Puts all elments with an "id" or an "xml:id" attribute into the
   * hashtable {@code identifiedElements}.
   */
5
  private void identifyElements(IXMLElement elem) {
    identifiedElements.put(elem.getAttribute("id"), elem);
    identifiedElements.put(elem.getAttribute("xml:id"), elem);
    for (IXMLElement child : elem.getChildren()) {
      identifyElements(child);
###
2642, toCommaSeparatedArray, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1326, 1327
4
/**
   * Returns a value as a String array.
   * The values are separated by commas with optional white space.
   */
2
  public static String[] toCommaSeparatedArray(String str) throws IOException {
    return str.split("\\s*,\\s*");
###
2643, read, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 176, 277
14
/**
   * This is the main reading method.
   *
   * @param in The input stream.
   * @param drawing The drawing to which this method adds figures.
   * @param replace Whether attributes on the drawing object
   * should by changed by this method. Set this to false, when reading individual
   * images from the clipboard.
   */
 --------------
/**
     * Factor for percent values relative to Viewport height.
     */
 --------------
92
  public void read(InputStream in, Drawing drawing, boolean replace) throws IOException {
    long start = System.currentTimeMillis();
    this.figures = new LinkedList<Figure>();
    IXMLParser parser;
    try {
      parser = XMLParserFactory.createDefaultXMLParser();
    } catch (Exception ex) {
      InternalError e = new InternalError("Unable to instantiate NanoXML Parser");
      e.initCause(ex);
      throw e;
    }
    System.out.println("SVGInputFormat parser created " + (System.currentTimeMillis() - start));
    IXMLReader reader = new StdXMLReader(in);
    parser.setReader(reader);
    System.out.println("SVGInputFormat reader created " + (System.currentTimeMillis() - start));
    try {
      document = (IXMLElement) parser.parse();
    } catch (XMLException ex) {
      IOException e = new IOException(ex.getMessage());
      e.initCause(ex);
      throw e;
    }
    System.out.println("SVGInputFormat document created " + (System.currentTimeMillis() - start));
    // Search for the first 'svg' element in the XML document
    // in preorder sequence
    IXMLElement svg = document;
    Stack<Iterator<IXMLElement>> stack = new Stack<Iterator<IXMLElement>>();
    LinkedList<IXMLElement> ll = new LinkedList<IXMLElement>();
    ll.add(document);
    stack.push(ll.iterator());
    while (!stack.empty() && stack.peek().hasNext()) {
      Iterator<IXMLElement> iter = stack.peek();
      IXMLElement node = iter.next();
      Iterator<IXMLElement> children = (node.getChildren() == null) ? null : node.getChildren().iterator();
      if (!iter.hasNext()) {
        stack.pop();
      }
      if (children != null && children.hasNext()) {
        stack.push(children);
      }
      if (node.getName() != null &&
          node.getName().equals("svg") &&
          (node.getNamespace() == null ||
          node.getNamespace().equals(SVG_NAMESPACE))) {
        svg = node;
        break;
      }
    }

    if (svg.getName() == null ||
        !svg.getName().equals("svg") ||
        (svg.getNamespace() != null &&
        !svg.getNamespace().equals(SVG_NAMESPACE))) {
      throw new IOException("'svg' element expected: " + svg.getName());
    }
    //long end1 = System.currentTimeMillis();
    // Flatten CSS Styles
    initStorageContext(document);
    flattenStyles(svg);
    //long end2 = System.currentTimeMillis();
    readElement(svg);
    long end = System.currentTimeMillis();
    if (DEBUG) {
      System.out.println("SVGInputFormat elapsed:" + (end - start));
    }
    /*if (DEBUG) System.out.println("SVGInputFormat read:"+(end1-start));
    if (DEBUG) System.out.println("SVGInputFormat flatten:"+(end2-end1));
    if (DEBUG) System.out.println("SVGInputFormat build:"+(end-end2));
     */
    if (replace) {
      drawing.removeAllChildren();
    }
    drawing.addAll(figures);

    if (replace) {
      Viewport viewport = viewportStack.firstElement();
      drawing.set(VIEWPORT_FILL, VIEWPORT_FILL.get(viewport.attributes));
      drawing.set(VIEWPORT_FILL_OPACITY, VIEWPORT_FILL_OPACITY.get(viewport.attributes));
      drawing.set(VIEWPORT_HEIGHT, VIEWPORT_HEIGHT.get(viewport.attributes));
      drawing.set(VIEWPORT_WIDTH, VIEWPORT_WIDTH.get(viewport.attributes));
    }
    // Get rid of all objects we don't need anymore to help garbage collector.
    document.dispose();
    identifiedElements.clear();
    elementObjects.clear();
    viewportStack.clear();
    styleManager.clear();
    document = null;
    identifiedElements = null;
    elementObjects = null;
    viewportStack = null;
    styleManager = null;
###
2644, readInheritColorAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1167, 1190
8
/**
   * Reads a color attribute that is inherited.
   * This is similar to {@code readInheritAttribute}, but takes care of the
   * "currentColor" magic attribute value.
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#Handler",
 --------------
24
  private String readInheritColorAttribute(IXMLElement elem, String attributeName, String defaultValue) {
    String value = null;
    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
      value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
      if (value.equals("inherit")) {
        return readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);
      }
    } else if (elem.hasAttribute(attributeName)) {
      value = elem.getAttribute(attributeName);
      if (value.equals("inherit")) {
        return readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);
      }
    } else if (elem.getParent() != null &&
        (elem.getParent().getNamespace() == null ||
        elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {
      value = readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);
    } else {
      value = defaultValue;
    }
    if (value != null && value.toLowerCase().equals("currentcolor") && !attributeName.equals("color")) {
      // Lets do some magic stuff for "currentColor" attribute value
      value = readInheritColorAttribute(elem, "color", "defaultValue");
    }
    return value;
###
2645, readPolygonElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 808, 820
3
/**
   * Reads an SVG "polygon" element.
   */
11
  private Figure readPolygonElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    Point2D.Double[] points = toPoints(elem, readAttribute(elem, "points", ""));
    Figure figure = factory.createPolygon(points, a);
    elementObjects.put(elem, figure);
    return figure;
###
2646, readRectElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 594, 620
3
/**
   * Reads an SVG "rect" element.
   */
24
  private Figure readRectElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    double x = toNumber(elem, readAttribute(elem, "x", "0"));
    double y = toNumber(elem, readAttribute(elem, "y", "0"));
    double w = toWidth(elem, readAttribute(elem, "width", "0"));
    double h = toHeight(elem, readAttribute(elem, "height", "0"));
    String rxValue = readAttribute(elem, "rx", "none");
    String ryValue = readAttribute(elem, "ry", "none");
    if (rxValue.equals("none")) {
      rxValue = ryValue;
    }
    if (ryValue.equals("none")) {
      ryValue = rxValue;
    }
    double rx = toNumber(elem, rxValue.equals("none") ? "0" : rxValue);
    double ry = toNumber(elem, ryValue.equals("none") ? "0" : ryValue);
    Figure figure = factory.createRect(x, y, w, h, rx, ry, a);
    elementObjects.put(elem, figure);
    return figure;
###
2647, toColor, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3151, 3201
4
/**
   * Reads a color style attribute. This can be a Color or null.
   * FIXME - Doesn't support url(...) colors yet.
   */
50
  private Color toColor(IXMLElement elem, String value) throws IOException {
    String str = value;
    if (str == null) {
      return null;
    }
    str = str.trim().toLowerCase();
    if (str.equals("currentcolor")) {
      String currentColor = readInheritAttribute(elem, "color", "black");
      if (currentColor == null || currentColor.trim().toLowerCase().equals("currentColor")) {
        return null;
      } else {
        return toColor(elem, currentColor);
      }
    } else if (SVG_COLORS.containsKey(str)) {
      return SVG_COLORS.get(str);
    } else if (str.startsWith("#") && str.length() == 7) {
      return new Color(Integer.decode(str));
    } else if (str.startsWith("#") && str.length() == 4) {
      // Three digits hex value
      int th = Integer.decode(str);
      return new Color(
          (th & 0xf) | ((th & 0xf) << 4) |
          ((th & 0xf0) << 4) | ((th & 0xf0) << 8) |
          ((th & 0xf00) << 8) | ((th & 0xf00) << 12));
    } else if (str.startsWith("rgb")) {
      try {
        StringTokenizer tt = new StringTokenizer(str, "() ,");
        tt.nextToken();
        String r = tt.nextToken();
        String g = tt.nextToken();
        String b = tt.nextToken();
        Color c = new Color(
            r.endsWith("%") ? (int) (Integer.decode(r.substring(0, r.length() - 1)) * 2.55) : Integer.decode(r),
            g.endsWith("%") ? (int) (Integer.decode(g.substring(0, g.length() - 1)) * 2.55) : Integer.decode(g),
            b.endsWith("%") ? (int) (Integer.decode(b.substring(0, b.length() - 1)) * 2.55) : Integer.decode(b));
        return c;
      } catch (Exception e) {
        if (DEBUG) {
          System.out.println("SVGInputFormat.toColor illegal RGB value " + str);
        }
        return null;
      }
    } else if (str.startsWith("url")) {
      // FIXME - Implement me
      if (DEBUG) {
        System.out.println("SVGInputFormat.toColor not implemented for " + str);
      }
      return null;
    } else {
      return null;
###
2648, readSolidColorElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1987, 2017
2
/* Reads solid color attributes.
   */
28
  private void readSolidColorElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    // 'solid-color'
    //Value:   currentColor | <color> | inherit
    //Initial:   black
    //Applies to:   'solidColor' elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     Specified <color> value, except inherit
    Color color = toColor(elem, readAttribute(elem, "solid-color", "black"));
    //'solid-opacity'
    //Value:  <opacity-value> | inherit
    //Initial:   1
    //Applies to:   'solidColor' elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     Specified value, except inherit
    double opacity = toDouble(elem, readAttribute(elem, "solid-opacity", "1"), 1, 0, 1);
    if (opacity != 1) {
      color = new Color(((int) (255 * opacity) << 24) | (0xffffff & color.getRGB()), true);
    }
    elementObjects.put(elem, color);
###
2649, readGElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 434, 458
3
/**
   * Reads an SVG "g" element.
   */
24
  private Figure readGElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readOpacityAttribute(elem, a);
    CompositeFigure g = factory.createG(a);
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        Figure childFigure = readElement(child);
        // skip invisible elements
        if (readAttribute(child, "visibility", "visible").equals("visible") &&
            !readAttribute(child, "display", "inline").equals("none")) {
          if (childFigure != null) {
            g.basicAdd(childFigure);
          }
        }
      }
    }
    readTransformAttribute(elem, a);
    if (TRANSFORM.get(a) != null) {
      g.transform(TRANSFORM.get(a));
    }
    return g;
###
2650, readShapeAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2024, 2219
2
/** Reads shape attributes.
   */
183
  private void readShapeAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    Object objectValue;
    String value;
    double doubleValue;
    //'color'
    // Value:    <color> | inherit
    // Initial:     depends on user agent
    // Applies to:    None. Indirectly affects other properties via currentColor
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified <color> value, except inherit
    //
    // value = readInheritAttribute(elem, "color", "black");
    // if (DEBUG) System.out.println("color="+value);
    //'color-rendering'
    // Value:     auto | optimizeSpeed | optimizeQuality | inherit
    // Initial:     auto
    // Applies to:     container elements , graphics elements and 'animateColor'
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    //
    // value = readInheritAttribute(elem, "color-rendering", "auto");
    // if (DEBUG) System.out.println("color-rendering="+value);
    // 'fill'
    // Value:    <paint> | inherit (See Specifying paint)
    // Initial:     black
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     "none", system paint, specified <color> value or absolute IRI
    objectValue = toPaint(elem, readInheritColorAttribute(elem, "fill", "black"));
    if (objectValue instanceof Color) {
      FILL_COLOR.put(a, (Color) objectValue);
    } else if (objectValue instanceof Gradient) {
      FILL_GRADIENT.putClone(a, (Gradient) objectValue);
    } else if (objectValue == null) {
      FILL_COLOR.put(a, null);
    } else {
      FILL_COLOR.put(a, null);
      if (DEBUG) {
        System.out.println("SVGInputFormat not implemented  fill=" + objectValue);
      }
    }
    //'fill-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "fill-opacity", "1");
    FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    // 'fill-rule'
    // Value:   nonzero | evenodd | inherit
    // Initial:    nonzero
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "fill-rule", "nonzero");
    WINDING_RULE.put(a, SVG_FILL_RULES.get(value));
    //'stroke'
    //Value:    <paint> | inherit (See Specifying paint)
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     "none", system paint, specified <color> value
    // or absolute IRI
    objectValue = toPaint(elem, readInheritColorAttribute(elem, "stroke", "none"));
    if (objectValue instanceof Color) {
      STROKE_COLOR.put(a, (Color) objectValue);
    } else if (objectValue instanceof Gradient) {
      STROKE_GRADIENT.putClone(a, (Gradient) objectValue);
    } else if (objectValue == null) {
      STROKE_COLOR.put(a, null);
    } else {
      STROKE_COLOR.put(a, null);
      if (DEBUG) {
        System.out.println("SVGInputFormat not implemented  stroke=" + objectValue);
      }
    }
    //'stroke-dasharray'
    //Value:     none | <dasharray> | inherit
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes (non-additive)
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-dasharray", "none");
    if (!value.equals("none")) {
      String[] values = toWSOrCommaSeparatedArray(value);
      double[] dashes = new double[values.length];
      for (int i = 0; i < values.length; i++) {
        dashes[i] = toNumber(elem, values[i]);
      }
      STROKE_DASHES.put(a, dashes);
    }
    //'stroke-dashoffset'
    //Value:    <length> | inherit
    //Initial:     0
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toNumber(elem, readInheritAttribute(elem, "stroke-dashoffset", "0"));
    STROKE_DASH_PHASE.put(a, doubleValue);
    IS_STROKE_DASH_FACTOR.put(a, false);
    //'stroke-linecap'
    //Value:     butt | round | square | inherit
    //Initial:     butt
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linecap", "butt");
    STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));

    //'stroke-linejoin'
    //Value:     miter | round | bevel | inherit
    //Initial:     miter
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linejoin", "miter");
    STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));
    //'stroke-miterlimit'
    //Value:     <miterlimit> | inherit
    //Initial:     4
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toDouble(elem, readInheritAttribute(elem, "stroke-miterlimit", "4"), 4d, 1d, Double.MAX_VALUE);
    STROKE_MITER_LIMIT.put(a, doubleValue);
    IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);
    //'stroke-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-opacity", "1");
    STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    //'stroke-width'
    //Value:    <length> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toNumber(elem, readInheritAttribute(elem, "stroke-width", "1"));
    STROKE_WIDTH.put(a, doubleValue);
###
2651, toLength, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1285, 1319
4
/**
   * Returns a value as a length.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength
   */
33
  private double toLength(IXMLElement elem, String str, double percentFactor) throws IOException {
    double scaleFactor = 1d;
    if (str == null || str.length() == 0 || str.equals("none")) {
      return 0d;
    }
    if (str.endsWith("%")) {
      str = str.substring(0, str.length() - 1);
      scaleFactor = percentFactor;
    } else if (str.endsWith("px")) {
      str = str.substring(0, str.length() - 2);
    } else if (str.endsWith("pt")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 1.25;
    } else if (str.endsWith("pc")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 15;
    } else if (str.endsWith("mm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 3.543307;
    } else if (str.endsWith("cm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 35.43307;
    } else if (str.endsWith("in")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 90;
    } else if (str.endsWith("em")) {
      str = str.substring(0, str.length() - 2);
      // XXX - This doesn't work
      scaleFactor = toLength(elem, readAttribute(elem, "font-size", "0"), percentFactor);
    } else {
      scaleFactor = 1d;
    }
    return Double.parseDouble(str) * scaleFactor;
###
2652, toWSOrCommaSeparatedArray, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1335, 1340
5
/**
   * Returns a value as a String array.
   * The values are separated by whitespace or by commas with optional white
   * space.
   */
6
  public static String[] toWSOrCommaSeparatedArray(String str) throws IOException {
    String[] result = str.split("(\\s*,\\s*|\\s+)");
    if (result.length == 1 && result[0].equals("")) {
      return new String[0];
    } else {
      return result;
###
2653, readLineAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2439, 2634
2
/** Reads line and polyline attributes.
   */
183
  private void readLineAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    Object objectValue;
    String value;
    double doubleValue;
    //'color'
    // Value:    <color> | inherit
    // Initial:     depends on user agent
    // Applies to:    None. Indirectly affects other properties via currentColor
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified <color> value, except inherit
    //
    // value = readInheritAttribute(elem, "color", "black");
    // if (DEBUG) System.out.println("color="+value);
    //'color-rendering'
    // Value:     auto | optimizeSpeed | optimizeQuality | inherit
    // Initial:     auto
    // Applies to:     container elements , graphics elements and 'animateColor'
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    //
    // value = readInheritAttribute(elem, "color-rendering", "auto");
    // if (DEBUG) System.out.println("color-rendering="+value);
    // 'fill'
    // Value:    <paint> | inherit (See Specifying paint)
    // Initial:     black
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     "none", system paint, specified <color> value or absolute IRI
    objectValue = toPaint(elem, readInheritColorAttribute(elem, "fill", "none"));
    if (objectValue instanceof Color) {
      FILL_COLOR.put(a, (Color) objectValue);
    } else if (objectValue instanceof Gradient) {
      FILL_GRADIENT.putClone(a, (Gradient) objectValue);
    } else if (objectValue == null) {
      FILL_COLOR.put(a, null);
    } else {
      FILL_COLOR.put(a, null);
      if (DEBUG) {
        System.out.println("SVGInputFormat not implemented  fill=" + objectValue);
      }
    }
    //'fill-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "fill-opacity", "1");
    FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    // 'fill-rule'
    // Value:   nonzero | evenodd | inherit
    // Initial:    nonzero
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "fill-rule", "nonzero");
    WINDING_RULE.put(a, SVG_FILL_RULES.get(value));
    //'stroke'
    //Value:    <paint> | inherit (See Specifying paint)
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     "none", system paint, specified <color> value
    // or absolute IRI
    objectValue = toPaint(elem, readInheritColorAttribute(elem, "stroke", "black"));
    if (objectValue instanceof Color) {
      STROKE_COLOR.put(a, (Color) objectValue);
    } else if (objectValue instanceof Gradient) {
      STROKE_GRADIENT.putClone(a, (Gradient) objectValue);
    } else if (objectValue == null) {
      STROKE_COLOR.put(a, null);
    } else {
      STROKE_COLOR.put(a, null);
      if (DEBUG) {
        System.out.println("SVGInputFormat not implemented  stroke=" + objectValue);
      }
    }
    //'stroke-dasharray'
    //Value:     none | <dasharray> | inherit
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes (non-additive)
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-dasharray", "none");
    if (!value.equals("none")) {
      String[] values = toWSOrCommaSeparatedArray(value);
      double[] dashes = new double[values.length];
      for (int i = 0; i < values.length; i++) {
        dashes[i] = toNumber(elem, values[i]);
      }
      STROKE_DASHES.put(a, dashes);
    }
    //'stroke-dashoffset'
    //Value:    <length> | inherit
    //Initial:     0
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toNumber(elem, readInheritAttribute(elem, "stroke-dashoffset", "0"));
    STROKE_DASH_PHASE.put(a, doubleValue);
    IS_STROKE_DASH_FACTOR.put(a, false);
    //'stroke-linecap'
    //Value:     butt | round | square | inherit
    //Initial:     butt
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linecap", "butt");
    STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));

    //'stroke-linejoin'
    //Value:     miter | round | bevel | inherit
    //Initial:     miter
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linejoin", "miter");
    STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));
    //'stroke-miterlimit'
    //Value:     <miterlimit> | inherit
    //Initial:     4
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toDouble(elem, readInheritAttribute(elem, "stroke-miterlimit", "4"), 4d, 1d, Double.MAX_VALUE);
    STROKE_MITER_LIMIT.put(a, doubleValue);
    IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);
    //'stroke-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-opacity", "1");
    STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    //'stroke-width'
    //Value:    <length> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toNumber(elem, readInheritAttribute(elem, "stroke-width", "1"));
    STROKE_WIDTH.put(a, doubleValue);
###
2654, readLinearGradientElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2805, 2883
3
/**
   * Reads an SVG "linearGradient" element.
   */
71
  private void readLinearGradientElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    double x1 = toLength(elem, readAttribute(elem, "x1", "0"), 0.01);
    double y1 = toLength(elem, readAttribute(elem, "y1", "0"), 0.01);
    double x2 = toLength(elem, readAttribute(elem, "x2", "1"), 0.01);
    double y2 = toLength(elem, readAttribute(elem, "y2", "0"), 0.01);
    boolean isRelativeToFigureBounds = readAttribute(elem, "gradientUnits", "objectBoundingBox").equals("objectBoundingBox");
    ArrayList<IXMLElement> stops = elem.getChildrenNamed("stop", SVG_NAMESPACE);
    if (stops.size() == 0) {
      stops = elem.getChildrenNamed("stop");
    }
    if (stops.size() == 0) {
      // FIXME - Implement xlink support throughouth SVGInputFormat
      String xlink = readAttribute(elem, "xlink:href", "");
      if (xlink.startsWith("#") &&
          identifiedElements.get(xlink.substring(1)) != null) {
        stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed("stop", SVG_NAMESPACE);
        if (stops.size() == 0) {
          stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed("stop");
        }
      }
    }
    if (stops.size() == 0) {
      if (DEBUG) {
        System.out.println("SVGInpuFormat: Warning no stops in linearGradient " + elem);
      }
    }
    double[] stopOffsets = new double[stops.size()];
    Color[] stopColors = new Color[stops.size()];
    double[] stopOpacities = new double[stops.size()];
    for (int i = 0; i < stops.size(); i++) {
      IXMLElement stopElem = stops.get(i);
      String offsetStr = readAttribute(stopElem, "offset", "0");
      if (offsetStr.endsWith("%")) {
        stopOffsets[i] = toDouble(stopElem, offsetStr.substring(0, offsetStr.length() - 1), 0, 0, 100) / 100d;
      } else {
        stopOffsets[i] = toDouble(stopElem, offsetStr, 0, 0, 1);
      }
      // 'stop-color'
      // Value:    currentColor | <color> | inherit
      // Initial:    black
      // Applies to:     'stop' elements
      // Inherited:    no
      // Percentages:    N/A
      // Media:    visual
      // Animatable:    yes
      // Computed value:     Specified <color> value, except i
      stopColors[i] = toColor(stopElem, readAttribute(stopElem, "stop-color", "black"));
      if (stopColors[i] == null) {
        stopColors[i] = new Color(0x0, true);
        //throw new IOException("stop color missing in "+stopElem);
      }
      //'stop-opacity'
      //Value:    <opacity-value> | inherit
      //Initial:    1
      //Applies to:     'stop' elements
      //Inherited:    no
      //Percentages:    N/A
      //Media:    visual
      //Animatable:    yes
      //Computed value:     Specified value, except inherit
      stopOpacities[i] = toDouble(stopElem, readAttribute(stopElem, "stop-opacity", "1"), 1, 0, 1);
    }
    AffineTransform tx = toTransform(elem, readAttribute(elem, "gradientTransform", "none"));
    Gradient gradient = factory.createLinearGradient(
        x1, y1, x2, y2,
        stopOffsets, stopColors, stopOpacities,
        isRelativeToFigureBounds, tx);
    elementObjects.put(elem, gradient);
###
2655, toDouble, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3208, 3209
3
/**
   * Reads a double attribute.
   */
2
  private double toDouble(IXMLElement elem, String value) throws IOException {
    return toDouble(elem, value, 0, Double.MIN_VALUE, Double.MAX_VALUE);
###
2656, readElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 336, 415
5
/**
   * Reads an SVG element of any kind.
   * @return Returns the Figure, if the SVG element represents a Figure.
   * Returns null in all other cases.
   */
79
  private Figure readElement(IXMLElement elem)
      throws IOException {
    if (DEBUG) {
      System.out.println("SVGInputFormat.readElement " + elem.getName() + " line:" + elem.getLineNr());
    }
    Figure f = null;
    if (elem.getNamespace() == null ||
        elem.getNamespace().equals(SVG_NAMESPACE)) {
      String name = elem.getName();
      if (name == null) {
        if (DEBUG) {
          System.err.println("SVGInputFormat warning: skipping nameless element at line " + elem.getLineNr());
        }
      } else if (name.equals("a")) {
        f = readAElement(elem);
      } else if (name.equals("circle")) {
        f = readCircleElement(elem);
      } else if (name.equals("defs")) {
        readDefsElement(elem);
        f = null;
      } else if (name.equals("ellipse")) {
        f = readEllipseElement(elem);
      } else if (name.equals("g")) {
        f = readGElement(elem);
      } else if (name.equals("image")) {
        f = readImageElement(elem);
      } else if (name.equals("line")) {
        f = readLineElement(elem);
      } else if (name.equals("linearGradient")) {
        readLinearGradientElement(elem);
        f = null;
      } else if (name.equals("path")) {
        f = readPathElement(elem);
      } else if (name.equals("polygon")) {
        f = readPolygonElement(elem);
      } else if (name.equals("polyline")) {
        f = readPolylineElement(elem);
      } else if (name.equals("radialGradient")) {
        readRadialGradientElement(elem);
        f = null;
      } else if (name.equals("rect")) {
        f = readRectElement(elem);
      } else if (name.equals("solidColor")) {
        readSolidColorElement(elem);
        f = null;
      } else if (name.equals("svg")) {
        f = readSVGElement(elem);
        //f = readGElement(elem);
      } else if (name.equals("switch")) {
        f = readSwitchElement(elem);
      } else if (name.equals("text")) {
        f = readTextElement(elem);
      } else if (name.equals("textArea")) {
        f = readTextAreaElement(elem);
      } else if (name.equals("title")) {
        //FIXME - Implement reading of title element
        //f = readTitleElement(elem);
      } else if (name.equals("use")) {
        f = readUseElement(elem);
      } else if (name.equals("style")) {
        // Nothing to do, style elements have been already
        // processed in method flattenStyles
      } else {
        if (DEBUG) {
          System.out.println("SVGInputFormat not implemented for <" + name + ">");
        }
      }
    }
    if (f instanceof SVGFigure) {
      if (((SVGFigure) f).isEmpty()) {
        // if (DEBUG) System.out.println("Empty figure "+f);
        return null;
      }
    } else if (f != null) {
      if (DEBUG) {
        System.out.println("SVGInputFormat warning: not an SVGFigure " + f);
      }
    }
    return f;
###
2657, toPaint, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3085, 3143
4
/**
   * Reads a paint style attribute. This can be a Color or a Gradient or null.
   * XXX - Doesn't support url(...) colors yet.
   */
57
  private Object toPaint(IXMLElement elem, String value) throws IOException {
    String str = value;
    if (str == null) {
      return null;
    }
    str = str.trim().toLowerCase();
    if (str.equals("none")) {
      return null;
    } else if (str.equals("currentcolor")) {
      String currentColor = readInheritAttribute(elem, "color", "black");
      if (currentColor == null || currentColor.trim().toLowerCase().equals("currentColor")) {
        return null;
      } else {
        return toPaint(elem, currentColor);
      }
    } else if (SVG_COLORS.containsKey(str)) {
      return SVG_COLORS.get(str);
    } else if (str.startsWith("#") && str.length() == 7) {
      return new Color(Integer.decode(str));
    } else if (str.startsWith("#") && str.length() == 4) {
      // Three digits hex value
      int th = Integer.decode(str);
      return new Color(
          (th & 0xf) | ((th & 0xf) << 4) |
          ((th & 0xf0) << 4) | ((th & 0xf0) << 8) |
          ((th & 0xf00) << 8) | ((th & 0xf00) << 12));
    } else if (str.startsWith("rgb")) {
      try {
        StringTokenizer tt = new StringTokenizer(str, "() ,");
        tt.nextToken();
        String r = tt.nextToken();
        String g = tt.nextToken();
        String b = tt.nextToken();
        Color c = new Color(
            r.endsWith("%") ? (int) (Double.parseDouble(r.substring(0, r.length() - 1)) * 2.55) : Integer.decode(r),
            g.endsWith("%") ? (int) (Double.parseDouble(g.substring(0, g.length() - 1)) * 2.55) : Integer.decode(g),
            b.endsWith("%") ? (int) (Double.parseDouble(b.substring(0, b.length() - 1)) * 2.55) : Integer.decode(b));
        return c;
      } catch (Exception e) {
        /*if (DEBUG)*/ System.out.println("SVGInputFormat.toPaint illegal RGB value " + str);
        e.printStackTrace();
        return null;
      }
    } else if (str.startsWith("url(")) {
      String href = value.substring(4, value.length() - 1);
      if (identifiedElements.containsKey(href.substring(1)) &&
          elementObjects.containsKey(identifiedElements.get(href.substring(1)))) {
        Object obj = elementObjects.get(identifiedElements.get(href.substring(1)));
        return obj;
      }
      // XXX - Implement me
      if (DEBUG) {
        System.out.println("SVGInputFormat.toPaint not implemented for " + href);
      }
      return null;
    } else {
      return null;
###
2658, readLineElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 757, 784
3
/**
   * Reads an SVG "line" element.
   */
25
  private Figure readLineElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readLineAttributes(elem, a);
    // Because 'line' elements are single lines and thus are geometrically
    // one-dimensional, they have no interior; thus, 'line' elements are
    // never filled (see the 'fill' property).
    if (FILL_COLOR.get(a) != null && STROKE_COLOR.get(a) == null) {
      STROKE_COLOR.put(a, FILL_COLOR.get(a));
    }
    if (FILL_GRADIENT.get(a) != null && STROKE_GRADIENT.get(a) == null) {
      STROKE_GRADIENT.put(a, FILL_GRADIENT.get(a));
    }
    FILL_COLOR.put(a, null);
    FILL_GRADIENT.put(a, null);
    double x1 = toNumber(elem, readAttribute(elem, "x1", "0"));
    double y1 = toNumber(elem, readAttribute(elem, "y1", "0"));
    double x2 = toNumber(elem, readAttribute(elem, "x2", "0"));
    double y2 = toNumber(elem, readAttribute(elem, "y2", "0"));
    Figure figure = factory.createLine(x1, y1, x2, y2, a);
    elementObjects.put(elem, figure);
    return figure;
###
2659, readTextElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 844, 912
3
/**
   * Reads an SVG "text" element.
   */
64
  private Figure readTextElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    readFontAttributes(elem, a);
    readTextAttributes(elem, a);
    String[] xStr = toCommaSeparatedArray(readAttribute(elem, "x", "0"));
    String[] yStr = toCommaSeparatedArray(readAttribute(elem, "y", "0"));
    Point2D.Double[] coordinates = new Point2D.Double[Math.max(xStr.length, yStr.length)];
    double lastX = 0;
    double lastY = 0;
    for (int i = 0; i < coordinates.length; i++) {
      if (xStr.length > i) {
        try {
          lastX = toNumber(elem, xStr[i]);
        } catch (NumberFormatException ex) {
        }
      }
      if (yStr.length > i) {
        try {
          lastY = toNumber(elem, yStr[i]);
        } catch (NumberFormatException ex) {
        }
      }
      coordinates[i] = new Point2D.Double(lastX, lastY);
    }

    String[] rotateStr = toCommaSeparatedArray(readAttribute(elem, "rotate", ""));
    double[] rotate = new double[rotateStr.length];
    for (int i = 0; i < rotateStr.length; i++) {
      try {
        rotate[i] = toDouble(elem, rotateStr[i]);
      } catch (NumberFormatException ex) {
        rotate[i] = 0;
      }
    }
    DefaultStyledDocument doc = new DefaultStyledDocument();
    try {
      if (elem.getContent() != null) {
        doc.insertString(0, toText(elem, elem.getContent()), null);
      } else {
        for (IXMLElement node : elem.getChildren()) {
          if (node.getName() == null) {
            doc.insertString(0, toText(elem, node.getContent()), null);
          } else if (node.getName().equals("tspan")) {
            readTSpanElement((IXMLElement) node, doc);
          } else {
            if (DEBUG) {
              System.out.println("SVGInputFormat unsupported text node <" + node.getName() + ">");
            }
          }
        }
      }
    } catch (BadLocationException e) {
      InternalError ex = new InternalError(e.getMessage());
      ex.initCause(e);
      throw ex;
    }
    Figure figure = factory.createText(coordinates, rotate, doc, a);
    elementObjects.put(elem, figure);
    return figure;
###
2660, readGraphicsAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2689, 2798
3
/* Reads graphics attributes as listed in
   * http://www.w3.org/TR/SVGMobile12/feature.html#GraphicsAttribute
   */
104
  private void readGraphicsAttributes(IXMLElement elem, Figure f)
      throws IOException {
    Object value;
    // 'display'
    // Value:     inline | block | list-item |
    // run-in | compact | marker |
    // table | inline-table | table-row-group | table-header-group |
    // table-footer-group | table-row | table-column-group | table-column |
    // table-cell | table-caption | none | inherit
    // Initial:     inline
    // Applies to:     'svg' , 'g' , 'switch' , 'a' , 'foreignObject' ,
    // graphics elements (including the text content block elements) and text
    // sub-elements (for example, 'tspan' and 'a' )
    // Inherited:     no
    // Percentages:     N/A
    // Media:     all
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    value = readAttribute(elem, "display", "inline");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented display=" + value);
    }

    //'image-rendering'
    //Value:     auto | optimizeSpeed | optimizeQuality | inherit
    //Initial:     auto
    //Applies to:     images
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "image-rendering", "auto");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented image-rendering=" + value);
    }
    //'pointer-events'
    //Value:    boundingBox | visiblePainted | visibleFill | visibleStroke | visible |
    //painted | fill | stroke | all | none | inherit
    //Initial:    visiblePainted
    //Applies to:    graphics elements
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:    Specified value, except inherit
    value = readInheritAttribute(elem, "pointer-events", "visiblePainted");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented pointer-events=" + value);
    }
    // 'shape-rendering'
    //Value:     auto | optimizeSpeed | crispEdges |
    //geometricPrecision | inherit
    //Initial:     auto
    //Applies to:     shapes
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "shape-rendering", "auto");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented shape-rendering=" + value);
    }
    //'text-rendering'
    //Value:     auto | optimizeSpeed | optimizeLegibility |
    //geometricPrecision | inherit
    //Initial:     auto
    //Applies to:    text content block elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "text-rendering", "auto");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented text-rendering=" + value);
    }
    //'vector-effect'
    //Value:     non-scaling-stroke | none | inherit
    //Initial:     none
    //Applies to:     graphics elements
    //Inherited:     no
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readAttribute(elem, "vector-effect", "none");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented vector-effect=" + value);
    }
    //'visibility'
    //Value:     visible | hidden | collapse | inherit
    //Initial:     visible
    //Applies to:     graphics elements (including the text content block
    // elements) and text sub-elements (for example, 'tspan' and 'a' )
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "visibility", null);
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented visibility=" + value);
###
2661, readRadialGradientElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2889, 2962
3
/**
   * Reads an SVG "radialGradient" element.
   */
69
  private void readRadialGradientElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    double cx = toLength(elem, readAttribute(elem, "cx", "0.5"), 0.01);
    double cy = toLength(elem, readAttribute(elem, "cy", "0.5"), 0.01);
    double fx = toLength(elem, readAttribute(elem, "fx", readAttribute(elem, "cx", "0.5")), 0.01);
    double fy = toLength(elem, readAttribute(elem, "fy", readAttribute(elem, "cy", "0.5")), 0.01);
    double r = toLength(elem, readAttribute(elem, "r", "0.5"), 0.01);
    boolean isRelativeToFigureBounds =
        readAttribute(elem, "gradientUnits", "objectBoundingBox").equals("objectBoundingBox");
    ArrayList<IXMLElement> stops = elem.getChildrenNamed("stop", SVG_NAMESPACE);
    if (stops.size() == 0) {
      stops = elem.getChildrenNamed("stop");
    }
    if (stops.size() == 0) {
      // FIXME - Implement xlink support throughout SVGInputFormat
      String xlink = readAttribute(elem, "xlink:href", "");
      if (xlink.startsWith("#") &&
          identifiedElements.get(xlink.substring(1)) != null) {
        stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed("stop", SVG_NAMESPACE);
        if (stops.size() == 0) {
          stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed("stop");
        }
      }
    }
    double[] stopOffsets = new double[stops.size()];
    Color[] stopColors = new Color[stops.size()];
    double[] stopOpacities = new double[stops.size()];
    for (int i = 0; i < stops.size(); i++) {
      IXMLElement stopElem = stops.get(i);
      String offsetStr = readAttribute(stopElem, "offset", "0");
      if (offsetStr.endsWith("%")) {
        stopOffsets[i] = toDouble(stopElem, offsetStr.substring(0, offsetStr.length() - 1), 0, 0, 100) / 100d;
      } else {
        stopOffsets[i] = toDouble(stopElem, offsetStr, 0, 0, 1);
      }
      // 'stop-color'
      // Value:    currentColor | <color> | inherit
      // Initial:    black
      // Applies to:     'stop' elements
      // Inherited:    no
      // Percentages:    N/A
      // Media:    visual
      // Animatable:    yes
      // Computed value:     Specified <color> value, except i
      stopColors[i] = toColor(stopElem, readAttribute(stopElem, "stop-color", "black"));
      if (stopColors[i] == null) {
        stopColors[i] = new Color(0x0, true);
        //throw new IOException("stop color missing in "+stopElem);
      }
      //'stop-opacity'
      //Value:    <opacity-value> | inherit
      //Initial:    1
      //Applies to:     'stop' elements
      //Inherited:    no
      //Percentages:    N/A
      //Media:    visual
      //Animatable:    yes
      //Computed value:     Specified value, except inherit
      stopOpacities[i] = toDouble(stopElem, readAttribute(stopElem, "stop-opacity", "1"), 1, 0, 1);
    }
    AffineTransform tx = toTransform(elem, readAttribute(elem, "gradientTransform", "none"));
    Gradient gradient = factory.createRadialGradient(
        cx, cy, fx, fy, r,
        stopOffsets, stopColors, stopOpacities,
        isRelativeToFigureBounds,
        tx);
    elementObjects.put(elem, gradient);
###
2662, readTextAreaElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 918, 963
3
/**
   * Reads an SVG "textArea" element.
   */
42
  private Figure readTextAreaElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    readFontAttributes(elem, a);
    readTextAttributes(elem, a);
    readTextFlowAttributes(elem, a);
    double x = toNumber(elem, readAttribute(elem, "x", "0"));
    double y = toNumber(elem, readAttribute(elem, "y", "0"));
// XXX - Handle "auto" width and height
    double w = toWidth(elem, readAttribute(elem, "width", "0"));
    double h = toHeight(elem, readAttribute(elem, "height", "0"));
    DefaultStyledDocument doc = new DefaultStyledDocument();
    try {
      if (elem.getContent() != null) {
        doc.insertString(0, toText(elem, elem.getContent()), null);
      } else {
        for (IXMLElement node : elem.getChildren()) {
          if (node.getName() == null) {
            doc.insertString(doc.getLength(), toText(elem, node.getContent()), null);
          } else if (node.getName().equals("tbreak")) {
            doc.insertString(doc.getLength(), "\n", null);
          } else if (node.getName().equals("tspan")) {
            readTSpanElement((IXMLElement) node, doc);
          } else {
            if (DEBUG) {
              System.out.println("SVGInputFormat unknown  text node " + node.getName());
            }
          }
        }
      }
    } catch (BadLocationException e) {
      InternalError ex = new InternalError(e.getMessage());
      ex.initCause(e);
      throw ex;
    }
    Figure figure = factory.createTextArea(x, y, w, h, doc, a);
    elementObjects.put(elem, figure);
    return figure;
###
2663, readSwitchElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1041, 1089
7
/**
   * Evaluates an SVG "switch" element.
   *
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#XlinkAttribute",
 --------------
46
  private Figure readSwitchElement(IXMLElement elem)
      throws IOException {
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        String[] requiredFeatures = toWSOrCommaSeparatedArray(readAttribute(child, "requiredFeatures", ""));
        String[] requiredExtensions = toWSOrCommaSeparatedArray(readAttribute(child, "requiredExtensions", ""));
        String[] systemLanguage = toWSOrCommaSeparatedArray(readAttribute(child, "systemLanguage", ""));
        String[] requiredFormats = toWSOrCommaSeparatedArray(readAttribute(child, "requiredFormats", ""));
        String[] requiredFonts = toWSOrCommaSeparatedArray(readAttribute(child, "requiredFonts", ""));
        boolean isMatch;
        isMatch = supportedFeatures.containsAll(Arrays.asList(requiredFeatures)) &&
            requiredExtensions.length == 0 &&
            requiredFormats.length == 0 &&
            requiredFonts.length == 0;
        if (isMatch && systemLanguage.length > 0) {
          isMatch = false;
          Locale locale = LocaleUtil.getDefault();
          for (String lng : systemLanguage) {
            int p = lng.indexOf('-');
            if (p == -1) {
              if (locale.getLanguage().equals(lng)) {
                isMatch = true;
                break;
              }
            } else {
              if (locale.getLanguage().equals(lng.substring(0, p)) &&
                  locale.getCountry().toLowerCase().equals(lng.substring(p + 1))) {
                isMatch = true;
                break;
              }
            }
          }
        }
        if (isMatch) {
          Figure figure = readElement(child);
          if (readAttribute(child, "visibility", "visible").equals("visible") &&
              !readAttribute(child, "display", "inline").equals("none")) {
            return figure;
          } else {
            return null;
          }
        }
      }
    }
    return null;
###
2664, readImageElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 667, 751
3
/**
   * Reads an SVG "image" element.
   */
80
  private Figure readImageElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    double x = toNumber(elem, readAttribute(elem, "x", "0"));
    double y = toNumber(elem, readAttribute(elem, "y", "0"));
    double w = toWidth(elem, readAttribute(elem, "width", "0"));
    double h = toHeight(elem, readAttribute(elem, "height", "0"));
    String href = readAttribute(elem, "xlink:href", null);
    if (href == null) {
      href = readAttribute(elem, "href", null);
    }
    byte[] imageData = null;
    if (href != null) {
      if (href.startsWith("data:")) {
        int semicolonPos = href.indexOf(';');
        if (semicolonPos != -1) {
          if (href.indexOf(";base64,") == semicolonPos) {
            imageData = Base64.decode(href.substring(semicolonPos + 8));
          } else {
            throw new IOException("Unsupported encoding in data href in image element:" + href);
          }
        } else {
          throw new IOException("Unsupported data href in image element:" + href);
        }
      } else {
        URL imageUrl = new URL(url, href);
        // Check whether the imageURL is an SVG image.
        // Load it as a group.
        if (imageUrl.getFile().endsWith("svg")) {
          SVGInputFormat svgImage = new SVGInputFormat(factory);
          Drawing svgDrawing = new DefaultDrawing();
          svgImage.read(imageUrl, svgDrawing, true);
          CompositeFigure svgImageGroup = factory.createG(a);
          for (Figure f : svgDrawing.getChildren()) {
            svgImageGroup.add(f);
          }
          svgImageGroup.setBounds(new Point2D.Double(x, y), new Point2D.Double(x + w, y + h));
          return svgImageGroup;
        }
        // Read the image data from the URL into a byte array
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        byte[] buf = new byte[512];
        int len = 0;
        try {
          InputStream in = imageUrl.openStream();
          try {
            while ((len = in.read(buf)) > 0) {
              bout.write(buf, 0, len);
            }
            imageData = bout.toByteArray();
          } finally {
            in.close();
          }
        } catch (FileNotFoundException e) {
          // Use empty image
        }
      }
    }
    // Create a buffered image from the image data
    BufferedImage bufferedImage = null;
    if (imageData != null) {
      try {
        bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));
      } catch (IIOException e) {
        System.err.println("SVGInputFormat warning: skipped unsupported image format.");
        e.printStackTrace();
      }
    }
    // Delete the image data in case of failure
    if (bufferedImage == null) {
      imageData = null;
      //if (DEBUG) System.out.println("FAILED:"+imageUrl);
    }
    // Create a figure from the image data and the buffered image.
    Figure figure = factory.createImage(x, y, w, h, imageData, bufferedImage, a);
    elementObjects.put(elem, figure);
    return figure;
###
2666, write, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 1311, 1338
3
/**
   * All other write methods delegate their work to here.
   */
22
  public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures) throws IOException {
    document = new XMLElement("svg", SVG_NAMESPACE);
    document.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
    document.setAttribute("version", "1.2");
    document.setAttribute("baseProfile", "tiny");
    writeViewportAttributes(document, drawing.getAttributes());
    initStorageContext(document);
    defs = new XMLElement("defs");
    document.addChild(defs);
    for (Figure f : figures) {
      writeElement(document, f);
    }
    // Write XML prolog
    PrintWriter writer = new PrintWriter(
        new OutputStreamWriter(out, "UTF-8"));
    writer.println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
    // Write XML content
    XMLWriter xmlWriter = new XMLWriter(writer);
    xmlWriter.write(document, isPrettyPrint);
    // Flush writer
    writer.flush();
    document.dispose();
###
2667, toNumber, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 1169, 1174
3
/**
   * Returns a double array as a number attribute value.
   */
6
  public static String toNumber(double number) {
    String str = (isFloatPrecision) ? Float.toString((float) number) : Double.toString(number);
    if (str.endsWith(".0")) {
      str = str.substring(0, str.length() - 2);
    }
    return str;
###
2668, writeTransformAttribute, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 846, 850
4
/* Writes the transform attribute as specified in
   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute
   *
   */
5
  protected void writeTransformAttribute(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    AffineTransform t = TRANSFORM.get(a);
    if (t != null) {
      writeAttribute(elem, "transform", toTransform(t), "none");
###
2669, writeFontAttributes, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 857, 934
3
/* Writes font attributes as listed in
   * http://www.w3.org/TR/SVGMobile12/feature.html#Font
   */
72
  private void writeFontAttributes(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    String value;
    double doubleValue;
    // 'font-family'
    // Value:    [[ <family-name> |
    // <generic-family> ],]* [<family-name> |
    // <generic-family>] | inherit
    // Initial:    depends on user agent
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Specified value, except inherit
    writeAttribute(elem, "font-family", FONT_FACE.get(a).getFontName(), "Dialog");
    // 'font-getChildCount'
    // Value:    <absolute-getChildCount> | <relative-getChildCount> |
    // <length> | inherit
    // Initial:    medium
    // Applies to:    text content elements
    // Inherited:    yes, the computed value is inherited
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Absolute length
    writeAttribute(elem, "font-size", FONT_SIZE.get(a), 0d);
    // 'font-style'
    // Value:    normal | italic | oblique | inherit
    // Initial:    normal
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Specified value, except inherit
    writeAttribute(elem, "font-style", (FONT_ITALIC.get(a)) ? "italic" : "normal", "normal");

    //'font-variant'
    //Value:    normal | small-caps | inherit
    //Initial:    normal
    //Applies to:    text content elements
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    no
    //Computed value:     Specified value, except inherit
    // XXX - Implement me
    writeAttribute(elem, "font-variant", "normal", "normal");
    // 'font-weight'
    // Value:    normal | bold | bolder | lighter | 100 | 200 | 300
    // | 400 | 500 | 600 | 700 | 800 | 900 | inherit
    // Initial:    normal
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     one of the legal numeric values, non-numeric
    // values shall be converted to numeric values according to the rules
    // defined below.
    writeAttribute(elem, "font-weight", (FONT_BOLD.get(a)) ? "bold" : "normal", "normal");
    // Note: text-decoration is an SVG 1.1 feature
    //'text-decoration'
    //Value:    none | [ underline || overline || line-through || blink ] | inherit
    //Initial:    none
    //Applies to:    text content elements
    //Inherited:    no (see prose)
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    writeAttribute(elem, "text-decoration", (FONT_UNDERLINE.get(a)) ? "underline" : "none", "none");
###
2671, writeOpacityAttribute, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 823, 839
2
/* Writes the opacity attribute.
   */
17
  protected void writeOpacityAttribute(IXMLElement elem, Map<AttributeKey, Object> m)
      throws IOException {
    //'opacity'
    //Value:    <opacity-value> | inherit
    //Initial:    1
    //Applies to:     'image' element
    //Inherited:    no
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:     Specified value, except inherit
    //<opacity-value>
    //The uniform opacity setting must be applied across an entire object.
    //Any values outside the range 0.0 (fully transparent) to 1.0
    //(fully opaque) shall be clamped to this range.
    //(See Clamping values which are restricted to a particular range.)
    writeAttribute(elem, "opacity", OPACITY.get(m), 1d);
###
2672, writeShapeAttributes, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 581, 818
2
/* Writes shape attributes.
   */
225
  protected void writeShapeAttributes(IXMLElement elem, Map<AttributeKey, Object> m)
      throws IOException {
    Color color;
    String value;
    int intValue;
    //'color'
    // Value:    <color> | inherit
    // Initial:     depends on user agent
    // Applies to:    None. Indirectly affects other properties via currentColor
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified <color> value, except inherit
    //
    // Nothing to do: Attribute 'color' is not needed.
    //'color-rendering'
    // Value:     auto | optimizeSpeed | optimizeQuality | inherit
    // Initial:     auto
    // Applies to:     container elements , graphics elements and 'animateColor'
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    //
    // Nothing to do: Attribute 'color-rendering' is not needed.
    // 'fill'
    // Value:    <paint> | inherit (See Specifying paint)
    // Initial:     black
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     "none", system paint, specified <color> value or absolute IRI
    Gradient gradient = FILL_GRADIENT.get(m);
    if (gradient != null) {
      String id;
      if (gradientToIDMap.containsKey(gradient)) {
        id = gradientToIDMap.get(gradient);
      } else {
        IXMLElement gradientElem;
        if (gradient instanceof LinearGradient) {
          LinearGradient lg = (LinearGradient) gradient;
          gradientElem = createLinearGradient(document,
              lg.getX1(), lg.getY1(),
              lg.getX2(), lg.getY2(),
              lg.getStopOffsets(),
              lg.getStopColors(),
              lg.getStopOpacities(),
              lg.isRelativeToFigureBounds(),
              lg.getTransform());
        } else /*if (gradient instanceof RadialGradient)*/ {
          RadialGradient rg = (RadialGradient) gradient;
          gradientElem = createRadialGradient(document,
              rg.getCX(), rg.getCY(),
              rg.getFX(), rg.getFY(),
              rg.getR(),
              rg.getStopOffsets(),
              rg.getStopColors(),
              rg.getStopOpacities(),
              rg.isRelativeToFigureBounds(),
              rg.getTransform());
        }
        id = getId(gradientElem);
        gradientElem.setAttribute("id", "xml", id);
        defs.addChild(gradientElem);
        gradientToIDMap.put(gradient, id);
      }
      writeAttribute(elem, "fill", "url(#" + id + ")", "#000");
    } else {
      writeAttribute(elem, "fill", toColor(FILL_COLOR.get(m)), "#000");
    }

    //'fill-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "fill-opacity", FILL_OPACITY.get(m), 1d);
    // 'fill-rule'
    // Value:   nonzero | evenodd | inherit
    // Initial:    nonzero
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    if (WINDING_RULE.get(m) != WindingRule.NON_ZERO) {
      writeAttribute(elem, "fill-rule", "evenodd", "nonzero");
    }
    //'stroke'
    //Value:    <paint> | inherit (See Specifying paint)
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     "none", system paint, specified <color> value
    // or absolute IRI
    gradient = STROKE_GRADIENT.get(m);
    if (gradient != null) {
      String id;
      if (gradientToIDMap.containsKey(gradient)) {
        id = gradientToIDMap.get(gradient);
      } else {
        IXMLElement gradientElem;
        if (gradient instanceof LinearGradient) {
          LinearGradient lg = (LinearGradient) gradient;
          gradientElem = createLinearGradient(document,
              lg.getX1(), lg.getY1(),
              lg.getX2(), lg.getY2(),
              lg.getStopOffsets(),
              lg.getStopColors(),
              lg.getStopOpacities(),
              lg.isRelativeToFigureBounds(),
              lg.getTransform());
        } else /*if (gradient instanceof RadialGradient)*/ {
          RadialGradient rg = (RadialGradient) gradient;
          gradientElem = createRadialGradient(document,
              rg.getCX(), rg.getCY(),
              rg.getFX(), rg.getFY(),
              rg.getR(),
              rg.getStopOffsets(),
              rg.getStopColors(),
              rg.getStopOpacities(),
              rg.isRelativeToFigureBounds(),
              rg.getTransform());
        }
        id = getId(gradientElem);
        gradientElem.setAttribute("id", "xml", id);
        defs.addChild(gradientElem);
        gradientToIDMap.put(gradient, id);
      }
      writeAttribute(elem, "stroke", "url(#" + id + ")", "none");
    } else {
      writeAttribute(elem, "stroke", toColor(STROKE_COLOR.get(m)), "none");
    }
    //'stroke-dasharray'
    //Value:     none | <dasharray> | inherit
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes (non-additive)
    //Computed value:     Specified value, except inherit
    double[] dashes = STROKE_DASHES.get(m);
    if (dashes != null) {
      StringBuilder buf = new StringBuilder();
      for (int i = 0; i < dashes.length; i++) {
        if (i != 0) {
          buf.append(',');
        }
        buf.append(toNumber(dashes[i]));
      }
      writeAttribute(elem, "stroke-dasharray", buf.toString(), null);
    }
    //'stroke-dashoffset'
    //Value:    <length> | inherit
    //Initial:     0
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-dashoffset", STROKE_DASH_PHASE.get(m), 0d);
    //'stroke-linecap'
    //Value:     butt | round | square | inherit
    //Initial:     butt
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-linecap", strokeLinecapMap.get(STROKE_CAP.get(m)), "butt");
    //'stroke-linejoin'
    //Value:     miter | round | bevel | inherit
    //Initial:     miter
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-linejoin", strokeLinejoinMap.get(STROKE_JOIN.get(m)), "miter");
    //'stroke-miterlimit'
    //Value:     <miterlimit> | inherit
    //Initial:     4
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-miterlimit", STROKE_MITER_LIMIT.get(m), 4d);
    //'stroke-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-opacity", STROKE_OPACITY.get(m), 1d);
    //'stroke-width'
    //Value:    <length> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-width", STROKE_WIDTH.get(m), 1d);
###
2673, writeViewportAttributes, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 939, 970
2
/* Writes viewport attributes.
   */
30
  private void writeViewportAttributes(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    Object value;
    Double doubleValue;
    if (VIEWPORT_WIDTH.get(a) != null && VIEWPORT_HEIGHT.get(a) != null) {
      // width of the viewport
      writeAttribute(elem, "width", toNumber(VIEWPORT_WIDTH.get(a)), null);
      // height of the viewport
      writeAttribute(elem, "height", toNumber(VIEWPORT_HEIGHT.get(a)), null);
    }
    //'viewport-fill'
    //Value:   "none" | <color> | inherit
    //Initial:   none
    //Applies to:  viewport-creating elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     "none" or specified <color> value, except inherit
    writeAttribute(elem, "viewport-fill", toColor(VIEWPORT_FILL.get(a)), "none");
    //'viewport-fill-opacity'
    //Value:  <opacity-value> | inherit
    //Initial:   1.0
    //Applies to:  viewport-creating elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "viewport-fill-opacity", VIEWPORT_FILL_OPACITY.get(a), 1.0);
###
2674, toTransform, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 1197, 1270
3
/* Converts an AffineTransform into an SVG transform attribute value as specified in
   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute
   */
73
  public static String toTransform(AffineTransform t) throws IOException {
    StringBuilder buf = new StringBuilder();
    switch (t.getType()) {
      case AffineTransform.TYPE_IDENTITY:
        buf.append("none");
        break;
      case AffineTransform.TYPE_TRANSLATION:
        // translate(<tx> [<ty>]), specifies a translation by tx and ty.
        // If <ty> is not provided, it is assumed to be zero.
        buf.append("translate(");
        buf.append(toNumber(t.getTranslateX()));
        if (t.getTranslateY() != 0d) {
          buf.append(' ');
          buf.append(toNumber(t.getTranslateY()));
        }
        buf.append(')');
        break;
      /*
      case AffineTransform.TYPE_GENERAL_ROTATION :
      case AffineTransform.TYPE_QUADRANT_ROTATION :
      case AffineTransform.TYPE_MASK_ROTATION :
      // rotate(<rotate-angle> [<cx> <cy>]), specifies a rotation by
      // <rotate-angle> degrees about a given point.
      // If optional parameters <cx> and <cy> are not supplied, the
      // rotate is about the origin of the current user coordinate
      // system. The operation corresponds to the matrix
      // [cos(a) sin(a) -sin(a) cos(a) 0 0].
      // If optional parameters <cx> and <cy> are supplied, the rotate
      // is about the point (<cx>, <cy>). The operation represents the
      // equivalent of the following specification:
      // translate(<cx>, <cy>) rotate(<rotate-angle>)
      // translate(-<cx>, -<cy>).
      buf.append("rotate(");
      buf.append(toNumber(t.getScaleX()));
      buf.append(')');
      break;*/
      case AffineTransform.TYPE_UNIFORM_SCALE:
        // scale(<sx> [<sy>]), specifies a scale operation by sx
        // and sy. If <sy> is not provided, it is assumed to be equal
        // to <sx>.
        buf.append("scale(");
        buf.append(toNumber(t.getScaleX()));
        buf.append(')');
        break;
      case AffineTransform.TYPE_GENERAL_SCALE:
      case AffineTransform.TYPE_MASK_SCALE:
        // scale(<sx> [<sy>]), specifies a scale operation by sx
        // and sy. If <sy> is not provided, it is assumed to be equal
        // to <sx>.
        buf.append("scale(");
        buf.append(toNumber(t.getScaleX()));
        buf.append(' ');
        buf.append(toNumber(t.getScaleY()));
        buf.append(')');
        break;
      default:
        // matrix(<a> <b> <c> <d> <e> <f>), specifies a transformation
        // in the form of a transformation matrix of six values.
        // matrix(a,b,c,d,e,f) is equivalent to applying the
        // transformation matrix [a b c d e f].
        buf.append("matrix(");
        double[] matrix = new double[6];
        t.getMatrix(matrix);
        for (int i = 0; i < matrix.length; i++) {
          if (i != 0) {
            buf.append(' ');
          }
          buf.append(toNumber(matrix[i]));
        }
        buf.append(')');
        break;
    }
    return buf.toString();
###
2675, toPath, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 997, 1163
3
/** Returns a value as a SVG Path attribute.
   * as specified in http://www.w3.org/TR/SVGMobile12/paths.html#PathDataBNF
   */
162
  public static String toPath(BezierPath[] paths) {
    StringBuilder buf = new StringBuilder();
    for (int j = 0; j < paths.length; j++) {
      BezierPath path = paths[j];
      if (path.size() == 0) {
        // nothing to do
      } else if (path.size() == 1) {
        BezierPath.Node current = path.get(0);
        buf.append("M ");
        buf.append(toNumber(current.x[0]));
        buf.append(' ');
        buf.append(toNumber(current.y[0]));
        //buf.append(" L ");
        buf.append(toNumber(current.x[0]));
        buf.append(' ');
        buf.append(toNumber(current.y[0] + 1));
      } else {
        BezierPath.Node previous;
        BezierPath.Node current;
        previous = current = path.get(0);
        buf.append("M ");
        buf.append(toNumber(current.x[0]));
        buf.append(' ');
        buf.append(toNumber(current.y[0]));
        char nextCommand = 'L';
        for (int i = 1, n = path.size(); i < n; i++) {
          previous = current;
          current = path.get(i);
          if ((previous.mask & BezierPath.C2_MASK) == 0) {
            if ((current.mask & BezierPath.C1_MASK) == 0) {
              if (nextCommand != 'L') {
                buf.append(" L ");
                nextCommand = 'L';
              } else {
                buf.append(' ');
              }
              buf.append(toNumber(current.x[0]));
              buf.append(' ');
              buf.append(toNumber(current.y[0]));
            } else {
              if (nextCommand != 'Q') {
                buf.append(" Q ");
                nextCommand = 'Q';
              } else {
                buf.append(' ');
              }
              buf.append(toNumber(current.x[1]));
              buf.append(' ');
              buf.append(toNumber(current.y[1]));
              buf.append(' ');
              buf.append(toNumber(current.x[0]));
              buf.append(' ');
              buf.append(toNumber(current.y[0]));
            }
          } else {
            if ((current.mask & BezierPath.C1_MASK) == 0) {
              if (nextCommand != 'Q') {
                buf.append(" Q ");
                nextCommand = 'Q';
              } else {
                buf.append(' ');
              }
              buf.append(toNumber(previous.x[2]));
              buf.append(' ');
              buf.append(toNumber(previous.y[2]));
              buf.append(' ');
              buf.append(toNumber(current.x[0]));
              buf.append(' ');
              buf.append(toNumber(current.y[0]));
            } else {
              if (nextCommand != 'C') {
                buf.append(" C ");
                nextCommand = 'C';
              } else {
                buf.append(' ');
              }
              buf.append(toNumber(previous.x[2]));
              buf.append(' ');
              buf.append(toNumber(previous.y[2]));
              buf.append(' ');
              buf.append(toNumber(current.x[1]));
              buf.append(' ');
              buf.append(toNumber(current.y[1]));
              buf.append(' ');
              buf.append(toNumber(current.x[0]));
              buf.append(' ');
              buf.append(toNumber(current.y[0]));
            }
          }
        }
        if (path.isClosed()) {
          if (path.size() > 1) {
            previous = path.get(path.size() - 1);
            current = path.get(0);
            if ((previous.mask & BezierPath.C2_MASK) == 0) {
              if ((current.mask & BezierPath.C1_MASK) == 0) {
                if (nextCommand != 'L') {
                  buf.append(" L ");
                  nextCommand = 'L';
                } else {
                  buf.append(' ');
                }
                buf.append(toNumber(current.x[0]));
                buf.append(' ');
                buf.append(toNumber(current.y[0]));
              } else {
                if (nextCommand != 'Q') {
                  buf.append(" Q ");
                  nextCommand = 'Q';
                } else {
                  buf.append(' ');
                }
                buf.append(toNumber(current.x[1]));
                buf.append(' ');
                buf.append(toNumber(current.y[1]));
                buf.append(' ');
                buf.append(toNumber(current.x[0]));
                buf.append(' ');
                buf.append(toNumber(current.y[0]));
              }
            } else {
              if ((current.mask & BezierPath.C1_MASK) == 0) {
                if (nextCommand != 'Q') {
                  buf.append(" Q ");
                  nextCommand = 'Q';
                } else {
                  buf.append(' ');
                }
                buf.append(toNumber(previous.x[2]));
                buf.append(' ');
                buf.append(toNumber(previous.y[2]));
                buf.append(' ');
                buf.append(toNumber(current.x[0]));
                buf.append(' ');
                buf.append(toNumber(current.y[0]));
              } else {
                if (nextCommand != 'C') {
                  buf.append(" C ");
                  nextCommand = 'C';
                } else {
                  buf.append(' ');
                }
                buf.append(toNumber(previous.x[2]));
                buf.append(' ');
                buf.append(toNumber(previous.y[2]));
                buf.append(' ');
                buf.append(toNumber(current.x[1]));
                buf.append(' ');
                buf.append(toNumber(current.y[1]));
                buf.append(' ');
                buf.append(toNumber(current.x[0]));
                buf.append(' ');
                buf.append(toNumber(current.y[0]));
              }
            }
          }
          buf.append(" Z");
          nextCommand = '\0';
        }
      }
    }
    return buf.toString();
###
2676, toPoints, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 1181, 1191
4
/**
   * Returns a Point2D.Double array as a Points attribute value.
   * as specified in http://www.w3.org/TR/SVGMobile12/shapes.html#PointsBNF
   */
11
  public static String toPoints(Point2D.Double[] points) throws IOException {
    StringBuilder buf = new StringBuilder();
    for (int i = 0; i < points.length; i++) {
      if (i != 0) {
        buf.append(", ");
      }
      buf.append(toNumber(points[i].x));
      buf.append(',');
      buf.append(toNumber(points[i].y));
    }
    return buf.toString();
###
2677, ViewToolBar, ViewToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBar.java, 45, 48
1
/** Creates new instance. */
4
  public ViewToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
    setDisclosureStateCount(3);
###
2678, getTransferData, XMLTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/XMLTransferable.java, 57, 61
11
/**
   * Returns an object which represents the data to be transferred.  The class
   * of the object returned is defined by the representation class of the flavor.
   *
   * @param flavor the requested flavor for the data
   * @see DataFlavor#getRepresentationClass
   * @exception IOException        if the data is no longer available
   *       in the requested flavor.
   * @exception UnsupportedFlavorException if the requested data flavor is
   *       not supported.
   */
5
  public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {
    if (this.flavor.equals(flavor)) {
      return new ByteArrayInputStream(data);
    } else {
      throw new UnsupportedFlavorException(flavor);
###
2679, getTransferDataFlavors, XMLTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/XMLTransferable.java, 71, 72
6
/**
   * Returns an array of DataFlavor objects indicating the flavors the data
   * can be provided in.  The array should be ordered according to preference
   * for providing the data (from most richly descriptive to least descriptive).
   * @return an array of data flavors in which this data can be transferred
   */
2
  public DataFlavor[] getTransferDataFlavors() {
    return new DataFlavor[] {flavor};
###
2680, XMLTransferable, XMLTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/XMLTransferable.java, 31, 33
1
/** Creates new XMLTransferable */
3
  public XMLTransferable(byte[] data, String mimeType, String humanPresentableName) {
    this.data = data;
    this.flavor = new DataFlavor(mimeType, humanPresentableName);
###
2683, PathTool, PathTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/PathTool.java, 47, 48
1
/** Creates a new instance. */
2
  public PathTool(SVGPathFigure pathPrototype, SVGBezierFigure bezierPrototype) {
    this(pathPrototype, bezierPrototype, null);
###
2684, createDrawing, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 268, 277
3
/**
   * Creates the drawing.
   */
10
  protected Drawing createDrawing() {
    DefaultDrawing drawing = new DefaultDrawing();
    drawing.addInputFormat(new SVGZInputFormat());
    drawing.addInputFormat(new ImageInputFormat(new SVGImageFigure()));
    drawing.addOutputFormat(new SVGOutputFormat());
    drawing.addOutputFormat(new SVGZOutputFormat());
    drawing.addOutputFormat(new ImageOutputFormat());
    drawing.addOutputFormat(new ImageOutputFormat("JPG", "Joint Photographics Experts Group (JPEG)", "jpg", BufferedImage.TYPE_INT_RGB));
    drawing.addOutputFormat(new ImageOutputFormat("BMP", "Windows Bitmap (BMP)", "bmp", BufferedImage.TYPE_BYTE_INDEXED));
    return drawing;
###
2685, init, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 104, 206
7
/**
   * Displays a progress indicator and then invokes <code>loadDrawing</code>
   * on a worker thread. Displays the drawing panel when done successfully.
   * Displays an error message when done unsuccessfully.
   *
   * @see #loadDrawing
   */
92
  @Override
  public final void init() {
    // set the language of the applet
    if (getParameter("Locale") != null) {
      Locale.setDefault(new Locale(getParameter("Locale")));
    }

    final ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    // Set look and feel
    // -----------------
    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Throwable e) {
      // Do nothing.
      // If we can't set the desired look and feel, UIManager does
      // automaticaly the right thing for us.
    }
    // Set our own popup factory, because the one that comes with Mac OS X
    // creates translucent popups which is not useful for color selection
    // using pop menus.
    try {
      PopupFactory.setSharedInstance(new PopupFactory());
    } catch (Throwable e) {
      // If we can't set the popup factory, we have to use what is there.
    }
    // Display a progress indicator while we are loading the drawing
    // ----------------------------------------------------------
    Container c = getContentPane();
    final ProgressIndicator progress = new ProgressIndicator(
        getName(), labels.getString("progressInitializing"));
    c.add(progress);
    progress.revalidate();
    // Load the drawing using a worker thread
    // --------------------------------------
    new Worker() {
      protected Object construct() throws Exception {
        Thread t = new Thread() {
          @Override
          public void run() {
            drawingComponent = createDrawingComponent();
          }
        };
        t.start();
        progress.setNote(labels.getString("progressLoading"));
        Object drawing = loadDrawing(progress);
        progress.setNote(labels.getString("progressOpeningEditor"));
        progress.setIndeterminate(true);
        t.join();
        return drawing;
      }
      protected void done(Object result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        c.add(drawingComponent.getComponent());
        initComponents();
        if (result != null) {
          if (result instanceof Drawing) {
            setDrawing((Drawing) result);
          } else if (result instanceof Throwable) {
            setDrawing(createDrawing());
            getDrawing().add(new SVGTextFigure(result.toString()));
            ((Throwable) result).printStackTrace();
          }
        }
        drawingComponent.revalidate();
      }
      protected void failed(Throwable result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        Throwable error = (Throwable) result;
        error.printStackTrace();
        String message = (error.getMessage() == null) ? error.toString() : error.getMessage();
        MessagePanel mp = new MessagePanel(
            UIManager.getIcon("OptionPane.errorIcon"),
            labels.getFormatted("messageLoadFailed", htmlencode(getParameter("DrawingURL")), htmlencode(message)));
        c.add(mp);
        mp.addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent evt) {
            if (evt.getActionCommand().equals("close")) {
              close();
            }
          }
        });
        mp.revalidate();
      }
      protected void finished() {
        long end = System.currentTimeMillis();
        System.out.println("AbstractDrawingApplet startup latency:" + (end - start));
      }
    }.start();
###
2686, getParameter, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 75, 80
4
/**
   * Same as <code>Applet.getParameter()</code> but doesn't throw a
   * NullPointerException when used without an Applet context.
   */
6
  @Override
  public String getParameter(String name) {
    try {
      return super.getParameter(name);
    } catch (NullPointerException e) {
      return null;
###
2687, htmlencode, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 402, 432
5
/**
   * Escapes all '<', '>' and '&' characters in a string.
   * @param str A String.
   * @return HTMlEncoded String.
   */
24
  private static String htmlencode(String str) {
    if (str == null) {
      return "";
    } else {
      StringBuilder buf = new StringBuilder();
      for (char ch : str.toCharArray()) {
        switch (ch) {
          case '<':
            buf.append("&lt;");
            break;
          case '>':
            buf.append("&gt;");
            break;
          case '&':
            buf.append("&amp;");
            break;
          default:
            buf.append(ch);
            break;
        }


      }
      return buf.toString();
###
2688, setDrawing, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 212, 213
3
/**
   * Sets the drawing on the drawing panel.
   */
2
  private void setDrawing(Drawing d) {
    drawingComponent.setDrawing(d);
###
2689, getParameter, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 88, 93
4
/**
   * Same as <code>Applet.getParameter()</code> but doesn't throw a
   * NullPointerException when used without an Applet context.
   */
6
  public String getParameter(String name, String defaultValue) {
    try {
      String value = super.getParameter(name);
      return (value == null) ? defaultValue : value;
    } catch (NullPointerException e) {
      return defaultValue;
###
2690, getDrawing, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 219, 220
3
/**
   * Gets the drawing from the drawing panel.
   */
2
  private Drawing getDrawing() {
    return drawingComponent.getDrawing();
###
2691, getAppletInfo, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 253, 259
3
/**
   * Returns information about the applet.
   */
7
  @Override
  public String getAppletInfo() {
    return getName() +
        "\nVersion " + getVersion() +
        "\n\nCopyright 1996-2010 (c) by the original authors of JHotDraw and all its contributors" +
        "\nThis software is licensed under LGPL or" +
        "\nCreative Commons 2.5 BY";
###
2692, loadDrawing, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 310, 370
8
/**
   * Loads the drawing.
   * By convention this method is invoked on a worker thread.
   *
   * @param progress A ProgressIndicator to inform the user about the progress
   * of the operation.
   * @return The Drawing that was loaded.
   */
58
  protected Drawing loadDrawing(ProgressIndicator progress) throws IOException {
    Drawing drawing = createDrawing();
    if (getParameter("datafile") != null) {
      ByteArrayOutputStream buf = new ByteArrayOutputStream();
      URL url = new URL(getDocumentBase(), getParameter("datafile"));
      URLConnection uc = url.openConnection();
      // Disable caching. This ensures that we always request the
      // newest version of the drawing from the server.
      // (Note: The server still needs to set the proper HTTP caching
      // properties to prevent proxies from caching the drawing).
      if (uc instanceof HttpURLConnection) {
        ((HttpURLConnection) uc).setUseCaches(false);
      }
      // Read the data into a buffer
      int contentLength = uc.getContentLength();
      InputStream in = uc.getInputStream();
      try {
        if (contentLength != -1) {
          in = new BoundedRangeInputStream(in);
          ((BoundedRangeInputStream) in).setMaximum(contentLength + 1);
          progress.setProgressModel((BoundedRangeModel) in);
          progress.setIndeterminate(false);
        }
        BufferedInputStream bin = new BufferedInputStream(in);
        bin.mark(512);
        // Read the data using all supported input formats
        // until we succeed
        final ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
        IOException formatException = null;
        for (InputFormat format : drawing.getInputFormats()) {
          try {
            bin.reset();
          } catch (IOException e) {
            uc = url.openConnection();
            in = uc.getInputStream();
            in = new BoundedRangeInputStream(in);
            ((BoundedRangeInputStream) in).setMaximum(contentLength + 1);
            progress.setProgressModel((BoundedRangeModel) in);
            bin = new BufferedInputStream(in);
            bin.mark(512);
          }
          try {
            bin.reset();
            format.read(bin, drawing, true);
            formatException = null;
            break;
          } catch (IOException e) {
            formatException = e;
          }
        }
        if (formatException != null) {
          throw formatException;
        }
      } finally {
        in.close();
      }
    }
    return drawing;
###
2693, createDrawingComponent, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 283, 288
3
/**
   * Creates the drawing component.
   */
5
  protected SVGDrawingPanel createDrawingComponent() {
    SVGDrawingPanel p = new SVGDrawingPanel();
    DefaultDrawingEditor editor = new DefaultDrawingEditor();
    p.setEditor(new DefaultDrawingEditor());
    return p;
###
2694, getVersion, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 226, 247
3
/**
   * Gets the version of the applet.
   */
22
  public String getVersion() {
    if (version == null) {
      BufferedReader r = null;
      try {
        InputStream resource = SVGApplet.class.getResourceAsStream("version.txt");
        r = new BufferedReader(new InputStreamReader(resource, "UTF-8"));
        version = r.readLine();
      } catch (IOException e) {
        version = "unknown";
      } catch (NullPointerException e) {
        version = "unknown";
      } finally {
        if (r != null) {
          try {
            r.close();
          } catch (IOException e) {
            // suppress
          }
        }
      }
    }
    return version;
###
2695, close, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 377, 391
4
/**
   * Closes the applet. This method can be implemented by invoking
   * <code>getAppletContext().showDocument(...)</code>.
   */
14
  protected void close() {
    AppletContext appletContext;
    try {
      appletContext = getAppletContext();
    } catch (Throwable e) {
      appletContext = null;
    }
    if (appletContext == null) {
      System.exit(0);
    } else {
      try {
        appletContext.showDocument(new URL(getDocumentBase(), getParameter("PageURL")));
      } catch (MalformedURLException ex) {
        ex.printStackTrace();
###
2697, SVGCreateFromFileTool, SVGCreateFromFileTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGCreateFromFileTool.java, 62, 65
1
/** Creates a new instance. */
4
  public SVGCreateFromFileTool(ImageHolderFigure imagePrototype, CompositeFigure groupPrototype, Map<AttributeKey, Object> attributes) {
    super(imagePrototype, attributes);
    this.groupPrototype = groupPrototype;
    this.imagePrototype = imagePrototype;
###
2698, SVGCreateFromFileTool, SVGCreateFromFileTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGCreateFromFileTool.java, 55, 58
1
/** Creates a new instance. */
4
  public SVGCreateFromFileTool(ImageHolderFigure imagePrototype, CompositeFigure groupPrototype) {
    super(imagePrototype);
    this.groupPrototype = groupPrototype;
    this.imagePrototype = imagePrototype;
###
2699, SVGApplicationModel, SVGApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplicationModel.java, 56, 57
1
/** Creates a new instance. */
2
  public SVGApplicationModel() {
    gridConstrainer = new GridConstrainer(12, 12);
###
2700, createToolBars, SVGApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplicationModel.java, 175, 178
7
/**
   * Overriden to create no toolbars.
   * 
   * @param app
   * @param p
   * @return An empty list.
   */
4
  @Override
  public List<JToolBar> createToolBars(Application app, View p) {
    LinkedList<JToolBar> list = new LinkedList<JToolBar>();
    return list;
###
2702, main, Main, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/Main.java, 28, 49
1
/** Creates a new instance. */
21
  public static void main(String[] args) {
    // Debug resource bundle
    ResourceBundleUtil.setVerbose(true);
    Application app;
    String os = System.getProperty("os.name").toLowerCase();
    if (os.startsWith("mac")) {
      app = new OSXApplication();
    } else if (os.startsWith("win")) {
      //  app = new DefaultMDIApplication();
      app = new SDIApplication();
    } else {
      app = new SDIApplication();
    }
    SVGApplicationModel model = new SVGApplicationModel();
    model.setName("JHotDraw SVG");
    model.setVersion(Main.class.getPackage().getImplementationVersion());
    model.setCopyright("Copyright 2006-2010 (c) by the authors of JHotDraw.\n" +
        "This software is licensed under LGPL and Creative Commons 3.0 Attribution.");
    model.setViewClassName("org.jhotdraw.samples.svg.SVGView");
    app.setModel(model);
    app.launch(args);
###
2703, ConvexHullOutlineHandle, ConvexHullOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/ConvexHullOutlineHandle.java, 55, 88
5
/**
   * Creates a bounds outline handle for resizing or transforming a component.
   * 
   * @param owner
   */
34
  public ConvexHullOutlineHandle(SVGPathFigure owner, boolean isTransformHandle, boolean isHoverHandle) {
    super(owner);
    if (isTransformHandle) {
      if (isHoverHandle) {
        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_HOVER;
        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_HOVER;
        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_HOVER;
        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_HOVER;
      } else {
        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1;
        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1;
        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2;
        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2;
      }
      stroke1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_DISABLED;
      strokeColor1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_DISABLED;
      stroke2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_DISABLED;
      strokeColor2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_DISABLED;
    } else {
      if (isHoverHandle) {
        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_HOVER;
        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_HOVER;
        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_HOVER;
        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_HOVER;
      } else {
        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1;
        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1;
        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2;
        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2;
      }
      stroke1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_DISABLED;
      strokeColor1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_DISABLED;
      stroke2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_DISABLED;
      strokeColor2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_DISABLED;
###
2704, ConvexHullOutlineHandle, ConvexHullOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/ConvexHullOutlineHandle.java, 46, 47
5
/**
   * Creates a bounds outline handle for resizing a component.
   * 
   * @param owner
   */
2
  public ConvexHullOutlineHandle(SVGPathFigure owner) {
    this(owner, false, false);
###
2705, ConvexHullOutlineHandle, ConvexHullOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/ConvexHullOutlineHandle.java, 97, 111
5
/**
   * Creates a bounds outline handle for resizing or transforming a component.
   *
   * @param owner
   */
15
  public ConvexHullOutlineHandle(SVGPathFigure owner, //
      AttributeKey<Stroke> stroke1Enabled, AttributeKey<Color> strokeColor1Enabled,//
      AttributeKey<Stroke> stroke2Enabled, AttributeKey<Color> strokeColor2Enabled,//
      AttributeKey<Stroke> stroke1Disabled, AttributeKey<Color> strokeColor1Disabled,//
      AttributeKey<Stroke> stroke2Disabled, AttributeKey<Color> strokeColor2Disabled
      ) {
    super(owner);
    this.stroke1Enabled = stroke1Enabled;
    this.strokeColor1Enabled = strokeColor1Enabled;
    this.stroke2Enabled = stroke2Enabled;
    this.strokeColor2Enabled = strokeColor2Enabled;
    this.stroke1Disabled = stroke1Disabled;
    this.strokeColor1Disabled = strokeColor1Disabled;
    this.stroke2Disabled = stroke2Disabled;
    this.strokeColor2Disabled = strokeColor2Disabled;
###
2706, LinkHandle, LinkHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/LinkHandle.java, 34, 35
1
/** Creates a new instance. */
2
  public LinkHandle(Figure owner) {
    super(owner);
###
2707, draw, LinkHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/LinkHandle.java, 46, 56
3
/**
   * Draws this handle.
   */
11
  @Override public void draw(Graphics2D g) {
    Figure o = getOwner();
    if (o.get(LINK)!=null&&o.get(LINK).trim().length()>0) {
      g.setColor((Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR));
      Rectangle r = basicGetBounds();
      g.drawLine(r.x+(r.width/2)-1, r.y, r.x, r.y);
      g.drawLine(r.x, r.y, r.x, r.y+r.height-1);
      g.drawLine(r.x, r.y+r.height-1, r.x+(r.width/2)-1, r.y+r.height-1);
      g.drawLine(r.x+(r.width/3), r.y+r.height/2, r.x+r.width-1, r.y+r.height/2);
      g.drawLine(r.x+r.width-1, r.y+r.height/2, (int)(r.x+r.width*.75-1), (int)(r.y+r.height*.25));
      g.drawLine(r.x+r.width-1, r.y+r.height/2, (int)(r.x+r.width*.75-1), (int)(r.y+r.height*.75));
###
2709, getDefaultEventIndex, SVGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java, 150, 151
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2712, getDefaultPropertyIndex, SVGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java, 139, 140
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2713, getEventSetDescriptors, SVGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java, 116, 117
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2714, getPropertyDescriptors, SVGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java, 105, 106
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2715, getBeanDescriptor, SVGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java, 89, 90
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2717, ViewSourceAction, ViewSourceAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/action/ViewSourceAction.java, 49, 52
1
/** Creates a new instance. */
4
  public ViewSourceAction(Application app, View view) {
    super(app, view);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    labels.configureAction(this, ID);
###
2718, read, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 329, 360
8
/**
   * Reads a drawing from the specified file into the SVGDrawingPanel using
   * the specified input format.
   * <p>
   * This method should be called from a worker thread.
   * Calling it from the Event Dispatcher Thread will block the user
   * interface, until the drawing is read.
   */
29
  public void read(File f, InputFormat format) throws IOException {
    if (format == null) {
      read(f);
      return;
    }
    // Create a new drawing object
    Drawing newDrawing = createDrawing();
    if (newDrawing.getInputFormats().size() == 0) {
      throw new InternalError("Drawing object has no input formats.");
    }
    format.read(f, newDrawing);
    final Drawing loadedDrawing = newDrawing;
    Runnable r = new Runnable() {
      public void run() {
        // Set the drawing on the Event Dispatcher Thread
        setDrawing(loadedDrawing);
      }
    };
    if (SwingUtilities.isEventDispatchThread()) {
      r.run();
    } else {
      try {
        SwingUtilities.invokeAndWait(r);
      } catch (InterruptedException ex) {
        // suppress silently
      } catch (InvocationTargetException ex) {
        InternalError ie = new InternalError("Error setting drawing.");
        ie.initCause(ex);
        throw ie;
###
2719, write, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 372, 415
7
/**
   * Writes the drawing from the SVGDrawingPanel into a file.
   * <p>
   * This method should be called from a worker thread.
   * Calling it from the Event Dispatcher Thread will block the user
   * interface, until the drawing is written.
   */
38
  public void write(File f) throws IOException {
    // Defensively clone the drawing object, so that we are not
    // affected by changes of the drawing while we write it into the file.
    final Drawing[] helper = new Drawing[1];
    Runnable r = new Runnable() {
      public void run() {
        helper[0] = (Drawing) getDrawing().clone();
      }
    };
    if (SwingUtilities.isEventDispatchThread()) {
      r.run();
    } else {
      try {
        SwingUtilities.invokeAndWait(r);
      } catch (InterruptedException ex) {
        // suppress silently
      } catch (InvocationTargetException ex) {
        InternalError ie = new InternalError("Error getting drawing.");
        ie.initCause(ex);
        throw ie;
      }
    }
    Drawing saveDrawing = helper[0];
    if (saveDrawing.getOutputFormats().size() == 0) {
      throw new InternalError("Drawing object has no output formats.");
    }
    // Try out all output formats until we find one which accepts the
    // filename entered by the user.
    for (OutputFormat format : saveDrawing.getOutputFormats()) {
      if (format.getFileFilter().accept(f)) {
        format.write(f, saveDrawing);
        // We get here if writing was successful.
        // We can return since we are done.
        return;
      }

    }
    throw new IOException("No output format for " + f.getName());
###
2720, read, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 272, 318
7
/**
   * Reads a drawing from the specified file into the SVGDrawingPanel.
   * <p>
   * This method should be called from a worker thread.
   * Calling it from the Event Dispatcher Thread will block the user
   * interface, until the drawing is read.
   */
45
  public void read(File f) throws IOException {
    // Create a new drawing object
    Drawing newDrawing = createDrawing();
    if (newDrawing.getInputFormats().size() == 0) {
      throw new InternalError("Drawing object has no input formats.");
    }
    // Try out all input formats until we succeed
    IOException firstIOException = null;
    for (InputFormat format : newDrawing.getInputFormats()) {
      try {
        format.read(f, newDrawing);
        final Drawing loadedDrawing = newDrawing;
        Runnable r = new Runnable() {
          public void run() {
            // Set the drawing on the Event Dispatcher Thread
            setDrawing(loadedDrawing);
          }
        };
        if (SwingUtilities.isEventDispatchThread()) {
          r.run();
        } else {
          try {
            SwingUtilities.invokeAndWait(r);
          } catch (InterruptedException ex) {
            // suppress silently
          } catch (InvocationTargetException ex) {
            InternalError ie = new InternalError("Error setting drawing.");
            ie.initCause(ex);
            throw ie;
          }
        }
        // We get here if reading was successful.
        // We can return since we are done.
        return;
        //
      } catch (IOException e) {
        // We get here if reading failed.
        // We only preserve the exception of the first input format,
        // because that's the one which is best suited for this drawing.
        if (firstIOException == null) {
          firstIOException = e;
        }
      }
    }
    throw firstIOException;
###
2721, write, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 426, 458
8
/**
   * Writes the drawing from the SVGDrawingPanel into a file using the
   * specified output format.
   * <p>
   * This method should be called from a worker thread.
   * Calling it from the Event Dispatcher Thread will block the user
   * interface, until the drawing is written.
   */
29
  public void write(File f, OutputFormat format) throws IOException {
    if (format == null) {
      write(f);
      return;
    }
    // Defensively clone the drawing object, so that we are not
    // affected by changes of the drawing while we write it into the file.
    final Drawing[] helper = new Drawing[1];
    Runnable r = new Runnable() {
      public void run() {
        helper[0] = (Drawing) getDrawing().clone();
      }
    };
    if (SwingUtilities.isEventDispatchThread()) {
      r.run();
    } else {
      try {
        SwingUtilities.invokeAndWait(r);
      } catch (InterruptedException ex) {
        // suppress silently
      } catch (InvocationTargetException ex) {
        InternalError ie = new InternalError("Error getting drawing.");
        ie.initCause(ex);
        throw ie;
      }
    }
    // Write drawing to file
    Drawing saveDrawing = helper[0];
    format.write(f, saveDrawing);
###
2723, createDrawing, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 193, 211
4
/**
   * Creates a new Drawing object which can be used with this
   * {@code SVGDrawingPanel}.
   */
18
  public Drawing createDrawing() {
    Drawing drawing = new QuadTreeDrawing();
    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();
    inputFormats.add(new SVGZInputFormat());
    inputFormats.add(new ImageInputFormat(new SVGImageFigure(), "PNG", "Portable Network Graphics (PNG)", "png", "image/png"));
    inputFormats.add(new ImageInputFormat(new SVGImageFigure(), "JPG", "Joint Photographics Experts Group (JPEG)", "jpg","image/jpg"));
    inputFormats.add(new ImageInputFormat(new SVGImageFigure(), "GIF", "Graphics Interchange Format (GIF)", "gif", "image/gif"));
    inputFormats.add(new TextInputFormat(new SVGTextFigure()));
    drawing.setInputFormats(inputFormats);
    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();
    outputFormats.add(new SVGOutputFormat());
    outputFormats.add(new SVGZOutputFormat());
    outputFormats.add(new ImageOutputFormat());
    outputFormats.add(new ImageOutputFormat("JPG", "Joint Photographics Experts Group (JPEG)", "jpg", BufferedImage.TYPE_INT_RGB));
    outputFormats.add(new ImageOutputFormat("BMP", "Windows Bitmap (BMP)", "bmp", BufferedImage.TYPE_BYTE_INDEXED));
    outputFormats.add(new ImageMapOutputFormat());
    drawing.setOutputFormats(outputFormats);
    return drawing;
###
2724, initComponents, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 467, 529
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
52
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    toolButtonGroup = new javax.swing.ButtonGroup();
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    toolsPanel = new javax.swing.JPanel();
    toolsScrollPane = new javax.swing.JScrollPane();
    toolsPane = new javax.swing.JPanel();
    creationToolBar = new org.jhotdraw.samples.svg.gui.ToolsToolBar();
    actionToolBar = new org.jhotdraw.samples.svg.gui.ActionsToolBar();
    fillToolBar = new org.jhotdraw.samples.svg.gui.FillToolBar();
    strokeToolBar = new org.jhotdraw.samples.svg.gui.StrokeToolBar();
    fontToolBar = new org.jhotdraw.samples.svg.gui.FontToolBar();
    arrangeToolBar = new org.jhotdraw.samples.svg.gui.ArrangeToolBar();
    alignToolBar = new org.jhotdraw.samples.svg.gui.AlignToolBar();
    figureToolBar = new org.jhotdraw.samples.svg.gui.FigureToolBar();
    linkToolBar = new org.jhotdraw.samples.svg.gui.LinkToolBar();
    canvasToolBar = new org.jhotdraw.samples.svg.gui.CanvasToolBar();
    viewToolBar = new org.jhotdraw.samples.svg.gui.ViewToolBar();
    setBackground(new java.awt.Color(255, 255, 255));
    setLayout(new java.awt.BorderLayout());
    scrollPane.setBorder(null);
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    toolsPanel.setBackground(new java.awt.Color(255, 255, 255));
    toolsPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
    toolsPanel.setOpaque(true);
    toolsPanel.setLayout(new java.awt.GridBagLayout());
    toolsScrollPane.setBorder(PaletteLookAndFeel.getInstance().getBorder("Ribbon.border"));
    toolsScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    toolsScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
    toolsScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));
    toolsPane.setForeground(new java.awt.Color(153, 153, 153));
    toolsPane.add(creationToolBar);
    toolsPane.add(actionToolBar);
    toolsPane.add(fillToolBar);
    strokeToolBar.setMargin(new java.awt.Insets(0, 10, 0, 0));
    toolsPane.add(strokeToolBar);
    toolsPane.add(fontToolBar);
    toolsPane.add(arrangeToolBar);
    toolsPane.add(alignToolBar);
    toolsPane.add(figureToolBar);
    toolsPane.add(linkToolBar);
    toolsPane.add(canvasToolBar);
    toolsPane.add(viewToolBar);
    toolsScrollPane.setViewportView(toolsPane);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.weighty = 1.0;
    toolsPanel.add(toolsScrollPane, gridBagConstraints);
    add(toolsPanel, java.awt.BorderLayout.SOUTH);
###
2725, SVGDrawingPanel, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 94, 164
1
/** Creates new instance. */
59
  public SVGDrawingPanel() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    ResourceBundleUtil drawLabels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    try {
      prefs = PreferencesUtil.userNodeForPackage(getClass());
    } catch (SecurityException e) {
      // prefs is null, because we are not permitted to read preferences
    }
    
    initComponents();
    toolsPane.setLayout(new ToolBarLayout());
    toolsPane.setBackground(new Color(0xf0f0f0));
    toolsPane.setOpaque(true);
    viewToolBar.setView(view);
    undoManager = new UndoRedoManager();
    Drawing drawing = createDrawing();
    view.setDrawing(drawing);
    drawing.addUndoableEditListener(undoManager);
    // Try to install the DnDDrawingViewTransferHandler
    // Since this class only works on J2SE 6, we have to use reflection.
    try {
      view.setTransferHandler((TransferHandler) Class.forName("org.jhotdraw.draw.DnDDrawingViewTransferHandler").newInstance());
    } catch (Exception e) {
      // bail silently
    }
    // Sort the toolbars according to the user preferences
    ArrayList<JToolBar> sortme = new ArrayList<JToolBar>();
    for (Component c : toolsPane.getComponents()) {
      if (c instanceof JToolBar) {
        sortme.add((JToolBar) c);
      }
    }
    Collections.sort(sortme, new Comparator<JToolBar>() {
      public int compare(JToolBar tb1, JToolBar tb2) {
        int i1 = prefs.getInt("toolBarIndex." + tb1.getName(), 0);
        int i2 = prefs.getInt("toolBarIndex." + tb2.getName(), 0);
        return i1 - i2;
      }
    });
    toolsPane.removeAll();
    for (JToolBar tb : sortme) {
      toolsPane.add(tb);
    }
    toolsPane.addContainerListener(containerHandler = new ContainerListener() {
      public void componentAdded(ContainerEvent e) {
        int i = 0;
        for (Component c : toolsPane.getComponents()) {
          if (c instanceof JToolBar) {
            JToolBar tb = (JToolBar) c;
            prefs.putInt("toolBarIndex." + tb.getName(), i);
            i++;
          }
        }
      }
      public void componentRemoved(ContainerEvent e) {
      }
    });

    setEditor(new DefaultDrawingEditor());
###
2726, CombineAction, CombineAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/action/CombineAction.java, 45, 46
1
/** Creates a new instance. */
2
  public CombineAction(DrawingEditor editor) {
    this(editor, new SVGPathFigure(true), true);
###
2727, SVGBezierFigure, SVGBezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java, 42, 43
1
/** Creates a new instance. */
2
  public SVGBezierFigure() {
    this(false);
###
2728, findSegment, SVGBezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java, 157, 168
5
/**
   * Gets the segment of the polyline that is hit by
   * the given Point2D.Double.
   * @return the index of the segment or -1 if no segment was hit.
   */
11
  @Override
  public int findSegment(Point2D.Double find, double tolerance) {
    // Apply inverse of transform to point
    if (get(TRANSFORM) != null) {
      try {
        find = (Point2D.Double) get(TRANSFORM).inverseTransform(find, new Point2D.Double());
      } catch (NoninvertibleTransformException ex) {
        System.err.println("Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform.");
      }
    }
    return getBezierPath().findSegment(find, tolerance);
###
2729, joinSegments, SVGBezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java, 180, 197
9
/**
   * Joins two segments into one if the given Point2D.Double hits a node
   * of the polyline.
   * @return true if the two segments were joined.
   *
   * @param join a Point at a node on the bezier path
   * @param tolerance a tolerance, tolerance should take into account
   * the line width, plus 2 divided by the zoom factor. 
   */
16
  @Override
  public boolean joinSegments(Point2D.Double join, double tolerance) {
    // Apply inverse of transform to point
    if (get(TRANSFORM) != null) {
      try {
        join = (Point2D.Double) get(TRANSFORM).inverseTransform(join, new Point2D.Double());
      } catch (NoninvertibleTransformException ex) {
        System.err.println("Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform.");
      }
    }
    int i = getBezierPath().findSegment(join, tolerance);
    if (i != -1 && i > 1) {
      removeNode(i);
      return true;
    }
    return false;
###
2730, splitSegment, SVGBezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java, 208, 224
8
/**
   * Splits the segment at the given Point2D.Double if a segment was hit.
   * @return the index of the segment or -1 if no segment was hit.
   *
   * @param split a Point on (or near) a segment of the bezier path
   * @param tolerance a tolerance, tolerance should take into account
   * the line width, plus 2 divided by the zoom factor. 
   */
15
  @Override
  public int splitSegment(Point2D.Double split, double tolerance) {
    // Apply inverse of transform to point
    if (get(TRANSFORM) != null) {
      try {
        split = (Point2D.Double) get(TRANSFORM).inverseTransform(split, new Point2D.Double());
      } catch (NoninvertibleTransformException ex) {
        System.err.println("Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform.");
      }
    }
    int i = getBezierPath().findSegment(split, tolerance);
    if (i != -1) {
      addNode(i + 1, new BezierPath.Node(split));
    }
    return i + 1;
###
2731, createDrawing, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 106, 107
3
/**
   * Creates a new Drawing for this View.
   */
2
  protected Drawing createDrawing() {
    return svgPanel.createDrawing();
###
2733, createPageable, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 113, 114
3
/**
   * Creates a Pageable object for printing the View.
   */
2
  public Pageable createPageable() {
    return new DrawingPageable(svgPanel.getDrawing());
###
2734, read, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 150, 204
3
/**
   * Reads the view from the specified uri.
   */
52
  public void read(final URI uri, URIChooser chooser) throws IOException {
    try {
      JFileURIChooser fc = (JFileURIChooser) chooser;
      final Drawing drawing = createDrawing();
      // We start with the selected uri format in the uri chooser,
      // and then try out all formats we can import.
      // We need to try out all formats, because the user may have
      // chosen to load a uri without having used the uri chooser.
      InputFormat selectedFormat = fileFilterInputFormatMap.get(fc.getFileFilter());
      boolean success = false;
      if (selectedFormat != null) {
        try {
          selectedFormat.read(new File(uri), drawing, true);
          success = true;
        } catch (Exception e) {
          e.printStackTrace();
          // try with the next input format
        }
      }
      if (!success) {
        for (InputFormat sfi : drawing.getInputFormats()) {
          if (sfi != selectedFormat) {
            try {
              sfi.read(new File(uri), drawing, true);
              success = true;
              break;
            } catch (Exception e) {
              // try with the next input format
            }
          }
        }
      }
      if (!success) {
        ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
        throw new IOException(labels.getFormatted("file.open.unsupportedFileFormat.message", URIUtil.getName(uri)));
      }
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          Drawing oldDrawing = svgPanel.getDrawing();
          svgPanel.setDrawing(drawing);
          firePropertyChange(DRAWING_PROPERTY, oldDrawing, svgPanel.getDrawing());
          undo.discardAllEdits();
        }
      });
    } catch (InterruptedException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
    } catch (InvocationTargetException e) {
      InternalError error = new InternalError();
      error.initCause(e);
      throw error;
###
2735, init, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 70, 87
3
/**
   * Initializes the View.
   */
14
  @Override
  public void init() {
    super.init();
    initComponents();
    JPanel zoomButtonPanel = new JPanel(new BorderLayout());
    undo = svgPanel.getUndoRedoManager();
    Drawing oldDrawing = svgPanel.getDrawing();
    svgPanel.setDrawing(createDrawing());
    firePropertyChange(DRAWING_PROPERTY, oldDrawing, svgPanel.getDrawing());
    svgPanel.getDrawing().addUndoableEditListener(undo);
    initActions();
    undo.addPropertyChangeListener(propertyHandler = new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        setHasUnsavedChanges(undo.hasSignificantEdits());
###
2736, initComponents, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 260, 265
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
4
  private void initComponents() {
    svgPanel = new org.jhotdraw.samples.svg.SVGDrawingPanel();
    setLayout(new java.awt.BorderLayout());
    add(svgPanel, java.awt.BorderLayout.CENTER);
###
2737, initActions, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 129, 131
3
/**
   * Initializes view specific actions.
   */
3
  private void initActions() {
    getActionMap().put(UndoAction.ID, undo.getUndoAction());
    getActionMap().put(RedoAction.ID, undo.getRedoAction());
###
2738, clear, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 220, 243
3
/**
   * Clears the view.
   */
23
  public void clear() {
    final Drawing newDrawing = createDrawing();
    try {
      Runnable r = new Runnable() {
        public void run() {
          Drawing oldDrawing = svgPanel.getDrawing();
          svgPanel.setDrawing(newDrawing);
          firePropertyChange(DRAWING_PROPERTY, oldDrawing, newDrawing);
          if (oldDrawing != null) {
            oldDrawing.removeAllChildren();
          }
          undo.discardAllEdits();
        }
      };
      if (SwingUtilities.isEventDispatchThread()) {
        r.run();
      } else {
        SwingUtilities.invokeAndWait(r);
      }
    } catch (InvocationTargetException ex) {
      ex.printStackTrace();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
###
2739, write, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 143, 144
3
/**
   * Writes the view to the specified uri.
   */
2
  public void write(URI uri, URIChooser chooser) throws IOException {
    new SVGOutputFormat().write(new File(uri), svgPanel.getDrawing());
###
2741, DateTitle, DateTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateTitle.java, 98, 99
7
/**
   * Default constructor - builds a new DateTitle that displays the current date in the default
   * (LONG) format for the locale, positioned to the bottom right of the chart.
   * <P>
   * The color will be black in 12 point, plain Helvetica font (maps to Arial on Win32 systems
   * without Helvetica).
   */
2
  public DateTitle() {
    this(DateFormat.LONG);
###
2742, DateTitle, DateTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateTitle.java, 82, 84
10
/**
   * Standard constructor - builds a new DateTitle object with the specified attributes and the
   * following defaults:  location = BOTTOM, alignment = RIGHT, insets = new Insets(2, 2, 2, 2).
   * @param dateStyle the Date style to use (SHORT, MEDIUM, LONG, or FULL constants from
   *          java.util.DateFormat);
   * @param locale the locale to use to format this date (if you are unsure what to use here, use
   *         Locale.getDefault() for your default locale);
   * @param font the font used to display the date;
   * @param paint the paint used to display the date;
   */
3
  public DateTitle(int dateStyle, Locale locale, Font font, Paint paint) {
    this(dateStyle, locale, font, paint, AbstractTitle.BOTTOM, AbstractTitle.RIGHT,
       AbstractTitle.MIDDLE, new Insets(2, 2, 2, 2));
###
2743, DateTitle, DateTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateTitle.java, 65, 69
12
/**
   * Full constructor - builds a new DateTitle with the specified attributes.
   * @param location the relative location of this title (use constants in AbstractTitle);
   * @param alignment the text alignment of this title (use constants in AbstractTitle);
   * @param dateStyle the Date style to use (SHORT, MEDIUM, LONG, or FULL constants from
   *          java.text.DateFormat);
   * @param locale the locale to use to format this date (if you are unsure what to use here, use
   *         Locale.getDefault() for your default locale);
   * @param font the font used to display the date;
   * @param paint the paint used to display the date;
   * @param insets the blank space around the outside of the title;
   */
5
  public DateTitle(int dateStyle, Locale locale, Font font, Paint paint, int position,
           int horizontalAlignment, int verticalAlignment, Insets insets) {

    super(DateFormat.getDateInstance(dateStyle, locale).format(new Date()),
        font, paint, position, horizontalAlignment, verticalAlignment, insets);
###
2744, createXYChart, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 339, 361
8
/**
   * Creates an XY (line) plot with default settings.
   * @param title The chart title.
   * @param xAxisLabel A label for the X-axis.
   * @param yAxisLabel A label for the Y-axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
23
  public static JFreeChart createXYChart(String title, String xAxisLabel, String yAxisLabel,
                         XYDataset data, boolean legend) {

    JFreeChart chart = null;

  try {
      NumberAxis xAxis = new HorizontalNumberAxis(xAxisLabel);
      xAxis.setAutoRangeIncludesZero(false);
    Axis yAxis = new VerticalNumberAxis(yAxisLabel);
      XYPlot plot = new XYPlot(xAxis, yAxis);
      plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));
    chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
  }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createXYChart(...) : axis not compatible.");
  }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createXYChart(...) : plot not compatible.");
  }

    return chart;
###
2745, createLineChart, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 279, 300
8
/**
   * Creates a line chart with default settings.
   * @param title The chart title.
   * @param categoryAxisLabel The label for the category axis.
   * @param valueAxisLabel The label for the value axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
22
  public static JFreeChart createLineChart(String title, String categoryAxisLabel,
                         String valueAxisLabel, CategoryDataset data,
                         boolean legend) {

    JFreeChart chart = null;

  try {
      Axis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);
    Axis valueAxis = new VerticalNumberAxis(valueAxisLabel);
    Plot plot = new LinePlot(categoryAxis, valueAxis);
    chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
  }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createLineChart(...) : axis not compatible.");
  }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createLineChart(...) : plot not compatible.");
  }

    return chart;
###
2746, createHighLowChart, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 483, 504
11
/**
   * Creates and returns a default instance of a high-low-open-close chart based on the specified
   * dataset.
   * <P>
   * Added by Andrzej Porebski.  Amended by David Gilbert.
   * @param title The chart title.
   * @param timeAxisLabel A label for the time axis.
   * @param valueAxisLabel A label for the value axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
22
  public static JFreeChart createHighLowChart(String title, String timeAxisLabel,
                        String valueAxisLabel, HighLowDataset data,
                        boolean legend) {

    JFreeChart chart = null;

  try {
    Axis timeAxis = new HorizontalDateAxis(timeAxisLabel);
    NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);
    HighLowPlot plot = new HighLowPlot(timeAxis, valueAxis);
    chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
  }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createHighLowChart(...) : axis not compatible.");
  }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createHighLowChart(...) : plot not compatible.");
  }

    return chart;
###
2747, createVerticalBarChart, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 58, 79
8
/**
   * Creates a vertical bar chart with default settings.
   * @param title The chart title.
   * @param categoryAxisLabel The label for the category axis.
   * @param valueAxisLabel The label for the value axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
22
  public static JFreeChart createVerticalBarChart(String title, String categoryAxisLabel,
                          String valueAxisLabel, CategoryDataset data,
                          boolean legend) {

    JFreeChart chart = null;

    try {
      Axis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);
      Axis valueAxis = new VerticalNumberAxis(valueAxisLabel);
      Plot plot = new VerticalBarPlot(categoryAxis, valueAxis);
      chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
    }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createVerticalBarChart(...) : axis not compatible.");
    }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createVerticalBarChart(...) : plot not compatible.");
    }

    return chart;
###
2748, createStackedHorizontalBarChart, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 243, 267
9
/**
   * Creates a stacked horizontal bar chart with default settings.  This is still experimental at
   * this point!
   * @param title The chart title.
   * @param categoryAxisLabel The label for the category axis.
   * @param valueAxisLabel The label for the value axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
25
  public static JFreeChart createStackedHorizontalBarChart(String title, String categoryAxisLabel,
                            String valueAxisLabel, CategoryDataset data,
                            boolean legend) {

    JFreeChart chart = null;

    try {
      Axis categoryAxis = new VerticalCategoryAxis(categoryAxisLabel);
      Axis valueAxis = new HorizontalNumberAxis(valueAxisLabel);
      HorizontalBarPlot plot = new HorizontalBarPlot(valueAxis, categoryAxis);
      plot.setRenderer(new StackedHorizontalBarRenderer());
      chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
    }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println(
        "ChartFactory.createStackedHorizontalBarChart(...) : axis not compatible.");
    }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println(
        "ChartFactory.createStackedHorizontalBarChart(...) : plot not compatible.");
    }

    return chart;
###
2749, createVerticalXYBarChart, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 446, 468
9
/**
   * Creates and returns a default instance of a VerticalXYBarChart based on the specified
   * dataset.
   * @param title The chart title.
   * @param xAxisLabel A label for the X-axis.
   * @param yAxisLabel A label for the Y-axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
23
  public static JFreeChart createVerticalXYBarChart(String title, String xAxisLabel,
                            String yAxisLabel, IntervalXYDataset data,
                            boolean legend) {

    JFreeChart chart = null;

  try {
    HorizontalDateAxis timeAxis = new HorizontalDateAxis(xAxisLabel);
    Axis valueAxis = new VerticalNumberAxis(yAxisLabel);
    Plot plot = new VerticalXYBarPlot(timeAxis, valueAxis, new Insets(0,0,0,0), Color.white,
      new BasicStroke(), Color.gray);
    chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
  }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createVerticalXYBarChart(...) : axis not compatible.");
  }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createVerticalXYBarChart(...) : plot not compatible.");
  }

    return chart;
###
2750, createPieChart, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 310, 327
6
/**
   * Creates a pie chart with default settings.
   * @param title The chart title.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
18
  public static JFreeChart createPieChart(String title, PieDataset data, boolean legend) {

    JFreeChart chart = null;

    try {
    Plot plot = new PiePlot();
    chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
  }
  catch (AxisNotCompatibleException e) {
      // can't see how this could happen for a pie chart
    System.err.println("ChartFactory.createPieChart(...) : axis not compatible.");
  }
    catch (PlotNotCompatibleException e) {
      // can't see how this could happen for a pie chart
    System.err.println("ChartFactory.createPieChart(...) : plot not compatible.");
  }

    return chart;
###
2751, createVerticalBarChart3D, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 93, 118
10
/**
   * Creates a vertical 3D-effect bar chart with default settings.
   * <P>
   * Added by Serge V. Grachov.
   * @param title The chart title.
   * @param categoryAxisLabel The label for the category axis.
   * @param valueAxisLabel The label for the value axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
26
  public static JFreeChart createVerticalBarChart3D(String title, String categoryAxisLabel,
                          String valueAxisLabel, CategoryDataset data,
                          boolean legend) {

    JFreeChart chart = null;

    try {
      Axis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);
      Axis valueAxis = new VerticalNumberAxis3D(valueAxisLabel);
      VerticalBarPlot plot = new VerticalBarPlot3D(categoryAxis, valueAxis);
      // the insets here are a workaround for the fact that the plot area is no longer a
      // rectangle, so it is overlapping the title.  To be fixed...
      plot.setInsets(new Insets(20, 2, 2, 2));
      plot.setRenderer(new VerticalBarRenderer3D());
      chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
    }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createVerticalBarChart3D(...) : axis not compatible.");
    }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createVerticalBarChart3D(...) : plot not compatible.");
    }

    return chart;
###
2752, createStackedVerticalBarChart3D, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 170, 197
11
/**
   * Creates a stacked vertical bar chart with default settings.  This is still experimental at
   * this point!
   * <P>
   * Added by Serge V. Grachov.
   * @param title The chart title.
   * @param categoryAxisLabel The label for the category axis.
   * @param valueAxisLabel The label for the value axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
28
  public static JFreeChart createStackedVerticalBarChart3D(String title, String categoryAxisLabel,
                            String valueAxisLabel, CategoryDataset data,
                            boolean legend) {

    JFreeChart chart = null;

    try {
      Axis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);
      Axis valueAxis = new VerticalNumberAxis3D(valueAxisLabel);
      VerticalBarPlot plot = new VerticalBarPlot3D(categoryAxis, valueAxis);
      // the insets here are a workaround for the fact that the plot area is no longer a
      // rectangle, so it is overlapping the title.  To be fixed...
      plot.setInsets(new Insets(20, 2, 2, 2));
      plot.setRenderer(new StackedVerticalBarRenderer3D());
      chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
    }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println(
        "ChartFactory.createStackedVerticalBarChart3D(...) : axis not compatible.");
    }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println(
        "ChartFactory.createStackedVerticalBarChart3D(...) : plot not compatible.");
    }

    return chart;
###
2753, createTimeSeriesChart, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 410, 433
12
/**
   * Creates and returns a time series chart.  A time series chart is an XYPlot with a date
   * axis (horizontal) and a number axis (vertical), and each data item is connected with a line.
   * <P>
   * Note that you can supply a TimeSeriesDataset to this method as it is a subclass of
   * XYDataset.
   * @param title The chart title.
   * @param timeAxisLabel A label for the time axis.
   * @param valueAxisLabel A label for the value axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
24
  public static JFreeChart createTimeSeriesChart(String title, String timeAxisLabel,
                           String valueAxisLabel, XYDataset data,
                           boolean legend) {

    JFreeChart chart = null;

  try {
      Axis timeAxis = new HorizontalDateAxis(timeAxisLabel);
    NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);
      valueAxis.setAutoRangeIncludesZero(false);  // override default
    XYPlot plot = new XYPlot(timeAxis, valueAxis);
      plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));
    chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
  }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createTimeSeriesChart(...) : axis not compatible.");
  }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createTimeSeriesChart(...) : axis not compatible.");
  }

    return chart;
###
2754, createHorizontalBarChart, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 209, 230
8
/**
   * Creates a horizontal bar chart with default settings.
   * @param title The chart title.
   * @param categoryAxisLabel The label for the category axis.
   * @param valueAxisLabel The label for the value axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
22
  public static JFreeChart createHorizontalBarChart(String title, String categoryAxisLabel,
                            String valueAxisLabel, CategoryDataset data,
                            boolean legend) {

    JFreeChart chart = null;

    try {
    Axis categoryAxis = new VerticalCategoryAxis(categoryAxisLabel);
    Axis valueAxis = new HorizontalNumberAxis(valueAxisLabel);
    Plot plot = new HorizontalBarPlot(valueAxis, categoryAxis);
    chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
  }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createHorizontalBarChart(...) : axis not compatible.");
    }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createHorizontalBarChart(...) : plot not compatible.");
    }

    return chart;
###
2755, createScatterPlot, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 373, 394
8
/**
   * Creates a scatter plot with default settings.
   * @param title The chart title.
   * @param xAxisLabel A label for the X-axis.
   * @param yAxisLabel A label for the Y-axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
22
  public static JFreeChart createScatterPlot(String title, String xAxisLabel, String yAxisLabel,
                         XYDataset data, boolean legend) {

    JFreeChart chart = null;

  try {
      Axis xAxis = new HorizontalNumberAxis(xAxisLabel);
    Axis yAxis = new VerticalNumberAxis(yAxisLabel);
      XYPlot plot = new XYPlot(xAxis, yAxis);
      plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.SHAPES));
    chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
  }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createScatterPlot(...) : axis not compatible.");
  }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println("ChartFactory.createScatterPlot(...) : plot not compatible.");
  }

    return chart;
###
2756, createStackedVerticalBarChart, ChartFactory, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ChartFactory.java, 131, 155
9
/**
   * Creates a stacked vertical bar chart with default settings.  This is still experimental at
   * this point!
   * @param title The chart title.
   * @param categoryAxisLabel The label for the category axis.
   * @param valueAxisLabel The label for the value axis.
   * @param data The dataset for the chart.
   * @param legend A flag specifying whether or not a legend is required.
   */
25
  public static JFreeChart createStackedVerticalBarChart(String title, String categoryAxisLabel,
                             String valueAxisLabel, CategoryDataset data,
                             boolean legend) {

    JFreeChart chart = null;

    try {
      Axis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);
      Axis valueAxis = new VerticalNumberAxis(valueAxisLabel);
      VerticalBarPlot plot = new VerticalBarPlot(categoryAxis, valueAxis);
      plot.setRenderer(new StackedVerticalBarRenderer());
      chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);
    }
  catch (AxisNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println(
        "ChartFactory.createStackedVerticalBarChart(...) : axis not compatible.");
    }
  catch (PlotNotCompatibleException e) {
      // this won't happen unless you mess with the axis constructors above
    System.err.println(
        "ChartFactory.createStackedVerticalBarChart(...) : plot not compatible.");
    }

    return chart;
###
2757, setTrailGapPercent, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 202, 205
5
/**
   * Sets the gap after the last bar on the chart, and notifies registered listeners that the plot
   * has been modified.
   * @param percent The new gap value.
   */
4
  public void setTrailGapPercent(double percent) {
  if (this.trailGapPercent!=percent) {
      trailGapPercent = Math.min(percent, MAX_TRAIL_GAP_PERCENT);
    notifyListeners(new PlotChangeEvent(this));
###
2758, BarPlot, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 123, 131
3
/**
   * Constructs a bar plot with the specified axes...other attributes take default values.
   */
9
  public BarPlot(Axis horizontalAxis, Axis verticalAxis) throws AxisNotCompatibleException,
                                  PlotNotCompatibleException
  {
  this(horizontalAxis, verticalAxis,
       new Insets(2, 2, 2, 2),
       DEFAULT_INTRO_GAP_PERCENT,
       DEFAULT_TRAIL_GAP_PERCENT,
       DEFAULT_CATEGORY_GAPS_PERCENT,
       DEFAULT_ITEM_GAPS_PERCENT);
###
2759, getItemGapsPercent, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 233, 234
4
/**
   * Returns the gap between one bar and the next within the same category, measured in Java 2D
   * User Space units.
   */
2
  public double getItemGapsPercent() {
  return itemGapsPercent;
###
2760, setIntroGapPercent, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 182, 185
5
/**
   * Sets the gap before the first bar on the chart, and notifies registered listeners that the
   * plot has been modified.
   * @param percent The new gap value.
   */
4
  public void setIntroGapPercent(double percent) {
  if (this.introGapPercent!=percent) {
      this.introGapPercent = Math.min(percent, MAX_INTRO_GAP_PERCENT);
    notifyListeners(new PlotChangeEvent(this));
###
2761, setVerticalAxis, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 148, 149
6
/**
   * Sets the vertical axis for the plot.
   * <P>
   * This method should throw an exception if the axis doesn't implement the required interfaces.
   * @param axis The new vertical axis.
   */
2
  public void setVerticalAxis(Axis axis) throws AxisNotCompatibleException {
  super.setVerticalAxis(axis);
###
2762, setCategoryGapsPercent, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 222, 225
5
/**
   * Sets the gap between the last bar in one category and the first bar in the
   * next category, and notifies registered listeners that the plot has been modified.
   * @param gap The new gap value.
   */
4
  public void setCategoryGapsPercent(double percent) {
  if (this.categoryGapsPercent!=percent) {
      this.categoryGapsPercent=Math.min(percent, MAX_CATEGORY_GAPS_PERCENT);
    notifyListeners(new PlotChangeEvent(this));
###
2763, getIntroGapPercent, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 173, 174
4
/**
   * Returns the gap before the first bar on the chart, as a percentage of the available drawing
   * space (0.05 = 5 percent).
   */
2
  public double getIntroGapPercent() {
  return introGapPercent;
###
2764, setHorizontalAxis, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 158, 159
6
/**
   * Sets the horizontal axis for the plot.
   * <P>
   * This method should throw an exception if the axis doesn't implement the required interfaces.
   * @param axis The new horizontal axis.
   */
2
  public void setHorizontalAxis(Axis axis) throws AxisNotCompatibleException {
  super.setHorizontalAxis(axis);
###
2765, BarPlot, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 107, 117
12
/**
   * Standard constructor: returns a BarPlot with attributes specified by the caller.
   * @param horizontal The horizontal axis;
   * @param vertical The vertical axis;
   * @param introGapPercent The gap before the first bar in the plot, as a percentage of the
   *            available drawing space;
   * @param trailGapPercent The gap after the last bar in the plot, as a percentage of the
   *            available drawing space;
   * @param categoryGapsPercent The percentage of drawing space allocated to the gap between the
   *               last bar in one category and the first bar in the next category;
   * @param itemGapsPercent The gap between bars within the same category;
   */
11
  public BarPlot(Axis horizontal, Axis vertical, Insets insets,
       double introGapPercent, double trailGapPercent,
           double categoryGapsPercent, double itemGapsPercent)
      throws AxisNotCompatibleException, PlotNotCompatibleException {

  super(horizontal, vertical);
  this.insets = insets;
  this.introGapPercent = introGapPercent;
  this.trailGapPercent = trailGapPercent;
  this.categoryGapsPercent = categoryGapsPercent;
  this.itemGapsPercent = itemGapsPercent;
###
2766, getDataset, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 138, 139
4
/**
   * A convenience method that returns the dataset for the plot, cast as a
   * CategoryDataset.
   */
2
  public CategoryDataset getDataset() {
  return (CategoryDataset)chart.getDataset();
###
2767, getTrailGapPercent, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 193, 194
4
/**
   * Returns the gap following the last bar on the chart, as a percentage of the available
   * drawing space.
   */
2
  public double getTrailGapPercent() {
  return trailGapPercent;
###
2768, getCategoryGapsPercent, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 213, 214
4
/**
   * Returns the percentage of the drawing space that is allocated to providing gaps between the
   * categories.
   */
2
  public double getCategoryGapsPercent() {
  return categoryGapsPercent;
###
2769, getCategories, BarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/BarPlot.java, 165, 166
3
/**
   * A convenience method that returns a list of the categories in the data source.
   */
2
  public java.util.List getCategories() {
  return getDataset().getCategories();
###
2770, setLabelFont, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 245, 255
6
/**
   * Sets the font for the axis label.
   * <P>
   * Registered listeners are notified of a general change to the axis.
   * @param font The new label font.
   */
11
  public void setLabelFont(Font font) {

    // check arguments...
    if (font==null) {
      throw new IllegalArgumentException("Axis.setLabelFont(...): null not permitted.");
    }

    // make the change (if necessary)...
  if (!this.labelFont.equals(font)) {
    this.labelFont = font;
    notifyListeners(new AxisChangeEvent(this));
###
2771, setTickMarksVisible, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 431, 435
6
/**
   * Sets the flag that indicates whether or not the tick marks are showing.
   * <P>
   * Registered listeners are notified of a general change to the axis.
   * @param flag The flag.
   */
5
  public void setTickMarksVisible(boolean flag) {

  if (flag!=tickMarksVisible) {
    tickMarksVisible = flag;
    notifyListeners(new AxisChangeEvent(this));
###
2772, getTickLabelInsets, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 394, 395
4
/**
   * Returns the insets for the tick labels.
   * @return The insets for the tick labels.
   */
2
  public Insets getTickLabelInsets() {
  return this.tickLabelInsets;
###
2775, setLabel, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 213, 225
6
/**
   * Sets the label for the axis.
   * <P>
   * Registered listeners are notified of a general change to the axis.
   * @param label The new label for the axis (null permitted).
   */
13
  public void setLabel(String label) {

    String existing = this.label;
    if (existing!=null) {
    if (!existing.equals(label)) {
      this.label = label;
      notifyListeners(new AxisChangeEvent(this));
    }
    }
    else {
      if (label!=null) {
      this.label = label;
      notifyListeners(new AxisChangeEvent(this));
###
2776, setTickLabelFont, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 346, 356
6
/**
   * Sets the font for the tick labels.
   * <P>
   * Registered listeners are notified of a general change to the axis.
   * @param font The new tick label font.
   */
11
  public void setTickLabelFont(Font font) {

    // check arguments...
    if (font==null) {
      throw new IllegalArgumentException("Axis.setTickLabelFont(...): null not permitted.");
    }

    // apply change if necessary...
  if (!this.tickLabelFont.equals(font)) {
    this.tickLabelFont = font;
    notifyListeners(new AxisChangeEvent(this));
###
2777, setTickMarkStroke, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 454, 464
6
/**
   * Sets the pen/brush used to draw tick marks (if they are showing).
   * <P>
   * Registered listeners are notified of a general change to the axis.
   * @param stroke The new pen/brush (null not permitted).
   */
11
  public void setTickMarkStroke(Stroke stroke) {

    // check arguments...
    if (stroke==null) {
      throw new IllegalArgumentException("Axis.setTickMarkStroke(...): null not permitted.");
    }

    // make the change (if necessary)...
  if (!this.tickMarkStroke.equals(stroke)) {
    this.tickMarkStroke = stroke;
    notifyListeners(new AxisChangeEvent(this));
###
2778, getLabel, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 203, 204
4
/**
   * Returns the label for the axis.
   * @return The label for the axis (null possible).
   */
2
  public String getLabel() {
  return label;
###
2779, isTickLabelsVisible, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 313, 314
4
/**
   * Returns a flag indicating whether or not the tick labels are visible.
   * @return A flag indicating whether or not the tick labels are visible.
   */
2
  public boolean isTickLabelsVisible() {
  return tickLabelsVisible;
###
2780, addChangeListener, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 539, 540
4
/**
   * Registers an object for notification of changes to the axis.
   * @param listener The object that is being registered.
   */
2
  public void addChangeListener(AxisChangeListener listener) {
  listeners.add(listener);
###
2781, getLabelInsets, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 293, 294
4
/**
   * Returns the insets for the label (that is, the amount of blank space that should be left
   * around the label).
   */
2
  public Insets getLabelInsets() {
  return this.labelInsets;
###
2782, getTickMarkStroke, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 444, 445
4
/**
   * Returns the pen/brush used to draw tick marks (if they are showing).
   * @return The pen/brush used to draw tick marks.
   */
2
  public Stroke getTickMarkStroke() {
  return tickMarkStroke;
###
2783, isTickMarksVisible, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 421, 422
4
/**
   * Returns the flag that indicates whether or not the tick marks are showing.
   * @return The flag that indicates whether or not the tick marks are showing.
   */
2
  public boolean isTickMarksVisible() {
  return tickMarksVisible;
###
2784, notifyListeners, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 527, 531
5
/**
   * Notifies all registered listeners that the axis has changed.  The AxisChangeEvent provides
   * information about the change.
   * @param event Information about the change to the axis.
   */
5
  protected void notifyListeners(AxisChangeEvent event) {
  java.util.Iterator iterator = listeners.iterator();
  while (iterator.hasNext()) {
    AxisChangeListener listener = (AxisChangeListener)iterator.next();
    listener.axisChanged(event);
###
2786, drawVerticalString, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 558, 567
7
/**
   * A utility method for drawing text vertically.
   * @param text The text.
   * @param g2 The graphics device.
   * @param x The x-coordinate.
   * @param y The y-coordinate.
   */
10
  protected void drawVerticalString(String text, Graphics2D g2, float x, float y) {

  AffineTransform saved = g2.getTransform();

  // apply a 90 degree rotation
  AffineTransform rotate = AffineTransform.getRotateInstance(-Math.PI/2, x, y);
  g2.transform(rotate);
  g2.drawString(text, x, y);

  g2.setTransform(saved);
###
2787, Axis, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 131, 149
13
/**
   * Constructs an axis.
   * @param label The axis label.
   * @param labelFont The font for displaying the axis label.
   * @param labelPaint The paint used to draw the axis label.
   * @param labelInsets Determines the amount of blank space around the label.
   * @param tickLabelsVisible Flag indicating whether or not the tick labels are visible.
   * @param tickLabelFont The font used to display tick labels.
   * @param tickLabelPaint The paint used to draw tick labels.
   * @param tickLabelInsets Determines the amount of blank space around tick labels.
   * @param tickMarksVisible Flag indicating whether or not tick marks are visible.
   * @param tickMarkStroke The stroke used to draw tick marks (if visible).
   */
19
  protected Axis(String label,
           Font labelFont, Paint labelPaint, Insets labelInsets,
       boolean tickLabelsVisible,
           Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,
       boolean tickMarkVisible, Stroke tickMarkStroke) {

  this.label = label;
  this.labelFont = labelFont;
  this.labelPaint = labelPaint;
  this.labelInsets = labelInsets;
  this.tickLabelsVisible = tickLabelsVisible;
  this.tickLabelFont = tickLabelFont;
  this.tickLabelPaint = tickLabelPaint;
  this.tickLabelInsets = tickLabelInsets;
  this.tickMarksVisible = tickMarksVisible;
  this.tickMarkStroke = tickMarkStroke;

  this.ticks = new java.util.ArrayList();
  this.listeners = new java.util.ArrayList();
###
2788, getLabelFont, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 235, 236
4
/**
   * Returns the font for the axis label.
   * @return The font for the axis label.
   */
2
  public Font getLabelFont() {
  return labelFont;
###
2790, getMaxTickLabelWidth, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 497, 511
6
/**
   * Returns the maximum width of the ticks in the working list (that is set up by
   * refreshTicks()).
   * @param g2 The graphics device.
   * @param plotArea The area within which the plot is to be drawn.
   */
15
  protected double getMaxTickLabelWidth(Graphics2D g2, Rectangle2D plotArea) {

  double maxWidth = 0.0;
  Font font = getTickLabelFont();
  FontRenderContext frc = g2.getFontRenderContext();

  Iterator iterator = this.ticks.iterator();
  while (iterator.hasNext()) {
    Tick tick = (Tick)iterator.next();
    Rectangle2D labelBounds = font.getStringBounds(tick.getText(), frc);
    if (labelBounds.getWidth()>maxWidth) {
    maxWidth = labelBounds.getWidth();
    }
  }
  return maxWidth;
###
2791, removeChangeListener, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 547, 548
4
/**
   * Deregisters an object for notification of changes to the axis.
   * @param listener The object to deregister.
   */
2
  public void removeChangeListener(AxisChangeListener listener) {
  listeners.remove(listener);
###
2792, getPlot, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 178, 179
6
/**
   * Returns the plot that the axis is assigned to.
   * <P>
   * This method will return null if the axis is not currently assigned to a plot.
   * @return The plot that the axis is assigned to.
   */
2
  public Plot getPlot() {
  return plot;
###
2793, getTickLabelPaint, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 365, 366
4
/**
   * Returns the color/shade used for the tick labels.
   * @return The color/shade used for the tick labels.
   */
2
  public Paint getTickLabelPaint() {
  return this.tickLabelPaint;
###
2794, setLabelPaint, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 274, 284
6
/**
   * Sets the color/shade used to draw the axis label.
   * <P>
   * Registered listeners are notified of a general change to the axis.
   * @param paint The new color/shade for the axis label.
   */
11
  public void setLabelPaint(Paint paint) {

    // check arguments...
    if (paint==null) {
      throw new IllegalArgumentException("Axis.setLabelPaint(...): null not permitted.");
    }

    // make the change (if necessary)...
  if (!this.labelPaint.equals(paint)) {
    this.labelPaint = paint;
    notifyListeners(new AxisChangeEvent(this));
###
2795, setTickLabelInsets, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 403, 413
5
/**
   * Sets the insets for the tick labels, and notifies registered listeners that the axis has
   * been modified.
   * @param insets The new tick label insets.
   */
11
  public void setTickLabelInsets(Insets insets) {

    // check arguments...
    if (insets==null) {
      throw new IllegalArgumentException("Axis.setTickLabelInsets(...): null not permitted.");
    }

    // apply change if necessary...
  if (!this.tickLabelInsets.equals(insets)) {
    this.tickLabelInsets = insets;
    notifyListeners(new AxisChangeEvent(this));
###
2796, getLabelPaint, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 264, 265
4
/**
   * Returns the color/shade used to draw the axis label.
   * @return The color/shade used to draw the axis label.
   */
2
  public Paint getLabelPaint() {
  return this.labelPaint;
###
2797, setLabelInsets, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 302, 305
5
/**
   * Sets the insets for the axis label, and notifies registered listeners that the axis has been
   * modified.
   * @param insets The new label insets;
   */
4
  public void setLabelInsets(Insets insets) {
  if (!insets.equals(this.labelInsets)) {
    this.labelInsets = insets;
    notifyListeners(new AxisChangeEvent(this));
###
2798, Axis, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 157, 168
4
/**
   * Constructs an axis, using default values where necessary.
   * @param label The axis label (null permitted).
   */
12
  protected Axis(String label) {

  this(label,
       DEFAULT_AXIS_LABEL_FONT,
       DEFAULT_AXIS_LABEL_PAINT,
       DEFAULT_AXIS_LABEL_INSETS,
       true,  // tick labels visible
       DEFAULT_TICK_LABEL_FONT,
       DEFAULT_TICK_LABEL_PAINT,
       DEFAULT_TICK_LABEL_INSETS,
       true,  // tick marks visible
       DEFAULT_TICK_STROKE);
###
2799, setPlot, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 189, 195
7
/**
   * Sets a reference to the plot that the axis is assigned to.
   * <P>
   * This method is called by Plot in the setHorizontalAxis() and setVerticalAxis() methods.
   * You shouldn't need to call the method yourself.
   * @param plot The plot that the axis belongs to.
   */
7
  public void setPlot(Plot plot) throws PlotNotCompatibleException {

    if (this.isCompatiblePlot(plot)) {
    this.plot = plot;
    }
    else throw new PlotNotCompatibleException("Axis.setPlot(...): "
                         +"plot not compatible with axis.");
###
2800, setTickLabelsVisible, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 323, 327
6
/**
   * Sets the flag that determines whether or not the tick labels are visible.
   * <P>
   * Registered listeners are notified of a general change to the axis.
   * @param flag The flag.
   */
5
  public void setTickLabelsVisible(boolean flag) {

  if (flag!=tickLabelsVisible) {
    tickLabelsVisible = flag;
    notifyListeners(new AxisChangeEvent(this));
###
2801, getTickLabelFont, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 336, 337
4
/**
   * Returns the font used for the tick labels (if showing).
   * @return The font used for the tick labels.
   */
2
  public Font getTickLabelFont() {
  return tickLabelFont;
###
2802, setTickLabelPaint, Axis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Axis.java, 375, 385
6
/**
   * Sets the color/shade used to draw tick labels (if they are showing).
   * <P>
   * Registered listeners are notified of a general change to the axis.
   * @param paint The new color/shade.
   */
11
  public void setTickLabelPaint(Paint paint) {

    // check arguments...
    if (paint==null) {
      throw new IllegalArgumentException("Axis.setTickLabelPaint(...): null not permitted.");
    }

    // make the change (if necessary)...
  if (!this.tickLabelPaint.equals(paint)) {
    this.tickLabelPaint = paint;
    notifyListeners(new AxisChangeEvent(this));
###
2803, getFillPaint, Bar, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Bar.java, 116, 117
4
/**
   * Returns the Paint object used to fill the bar.
   * @return The Paint used to fill the bar.
   */
2
  public Paint getFillPaint() {
  return fillPaint;
###
2804, Bar, Bar, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Bar.java, 84, 85
7
/**
   * Standard constructor: returns a new Bar object, with some default attributes.
   * @param x The x-coordinate of the bar;
   * @param y The y-coordinate of the bar;
   * @param width The width of the bar;
   * @param height The height of the bar;
   */
2
  public Bar(double x, double y, double width, double height) {
  this(x, y, width, height, new BasicStroke(), Color.gray, Color.green);
###
2805, getArea, Bar, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Bar.java, 92, 93
4
/**
   * Returns the rectangle that is the outline of the bar.
   * @return The outline of the bar;
   */
2
  public Rectangle2D getArea() {
  return area;
###
2806, getOutlinePaint, Bar, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Bar.java, 108, 109
4
/**
   * Returns the Paint object used to draw the outline of the bar.
   * @return The Paint used to draw the outline of the bar.
   */
2
  public Paint getOutlinePaint() {
  return outlinePaint;
###
2807, Bar, Bar, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Bar.java, 68, 74
10
/**
   * Full constructor: returns a new Bar object with attributes as defined by the caller.
   * @param x The x-coordinate of the bar;
   * @param y The y-coordinate of the bar;
   * @param width The width of the bar;
   * @param height The height of the bar;
   * @param outlineStroke The Stroke used to draw the outline of the bar;
   * @param outlinePaint The Paint used to draw the outline of the bar;
   * @param fillPaint The Paint used to draw the interior of the bar.
   */
7
  public Bar(double x, double y, double width, double height,
       Stroke outlineStroke, Paint outlinePaint, Paint fillPaint)
  {
  this.area = new Rectangle2D.Double(x, y, width, height);
  this.outlineStroke = outlineStroke;
  this.outlinePaint = outlinePaint;
  this.fillPaint = fillPaint;
###
2808, getOutlineStroke, Bar, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Bar.java, 100, 101
4
/**
   * Returns the Stroke object used to draw the outline of the bar.
   * @return The Stroke used to draw the outline of the bar.
   */
2
  public Stroke getOutlineStroke() {
  return outlineStroke;
###
2811, CategoryAxis, CategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/CategoryAxis.java, 63, 69
13
/**
   * Standard constructor: returns a new CategoryAxis with attributes as specified by the
   * caller.
   * @param label The axis label;
   * @param labelFont The font for displaying the axis label;
   * @param labelPaint The paint used to draw the axis label;
   * @param labelInsets Determines the amount of blank space around the label;
   * @param showCategoryLabels Flag indicating whether or not category (tick) labels are visible;
   * @param categoryLabelFont The font used to display category (tick) labels;
   * @param categoryLabelPaint The paint used to draw category (tick) labels;
   * @param showTickMarks Flag indicating whether or not tick marks are visible;
   * @param tickMarkStroke The stroke used to draw tick marks (if visible).
   */
7
  public CategoryAxis(String label, Font labelFont, Paint labelPaint, Insets labelInsets,
      boolean showCategoryLabels, Font categoryLabelFont, Paint categoryLabelPaint,
      Insets categoryLabelInsets, boolean showTickMarks, Stroke tickMarkStroke) {

  super(label, labelFont, labelPaint, labelInsets,
      showCategoryLabels, categoryLabelFont, categoryLabelPaint, categoryLabelInsets,
      showTickMarks, tickMarkStroke);
###
2812, getMinimumDate, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 121, 122
4
/**
   * Returns the earliest date visible on the axis.
   * @return The earliest date visible on the axis.
   */
2
  public Date getMinimumDate() {
  return this.minimumDate;
###
2813, getMaximumDate, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 138, 139
4
/**
   * Returns the latest date visible on the axis.
   * @return The latest date visible on the axis.
   */
2
  public Date getMaximumDate() {
  return this.maximumDate;
###
2814, nextStandardDate, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 268, 273
3
/**
   * Returns the first "standard" date (based on the specified field and units).
   */
6
  protected Date nextStandardDate(Date date, int field, int units) {
  Date previous = previousStandardDate(date, field, units);
  Calendar calendar = Calendar.getInstance();
  calendar.setTime(previous);
  calendar.add(field, units);
  return calendar.getTime();
###
2815, setTickUnit, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 162, 164
3
/**
   * Sets the tick unit for the axis.
   */
3
  public void setTickUnit(DateUnit unit) {
  this.tickUnit = unit;
  this.notifyListeners(new AxisChangeEvent(this));
###
2816, DateAxis, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 87, 102
24
/**
   * Full constructor - initialises the attributes for a ValueAxis.  This is an abstract class,
   * subclasses include HorizontalValueAxis and VerticalValueAxis.
   * @param label The axis label;
   * @param labelFont The font for displaying the axis label;
   * @param labelPaint The paint used to draw the axis label;
   * @param labelInsets Determines the amount of blank space around the label;
   * @param showTickLabels Flag indicating whether or not tick labels are visible;
   * @param tickLabelFont The font used to display tick labels;
   * @param tickLabelPaint The paint used to draw tick labels;
   * @param tickLabelInsets Determines the amount of blank space around tick labels;
   * @param showTickMarks Flag indicating whether or not tick marks are visible;
   * @param tickMarkStroke The stroke used to draw tick marks (if visible);
   * @param autoRange Flag indicating whether or not the axis range is automatically adjusted to
   *          fit the data;
   * @param minimumDate The earliest date showing on the axis;
   * @param maximumDate The latest date showing on the axis;
   * @param autoTickUnit A flag indicating whether or not the tick unit is automatically
   *            calculated;
   * @param tickUnit The tick unit;
   * @param showGridLines Flag indicating whether or not grid lines are visible for this axis;
   * @param gridStroke The Stroke used to display grid lines (if visible);
   * @param gridPaint The Paint used to display grid lines (if visible).
   */
16
  public DateAxis(String label, Font labelFont, Paint labelPaint, Insets labelInsets,
      boolean showTickLabels, Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,
      boolean showTickMarks, Stroke tickMarkStroke,
      boolean autoRange, Date minimumDate, Date maximumDate,
      boolean autoTickUnit, DateUnit tickUnit, SimpleDateFormat tickLabelFormatter,
      boolean showGridLines, Stroke gridStroke, Paint gridPaint) {

  super(label, labelFont, labelPaint, labelInsets,
      showTickLabels, tickLabelFont, tickLabelPaint, tickLabelInsets,
      showTickMarks, tickMarkStroke, autoRange,
      autoTickUnit, showGridLines, gridStroke, gridPaint);

  this.minimumDate = minimumDate;
  this.maximumDate = maximumDate;
  this.tickUnit = tickUnit;
  this.tickLabelFormatter = tickLabelFormatter;
###
2817, setMaximumDate, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 146, 148
4
/**
   * Sets the maximum date visible on the axis.
   * @param maximumDate The new maximum date;
   */
3
  public void setMaximumDate(Date maximumDate) {
  this.maximumDate = maximumDate;
  this.notifyListeners(new AxisChangeEvent(this));
###
2818, setMinimumDate, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 129, 131
4
/**
   * Sets the minimum date visible on the axis.
   * @param minimumDate The new minimum date;
   */
3
  public void setMinimumDate(Date minimumDate) {
  this.minimumDate = minimumDate;
  this.notifyListeners(new AxisChangeEvent(this));
###
2819, DateAxis, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 109, 114
3
/**
   * Standard constructor: builds a DateAxis with mostly default attributes.
   */
6
  public DateAxis(String label) {
  super(label);
  this.minimumDate = new Date();
  this.maximumDate = new Date();
  this.tickUnit = new DateUnit(Calendar.DATE, 1);
  this.tickLabelFormatter = new SimpleDateFormat();
###
2820, findAxisMagnitudeIndex, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 279, 286
3
/**
   * Returns the index of the largest tick unit that will fit within the axis range.
   */
8
  protected int findAxisMagnitudeIndex() {
  long axisMagnitude = this.maximumDate.getTime()-this.minimumDate.getTime();
  int index = 0;
  while(index<standardTickUnitMagnitudes.length-1) {
    if (axisMagnitude<standardTickUnitMagnitudes[index]) break;
    index++;
  }
  return Math.max(0, index-1);
###
2821, getTickLabelFormatter, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 170, 171
3
/**
   * Returns the format object used to format tick labels.
   */
2
  public SimpleDateFormat getTickLabelFormatter() {
  return tickLabelFormatter;
###
2822, previousStandardDate, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 191, 260
3
/**
   * Returns the previous "standard" date (based on the specified field and units).
   */
70
  protected Date previousStandardDate(Date date, int field, int units) {
  int milliseconds;
  int seconds;
  int minutes;
  int hours;
  int days;
  int months;
  int years;
  Calendar calendar = Calendar.getInstance();
  calendar.setTime(date);
  int current = calendar.get(field);
  int value = units*(current/units);
  switch (field) {

  case(Calendar.MILLISECOND) : {
    calendar.set(Calendar.MILLISECOND, value);
  }

  case(Calendar.SECOND)    : {
    years = calendar.get(Calendar.YEAR);
    months = calendar.get(Calendar.MONTH);
    days = calendar.get(Calendar.DATE);
    hours = calendar.get(Calendar.HOUR_OF_DAY);
    minutes = calendar.get(Calendar.MINUTE);
    calendar.clear(Calendar.MILLISECOND);
    calendar.set(years, months, days, hours, minutes, value);
    return calendar.getTime();
  }

  case(Calendar.MINUTE)    : {
    years = calendar.get(Calendar.YEAR);
    months = calendar.get(Calendar.MONTH);
    days = calendar.get(Calendar.DATE);
    hours = calendar.get(Calendar.HOUR_OF_DAY);
    calendar.clear(Calendar.MILLISECOND);
    calendar.set(years, months, days, hours, value, 0);
    return calendar.getTime();
  }

  case(Calendar.HOUR_OF_DAY)    : {
    years = calendar.get(Calendar.YEAR);
    months = calendar.get(Calendar.MONTH);
    days = calendar.get(Calendar.DATE);
    calendar.clear(Calendar.MILLISECOND);
    calendar.set(years, months, days, value, 0, 0);
    return calendar.getTime();
  }

  case(Calendar.DATE)    : {
    years = calendar.get(Calendar.YEAR);
    months = calendar.get(Calendar.MONTH);
    calendar.clear(Calendar.MILLISECOND);
    calendar.set(years, months, value, 0, 0, 0);
    return calendar.getTime();
  }

  case(Calendar.MONTH)     : {
    years = calendar.get(Calendar.YEAR);
    calendar.clear(Calendar.MILLISECOND);
    calendar.set(years, value, 1, 0, 0, 0);
    return calendar.getTime();
  }

  case(Calendar.YEAR)    : {
    calendar.clear(Calendar.MILLISECOND);
    calendar.set(value, 0, 1, 0, 0, 0);
    return calendar.getTime();
  }

  default: return null;
###
2823, calculateHighestVisibleTickValue, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 184, 185
3
/**
   * Calculates and returns the value of the highest visible tick on the axis.
   */
2
  public Date calculateHighestVisibleTickValue(DateUnit unit) {
  return this.previousStandardDate(maximumDate, unit.getField(), unit.getCount());
###
2824, getTickUnit, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 155, 156
4
/**
   * Returns the tick unit for the axis;
   * @return The tick unit for the axis.
   */
2
  public DateUnit getTickUnit() {
  return tickUnit;
###
2825, calculateLowestVisibleTickValue, DateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateAxis.java, 177, 178
3
/**
   * Calculates and returns the value of the lowest visible tick on the axis.
   */
2
  public Date calculateLowestVisibleTickValue(DateUnit unit) {
  return this.nextStandardDate(minimumDate, unit.getField(), unit.getCount());
###
2828, AbstractTitle, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 159, 160
11
/**
   * Standard constrcutor - builds an abstract title with the specified position and alignment,
   * with a default inset of 2 pixels around the title.  This class defines constants for the valid
   * position and alignment values---an IllegalArgumentException will be thrown if invalid values
   * are passed to this constructor.
   * @param position The relative position of the title (TOP, BOTTOM, RIGHT and LEFT---or NORTH,
   *         SOUTH, EAST and WEST if you prefer);
   * @param horizontalAlignment The horizontal alignment of the title (LEFT, CENTER or RIGHT);
   * @param verticalAlignment The vertical alignment of the title (TOP, MIDDLE or BOTTOM);
   * @exception IllegalArgumentException If an invalid location or alignment value is passed;
   */
2
  protected AbstractTitle(int position, int horizontalAlignment, int verticalAlignment) {
    this(position, horizontalAlignment, verticalAlignment, new Insets(2, 2, 2, 2));
###
2829, addChangeListener, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 321, 322
4
/**
   * Registers an object for notification of changes to the title.
   * @param listener The object that is being registered;
   */
2
  public void addChangeListener(TitleChangeListener listener) {
    listeners.add(listener);
###
2830, removeChangeListener, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 329, 330
4
/**
   * Unregisters an object for notification of changes to the chart title.
   * @param listener The object that is being unregistered;
   */
2
  public void removeChangeListener(TitleChangeListener listener) {
    listeners.remove(listener);
###
2831, setNotify, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 205, 206
5
/**
   * Sets the flag that indicates whether or not the notification mechanism is enabled.  There are
   * certain situations (such as cloning) where you want to turn notification off temporarily.
   * @param flag A boolean that indicates whether or not the notification mechanism is enabled;
   */
2
  public void setNotify(boolean flag) {
    this.notify = flag;
###
2832, setPosition, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 224, 228
5
/**
   * Sets the position for the title.
   * @param position The relative position of the title (use one of the constants TOP, BOTTOM,
   *         RIGHT and LEFT, or the equivalent NORTH, SOUTH, EAST and WEST);
   */
5
  public void setPosition(int position) {
    if (this.position!=position) {
      // check that the position is valid
      this.position = position;
      notifyListeners(new TitleChangeEvent(this));
###
2833, setInsets, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 287, 290
4
/**
   * Sets the insets for the title, and notifies registered listeners of the change.
   * @param insets The new insets value;
   */
4
  public void setInsets(Insets insets) {
    if (!this.insets.equals(insets)) {
      this.insets = insets;
      notifyListeners(new TitleChangeEvent(this));
###
2834, getNotify, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 196, 197
4
/**
   * Returns the flag that indicates whether or not the notification mechanism is enabled.
   * @return A boolean that indicates whether or not the notification mechanism is enabled;
   */
2
  public boolean getNotify() {
    return this.notify;
###
2835, setHorizontalAlignment, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 247, 250
6
/**
   * Sets the horizontal alignment for the title, and notifies any registered listeners of the
   * change.  The constants LEFT, CENTER and RIGHT (defined in this class) can be used to specify
   * the alignment.
   * @param alignment The new horizontal alignment (LEFT, CENTER or RIGHT).
   */
4
  public void setHorizontalAlignment(int alignment) {
    if (this.horizontalAlignment!=alignment) {
      this.horizontalAlignment = alignment;
      notifyListeners(new TitleChangeEvent(this));
###
2837, getPosition, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 215, 216
6
/**
   * Returns the relative position of the title---represented by one of four integer constants
   * defined in this class: TOP, BOTTOM, RIGHT or LEFT (or the equivalent NORTH, SOUTH, EAST and
   * WEST).
   * @return The title position;
   */
2
  public int getPosition() {
    return this.position;
###
2838, clone, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 176, 189
5
/**
   * Returns a clone of the title. One situation when this is useful is when editing the title
   * properties - you can edit a clone, and then it is easier to cancel the changes if necessary.
   * @return A clone of the title;
   */
14
  public Object clone() {
    AbstractTitle duplicate = null;
    try {
      duplicate = (AbstractTitle)(super.clone());
    }
    catch (CloneNotSupportedException e) {
      // this should never happen because Cloneable is implemented
      throw new RuntimeException("AbstractTitle.clone()");
    }

    duplicate.setNotify(false);
    duplicate.setInsets((Insets)this.getInsets().clone());
    duplicate.setNotify(true);
    return duplicate;
###
2839, getVerticalAlignment, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 259, 260
5
/**
   * Returns the vertical alignment of the title.  The constants TOP, MIDDLE and BOTTOM (defined
   * in this class) are used.
   * @return The vertical alignment of the title (TOP, MIDDLE or BOTTOM);
   */
2
  public int getVerticalAlignment() {
    return this.verticalAlignment;
###
2840, AbstractTitle, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 167, 168
4
/**
   * Default constructor - builds an AbstractTitle positioned at the top of the page, centered
   * horizontally and vertically within its space.
   */
2
  protected AbstractTitle() {
    this(TOP, CENTER, MIDDLE);
###
2841, getHorizontalAlignment, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 237, 238
5
/**
   * Returns the horizontal alignment of the title.  The constants LEFT, CENTER and RIGHT (defined
   * in this class) are used.
   * @return The horizontal alignment of the title (LEFT, CENTER or RIGHT);
   */
2
  public int getHorizontalAlignment() {
    return this.horizontalAlignment;
###
2843, getInsets, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 279, 280
3
/**
   * Returns the insets (the blank space around the edges) for this title.
   */
2
  public Insets getInsets() {
    return this.insets;
###
2844, AbstractTitle, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 119, 145
10
/**
   * Full constructor - builds an abstract title with the specified position and alignment. This
   * class defines constants for the valid position and alignment values---an
   * IllegalArgumentException will be thrown if invalid values are passed to this constructor.
   * @param position The relative position of the title (TOP, BOTTOM, RIGHT and LEFT---or NORTH,
   *         SOUTH, EAST and WEST if you prefer);
   * @param horizontalAlignment The horizontal alignment of the title (LEFT, CENTER or RIGHT);
   * @param verticalAlignment The vertical alignment of the title (TOP, MIDDLE or BOTTOM);
   * @exception IllegalArgumentException If an invalid location or alignment value is passed;
   */
27
  protected AbstractTitle(int position, int horizontalAlignment, int verticalAlignment,
              Insets insets) {

    // check position
    if (!this.isValidPosition(position)) {
      throw new IllegalArgumentException("AbstractTitle: Invalid position.");
    }

    // check the horizontal and vertical alignment
    if ((horizontalAlignment!=LEFT) &&
      (horizontalAlignment!=CENTER) &&
      (horizontalAlignment!=RIGHT)) {
      throw new IllegalArgumentException("AbstractTitle: Invalid horizontal alignment.");
    }

    if ((verticalAlignment!=TOP) &&
      (verticalAlignment!=BOTTOM) &&
      (verticalAlignment!=MIDDLE)) {
      throw new IllegalArgumentException("AbstractTitle: Invalid vertical alignment.");
    }

    this.position = position;
    this.horizontalAlignment = horizontalAlignment;
    this.verticalAlignment = verticalAlignment;
    this.insets = insets;
    this.listeners = new java.util.ArrayList();
    this.notify = true;
###
2845, setVerticalAlignment, AbstractTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/AbstractTitle.java, 269, 272
6
/**
   * Sets the vertical alignment for the title, and notifies any registered listeners of the change.
   * The constants TOP, MIDDLE and BOTTOM (defined in this class) can be used to specify the
   * alignment.
   * @param alignment The new vertical alignment (TOP, MIDDLE or BOTTOM);
   */
4
  public void setVerticalAlignment(int alignment) {
    if (this.verticalAlignment!=alignment) {
      this.verticalAlignment = alignment;
      notifyListeners(new TitleChangeEvent(this));
###
2846, VerticalNumberAxis, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 165, 167
3
/**
   * Consrtucts a vertical number axis, using default values where necessary.
   */
2
  public VerticalNumberAxis() {
    this(null);
###
2847, draw, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 272, 316
6
/**
   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device;
   * @param drawArea The area within which the chart should be drawn.
   * @param plotArea The area within which the plot should be drawn (a subset of the drawArea).
   */
41
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {
  // draw the axis label
  if (this.label!=null) {
    g2.setFont(labelFont);
    g2.setPaint(labelPaint);
    Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());
    if (labelDrawnVertical) {
    double xx = drawArea.getX()+labelInsets.left+labelBounds.getHeight();
    double yy = plotArea.getY()+plotArea.getHeight()/2+(labelBounds.getWidth()/2);
    drawVerticalString(label, g2, (float)xx, (float)yy);
    }
    else {
    double xx = drawArea.getX()+labelInsets.left;
    double yy = drawArea.getY()+drawArea.getHeight()/2-labelBounds.getHeight()/2;
    g2.drawString(label, (float)xx, (float)yy);
    }
  }
  // draw the tick labels and marks and gridlines
  this.refreshTicks(g2, drawArea, plotArea);
  double xx = plotArea.getX();
  g2.setFont(tickLabelFont);
  Iterator iterator = ticks.iterator();
  while (iterator.hasNext()) {
    Tick tick = (Tick)iterator.next();
    float yy = (float)this.translatedValue(tick.getNumericalValue(), plotArea);
    if (tickLabelsVisible) {
    g2.setPaint(this.tickLabelPaint);
    g2.drawString(tick.getText(), tick.getX(), tick.getY());
    }
    if (tickMarksVisible) {
    g2.setStroke(this.getTickMarkStroke());
    Line2D mark = new Line2D.Double(plotArea.getX()-2, yy,
            plotArea.getX()+2, yy);
    g2.draw(mark);
    }
    if (showGridLines) {
    g2.setStroke(gridStroke);
    g2.setPaint(gridPaint);
    Line2D gridline = new Line2D.Double(xx, yy,
              plotArea.getMaxX(), yy);
    g2.draw(gridline);
###
2848, VerticalNumberAxis, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 85, 109
27
/**
   * Constructs a vertical number axis.
   * @param label The axis label.
   * @param labelFont The font for displaying the axis label.
   * @param labelPaint The paint used to draw the axis label.
   * @param labelInsets Determines the amount of blank space around the label.
   * @param labelDrawnVertical Flag indicating whether or not the label is drawn vertically.
   * @param tickLabelsVisible Flag indicating whether or not tick labels are visible.
   * @param tickLabelFont The font used to display tick labels.
   * @param tickLabelPaint The paint used to draw tick labels.
   * @param tickLabelInsets Determines the amount of blank space around tick labels.
   * @param showTickMarks Flag indicating whether or not tick marks are visible.
   * @param tickMarkStroke The stroke used to draw tick marks (if visible).
   * @param autoRange Flag indicating whether or not the axis is automatically scaled to fit the
   *          data.
   * @param autoRangeIncludesZero A flag indicating whether or not zero *must* be displayed on
   *                axis.
   * @param autoRangeMinimum The smallest automatic range allowed.
   * @param minimumAxisValue The lowest value shown on the axis.
   * @param maximumAxisValue The highest value shown on the axis.
   * @param autoTickUnitSelection A flag indicating whether or not the tick units are
   *                selected automatically.
   * @param tickUnit The tick unit.
   * @param showGridLines Flag indicating whether or not grid lines are visible for this axis.
   * @param gridStroke The pen/brush used to display grid lines (if visible).
   * @param gridPaint The color used to display grid lines (if visible).
   */
23
  public VerticalNumberAxis(String label,
                Font labelFont, Paint labelPaint, Insets labelInsets,
          boolean labelDrawnVertical,
          boolean tickLabelsVisible, Font tickLabelFont, Paint tickLabelPaint,
                Insets tickLabelInsets,
          boolean tickMarksVisible, Stroke tickMarkStroke,
          boolean autoRange, boolean autoRangeIncludesZero,
                Number autoRangeMinimum,
          Number minimumAxisValue, Number maximumAxisValue,
          boolean autoTickUnitSelection,
                NumberTickUnit tickUnit,
           boolean gridLinesVisible, Stroke gridStroke, Paint gridPaint) {
  super(label,
        labelFont, labelPaint, labelInsets,
        tickLabelsVisible,
        tickLabelFont, tickLabelPaint, tickLabelInsets,
        tickMarksVisible,
        tickMarkStroke,
      autoRange, autoRangeIncludesZero, autoRangeMinimum,
      minimumAxisValue, maximumAxisValue,
        autoTickUnitSelection, tickUnit,
        gridLinesVisible, gridStroke, gridPaint);
  this.labelDrawnVertical = labelDrawnVertical;
###
2849, selectAutoTickUnit, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 399, 421
7
/**
   * Selects an appropriate tick value for the axis.  The strategy is to display as many ticks as
   * possible (selected from an array of 'standard' tick units) without the labels overlapping.
   * @param g2 The graphics device;
   * @param drawArea The area in which the plot and axes should be drawn;
   * @param plotArea The area in which the plot should be drawn;
   */
18
  private void selectAutoTickUnit(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {
    // calculate the tick label height...
    FontRenderContext frc = g2.getFontRenderContext();
    double tickLabelHeight = tickLabelFont.getLineMetrics("123", frc).getHeight()
                 +this.tickLabelInsets.top+this.tickLabelInsets.bottom;
    // now find the smallest tick unit that will accommodate the labels...
  double zero = this.translatedValue(Plot.ZERO, plotArea);
    // start with the current tick unit...
    NumberTickUnit candidate1
             = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(this.tickUnit);
    double y = this.translatedValue(candidate1.getValue(), plotArea);
    double unitHeight = Math.abs(y-zero);
    // then extrapolate...
    double bestguess = (tickLabelHeight/unitHeight) * candidate1.value.doubleValue();
    NumberTickUnit guess = new NumberTickUnit(new Double(bestguess), null);
    NumberTickUnit candidate2
               = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(guess);
    this.tickUnit = candidate2;
###
2850, translatedValue, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 210, 217
5
/**
   * Translates the data value to the display coordinates (Java 2D User Space) of the chart.
   * @param dataValue The value to be plotted;
   * @param plotArea The plot area in Java 2D User Space.
   */
7
  public double translatedValue(Number dataValue, Rectangle2D plotArea) {
  double value = dataValue.doubleValue();
  double axisMin = minimumAxisValue.doubleValue();
  double axisMax = maximumAxisValue.doubleValue();
  double maxY = plotArea.getMaxY();
  double minY = plotArea.getMinY();
  return maxY - (((value - axisMin)/(axisMax - axisMin)) * (maxY - minY));
###
2851, reserveWidth, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 329, 350
6
/**
   * Returns the width required to draw the axis in the specified draw area.
   * @param g2 The graphics device;
   * @param plot A reference to the plot;
   * @param drawArea The area within which the plot should be drawn.
   */
20
  public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {
  // calculate the width of the axis label...
  double labelWidth = 0.0;
  if (label!=null) {
    Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());
    labelWidth = labelInsets.left+labelInsets.right;
    if (this.labelDrawnVertical) {
    labelWidth = labelWidth + labelBounds.getHeight();  // assume width == height before rotation
    }
    else {
    labelWidth = labelWidth + labelBounds.getWidth();
    }
  }
  // calculate the width required for the tick labels (if visible);
  double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;
  if (tickLabelsVisible) {
    this.refreshTicks(g2, drawArea, drawArea);
    tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);
  }
  return labelWidth+tickLabelWidth;
###
2852, VerticalNumberAxis, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 120, 143
7
/**
   * Constructs a vertical number axis.
   * @param label The axis label (null permitted).
   * @param labelFont The font for displaying the axis label.
   * @param minimumAxisValue The lowest value shown on the axis.
   * @param maximumAxisValue The highest value shown on the axis.
   */
23
  public VerticalNumberAxis(String label, Font labelFont,
          Number minimumAxisValue, Number maximumAxisValue) {
  this(label,
       labelFont,
       Axis.DEFAULT_AXIS_LABEL_PAINT,
       Axis.DEFAULT_AXIS_LABEL_INSETS,
       true, // vertical axis label
       true, // tick labels visible
       Axis.DEFAULT_TICK_LABEL_FONT,
       Axis.DEFAULT_TICK_LABEL_PAINT,
       Axis.DEFAULT_TICK_LABEL_INSETS,
     true, // tick marks visible
       Axis.DEFAULT_TICK_STROKE,
       true, // auto range
       true, // auto range includes zero
       NumberAxis.DEFAULT_MINIMUM_AUTO_RANGE,
     minimumAxisValue,
       maximumAxisValue,
     true, // auto tick unit selection
       NumberAxis.DEFAULT_TICK_UNIT,
     true, // grid lines visible
       ValueAxis.DEFAULT_GRID_LINE_STROKE,
       ValueAxis.DEFAULT_GRID_LINE_PAINT);
###
2853, autoAdjustRange, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 223, 260
3
/**
   * Rescales the axis to ensure that all data is visible.
   */
31
  public void autoAdjustRange() {
  if (plot!=null) {
    if (plot instanceof VerticalValuePlot) {
    VerticalValuePlot vvp = (VerticalValuePlot)plot;
        Number u = vvp.getMaximumVerticalDataValue();
        double upper = this.DEFAULT_MAXIMUM_AXIS_VALUE.doubleValue();
        if (u!=null) {
      upper = u.doubleValue();
        }
        Number l = vvp.getMinimumVerticalDataValue();
        double lower = this.DEFAULT_MINIMUM_AXIS_VALUE.doubleValue();
        if (l!=null) {
      lower = l.doubleValue();
        }
    double range = upper-lower;
        // ensure the autorange is at least <minRange> in size...
    double minRange = this.autoRangeMinimumSize.doubleValue();
    if (range<minRange) {
      upper = (upper+lower+minRange)/2;
      lower = (upper+lower-minRange)/2;
    }
    if (this.autoRangeIncludesZero()) {
      if (upper!=0.0) upper = Math.max(0.0, upper+upperMargin*range);
      if (lower!=0.0) lower = Math.min(0.0, lower-lowerMargin*range);
    }
    else {
      if (upper!=0.0) upper = upper+upperMargin*range;
      if (lower!=0.0) lower = lower-lowerMargin*range;
    }
    this.minimumAxisValue=new Double(lower);
    this.maximumAxisValue=new Double(upper);
###
2854, isLabelDrawnVertical, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 177, 178
6
/**
   * Returns a flag that indicates whether or not the axis label is drawn with a vertical
   * orientation (this saves space).
   * @return A flag that indicates whether or not the axis label is drawn with a vertical
   * orientation.
   */
2
  public boolean isLabelDrawnVertical() {
  return this.labelDrawnVertical;
###
2855, refreshTicks, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 432, 457
7
/**
   * Calculates the positions of the tick labels for the axis, storing the results in the
   * tick label list (ready for drawing).
   * @param g2 The graphics device.
   * @param drawArea The area in which the plot and the axes should be drawn.
   * @param plotArea The area in which the plot should be drawn.
   */
22
  public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {
  this.ticks.clear();
  g2.setFont(tickLabelFont);
  if (this.autoTickUnit) {
    selectAutoTickUnit(g2, drawArea, plotArea);
  }
  double size = this.tickUnit.getValue().doubleValue();
  int count = this.calculateVisibleTickCount();
  double lowestTickValue = this.calculateLowestVisibleTickValue();
  //tickLabelFormatter = new DecimalFormat(tickLabelFormatter.toPattern());
  for (int i=0; i<count; i++) {
    Number currentTickValue = new Double(lowestTickValue+(i*size));
    double yy = this.translatedValue(currentTickValue, plotArea);
    String tickLabel = this.valueToString(currentTickValue);
    Rectangle2D tickLabelBounds = tickLabelFont.getStringBounds(tickLabel,
                                    g2.getFontRenderContext());
    float x = (float)(plotArea.getX()
                -tickLabelBounds.getWidth()
                -tickLabelInsets.left-tickLabelInsets.right);
    float y = (float)(yy+(tickLabelBounds.getHeight()/2));
    Tick tick = new Tick(currentTickValue, tickLabel, x, y);
    ticks.add(tick);
###
2856, VerticalNumberAxis, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 151, 158
4
/**
   * Constructs a vertical number axis, using default values where necessary.
   * @param label The axis label (null permitted).
   */
6
  public VerticalNumberAxis(String label) {
  this(label,
       Axis.DEFAULT_AXIS_LABEL_FONT,
       NumberAxis.DEFAULT_MINIMUM_AXIS_VALUE,
       NumberAxis.DEFAULT_MAXIMUM_AXIS_VALUE);
    this.autoRange = true;
###
2857, reserveAxisArea, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 361, 388
7
/**
   * Returns area in which the axis will be displayed.
   * @param g2 The graphics device;
   * @param plot A reference to the plot;
   * @param drawArea The area in which the plot and axes should be drawn;
   * @param reservedHeight The height reserved for the horizontal axis;
   */
25
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,
             double reservedHeight) {
  // calculate the width of the axis label...
  double labelWidth = 0.0;
  if (label!=null) {
    Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());
    labelWidth = labelInsets.left+labelInsets.right;
    if (this.labelDrawnVertical) {
    labelWidth = labelWidth + labelBounds.getHeight();  // assume width == height before rotation
    }
    else {
    labelWidth = labelWidth + labelBounds.getWidth();
    }
  }
  // calculate the width of the tick labels
  double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;
  if (tickLabelsVisible) {
    Rectangle2D approximatePlotArea = new Rectangle2D.Double(drawArea.getX(), drawArea.getY(),
                   drawArea.getWidth(),
                   drawArea.getHeight()-reservedHeight);
    this.refreshTicks(g2, drawArea, approximatePlotArea);
    tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, approximatePlotArea);
  }
  return new Rectangle2D.Double(drawArea.getX(), drawArea.getY(), labelWidth+tickLabelWidth,
            drawArea.getHeight()-reservedHeight);
###
2858, configure, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 199, 201
4
/**
   * Configures the axis to work with the specified plot.  If the axis has auto-scaling, then sets
   * the maximum and minimum values.
   */
3
  public void configure() {
  if (isAutoRange()) {
    autoAdjustRange();
###
2859, setLabelDrawnVertical, VerticalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis.java, 186, 190
5
/**
   * Sets the flag that controls whether or not the axis label is drawn with a vertical
   * orientation.
   * @param flag The flag.
   */
4
  public void setLabelDrawnVertical(boolean flag) {
    if (this.labelDrawnVertical!=flag) {
    this.labelDrawnVertical = flag;
    this.notifyListeners(new AxisChangeEvent(this));
###
2861, getDomainAxis, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 79, 80
3
/**
   * A convenience method that returns the horizontal axis cast as a ValueAxis.
   */
2
  public ValueAxis getDomainAxis() {
    return (ValueAxis)horizontalAxis;
###
2862, getMinimumHorizontalDataValue, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 200, 206
4
/**
   * Returns the minimum value in either the domain or the range, whichever is displayed against
   * the horizontal axis for the particular type of plot implementing this interface.
   */
6
  public Number getMinimumHorizontalDataValue() {
    Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMinimumDomainValue(data);
  }
  else return null;
###
2863, VerticalXYBarPlot, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 54, 59
9
/**
   * Standard constructor.
   * @param horizontalAxis The horizontal axis for the plot;
   * @param verticalAxis The vertical axis for the plot;
   * @param insets Amount of blank space around the plot area;
   * @param background The Paint used to fill the plot background;
   * @param outlineStroke The Stroke used to draw an outline around the plot;
   * @param outlinePaint Storage for registered change listeners.
   */
5
  public VerticalXYBarPlot(Axis horizontalAxis, Axis verticalAxis, Insets insets,
      Paint background, Stroke outlineStroke, Paint outlinePaint)
      throws AxisNotCompatibleException, PlotNotCompatibleException
  {
    super(horizontalAxis, verticalAxis, insets, background, outlineStroke, outlinePaint);
###
2864, getMinimumVerticalDataValue, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 228, 234
5
/**
   * Returns the minimum Y value from the datasource.
   * <P>
   * This method can return null if the data source is null.
   */
6
  public Number getMinimumVerticalDataValue()  {
    Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMinimumRangeValue(data);
  }
  else return null;
###
2865, getMaximumVerticalDataValue, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 243, 249
5
/**
   * Returns the maximum Y value from the datasource.
   * <P>
   * This method can return null if the data source is null.
   */
6
  public Number getMaximumVerticalDataValue() {
  Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMaximumRangeValue(data);
  }
  else return null;
###
2866, VerticalXYBarPlot, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 68, 72
5
/**
   * Standard constructor.
   * @param horizontalAxis The horizontal axis for the plot;
   * @param verticalAxis The vertical axis for the plot;
   */
4
  public VerticalXYBarPlot(Axis horizontalAxis, Axis verticalAxis)
    throws AxisNotCompatibleException, PlotNotCompatibleException
  {
     super(horizontalAxis, verticalAxis);
###
2867, isCompatibleHorizontalAxis, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 98, 101
8
/**
   * Returns true if the specified axis is compatible with the plot with regard to operating as
   * the horizontal axis.
   * <P>
   * This plot requires the horizontal axis to be a subclass of HorizontalNumberAxis or
   * HorizontalDateAxis.
   * @param axis The axis.
   */
4
  public boolean isCompatibleHorizontalAxis(Axis axis) {
    if (axis instanceof HorizontalNumberAxis) return true;
    else if (axis instanceof HorizontalDateAxis) return true;
    else return false;
###
2868, draw, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 121, 160
5
/**
   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device;
   * @param drawArea The area within which the plot should be drawn;
   */
36
  public void draw(Graphics2D g2, Rectangle2D drawArea) {
    // adjust the drawing area for plot insets (if any)...
    if (insets!=null) {
      drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,
                        drawArea.getY()+insets.top,
                        drawArea.getWidth()-insets.left-insets.right,
                        drawArea.getHeight()-insets.top-insets.bottom);
    }
    // estimate the area required for drawing the axes...
    HorizontalAxis ha = getHorizontalAxis();
    VerticalAxis va = getVerticalAxis();
    double hAxisAreaHeight = ha.reserveHeight(g2, this, drawArea);
    Rectangle2D vAxisArea = va.reserveAxisArea(g2, this, drawArea, hAxisAreaHeight);
    Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),
                            drawArea.getY(),
                            drawArea.getWidth()-vAxisArea.getWidth(),
                            drawArea.getHeight()-hAxisAreaHeight);
    // draw the background and axes...
    drawOutlineAndBackground(g2, plotArea);
    getDomainAxis().draw(g2, drawArea, plotArea);
    getRangeAxis().draw(g2, drawArea, plotArea);
    // now get the data and plot the bars...
    IntervalXYDataset data = (IntervalXYDataset)chart.getDataset();
    if (data!=null) {
      Shape savedClip = g2.getClip();
      g2.clip(plotArea);
      double translatedVerticalZero = getRangeAxis().translatedValue(Plot.ZERO, plotArea);
      int seriesCount = data.getSeriesCount();
      for (int series = 0; series<seriesCount; series++) {
        int itemCount = data.getItemCount(series);
        for (int item = 0; item<itemCount; item++) {
          drawBar(g2, plotArea, data, series, item, getDomainAxis(), getRangeAxis(),
              translatedVerticalZero);
        }
      }
      g2.setClip(savedClip);
###
2869, isCompatibleVerticalAxis, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 111, 113
7
/**
   * Returns true if the specified axis is compatible with the plot with regard to operating as
   * the vertical axis.
   * <P>
   * This plot requires the vertical axis to be a subclass of VerticalNumberAxis.
   * @param axis The axis.
   */
3
  public boolean isCompatibleVerticalAxis(Axis axis) {
    if (axis instanceof VerticalNumberAxis) return true;
    else return false;
###
2870, getRangeAxis, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 86, 87
3
/**
   * A convenience method that returns the vertical axis cast as a VerticalNumberAxis.
   */
2
  public VerticalNumberAxis getRangeAxis() {
    return (VerticalNumberAxis)verticalAxis;
###
2871, getMaximumHorizontalDataValue, VerticalXYBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalXYBarPlot.java, 214, 220
4
/**
   * Returns the maximum value in either the domain or the range, whichever is displayed against
   * the horizontal axis for the particular type of plot implementing this interface.
   */
6
  public Number getMaximumHorizontalDataValue() {
  Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMaximumDomainValue(data);
  }
  else return null;
###
2872, getY, LinearPlotFitAlgorithm, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/LinearPlotFitAlgorithm.java, 96, 103
6
/**
   * Returns a y-value for any given x-value.
   * @param x The x value.
   * @param series The series.
   * @return The y value.
   */
8
  public Number getY(int series, Number x) {

     // for a linear fit, this will return the y for the formula
     //  y = a + bx
     //  These are in the private variable linear_fit
     //  a = linear_fit[i][0]
     //  b = linear_fit[i][1]
    return new Double(linear_fit[series][0] + linear_fit[series][1] * x.doubleValue());
###
2873, getName, LinearPlotFitAlgorithm, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/LinearPlotFitAlgorithm.java, 54, 54
3
/**
   * @return The name that you want to see in the legend.
   */
1
  public String getName() { return "Linear Fit"; }
###
2874, setXYDataset, LinearPlotFitAlgorithm, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/LinearPlotFitAlgorithm.java, 59, 86
3
/**
   * @param data The dataset.
   */
28
  public void setXYDataset(XYDataset data) {
    this.dataset = data;

    // build the x and y data arrays to be passed to the
    // statistics class to get a linear fit and store them
    // for each dataset in the datasets Vector

    Vector datasets = new Vector();
    for(int i = 0; i < data.getSeriesCount(); i++) {
      int seriessize = data.getItemCount(i);
      Number[] x_data = new Number[seriessize];
      Number[] y_data = new Number[seriessize];
      for(int j = 0; j < seriessize; j++) {
        x_data[j] = data.getXValue(i,j);
        y_data[j] = data.getYValue(i,j);
      }
      Vector pair = new Vector();
      pair.addElement(x_data);
      pair.addElement(y_data);
      datasets.addElement(pair);
    }

    // put in the linear fit array
    linear_fit = new double[datasets.size()][2];
    for(int i = 0; i < datasets.size(); i++) {
      Vector pair = (Vector)datasets.elementAt(i);
      linear_fit[i] = Statistics.getLinearFit((Number[])pair.elementAt(0),
                          (Number[])pair.elementAt(1));
###
2875, barWidthsPerCategory, VerticalBarRenderer3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarRenderer3D.java, 63, 64
4
/**
   * This will be a method in the renderer that tells whether there is one bar width per category
   * or onebarwidth per series per category.
   */
2
  public int barWidthsPerCategory(CategoryDataset data) {
    return data.getSeriesCount();
###
2876, drawBar, VerticalBarRenderer3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarRenderer3D.java, 71, 146
4
/**
   * Renders an individual bar...there are bug-fixes that have been applied to VerticalBarRenderer
   * that need to be applied here too.
   */
66
  public void drawBar(Graphics2D g2, Rectangle2D plotArea, BarPlot plot, ValueAxis valueAxis,
            CategoryDataset data, int series, Object category, int categoryIndex,
            double translatedZero, double itemWidth,
            double categorySpan, double categoryGapSpan,
            double itemSpan, double itemGapSpan) {
    // first check the value we are plotting...
    Number value = data.getValue(series, category);
    if (value!=null) {
      // BAR X
      double rectX = plotArea.getX()
               // intro gap
               + plotArea.getWidth()*plot.getIntroGapPercent()
               // bars in completed categories
               + categoryIndex*categorySpan/data.getCategoryCount()
               // gaps between completed categories
               + (categoryIndex*categoryGapSpan/(data.getCategoryCount()-1))
               // bars+gaps completed in current category
               + (series*itemSpan/(data.getCategoryCount()*data.getSeriesCount()))
               + (series*itemGapSpan/(data.getCategoryCount()*(data.getSeriesCount()-1)));
      // BAR Y
      double translatedValue = valueAxis.translatedValue(value, plotArea);
      double rectY = Math.min(translatedZero, translatedValue);
      // BAR WIDTH
      double rectWidth = itemWidth;
      // BAR HEIGHT
      double rectHeight = Math.abs(translatedValue-translatedZero);
      Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, rectHeight);
      Paint seriesPaint = plot.getSeriesPaint(series);
      g2.setPaint(seriesPaint);
      g2.fill(bar);
      GeneralPath bar3dRight = null;
      GeneralPath bar3dTop = null;
      double effect3d = 0.00;
      VerticalAxis vAxis = plot.getVerticalAxis();
      if (rectHeight != 0 && vAxis instanceof VerticalNumberAxis3D) {
        effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();
        bar3dRight = new GeneralPath();
        bar3dRight.moveTo((float)(rectX+rectWidth), (float)rectY);
        bar3dRight.lineTo((float)(rectX+rectWidth), (float)(rectY+rectHeight));
        bar3dRight.lineTo((float)(rectX+rectWidth+effect3d),
                  (float)(rectY+rectHeight-effect3d));
        bar3dRight.lineTo((float)(rectX+rectWidth+effect3d), (float)(rectY-effect3d));
        if (seriesPaint instanceof Color) {
          g2.setPaint( ((Color) seriesPaint).darker());
        }
        g2.fill(bar3dRight);
        bar3dTop = new GeneralPath();
        bar3dTop.moveTo( (float) rectX, (float) rectY);
        bar3dTop.lineTo((float) (rectX+effect3d), (float) (rectY-effect3d));
        bar3dTop.lineTo((float) (rectX+rectWidth+effect3d), (float) (rectY-effect3d));
        bar3dTop.lineTo((float) (rectX+rectWidth), (float) (rectY) );
        if (seriesPaint instanceof Color) {
          g2.setPaint( ((Color) seriesPaint)); //.brighter());
        }
        g2.fill(bar3dTop);
      }
      if (itemWidth>3) {
        g2.setStroke(plot.getSeriesOutlineStroke(series));
        //g2.setStroke(new BasicStroke(0.25f));
        g2.setPaint(plot.getSeriesOutlinePaint(series));
        g2.draw(bar);
        if (bar3dRight != null) {
          g2.draw(bar3dRight);
        }
        if (bar3dTop != null) {
          g2.draw(bar3dTop);
###
2877, hasItemGaps, VerticalBarRenderer3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarRenderer3D.java, 55, 56
3
/**
   * Returns true, since there are (potentially) gaps between bars in this representation.
   */
2
  public boolean hasItemGaps() {
    return true;
###
2879, VerticalCategoryAxis, VerticalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalCategoryAxis.java, 88, 90
4
/**
   * Standard constructor - builds a VerticalCategoryAxis with mostly default attributes.
   * @param label The axis label;
   */
3
  public VerticalCategoryAxis(String label) {
  super(label);
  this.verticalLabel = true;
###
2880, refreshTicks, VerticalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalCategoryAxis.java, 139, 159
6
/**
   * Creates a temporary list of ticks that can be used when drawing the axis.
   * @param g2 The graphics device (used to get font measurements);
   * @param drawArea The area where the plot and axes will be drawn;
   * @param plotArea The area inside the axes;
   */
21
  public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {
  this.ticks.clear();
  CategoryPlot categoryPlot = (CategoryPlot)plot;
    Dataset data = categoryPlot.getDataset();
    if (data!=null) {
      Font font = this.getTickLabelFont();
    g2.setFont(font);
    FontRenderContext frc = g2.getFontRenderContext();
    int categoryIndex = 0;
    Iterator iterator = categoryPlot.getDataset().getCategories().iterator();
      while (iterator.hasNext()) {
      Object category = iterator.next();
      String label = category.toString();
      Rectangle2D labelBounds = font.getStringBounds(label, frc);
      LineMetrics metrics = font.getLineMetrics(label, frc);
      float xx = (float)(plotArea.getX()-tickLabelInsets.right-labelBounds.getWidth());
      float yy = (float)(categoryPlot.getCategoryCoordinate(categoryIndex, plotArea)+
           labelBounds.getHeight()/2);
      Tick tick = new Tick(category, label, xx, yy);
      ticks.add(tick);
      categoryIndex = categoryIndex+1;
###
2881, reserveWidth, VerticalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalCategoryAxis.java, 173, 191
9
/**
   * Estimates the height required for the axis, given a specific drawing area, without any
   * information about the width of the vertical axis.
   * <P>
   * Supports the HorizontalAxisLead interface.
   * @param g2 The graphics device (used to obtain font information);
   * @param drawArea The area within which the axis should be drawn;
   * @param plot The plot that the axis belongs to.
   */
17
  public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {
  // calculate the width of the axis label...
  Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());
  double labelWidth = this.labelInsets.left+labelInsets.right;
  if (this.verticalLabel) {
    labelWidth = labelWidth + labelBounds.getHeight();  // assume width == height before rotation
  }
  else {
    labelWidth = labelWidth + labelBounds.getWidth();
  }
  // calculate the width required for the tick labels (if visible);
  double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;
  if (tickLabelsVisible) {
    this.refreshTicks(g2, drawArea, drawArea);
    tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);
  }
  return labelWidth+tickLabelWidth;
###
2882, VerticalCategoryAxis, VerticalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalCategoryAxis.java, 70, 80
14
/**
   * Full constructor: returns a new VerticalCategoryAxis with attributes as specified by the
   * caller.
   * @param label The axis label;
   * @param labelFont The font for displaying the axis label;
   * @param labelPaint The paint used to draw the axis label;
   * @param labelInsets Determines the amount of blank space around the label;
   * @param verticalLabel Flag indicating whether or not the axis label is drawn vertically;
   * @param showCategoryLabels Flag indicating whether or not category (tick) labels are visible;
   * @param categoryLabelFont The font used to display category (tick) labels;
   * @param categoryLabelPaint The paint used to draw category (tick) labels;
   * @param showTickMarks Flag indicating whether or not tick marks are visible;
   * @param tickMarkStroke The stroke used to draw tick marks (if visible).
   */
9
  public VerticalCategoryAxis(String label, Font labelFont,
        Paint labelPaint, Insets labelInsets,
        boolean verticalLabel,
        boolean showTickLabels, Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,
        boolean showTickMarks, Stroke tickMarkStroke) {
  super(label, labelFont, labelPaint, labelInsets,
      showTickLabels, tickLabelFont, tickLabelPaint, tickLabelInsets,
      showTickMarks, tickMarkStroke);
  this.verticalLabel = verticalLabel;
###
2883, isCompatibleVerticalAxis, VerticalBarPlot3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot3D.java, 91, 95
5
/**
   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with
   * the plot, and false otherwise.
   * @param axis The vertical axis;
   */
5
  public boolean isCompatibleVerticalAxis(Axis axis) {
  if (axis instanceof VerticalNumberAxis3D) {
    return true;
  }
  else return false;
###
2884, calculateBackgroundPlotArea, VerticalBarPlot3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot3D.java, 101, 121
3
/**
   * Returns the shape of the background for the 3D-effect bar plot.
   */
18
  protected Shape calculateBackgroundPlotArea(Rectangle2D plotArea) {
  VerticalAxis vAxis = getVerticalAxis();
  double effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();
    GeneralPath backgroundPlotArea = new GeneralPath();
    backgroundPlotArea.moveTo((float) plotArea.getX(), (float)plotArea.getY());
    backgroundPlotArea.lineTo((float)(plotArea.getX()+effect3d),
                  (float)(plotArea.getY()-effect3d));
    backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()),
                  (float)(plotArea.getY()-effect3d));
    backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()),
                  (float)(plotArea.getY()+plotArea.getHeight()-effect3d));
    backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()-effect3d),
                  (float)(plotArea.getY()+plotArea.getHeight()));
    backgroundPlotArea.lineTo((float) plotArea.getX(),
                  (float)(plotArea.getY()+plotArea.getHeight()));
    backgroundPlotArea.lineTo((float) plotArea.getX(),
                  (float) plotArea.getY());
    return backgroundPlotArea;
###
2885, draw, VerticalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalCategoryAxis.java, 99, 127
6
/**
   * Draws the CategoryAxis on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device;
   * @param drawArea The area within which the axis should be drawn;
   * @param plotArea The area within which the plot is being drawn.
   */
27
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {
  // draw the axis label
  g2.setFont(labelFont);
  g2.setPaint(labelPaint);
  FontRenderContext frc = g2.getFontRenderContext();
  LineMetrics metrics = labelFont.getLineMetrics(label, frc);
  Rectangle2D labelBounds = labelFont.getStringBounds(label, frc);
  if (verticalLabel) {
    double xx = drawArea.getX()+labelInsets.left+metrics.getHeight()-metrics.getDescent()
    -metrics.getLeading();
    double yy = plotArea.getY()+plotArea.getHeight()/2+(labelBounds.getWidth()/2);
    drawVerticalString(label, g2, (float)xx, (float)yy);
  }
  else {
    double xx = drawArea.getX()+labelInsets.left;
    double yy = drawArea.getY()+drawArea.getHeight()/2-labelBounds.getHeight()/2;
    g2.drawString(label, (float)xx, (float)yy);
  }
  // draw the category labels
  if (this.tickLabelsVisible) {
    g2.setFont(tickLabelFont);
    g2.setPaint(tickLabelPaint);
    this.refreshTicks(g2, drawArea, plotArea);
    Iterator iterator = ticks.iterator();
    while (iterator.hasNext()) {
    Tick tick = (Tick)iterator.next();
    g2.drawString(tick.getText(), tick.getX(), tick.getY());
###
2886, isCompatiblePlot, VerticalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalCategoryAxis.java, 228, 230
4
/**
   * Returns true if the specified plot is compatible with the axis, and false otherwise.
   * @param plot The plot;
   */
3
  protected boolean isCompatiblePlot(Plot plot) {
    if (plot instanceof CategoryPlot) return true;
    else return false;
###
2887, drawBars, VerticalBarPlot3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot3D.java, 128, 145
3
/**
   * Draws the bars...
   */
17
  protected void drawBars(Graphics2D g2, Shape backgroundPlotArea, Rectangle2D plotArea) {
    VerticalAxis vAxis = getVerticalAxis();
  double effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();
    // draw far 3d axis
  if ((outlineStroke!=null) && (outlinePaint!=null)) {
    g2.setStroke(outlineStroke);
    g2.setPaint(outlinePaint);
    g2.draw(new Line2D.Double(plotArea.getX()+effect3d, plotArea.getY()-effect3d,
              plotArea.getX()+effect3d, plotArea.getY()+plotArea.getHeight()-effect3d));
    g2.draw(new Line2D.Double(plotArea.getX(), plotArea.getY()+plotArea.getHeight(),
              plotArea.getX()+effect3d, plotArea.getY()+plotArea.getHeight()-effect3d));
    g2.draw(new Line2D.Double(plotArea.getX()+effect3d,
                    plotArea.getY()+plotArea.getHeight()-effect3d,
                    plotArea.getX()+plotArea.getWidth(),
                    plotArea.getY()+plotArea.getHeight()-effect3d));
  }
  super.drawBars(g2, backgroundPlotArea, plotArea);
###
2888, reserveAxisArea, VerticalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalCategoryAxis.java, 201, 221
6
/**
   * Returns the area required to draw the axis in the specified draw area.
   * @param g2 The graphics device;
   * @param drawArea The area within which the plot should be drawn;
   * @param reservedHeight The height reserved by the horizontal axis.
   */
19
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,
             double reservedHeight) {
  // calculate the width of the axis label...
  Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());
  double labelWidth = this.labelInsets.left+labelInsets.right;
  if (this.verticalLabel) {
    labelWidth = labelWidth + labelBounds.getHeight();  // assume width == height before rotation
  }
  else {
    labelWidth = labelWidth + labelBounds.getWidth();
  }
  // calculate the width required for the tick labels (if visible);
  double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;
  if (tickLabelsVisible) {
    this.refreshTicks(g2, drawArea, drawArea);
    tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);
  }
  return new Rectangle2D.Double(drawArea.getX(), drawArea.getY(), labelWidth+tickLabelWidth,
            drawArea.getHeight()-reservedHeight);
###
2889, VerticalBarPlot3D, VerticalBarPlot3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot3D.java, 80, 83
5
/**
   * Standard constructor - builds a VerticalBarPlot with mostly default attributes.
   * @param horizontalAxis The horizontal axis;
   * @param verticalAxis The vertical axis;
   */
4
  public VerticalBarPlot3D(Axis horizontalAxis, Axis verticalAxis)
    throws AxisNotCompatibleException, PlotNotCompatibleException
  {
  this(horizontalAxis, verticalAxis, new Insets(2,2,2,2), 0.1, 0.1, 0.2, 0.0);
###
2890, VerticalBarPlot3D, VerticalBarPlot3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot3D.java, 65, 71
10
/**
   * Standard constructor: returns a BarPlot with attributes specified by the caller.
   * @param horizontal The horizontal axis.
   * @param vertical The vertical axis.
   * @param introGap The gap before the first bar in the plot.
   * @param trailGap The gap after the last bar in the plot.
   * @param categoryGap The gap between the last bar in one category and the first bar in the next
   *          category.
   * @param seriesGap The gap between bars within the same category.
   */
6
  public VerticalBarPlot3D(Axis horizontal, Axis vertical, Insets insets,
         double introGap, double trailGap, double categoryGap, double seriesGap)
  throws AxisNotCompatibleException, PlotNotCompatibleException
  {
  super(horizontal, vertical, insets,
      introGap, trailGap, categoryGap, seriesGap);
###
2891, isCompatibleVerticalAxis, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 200, 204
6
/**
   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with
   * the plot, and false otherwise.
   * @param axis The vertical axis;
   * @return True if the axis is compatible with the plot, and false otherwise.
   */
5
  public boolean isCompatibleVerticalAxis(Axis axis) {
  if (axis instanceof VerticalNumberAxis) {
    return true;
  }
  else return false;
###
2892, calculateBarWidth, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 357, 375
4
/**
   * Returns the width of each bar in the chart.
   * @param area The area within which the plot will be drawn.
   */
14
  double calculateBarWidth(Rectangle2D plotArea) {
  CategoryDataset data = getDataset();
  // series, category and bar counts
  int categoryCount = data.getCategoryCount();
  int seriesCount = data.getSeriesCount();
  int barCount = renderer.barWidthsPerCategory(data)*categoryCount;
  // calculate the plot width (bars are vertical) less whitespace
    double usable = plotArea.getWidth() *
                  (1.0 - introGapPercent - trailGapPercent - categoryGapsPercent);
    if (renderer.barWidthsPerCategory(data)>1) {
//    usable = usable - ((seriesCount-1) * categoryCount * seriesGap);
    }
  // and thus the width of the bars
  return usable/barCount;
###
2893, addVerticalLine, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 128, 135
4
/**
   * Adds a vertical of the given color at location with the given color.
   * @return void
   */
7
  public void addVerticalLine(Number location, Paint color) {
    if (verticalLines == null) {
      verticalLines = new ArrayList();
      verticalColors = new ArrayList();
    }
    verticalColors.add(color);
    verticalLines.add(location);
###
2894, getHorizontalValueAxis, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 165, 166
5
/**
   * A convenience method that returns a reference to the horizontal axis cast as a
   * ValueAxis.
   * @return The horizontal axis cast as a ValueAxis.
   */
2
  public ValueAxis getHorizontalValueAxis() {
  return (ValueAxis)horizontalAxis;
###
2895, setHorizontalAxis, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 152, 154
5
/**
   * Sets the horizontal axis for the plot.  This method should throw an exception if the axis
   * doesn't implement the required interfaces.
   * @param axis The new horizontal axis.
   */
3
  public void setHorizontalAxis(Axis axis) throws AxisNotCompatibleException {
  // check that the axis implements the required interface (if not raise an exception);
  super.setHorizontalAxis(axis);
###
2896, draw, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 215, 262
8
/**
   * Draws the XY plot on a Java 2D graphics device (such as the screen or a printer).
   * <P>
   * XYPlot now relies on an XYItemRenderer to draw each item in the plot.  This allows the
   * visual representation of the plot to be changed easily.
   * @param g2 The graphics device;
   * @param drawArea The area within which the plot (including axis labels) should be drawn;
   */
40
  public void draw(Graphics2D g2, Rectangle2D drawArea) {
    // adjust the drawing area for plot insets (if any)...
  if (insets!=null) {
    drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,
              drawArea.getY()+insets.top,
              drawArea.getWidth()-insets.left-insets.right,
              drawArea.getHeight()-insets.top-insets.bottom);
  }
  // estimate the area required for drawing the axes...
  HorizontalAxis hAxis = getHorizontalAxis();
  VerticalAxis vAxis = getVerticalAxis();
  double hAxisAreaHeight = hAxis.reserveHeight(g2, this, drawArea);
  Rectangle2D vAxisArea = vAxis.reserveAxisArea(g2, this, drawArea, hAxisAreaHeight);
    // ...and therefore what is left for the plot itself...
  Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),
                drawArea.getY(),
                drawArea.getWidth()-vAxisArea.getWidth(),
                drawArea.getHeight()-hAxisAreaHeight);
    // draw the plot background and axes...
  drawOutlineAndBackground(g2, plotArea);
  this.horizontalAxis.draw(g2, drawArea, plotArea);
  this.verticalAxis.draw(g2, drawArea, plotArea);
    // now get the data and plot it (the visual representation will depend on the renderer
    // that has been set)...
    XYDataset data = this.getDataset();
    if (data!=null) {
    Shape originalClip = g2.getClip();
    g2.clip(plotArea);
      drawVerticalLines(g2, plotArea);
      drawHorizontalLines(g2, plotArea);
      double transRangeZero = this.getVerticalValueAxis().translatedValue(Plot.ZERO, plotArea);
      int seriesCount = data.getSeriesCount();
      for (int series=0; series<seriesCount; series++) {
        int itemCount = data.getItemCount(series);
        for (int item=0; item<itemCount; item++) {
          renderer.drawItem(g2, plotArea, this, (ValueAxis)hAxis, (ValueAxis)vAxis,
                    data, series, item, transRangeZero);
        }
      }
      g2.setClip(originalClip);
###
2897, drawBars, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 272, 329
6
/**
   * Draws charts bars
   * @param g2 The graphics device;
   * @param backgroundPlotArea The area within which will be clipped
   * @param plotArea The area within which the plot should be drawn.
   */
49
  protected void drawBars(Graphics2D g2, Shape backgroundPlotArea, Rectangle2D plotArea) {
    // now get the data and plot the bars...
    CategoryDataset data = this.getDataset();
    if (data!=null) {
      Shape savedClip = g2.getClip();
      g2.clip(backgroundPlotArea);
      int seriesCount = data.getSeriesCount();
      int categoryCount = data.getCategoryCount();
      int barCount = renderer.barWidthsPerCategory(data);
      double translatedZero = getValueAxis().translatedValue(Plot.ZERO, plotArea);
      // work out the span dimensions for the categories...
      double categorySpan = 0.0;
      double categoryGapSpan = 0.0;
      if (categoryCount>1) {
        categorySpan = plotArea.getWidth()
                 * (1-introGapPercent-trailGapPercent-categoryGapsPercent);
        categoryGapSpan = plotArea.getWidth()*categoryGapsPercent;
      }
      else {
        categorySpan = plotArea.getWidth()*(1-introGapPercent-trailGapPercent);
      }
      // work out the item span...
      double itemSpan = categorySpan;
      double itemGapSpan = 0.0;
      if (seriesCount>1) {
        if (renderer.hasItemGaps()) {
          itemGapSpan = plotArea.getWidth()*itemGapsPercent;
          itemSpan = itemSpan - itemGapSpan;
        }
      }
      double itemWidth = itemSpan/(categoryCount*renderer.barWidthsPerCategory(data));
      int categoryIndex = 0;
    Iterator iterator = data.getCategories().iterator();
    while (iterator.hasNext()) {
    Object category = iterator.next();
    for (int series=0; series<seriesCount; series++) {
          renderer.drawBar(g2, plotArea, this, getValueAxis(), data, series,
                   category, categoryIndex,
                   translatedZero, itemWidth, categorySpan, categoryGapSpan,
                   itemSpan, itemGapSpan);
        }
        categoryIndex++;
      }
      // draw a line at zero...
      Line2D baseline = new Line2D.Double(plotArea.getX(), translatedZero,
                        plotArea.getMaxX(), translatedZero);
      g2.setStroke(new BasicStroke());
      g2.draw(baseline);
      g2.setClip(savedClip);
###
2898, drawVerticalLines, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 269, 279
3
/**
   * Support method for the draw(...) method.
   */
10
  private void drawVerticalLines(Graphics2D g2, Rectangle2D plotArea) {
    // Draw any vertical lines
    if (verticalLines != null) {
      for (int i=0; i<verticalLines.size(); i++) {
        g2.setPaint((Paint)verticalColors.get(i));
        g2.setStroke(new BasicStroke(1));
        g2.drawLine((int)getHorizontalValueAxis().translatedValue((Number)verticalLines.get(i), plotArea),
              0,
              (int)getHorizontalValueAxis().translatedValue((Number)verticalLines.get(i), plotArea),
              (int)(plotArea.getHeight()));
###
2899, getCategoryCoordinate, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 169, 190
5
/**
   * Returns the x-coordinate (in Java 2D User Space) of the center of the specified category.
   * @param category The index of the category of interest (first category index = 0);
   * @param area The region within which the plot will be drawn.
   */
18
  public double getCategoryCoordinate(int category, Rectangle2D area) {
    // calculate first part of result...
    double result = area.getX() + (area.getWidth()*introGapPercent);
    // then add some depending on how many categories...
  int categoryCount = getDataset().getCategoryCount();
    if (categoryCount>1) {
    double categorySpan = area.getWidth()
                  * (1-introGapPercent-trailGapPercent-categoryGapsPercent);
      double categoryGapSpan = area.getWidth()*categoryGapsPercent;
      result = result
           + (category+0.5)*(categorySpan/categoryCount)
           + (category)*(categoryGapSpan/(categoryCount-1));
    }
    else {
      result = result
           + (category+0.5)*area.getWidth()*(1-introGapPercent-trailGapPercent);
    }
    return result;
###
2900, XYPlot, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 84, 88
5
/**
   * Constructs an XYPlot with the specified axes (other attributes take default values).
   * @param horizontalAxis The horizontal axis.
   * @param verticalAxis The vertical axis.
   */
5
  public XYPlot(Axis horizontalAxis, Axis verticalAxis) throws AxisNotCompatibleException,
                                 PlotNotCompatibleException
  {
  super(horizontalAxis, verticalAxis);
    this.renderer = new StandardXYItemRenderer();
###
2901, addHorizontalLine, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 150, 157
4
/**
   * Adds a horizontal line at location with given color.
   * @return void
   */
7
  public void addHorizontalLine(Number location, Paint color) {
    if (horizontalLines == null) {
      horizontalLines = new ArrayList();
      horizontalColors = new ArrayList();
    }
    horizontalColors.add(color);
    horizontalLines.add(location);
###
2902, getPlotType, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 308, 309
4
/**
   * Returns the plot type as a string.
   * @return A short string describing the type of plot.
   */
2
  public String getPlotType() {
  return "XY Plot";
###
2903, draw, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 223, 254
5
/**
   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device.
   * @param drawArea The area within which the plot should be drawn.
   */
25
  public void draw(Graphics2D g2, Rectangle2D drawArea) {
    // adjust the drawing area for the plot insets (if any)...
  if (insets!=null) {
    drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,
              drawArea.getY()+insets.top,
              drawArea.getWidth()-insets.left-insets.right,
              drawArea.getHeight()-insets.top-insets.bottom);
  }
    if ((drawArea.getWidth()>=MINIMUM_WIDTH_TO_DRAW) && (drawArea.getHeight()>=MINIMUM_HEIGHT_TO_DRAW)) {
      // estimate the area required for drawing the axes...
      HorizontalAxis hAxis = getHorizontalAxis();
      VerticalAxis vAxis = getVerticalAxis();
      double hAxisAreaHeight = hAxis.reserveHeight(g2, this, drawArea);
      Rectangle2D vAxisArea = vAxis.reserveAxisArea(g2, this, drawArea, hAxisAreaHeight);
      // and thus the area available for plotting...
      Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),
                              drawArea.getY(),
                              drawArea.getWidth()-vAxisArea.getWidth(),
                              drawArea.getHeight()-hAxisAreaHeight);
      Shape backgroundPlotArea = calculateBackgroundPlotArea(plotArea);
      // draw the background and axes...
      drawOutlineAndBackground(g2, backgroundPlotArea);
      getCategoryAxis().draw(g2, drawArea, plotArea);
      getValueAxis().draw(g2, drawArea, plotArea);
      drawBars(g2, backgroundPlotArea, plotArea);
###
2904, getMaximumHorizontalDataValue, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 332, 338
5
/**
   * Returns the maximum value in the domain, since this is plotted against the horizontal axis
   * for an XYPlot.
   * @return The maximum value to be plotted against the horizontal axis.
   */
6
  public Number getMaximumHorizontalDataValue() {
  Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMaximumDomainValue(data);
  }
  else return null;
###
2905, setRenderer, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 109, 111
4
/**
   * Sets the renderer for the bar plot.
   * @param renderer The renderer.
   */
3
  public void setRenderer(VerticalBarRenderer renderer) {
    this.renderer = renderer;
    this.notifyListeners(new PlotChangeEvent(this));
###
2906, getMinimumVerticalDataValue, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 347, 353
5
/**
   * Returns the minimum value in the range, since this is plotted against the vertical axis for
   * an XYPlot.
   * @return The minimum value to be plotted against the vertical axis.
   */
6
  public Number getMinimumVerticalDataValue() {
  Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMinimumRangeValue(data);
  }
  else return null;
###
2907, getCategoryAxis, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 143, 144
4
/**
   * A convenience method that returns a reference to the horizontal axis cast as a
   * CategoryAxis.
   */
2
  public CategoryAxis getCategoryAxis() {
  return (CategoryAxis)horizontalAxis;
###
2908, getMinimumHorizontalDataValue, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 317, 323
5
/**
   * Returns the minimum value in the domain, since this is plotted against the horizontal axis
   * for an XYPlot.
   * @return The minimum value to be plotted against the horizontal axis.
   */
6
  public Number getMinimumHorizontalDataValue() {
  Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMinimumDomainValue(data);
  }
  else return null;
###
2909, VerticalBarPlot, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 96, 101
5
/**
   * Standard constructor - builds a VerticalBarPlot with mostly default attributes.
   * @param horizontalAxis The horizontal axis;
   * @param verticalAxis The vertical axis;
   */
5
  public VerticalBarPlot(Axis horizontalAxis, Axis verticalAxis)
    throws AxisNotCompatibleException, PlotNotCompatibleException
  {
  super(horizontalAxis, verticalAxis);
    this.renderer = new VerticalBarRenderer();
###
2910, getPlotType, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 381, 382
3
/**
   * Returns a short string describing the type of plot.
   */
2
  public String getPlotType() {
  return "Bar Plot";
###
2911, setXYItemRenderer, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 103, 105
4
/**
   * Sets the item renderer, and notifies all listeners of a change to the plot.
   * @param renderer The new renderer.
   */
3
  public void setXYItemRenderer(XYItemRenderer renderer) {
    this.renderer = renderer;
    this.notifyListeners(new PlotChangeEvent(this));
###
2912, isCompatibleHorizontalAxis, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 199, 203
5
/**
   * Checks the compatibility of a horizontal axis, returning true if the axis is compatible with
   * the plot, and false otherwise.
   * @param axis The horizontal axis;
   */
5
  public boolean isCompatibleHorizontalAxis(Axis axis) {
  if (axis instanceof CategoryAxis) {
    return true;
  }
  else return false;
###
2913, calculateBackgroundPlotArea, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 262, 263
3
/**
   * Returns chart's backgroud area
   */
2
  protected Shape calculateBackgroundPlotArea(Rectangle2D plotArea) {
    return plotArea;
###
2914, drawHorizontalLines, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 288, 298
3
/**
   * Support method for the draw(...) method.
   */
10
  private void drawHorizontalLines(Graphics2D g2, Rectangle2D plotArea) {
    // Draw any horizontal lines
    if (horizontalLines != null) {
      for (int i=0; i<horizontalLines.size(); i++) {
        g2.setPaint((Paint)horizontalColors.get(i));
        g2.setStroke(new BasicStroke(1));
        g2.drawLine(0,
              (int)getVerticalValueAxis().translatedValue((Number)horizontalLines.get(i), plotArea),
              (int)(plotArea.getWidth()),
              (int)getVerticalValueAxis().translatedValue((Number)horizontalLines.get(i), plotArea));
###
2915, setVerticalAxis, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 134, 136
5
/**
   * Sets the vertical axis for the plot.  This method should throw an exception if the axis
   * doesn't implement the required interfaces.
   * @param vAxis The new vertical axis.
   */
3
  public void setVerticalAxis(Axis vAxis) throws AxisNotCompatibleException {
  // check that the axis implements the required interface (if not raise an exception);
  super.setVerticalAxis(vAxis);
###
2916, addHorizontalLine, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 142, 143
4
/**
   * Adds a horizontal line at location with default color red.
   * @return void
   */
2
  public void addHorizontalLine(Number location) {
    addHorizontalLine(location, Color.red);
###
2917, VerticalBarPlot, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 79, 87
12
/**
   * Standard constructor: returns a BarPlot with attributes specified by the caller.
   * @param horizontal The horizontal axis.
   * @param vertical The vertical axis.
   * @param introGapPercent The gap before the first bar in the plot, as a percentage of the
   *            available drawing space.
   * @param trailGapPercent The gap after the last bar in the plot, as a percentage of the
   *            available drawing space.
   * @param categoryGapsPercent The percentage of drawing space allocated to the gap between the
   *               last bar in one category and the first bar in the next category.
   * @param itemGapsPercent The gap between bars within the same category.
   */
8
  public VerticalBarPlot(Axis horizontal, Axis vertical, Insets insets,
         double introGapPercent, double trailGapPercent,
               double categoryGapPercent, double seriesGapPercent)
    throws AxisNotCompatibleException, PlotNotCompatibleException
  {
  super(horizontal, vertical, insets,
      introGapPercent, trailGapPercent, categoryGapPercent, seriesGapPercent);
    this.renderer = new VerticalBarRenderer();
###
2918, isCompatibleHorizontalAxis, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 184, 191
6
/**
   * Checks the compatibility of a horizontal axis, returning true if the axis is compatible with
   * the plot, and false otherwise.
   * @param axis The horizontal axis;
   * @return True if the axis is compatible with the plot, and false otherwise.
   */
8
  public boolean isCompatibleHorizontalAxis(Axis axis) {
  if (axis instanceof HorizontalNumberAxis) {
    return true;
  }
  else if (axis instanceof HorizontalDateAxis) {
    return true;
  }
  else return false;
###
2919, getItemRenderer, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 95, 96
4
/**
   * Returns a reference to the current item renderer.
   * @return A reference to the current item renderer.
   */
2
  public XYItemRenderer getItemRenderer() {
    return this.renderer;
###
2920, getDataset, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 117, 118
3
/**
   * A convenience method that returns the dataset for the plot, cast as a CategoryDataset.
   */
2
  public CategoryDataset getDataset() {
  return (CategoryDataset)chart.getDataset();
###
2921, addVerticalLine, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 120, 121
4
/**
   * Adds a vertical line at location with default color blue.
   * @return void
   */
2
  public void addVerticalLine(Number location) {
    addVerticalLine(location, Color.blue);
###
2922, getMinimumVerticalDataValue, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 389, 395
4
/**
   * Returns the minimum value in the range, since this is plotted against the vertical axis for
   * BarPlot.
   */
6
  public Number getMinimumVerticalDataValue() {
  Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMinimumRangeValue(data);
  }
  else return null;
###
2923, getVerticalValueAxis, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 174, 175
5
/**
   * A convenience method that returns a reference to the vertical axis cast as a
   * ValueAxis.
   * @return The vertical axis cast as a ValueAxis.
   */
2
  public ValueAxis getVerticalValueAxis() {
  return (ValueAxis)verticalAxis;
###
2924, isCompatibleVerticalAxis, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 211, 215
5
/**
   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with
   * the plot, and false otherwise.
   * @param axis The vertical axis;
   */
5
  public boolean isCompatibleVerticalAxis(Axis axis) {
  if (axis instanceof VerticalNumberAxis) {
    return true;
  }
  else return false;
###
2925, getDataset, XYPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/XYPlot.java, 112, 113
4
/**
   * A convenience method that returns the dataset for the plot, cast as an XYDataset.
   * @return The dataset for the plot, cast as an XYDataset.
   */
2
  public XYDataset getDataset() {
  return (XYDataset)chart.getDataset();
###
2926, getCategories, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 160, 161
3
/**
   * A convenience method that returns a list of the categories in the dataset.
   */
2
  public java.util.List getCategories() {
  return getDataset().getCategories();
###
2927, drawOutlineAndBackground, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 338, 348
5
/**
   * Draws the plot outline and background.
   * @param g2 The graphics device.
   * @param area The area for the plot.
   */
9
  public void drawOutlineAndBackground(Graphics2D g2, Shape area) {
  if (backgroundPaint!=null) {
    g2.setPaint(backgroundPaint);
    g2.fill(area);
  }
  if ((outlineStroke!=null) && (outlinePaint!=null)) {
    g2.setStroke(outlineStroke);
    g2.setPaint(outlinePaint);
    g2.draw(area);
###
2928, getValueAxis, VerticalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarPlot.java, 125, 126
4
/**
   * A convenience method that returns a reference to the vertical axis cast as a
   * VerticalNumberAxis.
   */
2
  public VerticalNumberAxis getValueAxis() {
  return (VerticalNumberAxis)verticalAxis;
###
2929, barWidthsPerCategory, VerticalBarRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarRenderer.java, 64, 65
4
/**
   * Returns the number of bar-widths displayed in each category.  For this renderer, there is one
   * bar per series, so we return the number of series.
   */
2
  public int barWidthsPerCategory(CategoryDataset data) {
    return data.getSeriesCount();
###
2930, hasItemGaps, VerticalBarRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarRenderer.java, 56, 57
3
/**
   * Returns true, since for this renderer there are gaps between the items in one category.
   */
2
  public boolean hasItemGaps() {
    return true;
###
2931, drawBar, VerticalBarRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalBarRenderer.java, 85, 140
17
/**
   * Handles the rendering of a single bar.
   * @param g2
   * @param plotArea
   * @param plot
   * @param valueAxis
   * @param data
   * @param series
   * @param category
   * @param categoryIndex
   * @param translatedZero
   * @param itemWidth
   * @param categorySpan
   * @param categoryGapSpan
   * @param itemSpan
   * @param itemGapSpan
   */
49
  public void drawBar(Graphics2D g2, Rectangle2D plotArea, BarPlot plot, ValueAxis valueAxis,
            CategoryDataset data, int series, Object category, int categoryIndex,
            double translatedZero, double itemWidth,
            double categorySpan, double categoryGapSpan,
            double itemSpan, double itemGapSpan) {
    // first check the value we are plotting...
    Number value = data.getValue(series, category);
    if (value!=null) {
      // BAR X
      double rectX = plotArea.getX()+plotArea.getWidth()*plot.getIntroGapPercent();
      int categories = data.getCategoryCount();
      int seriesCount = data.getSeriesCount();
      if (categories>1) {
        rectX = rectX
            // bars in completed categories
            + categoryIndex*(categorySpan/categories)
            // gaps between completed categories
            + (categoryIndex*(categoryGapSpan/(categories-1))
            // bars+gaps completed in current category
            + (series*itemSpan/(categories*seriesCount)));
        if (seriesCount>1) {
          rectX = rectX
              + (series*itemGapSpan/(categories*(seriesCount-1)));
        }
      }
      else {
        rectX = rectX
            // bars+gaps completed in current category
            + (series*itemSpan/(categories*seriesCount));
        if (seriesCount>1) {
          rectX = rectX
              + (series*itemGapSpan/(categories*(seriesCount-1)));
        }
      }
      // BAR Y
      double translatedValue = valueAxis.translatedValue(value, plotArea);
      double rectY = Math.min(translatedZero, translatedValue);
      // BAR WIDTH
      double rectWidth = itemWidth;
      // BAR HEIGHT
      double rectHeight = Math.abs(translatedValue-translatedZero);
      Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, rectHeight);
      Paint seriesPaint = plot.getSeriesPaint(series);
      g2.setPaint(seriesPaint);
      g2.fill(bar);
      if (itemWidth>3) {
        g2.setStroke(plot.getSeriesStroke(series));
        g2.setPaint(plot.getSeriesOutlinePaint(series));
        g2.draw(bar);
###
2932, setGridPaint, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 222, 224
5
/**
   * Sets the Paint used to color the grid lines (if visible) and notifies registered listeners
   * that the axis has been modified.
   * @param paint The new grid paint.
   */
3
  public void setGridPaint(Paint paint) {
  gridPaint = paint;
  notifyListeners(new AxisChangeEvent(this));
###
2933, getGridPaint, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 213, 214
3
/**
   * Returns the Paint used to color the grid lines (if visible).
   */
2
  public Paint getGridPaint() {
  return gridPaint;
###
2934, ValueAxis, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 98, 113
20
/**
   * Constructs a value axis.
   * @param label The axis label.
   * @param labelFont The font for displaying the axis label.
   * @param labelPaint The paint used to draw the axis label.
   * @param labelInsets Determines the amount of blank space around the label.
   * @param tickLabelsVisible Flag indicating whether or not the tick labels are visible.
   * @param tickLabelFont The font used to display tick labels.
   * @param tickLabelPaint The paint used to draw tick labels.
   * @param tickLabelInsets Determines the amount of blank space around tick labels.
   * @param tickMarksVisible Flag indicating whether or not the tick marks are visible.
   * @param tickMarkStroke The stroke used to draw tick marks (if visible).
   * @param autoRange Flag indicating whether or not the axis range is automatically adjusted to
   *          fit the data.
   * @param autoTickUnit A flag indicating whether or not the tick unit is automatically
   *           selected.
   * @param showGridLines Flag indicating whether or not grid lines are visible for this axis.
   * @param gridStroke The Stroke used to display grid lines (if visible).
   * @param gridPaint The Paint used to display grid lines (if visible).
   */
14
  public ValueAxis(String label, Font labelFont, Paint labelPaint, Insets labelInsets,
       boolean tickLabelsVisible,
           Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,
       boolean tickMarksVisible, Stroke tickMarkStroke,
       boolean autoRange, boolean autoTickUnit,
       boolean showGridLines, Stroke gridStroke, Paint gridPaint) {
  super(label, labelFont, labelPaint, labelInsets,
      tickLabelsVisible, tickLabelFont, tickLabelPaint, tickLabelInsets,
      tickMarksVisible, tickMarkStroke);
  this.autoRange = autoRange;
  this.autoTickUnit = autoTickUnit;
  this.showGridLines = showGridLines;
  this.gridStroke = gridStroke;
  this.gridPaint = gridPaint;
###
2935, setGridStroke, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 205, 207
5
/**
   * Sets the Stroke used to draw the grid lines (if visible) and notifies registered listeners
   * that the axis has been modified.
   * @param stroke The new grid line stroke.
   */
3
  public void setGridStroke(Stroke stroke) {
  gridStroke = stroke;
  notifyListeners(new AxisChangeEvent(this));
###
2936, isShowGridLines, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 179, 180
3
/**
   * Returns true if the grid lines are visible for this axis, and false otherwise.
   */
2
  public boolean isShowGridLines() {
  return showGridLines;
###
2937, setShowGridLines, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 188, 190
5
/**
   * Sets the visibility of the grid lines and notifies registered listeners that the axis has
   * been modified.
   * @param show The new setting.
   */
3
  public void setShowGridLines(boolean show) {
  showGridLines = show;
  notifyListeners(new AxisChangeEvent(this));
###
2938, setAutoTickValue, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 167, 171
7
/**
   * Sets a flag indicating whether or not the tick unit is automatically selected from a
   * range of standard tick units.
   * <P>
   * Registered listeners are notified of a change to the axis.
   * @param flag The new value of the flag.
   */
4
  public void setAutoTickValue(boolean flag) {
    if (this.autoTickUnit!=flag) {
      this.autoTickUnit = flag;
    notifyListeners(new AxisChangeEvent(this));
###
2939, ValueAxis, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 121, 127
4
/**
   * Constructs a value axis.
   * @param label The axis label.
   */
7
  public ValueAxis(String label) {
  super(label);
  this.autoRange = true;
  this.autoTickUnit = true;
  this.showGridLines = true;
  this.gridStroke = ValueAxis.DEFAULT_GRID_LINE_STROKE;
    this.gridPaint = Color.gray;
###
2940, getGridStroke, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 196, 197
3
/**
   * Returns the Stroke used to draw the grid lines (if visible).
   */
2
  public Stroke getGridStroke() {
  return gridStroke;
###
2941, setAutoRange, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 143, 147
5
/**
   * Sets a flag that determines whether or not the axis range is automatically adjusted to fit
   * the data, and notifies registered listeners that the axis has been modified.
   * @param auto Flag indicating whether or not the axis is automatically scaled to fit the data.
   */
5
  public void setAutoRange(boolean auto) {
  if (this.autoRange!=auto) {
    this.autoRange=auto;
    if (autoRange) autoAdjustRange();
    notifyListeners(new AxisChangeEvent(this));
###
2942, isAutoTickUnit, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 156, 157
5
/**
   * Returns A flag indicating whether or not the tick unit is automatically selected from a
   * range of standard tick units.
   * @return A flag indicating whether or not the tick unit is automatically selected.
   */
2
  public boolean isAutoTickUnit() {
  return autoTickUnit;
###
2943, VerticalNumberAxis3D, VerticalNumberAxis3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 114, 123
7
/**
   * Standard constructor: returns a VerticalValueAxis with some default attributes.
   * @param label The axis label;
   * @param labelFont The font for displaying the axis label;
   * @param minimumAxisValue The lowest value shown on the axis;
   * @param maximumAxisValue The highest value shown on the axis;
   */
9
  public VerticalNumberAxis3D(String label, Font labelFont,
          Number minimumAxisValue, Number maximumAxisValue) {
  this(label, labelFont, Color.black, new Insets(4, 4, 4, 4), true,
     true, new Font("Arial", Font.PLAIN, 10), Color.black, new Insets(2, 1, 2, 1),
     true, new BasicStroke(1), false, true, new Double(0.00001),
     minimumAxisValue, maximumAxisValue,
     true, NumberAxis.DEFAULT_TICK_UNIT,
       /* new Double(5.0), new DecimalFormat("0"), */
     false, new BasicStroke(1), Color.lightGray, DEFAULT_EFFECT_3D);
###
2944, isAutoRange, ValueAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ValueAxis.java, 134, 135
4
/**
   * Returns true if the axis range is automatically adjusted to fit the data, and false
   * otherwise.
   */
2
  public boolean isAutoRange() {
  return autoRange;
###
2946, VerticalNumberAxis3D, VerticalNumberAxis3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 81, 103
27
/**
   * Full constructor: returns a new VerticalValueAxis.
   * @param label The axis label;
   * @param labelFont The font for displaying the axis label;
   * @param labelPaint The paint used to draw the axis label;
   * @param labelInsets Determines the amount of blank space around the label;
   * @param verticalLabel Flag indicating whether or not the label is drawn vertically;
   * @param showTickLabels Flag indicating whether or not tick labels are visible;
   * @param tickLabelFont The font used to display tick labels;
   * @param tickLabelPaint The paint used to draw tick labels;
   * @param tickLabelInsets Determines the amount of blank space around tick labels;
   * @param showTickMarks Flag indicating whether or not tick marks are visible;
   * @param tickMarkStroke The stroke used to draw tick marks (if visible).
   * @param autoRange Flag indicating whether or not the axis is automatically scaled to fit the
   *          data;
   * @param autoRangeIncludesZero - A flag indicating whether or not zero *must* be displayed on
   *                axis;
   * @param autoRangeMinimum - the smallest automatic range allowed;
   * @param minimumAxisValue The lowest value shown on the axis;
   * @param maximumAxisValue The highest value shown on the axis;
   * @param autoTickUnit A flag indicating whether or not the tick units are automatically
   *           selected.
   * @param showGridLines Flag indicating whether or not grid lines are visible for this axis;
   * @param gridStroke The Stroke used to display grid lines (if visible);
   * @param gridPaint The Paint used to display grid lines (if visible).
   * @param effect3d 'Z' axis deep
   */
21
  public VerticalNumberAxis3D(String label, Font labelFont, Paint labelPaint, Insets labelInsets,
          boolean verticalLabel,
          boolean showTickLabels, Font tickLabelFont, Paint tickLabelPaint,
                Insets tickLabelInsets,
          boolean showTickMarks, Stroke tickMarkStroke,
          boolean autoRange, boolean autoRangeIncludesZero,
                Number autoRangeMinimum,
          Number minimumAxisValue, Number maximumAxisValue,
          boolean autoTickUnit, NumberTickUnit tickUnit,
                /*Number tickValue, DecimalFormat formatter,*/
          boolean showGridLines, Stroke gridStroke, Paint gridPaint,
                double effect3d) {
  super(label, labelFont, labelPaint, labelInsets, verticalLabel, showTickLabels,
        tickLabelFont, tickLabelPaint,
      tickLabelInsets, showTickMarks, tickMarkStroke,
      autoRange, autoRangeIncludesZero, autoRangeMinimum,
      minimumAxisValue, maximumAxisValue,
        autoTickUnit, tickUnit,
        /* tickValue, formatter, */
        showGridLines, gridStroke, gridPaint);
  this.effect3d = effect3d;
###
2947, VerticalNumberAxis3D, VerticalNumberAxis3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 130, 131
4
/**
   * Standard constructor - builds a VerticalValueAxis with mostly default attributes.
   * @param label The axis label;
   */
2
  public VerticalNumberAxis3D(String label) {
  super(label);
###
2948, setTitle, Title, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Title.java, 81, 82
5
/**
   * Sets the title to the specified text and notifies registered listeners that the title has
   * been modified.
   * @param text The new chart title;
   */
2
  public void setTitle(String text) {
  this.title = text;
###
2949, draw, VerticalNumberAxis3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 154, 200
6
/**
   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device.
   * @param drawArea The area within which the chart should be drawn.
   * @param plotArea The area within which the plot should be drawn (a subset of the drawArea).
   */
44
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {
  // draw the axis label
  if (this.label!=null) {
    g2.setFont(labelFont);
    g2.setPaint(labelPaint);
    Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());
    if (labelDrawnVertical) {
    double xx = drawArea.getX()+labelInsets.left+labelBounds.getHeight();
    double yy = plotArea.getY()+plotArea.getHeight()/2+(labelBounds.getWidth()/2);
    drawVerticalString(label, g2, (float)xx, (float)yy);
    }
    else {
    double xx = drawArea.getX()+labelInsets.left;
    double yy = drawArea.getY()+drawArea.getHeight()/2-labelBounds.getHeight()/2;
    g2.drawString(label, (float)xx, (float)yy);
    }
  }
  // draw the tick labels and marks and gridlines
  this.refreshTicks(g2, drawArea, plotArea);
  double xx = plotArea.getX();
  g2.setFont(tickLabelFont);
  Iterator iterator = ticks.iterator();
  while (iterator.hasNext()) {
    Tick tick = (Tick)iterator.next();
    float yy = (float)this.translatedValue(tick.getNumericalValue(), plotArea);
    if (tickLabelsVisible) {
    g2.setPaint(this.tickLabelPaint);
    g2.drawString(tick.getText(), tick.getX(), tick.getY());
    }
    if (tickMarksVisible) {
    g2.setStroke(this.getTickMarkStroke());
    Line2D mark = new Line2D.Double(plotArea.getX()-2, yy,
            plotArea.getX(), yy);
    g2.draw(mark);
    }
    if (showGridLines) {
    g2.setStroke(gridStroke);
    g2.setPaint(gridPaint);
    Line2D gridline = new Line2D.Double(xx+effect3d, yy-effect3d,
              plotArea.getMaxX(), yy-effect3d);
    g2.draw(gridline);
    Line2D grid3Dline = new Line2D.Double(xx, yy,
              xx+effect3d, yy-effect3d);
    g2.draw(grid3Dline);
###
2950, removeChangeListener, Title, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Title.java, 98, 99
4
/**
   * Unregisters an object for notification of changes to the chart title.
   * @param listener The object that is being unregistered.
   */
2
  public void removeChangeListener(TitleChangeListener listener) {
  listeners.remove(listener);
###
2951, Title, Title, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Title.java, 64, 66
3
/**
   * Standard constructor - builds a Title object.
   */
3
  protected Title(String title) {
  this.title = title;
  this.listeners = new java.util.ArrayList();
###
2952, VerticalNumberAxis3D, VerticalNumberAxis3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 137, 138
3
/**
   * Default constructor.
   */
2
  public VerticalNumberAxis3D() {
  super(null);
###
2954, getEffect3d, VerticalNumberAxis3D, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 144, 145
3
/**
   * Return axis 3d deep along 'Z' axis.
   */
2
  public double getEffect3d() {
    return effect3d;
###
2955, getTitle, Title, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Title.java, 72, 73
3
/**
   * Returns the title text.
   */
2
  public String getTitle() {
  return this.title;
###
2956, addChangeListener, Title, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Title.java, 90, 91
7
/**
   * Registers an object for notification of changes to the title.
   * @param listener The object that is being registered.
   */
 --------------
//notifyListeners(new TitleChangeEvent(this));
 --------------
2
  public void addChangeListener(TitleChangeListener listener) {
  listeners.add(listener);
###
2957, createInstance, Title, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Title.java, 57, 58
5
/**
   * Static factory method that returns a concrete subclass of Title.
   * @param title The chart title;
   * @param font The font for displaying the chart title;
   */
2
  public static Title createInstance(String title, Font font) {
  return new StandardTitle(title, font);
###
2958, getText, Tick, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Tick.java, 98, 99
4
/**
   * Returns the text version of the tick value.
   * @return The formatted version of the tick value;
   */
2
  public String getText() {
  return text;
###
2959, Tick, Tick, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Tick.java, 76, 77
6
/**
   * Standard constructor: creates a Tick with the specified properties.
   * @param formattedValue The formatted version of the tick value;
   * @param x The x-coordinate of the tick;
   * @param y The y-coordinate of the tick;
   */
2
  public Tick(String text, float x, float y) {
  this(text, text, x, y);
###
2960, Tick, Tick, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Tick.java, 63, 67
7
/**
   * Standard constructor: creates a Tick with the specified properties.
   * @param value The tick value;
   * @param formattedValue The formatted version of the tick value;
   * @param x The x-coordinate of the tick;
   * @param y The y-coordinate of the tick;
   */
5
  public Tick(Object value, String text, float x, float y) {
  this.value = value;
  this.text = text;
  this.x=x;
  this.y=y;
###
2961, getX, Tick, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Tick.java, 106, 107
4
/**
   * Returns the x-coordinate of the tick.
   * @return The x-coordinate of the tick.
   */
2
  public float getX() {
  return x;
###
2962, getNumericalValue, Tick, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/Tick.java, 84, 91
4
/**
   * Returns the numerical value of the tick, or null if the value is not a Number.
   * @return The tick value;
   */
8
  public Number getNumericalValue() {
  if (value instanceof Number) {
    return (Number)value;
  }
  else if (value instanceof Date) {
    return new Long(((Date)value).getTime());
  }
  else return null;
###
2963, draw, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 191, 195
6
/**
   * Draws the title on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device;
   * @param chartArea The area within which the title (and plot) should be drawn;
   * @return The area used by the title;
   */
5
  public void draw(Graphics2D g2, Rectangle2D titleArea) {
    if (this.position == TOP || this.position == BOTTOM) {
      drawHorizontal(g2, titleArea);
    }
    else throw new RuntimeException("TextTitle.draw(...) - invalid title position.");
###
2964, getPaint, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 118, 119
4
/**
   * Returns the paint used to display the title.
   * @return  An object that implements the Paint interface used to paint this title;
   */
2
  public Paint getPaint() {
    return this.paint;
###
2965, getFont, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 98, 99
4
/**
   * Returns the current title font.
   * @return  A Font object of the font used to render this title;
   */
2
  public Font getFont() {
    return this.font;
###
2966, getPreferredWidth, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 166, 171
3
/**
   * Returns the preferred width of the title.
   */
6
  public double getPreferredWidth(Graphics2D g2) {
    g2.setFont(font);
    FontRenderContext frc = g2.getFontRenderContext();
    Rectangle2D titleBounds = font.getStringBounds(text, frc);
    double titleWidth = insets.left+titleBounds.getWidth()+insets.right;
    return titleWidth;
###
2967, setPaint, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 127, 130
5
/**
   * Sets the Paint used to display the title and notifies registered listeners that the title has
   * been modified.
   * @param paint The new paint for displaying the chart title;
   */
4
  public void setPaint(Paint paint) {
    if (!this.paint.equals(paint)) {
      this.paint = paint;
      notifyListeners(new TitleChangeEvent(this));
###
2968, TextTitle, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 90, 91
3
/**
   * Default constructor - builds a TextTitle with some default attributes.
   */
2
  public TextTitle(String text) {
    this(text, new Font("Dialog", Font.PLAIN, 12));
###
2969, setText, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 147, 150
5
/**
   * Sets the title to the specified text. This method notifies registered listeners that the
   * title has been modified.
   * @param text A String of the new chart title;
   */
4
  public void setText(String text) {
    if (!this.text.equals(text)) {
      this.text = text;
      notifyListeners(new TitleChangeEvent(this));
###
2970, isValidPosition, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 158, 160
4
/**
   * Returns true for the positions that are valid for TextTitle (TOP and BOTTOM for now) and
   * false for all other positions.
   */
3
  public boolean isValidPosition(int position) {
    if ((position==AbstractTitle.TOP) || (position==AbstractTitle.BOTTOM)) return true;
    else return false;
###
2971, TextTitle, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 61, 66
1
/** Full constructor - builds a TextTitle with the specified properties. */
6
  public TextTitle(String text, Font font, Paint paint, int position, int horizontalAlignment,
           int verticalAlignment, Insets insets) {
    super(position, horizontalAlignment, verticalAlignment, insets);
    this.text = text;
    this.font = font;
    this.paint = paint;
###
2972, TextTitle, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 79, 80
3
/**
   * Default constructor - builds a TextTitle with some default attributes.
   */
2
  public TextTitle(String text, Font font) {
    this(text, font, Color.black);
###
2973, setFont, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 107, 110
5
/**
   * Sets the title font to the specified font and notifies registered listeners that the title
   * has been modified.
   * @param font  A Font object of the new font;
   */
4
  public void setFont(Font font) {
    if (!this.font.equals(font)) {
      this.font = font;
      notifyListeners(new TitleChangeEvent(this));
###
2974, drawHorizontal, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 203, 241
5
/**
   * Draws the title on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device;
   * @param chartArea The area within which the title (and plot) should be drawn;
   */
32
  protected void drawHorizontal(Graphics2D g2, Rectangle2D titleArea) {
    g2.setFont(this.font);
    g2.setPaint(this.paint);
    FontRenderContext frc = g2.getFontRenderContext();
    Rectangle2D titleBounds = font.getStringBounds(text, frc);
    LineMetrics lineMetrics = font.getLineMetrics(text, frc);
    double titleWidth = titleBounds.getWidth();
    double titleHeight = lineMetrics.getHeight();
    double titleY = titleArea.getY()+insets.top;
    // work out the vertical alignment...
    if (this.verticalAlignment==TOP) {
      titleY = titleY+titleHeight-lineMetrics.getLeading()-lineMetrics.getDescent();
    }
    else if (this.verticalAlignment==MIDDLE) {
      double space = (titleArea.getHeight()-insets.top-insets.bottom-titleHeight);
      titleY = titleY+(space/2)+titleHeight-lineMetrics.getLeading()-lineMetrics.getDescent();
    }
    else if (this.verticalAlignment==BOTTOM) {
      titleY = titleArea.getMaxY()-insets.bottom-lineMetrics.getLeading()-lineMetrics.getDescent();
    }
    // work out the horizontal alignment...
    double titleX = titleArea.getX()+insets.left;
    if (this.horizontalAlignment==CENTER) {
      titleX = titleX+((titleArea.getWidth()-insets.left-insets.right)/2)-(titleWidth/2);
    }
    else if (this.horizontalAlignment==LEFT) {
      titleX = titleArea.getX()+insets.left;
    }
    else if (this.horizontalAlignment == RIGHT) {
      titleX = titleArea.getMaxX()-insets.right-titleWidth;
    }
    g2.drawString(text, (float)(titleX), (float)(titleY));
###
2975, TextTitle, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 72, 73
3
/**
   * Default constructor - builds a TextTitle with some default attributes.
   */
2
  public TextTitle(String text, Font font, Paint paint) {
    this(text, font, paint, TOP, CENTER, MIDDLE, new Insets(2, 2, 2, 2));
###
2976, getPreferredHeight, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 177, 182
3
/**
   * Returns the preferred height of the title.
   */
6
  public double getPreferredHeight(Graphics2D g2) {
    g2.setFont(font);
    FontRenderContext frc = g2.getFontRenderContext();
    LineMetrics lineMetrics = font.getLineMetrics(text, frc);
    double titleHeight = insets.top+lineMetrics.getHeight()+insets.bottom;
    return titleHeight;
###
2977, getText, TextTitle, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TextTitle.java, 138, 139
4
/**
   * Returns the title text.
   * @return A String of the title text;
   */
2
  public String getText() {
    return text;
###
2978, getChart, ChartChangeEvent, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/event/ChartChangeEvent.java, 99, 100
3
/**
   * Returns a reference to the chart that generated the change event.
   */
2
  public JFreeChart getChart() {
    return chart;
###
2979, setChart, ChartChangeEvent, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/event/ChartChangeEvent.java, 107, 108
4
/**
   * Sets the chart that generated the change event.
   * @param chart The chart that generated the event.
   */
2
  public void setChart(JFreeChart chart) {
    this.chart = chart;
###
2980, getType, ChartChangeEvent, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/event/ChartChangeEvent.java, 114, 115
3
/**
   * Returns the event type.
   */
2
  public int getType() {
    return this.type;
###
2982, ChartChangeEvent, ChartChangeEvent, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/event/ChartChangeEvent.java, 90, 93
3
/**
   * Full constructor: returns a new ChartChangeEvent object with the specified type.
   */
4
  public ChartChangeEvent(Object source, JFreeChart chart, int type) {
    super(source);
    this.chart = chart;
    this.type = type;
###
2983, ChartChangeEvent, ChartChangeEvent, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/event/ChartChangeEvent.java, 74, 75
4
/**
   * Standard constructor: returns a new ChartChangeEvent object, type GENERAL.
   * @param source The source of the event (could be the chart, a title, an axis etc.)
   */
2
  public ChartChangeEvent(Object source) {
    this(source, null, GENERAL);
###
2984, ChartChangeEvent, ChartChangeEvent, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/event/ChartChangeEvent.java, 83, 84
5
/**
   * Standard constructor: returns a new ChartChangeEvent object, type GENERAL.
   * @param source The source of the event (could be the chart, a title, an axis etc.);
   * @param chart The chart that generated the event;
   */
2
  public ChartChangeEvent(Object source, JFreeChart chart) {
    this(source, chart, GENERAL);
###
2985, getPlotShapes, StandardXYItemRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/StandardXYItemRenderer.java, 89, 90
3
/**
   * Returns true if shapes are being plotted by the renderer.
   */
2
  public boolean getPlotShapes() {
    return this.plotShapes;
###
2986, StandardXYItemRenderer, StandardXYItemRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/StandardXYItemRenderer.java, 77, 82
4
/**
   * Standard constructor.
   * @param type of renderer.  Use one of the constants SHAPES, LINES or SHAPES_AND_LINES.
   */
6
  public StandardXYItemRenderer(int type) {
    if (type==SHAPES) this.plotShapes=true;
    if (type==LINES) this.plotLines=true;
    if (type==SHAPES_AND_LINES) {
      this.plotShapes = true;
      this.plotLines = true;
###
2987, StandardXYItemRenderer, StandardXYItemRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/StandardXYItemRenderer.java, 68, 70
3
/**
   * Default constructor.
   */
3
  public StandardXYItemRenderer() {
    this.plotShapes = true;
    this.plotLines = false;
###
2988, drawItem, StandardXYItemRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/StandardXYItemRenderer.java, 113, 144
13
/**
   * Draws the visual representation of a single data item.
   * @param g2 The graphics device.
   * @param plotArea The area within which the plot is being drawn.
   * @param plot The plot (can be used to obtain standard color information etc).
   * @param horizontalAxis The horizontal axis.
   * @param verticalAxis The vertical axis.
   * @param data The dataset.
   * @param series The series index.
   * @param item The item index.
   * @param translatedRangeZero Zero on the range axis (supplied so that, if it is required, it
   *    doesn't have to be calculated repeatedly).
   */
26
  public void drawItem(Graphics2D g2, Rectangle2D plotArea,
             Plot plot, ValueAxis horizontalAxis, ValueAxis verticalAxis,
             XYDataset data, int series, int item,
             double translatedRangeZero) {
    Paint seriesPaint = plot.getSeriesPaint(series);
    Stroke seriesStroke = plot.getSeriesStroke(series);
    g2.setPaint(seriesPaint);
    g2.setStroke(seriesStroke);
    // get the data point...
    Number x1 = data.getXValue(series, item);
    Number y1 = data.getYValue(series, item);
    double transX1 = horizontalAxis.translatedValue(x1, plotArea);
    double transY1 = verticalAxis.translatedValue(y1, plotArea);
    if (this.plotShapes) {
      Shape shape = plot.getShape(series, item, transX1, transY1, shapeScale);
      g2.draw(shape);
    }
    if (this.plotLines) {
      if (item>0) {
        // get the previous data point...
        Number x0 = data.getXValue(series, item-1);
        Number y0 = data.getYValue(series, item-1);
        double transX0 = horizontalAxis.translatedValue(x0, plotArea);
        double transY0 = verticalAxis.translatedValue(y0, plotArea);
        Line2D line = new Line2D.Double(transX0, transY0, transX1, transY1);
        g2.draw(line);
###
2989, AxisChangeEvent, AxisChangeEvent, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/event/AxisChangeEvent.java, 51, 53
4
/**
   * Default constructor: returns a new AxisChangeEvent.
   * @param axis The axis that generated the event.
   */
3
  public AxisChangeEvent(Axis axis) {
    super(axis);
    this.axis = axis;
###
2990, getPlotLines, StandardXYItemRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/StandardXYItemRenderer.java, 96, 97
3
/**
   * Returns true if lines are being plotted by the renderer.
   */
2
  public boolean getPlotLines() {
    return this.plotLines;
###
2991, getNearestTickUnit, TickUnits, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/TickUnits.java, 57, 64
3
/**
   * Returns the tick unit in the collection that is closest in size to the specified unit.
   */
8
  public TickUnit getNearestTickUnit(TickUnit unit) {
    int index = Collections.binarySearch(units, unit);
    if (index>=0) {
      return (TickUnit)units.get(index);
    }
    else {
      index = -(index + 1);
      return (TickUnit)units.get(Math.min(index, units.size()));
###
2992, barWidthsPerCategory, HorizontalBarRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarRenderer.java, 65, 66
5
/**
   *  This renderer shows each series within a category as a separate bar (as opposed to a
   *  stacked bar renderer).
   *  @param data The data being plotted.
   */
2
  public int barWidthsPerCategory(CategoryDataset data) {
    return data.getSeriesCount();
###
2993, hasItemGaps, HorizontalBarRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarRenderer.java, 56, 57
3
/**
   * Returns true, since for this renderer there are gaps between the items in one category.
   */
2
  public boolean hasItemGaps() {
    return true;
###
2994, drawBar, HorizontalBarRenderer, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarRenderer.java, 86, 142
17
/**
   * Draws the bar for a single (series, category) data item.
   * @param g2
   * @param plotArea
   * @param plot
   * @param valueAxis
   * @param data
   * @param series
   * @param category
   * @param categoryIndex
   * @param translatedZero
   * @param itemWidth
   * @param categorySpan
   * @param categoryGapSpan
   * @param itemSpan
   * @param itemGapSpan
   */
57
  public void drawBar(Graphics2D g2, Rectangle2D plotArea, BarPlot plot, ValueAxis valueAxis,
            CategoryDataset data, int series, Object category, int categoryIndex,
            double translatedZero, double itemWidth,
            double categorySpan, double categoryGapSpan,
            double itemSpan, double itemGapSpan) {

    // first check the value we are plotting...
    Number value = data.getValue(series, category);
    if (value!=null) {

      // X
      double translatedValue = valueAxis.translatedValue(value, plotArea);
      double rectX = Math.min(translatedZero, translatedValue);

      // Y
      double rectY = plotArea.getY() + plotArea.getHeight()*plot.getIntroGapPercent();

      int categories = data.getCategoryCount();
      int seriesCount = data.getSeriesCount();
      if (categories>1) {
        rectY = rectY
            // bars in completed categories
            + (categoryIndex*categorySpan/categories)
            // gaps between completed categories
            + (categoryIndex*categoryGapSpan/(categories-1))
            // bars+gaps completed in current category
            + (series*itemSpan/(categories*seriesCount));
        if (seriesCount>1) {
          rectY = rectY
              + (series*itemGapSpan/(categories*(seriesCount-1)));
        }
      }
      else {
        rectY = rectY
            // bars+gaps completed in current category;
            + (series*itemSpan/(categories*seriesCount));
        if (seriesCount>1) {
          rectY = rectY
              + (series*itemGapSpan/(categories*(seriesCount-1)));
        }
      }

      // WIDTH
      double rectWidth = Math.abs(translatedValue-translatedZero);

      // HEIGHT
      double rectHeight = itemWidth;

      // DRAW THE BAR...
      Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, rectHeight);
      Paint seriesPaint = plot.getSeriesPaint(series);
      g2.setPaint(seriesPaint);
      g2.fill(bar);
      if (itemWidth>BAR_OUTLINE_WIDTH_THRESHOLD) {
        g2.setStroke(plot.getSeriesStroke(series));
        g2.setPaint(plot.getSeriesOutlinePaint(series));
        g2.draw(bar);
###
2995, getSeriesName, SampleXYDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleXYDataset.java, 105, 112
5
/**
   * Returns the name of the series.
   * @param series The index (zero-based) of the series;
   * @return The name of the series.
   */
8
  public String getSeriesName(int series) {
    if (series==0) {
      return "y = cosine(x)";
    }
    else if (series==1) {
      return "y = 2*sine(x)";
    }
    else return "Error";
###
2996, getXValue, SampleXYDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleXYDataset.java, 75, 76
6
/**
   * Returns the x-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The x-value for the specified series and item.
   */
2
  public Number getXValue(int series, int item) {
    return new Double(-10.0+translate+(item*0.2));
###
2997, SampleXYDataset, SampleXYDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleXYDataset.java, 56, 57
3
/**
   * Default constructor.
   */
2
  public SampleXYDataset() {
    this.translate = 0.0;
###
2998, getMaxTickLabelHeight, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 426, 445
3
/**
   * A utility method for determining the height of the tallest tick label.
   */
20
  private double getMaxTickLabelHeight(Graphics2D g2, Rectangle2D drawArea, boolean vertical) {
  Font font = getTickLabelFont();
  g2.setFont(font);
  FontRenderContext frc = g2.getFontRenderContext();
  double maxHeight = 0.0;
  if (vertical) {
    Iterator iterator = this.ticks.iterator();
    while (iterator.hasNext()) {
    Tick tick = (Tick)iterator.next();
    Rectangle2D labelBounds = font.getStringBounds(tick.getText(), frc);
    if (labelBounds.getWidth()>maxHeight) {
      maxHeight = labelBounds.getWidth();
    }
    }
  }
  else {
    LineMetrics metrics = font.getLineMetrics("Sample", frc);
    maxHeight = metrics.getHeight();
  }
  return maxHeight;
###
2999, getSeriesCount, SampleXYDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleXYDataset.java, 96, 97
4
/**
   * Returns the number of series in the data source.
   * @return The number of series in the data source.
   */
2
  public int getSeriesCount() {
    return 2;
###
3000, getYValue, SampleXYDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleXYDataset.java, 85, 89
6
/**
   * Returns the y-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The y-value for the specified series and item.
   */
5
  public Number getYValue(int series, int item) {
    if (series==0) {
      return new Double(Math.cos(-10.0+translate+(item/10.0)));
    }
    else return new Double(2*(Math.sin(-10.0+translate+(item/10.0))));
###
3001, tickLabelsFit, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 391, 419
6
/**
   * Determines whether or not the tick labels fit given the available space.
   */
 --------------
// there are two special cases to handle
 --------------
29
  private boolean tickLabelsFit(int index,
          Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

  // generate one label at a time until all are done OR there is an overlap (so fit==FALSE)
  SimpleDateFormat dateFormatter = new SimpleDateFormat(standardTickFormats[index]);
  DateUnit units = new DateUnit(this.standardTickUnits[index][0], this.standardTickUnits[index][1]);
  double lastLabelExtent = Double.NEGATIVE_INFINITY;
  double labelExtent;
  boolean labelsFit = true;
  Date tickDate = this.calculateLowestVisibleTickValue(units);
  while (tickDate.before(this.maximumDate) && labelsFit) {
    double xx = this.translatedValue(tickDate, plotArea);
    String tickLabel = dateFormatter.format(tickDate);
    Rectangle2D tickLabelBounds = tickLabelFont.getStringBounds(tickLabel,
                  g2.getFontRenderContext());
    if (this.verticalTickLabels) {
    labelExtent = xx-(tickLabelBounds.getHeight()/2);
    if (labelExtent<lastLabelExtent) labelsFit = false;
    lastLabelExtent = xx+(tickLabelBounds.getHeight()/2);
    }
    else {
    labelExtent = xx-(tickLabelBounds.getWidth()/2);
    if (labelExtent<lastLabelExtent) labelsFit = false;
    lastLabelExtent = xx+(tickLabelBounds.getWidth()/2);
    }
    tickDate = units.addToDate(tickDate);
  }

  return labelsFit;
###
3002, calculateAutoTickUnits, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 361, 380
3
/**
   * Determines an appropriate tick value for the axis...
   */
20
  private void calculateAutoTickUnits(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

  // find the index of the largest standard tick magnitude that fits into the axis range
  int index = this.findAxisMagnitudeIndex();
  boolean labelsFit = true;
  while (labelsFit && index>0) {
    index=index-1;
    labelsFit = tickLabelsFit(index, g2, drawArea, plotArea);
  }

  if (labelsFit) {
    this.autoTickIndex=index;
  }
  else {
    this.autoTickIndex=Math.min(index+1, this.standardTickUnitMagnitudes.length);
  }

  this.tickLabelFormatter.applyPattern(this.standardTickFormats[autoTickIndex]);
  this.tickUnit = new DateUnit(this.standardTickUnits[autoTickIndex][0],
           this.standardTickUnits[autoTickIndex][1]);
###
3003, configure, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 153, 155
4
/**
   * Configures the axis to work with the specified plot.  If the axis has auto-scaling, then sets
   * the maximum and minimum values.
   */
3
  public void configure() {
  if (isAutoRange()) {
    this.autoAdjustRange();
###
3004, translatedValue, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 178, 184
5
/**
   * Translates the data value to the display coordinates (Java 2D User Space) of the chart.
   * @param date The date to be plotted;
   * @param plotArea The plot area in Java 2D User Space.
   */
7
  public double translatedValue(Date date, Rectangle2D plotArea) {
  double value = (double)date.getTime();
  double axisMin = (double)minimumDate.getTime();
  double axisMax = (double)maximumDate.getTime();
  double plotX = plotArea.getX();
  double plotMaxX = plotArea.getMaxX();
  return plotX + ((value - axisMin)/(axisMax - axisMin)) * (plotMaxX - plotX);
###
3005, setVerticalTickLabels, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 144, 146
4
/**
   * Sets the flag that determines whether the tick labels are drawn 'vertically'.
   * @param flag The new value of the flag;
   */
3
  public void setVerticalTickLabels(boolean flag) {
  this.verticalTickLabels = flag;
  this.notifyListeners(new com.jrefinery.chart.event.AxisChangeEvent(this));
###
3006, HorizontalDateAxis, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 120, 122
5
/**
   * Standard constructor - builds a HorizontalDateAxis with some default attributes.
   * @param label The axis label;
   * @param labelFont The font for displaying the axis label;
   */
3
  public HorizontalDateAxis(String label) {
  super(label);
  this.verticalTickLabels = false;
###
3007, reserveAxisArea, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 336, 354
3
/**
   * Returns area in which the axis will be displayed.
   */
19
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,
             double reservedWidth) {

  // calculate the height of the axis label...
  LineMetrics metrics = labelFont.getLineMetrics(label, g2.getFontRenderContext());
  double labelHeight = this.labelInsets.top+metrics.getHeight()+this.labelInsets.bottom;

  // calculate the height required for the tick labels (if visible);
  double tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom;
  if (tickLabelsVisible) {
    g2.setFont(tickLabelFont);
    this.refreshTicks(g2, drawArea, drawArea);
    tickLabelHeight = tickLabelHeight+getMaxTickLabelHeight(g2, drawArea,
                  this.verticalTickLabels);
  }

  return new Rectangle2D.Double(drawArea.getX(), drawArea.getMaxY(),
            drawArea.getWidth()-reservedWidth,
            labelHeight+tickLabelHeight);
###
3008, HorizontalDateAxis, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 78, 93
25
/**
   * Full constructor: returns a new HorizontalDateAxis with attributes as specified by the
   * caller. There are other constructors that use default values for some attributes.
   * @param label The axis label;
   * @param labelFont The font for displaying the axis label;
   * @param labelPaint The paint used to draw the axis label;
   * @param labelInsets The blank space around the axis label;
   * @param showTickLabels Flag indicating whether or not tick labels are visible;
   * @param tickLabelFont Font for displaying tick labels;
   * @param tickLabelPaint The paint used to display the tick labels;
   * @param tickLabelInsets The blank space around the tick labels;
   * @param verticalTickLabels A flag indicating whether or not tick labels are drawn vertically;
   * @param showTickMarks Flag indicating whether or not tick marks are visible;
   * @param tickMarkStroke The stroke used to draw tick marks (if visible);
   * @param autoScale Flag indicating whether or not the axis is automatically scaled to fit the
   *          data;
   * @param min The lowest value shown on the axis;
   * @param max The highest value shown on the axis;
   * @param autoUnits A flag indicating whether or not the tick units are automatically calculated;
   * @param tickUnits The tick units;
   * @param tickLabelFormatter The format object used to display tick labels;
   * @param showGridLines Flag indicating whether or not grid lines are visible for this axis;
   * @param gridStroke The Stroke used to display grid lines (if visible);
   * @param gridPaint The Paint used to display grid lines (if visible).
   */
16
  public HorizontalDateAxis(String label, Font labelFont,
          Paint labelPaint, Insets labelInsets,
          boolean showTickLabels, Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,
          boolean verticalTickLabels,
          boolean showTickMarks, Stroke tickMarkStroke,
          boolean autoRange, Date minimumDate, Date maximumDate,
          boolean autoUnits, DateUnit tickUnits, SimpleDateFormat tickLabelFormatter,
          boolean showGridLines, Stroke gridStroke, Paint gridPaint) {

  super(label, labelFont, labelPaint, labelInsets,
      showTickLabels, tickLabelFont, tickLabelPaint, tickLabelInsets,
      showTickMarks, tickMarkStroke,
      autoRange, minimumDate, maximumDate, autoUnits, tickUnits, tickLabelFormatter,
      showGridLines, gridStroke, gridPaint);

  this.verticalTickLabels = verticalTickLabels;
###
3009, reserveHeight, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 312, 329
6
/**
   * Returns the height required to draw the axis in the specified draw area.
   * @param g2 The graphics device;
   * @param plot The plot that the axis belongs to;
   * @param drawArea The area within which the plot should be drawn.
   */
18
  public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

  // calculate the height of the axis label...
  double labelHeight = 0.0;
  if (label!=null) {
    LineMetrics metrics = labelFont.getLineMetrics(label, g2.getFontRenderContext());
    labelHeight = this.labelInsets.top+metrics.getHeight()+this.labelInsets.bottom;
  }

  // calculate the height required for the tick labels (if visible);
  double tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom;
  if (tickLabelsVisible) {
    g2.setFont(tickLabelFont);
    this.refreshTicks(g2, drawArea, drawArea);
    tickLabelHeight = tickLabelHeight+getMaxTickLabelHeight(g2, drawArea,
                  this.verticalTickLabels);
  }
  return labelHeight+tickLabelHeight;
###
3010, refreshTicks, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 219, 245
3
/**
   * Recalculates the ticks for the date axis.
   */
27
  public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {
  this.ticks.clear();
  g2.setFont(tickLabelFont);
  if (this.autoTickUnit) {
    calculateAutoTickUnits(g2, drawArea, plotArea);
  }

  Date tickDate = this.calculateLowestVisibleTickValue(tickUnit);
  while (tickDate.before(this.maximumDate)) {
    // work out the value, label and position
    double xx = this.translatedValue(tickDate, plotArea);
    String tickLabel = this.tickLabelFormatter.format(tickDate);
    Rectangle2D tickLabelBounds = tickLabelFont.getStringBounds(tickLabel,
                  g2.getFontRenderContext());
    float x = 0.0f;
    float y = 0.0f;
    if (this.verticalTickLabels) {
    x = (float)(xx+tickLabelBounds.getHeight()/2);
    y = (float)(plotArea.getMaxY()+tickLabelInsets.top+tickLabelBounds.getWidth());
    }
    else {
    x = (float)(xx-tickLabelBounds.getWidth()/2);
    y = (float)(plotArea.getMaxY()+tickLabelInsets.top+tickLabelBounds.getHeight());
    }
    Tick tick = new Tick(tickDate, tickLabel, x, y);
    ticks.add(tick);
    tickDate = this.tickUnit.addToDate(tickDate);
###
3011, autoAdjustRange, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 190, 211
3
/**
   * Rescales the axis to ensure that all data is visible.
   */
22
  public void autoAdjustRange() {
  if (plot!=null) {
    if (plot instanceof HorizontalValuePlot) {
    HorizontalValuePlot hvp = (HorizontalValuePlot)plot;

        Number u = hvp.getMaximumHorizontalDataValue();
        long upper = new Date().getTime()+24L*60L*60L*1000L;
        if (u!=null) {
      upper = u.longValue();
        }

        Number l = hvp.getMinimumHorizontalDataValue();
        long lower = new Date().getTime();
        if (l!=null) {
      lower = l.longValue();
        }

    long range = upper-lower;
    upper = upper+(range/20);
    lower = lower-(range/20);
    this.minimumDate=new Date(lower);
    this.maximumDate=new Date(upper);
###
3012, getVerticalTickLabels, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 136, 137
3
/**
   * Returns a flag indicating whether the tick labels are drawn 'vertically'.
   */
2
  public boolean getVerticalTickLabels() {
  return this.verticalTickLabels;
###
3013, HorizontalDateAxis, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 128, 130
3
/**
   * Default constructor.
   */
3
  public HorizontalDateAxis() {
  super(null);
  this.verticalTickLabels = false;
###
3014, HorizontalDateAxis, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 104, 111
7
/**
   * Standard constructor: returns a HorizontalValueAxis with some default attributes.
   * @param label The axis label;
   * @param labelFont The font for displaying the axis label;
   * @param min The lowest value shown on the axis;
   * @param max The highest value shown on the axis;
   */
8
  public HorizontalDateAxis(String label, Font labelFont,
          Date minimumDate, Date maximumDate) {

  this(label, labelFont, Color.black, new Insets(4, 4, 4, 4),
     true, new Font("Arial", Font.PLAIN, 10), Color.black, new Insets(1, 2, 1, 1),
     true, true, new BasicStroke(1),
     false, minimumDate, maximumDate, false, new DateUnit(Calendar.DATE, 1),
     new SimpleDateFormat(), false, null, null);
###
3015, draw, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 256, 299
6
/**
   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device;
   * @param drawArea The area within which the chart should be drawn;
   * @param plotArea The area within which the plot should be drawn (a subset of the drawArea).
   */
44
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {
  // draw the axis label
  if (this.label!=null) {
    g2.setFont(labelFont);
    g2.setPaint(labelPaint);
    FontRenderContext frc = g2.getFontRenderContext();
    Rectangle2D labelBounds = labelFont.getStringBounds(label, frc);
    LineMetrics lm = labelFont.getLineMetrics(label, frc);
    float labelx = (float)(plotArea.getX()+plotArea.getWidth()/2-labelBounds.getWidth()/2);
    float labely = (float)(drawArea.getMaxY()-labelInsets.bottom-lm.getDescent()-lm.getLeading());
    g2.drawString(label, labelx, labely);
  }
  // draw the tick labels and marks
  this.refreshTicks(g2, drawArea, plotArea);
  float maxY = (float)plotArea.getMaxY();
  g2.setFont(getTickLabelFont());

  Iterator iterator = ticks.iterator();
  while (iterator.hasNext()) {
    Tick tick = (Tick)iterator.next();
    float xx = (float)this.translatedValue(tick.getNumericalValue(), plotArea);

    if (tickLabelsVisible) {
    g2.setPaint(this.tickLabelPaint);
    if (this.verticalTickLabels) {
      drawVerticalString(tick.getText(), g2, tick.getX(), tick.getY());
    }
    else {
      g2.drawString(tick.getText(), tick.getX(), tick.getY());
    }
    }

    if (tickMarksVisible) {
    g2.setStroke(this.getTickMarkStroke());
    Line2D mark = new Line2D.Float(xx, maxY-2, xx, maxY+2);
    g2.draw(mark);
    }

    if (showGridLines) {
    g2.setStroke(gridStroke);
    g2.setPaint(gridPaint);
    Line2D gridline = new Line2D.Float(xx, (float)plotArea.getMaxY(), xx,
               (float)plotArea.getMinY());
    g2.draw(gridline);
###
3016, translatedValue, HorizontalDateAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalDateAxis.java, 164, 170
5
/**
   * Translates the data value to the display coordinates (Java 2D User Space) of the chart.
   * @param dataValue The value to be plotted;
   * @param plotArea The plot area in Java 2D User Space.
   */
7
  public double translatedValue(Number dataValue, Rectangle2D plotArea) {
  double value = dataValue.doubleValue();
  double axisMin = (double)minimumDate.getTime();
  double axisMax = (double)maximumDate.getTime();
  double plotX = plotArea.getX();
  double plotMaxX = plotArea.getMaxX();
  return plotX + ((value - axisMin)/(axisMax - axisMin)) * (plotMaxX - plotX);
###
3017, setDrawOpenCloseTicks, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 94, 97
5
/**
   * Sets the property that tells this plot to draw open/close marks.
   * Once the value of this property is set, all listeners are notified
   * of the change.
   */
4
  public void setDrawOpenCloseTicks(boolean draw) {
  if (drawOpenClose != draw) {
    drawOpenClose = draw;
      notifyListeners(new PlotChangeEvent(this));
###
3018, draw, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 188, 232
5
/**
   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device;
   * @param drawArea The area within which the plot should be drawn.
   */
45
  public void draw(Graphics2D g2, Rectangle2D drawArea) {

  if (insets!=null) {
    drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,
                drawArea.getY()+insets.top,
              drawArea.getWidth()-insets.left-insets.right,
              drawArea.getHeight()-insets.top-insets.bottom);
  }

  // we can cast the axes because HiLowPlot enforces support of these interfaces
  HorizontalAxis ha = getHorizontalAxis();
  VerticalAxis va = getVerticalAxis();

  double h = ha.reserveHeight(g2, this, drawArea);
  Rectangle2D vAxisArea = va.reserveAxisArea(g2, this, drawArea, h);

  // compute the plot area
  Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),
                drawArea.getY(),
                drawArea.getWidth()-vAxisArea.getWidth(),
                drawArea.getHeight()-h);

  drawOutlineAndBackground(g2, plotArea);

  // draw the axes

  this.horizontalAxis.draw(g2, drawArea, plotArea);
  this.verticalAxis.draw(g2, drawArea, plotArea);

  Shape originalClip = g2.getClip();
  g2.clip(plotArea);

  java.util.List lines = getLines(plotArea);   // area should be remaining area only
  for (int i=0; i<lines.size(); i++) {
      HighLow l = (HighLow)lines.get(i);
    g2.setPaint(l.getPaint());
    g2.setStroke(l.getStroke());
    g2.draw(l.getLine());
    if (getDrawOpenCloseTicks()) {
      g2.draw(l.getOpenTickLine());
      g2.draw(l.getCloseTickLine());
    }
  }

  g2.setClip(originalClip);
###
3019, isCompatibleHorizontalAxis, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 159, 166
5
/**
   * Checks the compatibility of a horizontal axis, returning true if the axis is compatible with
   * the plot, and false otherwise.
   * @param axis The horizontal axis.
   */
8
  public boolean isCompatibleHorizontalAxis(Axis axis) {
  if (axis instanceof HorizontalNumberAxis) {
    return true;
  }
  else if (axis instanceof HorizontalDateAxis) {
    return true;
  }
    else return false;
###
3020, getLines, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 120, 151
3
/**
   * Returns a list of HighLow elements that will fit inside the specified area.
   */
32
  private java.util.List getLines(Rectangle2D plotArea) {
  ArrayList elements = new ArrayList();
  HighLowDataset data = getDataset();
  if (data != null) {
    int seriesCount = data.getSeriesCount();

    for (int series=0; series<seriesCount; series++) {
      int itemCount = data.getItemCount(series);
      //if (itemCount % 4 != 0)
      //  continue;

      for(int itemIndex = 0; itemIndex < itemCount; itemIndex++) {
        Number x = data.getXValue(series, itemIndex);
        Number yHigh  = data.getHighValue(series,itemIndex);
        Number yLow   = data.getLowValue(series,itemIndex);
        Number yOpen  = data.getOpenValue(series,itemIndex);
        Number yClose = data.getCloseValue(series,itemIndex);

        double xx = getHorizontalValueAxis().translatedValue(x, plotArea);
        double yyHigh = getVerticalValueAxis().translatedValue(yHigh, plotArea);
        double yyLow = getVerticalValueAxis().translatedValue(yLow, plotArea);
        double yyOpen = getVerticalValueAxis().translatedValue(yOpen, plotArea);
        double yyClose = getVerticalValueAxis().translatedValue(yClose, plotArea);

        Paint p = this.getSeriesPaint(series);
        Stroke s = this.getSeriesStroke(series);

        elements.add(new HighLow(xx, yyHigh, yyLow, yyOpen, yyClose, s, p));
      }
    }
  }
  return elements;
###
3021, getMaximumHorizontalDataValue, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 260, 265
4
/**
   * Returns the maximum value in the domain, since this is plotted against the horizontal axis
   * for a HighLowPlot.
   */
6
  public Number getMaximumHorizontalDataValue() {
  Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMaximumDomainValue(data);
  }
  else return null;
###
3022, getDrawOpenCloseTicks, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 85, 86
3
/**
   * Returns true if this plot draws open/close marks.
   */
2
  public boolean getDrawOpenCloseTicks() {
  return drawOpenClose;
###
3023, HighLowPlot, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 69, 72
6
/**
   * Standard constructor: returns an HiLowPlot with attributes specified by the caller.
   *
   * @param horizontalAxis The horizontal axis.
   * @param verticalAxis The vertical axis.
   */
4
  public HighLowPlot(Axis horizontalAxis, Axis verticalAxis) throws AxisNotCompatibleException,
                                    PlotNotCompatibleException
  {
  super(horizontalAxis, verticalAxis);
###
3024, getDataset, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 78, 79
3
/**
   * A convenience method that returns the dataset for the plot, cast as an HighLowDataset.
   */
2
  public HighLowDataset getDataset() {
  return (HighLowDataset)chart.getDataset();
###
3025, isCompatibleVerticalAxis, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 175, 180
6
/**
   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with
   * the plot, and false otherwise.  The vertical axis for this plot must be an instance of
   * VerticalNumberAxis.
   * @param axis The vertical axis.
   */
6
  public boolean isCompatibleVerticalAxis(Axis axis)
  {
  if (axis instanceof VerticalNumberAxis)
    return true;
  else
    return false;
###
3026, getHorizontalValueAxis, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 105, 106
4
/**
   * A convenience method that returns a reference to the horizontal axis cast as a
   * HorizontalValueAxis.
   */
2
  public ValueAxis getHorizontalValueAxis() {
  return (ValueAxis)horizontalAxis;
###
3027, getVerticalValueAxis, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 113, 114
4
/**
   * A convenience method that returns a reference to the vertical axis cast as a
   * VerticalNumberAxis.
   */
2
  public ValueAxis getVerticalValueAxis() {
  return (ValueAxis)verticalAxis;
###
3028, getPlotType, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 238, 239
3
/**
   * Returns the plot type as a string. This implementation returns "HiLow Plot".
   */
2
  public String getPlotType() {
  return "HiLow Plot";
###
3029, getMinimumVerticalDataValue, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 272, 277
4
/**
   * Returns the minimum value in the range, since this is plotted against the vertical axis for
   * a HighLowPlot.
   */
6
  public Number getMinimumVerticalDataValue() {
  Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMinimumRangeValue(data);
  }
  else return null;
###
3030, getMinimumHorizontalDataValue, HighLowPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLowPlot.java, 246, 252
4
/**
   * Returns the minimum value in the domain, since this is plotted against the horizontal axis
   * for a HighLowPlot.
   */
7
  public Number getMinimumHorizontalDataValue() {

  Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMinimumDomainValue(data);
  }
  else return null;
###
3031, setRenderer, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 102, 104
4
/**
   * Sets the renderer for the bar plot.
   * @param renderer The renderer.
   */
3
  public void setRenderer(HorizontalBarRenderer renderer) {
    this.renderer = renderer;
    this.notifyListeners(new PlotChangeEvent(this));
###
3032, setHorizontalAxis, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 145, 147
5
/**
   * Sets the horizontal axis for the plot.  This method should throw an exception if the axis
   * doesn't implement the required interfaces.
   * @param axis The new horizontal axis;
   */
3
  public void setHorizontalAxis(Axis axis) throws AxisNotCompatibleException {
  // check that the axis implements the required interface (if not raise an exception);
  super.setHorizontalAxis(axis);
###
3033, setVerticalAxis, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 127, 129
5
/**
   * Sets the vertical axis for the plot.  This method should throw an exception if the axis
   * doesn't implement the required interfaces.
   * @param vAxis The new vertical axis;
   */
3
  public void setVerticalAxis(Axis vAxis) throws AxisNotCompatibleException {
  // check that the axis implements the required interface (if not raise an exception);
  super.setVerticalAxis(vAxis);
###
3034, getCategoryCoordinate, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 162, 185
5
/**
   * Returns the x-coordinate (in Java 2D User Space) of the center of the specified category.
   * @param category The index of the category of interest (first category index = 0).
   * @param area The region within which the plot will be drawn.
   */
24
  public double getCategoryCoordinate(int category, Rectangle2D area) {

    // calculate first part of result...
    double result = area.getY()+(area.getHeight()*introGapPercent);


    // then add some depending on how many categories...
    int categoryCount = getDataset().getCategoryCount();
    if (categoryCount>1) {

    double categorySpan = area.getHeight()
                  *(1-introGapPercent-trailGapPercent-categoryGapsPercent);
      double categoryGapSpan = area.getHeight()*categoryGapsPercent;
      result = result
           + (category+0.5)*(categorySpan/categoryCount)
           + (category)*(categoryGapSpan/(categoryCount-1));

    }
    else {
      result = result
           + (category+0.5)*area.getHeight()*(1-introGapPercent-trailGapPercent);
    }

    return result;
###
3035, getDataset, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 110, 111
3
/**
   * A convenience method that returns the dataset for the plot, cast as a CategoryDataset.
   */
2
  public CategoryDataset getDataset() {
  return (CategoryDataset)chart.getDataset();
###
3036, calculateBarWidth, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 309, 327
4
/**
   * Returns the width of each bar in the chart.
   * @param plotArea The area within which the plot will be drawn.
   */
19
  double calculateBarWidth(Rectangle2D plotArea) {

  CategoryDataset data = getDataset();

  // series, category and bar counts
  int categoryCount = data.getCategoryCount();
  int seriesCount = data.getSeriesCount();
  int barCount = renderer.barWidthsPerCategory(data)*categoryCount;

  // calculate the plot height (bars are horizontal) less whitespace
  double usable = plotArea.getHeight() *
                  (1.0 - introGapPercent - trailGapPercent - categoryGapsPercent);

    if (renderer.barWidthsPerCategory(data)>1) {
//    usable = usable - ((seriesCount-1) * categoryCount * seriesGap);
    }

  // and thus the width of the bars
  return usable/barCount;
###
3037, getMinimumHorizontalDataValue, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 341, 347
4
/**
   * Returns the minimum value in the range, since this is plotted against the horizontal axis for
   * a HorizontalBarPlot.
   */
7
  public Number getMinimumHorizontalDataValue() {

  Dataset data = this.getChart().getDataset();
  if (data!=null) {
    return Datasets.getMinimumRangeValue(data);
  }
  else return null;
###
3038, isCompatibleVerticalAxis, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 206, 210
5
/**
   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with
   * the plot, and false otherwise.
   * @param axis The vertical axis;
   */
5
  public boolean isCompatibleVerticalAxis(Axis axis) {
  if (axis instanceof VerticalCategoryAxis) {
    return true;
  }
  else return false;
###
3039, getCategories, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 153, 154
3
/**
   * A convenience method that returns a list of the categories in the data source.
   */
2
  public java.util.List getCategories() {
  return getDataset().getCategories();
###
3040, isCompatibleHorizontalAxis, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 194, 198
5
/**
   * Checks the compatibility of a horizontal axis, returning true if the axis is compatible with
   * the plot, and false otherwise.
   * @param axis The horizontal axis;
   */
5
  public boolean isCompatibleHorizontalAxis(Axis axis) {
  if (axis instanceof HorizontalNumberAxis) {
    return true;
  }
  else return false;
###
3041, getCategoryAxis, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 136, 137
4
/**
   * A convenience method that returns a reference to the horizontal axis cast as a
   * CategoryAxis.
   */
2
  public CategoryAxis getCategoryAxis() {
  return (CategoryAxis)verticalAxis;
###
3042, HorizontalBarPlot, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 72, 80
10
/**
   * Standard constructor: returns a BarPlot with attributes specified by the caller.
   * @param horizontalAxis The horizontal axis.
   * @param verticalAxis The vertical axis.
   * @param introGapPercent The gap before the first bar in the plot.
   * @param trailGapPercent The gap after the last bar in the plot.
   * @param categoryGapPercent The gap between the last bar in one category and the first bar in
   *               the next category.
   * @param seriesGapPercent The gap between bars within the same category.
   */
9
  public HorizontalBarPlot(Axis horizontalAxis, Axis verticalAxis, Insets insets,
         double introGapPercent, double trailGapPercent,
               double categoryGapPercent, double seriesGapPercent)
    throws AxisNotCompatibleException, PlotNotCompatibleException
  {

  super(horizontalAxis, verticalAxis, insets,
        introGapPercent, trailGapPercent, categoryGapPercent, seriesGapPercent);
    this.renderer = new HorizontalBarRenderer();
###
3043, draw, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 218, 300
5
/**
   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device;
   * @param drawArea The area within which the plot should be drawn;
   */
83
  public void draw(Graphics2D g2, Rectangle2D drawArea) {

    // adjust the drawing area for the plot insets (if any)...
  if (insets!=null) {
    drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,
              drawArea.getY()+insets.top,
              drawArea.getWidth()-insets.left-insets.right,
              drawArea.getHeight()-insets.top-insets.bottom);
  }

  // estimate the area required for drawing the axes...
  VerticalAxis vAxis = getVerticalAxis();
  HorizontalAxis hAxis = getHorizontalAxis();
  double vAxisAreaWidth = vAxis.reserveWidth(g2, this, drawArea);
  Rectangle2D hAxisArea = hAxis.reserveAxisArea(g2, this, drawArea, vAxisAreaWidth);

  // and this the area available for plotting...
  Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisAreaWidth,
                drawArea.getY(),
                drawArea.getWidth()-vAxisAreaWidth,
                drawArea.getHeight()-hAxisArea.getHeight());

    // draw the background and axes...
  drawOutlineAndBackground(g2, plotArea);
  getCategoryAxis().draw(g2, drawArea, plotArea);
  getValueAxis().draw(g2, drawArea, plotArea);

    // now get the data and plot the bars...
    CategoryDataset data = this.getDataset();
    if (data!=null) {
      Shape savedClip = g2.getClip();
      g2.clip(plotArea);

      // draw a line at zero...
      double translatedZero = getValueAxis().translatedValue(Plot.ZERO, plotArea);
      Line2D baseline = new Line2D.Double(translatedZero, plotArea.getY(),
                        translatedZero, plotArea.getMaxY());
      g2.setStroke(new BasicStroke());
      g2.draw(baseline);

      int seriesCount = data.getSeriesCount();
      int categoryCount = data.getCategoryCount();
      int barCount = renderer.barWidthsPerCategory(data);

      // work out the span dimensions for the categories...
      double categorySpan = 0.0;
      double categoryGapSpan = 0.0;
      if (categoryCount>1) {
        categorySpan = plotArea.getHeight()*
                 (1-introGapPercent-trailGapPercent-categoryGapsPercent);
        categoryGapSpan = plotArea.getHeight()*categoryGapsPercent;
      }
      else {
        categorySpan = plotArea.getHeight()*(1-introGapPercent-trailGapPercent);
      }

      // work out the item span...
      double itemSpan = categorySpan;
      double itemGapSpan = 0.0;
      if (seriesCount>1) {
        if (renderer.hasItemGaps()) {
          itemGapSpan = plotArea.getHeight()*itemGapsPercent;
          itemSpan = itemSpan - itemGapSpan;
        }
      }
      double itemWidth = itemSpan/(categoryCount*renderer.barWidthsPerCategory(data));

      int categoryIndex = 0;
      Iterator iterator = data.getCategories().iterator();
      while (iterator.hasNext()) {

        Object category = iterator.next();
        for (int series=0; series<seriesCount; series++) {
          renderer.drawBar(g2, plotArea, this, this.getValueAxis(), data, series,
                   category, categoryIndex,
                   translatedZero, itemWidth, categorySpan, categoryGapSpan,
                   itemSpan, itemGapSpan);
        }
        categoryIndex++;

      }

      g2.setClip(savedClip);
###
3044, getValueAxis, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 118, 119
4
/**
   * A convenience method that returns a reference to the vertical axis cast as a
   * VerticalValueAxis.
   */
2
  public HorizontalNumberAxis getValueAxis() {
  return (HorizontalNumberAxis)horizontalAxis;
###
3045, getPlotType, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 333, 334
3
/**
   * Returns a short string describing the type of plot.
   */
2
  public String getPlotType() {
  return "Horizontal Bar Plot";
###
3046, HorizontalBarPlot, HorizontalBarPlot, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalBarPlot.java, 89, 94
5
/**
   * Constructs a horizontal bar plot with the specified axes.
   * @param horizontalAxis The horizontal axis.
   * @param verticalAxis The vertical axis.
   */
6
  public HorizontalBarPlot(Axis horizontalAxis, Axis verticalAxis)
      throws AxisNotCompatibleException, PlotNotCompatibleException
  {

    super(horizontalAxis, verticalAxis);
    this.renderer = new HorizontalBarRenderer();
###
3047, getCloseTickLine, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 167, 168
3
/**
   * Returns the line. for close tick
   */
2
  public Line2D getCloseTickLine() {
  return getTickLine(getLine().getX1(), getValue(CLOSE), getTickSize());
###
3048, setValue, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 150, 154
5
/**
   * Sets either OPEN or Close value depending on the valueType.
   * @param valueType
   * @param newValue
   */
5
  public void setValue(int valueType, double newValue) {
  if (valueType == OPEN)
    open = newValue;
  else
    close = newValue;
###
3049, setTickSize, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 116, 117
4
/**
   * Sets the width of the open/close tick.
   * @param newSize
   */
2
  public void setTickSize(double newSize) {
  tickSize = newSize;
###
3050, getTickSize, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 123, 124
3
/**
   * Returns the width of the open/close tick.
   */
2
  public double getTickSize() {
  return tickSize;
###
3052, HighLow, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 101, 108
10
/**
   * Constructs a high-low item.
   * @param x
   * @param high
   * @param low
   * @param open
   * @param close
   * @param stroke
   * @param paint
   */
8
  public HighLow(double x, double high, double low, double open, double close,
       Stroke stroke, Paint paint) {

    this.line = new Line2D.Double(x, high, x, low);
  this.open = open;
  this.close = close;
  this.stroke = stroke;
  this.paint = paint;
###
3053, getOpenTickLine, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 160, 161
3
/**
   * Returns the line for open tick.
   */
2
  public Line2D getOpenTickLine() {
  return getTickLine(getLine().getX1(), getValue(OPEN), (-1) * getTickSize());
###
3054, getValue, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 138, 142
4
/**
   * Returns either OPEN or Close value depending on the valueType.
   * @param valueType
   */
5
  public double getValue(int valueType) {
  if (valueType == OPEN)
    return open;
  else
    return close;
###
3055, getStroke, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 181, 182
3
/**
   * Returns the Stroke object used to draw the line.
   */
2
  public Stroke getStroke() {
  return stroke;
###
3056, getLine, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 130, 131
3
/**
   * Returns the line.
   */
2
  public Line2D getLine() {
  return line;
###
3057, HighLow, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 75, 76
6
/**
   * Constructs a high-low item, with default values for the open/close and colors.
   * @param x
   * @param high
   * @param low
   */
2
  public HighLow(double x, double high, double low) {
  this(x, high, low, high, low, new BasicStroke(), Color.blue);
###
3058, HighLow, HighLow, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HighLow.java, 87, 88
8
/**
   * Constructs a high-low item, with default values for the colors.
   * @param x
   * @param high
   * @param low
   * @param open
   * @param close
   */
2
  public HighLow(double x, double high, double low, double open, double close) {
  this(x, high, low, open, close, new BasicStroke(), Color.blue);
###
3059, getCount, DateUnit, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateUnit.java, 68, 69
3
/**
   * Returns the number of units.
   */
2
  public int getCount() {
  return this.count;
###
3060, DateUnit, DateUnit, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateUnit.java, 53, 55
3
/**
   * Builds a DateUnit.
   */
3
  public DateUnit(int field, int count) {
  this.field = field;
  this.count = count;
###
3061, getField, DateUnit, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/DateUnit.java, 61, 62
3
/**
   * Returns the field used for this DateUnit.
   */
2
  public int getField() {
  return this.field;
###
3063, getVerticalTickLabels, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 163, 164
3
/**
   * Returns a flag indicating whether the tick labels are drawn 'vertically'.
   */
2
  public boolean getVerticalTickLabels() {
  return this.verticalTickLabels;
###
3064, reserveHeight, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 348, 362
6
/**
   * Returns the height required to draw the axis in the specified draw area.
   * @param g2 The graphics device;
   * @param plot The plot that the axis belongs to;
   * @param drawArea The area within which the plot should be drawn;
   */
15
  public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

  // calculate the height of the axis label...
  LineMetrics metrics = labelFont.getLineMetrics(label, g2.getFontRenderContext());
  double labelHeight = this.labelInsets.top+metrics.getHeight()+this.labelInsets.bottom;

  // calculate the height required for the tick labels (if visible);
  double tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom;
  if (tickLabelsVisible) {
    g2.setFont(tickLabelFont);
    this.refreshTicks(g2, drawArea, drawArea);
    tickLabelHeight = tickLabelHeight+getMaxTickLabelHeight(g2, drawArea,
                  this.verticalTickLabels);
  }
  return labelHeight+tickLabelHeight;
###
3065, autoAdjustRange, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 203, 240
3
/**
   * Rescales the axis to ensure that all data is visible.
   */
38
  public void autoAdjustRange() {

  if (plot!=null) {
    if (plot instanceof HorizontalValuePlot) {
    HorizontalValuePlot hvp = (HorizontalValuePlot)plot;

        Number u = hvp.getMaximumHorizontalDataValue();
        double upper = this.DEFAULT_MAXIMUM_AXIS_VALUE.doubleValue();
        if (u!=null) {
      upper = u.doubleValue();
        }

        Number l = hvp.getMinimumHorizontalDataValue();
        double lower = this.DEFAULT_MINIMUM_AXIS_VALUE.doubleValue();
        if (l!=null) {
      lower = l.doubleValue();
        }

    double range = upper-lower;

        // ensure the autorange is at least <minRange> in size...
    double minRange = this.autoRangeMinimumSize.doubleValue();
    if (range<minRange) {
      upper = (upper+lower+minRange)/2;
      lower = (upper+lower-minRange)/2;
    }

    if (this.autoRangeIncludesZero()) {
      if (upper!=0.0) upper = Math.max(0.0, upper+upperMargin*range);
      if (lower!=0.0) lower = Math.min(0.0, lower-lowerMargin*range);
    }
    else {
      if (upper!=0.0) upper = upper+upperMargin*range;
      if (lower!=0.0) lower = lower-lowerMargin*range;
    }

    this.minimumAxisValue=new Double(lower);
    this.maximumAxisValue=new Double(upper);
###
3066, setVerticalTickLabels, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 171, 173
4
/**
   * Sets the flag that determines whether the tick labels are drawn 'vertically'.
   * @param flag The new value of the flag;
   */
3
  public void setVerticalTickLabels(boolean flag) {
  this.verticalTickLabels = flag;
  this.notifyListeners(new com.jrefinery.chart.event.AxisChangeEvent(this));
###
3067, translatedValue, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 191, 197
5
/**
   * Translates the data value to the display coordinates (Java 2D User Space) of the chart.
   * @param dataValue The value to be plotted;
   * @param plotArea The plot area in Java 2D User Space;
   */
7
  public double translatedValue(Number dataValue, Rectangle2D plotArea) {
  double value = dataValue.doubleValue();
  double axisMin = minimumAxisValue.doubleValue();
  double axisMax = maximumAxisValue.doubleValue();
  double plotX = plotArea.getX();
  double plotMaxX = plotArea.getMaxX();
  return plotX + ((value - axisMin)/(axisMax - axisMin)) * (plotMaxX - plotX);
###
3068, refreshTicks, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 253, 284
7
/**
   * Calculates the positions of the tick labels for the axis, storing the results in the
   * tick label list (ready for drawing).
   * @param g2 The graphics device.
   * @param drawArea The area in which the plot and the axes should be drawn.
   * @param plotArea The area in which the plot should be drawn.
   */
32
  public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

  this.ticks.clear();

  g2.setFont(tickLabelFont);

  if (this.autoTickUnit) {
    selectAutoTickUnit(g2, drawArea, plotArea);
  }

  double size = this.tickUnit.getValue().doubleValue();
  int count = this.calculateVisibleTickCount();
  double lowestTickValue = this.calculateLowestVisibleTickValue();
  //tickLabelFormatter = new DecimalFormat(tickLabelFormatter.toPattern());
  for (int i=0; i<count; i++) {
    Number currentTickValue = new Double(lowestTickValue+(i*size));
    double xx = this.translatedValue(currentTickValue, plotArea);
    String tickLabel = this.valueToString(currentTickValue);
    Rectangle2D tickLabelBounds = tickLabelFont.getStringBounds(tickLabel,
                  g2.getFontRenderContext());
    float x = 0.0f;
    float y = 0.0f;
    if (this.verticalTickLabels) {
    x = (float)(xx+tickLabelBounds.getHeight()/2);
    y = (float)(plotArea.getMaxY()+tickLabelInsets.top+tickLabelBounds.getWidth());
    }
    else {
    x = (float)(xx-tickLabelBounds.getWidth()/2);
    y = (float)(plotArea.getMaxY()+tickLabelInsets.top+tickLabelBounds.getHeight());
    }
    Tick tick = new Tick(currentTickValue, tickLabel, x, y);
    ticks.add(tick);
###
3069, reserveAxisArea, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 373, 390
7
/**
   * Returns area in which the axis will be displayed.
   * @param g2 The graphics device;
   * @param plot A reference to the plot;
   * @param drawArea The area within which the plot and axes should be drawn;
   * @param reservedWidth The space already reserved for the vertical axis;
   */
18
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,
             double reservedWidth) {

  // calculate the height of the axis label...
  LineMetrics metrics = labelFont.getLineMetrics(label, g2.getFontRenderContext());
  double labelHeight = this.labelInsets.top+metrics.getHeight()+this.labelInsets.bottom;

  // calculate the height required for the tick labels (if visible);
  double tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom;
  if (tickLabelsVisible) {
    g2.setFont(tickLabelFont);
    this.refreshTicks(g2, drawArea, drawArea);
    tickLabelHeight = tickLabelHeight+getMaxTickLabelHeight(g2, drawArea,
                  this.verticalTickLabels);
  }
  return new Rectangle2D.Double(drawArea.getX(), drawArea.getMaxY(),
            drawArea.getWidth()-reservedWidth,
            labelHeight+tickLabelHeight);
###
3070, HorizontalNumberAxis, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 83, 108
28
/**
   * Constructs a horizontal number axis.
   * @param label The axis label.
   * @param labelFont The font for displaying the axis label.
   * @param labelPaint The color used to draw the axis label.
   * @param labelInsets The blank space around the axis label.
   * @param tickLabelsVisible Flag indicating whether or not the tick labels are visible.
   * @param tickLabelFont Font for displaying the tick labels.
   * @param tickLabelPaint The color used to display the tick labels.
   * @param tickLabelInsets The blank space around the tick labels.
   * @param verticalTickLabels A flag indicating whether or not tick labels are drawn vertically.
   * @param tickMarksVisible Flag indicating whether or not tick marks are visible.
   * @param tickMarkStroke The stroke used to draw tick marks (if visible).
   * @param autoRange Flag indicating whether or not the axis range is automatically determined to
   *          fit the data.
   * @param autoRangeIncludesZero A flag indicating whether or not the axis range *must* include
   *                zero.
   * @param autoRangeMinimum The smallest axis range permitted (avoids problems with a 'zero'
   *             range).
   * @param minimumAxisValue The lowest value shown on the axis.
   * @param maximumAxisValue The highest value shown on the axis.
   * @param autoTickUnit A flag indicating whether or not the tick value is automatically
   *           selected from the range of standard tick units.
   * @param tickUnit The tick unit.
   * @param gridLinesVisible Flag indicating whether or not grid lines are visible for this axis;
   * @param gridStroke The Stroke used to display grid lines (if visible);
   * @param gridPaint The Paint used to display grid lines (if visible).
   */
26
  public HorizontalNumberAxis(String label,
                Font labelFont, Paint labelPaint, Insets labelInsets,
        boolean tickLabelsVisible,
                Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,
        boolean verticalTickLabels,
        boolean tickMarksVisible, Stroke tickMarkStroke,
                boolean autoRange, boolean autoRangeIncludesZero,
                Number autoRangeMinimumSize,
        Number minimumAxisValue, Number maximumAxisValue,
        boolean autoTickUnitSelection, NumberTickUnit tickUnit,
        boolean gridLinesVisible,
                Stroke gridStroke, Paint gridPaint) {

  super(label,
        labelFont, labelPaint, labelInsets,
      tickLabelsVisible,
        tickLabelFont, tickLabelPaint, tickLabelInsets,
      tickMarksVisible, tickMarkStroke,
      autoRange, autoRangeIncludesZero,
        autoRangeMinimumSize,
      minimumAxisValue, maximumAxisValue,
        autoTickUnitSelection, tickUnit,
      gridLinesVisible,
        gridStroke, gridPaint);

  this.verticalTickLabels = verticalTickLabels;
###
3071, draw, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 295, 336
6
/**
   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).
   * @param g2 The graphics device;
   * @param drawArea The area within which the chart should be drawn;
   * @param plotArea The area within which the plot should be drawn (a subset of the drawArea);
   */
42
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

  // draw the axis label
  g2.setFont(labelFont);
  g2.setPaint(labelPaint);
  FontRenderContext frc = g2.getFontRenderContext();
  Rectangle2D labelBounds = labelFont.getStringBounds(label, frc);
  LineMetrics lm = labelFont.getLineMetrics(label, frc);
  float labelx = (float)(plotArea.getX()+plotArea.getWidth()/2-labelBounds.getWidth()/2);
  float labely = (float)(drawArea.getMaxY()-labelInsets.bottom-lm.getDescent()-lm.getLeading());
  g2.drawString(label, labelx, labely);

  // draw the tick labels and marks
  this.refreshTicks(g2, drawArea, plotArea);

  float maxY = (float)plotArea.getMaxY();
  g2.setFont(getTickLabelFont());

  Iterator iterator = ticks.iterator();
  while (iterator.hasNext()) {
    Tick tick = (Tick)iterator.next();
    float xx = (float)this.translatedValue(tick.getNumericalValue(), plotArea);
    if (tickLabelsVisible) {
    g2.setPaint(this.tickLabelPaint);
    if (this.verticalTickLabels) {
      drawVerticalString(tick.getText(), g2, tick.getX(), tick.getY());
    }
    else {
      g2.drawString(tick.getText(), tick.getX(), tick.getY());
    }
    }
    if (tickMarksVisible) {
    g2.setStroke(this.getTickMarkStroke());
    Line2D mark = new Line2D.Float(xx, maxY-2, xx, maxY+2);
    g2.draw(mark);
    }
    if (showGridLines) {
    g2.setStroke(gridStroke);
    g2.setPaint(gridPaint);
    Line2D gridline = new Line2D.Float(xx, (float)plotArea.getMaxY(), xx,
               (float)plotArea.getMinY());
    g2.draw(gridline);
###
3072, getMaxTickLabelHeight, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 452, 471
6
/**
   * A utility method for determining the height of the tallest tick label.
   * @param g2 The graphics device;
   * @param drawArea The area within which the plot and axes should be drawn;
   * @param vertical A flag that indicates whether or not the tick labels are 'vertical';
   */
20
  private double getMaxTickLabelHeight(Graphics2D g2, Rectangle2D drawArea, boolean vertical) {
  Font font = getTickLabelFont();
  g2.setFont(font);
  FontRenderContext frc = g2.getFontRenderContext();
  double maxHeight = 0.0;
  if (vertical) {
    Iterator iterator = this.ticks.iterator();
    while (iterator.hasNext()) {
    Tick tick = (Tick)iterator.next();
    Rectangle2D labelBounds = font.getStringBounds(tick.getText(), frc);
    if (labelBounds.getWidth()>maxHeight) {
      maxHeight = labelBounds.getWidth();
    }
    }
  }
  else {
    LineMetrics metrics = font.getLineMetrics("Sample", frc);
    maxHeight = metrics.getHeight();
  }
  return maxHeight;
###
3073, configure, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 180, 182
4
/**
   * Configures the axis to work with the specified plot.  If the axis has auto-scaling, then sets
   * the maximum and minimum values.
   */
3
  public void configure() {
  if (isAutoRange()) {
    autoAdjustRange();
###
3074, HorizontalNumberAxis, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 119, 141
7
/**
   * Constructs a horizontal number axis.
   * @param label The axis label.
   * @param labelFont The font for displaying the axis label.
   * @param minimumAxisValue The lowest value shown on the axis.
   * @param maximumAxisValue The highest value shown on the axis.
   */
23
  public HorizontalNumberAxis(String label, Font labelFont,
        Number minimumAxisValue, Number maximumAxisValue) {

  this(label,
       labelFont,
       Axis.DEFAULT_AXIS_LABEL_PAINT,
       Axis.DEFAULT_AXIS_LABEL_INSETS,
     true,  // tick labels visible
       Axis.DEFAULT_TICK_LABEL_FONT,
       Axis.DEFAULT_TICK_LABEL_PAINT,
       Axis.DEFAULT_TICK_LABEL_INSETS,
     false,  // tick labels drawn vertically
       true,  // tick marks visible
       Axis.DEFAULT_TICK_STROKE,
     false, // no auto range selection
       true,  // auto range includes zero
       NumberAxis.DEFAULT_MINIMUM_AUTO_RANGE,
       minimumAxisValue, maximumAxisValue,
     true,  // auto tick unit selection
       NumberAxis.DEFAULT_TICK_UNIT,
     true,  // grid lines visible
       ValueAxis.DEFAULT_GRID_LINE_STROKE,
       ValueAxis.DEFAULT_GRID_LINE_PAINT);
###
3075, HorizontalNumberAxis, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 149, 156
4
/**
   * Constructs a horizontal number axis, using default values where necessary.
   * @param label The axis label.
   */
8
  public HorizontalNumberAxis(String label) {

    this(label,
       Axis.DEFAULT_AXIS_LABEL_FONT,
       NumberAxis.DEFAULT_MINIMUM_AXIS_VALUE,
       NumberAxis.DEFAULT_MAXIMUM_AXIS_VALUE);

    this.autoRange = true;
###
3076, selectAutoTickUnit, HorizontalNumberAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalNumberAxis.java, 401, 438
7
/**
   * Selects an appropriate tick value for the axis.  The strategy is to display as many ticks as
   * possible (selected from an array of 'standard' tick units) without the labels overlapping.
   * @param g2 The graphics device;
   * @param drawArea The area in which the plot and axes should be drawn;
   * @param plotArea The area in which the plot should be drawn;
   */
38
  private void selectAutoTickUnit(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

    // calculate the tick label width...
    FontRenderContext frc = g2.getFontRenderContext();

    double tickLabelWidth = this.tickLabelInsets.left+this.tickLabelInsets.right;
    if (this.verticalTickLabels) {
    tickLabelWidth += tickLabelFont.getStringBounds("123", frc).getHeight();
    }
    else {

    double w1 = tickLabelFont.getStringBounds
                    (this.valueToString(this.minimumAxisValue), frc).getWidth();
    double w2 = tickLabelFont.getStringBounds
                    (this.valueToString(this.maximumAxisValue), frc).getWidth();

      tickLabelWidth += Math.max(w1, w2);
    }

    // perhaps take the greater of the label widths for the lower and upper axis bounds,
    // as they should be representative most of the time...

    // now find the smallest tick unit that will accommodate the labels...
  double zero = this.translatedValue(Plot.ZERO, plotArea);

    // start with the current tick unit...
    NumberTickUnit candidate1
             = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(this.tickUnit);
    double x = this.translatedValue(candidate1.getValue(), plotArea);
    double unitWidth = Math.abs(x-zero);

    // then extrapolate...
    double bestguess = (tickLabelWidth/unitWidth) * candidate1.value.doubleValue();
    NumberTickUnit guess = new NumberTickUnit(new Double(bestguess), null);
    NumberTickUnit candidate2
               = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(guess);

    this.tickUnit = candidate2;
###
3077, reserveHeight, HorizontalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalCategoryAxis.java, 202, 216
9
/**
   * Estimates the height required for the axis, given a specific drawing area, without any
   * information about the width of the vertical axis.
   * <P>
   * Supports the HorizontalAxis interface.
   * @param g2 The graphics device (used to obtain font information);
   * @param plot The plot that the axis belongs to;
   * @param drawArea The area within which the axis should be drawn;
   */
15
  public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

  // calculate the height of the axis label...
  Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());
  double labelHeight = this.labelInsets.top+labelInsets.bottom+labelBounds.getHeight();

  // calculate the height required for the tick labels (if visible);
  double tickLabelHeight = 0.0;
  if (tickLabelsVisible) {
    g2.setFont(tickLabelFont);
    this.refreshTicks(g2, drawArea, drawArea);
    tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom+
    getMaxTickLabelHeight(g2, drawArea, this.verticalCategoryLabels);
  }
  return labelHeight+tickLabelHeight;
###
3078, refreshTicks, HorizontalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalCategoryAxis.java, 158, 188
6
/**
   * Creates a temporary list of ticks that can be used when drawing the axis.
   * @param g2 The graphics device (used to get font measurements);
   * @param drawArea The area where the plot and axes will be drawn;
   * @param plotArea The area inside the axes;
   */
31
  public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {
  this.ticks.clear();
  CategoryPlot categoryPlot = (CategoryPlot)plot;
    Dataset data = categoryPlot.getDataset();
    if (data!=null) {
    FontRenderContext frc = g2.getFontRenderContext();
    Font font = this.getTickLabelFont();
    g2.setFont(font);
    int categoryIndex = 0;
    float xx = 0.0f;
    float yy = 0.0f;
    Iterator iterator = categoryPlot.getDataset().getCategories().iterator();
    while (iterator.hasNext()) {
      Object category = iterator.next();
      String label = category.toString();
      Rectangle2D labelBounds = font.getStringBounds(label, frc);
      LineMetrics metrics = font.getLineMetrics(label, frc);
      if (this.verticalCategoryLabels) {
      xx = (float)(categoryPlot.getCategoryCoordinate(categoryIndex, plotArea)+
          labelBounds.getHeight()/2);
      yy = (float)(plotArea.getMaxY()+tickLabelInsets.top+labelBounds.getWidth());
      }
      else {
      xx = (float)(categoryPlot.getCategoryCoordinate(categoryIndex, plotArea)-
         labelBounds.getWidth()/2);
      yy = (float)(plotArea.getMaxY()+tickLabelInsets.top+metrics.getHeight()
         -metrics.getDescent());
      }
      Tick tick = new Tick(category, label, xx, yy);
      ticks.add(tick);
        categoryIndex = categoryIndex+1;
###
3079, draw, HorizontalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalCategoryAxis.java, 120, 145
7
/**
   * Draws the HorizontalCategoryAxis on a Java 2D graphics device (such as the screen or a
   * printer).
   * @param g2 The graphics device;
   * @param drawArea The area within which the axis should be drawn;
   * @param plotArea The area within which the plot is being drawn.
   */
26
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

  // draw the axis label
  g2.setFont(labelFont);
  g2.setPaint(labelPaint);
  FontRenderContext frc = g2.getFontRenderContext();
  Rectangle2D labelBounds = labelFont.getStringBounds(label, frc);
  LineMetrics lm = labelFont.getLineMetrics(label, frc);
  float labelx = (float)(plotArea.getX()+plotArea.getWidth()/2-labelBounds.getWidth()/2);
  float labely = (float)(drawArea.getMaxY()-labelInsets.bottom
                 -lm.getDescent()-lm.getLeading());
  g2.drawString(label, labelx, labely);

  // draw the category labels
  if (this.tickLabelsVisible) {
    g2.setFont(tickLabelFont);
    g2.setPaint(tickLabelPaint);
    this.refreshTicks(g2, drawArea, plotArea);
    Iterator iterator = ticks.iterator();
    while (iterator.hasNext()) {
    Tick tick = (Tick)iterator.next();
    if (this.verticalCategoryLabels) {
      this.drawVerticalString(tick.getText(), g2, tick.getX(), tick.getY());
    }
    else {
      g2.drawString(tick.getText(), tick.getX(), tick.getY());
###
3080, HorizontalCategoryAxis, HorizontalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalCategoryAxis.java, 92, 94
4
/**
   * Standard constructor - builds a HorizontalCategoryAxis with defaults for most attributes.
   * @param label The axis label;
   */
3
  public HorizontalCategoryAxis(String label) {
  super(label);
  this.verticalCategoryLabels = false;
###
3081, getVerticalCategoryLabels, HorizontalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalCategoryAxis.java, 100, 101
3
/**
   * Returns a flag indicating whether the category labels are drawn 'vertically'.
   */
2
  public boolean getVerticalCategoryLabels() {
  return this.verticalCategoryLabels;
###
3082, reserveAxisArea, HorizontalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalCategoryAxis.java, 226, 244
7
/**
   * Returns the area required to draw the axis in the specified draw area.
   * @param g2 The graphics device;
   * @param plot The plot that the axis belongs to;
   * @param drawArea The area within which the plot should be drawn;
   * @param reservedWidth The width reserved by the vertical axis;
   */
19
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,
             double reservedWidth) {

  // calculate the height of the axis label...
  Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());
  double labelHeight = this.labelInsets.top+labelInsets.bottom+labelBounds.getHeight();

  // calculate the height required for the tick labels (if visible);
  double tickLabelHeight = 0.0;
  if (tickLabelsVisible) {
    g2.setFont(tickLabelFont);
    this.refreshTicks(g2, drawArea, drawArea);
    tickLabelHeight = tickLabelInsets.top+tickLabelInsets.bottom+
    getMaxTickLabelHeight(g2, drawArea, this.verticalCategoryLabels);
  }
  return new Rectangle2D.Double(drawArea.getX(),
                    drawArea.getMaxY()-labelHeight-tickLabelHeight,
            drawArea.getWidth()-reservedWidth,
                    labelHeight+tickLabelHeight);
###
3083, getMaxTickLabelHeight, HorizontalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalCategoryAxis.java, 250, 269
3
/**
   * A utility method for determining the height of the tallest tick label.
   */
20
  private double getMaxTickLabelHeight(Graphics2D g2, Rectangle2D drawArea, boolean vertical) {
  Font font = getTickLabelFont();
  g2.setFont(font);
  FontRenderContext frc = g2.getFontRenderContext();
  double maxHeight = 0.0;
  if (vertical) {
    Iterator iterator = this.ticks.iterator();
    while (iterator.hasNext()) {
    Tick tick = (Tick)iterator.next();
    Rectangle2D labelBounds = font.getStringBounds(tick.getText(), frc);
    if (labelBounds.getWidth()>maxHeight) {
      maxHeight = labelBounds.getWidth();
    }
    }
  }
  else {
    LineMetrics metrics = font.getLineMetrics("Sample", frc);
    maxHeight = metrics.getHeight();
  }
  return maxHeight;
###
3084, HorizontalCategoryAxis, HorizontalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalCategoryAxis.java, 73, 84
16
/**
   * Full constructor: returns a new HorizontalCategoryAxis with attributes as specified by the
   * caller.
   * @param label The axis label.
   * @param labelFont The font for displaying the axis label.
   * @param labelPaint The paint used to draw the axis label.
   * @param labelInsets Determines the amount of blank space around the label.
   * @param showCategoryLabels Flag indicating whether or not category (tick) labels are visible.
   * @param verticalCategoryLabels Flag indicating whether or not the category labels are drawn
   *                 vertically.
   * @param categoryLabelFont The font used to display category (tick) labels.
   * @param categoryLabelPaint The paint used to draw category (tick) labels.
   * @param categoryLabelInsets Determines the blank space around each category (tick) label.
   * @param showTickMarks Flag indicating whether or not tick marks are visible.
   * @param tickMarkStroke The stroke used to draw tick marks (if visible).
   */
12
  public HorizontalCategoryAxis(String label, Font labelFont, Paint labelPaint,
                  Insets labelInsets,
                  boolean showCategoryLabels, boolean verticalCategoryLabels,
          Font categoryLabelFont, Paint categoryLabelPaint,
                  Insets categoryLabelInsets,
          boolean showTickMarks, Stroke tickMarkStroke) {

  super(label, labelFont, labelPaint, labelInsets,
      showCategoryLabels, categoryLabelFont, categoryLabelPaint, categoryLabelInsets,
      showTickMarks, tickMarkStroke);

  this.verticalCategoryLabels = verticalCategoryLabels;
###
3085, setVerticalCategoryLabels, HorizontalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalCategoryAxis.java, 108, 110
4
/**
   * Sets the flag that determines whether the category labels are drawn 'vertically'.
   * @param flag The new value of the flag;
   */
3
  public void setVerticalCategoryLabels(boolean flag) {
  this.verticalCategoryLabels = flag;
  this.notifyListeners(new com.jrefinery.chart.event.AxisChangeEvent(this));
###
3086, isCompatiblePlot, HorizontalCategoryAxis, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/HorizontalCategoryAxis.java, 276, 278
4
/**
   * Returns true if the specified plot is compatible with the axis, and false otherwise.
   * @param plot The plot;
   */
3
  protected boolean isCompatiblePlot(Plot plot) {
    if (plot instanceof CategoryPlot) return true;
    else return false;
###
3087, createDateTime, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1193, 1195
3
/**
   * Returns a java.util.Date for the specified year, month, day, hour and minute.
   */
3
  private Date createDateTime(int year, int month, int day, int hour, int minute) {
    GregorianCalendar calendar = new GregorianCalendar(year, month, day, hour, minute);
    return calendar.getTime();
###
3088, displayXYPlotZeroData, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 863, 886
3
/**
   * Displays an XYPlot in its own frame.
   */
24
  private void displayXYPlotZeroData() {

    if (xyPlotZeroDataFrame==null) {

      // create a default chart based on some sample data...
      String title = "XY Plot (zero series)";
      String xAxisLabel = "X Axis";
      String yAxisLabel = "Y Axis";
      XYDataset data = new EmptyXYDataset();
      JFreeChart chart = ChartFactory.createXYChart(title, xAxisLabel, yAxisLabel, data, true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.red));

      // and present it in a frame...
      xyPlotZeroDataFrame = new JFreeChartFrame("XYPlot", chart);
      xyPlotZeroDataFrame.pack();
      SwingRefinery.positionFrameRandomly(xyPlotZeroDataFrame);
      xyPlotZeroDataFrame.show();

    }
    else {
      xyPlotZeroDataFrame.show();
      xyPlotZeroDataFrame.requestFocus();
###
3089, createDate, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1185, 1187
3
/**
   * Returns a java.util.Date for the specified year, month and day.
   */
3
  private Date createDate(int year, int month, int day) {
    GregorianCalendar calendar = new GregorianCalendar(year, month, day);
    return calendar.getTime();
###
3090, displayPieChartTwo, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 798, 823
3
/**
   * Displays pie chart two in its own frame.
   */
26
  private void displayPieChartTwo() {

    if (pieChartTwoFrame==null) {

      // create a default chart based on some sample data...
      String title = "Pie Chart";
      CategoryDataset data = createCategoryDataset();
      PieDataset extracted = Datasets.createPieDataset(data, "Category 2");
      JFreeChart chart = ChartFactory.createPieChart(title, extracted, true);

      // then customise it a little...
      chart.setLegend(null);
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 0, 1000, Color.orange));
      PiePlot pie = (PiePlot)chart.getPlot();
      pie.setSectionLabelType(PiePlot.NAME_AND_PERCENT_LABELS);

      // and present it in a frame...
      pieChartTwoFrame = new JFreeChartFrame("Pie Chart 2", chart);
      pieChartTwoFrame.pack();
      SwingRefinery.positionFrameRandomly(pieChartTwoFrame);
      pieChartTwoFrame.show();

    }
    else {
      pieChartTwoFrame.show();
      pieChartTwoFrame.requestFocus();
###
3091, displayLineChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 731, 755
3
/**
   * Displays a line chart in its own frame.
   */
25
  private void displayLineChart() {

    if (lineChartFrame==null) {

      // create a default chart based on some sample data...
      String title = "Line Chart";
      String categoryAxisLabel = "Categories";
      String valueAxisLabel = "Values";
      CategoryDataset data = createCategoryDataset();
      JFreeChart chart = ChartFactory.createLineChart(title, categoryAxisLabel, valueAxisLabel,
                            data, true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white,0, 1000, Color.yellow));

      // and present it in a frame...
      lineChartFrame = new JFreeChartFrame("Line Chart", chart);
      lineChartFrame.pack();
      SwingRefinery.positionFrameRandomly(lineChartFrame);
      lineChartFrame.show();

    }
    else {
      lineChartFrame.show();
      lineChartFrame.requestFocus();
###
3092, main, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1120, 1127
3
/**
   * The starting point for the demonstration application.
   */
8
  public static void main(String[] args) {
    JFreeChartDemo f = new JFreeChartDemo();
    f.pack();

    SwingRefinery.centerFrameOnScreen(f);

    // and show it...
    f.show();
###
3093, createSingleSeriesCategoryDataset, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1173, 1178
3
/**
   * Creates and returns a category dataset for the demo charts.
   */
6
  public CategoryDataset createSingleSeriesCategoryDataset() {

    Number[][] data = new Integer[][]
      { { new Integer(10), new Integer(-4), new Integer(15), new Integer(14) } };

    return new DefaultCategoryDataset(data);
###
3095, displayVerticalBarChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 492, 515
3
/**
   * Displays a vertical bar chart in its own frame.
   */
24
  private void displayVerticalBarChart() {

    if (verticalBarChartFrame==null) {

      CategoryDataset categoryData = createCategoryDataset();
      JFreeChart chart = ChartFactory.createVerticalBarChart("Vertical Bar Chart",
                   "Categories", "Values", categoryData, true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.red));
      Plot plot = chart.getPlot();
      HorizontalCategoryAxis hAxis = (HorizontalCategoryAxis)plot.getAxis(Plot.HORIZONTAL_AXIS);
        hAxis.setVerticalCategoryLabels(true);

      // and present it in a panel...
      verticalBarChartFrame = new JFreeChartFrame("Vertical Bar Chart", chart);
      verticalBarChartFrame.pack();
      SwingRefinery.positionFrameRandomly(verticalBarChartFrame);
      verticalBarChartFrame.show();

    }
    else {
      verticalBarChartFrame.show();
      verticalBarChartFrame.requestFocus();
###
3096, displayScatterPlot, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 894, 918
3
/**
   * Displays a scatter plot in its own frame.
   */
25
  private void displayScatterPlot() {

    if (scatterPlotFrame==null) {

      // create a default chart based on some sample data...
      String title = "Scatter Plot";
      String xAxisLabel = "X Axis";
      String yAxisLabel = "Y Axis";
      XYDataset scatterData = new SampleXYDataset2();
      JFreeChart chart = ChartFactory.createScatterPlot(title, xAxisLabel,
                              yAxisLabel, scatterData, true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.green));

      // and present it in a frame...
      scatterPlotFrame = new JFreeChartFrame("XYPlot", chart);
      scatterPlotFrame.pack();
      SwingRefinery.positionFrameRandomly(scatterPlotFrame);
      scatterPlotFrame.show();

    }
    else {
      scatterPlotFrame.show();
      scatterPlotFrame.requestFocus();
###
3097, displayVerticalStacked3DBarChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 559, 588
3
/**
   * Displays a vertical bar chart in its own frame.
   */
30
  private void displayVerticalStacked3DBarChart() {

    if (verticalStacked3DBarChartFrame==null) {

      // create a default chart based on some sample data...
      String title = "Vertical Stacked 3D Bar Chart";
      String categoryAxisLabel = "Categories";
      String valueAxisLabel = "Values";
      CategoryDataset categoryData = createCategoryDataset();
      JFreeChart chart = ChartFactory.createStackedVerticalBarChart3D(title, categoryAxisLabel,
                                 valueAxisLabel, categoryData, true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.red));
      Plot plot = chart.getPlot();
      VerticalNumberAxis valueAxis = (VerticalNumberAxis)plot.getAxis(Plot.VERTICAL_AXIS);
      //valueAxis.setAutoRange(false);
      valueAxis.setMinimumAxisValue(new Double(-32.0));
      valueAxis.setMaximumAxisValue(new Double(85.0));

      // and present it in a panel...
      verticalStacked3DBarChartFrame = new JFreeChartFrame("Vertical Stacked 3D Bar Chart", chart);
      verticalStacked3DBarChartFrame.pack();
      SwingRefinery.positionFrameRandomly(verticalStacked3DBarChartFrame);
      verticalStacked3DBarChartFrame.show();

    }
    else {
      verticalStacked3DBarChartFrame.show();
      verticalStacked3DBarChartFrame.requestFocus();
###
3098, createTabbedPane, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 174, 343
3
/**
   * Creates a tabbed pane containing descriptions of the demo charts.
   */
170
  private JTabbedPane createTabbedPane() {

    JTabbedPane tabs = new JTabbedPane();
    Font font = new Font("Dialog", Font.PLAIN, 12);

    JPanel barPanel = new JPanel(new LCBLayout(20));
    barPanel.setPreferredSize(new Dimension(360, 20));
    barPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

    JPanel piePanel = new JPanel(new LCBLayout(20));
    piePanel.setPreferredSize(new Dimension(360, 20));
    piePanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

    JPanel xyPanel = new JPanel(new LCBLayout(20));
    xyPanel.setPreferredSize(new Dimension(360, 20));
    xyPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

    JPanel timeSeriesPanel = new JPanel(new LCBLayout(20));
    timeSeriesPanel.setPreferredSize(new Dimension(360, 20));
    timeSeriesPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

    JPanel otherPanel = new JPanel(new LCBLayout(20));
    otherPanel.setPreferredSize(new Dimension(360, 20));
    otherPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

    JPanel testPanel = new JPanel(new LCBLayout(20));
    testPanel.setPreferredSize(new Dimension(360, 20));
    testPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

    barPanel.add(SwingRefinery.createJLabel("Horizontal Bar Chart: ", font));
    barPanel.add(new DescriptionPanel(new JTextArea("Displays horizontal bars, representing data from a CategoryDataset.")));
    JButton b1 = SwingRefinery.createJButton("Display", font);
    b1.setActionCommand("HORIZONTAL_BAR_CHART");
    b1.addActionListener(this);
    barPanel.add(b1);


    barPanel.add(SwingRefinery.createJLabel("Horizontal Stacked Bar Chart: ", font));
    barPanel.add(new DescriptionPanel(new JTextArea("Displays stacked horizontal bars, representing data from a CategoryDataset.")));
    JButton b2 = SwingRefinery.createJButton("Display", font);
    b2.setActionCommand("HORIZONTAL_STACKED_BAR_CHART");
    b2.addActionListener(this);
    barPanel.add(b2);

    barPanel.add(SwingRefinery.createJLabel("Vertical Bar Chart: ", font));
    barPanel.add(new DescriptionPanel(new JTextArea("Displays vertical bars, representing data from a CategoryDataset.")));
    JButton b3 = SwingRefinery.createJButton("Display", font);
    b3.setActionCommand("VERTICAL_BAR_CHART");
    b3.addActionListener(this);
    barPanel.add(b3);

    barPanel.add(SwingRefinery.createJLabel("Vertical 3D Bar Chart: ", font));
    barPanel.add(new DescriptionPanel(new JTextArea("Displays stacked vertical bars with a 3D effect, representing data from a CategoryDataset.")));
    JButton b6 = SwingRefinery.createJButton("Display", font);
    b6.setActionCommand("VERTICAL_3D_BAR_CHART");
    b6.addActionListener(this);
    barPanel.add(b6);

    barPanel.add(SwingRefinery.createJLabel("Vertical Stacked Bar Chart: ", font));
    barPanel.add(new DescriptionPanel(new JTextArea("Displays stacked vertical bars, representing data from a CategoryDataset.")));
    JButton b4 = SwingRefinery.createJButton("Display", font);
    b4.setActionCommand("VERTICAL_STACKED_BAR_CHART");
    b4.addActionListener(this);
    barPanel.add(b4);

    barPanel.add(SwingRefinery.createJLabel("Vertical Stacked 3D Bar Chart: ", font));
    barPanel.add(new DescriptionPanel(new JTextArea("Displays stacked vertical bars with a 3D effect, representing data from a CategoryDataset.")));
    JButton b5 = SwingRefinery.createJButton("Display", font);
    b5.setActionCommand("VERTICAL_STACKED_3D_BAR_CHART");
    b5.addActionListener(this);
    barPanel.add(b5);

    otherPanel.add(SwingRefinery.createJLabel("Line Chart: ", font));
    otherPanel.add(new DescriptionPanel(new JTextArea("A chart displaying lines and or shapes, representing data in a CategoryDataset.")));
    JButton b8 = SwingRefinery.createJButton("Display", font);
    b8.setActionCommand("LINE_CHART");
    b8.addActionListener(this);
    otherPanel.add(b8);

    piePanel.add(SwingRefinery.createJLabel("Pie Chart: ", font));
    piePanel.add(new DescriptionPanel(new JTextArea("A pie chart showing one section exploded.")));
    JButton b9 = SwingRefinery.createJButton("Display", font);
    b9.setActionCommand("PIE_CHART_1");
    b9.addActionListener(this);
    piePanel.add(b9);

    piePanel.add(SwingRefinery.createJLabel("Pie Chart 2: ", font));
    piePanel.add(new DescriptionPanel(new JTextArea("A pie chart showing percentage labels.")));
    JButton b10 = SwingRefinery.createJButton("Display", font);
    b10.setActionCommand("PIE_CHART_2");
    b10.addActionListener(this);
    piePanel.add(b10);

    otherPanel.add(SwingRefinery.createJLabel("Scatter Plot: ", font));
    otherPanel.add(new DescriptionPanel(new JTextArea("A scatter plot, based on data from an XYDataset.")));
    JButton b11 = SwingRefinery.createJButton("Display", font);
    b11.setActionCommand("SCATTER_PLOT");
    b11.addActionListener(this);
    otherPanel.add(b11);

    xyPanel.add(SwingRefinery.createJLabel("XY Plot: ", font));
    xyPanel.add(new DescriptionPanel(new JTextArea("A line chart, based on data from an XYDataset.")));
    JButton b12 = SwingRefinery.createJButton("Display", font);
    b12.setActionCommand("XY_PLOT");
    b12.addActionListener(this);
    xyPanel.add(b12);

    testPanel.add(SwingRefinery.createJLabel("Null Data: ", font));
    testPanel.add(new DescriptionPanel(new JTextArea("A chart with a null dataset.")));
    JButton b13 = SwingRefinery.createJButton("Display", font);
    b13.setActionCommand("XY_PLOT_NULL");
    b13.addActionListener(this);
    testPanel.add(b13);

    testPanel.add(SwingRefinery.createJLabel("Zero Data: ", font));
    testPanel.add(new DescriptionPanel(new JTextArea("A chart with a dataset containing zero series..")));
    JButton b14 = SwingRefinery.createJButton("Display", font);
    b14.setActionCommand("XY_PLOT_ZERO");
    b14.addActionListener(this);
    testPanel.add(b14);

    timeSeriesPanel.add(SwingRefinery.createJLabel("Time Series Chart: ", font));
    timeSeriesPanel.add(new DescriptionPanel(new JTextArea("A time series chart, based on data from an XYDataset.")));
    JButton b15 = SwingRefinery.createJButton("Display", font);
    b15.setActionCommand("TIME_SERIES_CHART");
    b15.addActionListener(this);
    timeSeriesPanel.add(b15);

    timeSeriesPanel.add(SwingRefinery.createJLabel("Time Series 2: ", font));
    timeSeriesPanel.add(new DescriptionPanel(new JTextArea("A time series chart with a moving average, based on data from an XYDataset.")));
    JButton b16 = SwingRefinery.createJButton("Display", font);
    b16.setActionCommand("TIME_SERIES_WITH_MA_CHART");
    b16.addActionListener(this);
    timeSeriesPanel.add(b16);

    testPanel.add(SwingRefinery.createJLabel("Chart in JScrollPane: ", font));
    testPanel.add(new DescriptionPanel(new JTextArea("A chart embedded in a JScrollPane.")));
    JButton b18 = SwingRefinery.createJButton("Display", font);
    b18.setActionCommand("TIME_SERIES_CHART_SCROLL");
    b18.addActionListener(this);
    testPanel.add(b18);

    timeSeriesPanel.add(SwingRefinery.createJLabel("High/Low/Open/Close Chart: ", font));
    timeSeriesPanel.add(new DescriptionPanel(new JTextArea("A high/low/open/close chart based on data in HighLowDataset.")));
    JButton b19 = SwingRefinery.createJButton("Display", font);
    b19.setActionCommand("HIGH_LOW_CHART");
    b19.addActionListener(this);
    timeSeriesPanel.add(b19);

    otherPanel.add(SwingRefinery.createJLabel("Vertical XY Bar Chart: ", font));
    otherPanel.add(new DescriptionPanel(new JTextArea("A chart showing vertical bars, based on data in an IntervalXYDataset.")));
    JButton b7 = SwingRefinery.createJButton("Display", font);
    b7.setActionCommand("VERTICAL_XY_BAR_CHART");
    b7.addActionListener(this);
    otherPanel.add(b7);

    testPanel.add(SwingRefinery.createJLabel("Dynamic Chart: ", font));
    testPanel.add(new DescriptionPanel(new JTextArea("A dynamic chart, to test the event notification mechanism.")));
    JButton b20 = SwingRefinery.createJButton("Display", font);
    b20.setActionCommand("DYNAMIC_CHART");
    b20.addActionListener(this);
    testPanel.add(b20);

    tabs.add("Bar Charts", new JScrollPane(barPanel));
    tabs.add("Pie Charts", new JScrollPane(piePanel));
    tabs.add("XY Charts", new JScrollPane(xyPanel));
    tabs.add("Time Series Charts", new JScrollPane(timeSeriesPanel));
    tabs.add("Other Charts", new JScrollPane(otherPanel));
    tabs.add("Test Charts", new JScrollPane(testPanel));
    return tabs;
###
3099, displayNullXYPlot, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 926, 949
3
/**
   * Displays a vertical bar chart in its own frame.
   */
24
  private void displayNullXYPlot() {

    if (this.xyPlotNullDataFrame==null) {

      // create a default chart based on some sample data...
      String title = "XY Plot (null data)";
      String xAxisLabel = "X Axis";
      String yAxisLabel = "Y Axis";
      XYDataset data = null;
      JFreeChart chart = ChartFactory.createXYChart(title, xAxisLabel, yAxisLabel, data, true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.red));

      // and present it in a panel...
      xyPlotNullDataFrame = new JFreeChartFrame("XY Plot with NULL data", chart);
      xyPlotNullDataFrame.pack();
      SwingRefinery.positionFrameRandomly(xyPlotNullDataFrame);
      xyPlotNullDataFrame.show();

    }
    else {
      xyPlotNullDataFrame.show();
      xyPlotNullDataFrame.requestFocus();
###
3100, displayTimeSeriesChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 957, 984
3
/**
   * Displays a vertical bar chart in its own frame.
   */
28
  private void displayTimeSeriesChart() {

    if (this.timeSeriesChartFrame==null) {

      // create a default chart based on some sample data...
      String title = "Time Series Chart";
      String xAxisLabel = "Date";
      String yAxisLabel = "USD per GBP";
      XYDataset data = createXYDataset();
      JFreeChart chart = ChartFactory.createTimeSeriesChart(title, xAxisLabel, yAxisLabel, data,
                                true);

      // then customise it a little...
      TextTitle subtitle = new TextTitle("Value of GBP", new Font("Arial", Font.BOLD, 12));
      chart.addTitle(subtitle);
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white,0, 1000, Color.blue));
      Plot plot = chart.getPlot();

      // and present it in a frame...
      timeSeriesChartFrame = new JFreeChartFrame("Time Series Chart", chart);
      timeSeriesChartFrame.pack();
      SwingRefinery.positionFrameRandomly(timeSeriesChartFrame);
      timeSeriesChartFrame.show();

    }
    else {
      timeSeriesChartFrame.show();
      timeSeriesChartFrame.requestFocus();
###
3101, createCategoryDataset, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1133, 1146
3
/**
   * Creates and returns a category dataset for the demo charts.
   */
14
  public CategoryDataset createCategoryDataset() {

    Number[][] data = new Integer[][]
      { { new Integer(10), new Integer(4), new Integer(15), new Integer(14) },
        { new Integer(-5), new Integer(-7), new Integer(14), new Integer(-3) },
        { new Integer(6), new Integer(17), new Integer(-12), new Integer(7) },
        { new Integer(7), new Integer(15), new Integer(11), new Integer(0) },
        { new Integer(-8), new Integer(-6), new Integer(10), new Integer(-9) },
        { new Integer(9), new Integer(8), null, new Integer(6) },
        { new Integer(-10), new Integer(9), new Integer(7), new Integer(7) },
        { new Integer(11), new Integer(13), new Integer(9), new Integer(9) },
        { new Integer(-3), new Integer(7), new Integer(11), new Integer(-10) } };

    return new DefaultCategoryDataset(data);
###
3103, displayDynamicXYChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 472, 484
4
/**
   * Displays an XY chart that is periodically updated by a background thread.  This is to
   * demonstrate the event notification system that automatically updates charts as required.
   */
13
  private void displayDynamicXYChart() {

    if (dynamicXYChartFrame==null) {

      SampleXYDataset data = new SampleXYDataset();
      JFreeChart chart = ChartFactory.createXYChart("Dynamic XY Chart", "X", "Y", data, true);
      SampleXYDatasetThread update = new SampleXYDatasetThread(data);
      dynamicXYChartFrame = new JFreeChartFrame("Dynamic Chart", chart);
      dynamicXYChartFrame.pack();
      SwingRefinery.positionFrameRandomly(dynamicXYChartFrame);
      dynamicXYChartFrame.show();
      Thread thread = new Thread(update);
      thread.start();
###
3104, createHighLowDataset, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1563, 1802
3
/**
   * Creates and returns a sample high-low dataset for the demo.  Added by Andrzej Porebski.
   */
240
  public XYDataset createHighLowDataset() {

    Object[][][] data = new Object[][][] { {
      { createDate(1999, Calendar.JANUARY,4), new Double(47) },
      { createDate(1999, Calendar.JANUARY,4), new Double(33) },
      { createDate(1999, Calendar.JANUARY,4), new Double(35) },
      { createDate(1999, Calendar.JANUARY,4), new Double(33) },

      { createDate(1999, Calendar.JANUARY,5), new Double(47) },
      { createDate(1999, Calendar.JANUARY,5), new Double(32) },
      { createDate(1999, Calendar.JANUARY,5), new Double(41) },
      { createDate(1999, Calendar.JANUARY,5), new Double(37) },

      { createDate(1999, Calendar.JANUARY,6), new Double(49) },
      { createDate(1999, Calendar.JANUARY,6), new Double(43) },
      { createDate(1999, Calendar.JANUARY,6), new Double(46) },
      { createDate(1999, Calendar.JANUARY,6), new Double(48) },

      { createDate(1999, Calendar.JANUARY,7), new Double(51) },
      { createDate(1999, Calendar.JANUARY,7), new Double(39) },
      { createDate(1999, Calendar.JANUARY,7), new Double(40) },
      { createDate(1999, Calendar.JANUARY,7), new Double(47) },

      { createDate(1999, Calendar.JANUARY,8), new Double(60) },
      { createDate(1999, Calendar.JANUARY,8), new Double(40) },
      { createDate(1999, Calendar.JANUARY,8), new Double(46) },
      { createDate(1999, Calendar.JANUARY,8), new Double(53) },

      { createDate(1999, Calendar.JANUARY,9), new Double(62) },
      { createDate(1999, Calendar.JANUARY,9), new Double(55) },
      { createDate(1999, Calendar.JANUARY,9), new Double(57) },
      { createDate(1999, Calendar.JANUARY,9), new Double(61) },

      { createDate(1999, Calendar.JANUARY,10), new Double(65) },
      { createDate(1999, Calendar.JANUARY,10), new Double(56) },
      { createDate(1999, Calendar.JANUARY,10), new Double(62) },
      { createDate(1999, Calendar.JANUARY,10), new Double(59) },

      { createDate(1999, Calendar.JANUARY,11), new Double(55) },
      { createDate(1999, Calendar.JANUARY,11), new Double(43) },
      { createDate(1999, Calendar.JANUARY,11), new Double(45) },
      { createDate(1999, Calendar.JANUARY,11), new Double(47) },

      { createDate(1999, Calendar.JANUARY,12), new Double(54) },
      { createDate(1999, Calendar.JANUARY,12), new Double(33) },
      { createDate(1999, Calendar.JANUARY,12), new Double(40) },
      { createDate(1999, Calendar.JANUARY,12), new Double(51) },

      { createDate(1999, Calendar.JANUARY,13), new Double(58) },
      { createDate(1999, Calendar.JANUARY,13), new Double(42) },
      { createDate(1999, Calendar.JANUARY,13), new Double(44) },
      { createDate(1999, Calendar.JANUARY,13), new Double(57) },

      { createDate(1999, Calendar.JANUARY,14), new Double(54) },
      { createDate(1999, Calendar.JANUARY,14), new Double(38) },
      { createDate(1999, Calendar.JANUARY,14), new Double(43) },
      { createDate(1999, Calendar.JANUARY,14), new Double(52) },

      { createDate(1999, Calendar.JANUARY,15), new Double(48) },
      { createDate(1999, Calendar.JANUARY,15), new Double(41) },
      { createDate(1999, Calendar.JANUARY,15), new Double(44) },
      { createDate(1999, Calendar.JANUARY,15), new Double(41) },

      { createDate(1999, Calendar.JANUARY,17), new Double(60) },
      { createDate(1999, Calendar.JANUARY,17), new Double(30) },
      { createDate(1999, Calendar.JANUARY,17), new Double(34) },
      { createDate(1999, Calendar.JANUARY,17), new Double(44) },

      { createDate(1999, Calendar.JANUARY,18), new Double(58) },
      { createDate(1999, Calendar.JANUARY,18), new Double(44) },
      { createDate(1999, Calendar.JANUARY,18), new Double(54) },
      { createDate(1999, Calendar.JANUARY,18), new Double(56) },

      { createDate(1999, Calendar.JANUARY,19), new Double(54) },
      { createDate(1999, Calendar.JANUARY,19), new Double(32) },
      { createDate(1999, Calendar.JANUARY,19), new Double(42) },
      { createDate(1999, Calendar.JANUARY,19), new Double(53) },

      { createDate(1999, Calendar.JANUARY,20), new Double(53) },
      { createDate(1999, Calendar.JANUARY,20), new Double(39) },
      { createDate(1999, Calendar.JANUARY,20), new Double(50) },
      { createDate(1999, Calendar.JANUARY,20), new Double(49) },

      { createDate(1999, Calendar.JANUARY,21), new Double(47) },
      { createDate(1999, Calendar.JANUARY,21), new Double(38) },
      { createDate(1999, Calendar.JANUARY,21), new Double(41) },
      { createDate(1999, Calendar.JANUARY,21), new Double(40) },

      { createDate(1999, Calendar.JANUARY,22), new Double(55) },
      { createDate(1999, Calendar.JANUARY,22), new Double(37) },
      { createDate(1999, Calendar.JANUARY,22), new Double(43) },
      { createDate(1999, Calendar.JANUARY,22), new Double(45) },

      { createDate(1999, Calendar.JANUARY,23), new Double(54) },
      { createDate(1999, Calendar.JANUARY,23), new Double(42) },
      { createDate(1999, Calendar.JANUARY,23), new Double(50) },
      { createDate(1999, Calendar.JANUARY,23), new Double(42) },

      { createDate(1999, Calendar.JANUARY,24), new Double(48) },
      { createDate(1999, Calendar.JANUARY,24), new Double(37) },
      { createDate(1999, Calendar.JANUARY,24), new Double(37) },
      { createDate(1999, Calendar.JANUARY,24), new Double(47) },

      { createDate(1999, Calendar.JANUARY,25), new Double(58) },
      { createDate(1999, Calendar.JANUARY,25), new Double(33) },
      { createDate(1999, Calendar.JANUARY,25), new Double(39) },
      { createDate(1999, Calendar.JANUARY,25), new Double(41) },

      { createDate(1999, Calendar.JANUARY,26), new Double(47) },
      { createDate(1999, Calendar.JANUARY,26), new Double(31) },
      { createDate(1999, Calendar.JANUARY,26), new Double(36) },
      { createDate(1999, Calendar.JANUARY,26), new Double(41) },

      { createDate(1999, Calendar.JANUARY,27), new Double(58) },
      { createDate(1999, Calendar.JANUARY,27), new Double(44) },
      { createDate(1999, Calendar.JANUARY,27), new Double(49) },
      { createDate(1999, Calendar.JANUARY,27), new Double(44) },

      { createDate(1999, Calendar.JANUARY,28), new Double(46) },
      { createDate(1999, Calendar.JANUARY,28), new Double(41) },
      { createDate(1999, Calendar.JANUARY,28), new Double(43) },
      { createDate(1999, Calendar.JANUARY,28), new Double(44) },

      { createDate(1999, Calendar.JANUARY,29), new Double(56) },
      { createDate(1999, Calendar.JANUARY,29), new Double(39) },
      { createDate(1999, Calendar.JANUARY,29), new Double(39) },
      { createDate(1999, Calendar.JANUARY,29), new Double(51) },

      { createDate(1999, Calendar.JANUARY,30), new Double(56) },
      { createDate(1999, Calendar.JANUARY,30), new Double(39) },
      { createDate(1999, Calendar.JANUARY,30), new Double(47) },
      { createDate(1999, Calendar.JANUARY,30), new Double(49) },

      { createDate(1999, Calendar.JANUARY,31), new Double(53) },
      { createDate(1999, Calendar.JANUARY,31), new Double(39) },
      { createDate(1999, Calendar.JANUARY,31), new Double(52) },
      { createDate(1999, Calendar.JANUARY,31), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,1), new Double(51) },
      { createDate(1999, Calendar.FEBRUARY,1), new Double(30) },
      { createDate(1999, Calendar.FEBRUARY,1), new Double(45) },
      { createDate(1999, Calendar.FEBRUARY,1), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,2), new Double(47) },
      { createDate(1999, Calendar.FEBRUARY,2), new Double(30) },
      { createDate(1999, Calendar.FEBRUARY,2), new Double(34) },
      { createDate(1999, Calendar.FEBRUARY,2), new Double(46) },

      { createDate(1999, Calendar.FEBRUARY,3), new Double(57) },
      { createDate(1999, Calendar.FEBRUARY,3), new Double(37) },
      { createDate(1999, Calendar.FEBRUARY,3), new Double(44) },
      { createDate(1999, Calendar.FEBRUARY,3), new Double(56) },

      { createDate(1999, Calendar.FEBRUARY,4), new Double(49) },
      { createDate(1999, Calendar.FEBRUARY,4), new Double(40) },
      { createDate(1999, Calendar.FEBRUARY,4), new Double(47) },
      { createDate(1999, Calendar.FEBRUARY,4), new Double(44) },

      { createDate(1999, Calendar.FEBRUARY,5), new Double(46) },
      { createDate(1999, Calendar.FEBRUARY,5), new Double(38) },
      { createDate(1999, Calendar.FEBRUARY,5), new Double(43) },
      { createDate(1999, Calendar.FEBRUARY,5), new Double(40) },

      { createDate(1999, Calendar.FEBRUARY,6), new Double(55) },
      { createDate(1999, Calendar.FEBRUARY,6), new Double(38) },
      { createDate(1999, Calendar.FEBRUARY,6), new Double(39) },
      { createDate(1999, Calendar.FEBRUARY,6), new Double(53) },

      { createDate(1999, Calendar.FEBRUARY,7), new Double(50) },
      { createDate(1999, Calendar.FEBRUARY,7), new Double(33) },
      { createDate(1999, Calendar.FEBRUARY,7), new Double(37) },
      { createDate(1999, Calendar.FEBRUARY,7), new Double(37) },

      { createDate(1999, Calendar.FEBRUARY,8), new Double(59) },
      { createDate(1999, Calendar.FEBRUARY,8), new Double(34) },
      { createDate(1999, Calendar.FEBRUARY,8), new Double(57) },
      { createDate(1999, Calendar.FEBRUARY,8), new Double(43) },

      { createDate(1999, Calendar.FEBRUARY,9), new Double(48) },
      { createDate(1999, Calendar.FEBRUARY,9), new Double(39) },
      { createDate(1999, Calendar.FEBRUARY,9), new Double(46) },
      { createDate(1999, Calendar.FEBRUARY,9), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,10), new Double(55) },
      { createDate(1999, Calendar.FEBRUARY,10), new Double(30) },
      { createDate(1999, Calendar.FEBRUARY,10), new Double(37) },
      { createDate(1999, Calendar.FEBRUARY,10), new Double(30) },

      { createDate(1999, Calendar.FEBRUARY,11), new Double(60) },
      { createDate(1999, Calendar.FEBRUARY,11), new Double(32) },
      { createDate(1999, Calendar.FEBRUARY,11), new Double(56) },
      { createDate(1999, Calendar.FEBRUARY,11), new Double(36) },

      { createDate(1999, Calendar.FEBRUARY,12), new Double(56) },
      { createDate(1999, Calendar.FEBRUARY,12), new Double(42) },
      { createDate(1999, Calendar.FEBRUARY,12), new Double(53) },
      { createDate(1999, Calendar.FEBRUARY,12), new Double(54) },

      { createDate(1999, Calendar.FEBRUARY,13), new Double(49) },
      { createDate(1999, Calendar.FEBRUARY,13), new Double(42) },
      { createDate(1999, Calendar.FEBRUARY,13), new Double(45) },
      { createDate(1999, Calendar.FEBRUARY,13), new Double(42) },

      { createDate(1999, Calendar.FEBRUARY,14), new Double(55) },
      { createDate(1999, Calendar.FEBRUARY,14), new Double(42) },
      { createDate(1999, Calendar.FEBRUARY,14), new Double(47) },
      { createDate(1999, Calendar.FEBRUARY,14), new Double(54) },

      { createDate(1999, Calendar.FEBRUARY,15), new Double(49) },
      { createDate(1999, Calendar.FEBRUARY,15), new Double(35) },
      { createDate(1999, Calendar.FEBRUARY,15), new Double(38) },
      { createDate(1999, Calendar.FEBRUARY,15), new Double(35) },

      { createDate(1999, Calendar.FEBRUARY,16), new Double(47) },
      { createDate(1999, Calendar.FEBRUARY,16), new Double(38) },
      { createDate(1999, Calendar.FEBRUARY,16), new Double(43) },
      { createDate(1999, Calendar.FEBRUARY,16), new Double(42) },

      { createDate(1999, Calendar.FEBRUARY,17), new Double(53) },
      { createDate(1999, Calendar.FEBRUARY,17), new Double(42) },
      { createDate(1999, Calendar.FEBRUARY,17), new Double(47) },
      { createDate(1999, Calendar.FEBRUARY,17), new Double(48) },

      { createDate(1999, Calendar.FEBRUARY,18), new Double(47) },
      { createDate(1999, Calendar.FEBRUARY,18), new Double(44) },
      { createDate(1999, Calendar.FEBRUARY,18), new Double(46) },
      { createDate(1999, Calendar.FEBRUARY,18), new Double(44) },

      { createDate(1999, Calendar.FEBRUARY,19), new Double(46) },
      { createDate(1999, Calendar.FEBRUARY,19), new Double(40) },
      { createDate(1999, Calendar.FEBRUARY,19), new Double(43) },
      { createDate(1999, Calendar.FEBRUARY,19), new Double(44) },

      { createDate(1999, Calendar.FEBRUARY,20), new Double(48) },
      { createDate(1999, Calendar.FEBRUARY,20), new Double(41) },
      { createDate(1999, Calendar.FEBRUARY,20), new Double(46) },
      { createDate(1999, Calendar.FEBRUARY,20), new Double(41) } }
    };

    return new DefaultXYDataset(new String[] { "IBM" }, data);
###
3105, displayHighLowChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1031, 1058
3
/**
   * Displays a vertical bar chart in its own frame.
   */
28
  private void displayHighLowChart() {

    if (this.highLowChartFrame==null) {

      // create a default chart based on some sample data...
      String title = "High-Low/Open-Close Chart";
      String timeAxisLabel = "Date";
      String valueAxisLabel = "Price ($ per share)";
      HighLowDataset data = new SampleHighLowDataset();
      JFreeChart chart = ChartFactory.createHighLowChart(title, timeAxisLabel, valueAxisLabel,
                               data, true);

      // then customise it a little...
      TextTitle subtitle = new TextTitle("IBM Stock Price", new Font("Arial", Font.BOLD, 12));
      chart.addTitle(subtitle);
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 0, 1000, Color.magenta));


      // and present it in a frame...
      highLowChartFrame = new JFreeChartFrame("High/Low/Open/Close Chart", chart);
      highLowChartFrame.pack();
      SwingRefinery.positionFrameRandomly(highLowChartFrame);
      highLowChartFrame.show();

    }
    else {
      highLowChartFrame.show();
      highLowChartFrame.requestFocus();
###
3106, displayVerticalXYBarChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 596, 621
3
/**
   * Displays a vertical bar chart in its own frame.
   */
26
  private void displayVerticalXYBarChart() {

    if (verticalXYBarChartFrame==null) {

      // create a default chart based on some sample data...
      String title = "Time Series Bar Chart";
      String xAxisLabel = "X Axis";
      String yAxisLabel = "Y Axis";
      TimeSeriesCollection data = createTestTimeSeriesCollection1();
      JFreeChart chart = ChartFactory.createVerticalXYBarChart(title, xAxisLabel, yAxisLabel,
                                   data, true);


      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.blue));

      // and present it in a panel...
      verticalXYBarChartFrame = new JFreeChartFrame("Vertical XY Bar Chart", chart);
      verticalXYBarChartFrame.pack();
      SwingRefinery.positionFrameRandomly(verticalXYBarChartFrame);
      verticalXYBarChartFrame.show();

    }
    else {
      verticalXYBarChartFrame.show();
      verticalXYBarChartFrame.requestFocus();
###
3107, attemptExit, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 458, 464
3
/**
   * Exits the application, but only if the user agrees.
   */
7
  private void attemptExit() {
    int result = JOptionPane.showConfirmDialog(this,
             "Are you sure you want to exit?", "Confirmation...",
             JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
    if (result==JOptionPane.YES_OPTION) {
      dispose();
      System.exit(0);
###
3108, displayVerticalStackedBarChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 523, 551
3
/**
   * Displays a vertical bar chart in its own frame.
   */
29
  private void displayVerticalStackedBarChart() {

    if (verticalStackedBarChartFrame==null) {

      // create a default chart based on some sample data...
      String title = "Vertical Stacked Bar Chart";
      String categoryAxisLabel = "Categories";
      String valueAxisLabel = "Values";
      CategoryDataset categoryData = createCategoryDataset();
      JFreeChart chart = ChartFactory.createStackedVerticalBarChart(title, categoryAxisLabel,
                                 valueAxisLabel, categoryData, true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.red));
      Plot plot = chart.getPlot();
      VerticalNumberAxis valueAxis = (VerticalNumberAxis)plot.getAxis(Plot.VERTICAL_AXIS);
      valueAxis.setMinimumAxisValue(new Double(-32.0));
      valueAxis.setMaximumAxisValue(new Double(85.0));

      // and present it in a panel...
      verticalStackedBarChartFrame = new JFreeChartFrame("Vertical Stacked Bar Chart", chart);
      verticalStackedBarChartFrame.pack();
      SwingRefinery.positionFrameRandomly(verticalStackedBarChartFrame);
      verticalStackedBarChartFrame.show();

    }
    else {
      verticalStackedBarChartFrame.show();
      verticalStackedBarChartFrame.requestFocus();
###
3109, actionPerformed, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 352, 415
3
/**
   * Handles menu selections by passing control to an appropriate method.
   */
64
  public void actionPerformed(ActionEvent event) {
    String command = event.getActionCommand();
    if (command.equals("exitItem")) {
      attemptExit();
    }
    else if (command.equals("DYNAMIC_CHART")) {
      displayDynamicXYChart();
    }
    else if (command.equals("aboutItem")) {
      about();
    }
    else if (command.equals("VERTICAL_BAR_CHART")) {
      displayVerticalBarChart();
    }
    else if (command.equals("VERTICAL_STACKED_BAR_CHART")) {
      displayVerticalStackedBarChart();
    }
    else if (command.equals("VERTICAL_XY_BAR_CHART")) {
      displayVerticalXYBarChart();
    }
    else if (command.equals("VERTICAL_3D_BAR_CHART")) {
      displayVertical3DBarChart();
    }
    else if (command.equals("VERTICAL_STACKED_3D_BAR_CHART")) {
      displayVerticalStacked3DBarChart();
    }
    else if (command.equals("HORIZONTAL_BAR_CHART")) {
      displayHorizontalBarChart();
    }
    else if (command.equals("HORIZONTAL_STACKED_BAR_CHART")) {
      displayHorizontalStackedBarChart();
    }
    else if (command.equals("LINE_CHART")) {
      displayLineChart();
    }
    else if (command.equals("PIE_CHART_1")) {
      displayPieChartOne();
    }
    else if (command.equals("PIE_CHART_2")) {
      displayPieChartTwo();
    }
    else if (command.equals("XY_PLOT")) {
      displayXYPlot();
    }
    else if (command.equals("SCATTER_PLOT")) {
      displayScatterPlot();
    }
    else if (command.equals("TIME_SERIES_CHART")) {
      displayTimeSeriesChart();
    }
    else if (command.equals("TIME_SERIES_WITH_MA_CHART")) {
      displayTimeSeriesWithMAChart();
    }
    else if (command.equals("TIME_SERIES_CHART_SCROLL")) {
      displayTimeSeriesChartInScrollPane();
    }
    else if (command.equals("HIGH_LOW_CHART")) {
      displayHighLowChart();
    }
    else if (command.equals("XY_PLOT_NULL")) {
      displayNullXYPlot();
    }
    else if (command.equals("XY_PLOT_ZERO")) {
      displayXYPlotZeroData();
###
3112, createXYDataset, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1201, 1512
3
/**
   * Creates and returns a XYDataset for the demo charts.
   */
312
  public XYDataset createXYDataset() {

    GregorianCalendar calendar = new GregorianCalendar(1999, Calendar.JANUARY, 4);

    Object[][][] data = new Object[][][] { {
      { createDate(1999, Calendar.JANUARY,4), new Double(1.6581) },
      { createDate(1999, Calendar.JANUARY,5), new Double(1.6566) },
      { createDate(1999, Calendar.JANUARY,6), new Double(1.6547) },
      { createDate(1999, Calendar.JANUARY,7), new Double(1.6495) },
      { createDate(1999, Calendar.JANUARY,8), new Double(1.6405) },
      { createDate(1999, Calendar.JANUARY,11), new Double(1.6375) },
      { createDate(1999, Calendar.JANUARY,12), new Double(1.6308) },
      { createDate(1999, Calendar.JANUARY,13), new Double(1.6493) },
      { createDate(1999, Calendar.JANUARY,14), new Double(1.6530) },
      { createDate(1999, Calendar.JANUARY,15), new Double(1.6500) },
      { createDate(1999, Calendar.JANUARY,19), new Double(1.6550) },
      { createDate(1999, Calendar.JANUARY,20), new Double(1.6467) },
      { createDate(1999, Calendar.JANUARY,21), new Double(1.6516) },
      { createDate(1999, Calendar.JANUARY,22), new Double(1.6560) },
      { createDate(1999, Calendar.JANUARY,25), new Double(1.6563) },
      { createDate(1999, Calendar.JANUARY,26), new Double(1.6585) },
      { createDate(1999, Calendar.JANUARY,27), new Double(1.6485) },
      { createDate(1999, Calendar.JANUARY,28), new Double(1.6470) },
      { createDate(1999, Calendar.JANUARY,29), new Double(1.6457) },
      { createDate(1999, Calendar.FEBRUARY,1), new Double(1.6410) },
      { createDate(1999, Calendar.FEBRUARY,2), new Double(1.6430) },
      { createDate(1999, Calendar.FEBRUARY,3), new Double(1.6375) },
      { createDate(1999, Calendar.FEBRUARY,4), new Double(1.6395) },
      { createDate(1999, Calendar.FEBRUARY,5), new Double(1.6370) },
      { createDate(1999, Calendar.FEBRUARY,8), new Double(1.6380) },
      { createDate(1999, Calendar.FEBRUARY,9), new Double(1.6355) },
      { createDate(1999, Calendar.FEBRUARY,10), new Double(1.6290) },
      { createDate(1999, Calendar.FEBRUARY,11), new Double(1.6244) },
      { createDate(1999, Calendar.FEBRUARY,12), new Double(1.6311) },
      { createDate(1999, Calendar.FEBRUARY,16), new Double(1.6317) },
      { createDate(1999, Calendar.FEBRUARY,17), new Double(1.6338) },
      { createDate(1999, Calendar.FEBRUARY,18), new Double(1.6338) },
      { createDate(1999, Calendar.FEBRUARY,19), new Double(1.6255) },
      { createDate(1999, Calendar.FEBRUARY,22), new Double(1.6238) },
      { createDate(1999, Calendar.FEBRUARY,23), new Double(1.6138) },
      { createDate(1999, Calendar.FEBRUARY,24), new Double(1.5980) },
      { createDate(1999, Calendar.FEBRUARY,25), new Double(1.6060) },
      { createDate(1999, Calendar.FEBRUARY,26), new Double(1.6027) },
      { createDate(1999, Calendar.MARCH,1), new Double(1.6058) },
      { createDate(1999, Calendar.MARCH,2), new Double(1.6135) },
      { createDate(1999, Calendar.MARCH,3), new Double(1.6134) },
      { createDate(1999, Calendar.MARCH,4), new Double(1.6065) },
      { createDate(1999, Calendar.MARCH,5), new Double(1.6073) },
      { createDate(1999, Calendar.MARCH,8), new Double(1.6085) },
      { createDate(1999, Calendar.MARCH,9), new Double(1.6148) },
      { createDate(1999, Calendar.MARCH,10), new Double(1.6267) },
      { createDate(1999, Calendar.MARCH,11), new Double(1.6270) },
      { createDate(1999, Calendar.MARCH,12), new Double(1.6335) },
      { createDate(1999, Calendar.MARCH,15), new Double(1.6223) },
      { createDate(1999, Calendar.MARCH,16), new Double(1.6240) },
      { createDate(1999, Calendar.MARCH,17), new Double(1.6302) },
      { createDate(1999, Calendar.MARCH,18), new Double(1.6290) },
      { createDate(1999, Calendar.MARCH,19), new Double(1.6303) },
      { createDate(1999, Calendar.MARCH,22), new Double(1.6280) },
      { createDate(1999, Calendar.MARCH,23), new Double(1.6372) },
      { createDate(1999, Calendar.MARCH,24), new Double(1.6410) },
      { createDate(1999, Calendar.MARCH,25), new Double(1.6314) },
      { createDate(1999, Calendar.MARCH,26), new Double(1.6205) },
      { createDate(1999, Calendar.MARCH,29), new Double(1.6140) },
      { createDate(1999, Calendar.MARCH,30), new Double(1.6115) },
      { createDate(1999, Calendar.MARCH,31), new Double(1.6140) },
      { createDate(1999, Calendar.APRIL,1), new Double(1.6063) },
      { createDate(1999, Calendar.APRIL,2), new Double(1.6023) },
      { createDate(1999, Calendar.APRIL,5), new Double(1.6015) },
      { createDate(1999, Calendar.APRIL,6), new Double(1.5920) },
      { createDate(1999, Calendar.APRIL,7), new Double(1.5975) },
      { createDate(1999, Calendar.APRIL,8), new Double(1.6083) },
      { createDate(1999, Calendar.APRIL,9), new Double(1.6068) },
      { createDate(1999, Calendar.APRIL,12), new Double(1.6127) },
      { createDate(1999, Calendar.APRIL,13), new Double(1.6135) },
      { createDate(1999, Calendar.APRIL,14), new Double(1.6124) },
      { createDate(1999, Calendar.APRIL,15), new Double(1.6103) },
      { createDate(1999, Calendar.APRIL,16), new Double(1.6112) },
      { createDate(1999, Calendar.APRIL,19), new Double(1.6075) },
      { createDate(1999, Calendar.APRIL,20), new Double(1.6135) },
      { createDate(1999, Calendar.APRIL,21), new Double(1.6074) },
      { createDate(1999, Calendar.APRIL,22), new Double(1.6117) },
      { createDate(1999, Calendar.APRIL,23), new Double(1.6170) },
      { createDate(1999, Calendar.APRIL,26), new Double(1.6113) },
      { createDate(1999, Calendar.APRIL,27), new Double(1.6177) },
      { createDate(1999, Calendar.APRIL,28), new Double(1.6148) },
      { createDate(1999, Calendar.APRIL,29), new Double(1.6105) },
      { createDate(1999, Calendar.APRIL,30), new Double(1.6085) },
      { createDate(1999, Calendar.MAY,3), new Double(1.6083) },
      { createDate(1999, Calendar.MAY,4), new Double(1.6210) },
      { createDate(1999, Calendar.MAY,5), new Double(1.6337) },
      { createDate(1999, Calendar.MAY,6), new Double(1.6377) },
      { createDate(1999, Calendar.MAY,7), new Double(1.6350) },
      { createDate(1999, Calendar.MAY,10), new Double(1.6300) },
      { createDate(1999, Calendar.MAY,11), new Double(1.6215) },
      { createDate(1999, Calendar.MAY,12), new Double(1.6193) },
      { createDate(1999, Calendar.MAY,13), new Double(1.6190) },
      { createDate(1999, Calendar.MAY,14), new Double(1.6175) },
      { createDate(1999, Calendar.MAY,17), new Double(1.6193) },
      { createDate(1999, Calendar.MAY,18), new Double(1.6203) },
      { createDate(1999, Calendar.MAY,19), new Double(1.6175) },
      { createDate(1999, Calendar.MAY,20), new Double(1.6122) },
      { createDate(1999, Calendar.MAY,21), new Double(1.6020) },
      { createDate(1999, Calendar.MAY,24), new Double(1.5978) },
      { createDate(1999, Calendar.MAY,25), new Double(1.6021) },
      { createDate(1999, Calendar.MAY,26), new Double(1.5963) },
      { createDate(1999, Calendar.MAY,27), new Double(1.5957) },
      { createDate(1999, Calendar.MAY,28), new Double(1.6020) },
      { createDate(1999, Calendar.JUNE,1), new Double(1.6150) },
      { createDate(1999, Calendar.JUNE,2), new Double(1.6075) },
      { createDate(1999, Calendar.JUNE,3), new Double(1.6055) },
      { createDate(1999, Calendar.JUNE,4), new Double(1.6074) },
      { createDate(1999, Calendar.JUNE,7), new Double(1.6010) },
      { createDate(1999, Calendar.JUNE,8), new Double(1.6050) },
      { createDate(1999, Calendar.JUNE,9), new Double(1.6001) },
      { createDate(1999, Calendar.JUNE,10), new Double(1.6002) },
      { createDate(1999, Calendar.JUNE,11), new Double(1.6085) },
      { createDate(1999, Calendar.JUNE,14), new Double(1.6075) },
      { createDate(1999, Calendar.JUNE,15), new Double(1.5950) },
      { createDate(1999, Calendar.JUNE,16), new Double(1.5862) },
      { createDate(1999, Calendar.JUNE,17), new Double(1.5925) },
      { createDate(1999, Calendar.JUNE,18), new Double(1.5924) },
      { createDate(1999, Calendar.JUNE,21), new Double(1.5890) },
      { createDate(1999, Calendar.JUNE,22), new Double(1.5895) },
      { createDate(1999, Calendar.JUNE,23), new Double(1.5787) },
      { createDate(1999, Calendar.JUNE,24), new Double(1.5833) },
      { createDate(1999, Calendar.JUNE,25), new Double(1.5893) },
      { createDate(1999, Calendar.JUNE,28), new Double(1.5822) },
      { createDate(1999, Calendar.JUNE,29), new Double(1.5781) },
      { createDate(1999, Calendar.JUNE,30), new Double(1.5765) },
      { createDate(1999, Calendar.JULY,1), new Double(1.5765) },
      { createDate(1999, Calendar.JULY,2), new Double(1.5792) },
      { createDate(1999, Calendar.JULY,6), new Double(1.5688) },
      { createDate(1999, Calendar.JULY,7), new Double(1.5602) },
      { createDate(1999, Calendar.JULY,8), new Double(1.5577) },
      { createDate(1999, Calendar.JULY,9), new Double(1.5515) },
      { createDate(1999, Calendar.JULY,12), new Double(1.5558) },
      { createDate(1999, Calendar.JULY,13), new Double(1.5566) },
      { createDate(1999, Calendar.JULY,14), new Double(1.5635) },
      { createDate(1999, Calendar.JULY,15), new Double(1.5665) },
      { createDate(1999, Calendar.JULY,16), new Double(1.5622) },
      { createDate(1999, Calendar.JULY,19), new Double(1.5630) },
      { createDate(1999, Calendar.JULY,20), new Double(1.5700) },
      { createDate(1999, Calendar.JULY,21), new Double(1.5766) },
      { createDate(1999, Calendar.JULY,22), new Double(1.5835) },
      { createDate(1999, Calendar.JULY,23), new Double(1.5780) },
      { createDate(1999, Calendar.JULY,26), new Double(1.5905) },
      { createDate(1999, Calendar.JULY,27), new Double(1.5895) },
      { createDate(1999, Calendar.JULY,28), new Double(1.5935) },
      { createDate(1999, Calendar.JULY,29), new Double(1.6130) },
      { createDate(1999, Calendar.JULY,30), new Double(1.6207) },
      { createDate(1999, Calendar.AUGUST,2), new Double(1.6145) },
      { createDate(1999, Calendar.AUGUST,3), new Double(1.6185) },
      { createDate(1999, Calendar.AUGUST,4), new Double(1.6200) },
      { createDate(1999, Calendar.AUGUST,5), new Double(1.6198) },
      { createDate(1999, Calendar.AUGUST,6), new Double(1.6147) },
      { createDate(1999, Calendar.AUGUST,9), new Double(1.6000) },
      { createDate(1999, Calendar.AUGUST,10), new Double(1.6180) },
      { createDate(1999, Calendar.AUGUST,11), new Double(1.6107) },
      { createDate(1999, Calendar.AUGUST,12), new Double(1.6090) },
      { createDate(1999, Calendar.AUGUST,13), new Double(1.6057) },
      { createDate(1999, Calendar.AUGUST,16), new Double(1.6011) },
      { createDate(1999, Calendar.AUGUST,17), new Double(1.6036) },
      { createDate(1999, Calendar.AUGUST,18), new Double(1.6004) },
      { createDate(1999, Calendar.AUGUST,19), new Double(1.6180) },
      { createDate(1999, Calendar.AUGUST,20), new Double(1.6133) },
      { createDate(1999, Calendar.AUGUST,23), new Double(1.6076) },
      { createDate(1999, Calendar.AUGUST,24), new Double(1.5946) },
      { createDate(1999, Calendar.AUGUST,25), new Double(1.5865) },
      { createDate(1999, Calendar.AUGUST,26), new Double(1.5876) },
      { createDate(1999, Calendar.AUGUST,27), new Double(1.5885) },
      { createDate(1999, Calendar.AUGUST,30), new Double(1.5875) },
      { createDate(1999, Calendar.AUGUST,31), new Double(1.6086) },
      { createDate(1999, Calendar.SEPTEMBER,1), new Double(1.6023) },
      { createDate(1999, Calendar.SEPTEMBER,2), new Double(1.6091) },
      { createDate(1999, Calendar.SEPTEMBER,3), new Double(1.6028) },
      { createDate(1999, Calendar.SEPTEMBER,7), new Double(1.6057) },
      { createDate(1999, Calendar.SEPTEMBER,8), new Double(1.6185) },
      { createDate(1999, Calendar.SEPTEMBER,9), new Double(1.6332) },
      { createDate(1999, Calendar.SEPTEMBER,10), new Double(1.6183) },
      { createDate(1999, Calendar.SEPTEMBER,13), new Double(1.6090) },
      { createDate(1999, Calendar.SEPTEMBER,14), new Double(1.6085) },
      { createDate(1999, Calendar.SEPTEMBER,15), new Double(1.6110) },
      { createDate(1999, Calendar.SEPTEMBER,16), new Double(1.6250) },
      { createDate(1999, Calendar.SEPTEMBER,17), new Double(1.6222) },
      { createDate(1999, Calendar.SEPTEMBER,20), new Double(1.6230) },
      { createDate(1999, Calendar.SEPTEMBER,21), new Double(1.6310) },
      { createDate(1999, Calendar.SEPTEMBER,22), new Double(1.6363) },
      { createDate(1999, Calendar.SEPTEMBER,23), new Double(1.6375) },
      { createDate(1999, Calendar.SEPTEMBER,24), new Double(1.6428) },
      { createDate(1999, Calendar.SEPTEMBER,27), new Double(1.6455) },
      { createDate(1999, Calendar.SEPTEMBER,28), new Double(1.6485) },
      { createDate(1999, Calendar.SEPTEMBER,29), new Double(1.6425) },
      { createDate(1999, Calendar.SEPTEMBER,30), new Double(1.6457) },
      { createDate(1999, Calendar.OCTOBER,1), new Double(1.6550) },
      { createDate(1999, Calendar.OCTOBER,4), new Double(1.6555) },
      { createDate(1999, Calendar.OCTOBER,5), new Double(1.6525) },
      { createDate(1999, Calendar.OCTOBER,6), new Double(1.6560) },
      { createDate(1999, Calendar.OCTOBER,7), new Double(1.6520) },
      { createDate(1999, Calendar.OCTOBER,8), new Double(1.6520) },
      { createDate(1999, Calendar.OCTOBER,12), new Double(1.6535) },
      { createDate(1999, Calendar.OCTOBER,13), new Double(1.6532) },
      { createDate(1999, Calendar.OCTOBER,14), new Double(1.6575) },
      { createDate(1999, Calendar.OCTOBER,15), new Double(1.6684) },
      { createDate(1999, Calendar.OCTOBER,18), new Double(1.6720) },
      { createDate(1999, Calendar.OCTOBER,19), new Double(1.6708) },
      { createDate(1999, Calendar.OCTOBER,20), new Double(1.6643) },
      { createDate(1999, Calendar.OCTOBER,21), new Double(1.6765) },
      { createDate(1999, Calendar.OCTOBER,22), new Double(1.6584) },
      { createDate(1999, Calendar.OCTOBER,25), new Double(1.6631) },
      { createDate(1999, Calendar.OCTOBER,26), new Double(1.6525) },
      { createDate(1999, Calendar.OCTOBER,27), new Double(1.6477) },
      { createDate(1999, Calendar.OCTOBER,28), new Double(1.6400) },
      { createDate(1999, Calendar.OCTOBER,29), new Double(1.6425) },
      { createDate(1999, Calendar.NOVEMBER,1), new Double(1.6404) },
      { createDate(1999, Calendar.NOVEMBER,2), new Double(1.6445) },
      { createDate(1999, Calendar.NOVEMBER,3), new Double(1.6440) },
      { createDate(1999, Calendar.NOVEMBER,4), new Double(1.6375) },
      { createDate(1999, Calendar.NOVEMBER,5), new Double(1.6205) },
      { createDate(1999, Calendar.NOVEMBER,8), new Double(1.6150) },
      { createDate(1999, Calendar.NOVEMBER,9), new Double(1.6210) },
      { createDate(1999, Calendar.NOVEMBER,10), new Double(1.6250) },
      { createDate(1999, Calendar.NOVEMBER,12), new Double(1.6131) },
      { createDate(1999, Calendar.NOVEMBER,15), new Double(1.6230) },
      { createDate(1999, Calendar.NOVEMBER,16), new Double(1.6164) },
      { createDate(1999, Calendar.NOVEMBER,17), new Double(1.6231) },
      { createDate(1999, Calendar.NOVEMBER,18), new Double(1.6150) },
      { createDate(1999, Calendar.NOVEMBER,19), new Double(1.6160) },
      { createDate(1999, Calendar.NOVEMBER,22), new Double(1.6205) },
      { createDate(1999, Calendar.NOVEMBER,23), new Double(1.6236) },
      { createDate(1999, Calendar.NOVEMBER,24), new Double(1.6090) },
      { createDate(1999, Calendar.NOVEMBER,26), new Double(1.6062) },
      { createDate(1999, Calendar.NOVEMBER,29), new Double(1.6024) },
      { createDate(1999, Calendar.NOVEMBER,30), new Double(1.5935) },
      { createDate(1999, Calendar.DECEMBER,1), new Double(1.5960) },
      { createDate(1999, Calendar.DECEMBER,2), new Double(1.5972) },
      { createDate(1999, Calendar.DECEMBER,3), new Double(1.6015) },
      { createDate(1999, Calendar.DECEMBER,6), new Double(1.6230) },
      { createDate(1999, Calendar.DECEMBER,7), new Double(1.6233) },
      { createDate(1999, Calendar.DECEMBER,8), new Double(1.6255) },
      { createDate(1999, Calendar.DECEMBER,9), new Double(1.6230) },
      { createDate(1999, Calendar.DECEMBER,10), new Double(1.6225) },
      { createDate(1999, Calendar.DECEMBER,13), new Double(1.6232) },
      { createDate(1999, Calendar.DECEMBER,14), new Double(1.6110) },
      { createDate(1999, Calendar.DECEMBER,15), new Double(1.6085) },
      { createDate(1999, Calendar.DECEMBER,16), new Double(1.6123) },
      { createDate(1999, Calendar.DECEMBER,17), new Double(1.6070) },
      { createDate(1999, Calendar.DECEMBER,20), new Double(1.6035) },
      { createDate(1999, Calendar.DECEMBER,21), new Double(1.6103) },
      { createDate(1999, Calendar.DECEMBER,22), new Double(1.6060) },
      { createDate(1999, Calendar.DECEMBER,23), new Double(1.6161) },
      { createDate(1999, Calendar.DECEMBER,24), new Double(1.6154) },
      { createDate(1999, Calendar.DECEMBER,27), new Double(1.6173) },
      { createDate(1999, Calendar.DECEMBER,28), new Double(1.6165) },
      { createDate(1999, Calendar.DECEMBER,29), new Double(1.6168) },
      { createDate(1999, Calendar.DECEMBER,30), new Double(1.6130) },
      { createDate(1999, Calendar.DECEMBER,31), new Double(1.6150) },
      { createDate(2000, Calendar.JANUARY,3), new Double(1.6270) },
      { createDate(2000, Calendar.JANUARY,4), new Double(1.6370) },
      { createDate(2000, Calendar.JANUARY,5), new Double(1.6415) },
      { createDate(2000, Calendar.JANUARY,6), new Double(1.6475) },
      { createDate(2000, Calendar.JANUARY,7), new Double(1.6384) },
      { createDate(2000, Calendar.JANUARY,10), new Double(1.6374) },
      { createDate(2000, Calendar.JANUARY,11), new Double(1.6480) },
      { createDate(2000, Calendar.JANUARY,12), new Double(1.6465) },
      { createDate(2000, Calendar.JANUARY,13), new Double(1.6482) },
      { createDate(2000, Calendar.JANUARY,14), new Double(1.6353) },
      { createDate(2000, Calendar.JANUARY,18), new Double(1.6380) },
      { createDate(2000, Calendar.JANUARY,19), new Double(1.6438) },
      { createDate(2000, Calendar.JANUARY,20), new Double(1.6538) },
      { createDate(2000, Calendar.JANUARY,21), new Double(1.6504) },
      { createDate(2000, Calendar.JANUARY,24), new Double(1.6520) },
      { createDate(2000, Calendar.JANUARY,25), new Double(1.6482) },
      { createDate(2000, Calendar.JANUARY,26), new Double(1.6395) },
      { createDate(2000, Calendar.JANUARY,27), new Double(1.6363) },
      { createDate(2000, Calendar.JANUARY,28), new Double(1.6210) },
      { createDate(2000, Calendar.JANUARY,31), new Double(1.6182) },
      { createDate(2000, Calendar.FEBRUARY,1), new Double(1.6150) },
      { createDate(2000, Calendar.FEBRUARY,2), new Double(1.6060) },
      { createDate(2000, Calendar.FEBRUARY,3), new Double(1.6025) },
      { createDate(2000, Calendar.FEBRUARY,4), new Double(1.5915) },
      { createDate(2000, Calendar.FEBRUARY,7), new Double(1.5917) },
      { createDate(2000, Calendar.FEBRUARY,8), new Double(1.6105) },
      { createDate(2000, Calendar.FEBRUARY,9), new Double(1.6115) },
      { createDate(2000, Calendar.FEBRUARY,10), new Double(1.6057) },
      { createDate(2000, Calendar.FEBRUARY,11), new Double(1.5923) },
      { createDate(2000, Calendar.FEBRUARY,14), new Double(1.5890) },
      { createDate(2000, Calendar.FEBRUARY,15), new Double(1.5950) },
      { createDate(2000, Calendar.FEBRUARY,16), new Double(1.6040) },
      { createDate(2000, Calendar.FEBRUARY,17), new Double(1.6050) },
      { createDate(2000, Calendar.FEBRUARY,18), new Double(1.5984) },
      { createDate(2000, Calendar.FEBRUARY,22), new Double(1.6165) },
      { createDate(2000, Calendar.FEBRUARY,23), new Double(1.6047) },
      { createDate(2000, Calendar.FEBRUARY,24), new Double(1.5981) },
      { createDate(2000, Calendar.FEBRUARY,25), new Double(1.5908) },
      { createDate(2000, Calendar.FEBRUARY,28), new Double(1.5935) },
      { createDate(2000, Calendar.FEBRUARY,29), new Double(1.5780) },
      { createDate(2000, Calendar.MARCH,1), new Double(1.5849) },
      { createDate(2000, Calendar.MARCH,2), new Double(1.5765) },
      { createDate(2000, Calendar.MARCH,3), new Double(1.5810) },
      { createDate(2000, Calendar.MARCH,6), new Double(1.5732) },
      { createDate(2000, Calendar.MARCH,7), new Double(1.5772) },
      { createDate(2000, Calendar.MARCH,8), new Double(1.5855) },
      { createDate(2000, Calendar.MARCH,9), new Double(1.5815) },
      { createDate(2000, Calendar.MARCH,10), new Double(1.5793) },
      { createDate(2000, Calendar.MARCH,13), new Double(1.5782) },
      { createDate(2000, Calendar.MARCH,14), new Double(1.5725) },
      { createDate(2000, Calendar.MARCH,15), new Double(1.5730) },
      { createDate(2000, Calendar.MARCH,16), new Double(1.5747) },
      { createDate(2000, Calendar.MARCH,17), new Double(1.5705) } } };

    return new DefaultXYDataset(new String[] { "USD" }, data);
###
3113, JFreeChartDemo, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 142, 159
3
/**
   * Constructs a demonstration application for the JFreeChart Class Library.
   */
18
  public JFreeChartDemo() {

    super("JFreeChart "+JFreeChart.VERSION+" Demo");

    addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        dispose();
        System.exit(0);
      }
    });

    // set up the menu
    JMenuBar menuBar = createMenuBar();
    setJMenuBar(menuBar);

    JPanel content = new JPanel(new BorderLayout());
    content.add(createTabbedPane());
    setContentPane(content);
###
3114, displayPieChartOne, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 763, 790
3
/**
   * Displays pie chart one in its own frame.
   */
28
  private void displayPieChartOne() {

    if (pieChartOneFrame==null) {

      // create a default chart based on some sample data...
      String title = "Pie Chart";
      CategoryDataset data = createCategoryDataset();
      PieDataset extracted = Datasets.createPieDataset(data, 0);
      JFreeChart chart = ChartFactory.createPieChart(title, extracted, true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 0, 1000, Color.orange));
      PiePlot plot = (PiePlot)chart.getPlot();
      plot.setCircular(false);
      // make section 1 explode by 100%...
      plot.setRadiusPercent(0.60);
      plot.setExplodePercent(1, 1.00);

      // and present it in a frame...
      pieChartOneFrame = new JFreeChartFrame("Pie Chart 1", chart);
      pieChartOneFrame.pack();
      SwingRefinery.positionFrameRandomly(pieChartOneFrame);
      pieChartOneFrame.show();

    }
    else {
      pieChartOneFrame.show();
      pieChartOneFrame.requestFocus();
###
3115, createSingleCategoryDataset, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1153, 1166
3
/**
   * Creates and returns a category dataset with JUST ONE CATEGORY for the demo charts.
   */
14
  public CategoryDataset createSingleCategoryDataset() {

    Number[][] data = new Integer[][]
      { { new Integer(10) },
        { new Integer(-5) },
        { new Integer(6) },
        { new Integer(7) },
        { new Integer(-8) },
        { new Integer(9) },
        { new Integer(-10) },
        { new Integer(11) },
        { new Integer(-3) } };

    return new DefaultCategoryDataset(data);
###
3116, displayXYPlot, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 832, 855
3
/**
   * Displays an XYPlot in its own frame.
   */
24
  private void displayXYPlot() {

    if (xyPlotFrame==null) {

      // create a default chart based on some sample data...
      String title = "XY Plot";
      String xAxisLabel = "X Axis";
      String yAxisLabel = "Y Axis";
      XYDataset data = new SampleXYDataset();
      JFreeChart chart = ChartFactory.createXYChart(title, xAxisLabel, yAxisLabel, data, true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white,0, 1000, Color.green));

      // and present it in a frame...
      xyPlotFrame = new JFreeChartFrame("XYPlot", chart);
      xyPlotFrame.pack();
      SwingRefinery.positionFrameRandomly(xyPlotFrame);
      xyPlotFrame.show();

    }
    else {
      xyPlotFrame.show();
      xyPlotFrame.requestFocus();
###
3117, windowClosed, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1814, 1821
3
/**
   * Clears the reference to the print preview frames when they are closed.
   */
8
  public void windowClosed(WindowEvent e) {

    //if (e.getWindow()==this.infoFrame) {
    //  infoFrame=null;
    //}
    //else
    if (e.getWindow()==this.aboutFrame) {
      aboutFrame=null;
###
3118, createMenuBar, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 423, 451
3
/**
   * Creates a menubar.
   */
29
  private JMenuBar createMenuBar() {

    // create the menus
    JMenuBar menuBar = new JMenuBar();

    // first the file menu
    JMenu fileMenu = new JMenu("File", true);
    fileMenu.setMnemonic('F');


    JMenuItem exitItem = new JMenuItem("Exit", 'x');
    exitItem.setActionCommand("exitItem");
    exitItem.addActionListener(this);
    fileMenu.add(exitItem);

    // then the help menu
    JMenu helpMenu = new JMenu("Help");
    helpMenu.setMnemonic('H');

    JMenuItem aboutItem = new JMenuItem("About...", 'A');
    aboutItem.setActionCommand("aboutItem");
    aboutItem.addActionListener(this);
    helpMenu.add(aboutItem);

    // finally, glue together the menu and return it
    menuBar.add(fileMenu);
    menuBar.add(helpMenu);

    return menuBar;
###
3119, displayVertical3DBarChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 629, 654
3
/**
   * Displays a vertical 3D bar chart in its own frame.
   */
26
  private void displayVertical3DBarChart() {

    if (vertical3DBarChartFrame==null) {

    // create a default chart based on some sample data...
    String title = "Vertical Bar Chart (3D Effect)";
    String categoryAxisLabel = "Categories";
    String valueAxisLabel = "Values";
    CategoryDataset categoryData = createCategoryDataset();
    JFreeChart chart = ChartFactory.createVerticalBarChart3D(title, categoryAxisLabel,
                                 valueAxisLabel, categoryData, true);

    // then customise it a little...
    chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.blue));
    Plot plot = chart.getPlot();

      // and present it in a panel...
      vertical3DBarChartFrame = new JFreeChartFrame("Vertical 3D Bar Chart", chart);
      vertical3DBarChartFrame.pack();
      SwingRefinery.positionFrameRandomly(vertical3DBarChartFrame);
      vertical3DBarChartFrame.show();

    }
    else {
      vertical3DBarChartFrame.show();
      vertical3DBarChartFrame.requestFocus();
###
3120, displayTimeSeriesWithMAChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 992, 1023
3
/**
   * Displays a vertical bar chart in its own frame.
   */
32
  private void displayTimeSeriesWithMAChart() {

    if (this.timeSeriesWithMAChartFrame==null) {

      // create a default chart based on some sample data...
      String title = "Moving Average";
      String timeAxisLabel = "Date";
      String valueAxisLabel = "USD per GBP";
      XYDataset data = createXYDataset();
      MovingAveragePlotFitAlgorithm mavg = new MovingAveragePlotFitAlgorithm();
    mavg.setPeriod(30);
      PlotFit pf = new PlotFit(data, mavg);
      data = pf.getFit();
      JFreeChart chart = ChartFactory.createTimeSeriesChart(title, timeAxisLabel, valueAxisLabel,
                                data, true);

      // then customise it a little...
      TextTitle subtitle = new TextTitle("30 day moving average of GBP", new Font("Arial", Font.BOLD, 12));
      chart.addTitle(subtitle);
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white,0, 1000, Color.blue));


      // and present it in a frame...
      timeSeriesWithMAChartFrame = new JFreeChartFrame("Time Series Chart", chart);
      timeSeriesWithMAChartFrame.pack();
      SwingRefinery.positionFrameRandomly(timeSeriesWithMAChartFrame);
      timeSeriesWithMAChartFrame.show();

    }
    else {
      timeSeriesWithMAChartFrame.show();
      timeSeriesWithMAChartFrame.requestFocus();
###
3121, displayHorizontalBarChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 662, 687
3
/**
   * Displays a horizontal bar chart in its own frame.
   */
26
  private void displayHorizontalBarChart() {

    if (horizontalBarChartFrame==null) {

      // create a default chart based on some sample data...
      String title = "Horizontal Bar Chart";
      String categoryAxisLabel = "Categories";
      String valueAxisLabel = "Values";
      CategoryDataset categoryData = createCategoryDataset();
      JFreeChart chart = ChartFactory.createHorizontalBarChart(title, categoryAxisLabel,
                                 valueAxisLabel, categoryData,
                                 true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white,0, 1000, Color.orange));

      // and present it in a frame...
      horizontalBarChartFrame = new JFreeChartFrame("Horizontal Bar Chart", chart);
      horizontalBarChartFrame.pack();
      SwingRefinery.positionFrameRandomly(horizontalBarChartFrame);
      horizontalBarChartFrame.show();

    }
    else {
      horizontalBarChartFrame.show();
      horizontalBarChartFrame.requestFocus();
###
3122, about, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1101, 1113
3
/**
   * Displays information about the application.
   */
13
  private void about() {

    if (aboutFrame==null) {
      aboutFrame = new AboutFrame("About...",
                    "JFreeChart",
                    "Version "+JFreeChart.VERSION,
                    "http://www.jrefinery.com/jfreechart",
                    Licences.LGPL);
      aboutFrame.pack();
      SwingRefinery.centerFrameOnScreen(aboutFrame);
    }
    aboutFrame.show();
    aboutFrame.requestFocus();
###
3123, displayTimeSeriesChartInScrollPane, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1066, 1093
3
/**
   * Displays a vertical bar chart in its own frame.
   */
28
  private void displayTimeSeriesChartInScrollPane() {

    if (this.timeSeriesChartScrollFrame==null) {

      // create a default chart based on some sample data...
      String title = "Time Series Chart";
      String xAxisLabel = "Date";
      String yAxisLabel = "USD per GBP";
      XYDataset data = createXYDataset();
      JFreeChart chart = ChartFactory.createTimeSeriesChart(title, xAxisLabel, yAxisLabel, data,
                                true);

      // then customise it a little...
      TextTitle subtitle = new TextTitle("Value of GBP", new Font("Arial", Font.BOLD, 12));
      chart.addTitle(subtitle);
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white,0, 1000, Color.gray));
      Plot plot = chart.getPlot();

      // and present it in a frame...
      timeSeriesChartScrollFrame = new JFreeChartFrame("Time Series Chart", chart, true);
      timeSeriesChartScrollFrame.pack();
      SwingRefinery.positionFrameRandomly(timeSeriesChartScrollFrame);
      timeSeriesChartScrollFrame.show();

    }
    else {
      timeSeriesChartScrollFrame.show();
      timeSeriesChartScrollFrame.requestFocus();
###
3124, getPreferredSize, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 167, 168
4
/**
   * Returns the preferred size for the frame.
   * @return The preferred size for the frame.
   */
2
  public Dimension getPreferredSize() {
    return PREFERRED_SIZE;
###
3125, createTestXYDataset, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 1518, 1531
3
/**
   * Creates and returns a XYDataset for the demo charts.
   */
14
  public XYDataset createTestXYDataset() {

    Object[][][] data = new Object[][][] { {
      { createDateTime(2000, Calendar.OCTOBER, 18, 9, 5), new Double(10921.0) },
      { createDateTime(2000, Calendar.OCTOBER, 18, 10, 6), new Double(10886.7) },
      { createDateTime(2000, Calendar.OCTOBER, 18, 11, 6), new Double(10846.6) },
      { createDateTime(2000, Calendar.OCTOBER, 18, 12, 6), new Double(10843.7) },
      { createDateTime(2000, Calendar.OCTOBER, 18, 13, 6), new Double(10841.2) },
      { createDateTime(2000, Calendar.OCTOBER, 18, 14, 6), new Double(10830.7) },
      { createDateTime(2000, Calendar.OCTOBER, 18, 15, 6), new Double(10795.8) },
      { createDateTime(2000, Calendar.OCTOBER, 18, 16, 7), new Double(10733.8) }
    } };

    return new DefaultXYDataset(data);
###
3127, displayHorizontalStackedBarChart, JFreeChartDemo, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/JFreeChartDemo.java, 695, 723
3
/**
   * Displays a horizontal bar chart in its own frame.
   */
29
  private void displayHorizontalStackedBarChart() {

    if (horizontalStackedBarChartFrame==null) {

      // create a default chart based on some sample data...
      String title = "Horizontal Stacked Bar Chart";
      String categoryAxisLabel = "Categories";
      String valueAxisLabel = "Values";
      CategoryDataset categoryData = createCategoryDataset();
      JFreeChart chart = ChartFactory.createStackedHorizontalBarChart(title, categoryAxisLabel,
                                 valueAxisLabel, categoryData, true);

      // then customise it a little...
      chart.setChartBackgroundPaint(new GradientPaint(0, 0, Color.white, 1000, 0, Color.blue));
      Plot plot = chart.getPlot();
      HorizontalNumberAxis valueAxis = (HorizontalNumberAxis)plot.getAxis(Plot.HORIZONTAL_AXIS);
      valueAxis.setMinimumAxisValue(new Double(-32.0));
      valueAxis.setMaximumAxisValue(new Double(85.0));

      // and present it in a frame...
      horizontalStackedBarChartFrame = new JFreeChartFrame("Horizontal Bar Chart", chart);
      horizontalStackedBarChartFrame.pack();
      SwingRefinery.positionFrameRandomly(horizontalStackedBarChartFrame);
      horizontalStackedBarChartFrame.show();

    }
    else {
      horizontalStackedBarChartFrame.show();
      horizontalStackedBarChartFrame.requestFocus();
###
3130, getResults, PlotFit, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/PlotFit.java, 83, 124
5
/**
   * Returns a three-dimensional array based on algorithm calculations.  Used to create a new
   * dataset.
   * Matthew Wright:  implements what I'm doing in code now... not the best way to do this?
   */
42
  public Object[][][] getResults() {

    /* set up our algorithm */
    alg.setXYDataset(dataset);

    /* make a data container big enough to hold it all */
    int arraysize = 0;
    int seriescount = dataset.getSeriesCount();
    for(int i = 0; i < seriescount; i++) {
      if(dataset.getItemCount(i) > arraysize) {
        arraysize = dataset.getItemCount(i);
      }
    }

    // we'll apply the plot fit to all of the series for now
    Object[][][] newdata = new Object[seriescount * 2][arraysize][2];

    /* copy in the series to the first half */
    for(int i = 0; i < seriescount; i++) {
      for(int j = 0; j < dataset.getItemCount(i); j++) {
        Number x = dataset.getXValue(i,j);
        newdata[i][j][0] = x;
        newdata[i][j][1] = dataset.getYValue(i,j);
        Number y = alg.getY(i, x);
        /*
         * only want to set data for non-null algorithm fits.
         * This allows things like moving average plots, or partial
         * plots to return null and not get NPEs when the chart is
         * created
         */
        //System.out.println("At [" + i + "," + j + "] the values = [" + x + "," + y + "]");
        if(y != null) {
          newdata[i + seriescount][j][0] = x;
          newdata[i + seriescount][j][1] = y;
        }
        else {
          newdata[i + seriescount][j][0] = null;
          newdata[i + seriescount][j][1] = null;
      }
      }
    }
    return newdata;
###
3131, setPlotFitAlgorithm, PlotFit, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/PlotFit.java, 74, 75
4
/**
   * Sets the algorithm used to generate the new dataset.
   * @param alg The algorithm.
   */
2
  public void setPlotFitAlgorithm(PlotFitAlgorithm alg) {
    this.alg = alg;
###
3132, PlotFit, PlotFit, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/PlotFit.java, 57, 59
5
/**
   * Standard constructor.
   * @param data The underlying dataset.
   * @param alg The algorithm.
   */
3
  public PlotFit(XYDataset data, PlotFitAlgorithm alg) {
    this.dataset = data;
    this.alg = alg;
###
3133, setXYDataset, PlotFit, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/PlotFit.java, 66, 67
4
/**
   * Sets the underlying dataset.
   * @param data The underlying dataset.
   */
2
  public void setXYDataset(XYDataset data) {
    this.dataset = data;
###
3134, getXValue, EmptyXYDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/EmptyXYDataset.java, 55, 56
6
/**
   * Returns the x-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The x-value for the specified series and item.
   */
2
  public Number getXValue(int series, int item) {
    return null;
###
3135, getYValue, EmptyXYDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/EmptyXYDataset.java, 65, 66
6
/**
   * Returns the y-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The y-value for the specified series and item.
   */
2
  public Number getYValue(int series, int item) {
    return null;
###
3136, getSeriesCount, EmptyXYDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/EmptyXYDataset.java, 73, 74
4
/**
   * Returns the number of series in the data source.
   * @return The number of series in the data source.
   */
2
  public int getSeriesCount() {
    return 0;
###
3137, getSeriesName, EmptyXYDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/EmptyXYDataset.java, 82, 83
5
/**
   * Returns the name of the series.
   * @param series The index (zero-based) of the series;
   * @return The name of the series.
   */
2
  public String getSeriesName(int series) {
    return null;
###
3139, getYValue, SampleXYDataset2, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleXYDataset2.java, 86, 87
6
/**
   * Returns the y-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The y-value for the specified series and item.
   */
2
  public Number getYValue(int series, int item) {
    return yValues[series][item];
###
3140, getSeriesName, SampleXYDataset2, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleXYDataset2.java, 103, 104
5
/**
   * Returns the name of the series.
   * @param series The index (zero-based) of the series;
   * @return The name of the series.
   */
2
  public String getSeriesName(int series) {
    return "Sample "+series;
###
3141, getSeriesCount, SampleXYDataset2, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleXYDataset2.java, 94, 95
4
/**
   * Returns the number of series in the data source.
   * @return The number of series in the data source.
   */
2
  public int getSeriesCount() {
    return SERIES_COUNT;
###
3142, SampleXYDataset2, SampleXYDataset2, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleXYDataset2.java, 58, 64
3
/**
   * Default constructor.
   */
7
  public SampleXYDataset2() {

    for (int series=0; series<SERIES_COUNT; series++) {
      for (int item=0; item<ITEM_COUNT; item++) {
        double x = (Math.random()-0.5) * RANGE;
        xValues[series][item] = new Double(x);
        yValues[series][item] = new Double((Math.random() - 0.5) * x * x);
###
3143, getXValue, SampleXYDataset2, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleXYDataset2.java, 76, 77
6
/**
   * Returns the x-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The x-value for the specified series and item.
   */
2
  public Number getXValue(int series, int item) {
    return xValues[series][item];
###
3144, getOpenValue, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 119, 123
6
/**
   * Returns the open-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The open-value for the specified series and item.
   */
5
  public Number getOpenValue(int series, int item) {
    if (series==0) {
      return opens[item];
    }
    else return null;
###
3145, initialiseData, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 171, 459
3
/**
   * Sets up the data for the sample data source.
   */
289
  private void initialiseData() {

    dates = new Date[47];
    highs = new Double[47];
    lows = new Double[47];
    opens = new Double[47];
    closes = new Double[47];

    dates[0]  = createDate(1999, Calendar.JANUARY,4);
    highs[0]  = new Double(47.0);
    lows[0]   = new Double(33.0);
    opens[0]  = new Double(35.0);
    closes[0] = new Double(33.0);

    dates[1]  = createDate(1999, Calendar.JANUARY,5);
    highs[1]  = new Double(47.0);
    lows[1]   = new Double(32.0);
    opens[1]  = new Double(41.0);
    closes[1] = new Double(37.0);

    dates[2]  = createDate(1999, Calendar.JANUARY,6);
    highs[2]  = new Double(49.0);
    lows[2]   = new Double(43.0);
    opens[2]  = new Double(46.0);
    closes[2] = new Double(48.0);

    dates[3]  = createDate(1999, Calendar.JANUARY,7);
    highs[3]  = new Double(51.0);
    lows[3]   = new Double(39.0);
    opens[3]  = new Double(40.0);
    closes[3] = new Double(47.0);

    dates[4]  = createDate(1999, Calendar.JANUARY,8);
    highs[4]  = new Double(60.0);
    lows[4]   = new Double(40.0);
    opens[4]  = new Double(46.0);
    closes[4] = new Double(53.0);

    dates[5]  = createDate(1999, Calendar.JANUARY,9);
    highs[5]  = new Double(62.0);
    lows[5]   = new Double(55.0);
    opens[5]  = new Double(57.0);
    closes[5] = new Double(61.0);

    dates[6]  = createDate(1999, Calendar.JANUARY,10);
    highs[6]  = new Double(65.0);
    lows[6]   = new Double(56.0);
    opens[6]  = new Double(62.0);
    closes[6] = new Double(59.0);

    dates[7]  = createDate(1999, Calendar.JANUARY,11);
    highs[7]  = new Double(55.0);
    lows[7]   = new Double(43.0);
    opens[7]  = new Double(45.0);
    closes[7] = new Double(47.0);

    dates[8]  = createDate(1999, Calendar.JANUARY,12);
    highs[8]  = new Double(54.0);
    lows[8]   = new Double(33.0);
    opens[8]  = new Double(40.0);
    closes[8] = new Double(51.0);

    dates[9]  = createDate(1999, Calendar.JANUARY,13);
    highs[9]  = new Double(47.0);
    lows[9]   = new Double(33.0);
    opens[9]  = new Double(35.0);
    closes[9] = new Double(33.0);

    dates[10]  = createDate(1999, Calendar.JANUARY,14);
    highs[10]  = new Double(54.0);
    lows[10]   = new Double(38.0);
    opens[10]  = new Double(43.0);
    closes[10] = new Double(52.0);

    dates[11]  = createDate(1999, Calendar.JANUARY,15);
    highs[11]  = new Double(48.0);
    lows[11]   = new Double(41.0);
    opens[11]  = new Double(44.0);
    closes[11] = new Double(41.0);

    dates[12]  = createDate(1999, Calendar.JANUARY,17);
    highs[12]  = new Double(60.0);
    lows[12]   = new Double(30.0);
    opens[12]  = new Double(34.0);
    closes[12] = new Double(44.0);

    dates[13]  = createDate(1999, Calendar.JANUARY,18);
    highs[13]  = new Double(58.0);
    lows[13]   = new Double(44.0);
    opens[13]  = new Double(54.0);
    closes[13] = new Double(56.0);

    dates[14]  = createDate(1999, Calendar.JANUARY,19);
    highs[14]  = new Double(54.0);
    lows[14]   = new Double(32.0);
    opens[14]  = new Double(42.0);
    closes[14] = new Double(53.0);

    dates[15]  = createDate(1999, Calendar.JANUARY,20);
    highs[15]  = new Double(53.0);
    lows[15]   = new Double(39.0);
    opens[15]  = new Double(50.0);
    closes[15] = new Double(49.0);

    dates[16]  = createDate(1999, Calendar.JANUARY,21);
    highs[16]  = new Double(47.0);
    lows[16]   = new Double(33.0);
    opens[16]  = new Double(41.0);
    closes[16] = new Double(40.0);

    dates[17]  = createDate(1999, Calendar.JANUARY,22);
    highs[17]  = new Double(55.0);
    lows[17]   = new Double(37.0);
    opens[17]  = new Double(43.0);
    closes[17] = new Double(45.0);

    dates[18]  = createDate(1999, Calendar.JANUARY,23);
    highs[18]  = new Double(54.0);
    lows[18]   = new Double(42.0);
    opens[18]  = new Double(50.0);
    closes[18] = new Double(42.0);

    dates[19]  = createDate(1999, Calendar.JANUARY,24);
    highs[19]  = new Double(48.0);
    lows[19]   = new Double(37.0);
    opens[19]  = new Double(37.0);
    closes[19] = new Double(47.0);

    dates[20]  = createDate(1999, Calendar.JANUARY,25);
    highs[20]  = new Double(58.0);
    lows[20]   = new Double(33.0);
    opens[20]  = new Double(39.0);
    closes[20] = new Double(41.0);

    dates[21]  = createDate(1999, Calendar.JANUARY,26);
    highs[21]  = new Double(47.0);
    lows[21]   = new Double(31.0);
    opens[21]  = new Double(36.0);
    closes[21] = new Double(41.0);

    dates[22]  = createDate(1999, Calendar.JANUARY,27);
    highs[22]  = new Double(58.0);
    lows[22]   = new Double(44.0);
    opens[22]  = new Double(49.0);
    closes[22] = new Double(44.0);

    dates[23]  = createDate(1999, Calendar.JANUARY,28);
    highs[23]  = new Double(46.0);
    lows[23]   = new Double(41.0);
    opens[23]  = new Double(43.0);
    closes[23] = new Double(44.0);

    dates[24]  = createDate(1999, Calendar.JANUARY,29);
    highs[24]  = new Double(56.0);
    lows[24]   = new Double(39.0);
    opens[24]  = new Double(39.0);
    closes[24] = new Double(51.0);

    dates[25]  = createDate(1999, Calendar.JANUARY,30);
    highs[25]  = new Double(56.0);
    lows[25]   = new Double(39.0);
    opens[25]  = new Double(47.0);
    closes[25] = new Double(49.0);

    dates[26]  = createDate(1999, Calendar.JANUARY,31);
    highs[26]  = new Double(53.0);
    lows[26]   = new Double(39.0);
    opens[26]  = new Double(52.0);
    closes[26] = new Double(47.0);

    dates[27]  = createDate(1999, Calendar.FEBRUARY,1);
    highs[27]  = new Double(51.0);
    lows[27]   = new Double(30.0);
    opens[27]  = new Double(45.0);
    closes[27] = new Double(47.0);

    dates[28]  = createDate(1999, Calendar.FEBRUARY,2);
    highs[28]  = new Double(47.0);
    lows[28]   = new Double(30.0);
    opens[28]  = new Double(34.0);
    closes[28] = new Double(46.0);

    dates[29]  = createDate(1999, Calendar.FEBRUARY,3);
    highs[29]  = new Double(57.0);
    lows[29]   = new Double(37.0);
    opens[29]  = new Double(44.0);
    closes[29] = new Double(56.0);

    dates[30]  = createDate(1999, Calendar.FEBRUARY,4);
    highs[30]  = new Double(49.0);
    lows[30]   = new Double(40.0);
    opens[30]  = new Double(47.0);
    closes[30] = new Double(44.0);

    dates[31]  = createDate(1999, Calendar.FEBRUARY,5);
    highs[31]  = new Double(46.0);
    lows[31]   = new Double(38.0);
    opens[31]  = new Double(43.0);
    closes[31] = new Double(40.0);

    dates[32]  = createDate(1999, Calendar.FEBRUARY,6);
    highs[32]  = new Double(55.0);
    lows[32]   = new Double(38.0);
    opens[32]  = new Double(39.0);
    closes[32] = new Double(53.0);

    dates[33]  = createDate(1999, Calendar.FEBRUARY,7);
    highs[33]  = new Double(50.0);
    lows[33]   = new Double(33.0);
    opens[33]  = new Double(37.0);
    closes[33] = new Double(37.0);

    dates[34]  = createDate(1999, Calendar.FEBRUARY,8);
    highs[34]  = new Double(59.0);
    lows[34]   = new Double(34.0);
    opens[34]  = new Double(57.0);
    closes[34] = new Double(43.0);

    dates[35]  = createDate(1999, Calendar.FEBRUARY,9);
    highs[35]  = new Double(48.0);
    lows[35]   = new Double(39.0);
    opens[35]  = new Double(46.0);
    closes[35] = new Double(47.0);

    dates[36]  = createDate(1999, Calendar.FEBRUARY,10);
    highs[36]  = new Double(55.0);
    lows[36]   = new Double(30.0);
    opens[36]  = new Double(37.0);
    closes[36] = new Double(30.0);

    dates[37]  = createDate(1999, Calendar.FEBRUARY,11);
    highs[37]  = new Double(60.0);
    lows[37]   = new Double(32.0);
    opens[37]  = new Double(56.0);
    closes[37] = new Double(36.0);

    dates[38]  = createDate(1999, Calendar.FEBRUARY,12);
    highs[38]  = new Double(56.0);
    lows[38]   = new Double(42.0);
    opens[38]  = new Double(53.0);
    closes[38] = new Double(54.0);

    dates[39]  = createDate(1999, Calendar.FEBRUARY,13);
    highs[39]  = new Double(49.0);
    lows[39]   = new Double(42.0);
    opens[39]  = new Double(45.0);
    closes[39] = new Double(42.0);

    dates[40]  = createDate(1999, Calendar.FEBRUARY,14);
    highs[40]  = new Double(55.0);
    lows[40]   = new Double(42.0);
    opens[40]  = new Double(47.0);
    closes[40] = new Double(54.0);

     dates[41]  = createDate(1999, Calendar.FEBRUARY,15);
    highs[41]  = new Double(49.0);
    lows[41]   = new Double(35.0);
    opens[41]  = new Double(38.0);
    closes[41] = new Double(35.0);

    dates[42]  = createDate(1999, Calendar.FEBRUARY,16);
    highs[42]  = new Double(47.0);
    lows[42]   = new Double(38.0);
    opens[42]  = new Double(43.0);
    closes[42] = new Double(42.0);

    dates[43]  = createDate(1999, Calendar.FEBRUARY,17);
    highs[43]  = new Double(53.0);
    lows[43]   = new Double(42.0);
    opens[43]  = new Double(47.0);
    closes[43] = new Double(48.0);

    dates[44]  = createDate(1999, Calendar.FEBRUARY,18);
    highs[44]  = new Double(47.0);
    lows[44]   = new Double(44.0);
    opens[44]  = new Double(46.0);
    closes[44] = new Double(44.0);

    dates[45]  = createDate(1999, Calendar.FEBRUARY,19);
    highs[45]  = new Double(46.0);
    lows[45]   = new Double(40.0);
    opens[45]  = new Double(43.0);
    closes[45] = new Double(44.0);

    dates[46]  = createDate(1999, Calendar.FEBRUARY,20);
    highs[46]  = new Double(48.0);
    lows[46]   = new Double(41.0);
    opens[46]  = new Double(46.0);
    closes[46] = new Double(41.0);
###
3146, getHighValue, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 93, 97
6
/**
   * Returns the high-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The high-value for the specified series and item.
   */
5
  public Number getHighValue(int series, int item) {
    if (series==0) {
      return highs[item];
    }
    else return null;
###
3147, getItemCount, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 164, 165
5
/**
   * Returns the number of items in the specified series.
   * @param series The index (zero-based) of the series;
   * @return The number of items in the specified series.
   */
2
  public int getItemCount(int series) {
    return 47;  // one series with 47 items in this sample
###
3148, getSeriesCount, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 143, 144
4
/**
   * Returns the number of series in the data source, ONE in this sample.
   * @return The number of series in the data source.
   */
2
  public int getSeriesCount() {
    return 1;
###
3149, getYValue, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 80, 84
6
/**
   * Returns the y-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The y-value for the specified series and item.
   */
5
  public Number getYValue(int series, int item) {
    if (series==0) {
      return closes[item];
    }
    else return null;
###
3150, getSeriesName, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 152, 156
5
/**
   * Returns the name of the series.
   * @param series The index (zero-based) of the series;
   * @return The name of the series.
   */
5
  public String getSeriesName(int series) {
    if (series==0) {
      return "IBM";
    }
    else return "Error";
###
3151, getLowValue, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 106, 110
6
/**
   * Returns the low-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The low-value for the specified series and item.
   */
5
  public Number getLowValue(int series, int item) {
    if (series==0) {
      return lows[item];
    }
    else return null;
###
3152, getXValue, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 70, 71
6
/**
   * Returns the x-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The x-value for the specified series and item.
   */
2
  public Number getXValue(int series, int item) {
    return new Long(dates[item].getTime());
###
3153, SampleHighLowDataset, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 60, 61
3
/**
   * Default constructor.
   */
2
  public SampleHighLowDataset() {
    this.initialiseData();
###
3154, getCloseValue, SampleHighLowDataset, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 132, 136
6
/**
   * Returns the close-value for the specified series and item.  Series are numbered 0, 1, ...
   * @param series The index (zero-based) of the series;
   * @param item The index (zero-based) of the required item;
   * @return The close-value for the specified series and item.
   */
5
  public Number getCloseValue(int series, int item) {
    if (series==0) {
      return closes[item];
    }
    else return null;
###
3155, setPeriod, MovingAveragePlotFitAlgorithm, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/MovingAveragePlotFitAlgorithm.java, 66, 67
4
/**
   * Sets the period for this moving average algorithm.
   * @param period The number of points to include in the average.
   */
2
  public void setPeriod(int period) {
    this.period = period;
###
3156, actionPerformed, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 292, 309
4
/**
   * Handles user interaction with the property panel.
   * @param event Information about the event that triggered the call to this method.
   */
18
  public void actionPerformed(ActionEvent event) {
    String command = event.getActionCommand();
    if (command.equals("SelectLabelFont")) {
      attemptLabelFontSelection();
    }
    else if (command.equals("SelectLabelPaint")) {
      attemptModifyLabelPaint();
    }
    else if (command.equals("SelectTickLabelFont")) {
      attemptTickLabelFontSelection();
    }
    else if (command.equals("LabelInsets"))
    {
      editLabelInsets();
    }
    else if (command.equals("TickLabelInsets"))
    {
      editTickLabelInsets();
###
3157, getName, MovingAveragePlotFitAlgorithm, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/MovingAveragePlotFitAlgorithm.java, 58, 59
3
/**
   * @return the name that you want to see in the legend.
   */
2
  public String getName() {
    return "Moving Average";
###
3158, isTickLabelsVisible, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 241, 242
3
/**
   * Returns a flag that indicates whether or not the tick labels are visible.
   */
2
  public boolean isTickLabelsVisible() {
    return showTickLabelsCheckBox.isSelected();
###
3159, attemptTickLabelFontSelection, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 343, 351
3
/**
   * Presents a tick label font selection dialog to the user.
   */
9
  public void attemptTickLabelFontSelection() {

    FontChooserPanel panel = new FontChooserPanel(tickLabelFont);
    int result = JOptionPane.showConfirmDialog(this, panel, "Font Selection",
      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {
      tickLabelFont = panel.getSelectedFont();
      tickLabelFontField.setText(tickLabelFont.getFontName()+" "+tickLabelFont.getSize());
###
3160, getLabelFont, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 227, 228
3
/**
   * Returns the current label font.
   */
2
  public Font getLabelFont() {
    return labelFont;
###
3161, setXYDataset, MovingAveragePlotFitAlgorithm, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/MovingAveragePlotFitAlgorithm.java, 73, 101
3
/**
   * @param ds The underlying XYDataset.
   */
29
  public void setXYDataset(XYDataset ds) {

    this.dataset = ds;

    /*
     * build the x and y data arrays to be passed to the
     * statistics class to get a linear fit and store them
     * for each dataset in the datasets Vector
     */
    Vector datasets = new Vector();
    for(int i = 0; i < ds.getSeriesCount(); i++) {
      int seriessize = ds.getItemCount(i);
      Number[] x_data = new Number[seriessize];
      Number[] y_data = new Number[seriessize];
      for(int j = 0; j < seriessize; j++) {
        x_data[j] = ds.getXValue(i,j);
        y_data[j] = ds.getYValue(i,j);
      }
      Vector pair = new Vector();
      pair.addElement(x_data);
      pair.addElement(y_data);
      datasets.addElement(pair);
    }
    plots = new Vector();
    for(int j = 0; j < datasets.size(); j++) {
      Vector pair = (Vector)datasets.elementAt(j);
      Number[] x_data = (Number[])pair.elementAt(0);
      Number[] y_data = (Number[])pair.elementAt(1);
      plots.addElement(new ArrayHolder(Statistics.getMovingAverage(x_data, y_data, period)));
###
3162, editTickLabelInsets, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 361, 369
5
/**
   * Presents insets chooser panel allowing user to modify tick label's
   * individual insets values. Updates the current insets text field if edit
   * is accepted.
   */
9
  private void editTickLabelInsets() {
    InsetsChooserPanel panel = new InsetsChooserPanel(_tickLabelInsets);
    int result =
      JOptionPane.showConfirmDialog(this, panel, "Edit Insets",
                      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {
      _tickLabelInsets = panel.getInsets();
      tickLabelInsetsTextField.setInsets(_tickLabelInsets);
###
3163, getY, MovingAveragePlotFitAlgorithm, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/data/MovingAveragePlotFitAlgorithm.java, 112, 127
6
/**
   * Returns the y-value for any x-value.
   * @param x The x-value.
   * @param series The series.
   * @return The y-value
   */
16
  public Number getY(int series, Number x) {

    /*
     * for a moving average, this returns a number if there is a match
     * for that y and series, otherwise, it returns a null reference
     */
    double[][] mavg = ((ArrayHolder)plots.elementAt(series)).getArray();
    for(int j = 0; j < mavg.length; j++) {

      /* if the x matches up, we have a moving average point for this x */
      if(mavg[j][0] == x.doubleValue()) {
        return new Double(mavg[j][1]);
      }
    }
    /* if we don't return null */
    return null;
###
3164, getOtherTabs, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 284, 285
3
/**
   * Returns a reference to the tabbed pane.
   */
2
  public JTabbedPane getOtherTabs() {
    return otherTabs;
###
3165, getTickLabelInsets, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 270, 271
3
/**
   * Returns the current tick label insets value
   */
2
  public Insets getTickLabelInsets() {
    return (_tickLabelInsets == null) ? new Insets(0,0,0,0) : _tickLabelInsets;
###
3166, attemptLabelFontSelection, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 316, 324
3
/**
   * Presents a font selection dialog to the user.
   */
9
  private void attemptLabelFontSelection() {

    FontChooserPanel panel = new FontChooserPanel(labelFont);
    int result = JOptionPane.showConfirmDialog(this, panel, "Font Selection",
      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {
      labelFont = panel.getSelectedFont();
      labelFontField.setText(labelFont.getFontName()+" "+labelFont.getSize());
###
3167, getInstance, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 98, 107
4
/**
   * A static method that returns a panel that is appropriate for the axis type.
   * @param axis The axis whose properties are to be displayed/edited in the panel;
   */
10
  public static AxisPropertyEditPanel getInstance(Axis axis) {

    if (axis!=null) {
      // figure out what type of axis we have and instantiate the appropriate panel
      if (axis instanceof NumberAxis) {
        return new NumberAxisPropertyEditPanel((NumberAxis)axis);
      }
      else return new AxisPropertyEditPanel(axis);
    }
    else return null;
###
3168, getLabelInsets, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 277, 278
3
/**
   * Returns the current label insets value
   */
2
  public Insets getLabelInsets() {
    return (_labelInsets == null) ? new Insets(0,0,0,0) : _labelInsets;
###
3169, setAxisProperties, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 393, 403
3
/**
   * Sets the properties of the specified axis to match the properties defined on this panel.
   */
11
  public void setAxisProperties(Axis axis) {
    axis.setLabel(this.getLabel());
    axis.setLabelFont(this.getLabelFont());
    axis.setLabelPaint(this.getLabelPaint());
    axis.setTickMarksVisible(this.isTickMarksVisible());
    // axis.setTickMarkStroke(this.getTickMarkStroke());
    axis.setTickLabelsVisible(this.isTickLabelsVisible());
    axis.setTickLabelFont(this.getTickLabelFont());
    axis.setTickLabelPaint(this.getTickLabelPaint());
    axis.setTickLabelInsets(this.getTickLabelInsets());
    axis.setLabelInsets(this.getLabelInsets());
###
3170, getTickLabelFont, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 248, 249
3
/**
   * Returns the font used to draw the tick labels (if they are showing).
   */
2
  public Font getTickLabelFont() {
    return tickLabelFont;
###
3171, isTickMarksVisible, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 263, 264
4
/**
   * Returns the current value of the flag that determines whether or not tick marks are
   * visible.
   */
2
  public boolean isTickMarksVisible() {
    return showTickMarksCheckBox.isSelected();
###
3172, getLabel, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 220, 221
3
/**
   * Returns the current axis label.
   */
2
  public String getLabel() {
    return label.getText();
###
3173, attemptModifyLabelPaint, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 332, 336
3
/**
   * Allows the user the opportunity to change the outline paint.
   */
5
  private void attemptModifyLabelPaint() {
    Color c;
    c = JColorChooser.showDialog(this, "Label Color", Color.blue);
    if (c!=null) {
      labelPaintSample.setPaint(c);
###
3174, getTickLabelPaint, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 255, 256
3
/**
   * Returns the current tick label paint.
   */
2
  public Paint getTickLabelPaint() {
    return tickLabelPaintSample.getPaint();
###
3175, getLabelPaint, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 234, 235
3
/**
   * Returns the current label paint.
   */
2
  public Paint getLabelPaint() {
    return labelPaintSample.getPaint();
###
3176, editLabelInsets, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 378, 386
5
/**
   * Presents insets chooser panel allowing user to modify label's
   * individual insets values. Updates the current insets text field if edit
   * is accepted.
   */
9
  private void editLabelInsets() {
    InsetsChooserPanel panel = new InsetsChooserPanel(_labelInsets);
    int result =
      JOptionPane.showConfirmDialog(this, panel, "Edit Insets",
                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {
      _labelInsets = panel.getInsets();
      labelInsetsTextField.setInsets(_labelInsets);
###
3177, AxisPropertyEditPanel, AxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 116, 213
5
/**
   * Standard constructor: builds a panel for displaying/editing the properties of the specified
   * axis.
   * @param axis The axis whose properties are to be displayed/edited in the panel;
   */
98
  public AxisPropertyEditPanel(Axis axis) {

    labelFont = axis.getLabelFont();
    labelPaintSample = new PaintSample(axis.getLabelPaint());
    tickLabelFont = axis.getTickLabelFont();
    tickLabelPaintSample = new PaintSample(axis.getTickLabelPaint());

    // Insets values
    _tickLabelInsets = axis.getTickLabelInsets();
    _labelInsets = axis.getLabelInsets();

    setLayout(new BorderLayout());

    JPanel general = new JPanel(new BorderLayout());
    general.setBorder(BorderFactory.createTitledBorder(
              BorderFactory.createEtchedBorder(), "General:"));

    JPanel interior = new JPanel(new LCBLayout(5));
    interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));
    interior.add(new JLabel("Label:"));
    label = new JTextField(axis.getLabel());
    interior.add(label);
    interior.add(new JPanel());

    interior.add(new JLabel("Font:"));
    labelFontField = new FontDisplayField(labelFont);
    interior.add(labelFontField);
    JButton b = new JButton("Select...");
    b.setActionCommand("SelectLabelFont");
    b.addActionListener(this);
    interior.add(b);

    interior.add(new JLabel("Paint:"));
    interior.add(labelPaintSample);
    b = new JButton("Select...");
    b.setActionCommand("SelectLabelPaint");
    b.addActionListener(this);
    interior.add(b);

    interior.add(new JLabel("Label Insets:"));
    b = new JButton("Edit...");
    b.setActionCommand("LabelInsets");
    b.addActionListener(this);
    labelInsetsTextField = new InsetsTextField(_labelInsets);
    interior.add(labelInsetsTextField);
    interior.add(b);

    interior.add(new JLabel("Tick Label Insets:"));
    b = new JButton("Edit...");
    b.setActionCommand("TickLabelInsets");
    b.addActionListener(this);
    tickLabelInsetsTextField = new InsetsTextField(_tickLabelInsets);
    interior.add(tickLabelInsetsTextField);
    interior.add(b);

    general.add(interior);

    add(general, BorderLayout.NORTH);

    slot1 = new JPanel(new BorderLayout());

    JPanel other = new JPanel(new BorderLayout());
    other.setBorder(BorderFactory.createTitledBorder(
               BorderFactory.createEtchedBorder(), "Other:"));

    otherTabs = new JTabbedPane();
    otherTabs.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    JPanel ticks = new JPanel(new LCBLayout(3));
    ticks.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

    showTickLabelsCheckBox = new JCheckBox("Show tick labels", axis.isTickLabelsVisible());
    ticks.add(showTickLabelsCheckBox);
    ticks.add(new JPanel());
    ticks.add(new JPanel());

    ticks.add(new JLabel("Tick label font:"));
    tickLabelFontField = new FontDisplayField(tickLabelFont);
    ticks.add(tickLabelFontField);
    b = new JButton("Select...");
    b.setActionCommand("SelectTickLabelFont");
    b.addActionListener(this);
    ticks.add(b);

    showTickMarksCheckBox = new JCheckBox("Show tick marks", axis.isTickMarksVisible());
    ticks.add(showTickMarksCheckBox);
    ticks.add(new JPanel());
    ticks.add(new JPanel());

    otherTabs.add("Ticks", ticks);

    other.add(otherTabs);

    slot1.add(other);

    slot2 = new JPanel(new BorderLayout());
    slot2.add(slot1, BorderLayout.NORTH);
    add(slot2);
###
3178, actionPerformed, NumberAxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 182, 199
3
/**
   * Handles actions from within the property panel.
   */
18
  public void actionPerformed(ActionEvent event) {
    String command = event.getActionCommand();
    if (command.equals("GridStroke")) {
      attemptGridStrokeSelection();
    }
    else if (command.equals("GridPaint")) {
      attemptGridPaintSelection();
    }
    else if (command.equals("AutoRangeOnOff")) {
      toggleAutoRange();
    }
    else if (command.equals("MinimumRange")) {
      validateMinimum();
    }
    else if (command.equals("MaximumRange")) {
      validateMaximum();
    }
    else super.actionPerformed(event);  // pass to the super-class for handling
###
3179, attemptGridPaintSelection, NumberAxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 218, 222
3
/**
   * Handle a grid paint selection.
   */
5
  private void attemptGridPaintSelection() {
    Color c;
    c = JColorChooser.showDialog(this, "Grid Color", Color.blue);
    if (c!=null) {
      gridPaintSample.setPaint(c);
###
3182, attemptGridStrokeSelection, NumberAxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 205, 211
3
/**
   * Handle a grid stroke selection.
   */
7
  private void attemptGridStrokeSelection() {
    StrokeChooserPanel panel = new StrokeChooserPanel(null, availableStrokeSamples);
    int result = JOptionPane.showConfirmDialog(this, panel, "Stroke Selection",
      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {
      gridStrokeSample.setStroke(panel.getSelectedStroke());
###
3184, isAutoRange, NumberAxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 161, 162
3
/**
   * Returns the current setting of the auto-range property.
   */
2
  public boolean isAutoRange() {
    return autoRange;
###
3185, getMinimumValue, NumberAxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 168, 169
3
/**
   * Returns the current setting of the minimum value in the axis range.
   */
2
  public Number getMinimumValue() {
    return minimumValue;
###
3187, NumberAxisPropertyEditPanel, NumberAxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 84, 154
3
/**
   * Standard constructor: builds a property panel for the specified axis.
   */
71
  public NumberAxisPropertyEditPanel(NumberAxis axis) {

    super(axis);

    autoRange = axis.isAutoRange();
    minimumValue = axis.getMinimumAxisValue();
    maximumValue = axis.getMaximumAxisValue();

    gridPaintSample = new PaintSample(axis.getGridPaint());
    gridStrokeSample = new StrokeSample(axis.getGridStroke());

    availableStrokeSamples = new StrokeSample[3];
    availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));
    availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));
    availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));

    JTabbedPane other = getOtherTabs();

    JPanel range = new JPanel(new LCBLayout(3));
    range.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));

    range.add(new JPanel());
    autoRangeCheckBox = new JCheckBox("Auto-adjust range:", autoRange);
    autoRangeCheckBox.setActionCommand("AutoRangeOnOff");
    autoRangeCheckBox.addActionListener(this);
    range.add(autoRangeCheckBox);
    range.add(new JPanel());

    range.add(new JLabel("Minimum range value:"));
    minimumRangeValue = new JTextField(minimumValue.toString());
    minimumRangeValue.setEnabled(!autoRange);
    minimumRangeValue.setActionCommand("MinimumRange");
    minimumRangeValue.addActionListener(this);
    minimumRangeValue.addFocusListener(this);
    range.add(minimumRangeValue);
    range.add(new JPanel());

    range.add(new JLabel("Maximum range value:"));
    maximumRangeValue = new JTextField(maximumValue.toString());
    maximumRangeValue.setEnabled(!autoRange);
    maximumRangeValue.setActionCommand("MaximumRange");
    maximumRangeValue.addActionListener(this);
    maximumRangeValue.addFocusListener(this);
    range.add(maximumRangeValue);
    range.add(new JPanel());

    other.add("Range", range);

    JPanel grid = new JPanel(new LCBLayout(3));
    grid.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));

    grid.add(new JPanel());
    showGridLinesCheckBox = new JCheckBox("Show grid lines", axis.isShowGridLines());
    grid.add(showGridLinesCheckBox);
    grid.add(new JPanel());

    grid.add(new JLabel("Grid stroke:"));
    JButton button = new JButton("Set stroke...");
    button.setActionCommand("GridStroke");
    button.addActionListener(this);
    grid.add(gridStrokeSample);
    grid.add(button);

    grid.add(new JLabel("Grid paint:"));
    button = new JButton("Set paint...");
    button.setActionCommand("GridPaint");
    button.addActionListener(this);
    grid.add(gridPaintSample);
    grid.add(button);

    other.add("Grid", grid);
###
3189, getMaximumValue, NumberAxisPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 175, 176
3
/**
   * Returns the current setting of the maximum value in the axis range.
   */
2
  public Number getMaximumValue() {
    return maximumValue;
###
3190, attemptModifySeriesPaint, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 246, 250
3
/**
   * Allows the user the opportunity to change the series label paint.
   */
5
  private void attemptModifySeriesPaint() {
    Color c;
    c = JColorChooser.showDialog(this, "Series Label Color", Color.blue);
    if (c!=null) {
      seriesPaint.setPaint(c);
###
3191, LegendPropertyEditPanel, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 71, 132
3
/**
   * Standard constructor: builds a panel based on the specified legend.
   */
62
  public LegendPropertyEditPanel(Legend legend) {

    StandardLegend l = (StandardLegend)legend;
    outlineStroke = new StrokeSample(l.getOutlineStroke());
    outlinePaint = new PaintSample(l.getOutlinePaint());
    backgroundPaint = new PaintSample(l.getBackgroundPaint());
    seriesFont = l.getSeriesFont();
    seriesPaint = new PaintSample(l.getSeriesPaint());

    availableStrokeSamples = new StrokeSample[4];
    availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));
    availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));
    availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));
    availableStrokeSamples[3] = new StrokeSample(new BasicStroke(4.0f));

    setLayout(new BorderLayout());

    JPanel general = new JPanel(new BorderLayout());
    general.setBorder(BorderFactory.createTitledBorder(
                BorderFactory.createEtchedBorder(), "General:"));

    JPanel interior = new JPanel(new LCBLayout(5));
    interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));
    JLabel titleLabel = new JLabel("Text:");

    interior.add(new JLabel("Outline:"));
    interior.add(outlineStroke);
    JButton button = new JButton("Select...");
    button.setActionCommand("OutlineStroke");
    button.addActionListener(this);
    interior.add(button);

    interior.add(new JLabel("Outline Paint:"));
    button = new JButton("Select...");
    button.setActionCommand("OutlinePaint");
    button.addActionListener(this);
    interior.add(outlinePaint);
    interior.add(button);

    interior.add(new JLabel("Background:"));
    button = new JButton("Select...");
    button.setActionCommand("BackgroundPaint");
    button.addActionListener(this);
    interior.add(backgroundPaint);
    interior.add(button);

    interior.add(new JLabel("Series label font:"));
    button = new JButton("Select...");
    button.setActionCommand("SeriesFont");
    button.addActionListener(this);
    interior.add(new FontDisplayField(seriesFont));
    interior.add(button);

    interior.add(new JLabel("Series label paint:")) ;
    button = new JButton("Select...");
    button.setActionCommand("SeriesPaint");
    button.addActionListener(this);
    interior.add(seriesPaint) ;
    interior.add(button) ;

    general.add(interior);
    add(general, BorderLayout.NORTH);
###
3192, getSeriesFont, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 159, 160
3
/**
   * Returns the current series label font.
   */
2
  public Font getSeriesFont() {
    return seriesFont;
###
3193, attemptModifySeriesFont, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 230, 237
3
/**
   * Allows the user the opportunity to change the series label font.
   */
8
  public void attemptModifySeriesFont() {

    FontChooserPanel panel = new FontChooserPanel(seriesFont);
    int result = JOptionPane.showConfirmDialog(this, panel, "Font Selection",
      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {
      seriesFont = panel.getSelectedFont();
###
3194, attemptModifyBackgroundPaint, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 219, 223
3
/**
   * Allows the user the opportunity to change the background paint.
   */
5
  private void attemptModifyBackgroundPaint() {
    Color c;
    c = JColorChooser.showDialog(this, "Background Color", Color.blue);
    if (c!=null) {
      backgroundPaint.setPaint(c);
###
3195, getSeriesPaint, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 166, 167
3
/**
   * Returns the current series label paint.
   */
2
  public Paint getSeriesPaint() {
    return seriesPaint.getPaint();
###
3196, attemptModifyOutlineStroke, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 195, 201
3
/**
   * Allows the user the opportunity to change the outline stroke.
   */
7
  private void attemptModifyOutlineStroke() {
    StrokeChooserPanel panel = new StrokeChooserPanel(outlineStroke, availableStrokeSamples);
    int result = JOptionPane.showConfirmDialog(this, panel, "Pen/Stroke Selection",
      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {
      outlineStroke.setStroke(panel.getSelectedStroke());
###
3197, actionPerformed, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 173, 188
3
/**
   * Handles user interactions with the panel.
   */
16
  public void actionPerformed(ActionEvent event) {
    String command = event.getActionCommand();
    if (command.equals("OutlineStroke")) {
      attemptModifyOutlineStroke();
    }
    else if (command.equals("OutlinePaint")) {
      attemptModifyOutlinePaint();
    }
    else if (command.equals("BackgroundPaint")) {
      attemptModifyBackgroundPaint();
    }
    else if (command.equals("SeriesFont")) {
      attemptModifySeriesFont();
    }
    else if (command.equals("SeriesPaint")) {
      attemptModifySeriesPaint();
###
3198, getBackgroundPaint, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 152, 153
3
/**
   * Returns the current background paint.
   */
2
  public Paint getBackgroundPaint() {
    return backgroundPaint.getPaint();
###
3199, getOutlinePaint, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 145, 146
3
/**
   * Returns the current outline paint.
   */
2
  public Paint getOutlinePaint() {
    return outlinePaint.getPaint();
###
3200, getOutlineStroke, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 138, 139
3
/**
   * Returns the current outline stroke.
   */
2
  public Stroke getOutlineStroke() {
    return outlineStroke.getStroke();
###
3201, setLegendProperties, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 257, 264
3
/**
   * Sets the properties of the specified legend to match the properties defined on this panel.
   */
8
  public void setLegendProperties(Legend legend) {
    if (legend instanceof StandardLegend) {  // only supports StandardLegend at present
      StandardLegend standard = (StandardLegend)legend;
      standard.setOutlineStroke(this.getOutlineStroke());
      standard.setOutlinePaint(this.getOutlinePaint());
      standard.setBackgroundPaint(this.getBackgroundPaint());
      standard.setSeriesFont(this.getSeriesFont());
      standard.setSeriesPaint(this.getSeriesPaint());
###
3202, attemptModifyOutlinePaint, LegendPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 208, 212
3
/**
   * Allows the user the opportunity to change the outline paint.
   */
5
  private void attemptModifyOutlinePaint() {
    Color c;
    c = JColorChooser.showDialog(this, "Outline Color", Color.blue);
    if (c!=null) {
      outlinePaint.setPaint(c);
###
3203, updatePlotProperties, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 282, 296
4
/**
   * Updates the plot properties to match the properties defined on the panel.
   * @param plot The plot.
   */
15
  public void updatePlotProperties(Plot plot) {

    // set the plot properties...
    plot.setOutlinePaint(this.getOutlinePaint());
    plot.setOutlineStroke(this.getOutlineStroke());
    plot.setBackgroundPaint(this.getBackgroundPaint());
    plot.setInsets(this.getPlotInsets());

    // then the axis properties...
    if (this.horizontalAxisPropertyPanel!=null) {
      this.horizontalAxisPropertyPanel.setAxisProperties(plot.getAxis(Plot.HORIZONTAL_AXIS));
    }

    if (this.verticalAxisPropertyPanel!=null) {
      this.verticalAxisPropertyPanel.setAxisProperties(plot.getAxis(Plot.VERTICAL_AXIS));
###
3204, editInsets, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 265, 273
3
/**
   * Allow the user to edit the individual insets' values.
   */
9
  private void editInsets() {
    InsetsChooserPanel panel = new InsetsChooserPanel(_insets);
    int result =
      JOptionPane.showConfirmDialog(this, panel, "Edit Insets",
                      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {
      _insets = panel.getInsets();
      insetsTextField.setInsets(_insets);
###
3205, attemptOutlinePaintSelection, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 254, 258
4
/**
   * Allow the user to change the outline paint.  We use JColorChooser, so the user can only
   * choose colors (a subset of all possible paints).
   */
5
  private void attemptOutlinePaintSelection() {
    Color c;
    c = JColorChooser.showDialog(this, "Outline Color", Color.blue);
    if (c!=null) {
      outlinePaintSample.setPaint(c);
###
3206, getOutlineStroke, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 181, 182
3
/**
   * Returns the current outline stroke.
   */
2
  public Stroke getOutlineStroke() {
    return outlineStrokeSample.getStroke();
###
3207, getHorizontalAxisPropertyEditPanel, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 202, 203
3
/**
   * Returns a reference to the panel for editing the properties of the horizontal axis.
   */
2
  public AxisPropertyEditPanel getHorizontalAxisPropertyEditPanel() {
    return horizontalAxisPropertyPanel;
###
3208, getBackgroundPaint, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 174, 175
3
/**
   * Returns the current background paint.
   */
2
  public Paint getBackgroundPaint() {
    return backgroundPaintSample.getPaint();
###
3209, PlotPropertyEditPanel, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 80, 159
7
/**
   * Standard constructor - constructs a panel for editing the properties of the specified plot.
   * <P>
   * In designing the panel, we need to be aware that subclasses of Plot will need to implement
   * subclasses of PlotPropertyEditPanel - so we need to leave one or two 'slots' where the
   * subclasses can extend the user interface.
   */
80
  public PlotPropertyEditPanel(Plot plot) {

    _insets = plot.getInsets();
    backgroundPaintSample = new PaintSample(plot.getBackgroundPaint());
    outlineStrokeSample = new StrokeSample(plot.getOutlineStroke());
    outlinePaintSample = new PaintSample(plot.getOutlinePaint());

    setLayout(new BorderLayout());

    availableStrokeSamples = new StrokeSample[3];
    availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));
    availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));
    availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));

    // create a panel for the settings...
    JPanel panel = new JPanel(new BorderLayout());
    panel.setBorder(BorderFactory.createTitledBorder(
              BorderFactory.createEtchedBorder(), plot.getPlotType()+":"));

    JPanel general = new JPanel(new BorderLayout());
    general.setBorder(BorderFactory.createTitledBorder(
                BorderFactory.createEtchedBorder(), "General:"));

    JPanel interior = new JPanel(new LCBLayout(4));
    interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    interior.add(new JLabel("Insets:"));
    JButton button = new JButton("Edit...");
    button.setActionCommand("Insets");
    button.addActionListener(this);

    insetsTextField = new InsetsTextField(_insets);
    insetsTextField.setEnabled(false);
    interior.add(insetsTextField);
    interior.add(button);

    interior.add(new JLabel("Outline stroke:"));
    button = new JButton("Select...");
    button.setActionCommand("OutlineStroke");
    button.addActionListener(this);
    interior.add(outlineStrokeSample);
    interior.add(button);

    interior.add(new JLabel("Outline paint:"));
    button = new JButton("Select...");
    button.setActionCommand("OutlinePaint");
    button.addActionListener(this);
    interior.add(outlinePaintSample);
    interior.add(button);

    interior.add(new JLabel("Background paint:"));
    button = new JButton("Select...");
    button.setActionCommand("BackgroundPaint");
    button.addActionListener(this);
    interior.add(backgroundPaintSample);
    interior.add(button);

    general.add(interior, BorderLayout.NORTH);

    JPanel appearance = new JPanel(new BorderLayout());
    appearance.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
    appearance.add(general, BorderLayout.NORTH);

    JTabbedPane tabs = new JTabbedPane();
    tabs.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    verticalAxisPropertyPanel = AxisPropertyEditPanel.getInstance(plot.getAxis(Plot.VERTICAL_AXIS));
    if (verticalAxisPropertyPanel!=null) {
      verticalAxisPropertyPanel.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));
      tabs.add("Vertical Axis", verticalAxisPropertyPanel);
    }
    horizontalAxisPropertyPanel = AxisPropertyEditPanel.getInstance(plot.getAxis(Plot.HORIZONTAL_AXIS));
    if (horizontalAxisPropertyPanel!=null) {
      horizontalAxisPropertyPanel.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));
      tabs.add("Horizontal Axis", horizontalAxisPropertyPanel);
    }
    tabs.add("Appearance", appearance);
    panel.add(tabs);

    add(panel);
###
3210, getVerticalAxisPropertyEditPanel, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 195, 196
3
/**
   * Returns a reference to the panel for editing the properties of the vertical axis.
   */
2
  public AxisPropertyEditPanel getVerticalAxisPropertyEditPanel() {
    return verticalAxisPropertyPanel;
###
3211, actionPerformed, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 209, 221
3
/**
   * Handles user actions generated within the panel.
   */
13
  public void actionPerformed(ActionEvent event) {
    String command = event.getActionCommand();
    if (command.equals("BackgroundPaint")) {
      attemptBackgroundPaintSelection();
    }
    else if (command.equals("OutlineStroke")) {
      attemptOutlineStrokeSelection();
    }
    else if (command.equals("OutlinePaint")) {
      attemptOutlinePaintSelection();
    }
    else if (command.equals("Insets")) {
      editInsets();
###
3212, getOutlinePaint, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 188, 189
3
/**
   * Returns the current outline paint.
   */
2
  public Paint getOutlinePaint() {
    return outlinePaintSample.getPaint();
###
3213, getPlotInsets, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 165, 168
3
/**
   * Returns the current plot insets.
   */
4
  public Insets getPlotInsets() {
    if (_insets == null)
      _insets = new Insets(0,0,0,0);
    return _insets;
###
3214, attemptOutlineStrokeSelection, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 240, 246
3
/**
   * Allow the user to change the outline stroke.
   */
7
  private void attemptOutlineStrokeSelection() {
    StrokeChooserPanel panel = new StrokeChooserPanel(null, availableStrokeSamples);
    int result = JOptionPane.showConfirmDialog(this, panel, "Stroke Selection",
      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {
      outlineStrokeSample.setStroke(panel.getSelectedStroke());
###
3215, attemptBackgroundPaintSelection, PlotPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 229, 233
3
/**
   * Allow the user to change the background paint.
   */
5
  private void attemptBackgroundPaintSelection() {
    Color c;
    c = JColorChooser.showDialog(this, "Background Color", Color.blue);
    if (c!=null) {
      backgroundPaintSample.setPaint(c);
###
3216, getLegendPropertyEditPanel, ChartPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 170, 171
3
/**
   * Returns a reference to the legend property sub-panel.
   */
2
  public LegendPropertyEditPanel getLegendPropertyEditPanel() {
    return legendPropertiesPanel;
###
3217, getAntiAlias, ChartPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 184, 185
3
/**
   * Returns the current setting of the anti-alias flag.
   */
2
  public boolean getAntiAlias() {
    return antialias.isSelected();
###
3218, ChartPropertyEditPanel, ChartPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 71, 157
4
/**
   * Standard constructor - the property panel is made up of a number of sub-panels that are
   * displayed in the tabbed pane.
   */
87
  public ChartPropertyEditPanel(JFreeChart chart) {
    setLayout(new BorderLayout());

    JPanel other = new JPanel(new BorderLayout());
    other.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

    JPanel general = new JPanel(new BorderLayout());
    general.setBorder(BorderFactory.createTitledBorder(
                BorderFactory.createEtchedBorder(), "General:"));

    JPanel interior = new JPanel(new LCBLayout(6));
    interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    antialias = new JCheckBox("Draw anti-aliased");
    antialias.setSelected(chart.getAntiAlias());
    interior.add(antialias);
    interior.add(new JLabel(""));
    interior.add(new JLabel(""));
    interior.add(new JLabel("Background paint:"));
    background = new PaintSample(chart.getChartBackgroundPaint());
    interior.add(background);
    JButton button = new JButton("Select...");
    button.setActionCommand("BackgroundPaint");
    button.addActionListener(this);
    interior.add(button);

    interior.add(new JLabel("Series Paint:"));
    JTextField info = new JTextField("No editor implemented");
    info.setEnabled(false);
    interior.add(info);
    button = new JButton("Edit...");
    button.setEnabled(false);
    interior.add(button);

    interior.add(new JLabel("Series Stroke:"));
    info = new JTextField("No editor implemented");
    info.setEnabled(false);
    interior.add(info);
    button = new JButton("Edit...");
    button.setEnabled(false);
    interior.add(button);

    interior.add(new JLabel("Series Outline Paint:"));
    info = new JTextField("No editor implemented");
    info.setEnabled(false);
    interior.add(info);
    button = new JButton("Edit...");
    button.setEnabled(false);
    interior.add(button);

    interior.add(new JLabel("Series Outline Stroke:"));
    info = new JTextField("No editor implemented");
    info.setEnabled(false);
    interior.add(info);
    button = new JButton("Edit...");
    button.setEnabled(false);
    interior.add(button);

    general.add(interior, BorderLayout.NORTH);
    other.add(general, BorderLayout.NORTH);

    JPanel parts = new JPanel(new BorderLayout());

    //Title title = chart.getTitle();
    Legend legend = chart.getLegend();
    Plot plot = chart.getPlot();

    JTabbedPane tabs = new JTabbedPane();

    //StandardTitle t = (StandardTitle)title;
    //titlePropertiesPanel = new TitlePropertyEditPanel(t);
    //titlePropertiesPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
    //tabs.addTab("Title", titlePropertiesPanel);

    if (legend!=null) {
      legendPropertiesPanel = new LegendPropertyEditPanel(legend);
      legendPropertiesPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
      tabs.addTab("Legend", legendPropertiesPanel);
    }

    plotPropertiesPanel = new PlotPropertyEditPanel(plot);
    plotPropertiesPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
    tabs.addTab("Plot", plotPropertiesPanel);

    tabs.add("Other", other);
    parts.add(tabs, BorderLayout.NORTH);
    add(parts);
###
3219, actionPerformed, ChartPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 198, 201
3
/**
   * Handles user interactions with the panel.
   */
4
  public void actionPerformed(ActionEvent event) {
    String command = event.getActionCommand();
    if (command.equals("BackgroundPaint")) {
      attemptModifyBackgroundPaint();
###
3220, getBackgroundPaint, ChartPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 191, 192
3
/**
   * Returns the current background paint.
   */
2
  public Paint getBackgroundPaint() {
    return background.getPaint();
###
3221, attemptModifyBackgroundPaint, ChartPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 209, 213
4
/**
   * Allows the user the opportunity to select a new background paint.  Uses JColorChooser,
   * so we are only allowing a subset of all Paint objects to be selected (fix later).
   */
5
  private void attemptModifyBackgroundPaint() {
    Color c;
    c = JColorChooser.showDialog(this, "Background Color", Color.blue);
    if (c!=null) {
      background.setPaint(c);
###
3222, getTitlePropertyEditPanel, ChartPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 163, 164
3
/**
   * Returns a reference to the title property sub-panel.
   */
2
  public TitlePropertyEditPanel getTitlePropertyEditPanel() {
    return titlePropertiesPanel;
###
3223, getPlotPropertyEditPanel, ChartPropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 177, 178
3
/**
   * Returns a reference to the plot property sub-panel.
   */
2
  public PlotPropertyEditPanel getPlotPropertyEditPanel() {
    return plotPropertiesPanel;
###
3224, actionPerformed, TitlePropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 132, 140
3
/**
   * Handles button clicks by passing control to an appropriate handler method.
   */
9
  public void actionPerformed(ActionEvent event) {

    String command = event.getActionCommand();

    if (command.equals("SelectFont")) {
      attemptFontSelection();
    }
    else if (command.equals("SelectPaint")) {
      attemptPaintSelection();
###
3225, getTitlePaint, TitlePropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 125, 126
3
/**
   * Returns the paint selected in the panel.
   */
2
  public Paint getTitlePaint() {
    return titlePaint.getPaint();
###
3226, attemptFontSelection, TitlePropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 148, 156
3
/**
   * Presents a font selection dialog to the user.
   */
9
  public void attemptFontSelection() {

    FontChooserPanel panel = new FontChooserPanel(titleFont);
    int result = JOptionPane.showConfirmDialog(this, panel, "Font Selection",
      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {
      titleFont = panel.getSelectedFont();
      fontfield.setText(titleFont.getFontName()+" "+titleFont.getSize());
###
3227, setTitleProperties, TitlePropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 176, 181
3
/**
   * Sets the properties of the specified title to match the properties defined on this panel.
   */
6
  public void setTitleProperties(Title title) {
    if (title instanceof StandardTitle) {  // only supports StandardTitle at present
      StandardTitle standard = (StandardTitle)title;
      standard.setTitle(this.getTitle());
      standard.setTitleFont(this.getTitleFont());
      standard.setTitlePaint(this.getTitlePaint());
###
3228, getTitle, TitlePropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 111, 112
3
/**
   * Returns the title entered in the panel.
   */
2
  public String getTitle() {
    return titleField.getText();
###
3229, getTitleFont, TitlePropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 118, 119
3
/**
   * Returns the font selected in the panel.
   */
2
  public Font getTitleFont() {
    return titleFont;
###
3230, attemptPaintSelection, TitlePropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 166, 169
5
/**
   * Allow the user the opportunity to select a Paint object.  For now, we just use the
   * standard color chooser - all colors are Paint objects, but not all Paint objects are
   * colors (later we can implement a more general Paint chooser).
   */
4
  public void attemptPaintSelection() {
    Color c = JColorChooser.showDialog(this, "Title Color", Color.blue);
    if (c!=null) {
      titlePaint.setPaint(c);
###
3231, TitlePropertyEditPanel, TitlePropertyEditPanel, JFreeChart060
jfreechart-0.6.0/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 66, 105
4
/**
   * Standard constructor: builds a panel for displaying/editing the properties of the specified
   * title.
   */
40
  public TitlePropertyEditPanel(StandardTitle title) {

    // initialise local selections
    titleFont = title.getTitleFont();
    titlePaint = new PaintSample(title.getTitlePaint());

    setLayout(new BorderLayout());

    JPanel general = new JPanel(new BorderLayout());
    general.setBorder(BorderFactory.createTitledBorder(
              BorderFactory.createEtchedBorder(), "General:"));

    JPanel interior = new JPanel(new LCBLayout(3));
    interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));
    JLabel titleLabel = new JLabel("Text:");
    titleField = new JTextField(title.getTitle());
    interior.add(titleLabel);
    interior.add(titleField);
    interior.add(new JPanel());
    interior.add(new JLabel("Font:"));

    fontfield = new FontDisplayField(titleFont);
    JButton b = new JButton("Select...");
    b.setActionCommand("SelectFont");
    b.addActionListener(this);

    interior.add(fontfield);
    interior.add(b);

    interior.add(new JLabel("Color:"));

    titlePaint = new PaintSample(title.getTitlePaint());
    b = new JButton("Select...");
    b.setActionCommand("SelectPaint");
    b.addActionListener(this);
    interior.add(titlePaint);
    interior.add(b);

    general.add(interior);
    add(general, BorderLayout.NORTH);
###
3232, HighLow, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 79, 80
11
/**

   * Constructs a high-low item, with default values for the open/close and colors.

   * @param x

   * @param high

   * @param low

   */
4
  public HighLow(double x, double high, double low) {

  this(x, high, low, high, low, new BasicStroke(), Color.blue);

###
3233, setValue, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 154, 158
9
/**

   * Sets either OPEN or Close value depending on the valueType.

   * @param valueType

   * @param newValue

   */
10
  public void setValue(int valueType, double newValue) {

  if (valueType == OPEN)

    open = newValue;

  else

    close = newValue;

###
3234, getCloseTickLine, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 171, 172
5
/**

   * Returns the line. for close tick

   */
4
  public Line2D getCloseTickLine() {

  return getTickLine(getLine().getX1(), getValue(CLOSE), getTickSize());

###
3235, getOpenTickLine, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 164, 165
5
/**

   * Returns the line for open tick.

   */
4
  public Line2D getOpenTickLine() {

  return getTickLine(getLine().getX1(), getValue(OPEN), (-1) * getTickSize());

###
3236, getValue, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 142, 146
7
/**

   * Returns either OPEN or Close value depending on the valueType.

   * @param valueType

   */
10
  public double getValue(int valueType) {

  if (valueType == OPEN)

    return open;

  else

    return close;

###
3237, setTickSize, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 120, 121
7
/**

   * Sets the width of the open/close tick.

   * @param newSize

   */
4
  public void setTickSize(double newSize) {

  tickSize = newSize;

###
3238, HighLow, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 91, 92
15
/**

   * Constructs a high-low item, with default values for the colors.

   * @param x

   * @param high

   * @param low

   * @param open

   * @param close

   */
4
  public HighLow(double x, double high, double low, double open, double close) {

  this(x, high, low, open, close, new BasicStroke(), Color.blue);

###
3239, getLine, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 134, 135
5
/**

   * Returns the line.

   */
4
  public Line2D getLine() {

  return line;

###
3240, getStroke, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 185, 186
5
/**

   * Returns the Stroke object used to draw the line.

   */
4
  public Stroke getStroke() {

  return stroke;

###
3242, getTickSize, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 127, 128
5
/**

   * Returns the width of the open/close tick.

   */
4
  public double getTickSize() {

  return tickSize;

###
3243, HighLow, HighLow, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HighLow.java, 105, 112
19
/**

   * Constructs a high-low item.

   * @param x

   * @param high

   * @param low

   * @param open

   * @param close

   * @param stroke

   * @param paint

   */
14
  public HighLow(double x, double high, double low, double open, double close,

       Stroke stroke, Paint paint) {

    this.line = new Line2D.Double(x, high, x, low);

  this.open = open;

  this.close = close;

  this.stroke = stroke;

  this.paint = paint;

###
3244, isValidHorizontalAlignment, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 375, 381
5
/**

   * Utility method for checking a horizontal alignment code.

   */
12
  protected static boolean isValidHorizontalAlignment(int code) {

    switch(code) {

      case AbstractTitle.LEFT:   return true;

      case AbstractTitle.MIDDLE: return true;

      case AbstractTitle.RIGHT:  return true;

      default: return false;

###
3245, getVerticalAlignment, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 281, 282
9
/**

   * Returns the vertical alignment of the title.  The constants TOP, MIDDLE and BOTTOM (defined

   * in this class) are used.

   * @return The vertical alignment of the title (TOP, MIDDLE or BOTTOM);

   */
4
  public int getVerticalAlignment() {

    return this.verticalAlignment;

###
3247, setHorizontalAlignment, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 269, 272
11
/**

   * Sets the horizontal alignment for the title, and notifies any registered listeners of the

   * change.  The constants LEFT, CENTER and RIGHT (defined in this class) can be used to specify

   * the alignment.

   * @param alignment The new horizontal alignment (LEFT, CENTER or RIGHT).

   */
8
  public void setHorizontalAlignment(int alignment) {

    if (this.horizontalAlignment!=alignment) {

      this.horizontalAlignment = alignment;

      notifyListeners(new TitleChangeEvent(this));

###
3248, setVerticalAlignment, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 292, 295
13
/**

   * Sets the vertical alignment for the title, and notifies any registered listeners of the

   * change.

   * The constants TOP, MIDDLE and BOTTOM (defined in this class) can be used to specify the

   * alignment.

   * @param alignment The new vertical alignment (TOP, MIDDLE or BOTTOM);

   */
8
  public void setVerticalAlignment(int alignment) {

    if (this.verticalAlignment!=alignment) {

      this.verticalAlignment = alignment;

      notifyListeners(new TitleChangeEvent(this));

###
3249, AbstractTitle, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 180, 184
7
/**

   * Default constructor - builds an AbstractTitle positioned at the top of the page, centered

   * horizontally and vertically within its space.

   */
8
  protected AbstractTitle() {

    this(AbstractTitle.DEFAULT_POSITION,

       AbstractTitle.DEFAULT_HORIZONTAL_ALIGNMENT,

       AbstractTitle.DEFAULT_VERTICAL_ALIGNMENT);

###
3250, AbstractTitle, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 134, 156
21
/**

   * Constructs a title.

   * <P>

   * This class defines constants for the valid position and alignment values---an

   * IllegalArgumentException will be thrown if invalid values are passed to this constructor.

   * @param position The relative position of the title (TOP, BOTTOM, RIGHT and LEFT---or NORTH,

   *         SOUTH, EAST and WEST if you prefer).

   * @param horizontalAlignment The horizontal alignment of the title (LEFT, CENTER or RIGHT).

   * @param verticalAlignment The vertical alignment of the title (TOP, MIDDLE or BOTTOM).

   * @exception IllegalArgumentException If an invalid location or alignment value is passed.

   */
38
  protected AbstractTitle(int position,

              int horizontalAlignment, int verticalAlignment, Insets insets) {

    // check arguments...

    if (!this.isValidPosition(position)) {

      throw new IllegalArgumentException("AbstractTitle(): Invalid position.");

    }

    if (!AbstractTitle.isValidHorizontalAlignment(horizontalAlignment)) {

      throw new IllegalArgumentException("AbstractTitle(): Invalid horizontal alignment.");

    }

    if (!AbstractTitle.isValidVerticalAlignment(verticalAlignment)) {

      throw new IllegalArgumentException("AbstractTitle(): Invalid vertical alignment.");

    }

    // initialise...

    this.position = position;

    this.horizontalAlignment = horizontalAlignment;

    this.verticalAlignment = verticalAlignment;

    this.insets = insets;

    this.listeners = new java.util.ArrayList();

    this.notify = true;

###
3251, HorizontalBarPlot, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 75, 86
9
/**

   * Constructs a horizontal bar plot.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   */
20
  public HorizontalBarPlot(Axis horizontalAxis, Axis verticalAxis) {

    this(horizontalAxis,

       verticalAxis,

       Plot.DEFAULT_INSETS,

       BarPlot.DEFAULT_INTRO_GAP_PERCENT,

       BarPlot.DEFAULT_TRAIL_GAP_PERCENT,

       BarPlot.DEFAULT_CATEGORY_GAPS_PERCENT,

       BarPlot.DEFAULT_ITEM_GAPS_PERCENT,

       null);

    this.renderer = new HorizontalBarRenderer();

###
3252, getMaximumHorizontalDataValue, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 408, 414
7
/**

   * Returns the maximum value in the range, since this is plotted against the horizontal axis for

   * a HorizontalBarPlot.

   */
12
  public Number getMaximumHorizontalDataValue() {

  Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMaximumRangeValue(data);

  }

  else return null;

###
3253, setInsets, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 310, 313
7
/**

   * Sets the insets for the title, and notifies registered listeners of the change.

   * @param insets The new insets value;

   */
8
  public void setInsets(Insets insets) {

    if (!this.insets.equals(insets)) {

      this.insets = insets;

      notifyListeners(new TitleChangeEvent(this));

###
3254, getCategories, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 169, 170
5
/**

   * A convenience method that returns a list of the categories in the data source.

   */
4
  public java.util.List getCategories() {

  return getDataset().getCategories();

###
3255, getInsets, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 302, 303
5
/**

   * Returns the insets (the blank space around the edges) for this title.

   */
4
  public Insets getInsets() {

    return this.insets;

###
3256, setNotify, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 227, 228
9
/**

   * Sets the flag that indicates whether or not the notification mechanism is enabled.  There are

   * certain situations (such as cloning) where you want to turn notification off temporarily.

   * @param flag A boolean that indicates whether or not the notification mechanism is enabled;

   */
4
  public void setNotify(boolean flag) {

    this.notify = flag;

###
3257, calculateBarWidth, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 362, 380
7
/**

   * Returns the width of each bar in the chart.

   * @param plotArea The area within which the plot will be drawn.

   */
28
  double calculateBarWidth(Rectangle2D plotArea) {

  CategoryDataset data = getDataset();

  // series, category and bar counts

  int categoryCount = data.getCategoryCount();

  int seriesCount = data.getSeriesCount();

  int barCount = renderer.barWidthsPerCategory(data)*categoryCount;

  // calculate the plot height (bars are horizontal) less whitespace

  double usable = plotArea.getHeight() *

                  (1.0 - introGapPercent - trailGapPercent - categoryGapsPercent);

    if (renderer.barWidthsPerCategory(data)>1) {

//    usable = usable - ((seriesCount-1) * categoryCount * seriesGap);

    }

  // and thus the width of the bars

  return usable/barCount;

###
3258, removeChangeListener, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 354, 355
7
/**

   * Unregisters an object for notification of changes to the chart title.

   * @param listener The object that is being unregistered;

   */
4
  public void removeChangeListener(TitleChangeListener listener) {

    listeners.remove(listener);

###
3259, getDataset, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 127, 128
5
/**

   * A convenience method that returns the dataset for the plot, cast as a CategoryDataset.

   */
4
  public CategoryDataset getDataset() {

  return (CategoryDataset)chart.getDataset();

###
3260, AbstractTitle, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 168, 172
15
/**

   * Constructs a title.

   * @param position The relative position of the title (TOP, BOTTOM, RIGHT and LEFT---or NORTH,

   *         SOUTH, EAST and WEST if you prefer);

   * @param horizontalAlignment The horizontal alignment of the title (LEFT, CENTER or RIGHT);

   * @param verticalAlignment The vertical alignment of the title (TOP, MIDDLE or BOTTOM);

   * @exception IllegalArgumentException If an invalid location or alignment value is passed;

   */
8
  protected AbstractTitle(int position, int horizontalAlignment, int verticalAlignment) {

    this(position,

       horizontalAlignment, verticalAlignment,

       AbstractTitle.DEFAULT_INSETS);

###
3261, HorizontalBarPlot, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 100, 111
19
/**

   * Constructs a horizontal bar plot.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   * @param introGapPercent The gap before the first bar in the plot.

   * @param trailGapPercent The gap after the last bar in the plot.

   * @param categoryGapPercent The gap between the last bar in one category and the first bar in

   *               the next category.

   * @param itemGapPercent The gap between bars within the same category.

   */
20
  public HorizontalBarPlot(Axis horizontalAxis, Axis verticalAxis,

               Insets insets,

         double introGapPercent, double trailGapPercent,

               double categoryGapPercent, double itemGapPercent,

               CategoryToolTipGenerator toolTipGenerator) {

  super(horizontalAxis, verticalAxis,

        insets,

        introGapPercent, trailGapPercent, categoryGapPercent, itemGapPercent,

        toolTipGenerator);

    this.renderer = new HorizontalBarRenderer();

###
3263, getPlotType, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 386, 387
5
/**

   * Returns a short string describing the type of plot.

   */
4
  public String getPlotType() {

  return "Horizontal Bar Plot";

###
3264, addChangeListener, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 346, 347
7
/**

   * Registers an object for notification of changes to the title.

   * @param listener The object that is being registered;

   */
4
  public void addChangeListener(TitleChangeListener listener) {

    listeners.add(listener);

###
3265, getCategoryAxis, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 152, 153
7
/**

   * A convenience method that returns a reference to the horizontal axis cast as a

   * CategoryAxis.

   */
4
  public CategoryAxis getCategoryAxis() {

  return (CategoryAxis)verticalAxis;

###
3266, getNotify, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 218, 219
7
/**

   * Returns the flag that indicates whether or not the notification mechanism is enabled.

   * @return A boolean that indicates whether or not the notification mechanism is enabled;

   */
4
  public boolean getNotify() {

    return this.notify;

###
3267, isCompatibleHorizontalAxis, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 210, 214
9
/**

   * Checks the compatibility of a horizontal axis, returning true if the axis is compatible with

   * the plot, and false otherwise.

   * @param axis The horizontal axis;

   */
10
  public boolean isCompatibleHorizontalAxis(Axis axis) {

  if (axis instanceof HorizontalNumberAxis) {

    return true;

  }

  else return false;

###
3268, setPosition, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 246, 250
9
/**

   * Sets the position for the title.

   * @param position The relative position of the title (use one of the constants TOP, BOTTOM,

   *         RIGHT and LEFT, or the equivalent NORTH, SOUTH, EAST and WEST);

   */
10
  public void setPosition(int position) {

    if (this.position!=position) {

      // check that the position is valid

      this.position = position;

      notifyListeners(new TitleChangeEvent(this));

###
3269, setHorizontalAxis, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 161, 163
9
/**

   * Sets the horizontal axis for the plot.  This method should throw an exception if the axis

   * doesn't implement the required interfaces.

   * @param axis The new horizontal axis;

   */
6
  public void setHorizontalAxis(Axis axis) throws AxisNotCompatibleException {

  // check that the axis implements the required interface (if not raise an exception);

  super.setHorizontalAxis(axis);

###
3271, getPosition, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 237, 238
11
/**

   * Returns the relative position of the title---represented by one of four integer constants

   * defined in this class: TOP, BOTTOM, RIGHT or LEFT (or the equivalent NORTH, SOUTH, EAST and

   * WEST).

   * @return The title position;

   */
4
  public int getPosition() {

    return this.position;

###
3272, setVerticalAxis, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 143, 145
9
/**

   * Sets the vertical axis for the plot.  This method should throw an exception if the axis

   * doesn't implement the required interfaces.

   * @param vAxis The new vertical axis;

   */
6
  public void setVerticalAxis(Axis vAxis) throws AxisNotCompatibleException {

  // check that the axis implements the required interface (if not raise an exception);

  super.setVerticalAxis(vAxis);

###
3273, notifyListeners, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 362, 367
7
/**

   * Notifies all registered listeners that the chart title has changed in some way.

   * @param event An object that contains information about the change to the title;

   */
12
  protected void notifyListeners(TitleChangeEvent event) {

    if (this.notify) {

      java.util.Iterator iterator = listeners.iterator();

      while (iterator.hasNext()) {

        TitleChangeListener listener = (TitleChangeListener)iterator.next();

        listener.titleChanged(event);

###
3274, clone, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 196, 210
15
/**

   * Returns a clone of the title.

   * <P>

   * One situation when this is useful is when editing the title properties - you can edit a

   * clone, and then it is easier to cancel the changes if necessary.

   * @return A clone of the title.

   *

   */
26
  public Object clone() {

    AbstractTitle duplicate = null;

    try {

      duplicate = (AbstractTitle)(super.clone());

    }

    catch (CloneNotSupportedException e) {

      // this should never happen because Cloneable is implemented

      throw new RuntimeException("AbstractTitle.clone()");

    }

    duplicate.setNotify(false);

    duplicate.setInsets((Insets)this.getInsets().clone());

    duplicate.setNotify(true);

    return duplicate;

###
3276, getHorizontalAlignment, AbstractTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/AbstractTitle.java, 259, 260
9
/**

   * Returns the horizontal alignment of the title.  The constants LEFT, CENTER and RIGHT (defined

   * in this class) are used.

   * @return The horizontal alignment of the title (LEFT, CENTER or RIGHT);

   */
4
  public int getHorizontalAlignment() {

    return this.horizontalAlignment;

###
3277, draw, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 239, 353
19
/**

   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).

   * <P>

   * At your option, you may supply an instance of DrawInfo.  If you do, it will be populated

   * with information about the drawing, including various plot dimensions and tooltip info.

   * @param g2 The graphics device.

   * @param plotArea The area within which the plot should be drawn.

   * @param info A structure for passing back information about the chart drawing (ignored if

   *       null).

   */
196
  public void draw(Graphics2D g2, Rectangle2D plotArea, DrawInfo info) {

    // set up collection of drawing info...

    ToolTipsCollection tooltips = null;

    if (info!=null) {

      info.setPlotArea(plotArea);

      tooltips = info.getToolTipsCollection();

    }

    // adjust the drawing area for the plot insets (if any)...

  if (insets!=null) {

    plotArea.setRect(plotArea.getX()+insets.left,

         plotArea.getY()+insets.top,

               plotArea.getWidth()-insets.left-insets.right,

         plotArea.getHeight()-insets.top-insets.bottom);

  }

  // estimate the area required for drawing the axes...

  VerticalAxis vAxis = getVerticalAxis();

  HorizontalAxis hAxis = getHorizontalAxis();

  double vAxisAreaWidth = vAxis.reserveWidth(g2, this, plotArea);

  Rectangle2D hAxisArea = hAxis.reserveAxisArea(g2, this, plotArea, vAxisAreaWidth);

  // and this the area available for plotting data...

  Rectangle2D dataArea = new Rectangle2D.Double(plotArea.getX()+vAxisAreaWidth,

                plotArea.getY(),

                plotArea.getWidth()-vAxisAreaWidth,

                plotArea.getHeight()-hAxisArea.getHeight());

    if (info!=null) {

      info.setDataArea(dataArea);

    }

    // draw the background and axes...

  drawOutlineAndBackground(g2, dataArea);

  getCategoryAxis().draw(g2, plotArea, dataArea);

  getRangeAxis().draw(g2, plotArea, dataArea);

    // now get the data and plot the bars...

    CategoryDataset data = this.getDataset();

    if (data!=null) {

      Shape savedClip = g2.getClip();

      g2.clip(dataArea);

      // draw a line at zero...

      double translatedZero = getRangeAxis().translateValueToJava2D(0.0, dataArea);

      Line2D baseline = new Line2D.Double(translatedZero, dataArea.getY(),

                        translatedZero, dataArea.getMaxY());

      g2.setStroke(new BasicStroke());

      g2.draw(baseline);

      int seriesCount = data.getSeriesCount();

      int categoryCount = data.getCategoryCount();

      int barCount = renderer.barWidthsPerCategory(data);

      // work out the span dimensions for the categories...

      double categorySpan = 0.0;

      double categoryGapSpan = 0.0;

      if (categoryCount>1) {

        categorySpan = dataArea.getHeight()*

                 (1-introGapPercent-trailGapPercent-categoryGapsPercent);

        categoryGapSpan = dataArea.getHeight()*categoryGapsPercent;

      }

      else {

        categorySpan = dataArea.getHeight()*(1-introGapPercent-trailGapPercent);

      }

      // work out the item span...

      double itemSpan = categorySpan;

      double itemGapSpan = 0.0;

      if (seriesCount>1) {

        if (renderer.hasItemGaps()) {

          itemGapSpan = plotArea.getHeight()*itemGapsPercent;

          itemSpan = itemSpan - itemGapSpan;

        }

      }

      double itemWidth = itemSpan/(categoryCount*renderer.barWidthsPerCategory(data));

      int categoryIndex = 0;

      Iterator iterator = data.getCategories().iterator();

      while (iterator.hasNext()) {

        Object category = iterator.next();

        for (int series=0; series<seriesCount; series++) {

          Shape tooltipArea = renderer.drawBar(g2, dataArea, this,

                             this.getRangeAxis(), data, series,

                             category, categoryIndex,

                             translatedZero, itemWidth,

                             categorySpan, categoryGapSpan,

                             itemSpan, itemGapSpan);

          // collect optional tooltip information...

          if (tooltips!=null) {

            if (this.toolTipGenerator==null) {

              toolTipGenerator = new StandardCategoryToolTipGenerator();

            }

            String tip = this.toolTipGenerator.generateToolTip(data, series, category);

            if (tooltipArea!=null) {

              tooltips.addToolTip(tip, tooltipArea);

            }

          }

        }

        categoryIndex++;

      }

      // draw vertical crosshair if required...

      ValueAxis hva = this.getRangeAxis();

      if (hva.isCrosshairVisible()) {

        this.drawVerticalLine(g2, dataArea, hva.getCrosshairValue(),

                    hva.getCrosshairStroke(),

                    hva.getCrosshairPaint());

      }

      g2.setClip(savedClip);

###
3278, drawItem, CandlestickRenderer, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/CandlestickRenderer.java, 78, 128
27
/**

   * Draws the visual representation of a single data item.

   * @param g2 The graphics device.

   * @param dataArea The area within which the plot is being drawn.

   * @param info Collects info about the drawing.

   * @param plot The plot (can be used to obtain standard color information etc).

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   * @param data The dataset.

   * @param series The series index.

   * @param item The item index.

   * @param translatedRangeZero Zero on the range axis (supplied so that, if it is required, it

   *    doesn't have to be calculated repeatedly).

   */
84
  public Shape drawItem(Graphics2D g2, Rectangle2D dataArea, DrawInfo info,

              XYPlot plot, ValueAxis horizontalAxis, ValueAxis verticalAxis,

              XYDataset data, int series, int item,

              double translatedRangeZero, CrosshairInfo crosshairInfo) {

    Shape result = null;

    HighLowDataset highLowData = (HighLowDataset)data;

  Number x = highLowData.getXValue(series, item);

    Number yHigh  = highLowData.getHighValue(series, item);

    Number yLow   = highLowData.getLowValue(series, item);

    Number yOpen  = highLowData.getOpenValue(series, item);

    Number yClose = highLowData.getCloseValue(series, item);

    double xx = horizontalAxis.translateValueToJava2D(x.doubleValue(), dataArea);

    double yyHigh = verticalAxis.translateValueToJava2D(yHigh.doubleValue(), dataArea);

    double yyLow = verticalAxis.translateValueToJava2D(yLow.doubleValue(), dataArea);

    double yyOpen = verticalAxis.translateValueToJava2D(yOpen.doubleValue(), dataArea);

    double yyClose = verticalAxis.translateValueToJava2D(yClose.doubleValue(), dataArea);

    Paint p = plot.getSeriesPaint(series);

    Stroke s = plot.getSeriesStroke(series);

    g2.setPaint(p);

    g2.setStroke(s);

    // draw the upper shadow

    if ((yyHigh<yyOpen) && (yyHigh<yyClose)) {

      g2.draw(new Line2D.Double(xx, yyHigh, xx, Math.min(yyOpen, yyClose)));

    }

    // draw the lower shadow

    if ((yyLow>yyOpen) && (yyLow>yyClose)) {

      g2.draw(new Line2D.Double(xx, yyLow, xx, Math.max(yyOpen, yyClose)));

    }

    // draw the body

    Shape body = null;

    if (yyOpen<yyClose) {

      body = new Rectangle2D.Double(xx-candleWidth/2, yyOpen,

                      candleWidth, yyClose-yyOpen);

      g2.fill(body);

    }

    else {

      body = new Rectangle2D.Double(xx-candleWidth/2, yyClose,

                      candleWidth, yyOpen-yyClose);

      g2.draw(body);

    }

    result = body;

    return result;

###
3279, CandlestickRenderer, CandlestickRenderer, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/CandlestickRenderer.java, 58, 60
5
/**

   * Creates a new renderer.

   */
4
  public CandlestickRenderer(double candleWidth) {

    this.candleWidth = candleWidth;

###
3280, handleClick, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 420, 426
5
/**

   * Handles a 'click' on the plot by updating the anchor values...

   */
12
  public void handleClick(int x, int y, DrawInfo info) {

    // set the anchor value for the horizontal axis...

    ValueAxis hva = this.getRangeAxis();

    double hvalue = hva.translateJava2DtoValue((float)x, info.getDataArea());

    hva.setAnchorValue(hvalue);

    hva.setCrosshairValue(hvalue);

###
3281, isCompatibleVerticalAxis, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 222, 226
9
/**

   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with

   * the plot, and false otherwise.

   * @param axis The vertical axis;

   */
10
  public boolean isCompatibleVerticalAxis(Axis axis) {

  if (axis instanceof VerticalCategoryAxis) {

    return true;

  }

  else return false;

###
3282, setRenderer, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 119, 121
7
/**

   * Sets the renderer for the bar plot.

   * @param renderer The renderer.

   */
6
  public void setRenderer(HorizontalBarRenderer renderer) {

    this.renderer = renderer;

    this.notifyListeners(new PlotChangeEvent(this));

###
3283, getCategoryCoordinate, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 178, 201
9
/**

   * Returns the x-coordinate (in Java 2D User Space) of the center of the specified category.

   * @param category The index of the category of interest (first category index = 0).

   * @param area The region within which the plot will be drawn.

   */
36
  public double getCategoryCoordinate(int category, Rectangle2D area) {

    // calculate first part of result...

    double result = area.getY()+(area.getHeight()*introGapPercent);

    // then add some depending on how many categories...

    int categoryCount = getDataset().getCategoryCount();

    if (categoryCount>1) {

    double categorySpan = area.getHeight()

                  *(1-introGapPercent-trailGapPercent-categoryGapsPercent);

      double categoryGapSpan = area.getHeight()*categoryGapsPercent;

      result = result

           + (category+0.5)*(categorySpan/categoryCount)

           + (category)*(categoryGapSpan/(categoryCount-1));

    }

    else {

      result = result

           + (category+0.5)*area.getHeight()*(1-introGapPercent-trailGapPercent);

    }

    return result;

###
3284, getRangeAxis, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 134, 135
5
/**

   * Returns the range axis for the plot.

   */
4
  public ValueAxis getRangeAxis() {

  return (ValueAxis)horizontalAxis;

###
3285, getMinimumHorizontalDataValue, HorizontalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/HorizontalBarPlot.java, 394, 400
7
/**

   * Returns the minimum value in the range, since this is plotted against the horizontal axis for

   * a HorizontalBarPlot.

   */
12
  public Number getMinimumHorizontalDataValue() {

  Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMinimumRangeValue(data);

  }

  else return null;

###
3286, saveChartAsPNG, ChartUtilities, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartUtilities.java, 76, 82
13
/**

   * Saves the chart as a PNG format image file.

   * @param chart The chart.

   * @param width The image width.

   * @param height The image height.

   * @param file The file.

   */
12
  public static void saveChartAsPNG(File file, JFreeChart chart, int width, int height)

    throws IOException {

    DataOutputStream out = new DataOutputStream(

                   new BufferedOutputStream(new FileOutputStream(file)));

    writeChartAsPNG(out, chart, width, height);

    out.close();

###
3287, writeChartAsJPEG, ChartUtilities, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartUtilities.java, 93, 100
13
/**

   * Writes the chart to the output stream in JPEG format.

   * @param out The output stream.

   * @param chart The chart.

   * @param width The image width.

   * @param height The image height.

   */
14
  public static void writeChartAsJPEG(OutputStream out, JFreeChart chart, int width, int height)

    throws IOException {

    BufferedImage image = chart.createBufferedImage(width, height);

    JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);

    JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(image);

    param.setQuality(1.0f, true);

    encoder.encode(image, param);

###
3288, writeChartAsPNG, ChartUtilities, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartUtilities.java, 59, 65
13
/**

   * Writes the chart to the output stream in PNG format.

   * @param out The output stream.

   * @param chart The chart.

   * @param width The image width.

   * @param height The image height.

   */
12
  public static void writeChartAsPNG(OutputStream out, JFreeChart chart, int width, int height)

    throws IOException {

    BufferedImage chartImage = chart.createBufferedImage(width, height);

    PngEncoder encoder = new PngEncoder(chartImage, false, 0, 9);

    byte[] pngData = encoder.pngEncode();

    out.write(pngData);

###
3289, getCount, DateUnit, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateUnit.java, 74, 75
5
/**

   * Returns the number of units.

   */
4
  public int getCount() {

  return this.count;

###
3290, createVerticalBarChart3D, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 94, 107
19
/**

   * Creates a vertical 3D-effect bar chart with default settings.

   * <P>

   * Added by Serge V. Grachov.

   * @param title The chart title.

   * @param categoryAxisLabel The label for the category axis.

   * @param valueAxisLabel The label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
24
  public static JFreeChart createVerticalBarChart3D(String title, String categoryAxisLabel,

                          String valueAxisLabel, CategoryDataset data,

                          boolean legend) {

    CategoryAxis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);

    ValueAxis valueAxis = new VerticalNumberAxis3D(valueAxisLabel);

    VerticalBarPlot plot = new VerticalBarPlot3D(categoryAxis, valueAxis);

    // the insets here are a workaround for the fact that the plot area is no longer a

    // rectangle, so it is overlapping the title.  To be fixed...

    plot.setInsets(new Insets(20, 2, 2, 2));

    plot.setRenderer(new VerticalBarRenderer3D());

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3291, getField, DateUnit, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateUnit.java, 67, 68
5
/**

   * Returns the field used for this DateUnit.

   */
4
  public int getField() {

  return this.field;

###
3292, DateUnit, DateUnit, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateUnit.java, 59, 61
5
/**

   * Builds a DateUnit.

   */
6
  public DateUnit(int field, int count) {

  this.field = field;

  this.count = count;

###
3293, createStackedVerticalBarChart3D, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 144, 156
21
/**

   * Creates a stacked vertical bar chart with default settings.  This is still experimental at

   * this point!

   * <P>

   * Added by Serge V. Grachov.

   * @param title The chart title.

   * @param categoryAxisLabel The label for the category axis.

   * @param valueAxisLabel The label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
24
  public static JFreeChart createStackedVerticalBarChart3D(String title, String categoryAxisLabel,

                            String valueAxisLabel, CategoryDataset data,

                            boolean legend) {

    CategoryAxis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);

    ValueAxis valueAxis = new VerticalNumberAxis3D(valueAxisLabel);

    VerticalBarPlot plot = new VerticalBarPlot3D(categoryAxis, valueAxis);

    // the insets here are a workaround for the fact that the plot area is no longer a

    // rectangle, so it is overlapping the title.  To be fixed...

    plot.setInsets(new Insets(20, 2, 2, 2));

    plot.setRenderer(new StackedVerticalBarRenderer3D());

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3294, createLineChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 210, 218
15
/**

   * Creates a line chart with default settings.

   * @param title The chart title.

   * @param categoryAxisLabel The label for the category axis.

   * @param valueAxisLabel The label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
16
  public static JFreeChart createLineChart(String title, String categoryAxisLabel,

                         String valueAxisLabel, CategoryDataset data,

                         boolean legend) {

    Axis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);

    Axis valueAxis = new VerticalNumberAxis(valueAxisLabel);

    Plot plot = new LinePlot(categoryAxis, valueAxis);

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3295, createTimeSeriesChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 289, 301
23
/**

   * Creates and returns a time series chart.  A time series chart is an XYPlot with a date

   * axis (horizontal) and a number axis (vertical), and each data item is connected with a line.

   * <P>

   * Note that you can supply a TimeSeriesDataset to this method as it is a subclass of

   * XYDataset.

   * @param title The chart title.

   * @param timeAxisLabel A label for the time axis.

   * @param valueAxisLabel A label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
24
  public static JFreeChart createTimeSeriesChart(String title, String timeAxisLabel,

                           String valueAxisLabel, XYDataset data,

                           boolean legend) {

    ValueAxis timeAxis = new HorizontalDateAxis(timeAxisLabel);

    //timeAxis.setCrosshairLockedOnData(false);

    NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);

    valueAxis.setAutoRangeIncludesZero(false);  // override default

    //valueAxis.setCrosshairLockedOnData(false);

    XYPlot plot = new XYPlot(timeAxis, valueAxis);

    plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3296, createSignalChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 389, 398
19
/**

   * Creates and returns a default instance of a signal chart based on the specified dataset.

   * <P>

   * Added by David Gilbert.

   * @param title The chart title.

   * @param timeAxisLabel A label for the time axis.

   * @param valueAxisLabel A label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
18
  public static JFreeChart createSignalChart(String title, String timeAxisLabel,

                         String valueAxisLabel, SignalsDataset data,

                         boolean legend) {

    ValueAxis timeAxis = new HorizontalDateAxis(timeAxisLabel);

    NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);

    XYPlot plot = new XYPlot(timeAxis, valueAxis);

    plot.setXYItemRenderer(new SignalRenderer());

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3297, createHighLowChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 341, 351
21
/**

   * Creates and returns a default instance of a high-low-open-close chart based on the specified

   * dataset.

   * <P>

   * Added by Andrzej Porebski.  Amended by David Gilbert.

   * @param title The chart title.

   * @param timeAxisLabel A label for the time axis.

   * @param valueAxisLabel A label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
20
  public static JFreeChart createHighLowChart(String title, String timeAxisLabel,

                        String valueAxisLabel, HighLowDataset data,

                        boolean legend) {

    ValueAxis timeAxis = new HorizontalDateAxis(timeAxisLabel);

    NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);

    //HighLowPlot plot = new HighLowPlot(timeAxis, valueAxis);

    XYPlot plot = new XYPlot(timeAxis, valueAxis);

    plot.setXYItemRenderer(new HighLowRenderer());

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3298, createVerticalBarChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 71, 80
15
/**

   * Creates a vertical bar chart with default settings.

   * @param title The chart title.

   * @param categoryAxisLabel The label for the category axis.

   * @param valueAxisLabel The label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
16
  public static JFreeChart createVerticalBarChart(String title,

                          String categoryAxisLabel, String valueAxisLabel,

                          CategoryDataset data, boolean legend) {

    CategoryAxis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);

    ValueAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);

    Plot plot = new VerticalBarPlot(categoryAxis, valueAxis);

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3299, createHorizontalBarChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 168, 176
15
/**

   * Creates a horizontal bar chart with default settings.

   * @param title The chart title.

   * @param categoryAxisLabel The label for the category axis.

   * @param valueAxisLabel The label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
16
  public static JFreeChart createHorizontalBarChart(String title, String categoryAxisLabel,

                            String valueAxisLabel, CategoryDataset data,

                            boolean legend) {

    Axis categoryAxis = new VerticalCategoryAxis(categoryAxisLabel);

    Axis valueAxis = new HorizontalNumberAxis(valueAxisLabel);

    Plot plot = new HorizontalBarPlot(valueAxis, categoryAxis);

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3300, createStackedVerticalBarChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 120, 129
17
/**

   * Creates a stacked vertical bar chart with default settings.  This is still experimental at

   * this point!

   * @param title The chart title.

   * @param categoryAxisLabel The label for the category axis.

   * @param valueAxisLabel The label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
18
  public static JFreeChart createStackedVerticalBarChart(String title, String categoryAxisLabel,

                             String valueAxisLabel, CategoryDataset data,

                             boolean legend) {

    CategoryAxis categoryAxis = new HorizontalCategoryAxis(categoryAxisLabel);

    ValueAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);

    VerticalBarPlot plot = new VerticalBarPlot(categoryAxis, valueAxis);

    plot.setRenderer(new StackedVerticalBarRenderer());

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3301, createStackedHorizontalBarChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 189, 198
17
/**

   * Creates a stacked horizontal bar chart with default settings.  This is still experimental at

   * this point!

   * @param title The chart title.

   * @param categoryAxisLabel The label for the category axis.

   * @param valueAxisLabel The label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
18
  public static JFreeChart createStackedHorizontalBarChart(String title, String categoryAxisLabel,

                            String valueAxisLabel, CategoryDataset data,

                            boolean legend) {

    Axis categoryAxis = new VerticalCategoryAxis(categoryAxisLabel);

    Axis valueAxis = new HorizontalNumberAxis(valueAxisLabel);

    HorizontalBarPlot plot = new HorizontalBarPlot(valueAxis, categoryAxis);

    plot.setRenderer(new StackedHorizontalBarRenderer());

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3302, createScatterPlot, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 265, 273
15
/**

   * Creates a scatter plot with default settings.

   * @param title The chart title.

   * @param xAxisLabel A label for the X-axis.

   * @param yAxisLabel A label for the Y-axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
16
  public static JFreeChart createScatterPlot(String title, String xAxisLabel, String yAxisLabel,

                         XYDataset data, boolean legend) {

    ValueAxis xAxis = new HorizontalNumberAxis(xAxisLabel);

    ValueAxis yAxis = new VerticalNumberAxis(yAxisLabel);

    XYPlot plot = new XYPlot(xAxis, yAxis);

    plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.SHAPES));

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3303, createVerticalXYBarChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 314, 326
17
/**

   * Creates and returns a default instance of a VerticalXYBarChart based on the specified

   * dataset.

   * @param title The chart title.

   * @param xAxisLabel A label for the X-axis.

   * @param yAxisLabel A label for the Y-axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
24
  public static JFreeChart createVerticalXYBarChart(String title, String xAxisLabel,

                            String yAxisLabel, IntervalXYDataset data,

                            boolean legend) {

    HorizontalDateAxis timeAxis = new HorizontalDateAxis(xAxisLabel);

    ValueAxis valueAxis = new VerticalNumberAxis(yAxisLabel);

    //Plot plot = new VerticalXYBarPlot(timeAxis, valueAxis, new Insets(0,0,0,0), Color.white,

    //                  new BasicStroke(), Color.gray);

    XYPlot plot = new XYPlot(timeAxis, valueAxis, new Insets(0,0,0,0), Color.white,

                 new BasicStroke(), Color.gray);

    plot.setXYItemRenderer(new VerticalXYBarRenderer());

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3304, setMinimumDate, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 173, 177
7
/**

   * Sets the minimum date visible on the axis.

   * @param minimumDate The new minimum date.

   */
8
  public void setMinimumDate(Date minimumDate) {

  this.minimumDate = minimumDate;

    double millis = (double)minimumDate.getTime();

    this.setMinimumAxisValue(millis);

###
3305, createCombinableTimeSeriesChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 431, 435
20
/**

   * Creates and returns a combinable time series chart.  A time series chart is an XYPlot with a

   * date axis (horizontal) and a number axis (vertical), and each data item is connected with a

   * line.

   * <P>

   * @author Bill Kelemen.

   * @param horizontal The horizontal axis

   * @param vertical The vertical axis

   * @param data The dataset for the chart.

   */

10
  public static CombinedChart createCombinableTimeSeriesChart(ValueAxis horizontal,

                                ValueAxis vertical, Dataset data) {

    XYPlot plot = new XYPlot(horizontal, vertical);

      plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));

      return createCombinableChart(data, plot);

###
3306, calculateHighestVisibleTickValue, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 307, 308
7
/**

   * Calculates the value of the highest visible tick on the axis.

   * @return The value of the highest visible tick on the axis.

   */
4
  public Date calculateHighestVisibleTickValue(DateUnit unit) {

  return this.previousStandardDate(maximumDate, unit.getField(), unit.getCount());

###
3307, createXYChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 244, 253
15
/**

   * Creates an XY (line) plot with default settings.

   * @param title The chart title.

   * @param xAxisLabel A label for the X-axis.

   * @param yAxisLabel A label for the Y-axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
18
  public static JFreeChart createXYChart(String title, String xAxisLabel, String yAxisLabel,

                         XYDataset data, boolean legend) {

    NumberAxis xAxis = new HorizontalNumberAxis(xAxisLabel);

    xAxis.setAutoRangeIncludesZero(false);

    NumberAxis yAxis = new VerticalNumberAxis(yAxisLabel);

    XYPlot plot = new XYPlot(xAxis, yAxis);

    plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3308, DateAxis, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 127, 157
45
/**

   * Constructs a date axis.

   * @param label The axis label.

   * @param labelFont The font for displaying the axis label.

   * @param labelPaint The paint used to draw the axis label.

   * @param labelInsets Determines the amount of blank space around the label.

   * @param tickLabelsVisible Flag indicating whether or not tick labels are visible.

   * @param tickLabelFont The font used to display tick labels.

   * @param tickLabelPaint The paint used to draw tick labels.

   * @param tickLabelInsets Determines the amount of blank space around tick labels.

   * @param tickMarksVisible Flag indicating whether or not tick marks are visible.

   * @param tickMarkStroke The stroke used to draw tick marks (if visible).

   * @param autoRange Flag indicating whether or not the axis range is automatically adjusted to

   *          fit the data.

   * @param minimumDate The earliest date showing on the axis.

   * @param maximumDate The latest date showing on the axis.

   * @param autoTickUnitSelection A flag indicating whether or not the tick unit is automatically

   *                selected.

   * @param tickUnit The tick unit.

   * @param gridLinesVisible Flag indicating whether or not grid lines are visible.

   * @param gridStroke The Stroke used to display grid lines (if visible).

   * @param gridPaint The Paint used to display grid lines (if visible).

   */
56
  protected DateAxis(String label,

             Font labelFont, Paint labelPaint, Insets labelInsets,

         boolean tickLabelsVisible,

             Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,

         boolean tickMarksVisible, Stroke tickMarkStroke,

         boolean autoRange, Date minimumDate, Date maximumDate,

         boolean autoTickUnitSelection, DateUnit tickUnit,

             SimpleDateFormat tickLabelFormatter,

         boolean gridLinesVisible, Stroke gridStroke, Paint gridPaint,

             Date crosshairDate, Stroke crosshairStroke, Paint crosshairPaint) {

  super(label, labelFont, labelPaint, labelInsets,

      tickLabelsVisible, tickLabelFont, tickLabelPaint, tickLabelInsets,

      tickMarksVisible, tickMarkStroke, autoRange,

      autoTickUnitSelection, gridLinesVisible, gridStroke, gridPaint,

        0.0,

        crosshairStroke, crosshairPaint);

  this.minimumDate = minimumDate;

    if (minimumDate!=null) {

      this.minimumAxisValue = (double)minimumDate.getTime();

    }

  this.maximumDate = maximumDate;

    if (maximumDate!=null) {

      this.maximumAxisValue = (double)maximumDate.getTime();

    }

    this.crosshairDate = crosshairDate;

  this.tickUnit = tickUnit;

  this.tickLabelFormatter = tickLabelFormatter;

    this.anchorValue = (double)this.anchorDate.getTime();

###
3309, createCombinableXYChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 413, 417
13
/**

   * Creates a combinable XY (line) plot with default settings.

   * @author Bill Kelemen.

   * @param horizontal The horizontal axis

   * @param vertical The vertical axis

   * @param data The dataset for the chart.

   */
10
  public static CombinedChart createCombinableXYChart(ValueAxis horizontal, ValueAxis vertical,

                            Dataset data) {

    XYPlot plot = new XYPlot(horizontal, vertical);

    plot.setXYItemRenderer(new StandardXYItemRenderer(StandardXYItemRenderer.LINES));

    return createCombinableChart(data, plot);

###
3310, createCandlestickChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 366, 375
21
/**

   * Creates and returns a default instance of a candlesticks chart based on the specified

   * dataset.

   * <P>

   * Added by David Gilbert.

   * @param title The chart title.

   * @param timeAxisLabel A label for the time axis.

   * @param valueAxisLabel A label for the value axis.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
18
  public static JFreeChart createCandlestickChart(String title, String timeAxisLabel,

                          String valueAxisLabel, HighLowDataset data,

                          boolean legend) {

    ValueAxis timeAxis = new HorizontalDateAxis(timeAxisLabel);

    NumberAxis valueAxis = new VerticalNumberAxis(valueAxisLabel);

    XYPlot plot = new XYPlot(timeAxis, valueAxis);

    plot.setXYItemRenderer(new CandlestickRenderer(4.0));

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3311, createCombinableVerticalXYBarChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 468, 472
17
/**

   * Creates and returns a default instance of a VerticalXYBar combinable chart based on the

   * specified dataset.

   * <P>

   * @author Bill Kelemen.

   * @param horizontal The horizontal axis

   * @param vertical The vertical axis

   * @param data The dataset for the chart.

   */
8
  public static CombinedChart createCombinableVerticalXYBarChart(Axis horizontal, Axis vertical,

                                   Dataset data) {

    VerticalXYBarPlot plot = new VerticalXYBarPlot(horizontal, vertical);

    return createCombinableChart(data, plot);

###
3312, createCombinableHighLowChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 448, 454
18
/**

   * Creates and returns a default instance of a high-low-open-close combinable chart based on

   * the specified dataset.

   * <P>

   * @author Bill Kelemen.

   * @param horizontal The horizontal axis

   * @param vertical The vertical axis

   * @param data The dataset for the chart.

   */

12
  public static CombinedChart createCombinableHighLowChart(ValueAxis horizontal,

                               ValueAxis vertical,

                               Dataset data) {

    XYPlot plot = new XYPlot(horizontal, vertical);

      plot.setXYItemRenderer(new HighLowRenderer());

      return createCombinableChart(data, plot);

###
3313, previousStandardDate, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 314, 390
5
/**

   * Returns the previous "standard" date (based on the specified field and units).

   */
138
  protected Date previousStandardDate(Date date, int field, int units) {

  int milliseconds;

  int seconds;

  int minutes;

  int hours;

  int days;

  int months;

  int years;

  Calendar calendar = Calendar.getInstance();

  calendar.setTime(date);

  int current = calendar.get(field);

  int value = units*(current/units);

  switch (field) {

  case(Calendar.MILLISECOND) : {

      years = calendar.get(Calendar.YEAR);

      months = calendar.get(Calendar.MONTH);

      days = calendar.get(Calendar.DATE);

      hours = calendar.get(Calendar.HOUR_OF_DAY);

      minutes = calendar.get(Calendar.MINUTE);

      seconds = calendar.get(Calendar.SECOND);

      calendar.set(years, months, days, hours, minutes, seconds);

      calendar.set(Calendar.MILLISECOND, value);

      return calendar.getTime();   }

  case(Calendar.SECOND)    : {

    years = calendar.get(Calendar.YEAR);

    months = calendar.get(Calendar.MONTH);

    days = calendar.get(Calendar.DATE);

    hours = calendar.get(Calendar.HOUR_OF_DAY);

    minutes = calendar.get(Calendar.MINUTE);

    calendar.clear(Calendar.MILLISECOND);

    calendar.set(years, months, days, hours, minutes, value);

    return calendar.getTime();

  }

  case(Calendar.MINUTE)    : {

    years = calendar.get(Calendar.YEAR);

    months = calendar.get(Calendar.MONTH);

    days = calendar.get(Calendar.DATE);

    hours = calendar.get(Calendar.HOUR_OF_DAY);

    calendar.clear(Calendar.MILLISECOND);

    calendar.set(years, months, days, hours, value, 0);

    return calendar.getTime();

  }

  case(Calendar.HOUR_OF_DAY)    : {

    years = calendar.get(Calendar.YEAR);

    months = calendar.get(Calendar.MONTH);

    days = calendar.get(Calendar.DATE);

    calendar.clear(Calendar.MILLISECOND);

    calendar.set(years, months, days, value, 0, 0);

    return calendar.getTime();

  }

  case(Calendar.DATE)    : {

    years = calendar.get(Calendar.YEAR);

    months = calendar.get(Calendar.MONTH);

    calendar.clear(Calendar.MILLISECOND);

    calendar.set(years, months, value, 0, 0, 0);

    return calendar.getTime();

  }

  case(Calendar.MONTH)     : {

    years = calendar.get(Calendar.YEAR);

    calendar.clear(Calendar.MILLISECOND);

    calendar.set(years, value, 1, 0, 0, 0);

    return calendar.getTime();

  }

  case(Calendar.YEAR)    : {

    calendar.clear(Calendar.MILLISECOND);

    calendar.set(value, 0, 1, 0, 0, 0);

    return calendar.getTime();

  }

  default: return null;

###
3314, createPieChart, ChartFactory, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ChartFactory.java, 228, 232
11
/**

   * Creates a pie chart with default settings.

   * @param title The chart title.

   * @param data The dataset for the chart.

   * @param legend A flag specifying whether or not a legend is required.

   */
8
  public static JFreeChart createPieChart(String title, PieDataset data, boolean legend) {

    Plot plot = new PiePlot();

    JFreeChart chart = new JFreeChart(data, plot, title, JFreeChart.DEFAULT_TITLE_FONT, legend);

    return chart;

###
3315, setMaximumDate, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 193, 197
7
/**

   * Sets the maximum date visible on the axis.

   * @param maximumDate The new maximum date.

   */
8
  public void setMaximumDate(Date maximumDate) {

  this.maximumDate = maximumDate;

    double millis = (double)maximumDate.getTime();

    this.setMaximumAxisValue(millis);

###
3316, getMinimumDate, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 165, 166
7
/**

   * Returns the earliest date visible on the axis.

   * @return The earliest date visible on the axis.

   */
4
  public Date getMinimumDate() {

  return this.minimumDate;

###
3317, setCrosshairDate, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 240, 244
7
/**

   * Sets the crosshair date for the axis.

   * @param maximumDate The new crosshair date (null permitted).

   */
8
  public void setCrosshairDate(Date crosshairDate) {

  this.crosshairDate = crosshairDate;

    double millis = (double)crosshairDate.getTime();

    this.setCrosshairValue(millis);

###
3318, calculateLowestVisibleTickValue, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 299, 300
7
/**

   * Calculates the value of the lowest visible tick on the axis.

   * @return The value of the lowest visible tick on the axis.

   */
4
  public Date calculateLowestVisibleTickValue(DateUnit unit) {

  return this.nextStandardDate(minimumDate, unit.getField(), unit.getCount());

###
3319, DateAxis, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 77, 100
7
/**

   * Constructs a date axis, using default values where necessary.

   * @param label The axis label.

   */
46
  public DateAxis(String label) {

  this(label,

       Axis.DEFAULT_AXIS_LABEL_FONT,

       Axis.DEFAULT_AXIS_LABEL_PAINT,

       Axis.DEFAULT_AXIS_LABEL_INSETS,

       true, // tick labels visible

       Axis.DEFAULT_TICK_LABEL_FONT,

       Axis.DEFAULT_TICK_LABEL_PAINT,

       Axis.DEFAULT_TICK_LABEL_INSETS,

       true, // tick marks visible

       Axis.DEFAULT_TICK_STROKE,

       true, // auto range

       null, // minimum date

       null, // maximum date

       true, // auto tick unit selection

       new DateUnit(Calendar.DATE, 1),

       new SimpleDateFormat(),

       true, // grid lines visible

       ValueAxis.DEFAULT_GRID_LINE_STROKE,

       ValueAxis.DEFAULT_GRID_LINE_PAINT,

       DEFAULT_CROSSHAIR_DATE,

       ValueAxis.DEFAULT_CROSSHAIR_STROKE,

       ValueAxis.DEFAULT_CROSSHAIR_PAINT);

###
3320, getFillPaint, Bar, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Bar.java, 120, 121
7
/**

   * Returns the Paint object used to fill the bar.

   * @return The Paint used to fill the bar.

   */
4
  public Paint getFillPaint() {

  return fillPaint;

###
3321, setTickUnit, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 280, 283
7
/**

   * Sets the tick unit for the axis.

   * @param unit The new date unit.

   */
6
  public void setTickUnit(DateUnit unit) {

  this.tickUnit = unit;

  this.notifyListeners(new AxisChangeEvent(this));

###
3322, Bar, Bar, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Bar.java, 72, 78
19
/**

   * Full constructor: returns a new Bar object with attributes as defined by the caller.

   * @param x The x-coordinate of the bar;

   * @param y The y-coordinate of the bar;

   * @param width The width of the bar;

   * @param height The height of the bar;

   * @param outlineStroke The Stroke used to draw the outline of the bar;

   * @param outlinePaint The Paint used to draw the outline of the bar;

   * @param fillPaint The Paint used to draw the interior of the bar.

   */
14
  public Bar(double x, double y, double width, double height,

       Stroke outlineStroke, Paint outlinePaint, Paint fillPaint)

  {

  this.area = new Rectangle2D.Double(x, y, width, height);

  this.outlineStroke = outlineStroke;

  this.outlinePaint = outlinePaint;

  this.fillPaint = fillPaint;

###
3323, getAnchorDate, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 252, 253
7
/**

   * Returns the anchor date for the axis.

   * @return The anchor date for the axis (possibly null).

   */
4
  public Date getAnchorDate() {

  return this.anchorDate;

###
3324, Bar, Bar, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Bar.java, 88, 89
13
/**

   * Standard constructor: returns a new Bar object, with some default attributes.

   * @param x The x-coordinate of the bar;

   * @param y The y-coordinate of the bar;

   * @param width The width of the bar;

   * @param height The height of the bar;

   */
4
  public Bar(double x, double y, double width, double height) {

  this(x, y, width, height, new BasicStroke(), Color.gray, Color.green);

###
3325, nextStandardDate, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 398, 403
5
/**

   * Returns the first "standard" date (based on the specified field and units).

   */
12
  protected Date nextStandardDate(Date date, int field, int units) {

  Date previous = previousStandardDate(date, field, units);

  Calendar calendar = Calendar.getInstance();

  calendar.setTime(previous);

  calendar.add(field, units);

  return calendar.getTime();

###
3326, getOutlinePaint, Bar, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Bar.java, 112, 113
7
/**

   * Returns the Paint object used to draw the outline of the bar.

   * @return The Paint used to draw the outline of the bar.

   */
4
  public Paint getOutlinePaint() {

  return outlinePaint;

###
3327, getOutlineStroke, Bar, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Bar.java, 104, 105
7
/**

   * Returns the Stroke object used to draw the outline of the bar.

   * @return The Stroke used to draw the outline of the bar.

   */
4
  public Stroke getOutlineStroke() {

  return outlineStroke;

###
3328, findAxisMagnitudeIndex, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 409, 417
5
/**

   * Returns the index of the largest tick unit that will fit within the axis range.

   */
16
  protected int findAxisMagnitudeIndex() {

  long axisMagnitude = this.maximumDate.getTime()-this.minimumDate.getTime();

  int index = 0;

  while(index<standardTickUnitMagnitudes.length-1) {

    if (axisMagnitude<standardTickUnitMagnitudes[index]) break;

    index++;

  }

  return Math.max(0, index-1);

###
3329, getArea, Bar, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Bar.java, 96, 97
7
/**

   * Returns the rectangle that is the outline of the bar.

   * @return The outline of the bar;

   */
4
  public Rectangle2D getArea() {

  return area;

###
3330, getTickLabelFormatter, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 291, 292
7
/**

   * Returns the formatter for the tick labels.

   * @return The formatter for the tick labels.

   */
4
  public SimpleDateFormat getTickLabelFormatter() {

  return tickLabelFormatter;

###
3331, getCrosshairDate, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 232, 233
7
/**

   * Returns the crosshair date for the axis.

   * @return The crosshair date for the axis (possibly null).

   */
4
  public Date getCrosshairDate() {

  return this.crosshairDate;

###
3332, getTickUnit, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 272, 273
7
/**

   * Returns the tick unit for the axis.

   * @return The tick unit for the axis.

   */
4
  public DateUnit getTickUnit() {

  return tickUnit;

###
3333, getMaximumDate, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 185, 186
7
/**

   * Returns the latest date visible on the axis.

   * @return The latest date visible on the axis.

   */
4
  public Date getMaximumDate() {

  return this.maximumDate;

###
3334, CategoryAxis, CategoryAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/CategoryAxis.java, 91, 102
7
/**

   * Constructs a category axis, using default values where necessary.

   * @param label The axis label.

   */
22
  protected CategoryAxis(String label) {

  this(label,

       Axis.DEFAULT_AXIS_LABEL_FONT,

       Axis.DEFAULT_AXIS_LABEL_PAINT,

       Axis.DEFAULT_AXIS_LABEL_INSETS,

       true, // category labels visible

       Axis.DEFAULT_TICK_LABEL_FONT,

       Axis.DEFAULT_TICK_LABEL_PAINT,

       Axis.DEFAULT_TICK_LABEL_INSETS,

       false, // tick marks visible (not supported anyway)

       Axis.DEFAULT_TICK_STROKE);

###
3335, setAnchorDate, DateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateAxis.java, 260, 264
7
/**

   * Sets the anchor date for the axis.

   * @param anchorDate The new anchor date (null permitted).

   */
8
  public void setAnchorDate(Date anchorDate) {

  this.anchorDate = anchorDate;

    double millis = (double)anchorDate.getTime();

    super.setAnchorValue(millis);

###
3336, CategoryAxis, CategoryAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/CategoryAxis.java, 70, 83
25
/**

   * Constructs a category axis.

   * @param label The axis label.

   * @param labelFont The font for displaying the axis label.

   * @param labelPaint The paint used to draw the axis label.

   * @param labelInsets Determines the amount of blank space around the label.

   * @param categoryLabelsVisible Flag indicating whether or not category labels are visible.

   * @param categoryLabelFont The font used to display category (tick) labels.

   * @param categoryLabelPaint The paint used to draw category (tick) labels.

   * @param categoryLabelInsets The insets for the category labels.

   * @param tickMarksVisible Flag indicating whether or not tick marks are visible.

   * @param tickMarkStroke The stroke used to draw tick marks (if visible).

   */
26
  protected CategoryAxis(String label,

               Font labelFont, Paint labelPaint, Insets labelInsets,

         boolean categoryLabelsVisible,

               Font categoryLabelFont, Paint categoryLabelPaint,

               Insets categoryLabelInsets,

               boolean tickMarksVisible,

               Stroke tickMarkStroke) {

  super(label,

        labelFont, labelPaint, labelInsets,

      categoryLabelsVisible,

        categoryLabelFont, categoryLabelPaint, categoryLabelInsets,

      tickMarksVisible,

        tickMarkStroke);

###
3338, DateTitle, DateTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateTitle.java, 98, 99
5
/**

   * Constructs a new DateTitle with the specified style.

   */
4
  public DateTitle(int dateStyle) {

    this(dateStyle, Locale.getDefault(), new Font("Dialog", Font.PLAIN, 12), Color.black);

###
3339, DateTitle, DateTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateTitle.java, 109, 111
13
/**

   * Constructs a new DateTitle that displays the current date in the default

   * (LONG) format for the locale, positioned to the bottom right of the chart.

   * <P>

   * The color will be black in 12 point, plain Helvetica font (maps to Arial on Win32 systems

   * without Helvetica).

   */
4
  public DateTitle() {

    this(DateFormat.LONG);

###
3340, DateTitle, DateTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateTitle.java, 70, 74
23
/**

   * Constructs a new DateTitle with the specified attributes.

   * @param location the relative location of this title (use constants in AbstractTitle).

   * @param alignment the text alignment of this title (use constants in AbstractTitle).

   * @param dateStyle the Date style to use (SHORT, MEDIUM, LONG, or FULL constants from

   *          java.text.DateFormat).

   * @param locale the locale to use to format this date (if you are unsure what to use here, use

   *         Locale.getDefault() for your default locale).

   * @param font the font used to display the date.

   * @param paint the paint used to display the date.

   * @param insets the blank space around the outside of the title.

   */
8
  public DateTitle(int dateStyle, Locale locale, Font font, Paint paint, int position,

           int horizontalAlignment, int verticalAlignment, Insets insets) {

    super(DateFormat.getDateInstance(dateStyle, locale).format(new Date()),

        font, paint, position, horizontalAlignment, verticalAlignment, insets);

###
3341, DateTitle, DateTitle, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/DateTitle.java, 88, 92
19
/**

   * Constructs a new DateTitle object with the specified attributes and the following defaults:

   * location = BOTTOM, alignment = RIGHT, insets = new Insets(2, 2, 2, 2).

   * @param dateStyle the Date style to use (SHORT, MEDIUM, LONG, or FULL constants from

   *          java.util.DateFormat);

   * @param locale the locale to use to format this date (if you are unsure what to use here, use

   *         Locale.getDefault() for your default locale);

   * @param font the font used to display the date;

   * @param paint the paint used to display the date;

   */
8
  public DateTitle(int dateStyle, Locale locale, Font font, Paint paint) {

    this(dateStyle, locale, font, paint,

       AbstractTitle.BOTTOM, AbstractTitle.RIGHT, AbstractTitle.MIDDLE,

       new Insets(2, 2, 2, 2));

###
3342, setTickLabelFont, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 352, 362
11
/**

   * Sets the font for the tick labels.

   * <P>

   * Registered listeners are notified of a general change to the axis.

   * @param font The new tick label font.

   */
18
  public void setTickLabelFont(Font font) {

    // check arguments...

    if (font==null) {

      throw new IllegalArgumentException("Axis.setTickLabelFont(...): null not permitted.");

    }

    // apply change if necessary...

  if (!this.tickLabelFont.equals(font)) {

    this.tickLabelFont = font;

    notifyListeners(new AxisChangeEvent(this));

###
3343, Axis, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 128, 139
7
/**

   * Constructs an axis, using default values where necessary.

   * @param label The axis label (null permitted).

   */
22
  protected Axis(String label) {

  this(label,

       DEFAULT_AXIS_LABEL_FONT,

       DEFAULT_AXIS_LABEL_PAINT,

       DEFAULT_AXIS_LABEL_INSETS,

       true,  // tick labels visible

       DEFAULT_TICK_LABEL_FONT,

       DEFAULT_TICK_LABEL_PAINT,

       DEFAULT_TICK_LABEL_INSETS,

       true,  // tick marks visible

       DEFAULT_TICK_STROKE);

###
3344, getLabelInsets, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 299, 300
7
/**

   * Returns the insets for the label (that is, the amount of blank space that should be left

   * around the label).

   */
4
  public Insets getLabelInsets() {

  return this.labelInsets;

###
3345, notifyListeners, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 533, 537
9
/**

   * Notifies all registered listeners that the axis has changed.  The AxisChangeEvent provides

   * information about the change.

   * @param event Information about the change to the axis.

   */
10
  protected void notifyListeners(AxisChangeEvent event) {

  java.util.Iterator iterator = listeners.iterator();

  while (iterator.hasNext()) {

    AxisChangeListener listener = (AxisChangeListener)iterator.next();

    listener.axisChanged(event);

###
3346, getLabelPaint, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 270, 271
7
/**

   * Returns the color/shade used to draw the axis label.

   * @return The color/shade used to draw the axis label.

   */
4
  public Paint getLabelPaint() {

  return this.labelPaint;

###
3347, setLabel, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 219, 231
11
/**

   * Sets the label for the axis.

   * <P>

   * Registered listeners are notified of a general change to the axis.

   * @param label The new label for the axis (null permitted).

   */
24
  public void setLabel(String label) {

    String existing = this.label;

    if (existing!=null) {

    if (!existing.equals(label)) {

      this.label = label;

      notifyListeners(new AxisChangeEvent(this));

    }

    }

    else {

      if (label!=null) {

      this.label = label;

      notifyListeners(new AxisChangeEvent(this));

###
3348, getTickLabelFont, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 342, 343
7
/**

   * Returns the font used for the tick labels (if showing).

   * @return The font used for the tick labels.

   */
4
  public Font getTickLabelFont() {

  return tickLabelFont;

###
3349, setTickMarksVisible, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 437, 441
11
/**

   * Sets the flag that indicates whether or not the tick marks are showing.

   * <P>

   * Registered listeners are notified of a general change to the axis.

   * @param flag The flag.

   */
8
  public void setTickMarksVisible(boolean flag) {

  if (flag!=tickMarksVisible) {

    tickMarksVisible = flag;

    notifyListeners(new AxisChangeEvent(this));

###
3350, setTickLabelPaint, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 381, 391
11
/**

   * Sets the color/shade used to draw tick labels (if they are showing).

   * <P>

   * Registered listeners are notified of a general change to the axis.

   * @param paint The new color/shade.

   */
18
  public void setTickLabelPaint(Paint paint) {

    // check arguments...

    if (paint==null) {

      throw new IllegalArgumentException("Axis.setTickLabelPaint(...): null not permitted.");

    }

    // make the change (if necessary)...

  if (!this.tickLabelPaint.equals(paint)) {

    this.tickLabelPaint = paint;

    notifyListeners(new AxisChangeEvent(this));

###
3351, setLabelFont, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 251, 261
11
/**

   * Sets the font for the axis label.

   * <P>

   * Registered listeners are notified of a general change to the axis.

   * @param font The new label font.

   */
18
  public void setLabelFont(Font font) {

    // check arguments...

    if (font==null) {

      throw new IllegalArgumentException("Axis.setLabelFont(...): null not permitted.");

    }

    // make the change (if necessary)...

  if (!this.labelFont.equals(font)) {

    this.labelFont = font;

    notifyListeners(new AxisChangeEvent(this));

###
3352, isTickLabelsVisible, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 319, 320
7
/**

   * Returns a flag indicating whether or not the tick labels are visible.

   * @return A flag indicating whether or not the tick labels are visible.

   */
4
  public boolean isTickLabelsVisible() {

  return tickLabelsVisible;

###
3353, isTickMarksVisible, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 427, 428
7
/**

   * Returns the flag that indicates whether or not the tick marks are showing.

   * @return The flag that indicates whether or not the tick marks are showing.

   */
4
  public boolean isTickMarksVisible() {

  return tickMarksVisible;

###
3354, getTickLabelInsets, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 400, 401
7
/**

   * Returns the insets for the tick labels.

   * @return The insets for the tick labels.

   */
4
  public Insets getTickLabelInsets() {

  return this.tickLabelInsets;

###
3355, Axis, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 156, 174
25
/**

   * Constructs an axis.

   * @param label The axis label.

   * @param labelFont The font for displaying the axis label.

   * @param labelPaint The paint used to draw the axis label.

   * @param labelInsets Determines the amount of blank space around the label.

   * @param tickLabelsVisible Flag indicating whether or not the tick labels are visible.

   * @param tickLabelFont The font used to display tick labels.

   * @param tickLabelPaint The paint used to draw tick labels.

   * @param tickLabelInsets Determines the amount of blank space around tick labels.

   * @param tickMarksVisible Flag indicating whether or not tick marks are visible.

   * @param tickMarkStroke The stroke used to draw tick marks (if visible).

   */
34
  protected Axis(String label,

           Font labelFont, Paint labelPaint, Insets labelInsets,

       boolean tickLabelsVisible,

           Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,

       boolean tickMarkVisible, Stroke tickMarkStroke) {

  this.label = label;

  this.labelFont = labelFont;

  this.labelPaint = labelPaint;

  this.labelInsets = labelInsets;

  this.tickLabelsVisible = tickLabelsVisible;

  this.tickLabelFont = tickLabelFont;

  this.tickLabelPaint = tickLabelPaint;

  this.tickLabelInsets = tickLabelInsets;

  this.tickMarksVisible = tickMarksVisible;

  this.tickMarkStroke = tickMarkStroke;

  this.ticks = new java.util.ArrayList();

  this.listeners = new java.util.ArrayList();

###
3356, addChangeListener, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 545, 546
7
/**

   * Registers an object for notification of changes to the axis.

   * @param listener The object that is being registered.

   */
4
  public void addChangeListener(AxisChangeListener listener) {

  listeners.add(listener);

###
3357, drawVerticalString, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 564, 573
13
/**

   * A utility method for drawing text vertically.

   * @param text The text.

   * @param g2 The graphics device.

   * @param x The x-coordinate.

   * @param y The y-coordinate.

   */
14
  protected void drawVerticalString(String text, Graphics2D g2, float x, float y) {

  AffineTransform saved = g2.getTransform();

  // apply a 90 degree rotation

  AffineTransform rotate = AffineTransform.getRotateInstance(-Math.PI/2, x, y);

  g2.transform(rotate);

  g2.drawString(text, x, y);

  g2.setTransform(saved);

###
3359, setTickMarkStroke, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 460, 470
11
/**

   * Sets the pen/brush used to draw tick marks (if they are showing).

   * <P>

   * Registered listeners are notified of a general change to the axis.

   * @param stroke The new pen/brush (null not permitted).

   */
18
  public void setTickMarkStroke(Stroke stroke) {

    // check arguments...

    if (stroke==null) {

      throw new IllegalArgumentException("Axis.setTickMarkStroke(...): null not permitted.");

    }

    // make the change (if necessary)...

  if (!this.tickMarkStroke.equals(stroke)) {

    this.tickMarkStroke = stroke;

    notifyListeners(new AxisChangeEvent(this));

###
3360, setLabelInsets, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 308, 311
9
/**

   * Sets the insets for the axis label, and notifies registered listeners that the axis has been

   * modified.

   * @param insets The new label insets;

   */
8
  public void setLabelInsets(Insets insets) {

  if (!insets.equals(this.labelInsets)) {

    this.labelInsets = insets;

    notifyListeners(new AxisChangeEvent(this));

###
3361, setLabelPaint, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 280, 290
11
/**

   * Sets the color/shade used to draw the axis label.

   * <P>

   * Registered listeners are notified of a general change to the axis.

   * @param paint The new color/shade for the axis label.

   */
18
  public void setLabelPaint(Paint paint) {

    // check arguments...

    if (paint==null) {

      throw new IllegalArgumentException("Axis.setLabelPaint(...): null not permitted.");

    }

    // make the change (if necessary)...

  if (!this.labelPaint.equals(paint)) {

    this.labelPaint = paint;

    notifyListeners(new AxisChangeEvent(this));

###
3362, setTickLabelsVisible, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 329, 333
11
/**

   * Sets the flag that determines whether or not the tick labels are visible.

   * <P>

   * Registered listeners are notified of a general change to the axis.

   * @param flag The flag.

   */
8
  public void setTickLabelsVisible(boolean flag) {

  if (flag!=tickLabelsVisible) {

    tickLabelsVisible = flag;

    notifyListeners(new AxisChangeEvent(this));

###
3364, setPlot, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 195, 201
13
/**

   * Sets a reference to the plot that the axis is assigned to.

   * <P>

   * This method is called by Plot in the setHorizontalAxis() and setVerticalAxis() methods.

   * You shouldn't need to call the method yourself.

   * @param plot The plot that the axis belongs to.

   */
12
  public void setPlot(Plot plot) throws PlotNotCompatibleException {

    if (this.isCompatiblePlot(plot) || plot == null) {

    this.plot = plot;

    }

    else throw new PlotNotCompatibleException("Axis.setPlot(...): "

                         +"plot not compatible with axis.");

###
3365, getLabel, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 209, 210
7
/**

   * Returns the label for the axis.

   * @return The label for the axis (null possible).

   */
4
  public String getLabel() {

  return label;

###
3366, getMaxTickLabelWidth, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 503, 517
11
/**

   * Returns the maximum width of the ticks in the working list (that is set up by

   * refreshTicks()).

   * @param g2 The graphics device.

   * @param plotArea The area within which the plot is to be drawn.

   */
26
  protected double getMaxTickLabelWidth(Graphics2D g2, Rectangle2D plotArea) {

  double maxWidth = 0.0;

  Font font = getTickLabelFont();

  FontRenderContext frc = g2.getFontRenderContext();

  Iterator iterator = this.ticks.iterator();

  while (iterator.hasNext()) {

    Tick tick = (Tick)iterator.next();

    Rectangle2D labelBounds = font.getStringBounds(tick.getText(), frc);

    if (labelBounds.getWidth()>maxWidth) {

    maxWidth = labelBounds.getWidth();

    }

  }

  return maxWidth;

###
3367, removeChangeListener, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 553, 554
7
/**

   * Deregisters an object for notification of changes to the axis.

   * @param listener The object to deregister.

   */
4
  public void removeChangeListener(AxisChangeListener listener) {

  listeners.remove(listener);

###
3369, getPlot, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 184, 185
11
/**

   * Returns the plot that the axis is assigned to.

   * <P>

   * This method will return null if the axis is not currently assigned to a plot.

   * @return The plot that the axis is assigned to.

   */
4
  public Plot getPlot() {

  return plot;

###
3370, getTickMarkStroke, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 450, 451
7
/**

   * Returns the pen/brush used to draw tick marks (if they are showing).

   * @return The pen/brush used to draw tick marks.

   */
4
  public Stroke getTickMarkStroke() {

  return tickMarkStroke;

###
3372, setTickLabelInsets, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 409, 419
9
/**

   * Sets the insets for the tick labels, and notifies registered listeners that the axis has

   * been modified.

   * @param insets The new tick label insets.

   */
18
  public void setTickLabelInsets(Insets insets) {

    // check arguments...

    if (insets==null) {

      throw new IllegalArgumentException("Axis.setTickLabelInsets(...): null not permitted.");

    }

    // apply change if necessary...

  if (!this.tickLabelInsets.equals(insets)) {

    this.tickLabelInsets = insets;

    notifyListeners(new AxisChangeEvent(this));

###
3373, getLabelFont, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 241, 242
7
/**

   * Returns the font for the axis label.

   * @return The font for the axis label.

   */
4
  public Font getLabelFont() {

  return labelFont;

###
3374, getTickLabelPaint, Axis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Axis.java, 371, 372
7
/**

   * Returns the color/shade used for the tick labels.

   * @return The color/shade used for the tick labels.

   */
4
  public Paint getTickLabelPaint() {

  return this.tickLabelPaint;

###
3375, getItemGapsPercent, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 270, 271
7
/**

   * Returns the percentage of the drawing space that is allocated to providing gaps between the

   * items in a category.

   */
4
  public double getItemGapsPercent() {

  return itemGapsPercent;

###
3376, setHorizontalAxis, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 173, 174
7
/**

   * Sets the horizontal axis for the plot.

   * @param axis The new axis.

   */
4
  public void setHorizontalAxis(Axis axis) {

  super.setHorizontalAxis(axis);

###
3377, BarPlot, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 136, 149
25
/**

   * Constructs a bar plot.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   * @param introGapPercent The gap before the first bar in the plot, as a percentage of the

   *            available drawing space.

   * @param trailGapPercent The gap after the last bar in the plot, as a percentage of the

   *            available drawing space.

   * @param categoryGapsPercent The percentage of drawing space allocated to the gap between the

   *              last bar in one category and the first bar in the next category.

   * @param itemGapsPercent The gap between bars within the same category.

   * @param toolTipGenerator The tool tip generator.

   */
24
  protected BarPlot(Axis horizontalAxis, Axis verticalAxis,

            Insets insets,

        double introGapPercent, double trailGapPercent,

            double categoryGapsPercent, double itemGapsPercent,

            CategoryToolTipGenerator toolTipGenerator) {

  super(horizontalAxis, verticalAxis);

    this.insets = insets;

  this.introGapPercent = introGapPercent;

  this.trailGapPercent = trailGapPercent;

  this.categoryGapsPercent = categoryGapsPercent;

  this.itemGapsPercent = itemGapsPercent;

    this.toolTipGenerator = toolTipGenerator;

###
3378, setCategoryGapsPercent, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 250, 261
11
/**

   * Sets the gap between the last bar in one category and the first bar in the

   * next category, and notifies registered listeners that the plot has been modified.

   * @param percent The new gap value, expressed as a percentage of the width of the plot area

   *        (0.05 = 5 percent).

   */
20
  public void setCategoryGapsPercent(double percent) {

    // check argument...

    if ((percent<0.0) || (percent>MAX_CATEGORY_GAPS_PERCENT)) {

      throw new IllegalArgumentException("BarPlot.setCategoryGapsPercent(double): argument "

                        +"outside valid range.");

    }

    // make the change...

  if (this.categoryGapsPercent!=percent) {

      this.categoryGapsPercent=percent;

    notifyListeners(new PlotChangeEvent(this));

###
3379, setVerticalAxis, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 165, 166
7
/**

   * Sets the vertical axis for the plot.

   * @param axis The new axis.

   */
4
  public void setVerticalAxis(Axis axis) {

  super.setVerticalAxis(axis);

###
3380, getDataset, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 157, 158
7
/**

   * A convenience method that returns the dataset for the plot, cast as a

   * CategoryDataset.

   */
4
  public CategoryDataset getDataset() {

  return (CategoryDataset)chart.getDataset();

###
3381, setTrailGapPercent, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 220, 231
11
/**

   * Sets the gap after the last bar on the chart, and notifies registered listeners that the plot

   * has been modified.

   * @param percent The new gap value, expressed as a percentage of the width of the plot area

   *        (0.05 = 5 percent).

   */
20
  public void setTrailGapPercent(double percent) {

    // check argument...

    if ((percent<0.0) || (percent>MAX_TRAIL_GAP_PERCENT)) {

      throw new IllegalArgumentException("BarPlot.setTrailGapPercent(double): argument "

                        +"outside valid range.");

    }

    // make the change...

  if (this.trailGapPercent!=percent) {

      trailGapPercent = percent;

    notifyListeners(new PlotChangeEvent(this));

###
3382, getTrailGapPercent, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 210, 211
7
/**

   * Returns the gap following the last bar on the chart, as a percentage of the available

   * drawing space.

   */
4
  public double getTrailGapPercent() {

  return trailGapPercent;

###
3383, getIntroGapPercent, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 181, 182
7
/**

   * Returns the gap before the first bar on the chart, as a percentage of the available drawing

   * space (0.05 = 5 percent).

   */
4
  public double getIntroGapPercent() {

  return introGapPercent;

###
3384, setIntroGapPercent, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 191, 202
11
/**

   * Sets the gap before the first bar on the chart, and notifies registered listeners that the

   * plot has been modified.

   * @param percent The new gap value, expressed as a percentage of the width of the plot area

   *        (0.05 = 5 percent).

   */
20
  public void setIntroGapPercent(double percent) {

    // check argument...

    if ((percent<0.0) || (percent>MAX_INTRO_GAP_PERCENT)) {

      throw new IllegalArgumentException("BarPlot.setIntroGapPercent(double): argument "

                        +"outside valid range.");

    }

    // make the change...

  if (this.introGapPercent!=percent) {

      this.introGapPercent = percent;

    notifyListeners(new PlotChangeEvent(this));

###
3385, setItemGapsPercent, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 280, 291
11
/**

   * Sets the gap between one bar and the next within the same category, and notifies registered

   * listeners that the plot has been modified.

   * @param percent The new gap value, expressed as a percentage of the width of the plot area

   *        (0.05 = 5 percent).

   */
20
  public void setItemGapsPercent(double percent) {

    // check argument...

    if ((percent<0.0) || (percent>MAX_ITEM_GAPS_PERCENT)) {

      throw new IllegalArgumentException("BarPlot.setItemGapsPercent(double): argument "

                        +"outside valid range.");

    }

    // make the change...

  if (percent!=this.itemGapsPercent) {

      this.itemGapsPercent = percent;

    notifyListeners(new PlotChangeEvent(this));

###
3386, BarPlot, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 111, 119
9
/**

   * Constructs a bar plot, using default values where necessary.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   */
16
  protected BarPlot(Axis horizontalAxis, Axis verticalAxis) {

  this(horizontalAxis, verticalAxis,

       Plot.DEFAULT_INSETS,

       DEFAULT_INTRO_GAP_PERCENT,

       DEFAULT_TRAIL_GAP_PERCENT,

       DEFAULT_CATEGORY_GAPS_PERCENT,

       DEFAULT_ITEM_GAPS_PERCENT,

       null);  // tool tip generator

###
3387, getCategoryGapsPercent, BarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/BarPlot.java, 240, 241
7
/**

   * Returns the percentage of the drawing space that is allocated to providing gaps between the

   * categories.

   */
4
  public double getCategoryGapsPercent() {

  return categoryGapsPercent;

###
3390, PeriodMarkerPlot, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 55, 58
1
/** Creates new SignalsPlot */
6
  public PeriodMarkerPlot(Axis horizontal, Axis vertical) throws AxisNotCompatibleException,

                                   PlotNotCompatibleException {

      super(horizontal, vertical);

###
3391, isCompatibleVerticalAxis, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 100, 105
11
/**

   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with

   * the plot, and false otherwise.  The vertical axis for this plot must be an instance of

   * VerticalNumberAxis.

   * @param axis The vertical axis.

   */
12
  public boolean isCompatibleVerticalAxis(Axis axis)

  {

  if (axis instanceof VerticalNumberAxis)

    return true;

  else

    return false;

###
3392, draw, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 195, 234
9
/**

   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).

   * @param g2 The graphics device;

   * @param drawArea The area within which the plot should be drawn;

   */
62
  public void draw(Graphics2D g2, Rectangle2D drawArea, DrawInfo info){

    if (insets!=null) {

      drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,

                        drawArea.getY()+insets.top,

                        drawArea.getWidth()-insets.left-insets.right,

                        drawArea.getHeight()-insets.top-insets.bottom);

    }

    // we can cast the axes because HiLowPlot enforces support of these interfaces

    HorizontalAxis ha = getHorizontalAxis();

    VerticalAxis va = getVerticalAxis();

    double h = ha.reserveHeight(g2, this, drawArea);

    Rectangle2D vAxisArea = va.reserveAxisArea(g2, this, drawArea, h);

    // compute the plot area

    Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),

                            drawArea.getY(),

                            drawArea.getWidth()-vAxisArea.getWidth(),

                            drawArea.getHeight()-h);

    drawOutlineAndBackground(g2, plotArea);

    // draw the axes

    this.horizontalAxis.draw(g2, drawArea, plotArea);

    this.verticalAxis.draw(g2, drawArea, plotArea);

    Shape originalClip = g2.getClip();

    g2.clip(plotArea);

    //SignalsDataset data = getDataset();

    XYDataset data = getTempXYDataset();

    if( data!= null ){

      int seriesCount = data.getSeriesCount();

      for(int serie=0; serie<seriesCount; serie++)

        drawMarkedPeriods(data, serie, g2, plotArea);   // area should be remaining area only

    }

    g2.setClip(originalClip);

###
3393, getMinimumHorizontalDataValue, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 130, 147
7
/**

   * Returns the minimum value in the domain, since this is plotted against the horizontal axis

   * for a HighLowPlot.

   */
32
  public Number getMinimumHorizontalDataValue() {

  //SignalsDataset data = getDataset();

    XYDataset data = getTempXYDataset();

  if( data ==null )

      return null;

    long minimum = Long.MAX_VALUE;

    int seriesCount = data.getSeriesCount();

    for (int series=0; series<seriesCount; series++) {

      int itemCount = data.getItemCount(series);

      for(int itemIndex = 0; itemIndex < itemCount; itemIndex++){

        Number value = data.getXValue(series, itemIndex); // Adjust with type to make room for the symbols

        if (value!=null)

          minimum = Math.min(minimum, value.longValue());

      }

    }

    return new Long(minimum);

###
3394, getTempXYDataset, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 75, 76
5
/**

   * A convenience method that returns the dataset for the plot, cast as an HighLowDataset.

   */
4
  public XYDataset getTempXYDataset() { // Usefull until SignalsDataset is included in jcommon.SubSeriesDataset

  return (XYDataset)chart.getDataset();

###
3395, getHorizontalValueAxis, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 112, 114
7
/**

   * A convenience method that returns a reference to the horizontal axis cast as a

   * HorizontalValueAxis.

   */
6
  public ValueAxis getHorizontalValueAxis()

  {

    return (ValueAxis)horizontalAxis;

###
3396, getMaximumVerticalDataValue, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 186, 187
7
/**

   * Returns the maximum value in the range, since this is plotted against the vertical axis for

   * a HighLowPlot.

   */
4
  public Number getMaximumVerticalDataValue() {

    return null; //new Double(Double.NEGATIVE_INFINITY); doesn't work (??)

###
3397, getVerticalValueAxis, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 121, 123
7
/**

   * A convenience method that returns a reference to the vertical axis cast as a

   * VerticalNumberAxis.

   */
6
  public ValueAxis getVerticalValueAxis()

  {

    return (ValueAxis)verticalAxis;

###
3398, getPlotType, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 65, 66
5
/**

   * Returns the plot type as a string. This implementation returns "HiLow Plot".

   */
4
  public String getPlotType() {

      return "Period Marker Plot";

###
3399, isCompatibleHorizontalAxis, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 84, 91
10
/**

   * Checks the compatibility of a horizontal axis, returning true if the axis is compatible with

   * the plot, and false otherwise.

   * @param axis The horizontal axis.

   */

16
  public boolean isCompatibleHorizontalAxis(Axis axis) {

  if (axis instanceof HorizontalNumberAxis) {

    return true;

  }

  else if (axis instanceof HorizontalDateAxis) {

    return true;

  }

    else return false;

###
3400, getMaximumHorizontalDataValue, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 154, 171
7
/**

   * Returns the maximum value in the domain, since this is plotted against the horizontal axis

   * for a HighLowPlot.

   */
32
  public Number getMaximumHorizontalDataValue() {

     //SignalsDataset data = getDataset();

    XYDataset data = getTempXYDataset();

  if( data ==null )

      return null;

    long maximum = Long.MIN_VALUE;

    int seriesCount = data.getSeriesCount();

    for (int series=0; series<seriesCount; series++) {

      int itemCount = data.getItemCount(series);

      for(int itemIndex = 0; itemIndex < itemCount; itemIndex++){

        Number value = data.getXValue(series, itemIndex); // Adjust with type to make room for the symbols

        if (value!=null)

          maximum = Math.max(maximum, value.longValue());

      }

    }

    return new Long(maximum);

###
3401, getMinimumVerticalDataValue, PeriodMarkerPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PeriodMarkerPlot.java, 178, 179
7
/**

   * Returns the minimum value in the range, since this is plotted against the vertical axis for

   * a HighLowPlot.

   */
4
  public Number getMinimumVerticalDataValue() {

    return new Double(Double.POSITIVE_INFINITY); // null doesn't work (??)

###
3402, LinePlot, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 93, 98
11
/**

   * Constructs a line plot.

   * @param chart The chart that the plot belongs to.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   */
10
  public LinePlot(Axis horizontalAxis, Axis verticalAxis) {

  super(horizontalAxis, verticalAxis);

    this.renderer = new LineAndShapeRenderer(LineAndShapeRenderer.SHAPES_AND_LINES);

    this.introGapPercent = DEFAULT_INTRO_GAP;

    this.trailGapPercent = DEFAULT_TRAIL_GAP;

###
3403, getCategoryAxis, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 169, 170
7
/**

   * A convenience method that returns a reference to the horizontal axis cast as a

   * CategoryAxis.

   */
4
  public CategoryAxis getCategoryAxis() {

  return (CategoryAxis)horizontalAxis;

###
3404, getIntroGapPercent, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 106, 107
7
/**

   * Returns the intro gap.

   * @return The intro gap as a percentage of the available width.

   */
4
  public double getIntroGapPercent() {

    return this.introGapPercent;

###
3405, getCategoryCoordinate, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 193, 214
9
/**

   * Returns the x-coordinate (in Java 2D User Space) of the center of the specified category.

   * @param category The category (zero-based index).

   * @param area The region within which the plot will be drawn.

   */
38
  public double getCategoryCoordinate(int category, Rectangle2D area) {

    // check arguments...

  int count = getDataset().getCategoryCount();

    if ((category<0) || (category>=count)) {

      throw new IllegalArgumentException("LinePlot.getCategoryCoordinate(...): "

                         +"category outside valid range.");

    }

    if (area==null) {

      throw new IllegalArgumentException("LinePlot.getCategoryCoordinate(...): "

                         +"null area not permitted.");

    }

    // calculate result...

    double result = area.getX() + area.getWidth()/2;

    if (count>1) {

      double available = area.getWidth() * (1-introGapPercent-trailGapPercent);

    result = area.getX()+(introGapPercent*area.getWidth())

                +(category*1.0/(count-1.0))*available;

    }

    return result;

###
3406, getMinimumVerticalDataValue, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 315, 321
7
/**

   * Returns the minimum value in the range, since this is plotted against the vertical axis for

   * LinePlot.

   */
12
  public Number getMinimumVerticalDataValue() {

  Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMinimumRangeValue(data);

  }

  else return null;

###
3407, setIntroGapPercent, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 114, 125
7
/**

   * Sets the intro gap.

   * @param The gap as a percentage of the total width.

   */
20
  public void setIntroGapPercent(double percent) {

    // check arguments...

    if ((percent<=0.0) || (percent>MAX_INTRO_GAP)) {

      throw new IllegalArgumentException("LinePlot.setIntroGapPercent(double): "

                         +"gap percent outside valid range.");

    }

    // make the change...

    if (introGapPercent!=percent) {

      introGapPercent = percent;

      notifyListeners(new PlotChangeEvent(this));

###
3408, getDataset, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 161, 162
5
/**

   * A convenience method that returns the dataset for the plot, cast as a CategoryDataset.

   */
4
  public CategoryDataset getDataset() {

  return (CategoryDataset)chart.getDataset();

###
3409, setTrailGapPercent, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 142, 153
7
/**

   * Sets the trail gap.

   * @param The gap as a percentage of the total width.

   */
20
  public void setTrailGapPercent(double percent) {

    // check arguments...

    if ((percent<=0.0) || (percent>MAX_TRAIL_GAP)) {

      throw new IllegalArgumentException("LinePlot.setTrailGapPercent(double): "

                         +"gap percent outside valid range.");

    }

    // make the change...

    if (trailGapPercent!=percent) {

      trailGapPercent = percent;

      notifyListeners(new PlotChangeEvent(this));

###
3410, getValueAxis, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 177, 178
7
/**

   * A convenience method that returns a reference to the vertical axis cast as a

   * VerticalNumberAxis.

   */
4
  public VerticalNumberAxis getValueAxis() {

  return (VerticalNumberAxis)verticalAxis;

###
3411, getTrailGapPercent, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 134, 135
7
/**

   * Returns the trail gap.

   * @return The trail gap as a percentage of the available width.

   */
4
  public double getTrailGapPercent() {

    return this.introGapPercent;

###
3412, isCompatibleHorizontalAxis, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 223, 227
9
/**

   * Checks the compatibility of a horizontal axis, returning true if the axis is compatible with

   * the plot, and false otherwise.

   * @param axis The horizontal axis.

   */
10
  public boolean isCompatibleHorizontalAxis(Axis axis) {

  if (axis instanceof CategoryAxis) {

    return true;

  }

  else return false;

###
3413, isCompatibleVerticalAxis, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 235, 239
9
/**

   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with

   * the plot, and false otherwise.

   * @param axis The vertical axis;

   */
10
  public boolean isCompatibleVerticalAxis(Axis axis) {

  if (axis instanceof VerticalNumberAxis) {

    return true;

  }

  else return false;

###
3414, getCategories, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 184, 185
5
/**

   * A convenience method that returns a list of the categories in the data source.

   */
4
  public java.util.List getCategories() {

  return getDataset().getCategories();

###
3415, getPlotType, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 307, 308
5
/**

   * Returns a short string describing the plot type;

   */
4
  public String getPlotType() {

  return "Line Plot";

###
3416, draw, LinePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LinePlot.java, 248, 299
11
/**

   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).

   * @param g2 The graphics device.

   * @param drawArea The area within which the plot should be drawn.

   * @param info Collects info about the drawing.

   */
84
  public void draw(Graphics2D g2, Rectangle2D drawArea, DrawInfo info) {

    // adjust the drawing area for the plot insets (if any)...

  if (insets!=null) {

    drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,

              drawArea.getY()+insets.top,

              drawArea.getWidth()-insets.left-insets.right,

              drawArea.getHeight()-insets.top-insets.bottom);

  }

  // estimate the area required for drawing the axes...

  HorizontalAxis hAxis = getHorizontalAxis();

  VerticalAxis vAxis = getVerticalAxis();

  double hAxisAreaHeight = hAxis.reserveHeight(g2, this, drawArea);

  Rectangle2D vAxisArea = vAxis.reserveAxisArea(g2, this, drawArea, hAxisAreaHeight);

  // and thus the area available for plotting...

  Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),

                drawArea.getY(),

                drawArea.getWidth()-vAxisArea.getWidth(),

                drawArea.getHeight()-hAxisAreaHeight);

    // draw the background and axes...

  drawOutlineAndBackground(g2, plotArea);

  getCategoryAxis().draw(g2, drawArea, plotArea);

  getValueAxis().draw(g2, drawArea, plotArea);

    // now get the data and plot the lines (or shapes, or lines and shapes)...

    CategoryDataset data = this.getDataset();

    if (data!=null) {

      Shape originalClip=g2.getClip();

    g2.clip(plotArea);

    int seriesCount = data.getSeriesCount();

      int categoryCount = data.getCategoryCount();

      int categoryIndex = 0;

      Object previousCategory = null;

      Iterator iterator = data.getCategories().iterator();

      while (iterator.hasNext()) {

        Object category = iterator.next();

        for (int series=0; series<seriesCount; series++) {

          renderer.drawCategoryItem(g2, plotArea, this, getValueAxis(), data,

                        series, category, categoryIndex, previousCategory);

        }

        previousCategory = category;

        categoryIndex++;

      }

    g2.setClip(originalClip);

###
3417, getTickUnit, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 349, 350
7
/**

   * Returns the tick unit for the axis.

   * @return The tick unit for the axis.

   */
4
  public NumberTickUnit getTickUnit() {

    return this.tickUnit;

###
3418, valueToString, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 370, 373
5
/**

   * Converts a value to a string, using the current format for the tick labels on the axis.

   */
6
  public String valueToString(double value) {

    // is there an override format?

    return this.tickUnit.formatter.format(value);

###
3419, setAutoRangeIncludesZero, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 257, 260
9
/**

   * Sets the flag that indicates whether or not the automatic axis range is forced to include

   * zero.

   * @param flag The new value of the flag;

   */
8
  public void setAutoRangeIncludesZero(boolean flag) {

  if (autoRangeIncludesZero!=flag) {

    this.autoRangeIncludesZero = flag;

    notifyListeners(new AxisChangeEvent(this));

###
3420, getStandardTickUnits, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 332, 333
11
/**

   * Returns the standard tick units for the axis.

   * <P>

   * If autoTickUnitSelection is on, the tick unit for the axis will be automatically selected

   * from this collection.

   */
4
  public TickUnits getStandardTickUnits() {

    return this.standardTickUnits;

###
3421, setLowerMargin, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 321, 323
7
/**

   * Sets the lower margin.

   * @param margin The new margin;

   */
6
  public void setLowerMargin(double margin) {

    this.lowerMargin = margin;

    notifyListeners(new AxisChangeEvent(this));

###
3422, calculateLowestVisibleTickValue, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 381, 386
7
/**

   * Calculates the value of the lowest visible tick on the axis.

   * @return The value of the lowest visible tick on the axis.

   */
10
  public double calculateLowestVisibleTickValue() {

  //double min = minimumAxisValue.doubleValue();

  double unit = getTickUnit().getValue().doubleValue();

  double index = Math.ceil(minimumAxisValue/unit);

  return index*unit;

###
3423, getUpperMargin, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 296, 297
7
/**

   * Returns the margin (as a percentage of the range) by which the maximum axis value exceeds

   * the maximum data value.

   */
4
  public double getUpperMargin() {

    return this.upperMargin;

###
3424, setStandardTickUnits, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 340, 342
7
/**

   * Sets the standard tick units for the axis.

   * @param units The tick units.

   */
6
  public void setStandardTickUnits(TickUnits units) {

    this.standardTickUnits = units;

    notifyListeners(new AxisChangeEvent(this));

###
3425, setUpperMargin, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 304, 306
7
/**

   * Sets the upper margin.

   * @param margin The new margin;

   */
6
  public void setUpperMargin(double margin) {

    this.upperMargin = margin;

    notifyListeners(new AxisChangeEvent(this));

###
3426, autoRangeIncludesZero, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 248, 249
7
/**

   * Returns the flag that indicates whether or not the automatic axis range (if indeed it is

   * determined automatically) is forced to include zero.

   */
4
  public boolean autoRangeIncludesZero() {

  return this.autoRangeIncludesZero;

###
3427, setTickUnit, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 360, 363
13
/**

   * Sets the tick unit for the axis.

   * <P>

   * Registered listeners are notified that the axis has been changed.  This method also sets the

   * AutoTickUnit property to false.

   * @param unit The new tick unit.

   */
6
  public void setTickUnit(NumberTickUnit unit) {

    this.autoTickUnitSelection = false;

    this.tickUnit = unit;

###
3428, NumberAxis, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 109, 134
7
/**

   * Constructs a number axis, using default values where necessary.

   * @param label The axis label.

   */
50
  protected NumberAxis(String label) {

  this(label,

       Axis.DEFAULT_AXIS_LABEL_FONT,

       Axis.DEFAULT_AXIS_LABEL_PAINT,

       Axis.DEFAULT_AXIS_LABEL_INSETS,

       true, // tick labels visible

       Axis.DEFAULT_TICK_LABEL_FONT,

       Axis.DEFAULT_TICK_LABEL_PAINT,

       Axis.DEFAULT_TICK_LABEL_INSETS,

       true, // tick marks visible

       Axis.DEFAULT_TICK_STROKE,

       true, // auto range

       true, // auto range includes zero

       NumberAxis.DEFAULT_MINIMUM_AUTO_RANGE,

       ValueAxis.DEFAULT_MINIMUM_AXIS_VALUE,

       ValueAxis.DEFAULT_MAXIMUM_AXIS_VALUE,

       false, // inverted

       true, // auto tick unit

       NumberAxis.DEFAULT_TICK_UNIT,

       true, // grid lines visible

       ValueAxis.DEFAULT_GRID_LINE_STROKE,

       ValueAxis.DEFAULT_GRID_LINE_PAINT,

       0.0,  // crosshair value

       ValueAxis.DEFAULT_CROSSHAIR_STROKE,

       ValueAxis.DEFAULT_CROSSHAIR_PAINT);

###
3429, NumberAxis, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 167, 227
57
/**

   * Constructs a number axis.

   * @param label The axis label.

   * @param labelFont The font for displaying the axis label.

   * @param labelPaint The paint used to display the axis label.

   * @param labelInsets The amount of blank space around the axis label.

   * @param tickLabelsVisible Flag indicating whether or not the tick labels are visible.

   * @param tickLabelFont The font used to display the tick labels.

   * @param tickLabelPaint The paint used to draw the tick labels.

   * @param tickLabelInsets The amount of blank space around the tick labels.

   * @param tickMarksVisible Flag indicating whether or not tick marks are visible;

   * @param tickMarkStroke The stroke used to draw the tick marks (if visible);

   * @param autoRange Flag indicating whether or not the axis range is automatically determined.

   * @param autoRangeIncludesZero A flag indicating whether the auto range must include zero.

   * @param autoRangeMinimumSize The minimum size for the auto range.

   * @param minimumAxisValue The lowest value shown on the axis.

   * @param maximumAxisValue The highest value shown on the axis.

   * @param inverted A flag indicating whether the axis is normal or inverted (inverted means

   *         running from positive to negative).

   * @param autoTickUnitSelection A flag indicating whether or not the tick value is automatically

   *                selected.

   * @param tickUnit The tick unit for the axis.

   * @param gridLinesVisible Flag indicating whether or not grid lines are visible.

   * @param gridStroke The pen/brush used to display grid lines (if visible).

   * @param gridPaint The color used to display grid lines (if visible).

   * @param crosshairValue The value at which to draw the crosshair line (null permitted).

   * @param crosshairStroke The pen/brush used to draw the data line.

   * @param crosshairPaint The color used to draw the data line.

   */
100
  protected NumberAxis(String label, Font labelFont, Paint labelPaint, Insets labelInsets,

         boolean tickLabelsVisible, Font tickLabelFont, Paint tickLabelPaint,

             Insets tickLabelInsets,

         boolean tickMarksVisible, Stroke tickMarkStroke,

         boolean autoRange, boolean autoRangeIncludesZero,

             Number autoRangeMinimumSize,

         double minimumAxisValue, double maximumAxisValue,

             boolean inverted,

         boolean autoTickUnitSelection, NumberTickUnit tickUnit,

             boolean gridLinesVisible, Stroke gridStroke, Paint gridPaint,

             double crosshairValue, Stroke crosshairStroke, Paint crosshairPaint) {

  super(label,

        labelFont, labelPaint, labelInsets,

      tickLabelsVisible,

        tickLabelFont, tickLabelPaint, tickLabelInsets,

      tickMarksVisible, tickMarkStroke,

        autoRange, autoTickUnitSelection,

        gridLinesVisible, gridStroke, gridPaint,

        crosshairValue,

        crosshairStroke, crosshairPaint);

    // check arguments...

    if (minimumAxisValue>=maximumAxisValue) {

      throw new IllegalArgumentException("NumberAxis(...): minimum axis value must be less "

                         +"than maximum axis value.");

    }

    if (!autoRange) {

    //  if (minimumAxisValue == null) {

    //    throw new IllegalArgumentException("NumberAxis(...): minimum axis value must be  "

    //                       +"specified if auto range calculation is off.");

    //

    //  }

    //  if (maximumAxisValue == null) {

    //    throw new IllegalArgumentException("NumberAxis(...): maximum axis value must be  "

    //                       +"specified if auto range calculation is off.");

//      }

    }

    if (autoRangeMinimumSize==null) {

      throw new IllegalArgumentException("NumberAxis(...): autoRangeMinimum cannot be null.");

    }

    // do the initialisation...

  this.autoRangeIncludesZero = autoRangeIncludesZero;

  this.autoRangeMinimumSize = autoRangeMinimumSize;

  this.minimumAxisValue = minimumAxisValue;

  this.maximumAxisValue = maximumAxisValue;

    this.anchorValue = 0.0;

    this.inverted = inverted;

  this.tickUnit = tickUnit;

    this.upperMargin = DEFAULT_UPPER_MARGIN;

    this.lowerMargin = DEFAULT_LOWER_MARGIN;

    this.standardTickUnits = createStandardTickUnits();

###
3430, calculateVisibleTickCount, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 407, 412
7
/**

   * Calculates the number of visible ticks.

   * @return The number of visible ticks on the axis.

   */
10
  public int calculateVisibleTickCount() {

  //double low = minimumAxisValue.doubleValue();

  //double high = maximumAxisValue.doubleValue();

  double unit = getTickUnit().getValue().doubleValue();

  return (int)(Math.floor(maximumAxisValue/unit)-Math.ceil(minimumAxisValue/unit)+1);

###
3431, getLowerMargin, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 313, 314
7
/**

   * Returns the margin (as a percentage of the range) by which the minimum axis value is less

   * than the minimum data value.

   */
4
  public double getLowerMargin() {

    return this.lowerMargin;

###
3432, setAutoRangeMinimumSize, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 276, 287
7
/**

   * Sets the minimum size of the automatic axis range.

   * @param minimum The new minimum.

   */
20
  public void setAutoRangeMinimumSize(Number size) {

    // check argument...

    if (size==null) {

      throw new IllegalArgumentException("NumberAxis.setAutoRangeMinimumSize(Number): "

                         +"null not permitted.");

    }

    // make the change...

  if (autoRangeMinimumSize.doubleValue()!=size.doubleValue()) {

    this.autoRangeMinimumSize = size;

    notifyListeners(new AxisChangeEvent(this));

###
3433, getAutoRangeMinimumSize, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 268, 269
7
/**

   * Returns the minimum size of the automatic axis range (if indeed it is determined

   * automatically).

   */
4
  public Number getAutoRangeMinimumSize() {

  return this.autoRangeMinimumSize;

###
3434, calculateHighestVisibleTickValue, NumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberAxis.java, 394, 399
7
/**

   * Calculates the value of the highest visible tick on the axis.

   * @return The value of the highest visible tick on the axis.

   */
10
  public double calculateHighestVisibleTickValue() {

  //double max = maximumAxisValue.doubleValue();

  double unit = getTickUnit().getValue().doubleValue();

  double index = Math.floor(maximumAxisValue/unit);

  return index*unit;

###
3435, NumberTickUnit, NumberTickUnit, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/NumberTickUnit.java, 55, 57
9
/**

   * Creates a new number tick unit.

   * @param value The size of the tick unit.

   * @param formatter A number formatter for the tick unit.

   */
6
  public NumberTickUnit(Number value, NumberFormat formatter) {

    super(value);

    this.formatter = formatter;

###
3436, Line, Line, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Line.java, 55, 56
5
/**

   * Standard constructor, with default values for the colors.

   */
4
  public Line(double x1, double y1, double x2, double y2) {

  this(x1, y1, x2, y2, new BasicStroke(), Color.blue);

###
3437, Line, Line, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Line.java, 62, 65
5
/**

   * Standard constructor.

   */
8
  public Line(double x1, double y1, double x2, double y2, Stroke stroke, Paint paint) {

  this.line = new Line2D.Double(x1, y1, x2, y2);

  this.stroke = stroke;

  this.paint = paint;

###
3438, getStroke, Line, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Line.java, 78, 79
5
/**

   * Returns the Stroke object used to draw the line.

   */
4
  public Stroke getStroke() {

  return stroke;

###
3439, getLine, Line, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Line.java, 71, 72
5
/**

   * Returns the line.

   */
4
  public Line2D getLine() {

  return line;

###
3440, LineAndShapeRenderer, LineAndShapeRenderer, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LineAndShapeRenderer.java, 81, 86
7
/**

   * Constructs a renderer of the specified type.

   * @param type of renderer.  Use one of the constants SHAPES, LINES or SHAPES_AND_LINES.

   */
12
  public LineAndShapeRenderer(int type) {

    if (type==SHAPES) this.plotShapes=true;

    if (type==LINES) this.plotLines=true;

    if (type==SHAPES_AND_LINES) {

      this.plotShapes = true;

      this.plotLines = true;

###
3441, LineAndShapeRenderer, LineAndShapeRenderer, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LineAndShapeRenderer.java, 73, 74
5
/**

   * Constructs a renderer that draws shapes only.

   */
4
  public LineAndShapeRenderer() {

    this(SHAPES_AND_LINES);

###
3442, drawCategoryItem, LineAndShapeRenderer, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/LineAndShapeRenderer.java, 103, 138
25
/**

   * Draw a single data item.

   * @param g2 The graphics device.

   * @param plotArea The data plot area.

   * @param plot The plot.

   * @param axis The range axis.

   * @param data The data.

   * @param series The series number (zero-based index).

   * @param category The category.

   * @param categoryIndex The category number (zero-based index).

   * @param previousCategory The previous category (will be null when the first category is

   *             drawn).

   */
58
  public void drawCategoryItem(Graphics2D g2, Rectangle2D dataArea,

                 CategoryPlot plot, ValueAxis axis,

                 CategoryDataset data, int series, Object category,

                 int categoryIndex, Object previousCategory) {

    // first check the number we are plotting...

    Number value = data.getValue(series, category);

    if (value!=null) {

      // Current X

      double x1 = plot.getCategoryCoordinate(categoryIndex, dataArea);

      // Current Y

      double y1 = axis.translateValueToJava2D(value.doubleValue(), dataArea);

      g2.setPaint(((Plot)plot).getSeriesPaint(series));

      g2.setStroke(((Plot)plot).getSeriesStroke(series));

      if (this.plotShapes) {

        Shape shape = ((Plot)plot).getShape(series, category, x1, y1, shapeScale);

        g2.fill(shape);

        //g2.draw(shape);

      }

      if (this.plotLines) {

        if (previousCategory!=null) {

          Number previousValue = data.getValue(series, previousCategory);

          if (previousValue!=null) {

            // get the previous data point...

            double x0 = plot.getCategoryCoordinate(categoryIndex-1, dataArea);

            double y0 = axis.translateValueToJava2D(previousValue.doubleValue(), dataArea);

            g2.setPaint(((Plot)plot).getSeriesPaint(series));

            g2.setStroke(((Plot)plot).getSeriesStroke(series));

            Line2D line = new Line2D.Double(x0, y0, x1, y1);

            g2.draw(line);

###
3443, PiePlot, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 146, 157
5
/**

   * Constructs a new pie plot.

   */
22
  public PiePlot() {

    this(DEFAULT_INTERIOR_GAP,

       true, // circular

       DEFAULT_RADIUS,

       NAME_LABELS,

       DEFAULT_SECTION_LABEL_FONT,

       DEFAULT_SECTION_LABEL_PAINT,

       DEFAULT_SECTION_LABEL_GAP,

       "0.0",

       new Insets(2, 2, 2, 2),

       null);

###
3444, setRadiusPercent, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 257, 268
7
/**

   * Sets the radius percentage.

   * @param percent The new value.

   */
20
  public void setRadiusPercent(double percent) {

    // check arguments...

    if ((percent<=0.0) || (percent>MAX_RADIUS)) {

      throw new IllegalArgumentException("PiePlot.setRadiusPercent(double): "

                         +"percentage outside valid range.");

    }

    // make the change (if necessary)...

    if (this.radiusPercent!=percent) {

      this.radiusPercent = percent;

      this.notifyListeners(new PlotChangeEvent(this));

###
3445, getSectionLabelFont, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 311, 312
7
/**

   * Returns the section label font.

   * @return The section label font.

   */
4
  public Font getSectionLabelFont() {

  return this.sectionLabelFont;

###
3446, setInteriorGapPercent, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 205, 216
5
/**

   * Sets the interior gap percent.

   */
20
  public void setInteriorGapPercent(double percent) {

    // check arguments...

    if ((percent<0.0) || (percent>MAX_INTERIOR_GAP)) {

      throw new IllegalArgumentException("PiePlot.setInteriorGapPercent(double): "

                         +"percentage outside valid range.");

    }

    // make the change...

    if (this.interiorGapPercent!=percent) {

      this.interiorGapPercent = percent;

      notifyListeners(new PlotChangeEvent(this));

###
3447, drawLabel, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 629, 655
19
/**

   * Draws the label for one pie section.

   * @param g2 The graphics device.

   * @param pieArea The area for the unexploded pie sections.

   * @param explodedPieArea The area for the exploded pie section.

   * @param data The data for the plot.

   * @param section The section (zero-based index).

   * @param startAngle The starting angle.

   * @param extent The extent of the arc.

   */
50
  protected void drawLabel(Graphics2D g2, Rectangle2D pieArea, Rectangle2D explodedPieArea,

               PieDataset data, int section, double startAngle, double extent) {

    // handle label drawing...

    FontRenderContext frc = g2.getFontRenderContext();

    String[] legendItemLabels = chart.getLegendItemLabels();

    String label = "";

    if (this.sectionLabelType==NAME_LABELS) {

      label = legendItemLabels[section];

    }

    else if (this.sectionLabelType==PERCENT_LABELS) {

      label = percentFormatter.format(extent/3.60)+"%";

    }

    else if (this.sectionLabelType==NAME_AND_PERCENT_LABELS) {

      label = legendItemLabels[section]+" ("+percentFormatter.format(extent/3.60)+"%)";

    }

    Rectangle2D labelBounds = this.sectionLabelFont.getStringBounds(label, frc);

    LineMetrics lm = this.sectionLabelFont.getLineMetrics(label, frc);

    double ascent = lm.getAscent();

    Point2D labelLocation = this.calculateLabelLocation(labelBounds, ascent,

                              pieArea, explodedPieArea,

                              startAngle, extent,

                              this.getExplodePercent(section));

    g2.setPaint(this.sectionLabelPaint);

    g2.setFont(this.sectionLabelFont);

    g2.drawString(label, (float)labelLocation.getX(), (float)labelLocation.getY());

###
3448, getRadiusPercent, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 249, 250
7
/**

   * Returns the radius percentage.

   * @return The radius percentage.

   */
4
  public double getRadiusPercent() {

    return this.radiusPercent;

###
3449, setPercentFormatString, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 397, 398
5
/**

   * Sets the format string for the percent labels.

   */
4
  public void setPercentFormatString(String format) {

    this.percentFormatter = new DecimalFormat(format);

###
3450, setSectionLabelFont, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 321, 332
11
/**

   * Sets the section label font.

   * <P>

   * Notifies registered listeners that the plot has been changed.

   * @param font The new section label font.

   */
20
  public void setSectionLabelFont(Font font) {

    // check arguments...

    if (font==null) {

      throw new IllegalArgumentException("PiePlot.setSectionLabelFont(...): "

                         +"null font not allowed.");

    }

    // make the change...

    if (!this.sectionLabelFont.equals(font)) {

    this.sectionLabelFont = font;

    notifyListeners(new PlotChangeEvent(this));

###
3451, getArcBounds, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 695, 709
17
/**

   * Returns a rectangle that can be used to create a pie section (taking into account the

   * amount by which the pie section is 'exploded').

   * @param unexploded The area inside which the unexploded pie sections are drawn.

   * @param exploded The area inside which the exploded pie sections are drawn.

   * @param startAngle The start angle.

   * @param extent The extent of the arc.

   * @param explodePercent The amount by which the pie section is exploded.

   */
28
  protected Rectangle2D getArcBounds(Rectangle2D unexploded, Rectangle2D exploded,

                     double startAngle, double extent, double explodePercent) {

    if (explodePercent==0.0) {

      return unexploded;

    }

    else {

      Arc2D arc1 = new Arc2D.Double(unexploded, startAngle, extent/2, Arc2D.OPEN);

      Point2D point1 = arc1.getEndPoint();

      Arc2D.Double arc2 = new Arc2D.Double(exploded, startAngle, extent/2, Arc2D.OPEN);

      Point2D point2 = arc2.getEndPoint();

      double deltaX = (point1.getX()-point2.getX())*explodePercent;

      double deltaY = (point1.getY()-point2.getY())*explodePercent;

      return new Rectangle2D.Double(unexploded.getX()-deltaX, unexploded.getY()-deltaY,

                      unexploded.getWidth(), unexploded.getHeight());

###
3452, getDataset, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 464, 465
11
/**

   * Returns the dataset for the plot, cast as a PieDataset.

   * <P>

   * Provided for convenience.

   * @return The dataset for the plot, cast as a PieDataset.

   */
4
  public PieDataset getDataset() {

  return (PieDataset)chart.getDataset();

###
3453, getExplodePercent, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 405, 422
7
/**

   * Returns the amount that a section should be 'exploded'.

   * <P>

   */
28
  public double getExplodePercent(int section) {

    // check argument...

    if (section<0) {

      throw new IllegalArgumentException("PiePlot.getExplodePercent(int): "

                         +"section outside valid range.");

    }

    // fetch the result...

    double result = 0.0;

    if (this.explodePercentages!=null) {

      if (section<this.explodePercentages.length) {

        result = explodePercentages[section];

      }

    }

    return result;

###
3454, setToolTipGenerator, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 486, 488
5
/**

   * Sets the tooltip generator.

   */
4
  public void setToolTipGenerator(PieToolTipGenerator generator) {

    this.toolTipGenerator = generator;

###
3455, getToolTipGenerator, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 479, 480
5
/**

   * Returns the tooltip generator (possibly null).

   */
4
  public PieToolTipGenerator getToolTipGenerator() {

    return this.toolTipGenerator;

###
3456, isCircular, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 226, 227
9
/**

   * Returns a flag indicating whether the pie chart is circular, or stretched into an elliptical

   * shape.

   * @return A flag indicating whether the pie chart is circular.

   */
4
  public boolean isCircular() {

  return circular;

###
3457, setCircular, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 234, 240
7
/**

   * A flag indicating whether the pie chart is circular, or stretched into an elliptical shape.

   * @param flag The new value.

   */
12
  public void setCircular(boolean flag) {

    // no argument checking required...

    // make the change...

    if (circular!=flag) {

    circular = flag;

      this.notifyListeners(new PlotChangeEvent(this));

###
3458, isCompatibleVerticalAxis, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 681, 683
9
/**

   * Returns true if the axis is compatible with the pie plot, and false otherwise.  Since a pie

   * plot requires no axes, only a null axis is compatible.

   * @param axis The axis.

   */
6
  public boolean isCompatibleVerticalAxis(Axis axis) {

  if (axis==null) return true;

  else return false;

###
3459, setExplodePercent, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 429, 453
5
/**

   * Sets the amount that a pie section should be exploded.

   */
46
  public void setExplodePercent(int section, double percent) {

    // check argument...

    if ((section<0) || (section>=this.getDataset().getCategories().size())) {

      throw new IllegalArgumentException("PiePlot.setExplodePercent(int, double): "

                         +"section outside valid range.");

    }

    // store the value in an appropriate data structure...

    if (this.explodePercentages!=null) {

      if (section<this.explodePercentages.length) {

        explodePercentages[section] = percent;

      }

      else {

        double[] newExplodePercentages = new double[section];

        for (int i=0; i<this.explodePercentages.length; i++) {

          newExplodePercentages[i] = this.explodePercentages[i];

        }

        this.explodePercentages = newExplodePercentages;

        this.explodePercentages[section] = percent;

      }

    }

    else {

      explodePercentages = new double[this.getDataset().getCategories().size()];

      explodePercentages[section] = percent;

###
3460, getCategories, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 472, 473
7
/**

   * Returns a collection of the categories in the dataset.

   * @return A collection of the categories in the dataset.

   */
4
  public Collection getCategories() {

  return getDataset().getCategories();

###
3461, getSectionLabelPaint, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 341, 342
7
/**

   * Returns the section label paint.

   * @return The section label paint.

   */
4
  public Paint getSectionLabelPaint() {

  return this.sectionLabelPaint;

###
3462, draw, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 498, 614
11
/**

   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).

   * @param g2 The graphics device.

   * @param plotArea The area within which the plot should be drawn.

   * @param info Collects info about the drawing.

   */
200
  public void draw(Graphics2D g2, Rectangle2D plotArea, DrawInfo info) {

    ToolTipsCollection tooltips = null;

    if (info!=null) {

      info.setPlotArea(plotArea);

      tooltips = info.getToolTipsCollection();

    }

  // adjust for insets...

  if (insets!=null) {

    plotArea.setRect(plotArea.getX()+insets.left,

               plotArea.getY()+insets.top,

         plotArea.getWidth()-insets.left-insets.right,

         plotArea.getHeight()-insets.top-insets.bottom);

  }

  // draw the outline and background

  drawOutlineAndBackground(g2, plotArea);

  // adjust the plot area by the interior spacing value

    double gapHorizontal = plotArea.getWidth()*this.interiorGapPercent;

    double gapVertical = plotArea.getHeight()*this.interiorGapPercent;

  double pieX = plotArea.getX()+gapHorizontal/2;

  double pieY = plotArea.getY()+gapVertical/2;

    double pieW = plotArea.getWidth()-gapHorizontal;

    double pieH = plotArea.getHeight()-gapVertical;

  // make the pie area a square if the pie chart is to be circular...

  if (circular) {

    double min = Math.min(pieW, pieH)/2;

      pieX = (pieX+pieX+pieW)/2 - min;

      pieY = (pieY+pieY+pieH)/2 - min;

      pieW = 2*min;

      pieH = 2*min;

  }

    Rectangle2D explodedPieArea = new Rectangle2D.Double(pieX, pieY, pieW, pieH);

    double explodeHorizontal = (1-radiusPercent)*pieW;

    double explodeVertical = (1-radiusPercent)*pieH;

  Rectangle2D pieArea = new Rectangle2D.Double(pieX+explodeHorizontal/2,

                           pieY+explodeVertical/2,

                           pieW-explodeHorizontal,

                           pieH-explodeVertical);

  // plot the data (unless the dataset is null)...

  PieDataset data = (PieDataset)chart.getDataset();

  if (data != null) {

      // get a sorted collection of categories...

      Set categories = data.getCategories();

      SortedSet ss = new TreeSet(categories);

      // compute the total value of the data series skipping over the negative values

      double totalValue = 0;

      Iterator iterator = ss.iterator();

      while (iterator.hasNext()) {

        Object current = iterator.next();

        if (current!=null) {

          Number value = data.getValue(current);

          double v = value.doubleValue();

          if (v>0) {

            totalValue = totalValue + v;

          }

        }

      }

      // For each positive value in the dataseries, compute and draw the corresponding arc.

      double sumTotal = 0;

      int section = 0;

      iterator = ss.iterator();

      while (iterator.hasNext()) {

        Object current = iterator.next();

        Number dataValue = data.getValue(current);

        if (dataValue!=null) {

          double value = dataValue.doubleValue();

          if (value>0) {

            // draw the pie section...

            double startAngle = sumTotal * 360 / totalValue;

            double extent = (sumTotal+value) * 360 / totalValue - startAngle;

            Rectangle2D arcBounds = getArcBounds(pieArea, explodedPieArea,

                               startAngle, extent,

                               this.getExplodePercent(section));

            Arc2D.Double arc = new Arc2D.Double(arcBounds, startAngle, extent,

                              Arc2D.PIE);

            sumTotal += value;

            Paint paint = this.getSeriesPaint(section);

            Paint outlinePaint = this.getSeriesOutlinePaint(section);

            g2.setPaint(paint);

            g2.fill(arc);

            g2.setStroke(new BasicStroke());

            g2.setPaint(outlinePaint);

            g2.draw(arc);

            // add a tooltip for the bar...

            if (tooltips!=null) {

              if (this.toolTipGenerator==null) {

                toolTipGenerator = new StandardPieToolTipGenerator();

              }

              String tip = this.toolTipGenerator.generateToolTip(data, current);

              if (arc!=null) {

                tooltips.addToolTip(tip, arc);

              }

            }

            // then draw the label...

            if (this.sectionLabelType!=NO_LABELS) {

              this.drawLabel(g2, pieArea, explodedPieArea, data, section, startAngle,

                       extent);

            }

          }

        }

        section = section + 1;

###
3463, PiePlot, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 173, 190
23
/**

   * Constructs a pie plot.

   * @param interiorGapPercent The interior gap (space for labels) as a percentage of the

   *    available space.

   * @param circular Flag indicating whether the pie chart is circular or elliptical.

   * @param radiusPercent The radius of the pie chart, as a percentage of the available space

   *    (after accounting for interior gap).

   * @param sectionLabelFont The font for the section labels.

   * @param sectionLabelPaint The color for the section labels.

   * @param sectionLabelGapPercent The space between the pie sections and the labels.

   * @param insets The gaps between the plot area and the border of the chart.

   */
34
  public PiePlot(double interiorGapPercent, boolean circular, double radiusPercent,

           int sectionLabelType,

           Font sectionLabelFont, Paint sectionLabelPaint, double sectionLabelGapPercent,

           String percentFormatString, Insets insets,

           PieToolTipGenerator tooltipGenerator) {

  super(null, null);

    this.interiorGapPercent = interiorGapPercent;

    this.circular = circular;

    this.radiusPercent = radiusPercent;

    this.sectionLabelType = sectionLabelType;

    this.sectionLabelFont = sectionLabelFont;

    this.sectionLabelPaint = sectionLabelPaint;

    this.sectionLabelGapPercent = sectionLabelGapPercent;

    this.percentFormatter = new DecimalFormat(percentFormatString);

    this.explodePercentages = null;

    this.toolTipGenerator = tooltipGenerator;

    setInsets(insets);

###
3464, isCompatibleHorizontalAxis, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 671, 673
9
/**

   * Returns true if the axis is compatible with the pie plot, and false otherwise.  Since a pie

   * plot requires no axes, only a null axis is compatible.

   * @param axis The axis.

   */
6
  public boolean isCompatibleHorizontalAxis(Axis axis) {

  if (axis==null) return true;

  else return false;

###
3465, setSectionLabelPaint, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 351, 362
11
/**

   * Sets the section label paint.

   * <P>

   * Notifies registered listeners that the plot has been changed.

   * @param paint The new section label paint.

   */
20
  public void setSectionLabelPaint(Paint paint) {

    // check arguments...

    if (paint==null) {

      throw new IllegalArgumentException("PiePlot.setSectionLabelPaint(...): "

                         +"null paint not allowed.");

    }

    // make the change...

    if (!this.sectionLabelPaint.equals(paint)) {

    this.sectionLabelPaint = paint;

    notifyListeners(new PlotChangeEvent(this));

###
3466, setSectionLabelType, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 288, 302
11
/**

   * Sets the section label type.

   * <P>

   * Valid types are defined by the following constants: NO_LABELS, NAME_LABELS, PERCENT_LABELS,

   *                           NAME_AND_PERCENT_LABELS.

   */
22
  public void setSectionLabelType(int type) {

    // check the argument...

    if ((type!=NO_LABELS) && (type!=NAME_LABELS) && (type!=PERCENT_LABELS)

      && (type!=NAME_AND_PERCENT_LABELS)) {

      throw new IllegalArgumentException("PiePlot.setSectionLabelType(int): "

                         +"unrecognised type.");

    }

    // make the change...

    if (sectionLabelType!=type) {

      this.sectionLabelType = type;

      notifyListeners(new PlotChangeEvent(this));

###
3467, setSectionLabelGapPercent, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 378, 389
5
/**

   * Sets the section label gap percent.

   */
20
  public void setSectionLabelGapPercent(double percent) {

    // check arguments...

    if ((percent<0.0) || (percent>MAX_SECTION_LABEL_GAP)) {

      throw new IllegalArgumentException("PiePlot.setSectionLabelGapPercent(double): "

                         +"percentage outside valid range.");

    }

    // make the change...

    if (this.sectionLabelGapPercent!=percent) {

      this.sectionLabelGapPercent = percent;

      notifyListeners(new PlotChangeEvent(this));

###
3468, getPlotType, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 662, 663
5
/**

   * Returns a short string describing the type of plot.

   */
4
  public String getPlotType() {

  return "Pie Plot";

###
3469, getInteriorGapPercent, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 198, 199
7
/**

   * Returns the interior gap, measures as a percentage of the available drawing space.

   * @return The interior gap, measured as a percentage of the available drawing space.

   */
4
  public double getInteriorGapPercent() {

    return this.interiorGapPercent;

###
3470, getSectionLabelGapPercent, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 371, 372
7
/**

   * Returns the section label gap, measures as a percentage of the radius.

   * @return The section label gap, measures as a percentage of the radius.

   */
4
  public double getSectionLabelGapPercent() {

    return this.sectionLabelGapPercent;

###
3471, getSectionLabelType, PiePlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/PiePlot.java, 278, 279
9
/**

   * Returns the section label type.  Defined by the constants: NO_LABELS, NAME_LABELS,

   * PERCENT_LABELS and NAME_AND_PERCENT_LABELS.

   * @return The section label type.

   */
4
  public int getSectionLabelType() {

    return this.sectionLabelType;

###
3472, getVerticalAxis, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 230, 231
9
/**

   * Returns a reference to the vertical axis.

   * @return A reference to the vertical axis.

   * @see Plot#getAxis

   */
4
  public VerticalAxis getVerticalAxis() {

  return (VerticalAxis)verticalAxis;

###
3473, setChart, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 327, 338
9
/**

   * Sets a reference back to the chart that this plot belongs to.  Reconfigures the axes

   * according to the chart's data source.

   * @param chart The chart that the plot belongs to.

   */
18
  public void setChart(JFreeChart chart) {

  // if replacing an existing chart, the plot may be a registered listener...

    if (this.chart!=null) {

      chart.removeChangeListener(this);

    }

  this.chart = chart;

  // new chart means new data source, so reconfigure axes...

  if (verticalAxis!=null) verticalAxis.configure();

  if (horizontalAxis!=null) horizontalAxis.configure();

###
3474, getMaximumHorizontalDataValue, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 234, 240
7
/**

   * Returns the maximum value in either the domain or the range, whichever is displayed against

   * the horizontal axis for the particular type of plot implementing this interface.

   */
12
  public Number getMaximumHorizontalDataValue() {

  Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMaximumDomainValue(data);

  }

  else return null;

###
3475, handleClick, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 585, 598
13
/**

   * Handles a 'click' on the plot.  Since the plot does not maintain any information about where

   * it has been drawn, the plot area is supplied as an argument.

   * @param x The x coordinate.

   * @param y The y coordinate.

   * @param plotArea The area in which the plot is assumed to be drawn.

   */
24
  public void handleClick(int x, int y, DrawInfo info) {

    // translate x into a data value

    // if the axis is a value axis, set the crosshair value

    if (horizontalAxis instanceof ValueAxis) {

      ValueAxis hva = (ValueAxis)horizontalAxis;

      double xx = hva.translateJava2DtoValue(x, info.getDataArea());

    }

    // translate the y into a data value

    // if the axis is a value axis, set the crosshair value

    if (verticalAxis instanceof ValueAxis) {

      ValueAxis vva = (ValueAxis)verticalAxis;

      double yy = vva.translateJava2DtoValue(y, info.getDataArea());

###
3476, VerticalXYBarPlot, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 84, 88
17
/**

   * Constructs a new vertical XY bar plot.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   * @param insets Amount of blank space around the plot area.

   * @param background The Paint used to fill the plot background.

   * @param outlineStroke The Stroke used to draw an outline around the plot.

   * @param outlinePaint The color used to draw the plot outline.

   */
8
  public VerticalXYBarPlot(Axis horizontalAxis, Axis verticalAxis,

               Insets insets, Paint background,

               Stroke outlineStroke, Paint outlinePaint) {

    super(horizontalAxis, verticalAxis, insets, background, outlineStroke, outlinePaint);

###
3477, drawOutlineAndBackground, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 563, 573
9
/**

   * Draw the plot outline and background.

   * @param g2 The graphics device.

   * @param area The area within which the plot should be drawn.

   */
18
  public void drawOutlineAndBackground(Graphics2D g2, Rectangle2D area) {

  if (backgroundPaint!=null) {

    g2.setPaint(backgroundPaint);

    g2.fill(area);

  }

  if ((outlineStroke!=null) && (outlinePaint!=null)) {

    g2.setStroke(outlineStroke);

    g2.setPaint(outlinePaint);

    g2.draw(area);

###
3478, isCompatibleVerticalAxis, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 127, 129
13
/**

   * Returns true if the specified axis is compatible with the plot with regard to operating as

   * the vertical axis.

   * <P>

   * This plot requires the vertical axis to be a subclass of VerticalNumberAxis.

   * @param axis The axis.

   */
6
  public boolean isCompatibleVerticalAxis(Axis axis) {

    if (axis instanceof VerticalNumberAxis) return true;

    else return false;

###
3480, getMinimumVerticalDataValue, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 248, 254
9
/**

   * Returns the minimum Y value from the datasource.

   * <P>

   * This method can return null if the data source is null.

   */
12
  public Number getMinimumVerticalDataValue()  {

    Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMinimumRangeValue(data);

  }

  else return null;

###
3481, axisChanged, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 610, 611
7
/**

   * Receives notification of a change to one of the plot's axes.

   * @param event Information about the event (not used here).

   */
4
  public void axisChanged(AxisChangeEvent event) {

  notifyListeners(new PlotChangeEvent(this));

###
3482, getChart, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 195, 196
7
/**

   * Returns a reference to the chart that this plot belongs to.

   * @return A reference to the chart that this plot belongs to (null possible).

   */
4
  public JFreeChart getChart() {

  return chart;

###
3483, VerticalXYBarPlot, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 64, 71
9
/**

   * Constructs a new vertical XY bar plot.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   */
14
  public VerticalXYBarPlot(Axis horizontalAxis, Axis verticalAxis) {

     this(horizontalAxis,

      verticalAxis,

      Plot.DEFAULT_INSETS,

      Plot.DEFAULT_BACKGROUND_COLOR,

      Plot.DEFAULT_OUTLINE_STROKE,

      Plot.DEFAULT_OUTLINE_COLOR);

###
3484, getSeriesPaint, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 414, 415
7
/**

   * Returns the Paint used to color any shapes for the specified series.

   * @param index The index of the series of interest (zero-based);

   */
4
  public Paint getSeriesPaint(int index) {

  return seriesPaint[index % seriesPaint.length];

###
3485, getDomainAxis, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 95, 96
5
/**

   * A convenience method that returns the horizontal axis cast as a ValueAxis.

   */
4
  public ValueAxis getDomainAxis() {

    return (ValueAxis)horizontalAxis;

###
3486, setSeriesOutlinePaint, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 459, 461
9
/**

   * Sets the paint used to outline any shapes representing series, and notifies registered

   * listeners that the chart has been modified.

   * @param paint An array of Paint objects for drawing the outline of series shapes;

   */
6
  public void setSeriesOutlinePaint(Paint[] paint) {

  this.seriesOutlinePaint = paint;

  notifyListeners(new PlotChangeEvent(this));

###
3487, setOutlinePaint, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 313, 317
9
/**

   * Sets the color of the outline of the plot area, and notifies registered listeners that the

   * Plot has been modified.

   * @param paint The new outline paint.

   */
8
  public void setOutlinePaint(Paint paint) {

    if (!this.outlinePaint.equals(paint)) {

      this.outlinePaint = paint;

    notifyListeners(new PlotChangeEvent(this));

###
3488, setSeriesOutlineStroke, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 477, 479
9
/**

   * Sets the stroke used to draw any shapes representing series, and notifies registered

   * listeners that the chart has been modified.

   * @param stroke An array of Stroke objects;

   */
6
  public void setSeriesOutlineStroke(Stroke[] stroke) {

  this.seriesOutlineStroke = stroke;

  notifyListeners(new PlotChangeEvent(this));

###
3489, drawBar, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 185, 211
5
/**

   * Draws one bar.

   */
44
  protected void drawBar(Graphics2D g2, Rectangle2D plotArea, IntervalXYDataset data,

               int series, int item, ValueAxis horizontalAxis, ValueAxis verticalAxis,

               double translatedRangeZero) {

    Paint seriesPaint = this.getSeriesPaint(series);

    Paint seriesOutlinePaint = this.getSeriesOutlinePaint(series);

    Number valueNumber = data.getYValue(series, item);

    double translatedValue = verticalAxis.translateValueToJava2D(valueNumber.doubleValue(), plotArea);

    Number startXNumber = data.getStartXValue(series, item);

    double translatedStartX = horizontalAxis.translateValueToJava2D(startXNumber.doubleValue(), plotArea);

    Number endXNumber = data.getEndXValue(series, item);

    double translatedEndX = horizontalAxis.translateValueToJava2D(endXNumber.doubleValue(), plotArea);

    double translatedWidth = Math.max(1, translatedEndX-translatedStartX);

    double translatedHeight = Math.abs(translatedValue-translatedRangeZero);

    Rectangle2D bar = new Rectangle2D.Double(translatedStartX,

                         Math.min(translatedRangeZero, translatedValue),

                         translatedWidth, translatedHeight);

    g2.setPaint(seriesPaint);

    g2.fill(bar);

    if ((translatedEndX-translatedStartX)>3) {

      g2.setStroke(this.getSeriesOutlineStroke(series));

      g2.setPaint(seriesOutlinePaint);

      g2.draw(bar);

###
3490, addChangeListener, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 518, 519
7
/**

   * Registers an object for notification of changes to the plot.

   * @param listener The object to be registered.

   */
4
  public void addChangeListener(PlotChangeListener listener) {

  listeners.add(listener);

###
3491, setVerticalAxis, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 348, 372
11
/**

   * Sets the vertical axis for the plot.

   * <P>

   * An exception is thrown if the new axis and the plot are not mutually compatible.

   * @param axis The new axis (null permitted).

   */
40
  public void setVerticalAxis(Axis axis) throws AxisNotCompatibleException {

    if (isCompatibleVerticalAxis(axis)) {

      if (axis!=null) {

        try {

          axis.setPlot(this);

        }

        catch (PlotNotCompatibleException e) {

          throw new AxisNotCompatibleException("Plot.setVerticalAxis(...): "

                            +"plot not compatible with axis.");

        }

        axis.addChangeListener(this);

      }

      // plot is likely registered as a listener with the existing axis...

      if (this.verticalAxis!=null) {

      this.verticalAxis.removeChangeListener(this);

      }

      this.verticalAxis = axis;

    }

    else throw new AxisNotCompatibleException("Plot.setVerticalAxis(...): "

                         +"axis not compatible with plot.");

###
3492, draw, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 138, 177
11
/**

   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).

   * @param g2 The graphics device.

   * @param drawArea The area within which the plot should be drawn.

   * @param info Collects drawing info.

   */
72
  public void draw(Graphics2D g2, Rectangle2D drawArea, DrawInfo info) {

    // adjust the drawing area for plot insets (if any)...

    if (insets!=null) {

      drawArea = new Rectangle2D.Double(drawArea.getX()+insets.left,

                        drawArea.getY()+insets.top,

                        drawArea.getWidth()-insets.left-insets.right,

                        drawArea.getHeight()-insets.top-insets.bottom);

    }

    // estimate the area required for drawing the axes...

    HorizontalAxis ha = getHorizontalAxis();

    VerticalAxis va = getVerticalAxis();

    double hAxisAreaHeight = ha.reserveHeight(g2, this, drawArea);

    Rectangle2D vAxisArea = va.reserveAxisArea(g2, this, drawArea, hAxisAreaHeight);

    Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX()+vAxisArea.getWidth(),

                            drawArea.getY(),

                            drawArea.getWidth()-vAxisArea.getWidth(),

                            drawArea.getHeight()-hAxisAreaHeight);

    // draw the background and axes...

    drawOutlineAndBackground(g2, plotArea);

    getDomainAxis().draw(g2, drawArea, plotArea);

    getRangeAxis().draw(g2, drawArea, plotArea);

    // now get the data and plot the bars...

    IntervalXYDataset data = (IntervalXYDataset)chart.getDataset();

    if (data!=null) {

      Shape savedClip = g2.getClip();

      g2.clip(plotArea);

      double translatedVerticalZero = getRangeAxis().translateValueToJava2D(0.0, plotArea);

      int seriesCount = data.getSeriesCount();

      for (int series = 0; series<seriesCount; series++) {

        int itemCount = data.getItemCount(series);

        for (int item = 0; item<itemCount; item++) {

          drawBar(g2, plotArea, data, series, item, getDomainAxis(), getRangeAxis(),

              translatedVerticalZero);

        }

      }

      g2.setClip(savedClip);

###
3493, getSeriesStroke, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 432, 433
7
/**

   * Returns the Stroke used to draw any shapes for the specified series.

   * @param index The index of the series of interest (zero-based);

   */
4
  public Stroke getSeriesStroke(int index) {

  return seriesStroke[index % seriesStroke.length];

###
3494, getRangeAxis, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 102, 103
5
/**

   * A convenience method that returns the vertical axis cast as a VerticalNumberAxis.

   */
4
  public VerticalNumberAxis getRangeAxis() {

    return (VerticalNumberAxis)verticalAxis;

###
3495, getMaximumVerticalDataValue, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 263, 269
9
/**

   * Returns the maximum Y value from the datasource.

   * <P>

   * This method can return null if the data source is null.

   */
12
  public Number getMaximumVerticalDataValue() {

  Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMaximumRangeValue(data);

  }

  else return null;

###
3496, Plot, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 156, 187
17
/**

   * Constructs a new plot.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   * @param insets Amount of blank space around the plot area.

   * @param background The Paint used to fill the plot background.

   * @param outlineStroke The Stroke used to draw an outline around the plot.

   * @param outlinePaint The color used to draw an outline around the plot.

   */
50
  protected Plot(Axis horizontalAxis, Axis verticalAxis,

           Insets insets,

           Paint background, Stroke outlineStroke, Paint outlinePaint) {

  this.chart = null;

  this.horizontalAxis=horizontalAxis;

    if (horizontalAxis!=null) {

    horizontalAxis.setPlot(this);

    horizontalAxis.addChangeListener(this);

    }

  this.verticalAxis=verticalAxis;

    if (verticalAxis!=null) {

    verticalAxis.setPlot(this);

    verticalAxis.addChangeListener(this);

    }

  this.insets = insets;

  this.backgroundPaint = background;

    this.outlineStroke = outlineStroke;

  this.outlinePaint = outlinePaint;

      this.seriesPaint = new Paint[] {Color.red, Color.blue, Color.green, Color.yellow,

                    Color.cyan, Color.magenta, Color.orange, Color.pink,

                    Color.lightGray};

  this.seriesStroke = new Stroke[] { new BasicStroke(1) };

  this.seriesOutlinePaint = new Paint[] { Color.gray };

  this.seriesOutlineStroke = new Stroke[] { new BasicStroke(0.5f) };

  this.listeners = new java.util.ArrayList();

###
3497, isCompatibleHorizontalAxis, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 114, 117
15
/**

   * Returns true if the specified axis is compatible with the plot with regard to operating as

   * the horizontal axis.

   * <P>

   * This plot requires the horizontal axis to be a subclass of HorizontalNumberAxis or

   * HorizontalDateAxis.

   * @param axis The axis.

   */
8
  public boolean isCompatibleHorizontalAxis(Axis axis) {

    if (axis instanceof HorizontalNumberAxis) return true;

    else if (axis instanceof HorizontalDateAxis) return true;

    else return false;

###
3498, setOutlineStroke, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 291, 295
9
/**

   * Sets the pen/brush used to outline the plot area, and notifies registered listeners that the

   * plot has been modified.

   * @param stroke The new outline pen/brush.

   */
8
  public void setOutlineStroke(Stroke stroke) {

    if (!this.outlineStroke.equals(stroke)) {

    this.outlineStroke = stroke;

    notifyListeners(new PlotChangeEvent(this));

###
3499, getMinimumHorizontalDataValue, VerticalXYBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalXYBarPlot.java, 220, 226
7
/**

   * Returns the minimum value in either the domain or the range, whichever is displayed against

   * the horizontal axis for the particular type of plot implementing this interface.

   */
12
  public Number getMinimumHorizontalDataValue() {

    Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMinimumDomainValue(data);

  }

  else return null;

###
3500, Plot, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 137, 143
9
/**

   * Constructs a new plot with the specified axes.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   */
12
  protected Plot(Axis horizontalAxis, Axis verticalAxis) {

    this(horizontalAxis, verticalAxis,

       DEFAULT_INSETS,

       DEFAULT_BACKGROUND_COLOR,

       DEFAULT_OUTLINE_STROKE,

       DEFAULT_OUTLINE_COLOR);

###
3501, getBackgroundPaint, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 260, 261
7
/**

   * Returns the background color of the plot area.

   * @return The background color of the plot area.

   */
4
  public Paint getBackgroundPaint() {

  return this.backgroundPaint;

###
3502, getSeriesOutlinePaint, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 450, 451
7
/**

   * Returns the Paint used to outline any shapes for the specified series.

   * @param index The index of the series of interest (zero-based);

   */
4
  public Paint getSeriesOutlinePaint(int index) {

  return seriesOutlinePaint[index % seriesOutlinePaint.length];

###
3503, getSeriesOutlineStroke, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 468, 469
7
/**

   * Returns the Stroke used to outline any shapes for the specified series.

   * @param index The index of the series of interest (zero-based);

   */
4
  public Stroke getSeriesOutlineStroke(int index) {

  return seriesOutlineStroke[index % seriesOutlinePaint.length];

###
3504, getOutlineStroke, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 282, 283
7
/**

   * Returns the pen/brush used to outline the plot area.

   * @return The pen/brush used to outline the plot area.

   */
4
  public Stroke getOutlineStroke() {

  return this.outlineStroke;

###
3505, setInsets, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 247, 251
9
/**

   * Sets the insets for the plot and notifies registered listeners that the plot has been

   * modified.

   * @param insets The new insets.

   */
8
  public void setInsets(Insets insets) {

    if (!this.insets.equals(insets)) {

    this.insets = insets;

    notifyListeners(new PlotChangeEvent(this));

###
3506, getAxis, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 206, 211
13
/**

   * Returns the specified axis.

   * @param select Determines the axis returned (use the constants HORIZONTAL_AXIS and

   *         VERTICAL_AXIS).

   * @see Plot#getHorizontalAxis

   * @see Plot#getVerticalAxis

   */
10
  public Axis getAxis(int select) {

  switch (select) {

      case HORIZONTAL_AXIS : return horizontalAxis;

    case VERTICAL_AXIS : return verticalAxis;

    default: return null;

###
3507, setSeriesPaint, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 423, 425
9
/**

   * Sets the paint used to color any shapes representing series, and notifies registered

   * listeners that the plot has been modified.

   * @param paint An array of Paint objects used to color series;

   */
6
  public void setSeriesPaint(Paint[] paint) {

  this.seriesPaint = paint;

  notifyListeners(new PlotChangeEvent(this));

###
3508, getShape, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 486, 489
7
/**

   * Returns a Shape that can be used in plotting data. Should allow a plugin object to

   * determine the shape (optionally)...

   */
6
  public Shape getShape(int series, int item, double x, double y, double scale) {

     // return new Rectangle2D.Double(x-0.5*scale, y-0.5*scale, scale, scale);

    return new Ellipse2D.Double(x-0.5*scale, y-0.5*scale, scale, scale);

###
3509, removeChangeListener, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 526, 527
7
/**

   * Unregisters an object for notification of changes to the plot.

   * @param listener The object to be unregistered.

   */
4
  public void removeChangeListener(PlotChangeListener listener) {

  listeners.remove(listener);

###
3511, chartChanged, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 620, 636
11
/**

   * Receives notification of a change to a (the) chart.

   * <P>

   * Reacts to dataset changes by reconfiguring the axes.

   * @param event Information about the chart change event.

   */
30
  public void chartChanged(ChartChangeEvent event) {

  if (event.getType()==ChartChangeEvent.NEW_DATASET) {

    if (verticalAxis!=null) {

        verticalAxis.configure();

      }

      if (horizontalAxis!=null) {

      horizontalAxis.configure();

      }

  }

  if (event.getType()==ChartChangeEvent.UPDATED_DATASET) {

    if (verticalAxis!=null) {

        verticalAxis.configure();

      }

      if (horizontalAxis!=null) {

      horizontalAxis.configure();

###
3512, setSeriesStroke, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 441, 443
9
/**

   * Sets the stroke used to draw any shapes representing series, and notifies registered

   * listeners that the chart has been modified.

   * @param stroke An array of Stroke objects used to draw series;

   */
6
  public void setSeriesStroke(Stroke[] stroke) {

  this.seriesStroke = stroke;

  notifyListeners(new PlotChangeEvent(this));

###
3513, setBackgroundPaint, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 269, 273
9
/**

   * Sets the background color of the plot area, and notifies registered listeners that the

   * plot has been modified.

   * @param paint The new background Paint.

   */
8
  public void setBackgroundPaint(Paint paint) {

    if (!this.backgroundPaint.equals(paint)) {

    this.backgroundPaint = paint;

    notifyListeners(new PlotChangeEvent(this));

###
3514, getInsets, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 238, 239
7
/**

   * Returns the insets for the plot area.

   * @return The insets for the plot area.

   */
4
  public Insets getInsets() {

  return this.insets;

###
3515, getShape, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 496, 499
7
/**

   * Returns a Shape that can be used in plotting data.  Should allow a plug-in object to

   * determine the shape...

   */
6
  public Shape getShape(int series, Object category, double x, double y, double scale) {

     // return new Rectangle2D.Double(x-0.5*scale, y-0.5*scale, scale, scale);

    return new Ellipse2D.Double(x-0.5*scale, y-0.5*scale, scale, scale);

###
3516, getHorizontalAxis, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 221, 222
9
/**

   * Returns a reference to the horizontal axis.

   * @return A reference to the horizontal axis.

   * @see Plot#getAxis

   */
4
  public HorizontalAxis getHorizontalAxis() {

  return (HorizontalAxis)horizontalAxis;

###
3517, getOutlinePaint, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 304, 305
7
/**

   * Returns the color used to draw the outline of the plot area.

   * @return The color used to draw the outline of the plot area.

   */
4
  public Paint getOutlinePaint() {

  return this.outlinePaint;

###
3518, notifyListeners, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 506, 510
7
/**

   * Notifies all registered listeners that the plot has been modified.

   * @param event Information about the change event.

   */
10
  public void notifyListeners(PlotChangeEvent event) {

  java.util.Iterator iterator = listeners.iterator();

  while (iterator.hasNext()) {

    PlotChangeListener listener = (PlotChangeListener)iterator.next();

    listener.plotChanged(event);

###
3519, setHorizontalAxis, Plot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Plot.java, 381, 406
9
/**

   * Sets the horizontal axis for the plot (this must be compatible with the plot type or an

   * exception is thrown).

   * @param axis The new axis;

   */
40
  public void setHorizontalAxis(Axis axis) throws AxisNotCompatibleException {

    if (isCompatibleHorizontalAxis(axis)) {

      if (axis!=null) {

        try {

          axis.setPlot(this);

        }

        catch (PlotNotCompatibleException e) {

          throw new AxisNotCompatibleException("Plot.setHorizontalAxis(...): "

                            +"plot not compatible with axis.");

        }

        axis.addChangeListener(this);

      }

      // plot is likely registered as a listener with the existing axis...

      if (this.horizontalAxis!=null) {

      this.horizontalAxis.removeChangeListener(this);

      }

      this.horizontalAxis = axis;

    }

    else throw new AxisNotCompatibleException("Plot.setHorizontalAxis(...): "

                         +"axis not compatible with plot.");

###
3521, drawHorizontalLines, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 411, 420
5
/**

   * Support method for the draw(...) method.

   */
18
  private void drawHorizontalLines(Graphics2D g2, Rectangle2D dataArea) {

    // Draw any horizontal lines

    if (horizontalLines != null) {

      for (int i=0; i<horizontalLines.size(); i++) {

        g2.setPaint((Paint)horizontalColors.get(i));

        g2.setStroke(new BasicStroke(1));

        Number y = (Number)horizontalLines.get(i);

        int yint = (int)getRangeAxis().translateValueToJava2D(y.doubleValue(), dataArea);

        g2.drawLine(0, yint, (int)(dataArea.getWidth()), yint);

###
3522, drawVerticalLines, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 393, 402
5
/**

   * Support method for the draw(...) method.

   */
18
  private void drawVerticalLines(Graphics2D g2, Rectangle2D dataArea) {

    // Draw any vertical lines

    if (verticalLines != null) {

      for (int i=0; i<verticalLines.size(); i++) {

        g2.setPaint((Paint)verticalColors.get(i));

        g2.setStroke(new BasicStroke(1));

        Number x = (Number)verticalLines.get(i);

        int xint = (int)getDomainAxis().translateValueToJava2D(x.doubleValue(), dataArea);

        g2.drawLine(xint, 0, xint, (int)(dataArea.getHeight()));

###
3523, setXYItemRenderer, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 139, 141
7
/**

   * Sets the item renderer, and notifies all listeners of a change to the plot.

   * @param renderer The new renderer.

   */
6
  public void setXYItemRenderer(XYItemRenderer renderer) {

    this.renderer = renderer;

    this.notifyListeners(new PlotChangeEvent(this));

###
3524, addHorizontalLine, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 180, 183
7
/**

   * Adds a horizontal line at the specified data value, using the default color red.

   * @param value The data value.

   */
6
  public void addHorizontalLine(Number value) {

    addHorizontalLine(value, Color.red);

    this.notifyListeners(new PlotChangeEvent(this));

###
3525, XYPlot, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 98, 104
9
/**

   * Constructs an XYPlot with the specified axes (other attributes take default values).

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   */
12
  public XYPlot(ValueAxis horizontalAxis, ValueAxis verticalAxis) {

  this(horizontalAxis, verticalAxis,

       Plot.DEFAULT_INSETS,

       Plot.DEFAULT_BACKGROUND_COLOR,

       Plot.DEFAULT_OUTLINE_STROKE,

       Plot.DEFAULT_OUTLINE_COLOR);

###
3526, isCompatibleVerticalAxis, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 243, 247
11
/**

   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with

   * the plot, and false otherwise.

   * @param axis The vertical axis;

   * @return True if the axis is compatible with the plot, and false otherwise.

   */
10
  public boolean isCompatibleVerticalAxis(Axis axis) {

  if (axis instanceof VerticalNumberAxis) {

    return true;

  }

  else return false;

###
3527, getRangeAxis, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 217, 218
9
/**

   * A convenience method that returns a reference to the vertical axis cast as a

   * ValueAxis.

   * @return The vertical axis cast as a ValueAxis.

   */
4
  public ValueAxis getRangeAxis() {

  return (ValueAxis)verticalAxis;

###
3528, getMinimumHorizontalDataValue, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 479, 485
9
/**

   * Returns the minimum value in the domain, since this is plotted against the horizontal axis

   * for an XYPlot.

   * @return The minimum value to be plotted against the horizontal axis.

   */
12
  public Number getMinimumHorizontalDataValue() {

  Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMinimumDomainValue(data);

  }

  else return null;

###
3529, getItemRenderer, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 131, 132
7
/**

   * Returns a reference to the current item renderer.

   * @return A reference to the current item renderer.

   */
4
  public XYItemRenderer getItemRenderer() {

    return this.renderer;

###
3530, addHorizontalLine, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 191, 199
9
/**

   * Adds a horizontal line at the specified data value, using the specified color.

   * @param value The data value.

   * @param color The line color.

   */
14
  public void addHorizontalLine(Number location, Paint color) {

    if (horizontalLines == null) {

      horizontalLines = new ArrayList();

      horizontalColors = new ArrayList();

    }

    horizontalColors.add(color);

    horizontalLines.add(location);

###
3531, drawVerticalLine, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 365, 372
5
/**

   * Utility method for drawing a crosshair on the chart (if required).

   */
14
  private void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea, double value,

                  Stroke stroke, Paint paint) {

    double xx = this.getDomainAxis().translateValueToJava2D(value, dataArea);

    Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx, dataArea.getMaxY());

    g2.setStroke(stroke);

    g2.setPaint(paint);

    g2.draw(line);

###
3532, handleClick, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 429, 442
5
/**

   * Handles a 'click' on the plot by updating the anchor values...

   */
22
  public void handleClick(int x, int y, DrawInfo info) {

    // set the anchor value for the horizontal axis...

    ValueAxis hva = this.getDomainAxis();

    double hvalue = hva.translateJava2DtoValue((float)x, info.getDataArea());

    hva.setAnchorValue(hvalue);

    hva.setCrosshairValue(hvalue);

    // set the anchor value for the vertical axis...

    ValueAxis vva = this.getRangeAxis();

    double vvalue = vva.translateJava2DtoValue((float)y, info.getDataArea());

    vva.setAnchorValue(vvalue);

    vva.setCrosshairValue(vvalue);

###
3533, getDomainAxis, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 208, 209
9
/**

   * A convenience method that returns a reference to the horizontal axis cast as a

   * ValueAxis.

   * @return The horizontal axis cast as a ValueAxis.

   */
4
  public ValueAxis getDomainAxis() {

  return (ValueAxis)horizontalAxis;

###
3534, addVerticalLine, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 156, 157
7
/**

   * Adds a vertical line at location with default color blue.

   * @return void

   */
4
  public void addVerticalLine(Number location) {

    addVerticalLine(location, Color.blue);

###
3535, draw, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 259, 358
17
/**

   * Draws the XY plot on a Java 2D graphics device (such as the screen or a printer).

   * <P>

   * XYPlot now relies on an XYItemRenderer to draw each item in the plot.  This allows the

   * visual representation of the plot to be changed easily.

   * @param g2 The graphics device.

   * @param drawArea The area within which the plot (including axis labels) should be drawn.

   * @param info Collects chart drawing information (null permitted).

   */
164
  public void draw(Graphics2D g2, Rectangle2D plotArea, DrawInfo info) {

    // set up info collection...

    ToolTipsCollection tooltips = null;

    if (info!=null) {

      info.setPlotArea(plotArea);

      tooltips = info.getToolTipsCollection();

    }

    // adjust the drawing area for plot insets (if any)...

  if (insets!=null) {

    plotArea.setRect(plotArea.getX()+insets.left,

               plotArea.getY()+insets.top,

               plotArea.getWidth()-insets.left-insets.right,

               plotArea.getHeight()-insets.top-insets.bottom);

  }

  // estimate the area required for drawing the axes...

  HorizontalAxis hAxis = getHorizontalAxis();

  VerticalAxis vAxis = getVerticalAxis();

  double hAxisAreaHeight = hAxis.reserveHeight(g2, this, plotArea);

  Rectangle2D vAxisArea = vAxis.reserveAxisArea(g2, this, plotArea, hAxisAreaHeight);

    // ...and therefore what is left for the plot itself...

  Rectangle2D dataArea = new Rectangle2D.Double(plotArea.getX()+vAxisArea.getWidth(),

                            plotArea.getY(),

                            plotArea.getWidth()-vAxisArea.getWidth(),

                            plotArea.getHeight()-hAxisAreaHeight);

    if (info!=null) {

      info.setDataArea(dataArea);

    }

    CrosshairInfo crosshairInfo = new CrosshairInfo();

    crosshairInfo.setCrosshairDistance(Double.POSITIVE_INFINITY);

    crosshairInfo.setAnchorX(this.getDomainAxis().getAnchorValue());

    crosshairInfo.setAnchorY(this.getRangeAxis().getAnchorValue());

    // draw the plot background and axes...

  drawOutlineAndBackground(g2, dataArea);

  this.horizontalAxis.draw(g2, plotArea, dataArea);

  this.verticalAxis.draw(g2, plotArea, dataArea);

    // now get the data and plot it (the visual representation will depend on the renderer

    // that has been set)...

    XYDataset data = this.getDataset();

    if (data!=null) {

    Shape originalClip = g2.getClip();

    g2.clip(dataArea);

      drawVerticalLines(g2, dataArea);

      drawHorizontalLines(g2, dataArea);

      double transRangeZero = this.getRangeAxis().translateValueToJava2D(0.0, dataArea);

      int seriesCount = data.getSeriesCount();

      for (int series=0; series<seriesCount; series++) {

        int itemCount = data.getItemCount(series);

        for (int item=0; item<itemCount; item++) {

          Shape tooltipArea = renderer.drawItem(g2, dataArea, info, this,

                              (ValueAxis)horizontalAxis,

                              (ValueAxis)verticalAxis,

                              data, series, item,

                              transRangeZero, crosshairInfo);

          // add a tooltip for the item...

          if (tooltips!=null) {

            if (this.toolTipGenerator==null) {

              toolTipGenerator = new StandardXYToolTipGenerator();

            }

            String tip = this.toolTipGenerator.generateToolTip(data, series, item);

            if (tooltipArea!=null) {

              tooltips.addToolTip(tip, tooltipArea);

            }

          }

        }

      }

      // draw vertical crosshair if required...

      ValueAxis hva = (ValueAxis)this.horizontalAxis;

      hva.setCrosshairValue(crosshairInfo.getCrosshairX());

      if (hva.isCrosshairVisible()) {

        this.drawVerticalLine(g2, dataArea, hva.getCrosshairValue(),

                    hva.getCrosshairStroke(),

                    hva.getCrosshairPaint());

      }

      // draw horizontal crosshair if required...

      ValueAxis vva = (ValueAxis)this.verticalAxis;

      vva.setCrosshairValue(crosshairInfo.getCrosshairY());

      if (vva.isCrosshairVisible()) {

        this.drawHorizontalLine(g2, dataArea, vva.getCrosshairValue(),

                    vva.getCrosshairStroke(),

                    vva.getCrosshairPaint());

      }

      g2.setClip(originalClip);

###
3536, drawHorizontalLine, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 379, 386
5
/**

   * Utility method for drawing a crosshair on the chart (if required).

   */
14
  private void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea, double value,

                  Stroke stroke, Paint paint) {

    double yy = this.getRangeAxis().translateValueToJava2D(value, dataArea);

    Line2D line = new Line2D.Double(dataArea.getMinX(), yy, dataArea.getMaxX(), yy);

    g2.setStroke(stroke);

    g2.setPaint(paint);

    g2.draw(line);

###
3537, XYPlot, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 117, 123
17
/**

   * Constructs a new XY plot.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   * @param insets Amount of blank space around the plot area.

   * @param background The Paint used to fill the plot background.

   * @param outlineStroke The Stroke used to draw an outline around the plot.

   * @param outlinePaint The color used to draw the plot outline.

   */
12
  public XYPlot(ValueAxis horizontalAxis, ValueAxis verticalAxis,

          Insets insets, Paint background,

          Stroke outlineStroke, Paint outlinePaint) {

    super(horizontalAxis, verticalAxis, insets, background, outlineStroke, outlinePaint);

    this.renderer = new StandardXYItemRenderer();

    this.toolTipGenerator = null;

###
3538, getMaximumHorizontalDataValue, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 494, 500
9
/**

   * Returns the maximum value in the domain, since this is plotted against the horizontal axis

   * for an XYPlot.

   * @return The maximum value to be plotted against the horizontal axis.

   */
12
  public Number getMaximumHorizontalDataValue() {

  Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMaximumDomainValue(data);

  }

  else return null;

###
3539, getPlotType, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 470, 471
7
/**

   * Returns the plot type as a string.

   * @return A short string describing the type of plot.

   */
4
  public String getPlotType() {

  return "XY Plot";

###
3540, isCompatibleHorizontalAxis, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 227, 234
11
/**

   * Checks the compatibility of a horizontal axis, returning true if the axis is compatible with

   * the plot, and false otherwise.

   * @param axis The horizontal axis;

   * @return True if the axis is compatible with the plot, and false otherwise.

   */
16
  public boolean isCompatibleHorizontalAxis(Axis axis) {

  if (axis instanceof HorizontalNumberAxis) {

    return true;

  }

  else if (axis instanceof HorizontalDateAxis) {

    return true;

  }

  else return false;

###
3541, getDataset, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 148, 149
7
/**

   * A convenience method that returns the dataset for the plot, cast as an XYDataset.

   * @return The dataset for the plot, cast as an XYDataset.

   */
4
  public XYDataset getDataset() {

  return (XYDataset)chart.getDataset();

###
3542, getMinimumVerticalDataValue, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 509, 515
9
/**

   * Returns the minimum value in the range, since this is plotted against the vertical axis for

   * an XYPlot.

   * @return The minimum value to be plotted against the vertical axis.

   */
12
  public Number getMinimumVerticalDataValue() {

  Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMinimumRangeValue(data);

  }

  else return null;

###
3543, addVerticalLine, XYPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/XYPlot.java, 164, 172
7
/**

   * Adds a vertical of the given color at location with the given color.

   * @return void

   */
14
  public void addVerticalLine(Number location, Paint color) {

    if (verticalLines == null) {

      verticalLines = new ArrayList();

      verticalColors = new ArrayList();

    }

    verticalColors.add(color);

    verticalLines.add(location);

###
3549, getEffect3d, VerticalNumberAxis3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 184, 185
5
/**

   * Return axis 3d deep along 'Z' axis.

   */
4
  public double getEffect3d() {

    return effect3d;

###
3550, VerticalNumberAxis3D, VerticalNumberAxis3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 75, 80
7
/**

   * Constructs a VerticalNumberAxis3D, with the specified label and default attributes.

   * @param label The axis label.

   */
10
  public VerticalNumberAxis3D(String label) {

  this(label,

       Axis.DEFAULT_AXIS_LABEL_FONT,

       ValueAxis.DEFAULT_MINIMUM_AXIS_VALUE,

       ValueAxis.DEFAULT_MAXIMUM_AXIS_VALUE);

###
3551, VerticalNumberAxis3D, VerticalNumberAxis3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 91, 117
13
/**

   * Constructs a VerticalNumberAxis3D, using default attributes where necessary.

   * @param label The axis label.

   * @param labelFont The font for displaying the axis label.

   * @param minimumAxisValue The lowest value shown on the axis.

   * @param maximumAxisValue The highest value shown on the axis.

   */
52
  public VerticalNumberAxis3D(String label, Font labelFont,

          double minimumAxisValue, double maximumAxisValue) {

  this(label, labelFont,

       Axis.DEFAULT_AXIS_LABEL_PAINT,

       Axis.DEFAULT_AXIS_LABEL_INSETS,

       true,  // vertical label

     true,  // show tick labels

       Axis.DEFAULT_TICK_LABEL_FONT,

       Axis.DEFAULT_TICK_LABEL_PAINT,

       Axis.DEFAULT_TICK_LABEL_INSETS,

     true,  // show tick marks

       Axis.DEFAULT_TICK_STROKE,

       true,  // autorange

       true,  // autorange includes zero

       NumberAxis.DEFAULT_MINIMUM_AUTO_RANGE,

     minimumAxisValue, maximumAxisValue,

       false, // inverted

     true,

       NumberAxis.DEFAULT_TICK_UNIT,

       false,  // show grid lines

       ValueAxis.DEFAULT_GRID_LINE_STROKE,

       ValueAxis.DEFAULT_GRID_LINE_PAINT,

       0.0,

       ValueAxis.DEFAULT_CROSSHAIR_STROKE,

       ValueAxis.DEFAULT_CROSSHAIR_PAINT,

       DEFAULT_EFFECT_3D);

###
3552, VerticalNumberAxis3D, VerticalNumberAxis3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 153, 177
63
/**

   * Constructs a new VerticalNumberAxis3D.

   * @param label The axis label.

   * @param labelFont The font for displaying the axis label.

   * @param labelPaint The paint used to draw the axis label.

   * @param labelInsets Determines the amount of blank space around the label.

   * @param verticalLabel Flag indicating whether or not the label is drawn vertically.

   * @param showTickLabels Flag indicating whether or not tick labels are visible.

   * @param tickLabelFont The font used to display tick labels.

   * @param tickLabelPaint The paint used to draw tick labels.

   * @param tickLabelInsets Determines the amount of blank space around tick labels.

   * @param showTickMarks Flag indicating whether or not tick marks are visible.

   * @param tickMarkStroke The stroke used to draw tick marks (if visible).

   * @param autoRange Flag indicating whether or not the axis is automatically scaled to fit the

   *          data.

   * @param autoRangeIncludesZero A flag indicating whether or not zero *must* be displayed on

   *                axis.

   * @param autoRangeMinimum The smallest automatic range allowed.

   * @param minimumAxisValue The lowest value shown on the axis.

   * @param maximumAxisValue The highest value shown on the axis.

   * @param inverted A flag indicating whether the axis is normal or inverted (inverted means

   *         running from positive to negative).

   * @param autoTickUnit A flag indicating whether or not the tick units are automatically

   *           selected.

   * @param showGridLines Flag indicating whether or not grid lines are visible for this axis.

   * @param gridStroke The Stroke used to display grid lines (if visible).

   * @param gridPaint The Paint used to display grid lines (if visible).

   * @param crosshairValue The value at which to draw an optional crosshair (null permitted).

   * @param crosshairStroke The pen/brush used to draw the crosshair.

   * @param crosshairPaint The color used to draw the crosshair.

   * @param effect3d 'Z' axis deep.

   */
46
  public VerticalNumberAxis3D(String label, Font labelFont, Paint labelPaint, Insets labelInsets,

          boolean verticalLabel,

          boolean showTickLabels, Font tickLabelFont, Paint tickLabelPaint,

                Insets tickLabelInsets,

          boolean showTickMarks, Stroke tickMarkStroke,

          boolean autoRange, boolean autoRangeIncludesZero,

                Number autoRangeMinimum,

          double minimumAxisValue, double maximumAxisValue,

                boolean inverted,

          boolean autoTickUnit, NumberTickUnit tickUnit,

          boolean showGridLines, Stroke gridStroke, Paint gridPaint,

                double crosshairValue, Stroke crosshairStroke, Paint crosshairPaint,

                double effect3d) {

  super(label, labelFont, labelPaint, labelInsets, verticalLabel, showTickLabels,

        tickLabelFont, tickLabelPaint,

      tickLabelInsets, showTickMarks, tickMarkStroke,

      autoRange, autoRangeIncludesZero, autoRangeMinimum,

      minimumAxisValue, maximumAxisValue,

        inverted,

        autoTickUnit, tickUnit,

        showGridLines, gridStroke, gridPaint,

        crosshairValue, crosshairStroke, crosshairPaint);

  this.effect3d = effect3d;

###
3553, VerticalNumberAxis3D, VerticalNumberAxis3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 67, 68
5
/**

   * Constructs a VerticalNumberAxis3D, with no label and default attributes.

   */
4
  public VerticalNumberAxis3D() {

  this(null);

###
3554, draw, VerticalNumberAxis3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis3D.java, 194, 240
11
/**

   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).

   * @param g2 The graphics device.

   * @param drawArea The area within which the chart should be drawn.

   * @param plotArea The area within which the plot should be drawn (a subset of the drawArea).

   */
88
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

  // draw the axis label

  if (this.label!=null) {

    g2.setFont(labelFont);

    g2.setPaint(labelPaint);

    Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());

    if (labelDrawnVertical) {

    double xx = drawArea.getX()+labelInsets.left+labelBounds.getHeight();

    double yy = plotArea.getY()+plotArea.getHeight()/2+(labelBounds.getWidth()/2);

    drawVerticalString(label, g2, (float)xx, (float)yy);

    }

    else {

    double xx = drawArea.getX()+labelInsets.left;

    double yy = drawArea.getY()+drawArea.getHeight()/2-labelBounds.getHeight()/2;

    g2.drawString(label, (float)xx, (float)yy);

    }

  }

  // draw the tick labels and marks and gridlines

  this.refreshTicks(g2, drawArea, plotArea);

  double xx = plotArea.getX();

  g2.setFont(tickLabelFont);

  Iterator iterator = ticks.iterator();

  while (iterator.hasNext()) {

    Tick tick = (Tick)iterator.next();

    float yy = (float)this.translateValueToJava2D(tick.getNumericalValue(), plotArea);

    if (tickLabelsVisible) {

    g2.setPaint(this.tickLabelPaint);

    g2.drawString(tick.getText(), tick.getX(), tick.getY());

    }

    if (tickMarksVisible) {

    g2.setStroke(this.getTickMarkStroke());

    Line2D mark = new Line2D.Double(plotArea.getX()-2, yy,

            plotArea.getX(), yy);

    g2.draw(mark);

    }

    if (gridLinesVisible) {

    g2.setStroke(gridStroke);

    g2.setPaint(gridPaint);

    Line2D gridline = new Line2D.Double(xx+effect3d, yy-effect3d,

              plotArea.getMaxX(), yy-effect3d);

    g2.draw(gridline);

    Line2D grid3Dline = new Line2D.Double(xx, yy,

              xx+effect3d, yy-effect3d);

    g2.draw(grid3Dline);

###
3555, getMin, AbstractAxisRange, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/AbstractAxisRange.java, 68, 69
5
/**

   * Returns the min of the range.

   */
4
  public Object getMin() {

    return min;

###
3556, getMax, AbstractAxisRange, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/AbstractAxisRange.java, 75, 76
5
/**

   * Returns the max of the range.

   */
4
  public Object getMax() {

    return max;

###
3557, after, AbstractAxisRange, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/AbstractAxisRange.java, 111, 112
11
/**

   * Returns true if o1 is after o2.

   *

   * @param o1 Object #1 to compare.

   * @param o2 Object #2 to compare.

   */
4
  protected boolean after(Object o1, Object o2) {

    return (!o1.equals(o2) && !before(o1, o2));

###
3559, AbstractAxisRange, AbstractAxisRange, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/AbstractAxisRange.java, 60, 62
11
/**

   * Creates an AbstractAxisRange object.

   *

   * @param min Minimum value

   * @param max Maximum value

   */
6
  public AbstractAxisRange(Object min, Object max) {

    this.min = min;

    this.max = max;

###
3560, combine, AbstractAxisRange, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/AbstractAxisRange.java, 85, 92
11
/**

   * Combines this with range. The result will be a range that contains both

   * this and range.

   *

   * @param range Range to combine with this.

   */
16
  public void combine(AxisRange range) {

    Object otherMin = range.getMin();

    Object otherMax = range.getMax();

    if (before(otherMin, min)) {

      min = otherMin;

    }

    if (after(otherMax, max)) {

      max = otherMax;

###
3563, CombinedChart, CombinedChart, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedChart.java, 61, 62
13
/**

   * Standard constructor: returns a CombinedCart for displaying a dataset and

   * a plot.

   *

   * @param data The data to be represented in the chart.

   * @param plot Controller of the visual representation of the data.

   */
4
  public CombinedChart(Dataset data, Plot plot) {

    super(data, plot, null, null, false);

###
3569, reserveAxisArea, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 408, 435
13
/**

   * Returns area in which the axis will be displayed.

   * @param g2 The graphics device;

   * @param plot A reference to the plot;

   * @param drawArea The area in which the plot and axes should be drawn;

   * @param reservedHeight The height reserved for the horizontal axis;

   */
50
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,

             double reservedHeight) {

  // calculate the width of the axis label...

  double labelWidth = 0.0;

  if (label!=null) {

    Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());

    labelWidth = labelInsets.left+labelInsets.right;

    if (this.labelDrawnVertical) {

    labelWidth = labelWidth + labelBounds.getHeight();  // assume width == height before rotation

    }

    else {

    labelWidth = labelWidth + labelBounds.getWidth();

    }

  }

  // calculate the width of the tick labels

  double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;

  if (tickLabelsVisible) {

    Rectangle2D approximatePlotArea = new Rectangle2D.Double(drawArea.getX(), drawArea.getY(),

                   drawArea.getWidth(),

                   drawArea.getHeight()-reservedHeight);

    this.refreshTicks(g2, drawArea, approximatePlotArea);

    tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, approximatePlotArea);

  }

  return new Rectangle2D.Double(drawArea.getX(), drawArea.getY(), labelWidth+tickLabelWidth,

            drawArea.getHeight()-reservedHeight);

###
3570, isLabelDrawnVertical, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 198, 199
11
/**

   * Returns a flag that indicates whether or not the axis label is drawn with a vertical

   * orientation (this saves space).

   * @return A flag that indicates whether or not the axis label is drawn with a vertical

   * orientation.

   */
4
  public boolean isLabelDrawnVertical() {

  return this.labelDrawnVertical;

###
3571, VerticalNumberAxis, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 160, 188
63
/**

   * Constructs a vertical number axis.

   * @param label The axis label.

   * @param labelFont The font for displaying the axis label.

   * @param labelPaint The paint used to draw the axis label.

   * @param labelInsets Determines the amount of blank space around the label.

   * @param labelDrawnVertical Flag indicating whether or not the label is drawn vertically.

   * @param tickLabelsVisible Flag indicating whether or not tick labels are visible.

   * @param tickLabelFont The font used to display tick labels.

   * @param tickLabelPaint The paint used to draw tick labels.

   * @param tickLabelInsets Determines the amount of blank space around tick labels.

   * @param showTickMarks Flag indicating whether or not tick marks are visible.

   * @param tickMarkStroke The stroke used to draw tick marks (if visible).

   * @param autoRange Flag indicating whether or not the axis is automatically scaled to fit the

   *          data.

   * @param autoRangeIncludesZero A flag indicating whether or not zero *must* be displayed on

   *                axis.

   * @param autoRangeMinimum The smallest automatic range allowed.

   * @param minimumAxisValue The lowest value shown on the axis.

   * @param maximumAxisValue The highest value shown on the axis.

   * @param inverted A flag indicating whether the axis is normal or inverted (inverted means

   *         running from positive to negative).

   * @param autoTickUnitSelection A flag indicating whether or not the tick units are

   *                selected automatically.

   * @param tickUnit The tick unit.

   * @param showGridLines Flag indicating whether or not grid lines are visible for this axis.

   * @param gridStroke The pen/brush used to display grid lines (if visible).

   * @param gridPaint The color used to display grid lines (if visible).

   * @param crosshairValue The value at which to draw an optional crosshair (null permitted).

   * @param crosshairStroke The pen/brush used to draw the crosshair.

   * @param crosshairPaint The color used to draw the crosshair.

   */
54
  public VerticalNumberAxis(String label,

                Font labelFont, Paint labelPaint, Insets labelInsets,

          boolean labelDrawnVertical,

          boolean tickLabelsVisible, Font tickLabelFont, Paint tickLabelPaint,

                Insets tickLabelInsets,

          boolean tickMarksVisible, Stroke tickMarkStroke,

          boolean autoRange, boolean autoRangeIncludesZero,

                Number autoRangeMinimum,

          double minimumAxisValue, double maximumAxisValue,

                boolean inverted,

          boolean autoTickUnitSelection,

                NumberTickUnit tickUnit,

           boolean gridLinesVisible, Stroke gridStroke, Paint gridPaint,

                double crosshairValue, Stroke crosshairStroke, Paint crosshairPaint) {

  super(label,

        labelFont, labelPaint, labelInsets,

        tickLabelsVisible,

        tickLabelFont, tickLabelPaint, tickLabelInsets,

        tickMarksVisible,

        tickMarkStroke,

      autoRange, autoRangeIncludesZero, autoRangeMinimum,

      minimumAxisValue, maximumAxisValue,

        inverted,

        autoTickUnitSelection, tickUnit,

        gridLinesVisible, gridStroke, gridPaint,

        crosshairValue, crosshairStroke, crosshairPaint);

  this.labelDrawnVertical = labelDrawnVertical;

###
3572, VerticalNumberAxis, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 69, 71
5
/**

   * Constructs a vertical number axis, using default values where necessary.

   */
4
  public VerticalNumberAxis() {

    this(null);

###
3573, VerticalNumberAxis, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 97, 124
13
/**

   * Constructs a vertical number axis.

   * @param label The axis label (null permitted).

   * @param labelFont The font for displaying the axis label.

   * @param minimumAxisValue The lowest value shown on the axis.

   * @param maximumAxisValue The highest value shown on the axis.

   */
54
  public VerticalNumberAxis(String label, Font labelFont,

          double minimumAxisValue, double maximumAxisValue) {

  this(label,

       labelFont,

       Axis.DEFAULT_AXIS_LABEL_PAINT,

       Axis.DEFAULT_AXIS_LABEL_INSETS,

       true, // vertical axis label

       true, // tick labels visible

       Axis.DEFAULT_TICK_LABEL_FONT,

       Axis.DEFAULT_TICK_LABEL_PAINT,

       Axis.DEFAULT_TICK_LABEL_INSETS,

     true, // tick marks visible

       Axis.DEFAULT_TICK_STROKE,

       true, // auto range

       true, // auto range includes zero

       NumberAxis.DEFAULT_MINIMUM_AUTO_RANGE,

     minimumAxisValue,

       maximumAxisValue,

       false, // inverted

     true, // auto tick unit selection

       NumberAxis.DEFAULT_TICK_UNIT,

     true, // grid lines visible

       ValueAxis.DEFAULT_GRID_LINE_STROKE,

       ValueAxis.DEFAULT_GRID_LINE_PAINT,

       0.0,

       ValueAxis.DEFAULT_CROSSHAIR_STROKE,

       ValueAxis.DEFAULT_CROSSHAIR_PAINT);

###
3574, setLabelDrawnVertical, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 207, 211
9
/**

   * Sets the flag that controls whether or not the axis label is drawn with a vertical

   * orientation.

   * @param flag The flag.

   */
8
  public void setLabelDrawnVertical(boolean flag) {

    if (this.labelDrawnVertical!=flag) {

    this.labelDrawnVertical = flag;

    this.notifyListeners(new AxisChangeEvent(this));

###
3575, selectAutoTickUnit, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 446, 468
13
/**

   * Selects an appropriate tick value for the axis.  The strategy is to display as many ticks as

   * possible (selected from an array of 'standard' tick units) without the labels overlapping.

   * @param g2 The graphics device;

   * @param drawArea The area in which the plot and axes should be drawn;

   * @param plotArea The area in which the plot should be drawn;

   */
36
  private void selectAutoTickUnit(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

    // calculate the tick label height...

    FontRenderContext frc = g2.getFontRenderContext();

    double tickLabelHeight = tickLabelFont.getLineMetrics("123", frc).getHeight()

                 +this.tickLabelInsets.top+this.tickLabelInsets.bottom;

    // now find the smallest tick unit that will accommodate the labels...

  double zero = this.translateValueToJava2D(0.0, plotArea);

    // start with the current tick unit...

    NumberTickUnit candidate1

             = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(this.tickUnit);

    double y = this.translateValueToJava2D(candidate1.getValue().doubleValue(), plotArea);

    double unitHeight = Math.abs(y-zero);

    // then extrapolate...

    double bestguess = (tickLabelHeight/unitHeight) * candidate1.value.doubleValue();

    NumberTickUnit guess = new NumberTickUnit(new Double(bestguess), null);

    NumberTickUnit candidate2

               = (NumberTickUnit)this.standardTickUnits.getNearestTickUnit(guess);

    this.tickUnit = candidate2;

###
3577, reserveWidth, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 376, 397
11
/**

   * Returns the width required to draw the axis in the specified draw area.

   * @param g2 The graphics device;

   * @param plot A reference to the plot;

   * @param drawArea The area within which the plot should be drawn.

   */
40
  public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

  // calculate the width of the axis label...

  double labelWidth = 0.0;

  if (label!=null) {

    Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());

    labelWidth = labelInsets.left+labelInsets.right;

    if (this.labelDrawnVertical) {

    labelWidth = labelWidth + labelBounds.getHeight();  // assume width == height before rotation

    }

    else {

    labelWidth = labelWidth + labelBounds.getWidth();

    }

  }

  // calculate the width required for the tick labels (if visible);

  double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;

  if (tickLabelsVisible) {

    this.refreshTicks(g2, drawArea, drawArea);

    tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);

  }

  return labelWidth+tickLabelWidth;

###
3578, refreshTicks, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 479, 504
13
/**

   * Calculates the positions of the tick labels for the axis, storing the results in the

   * tick label list (ready for drawing).

   * @param g2 The graphics device.

   * @param drawArea The area in which the plot and the axes should be drawn.

   * @param plotArea The area in which the plot should be drawn.

   */
44
  public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

  this.ticks.clear();

  g2.setFont(tickLabelFont);

  if (this.autoTickUnitSelection) {

    selectAutoTickUnit(g2, drawArea, plotArea);

  }

  double size = this.tickUnit.getValue().doubleValue();

  int count = this.calculateVisibleTickCount();

  double lowestTickValue = this.calculateLowestVisibleTickValue();

  //tickLabelFormatter = new DecimalFormat(tickLabelFormatter.toPattern());

  for (int i=0; i<count; i++) {

    Number currentTickValue = new Double(lowestTickValue+(i*size));

    double yy = this.translateValueToJava2D(currentTickValue.doubleValue(), plotArea);

    String tickLabel = this.valueToString(currentTickValue.doubleValue());

    Rectangle2D tickLabelBounds = tickLabelFont.getStringBounds(tickLabel,

                                    g2.getFontRenderContext());

    float x = (float)(plotArea.getX()

                -tickLabelBounds.getWidth()

                -tickLabelInsets.left-tickLabelInsets.right);

    float y = (float)(yy+(tickLabelBounds.getHeight()/2));

    Tick tick = new Tick(currentTickValue, tickLabel, x, y);

    ticks.add(tick);

###
3579, VerticalNumberAxis, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 79, 86
7
/**

   * Constructs a vertical number axis, using default values where necessary.

   * @param label The axis label (null permitted).

   */
12
  public VerticalNumberAxis(String label) {

  this(label,

       Axis.DEFAULT_AXIS_LABEL_FONT,

       ValueAxis.DEFAULT_MINIMUM_AXIS_VALUE,

       ValueAxis.DEFAULT_MAXIMUM_AXIS_VALUE);

    this.autoRange = true;

###
3580, configure, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 220, 222
7
/**

   * Configures the axis to work with the specified plot.  If the axis has auto-scaling, then sets

   * the maximum and minimum values.

   */
6
  public void configure() {

  if (isAutoRange()) {

    autoAdjustRange();

###
3581, draw, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 555, 635
12
/**

   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).

   * @param g2 The graphics device;

   * @param drawArea The area within which the chart should be drawn.

   * @param plotArea The area within which the plot should be drawn (a subset of the drawArea).

   */

82
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

  // draw the axis label

  if (this.label!=null) {

    g2.setFont(labelFont);

    g2.setPaint(labelPaint);

    Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());

    if (labelDrawnVertical) {

    double xx = drawArea.getX()+labelInsets.left+labelBounds.getHeight();

    double yy = plotArea.getY()+plotArea.getHeight()/2+(labelBounds.getWidth()/2);

    drawVerticalString(label, g2, (float)xx, (float)yy);

    }

    else {

    double xx = drawArea.getX()+labelInsets.left;

    double yy = drawArea.getY()+drawArea.getHeight()/2-labelBounds.getHeight()/2;

    g2.drawString(label, (float)xx, (float)yy);

    }

  }

  // draw the tick labels and marks and gridlines

  this.refreshTicks(g2, drawArea, plotArea);

  double xx = plotArea.getX();

  g2.setFont(tickLabelFont);

  Iterator iterator = ticks.iterator();

  while (iterator.hasNext()) {

    Tick tick = (Tick)iterator.next();

    float yy = (float)this.translateValueToJava2D(tick.getNumericalValue(), plotArea);

    if (tickLabelsVisible) {

    g2.setPaint(this.tickLabelPaint);

    g2.drawString(tick.getText(), tick.getX(), tick.getY());

    }

    if (tickMarksVisible) {

    g2.setStroke(this.getTickMarkStroke());

    Line2D mark = new Line2D.Double(plotArea.getX()-2, yy,

            plotArea.getX()+2, yy);

    g2.draw(mark);

    }

    if (gridLinesVisible) {

    g2.setStroke(gridStroke);

    g2.setPaint(gridPaint);

    Line2D gridline = new Line2D.Double(xx, yy,

              plotArea.getMaxX(), yy);

    g2.draw(gridline);

###
3582, autoAdjustRange, VerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalNumberAxis.java, 270, 307
5
/**

   * Rescales the axis to ensure that all data is visible.

   */
62
  public void autoAdjustRange() {

  if (plot!=null) {

    if (plot instanceof VerticalValuePlot) {

    VerticalValuePlot vvp = (VerticalValuePlot)plot;

        Number u = vvp.getMaximumVerticalDataValue();

        double upper = this.DEFAULT_MAXIMUM_AXIS_VALUE;

        if (u!=null) {

      upper = u.doubleValue();

        }

        Number l = vvp.getMinimumVerticalDataValue();

        double lower = this.DEFAULT_MINIMUM_AXIS_VALUE;

        if (l!=null) {

      lower = l.doubleValue();

        }

    double range = upper-lower;

        // ensure the autorange is at least <minRange> in size...

    double minRange = this.autoRangeMinimumSize.doubleValue();

    if (range<minRange) {

      upper = (upper+lower+minRange)/2;

      lower = (upper+lower-minRange)/2;

    }

    if (this.autoRangeIncludesZero()) {

      if (upper!=0.0) upper = Math.max(0.0, upper+upperMargin*range);

      if (lower!=0.0) lower = Math.min(0.0, lower-lowerMargin*range);

    }

    else {

      if (upper!=0.0) upper = upper+upperMargin*range;

      if (lower!=0.0) lower = lower-lowerMargin*range;

    }

    this.minimumAxisValue=lower;

    this.maximumAxisValue=upper;

###
3583, getMinimumVerticalDataValue, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 447, 453
7
/**

   * Returns the minimum value in the range, since this is plotted against the vertical axis for

   * BarPlot.

   */
12
  public Number getMinimumVerticalDataValue() {

  Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMinimumRangeValue(data);

  }

  else return null;

###
3584, getCategoryAxis, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 158, 159
7
/**

   * A convenience method that returns a reference to the horizontal axis cast as a

   * CategoryAxis.

   */
4
  public CategoryAxis getCategoryAxis() {

  return (CategoryAxis)horizontalAxis;

###
3585, isCompatibleHorizontalAxis, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 214, 218
9
/**

   * Checks the compatibility of a horizontal axis, returning true if the axis is compatible with

   * the plot, and false otherwise.

   * @param axis The horizontal axis;

   */
10
  public boolean isCompatibleHorizontalAxis(Axis axis) {

  if (axis instanceof CategoryAxis) {

    return true;

  }

  else return false;

###
3586, setVerticalAxis, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 149, 151
9
/**

   * Sets the vertical axis for the plot.  This method should throw an exception if the axis

   * doesn't implement the required interfaces.

   * @param vAxis The new vertical axis.

   */
6
  public void setVerticalAxis(Axis vAxis) throws AxisNotCompatibleException {

  // check that the axis implements the required interface (if not raise an exception);

  super.setVerticalAxis(vAxis);

###
3587, getCategoryCoordinate, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 184, 205
9
/**

   * Returns the x-coordinate (in Java 2D User Space) of the center of the specified category.

   * @param category The index of the category of interest (first category index = 0);

   * @param area The region within which the plot will be drawn.

   */
36
  public double getCategoryCoordinate(int category, Rectangle2D area) {

    // calculate first part of result...

    double result = area.getX() + (area.getWidth()*introGapPercent);

    // then add some depending on how many categories...

  int categoryCount = getDataset().getCategoryCount();

    if (categoryCount>1) {

    double categorySpan = area.getWidth()

                  * (1-introGapPercent-trailGapPercent-categoryGapsPercent);

      double categoryGapSpan = area.getWidth()*categoryGapsPercent;

      result = result

           + (category+0.5)*(categorySpan/categoryCount)

           + (category)*(categoryGapSpan/(categoryCount-1));

    }

    else {

      result = result

           + (category+0.5)*area.getWidth()*(1-introGapPercent-trailGapPercent);

    }

    return result;

###
3588, getRangeAxis, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 140, 141
5
/**

   * Returns the range axis.

   */
4
  public ValueAxis getRangeAxis() {

  return (ValueAxis)verticalAxis;

###
3589, calculateBarWidth, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 415, 433
7
/**

   * Returns the width of each bar in the chart.

   * @param area The area within which the plot will be drawn.

   */
28
  double calculateBarWidth(Rectangle2D plotArea) {

  CategoryDataset data = getDataset();

  // series, category and bar counts

  int categoryCount = data.getCategoryCount();

  int seriesCount = data.getSeriesCount();

  int barCount = renderer.barWidthsPerCategory(data)*categoryCount;

  // calculate the plot width (bars are vertical) less whitespace

    double usable = plotArea.getWidth() *

                  (1.0 - introGapPercent - trailGapPercent - categoryGapsPercent);

    if (renderer.barWidthsPerCategory(data)>1) {

//    usable = usable - ((seriesCount-1) * categoryCount * seriesGap);

    }

  // and thus the width of the bars

  return usable/barCount;

###
3590, getPlotType, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 439, 440
5
/**

   * Returns a short string describing the type of plot.

   */
4
  public String getPlotType() {

  return "Bar Plot";

###
3591, VerticalBarPlot, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 106, 117
23
/**

   * Constructs a new vertical bar plot.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   * @param introGapPercent The gap before the first bar in the plot, as a percentage of the

   *            available drawing space.

   * @param trailGapPercent The gap after the last bar in the plot, as a percentage of the

   *            available drawing space.

   * @param categoryGapPercent The percentage of drawing space allocated to the gap between the

   *               last bar in one category and the first bar in the next category.

   * @param itemGapPercent The gap between bars within the same category.

   */
20
  public VerticalBarPlot(CategoryAxis horizontalAxis, ValueAxis verticalAxis,

               Insets insets,

         double introGapPercent, double trailGapPercent,

               double categoryGapPercent, double itemGapPercent,

               CategoryToolTipGenerator toolTipGenerator) {

  super(horizontalAxis, verticalAxis,

        insets,

      introGapPercent, trailGapPercent, categoryGapPercent, itemGapPercent,

        toolTipGenerator);

    this.renderer = new VerticalBarRenderer();

###
3592, draw, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 239, 288
11
/**

   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).

   * @param g2 The graphics device.

   * @param plotArea The area within which the plot should be drawn.

   * @param info Collects info as the chart is drawn.

   */
82
  public void draw(Graphics2D g2, Rectangle2D plotArea, DrawInfo info) {

    // set up the drawing info...

    ToolTipsCollection tooltips = null;

    if (info!=null) {

      info.setPlotArea(plotArea);

      tooltips = info.getToolTipsCollection();

    }

    // adjust the drawing area for the plot insets (if any)...

  if (insets!=null) {

    plotArea.setRect(plotArea.getX()+insets.left,

               plotArea.getY()+insets.top,

               plotArea.getWidth()-insets.left-insets.right,

         plotArea.getHeight()-insets.top-insets.bottom);

  }

    if ((plotArea.getWidth()>=MINIMUM_WIDTH_TO_DRAW)

     && (plotArea.getHeight()>=MINIMUM_HEIGHT_TO_DRAW)) {

      // estimate the area required for drawing the axes...

      HorizontalAxis hAxis = getHorizontalAxis();

      VerticalAxis vAxis = getVerticalAxis();

      double hAxisAreaHeight = hAxis.reserveHeight(g2, this, plotArea);

      Rectangle2D vAxisArea = vAxis.reserveAxisArea(g2, this, plotArea, hAxisAreaHeight);

      // and thus the area available for plotting...

      Rectangle2D dataArea = new Rectangle2D.Double(plotArea.getX()+vAxisArea.getWidth(),

                              plotArea.getY(),

                              plotArea.getWidth()-vAxisArea.getWidth(),

                              plotArea.getHeight()-hAxisAreaHeight);

      if (info!=null) {

        info.setDataArea(dataArea);

      }

      Shape backgroundPlotArea = calculateBackgroundPlotArea(dataArea);

      // draw the background and axes...

      drawOutlineAndBackground(g2, backgroundPlotArea);

      getCategoryAxis().draw(g2, plotArea, dataArea);

      getRangeAxis().draw(g2, plotArea, dataArea);

      drawBars(g2, backgroundPlotArea, dataArea, info);

      // draw horizontal crosshair if required...

      ValueAxis vva = this.getRangeAxis();

      if (vva.isCrosshairVisible()) {

        this.drawHorizontalLine(g2, dataArea, vva.getCrosshairValue(),

                    vva.getCrosshairStroke(),

                    vva.getCrosshairPaint());

###
3593, setRenderer, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 125, 127
7
/**

   * Sets the renderer for the bar plot.

   * @param renderer The renderer.

   */
6
  public void setRenderer(VerticalBarRenderer renderer) {

    this.renderer = renderer;

    this.notifyListeners(new PlotChangeEvent(this));

###
3594, calculateBackgroundPlotArea, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 298, 299
5
/**

   * Returns chart's background area.

   */
4
  protected Shape calculateBackgroundPlotArea(Rectangle2D plotArea) {

    return plotArea;

###
3595, getMaximumVerticalDataValue, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 461, 467
7
/**

   * Returns the maximum value in either the domain or the range, whichever is displayed against

   * the vertical axis for the particular type of plot implementing this interface.

   */
12
  public Number getMaximumVerticalDataValue() {

  Dataset data = this.getChart().getDataset();

  if (data!=null) {

    return Datasets.getMaximumRangeValue(data);

  }

  else return null;

###
3596, getCategories, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 175, 176
5
/**

   * A convenience method that returns a list of the categories in the dataset.

   */
4
  public java.util.List getCategories() {

  return getDataset().getCategories();

###
3597, VerticalBarPlot, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 81, 89
9
/**

   * Constructs a new vertical bar plot.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   */
16
  public VerticalBarPlot(CategoryAxis horizontalAxis, ValueAxis verticalAxis) {

  this(horizontalAxis, verticalAxis,

       Plot.DEFAULT_INSETS,

       BarPlot.DEFAULT_INTRO_GAP_PERCENT,

       BarPlot.DEFAULT_TRAIL_GAP_PERCENT,

       BarPlot.DEFAULT_CATEGORY_GAPS_PERCENT,

       BarPlot.DEFAULT_ITEM_GAPS_PERCENT,

       null

###
3598, getDataset, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 133, 134
5
/**

   * A convenience method that returns the dataset for the plot, cast as a CategoryDataset.

   */
4
  public CategoryDataset getDataset() {

  return (CategoryDataset)chart.getDataset();

###
3599, isCompatibleVerticalAxis, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 226, 230
9
/**

   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with

   * the plot, and false otherwise.

   * @param axis The vertical axis;

   */
10
  public boolean isCompatibleVerticalAxis(Axis axis) {

  if (axis instanceof VerticalNumberAxis) {

    return true;

  }

  else return false;

###
3600, setHorizontalAxis, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 167, 169
9
/**

   * Sets the horizontal axis for the plot.  This method should throw an exception if the axis

   * doesn't implement the required interfaces.

   * @param axis The new horizontal axis.

   */
6
  public void setHorizontalAxis(Axis axis) throws AxisNotCompatibleException {

  // check that the axis implements the required interface (if not raise an exception);

  super.setHorizontalAxis(axis);

###
3601, drawBars, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 308, 387
11
/**

   * Draws charts bars

   * @param g2 The graphics device;

   * @param backgroundPlotArea The area within which will be clipped

   * @param plotArea The area within which the plot should be drawn.

   */
138
  protected void drawBars(Graphics2D g2,

              Shape backgroundPlotArea, Rectangle2D dataArea,

              DrawInfo info) {

    // now get the data and plot the bars...

    CategoryDataset data = this.getDataset();

    if (data!=null) {

      Shape savedClip = g2.getClip();

      g2.clip(backgroundPlotArea);

      int seriesCount = data.getSeriesCount();

      int categoryCount = data.getCategoryCount();

      int barCount = renderer.barWidthsPerCategory(data);

      double translatedZero = getRangeAxis().translateValueToJava2D(0.0, dataArea);

      // work out the span dimensions for the categories...

      double categorySpan = 0.0;

      double categoryGapSpan = 0.0;

      if (categoryCount>1) {

        categorySpan = dataArea.getWidth()

                 * (1-introGapPercent-trailGapPercent-categoryGapsPercent);

        categoryGapSpan = dataArea.getWidth()*categoryGapsPercent;

      }

      else {

        categorySpan = dataArea.getWidth()*(1-introGapPercent-trailGapPercent);

      }

      // work out the item span...

      double itemSpan = categorySpan;

      double itemGapSpan = 0.0;

      if (seriesCount>1) {

        if (renderer.hasItemGaps()) {

          itemGapSpan = dataArea.getWidth()*itemGapsPercent;

          itemSpan = itemSpan - itemGapSpan;

        }

      }

      double itemWidth = itemSpan/(categoryCount*renderer.barWidthsPerCategory(data));

      int categoryIndex = 0;

    Iterator iterator = data.getCategories().iterator();

    while (iterator.hasNext()) {

    Object category = iterator.next();

    for (int series=0; series<seriesCount; series++) {

          Shape tooltipArea = renderer.drawBar(g2,

                             dataArea, this,

                             getRangeAxis(),

                             data, series,

                             category, categoryIndex,

                             translatedZero, itemWidth,

                             categorySpan, categoryGapSpan,

                             itemSpan, itemGapSpan);

          // add a tooltip for the bar...

          if (info!=null) {

            ToolTipsCollection tooltips = info.getToolTipsCollection();

            if (tooltips!=null) {

              if (this.toolTipGenerator==null) {

                toolTipGenerator = new StandardCategoryToolTipGenerator();

              }

              String tip = this.toolTipGenerator.generateToolTip(data, series,

                                         category);

              if (tooltipArea!=null) {

                tooltips.addToolTip(tip, tooltipArea);

              }

            }

          }

        }

        categoryIndex++;

      }

      // draw a line at zero...

      Line2D baseline = new Line2D.Double(dataArea.getX(), translatedZero,

                        dataArea.getMaxX(), translatedZero);

      g2.setStroke(new BasicStroke());

      g2.draw(baseline);

      g2.setClip(savedClip);

###
3602, handleClick, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 474, 480
5
/**

   * Handles a 'click' on the plot by updating the anchor values...

   */
12
  public void handleClick(int x, int y, DrawInfo info) {

    // set the anchor value for the horizontal axis...

    ValueAxis vva = this.getRangeAxis();

    double vvalue = vva.translateJava2DtoValue((float)y, info.getDataArea());

    vva.setAnchorValue(vvalue);

    vva.setCrosshairValue(vvalue);

###
3603, drawOutlineAndBackground, VerticalBarPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot.java, 396, 406
9
/**

   * Draws the plot outline and background.

   * @param g2 The graphics device.

   * @param area The area for the plot.

   */
18
  public void drawOutlineAndBackground(Graphics2D g2, Shape area) {

  if (backgroundPaint!=null) {

    g2.setPaint(backgroundPaint);

    g2.fill(area);

  }

  if ((outlineStroke!=null) && (outlinePaint!=null)) {

    g2.setStroke(outlineStroke);

    g2.setPaint(outlinePaint);

    g2.draw(area);

###
3604, setAutoTickUnitSelection, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 300, 304
13
/**

   * Sets a flag indicating whether or not the tick unit is automatically selected from a

   * range of standard tick units.

   * <P>

   * Registered listeners are notified of a change to the axis.

   * @param flag The new value of the flag.

   */
8
  public void setAutoTickUnitSelection(boolean flag) {

    if (this.autoTickUnitSelection!=flag) {

      this.autoTickUnitSelection = flag;

    notifyListeners(new AxisChangeEvent(this));

###
3605, setCrosshairVisible, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 405, 409
7
/**

   * Sets the flag indicating whether or not a crosshair is visible for this axis.

   * @param flag The new value of the flag.

   */
8
  public void setCrosshairVisible(boolean flag) {

    if (this.crosshairVisible!=flag) {

      this.crosshairVisible=flag;

      notifyListeners(new AxisChangeEvent(this));

###
3606, isGridLinesVisible, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 313, 314
7
/**

   * Returns true if the grid lines are showing, and false otherwise.

   * @return True if the grid lines are showing, and false otherwise.

   */
4
  public boolean isGridLinesVisible() {

  return gridLinesVisible;

###
3607, getGridPaint, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 360, 361
7
/**

   * Returns the grid line color.

   * @return The grid line color.

   */
4
  public Paint getGridPaint() {

  return gridPaint;

###
3608, setGridLinesVisible, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 322, 326
9
/**

   * Sets the visibility of the grid lines and notifies registered listeners that the axis has

   * been modified.

   * @param flag The new setting.

   */
8
  public void setGridLinesVisible(boolean flag) {

    if (gridLinesVisible!=flag) {

      gridLinesVisible = flag;

    notifyListeners(new AxisChangeEvent(this));

###
3609, setCrosshairValue, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 448, 451
11
/**

   * Sets the crosshair value for the axis.

   * <P>

   * Registered listeners are notified that the axis has been modified.

   * @param value The new value (null permitted).

   */
6
  public void setCrosshairValue(double value) {

    this.crosshairValue = value;

    notifyListeners(new AxisChangeEvent(this));

###
3610, setMaximumAxisValue, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 260, 265
11
/**

   * Sets the maximum value for the axis.

   * <P>

   * Registered listeners are notified that the axis has been modified.

   * @param value The new maximum.

   */
10
  public void setMaximumAxisValue(double value) {

  if (this.maximumAxisValue!=value) {

    this.maximumAxisValue = value;

      this.autoRange = false;

      notifyListeners(new AxisChangeEvent(this));

###
3611, getMinimumAxisValue, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 227, 228
7
/**

   * Returns the minimum value for the axis.

   * @return The minimum value for the axis.

   */
4
  public double getMinimumAxisValue() {

  return minimumAxisValue;

###
3612, setAnchorValue, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 389, 391
5
/**

   * Sets the anchor value for this axis.

   */
6
  public void setAnchorValue(double value) {

    this.anchorValue = value;

    notifyListeners(new AxisChangeEvent(this));

###
3613, setCrosshairStroke, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 467, 469
9
/**

   * Sets the Stroke used to draw the grid lines (if visible) and notifies registered listeners

   * that the axis has been modified.

   * @param stroke The new grid line stroke.

   */
6
  public void setCrosshairStroke(Stroke stroke) {

  crosshairStroke = stroke;

  notifyListeners(new AxisChangeEvent(this));

###
3614, getCrosshairPaint, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 476, 477
7
/**

   * Returns the grid line color.

   * @return The grid line color.

   */
4
  public Paint getCrosshairPaint() {

  return crosshairPaint;

###
3615, getCrosshairStroke, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 458, 459
5
/**

   * Returns the Stroke used to draw the crosshair (if visible).

   */
4
  public Stroke getCrosshairStroke() {

  return crosshairStroke;

###
3616, ValueAxis, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 127, 146
7
/**

   * Constructs a value axis, using default values where necessary.

   * @param label The axis label.

   */
38
  public ValueAxis(String label) {

  this(label,

       Axis.DEFAULT_AXIS_LABEL_FONT,

       Axis.DEFAULT_AXIS_LABEL_PAINT,

       Axis.DEFAULT_AXIS_LABEL_INSETS,

       true, // tick labels visible

       Axis.DEFAULT_TICK_LABEL_FONT,

       Axis.DEFAULT_TICK_LABEL_PAINT,

       Axis.DEFAULT_TICK_LABEL_INSETS,

       true, // tick marks visible

       Axis.DEFAULT_TICK_STROKE,

       true, // auto range

       true, // auto tick unit

       true, // show grid lines

       ValueAxis.DEFAULT_GRID_LINE_STROKE,

       ValueAxis.DEFAULT_GRID_LINE_PAINT,

       0.0,  // crosshair

       ValueAxis.DEFAULT_CROSSHAIR_STROKE,

       ValueAxis.DEFAULT_CROSSHAIR_PAINT);

###
3617, getCrosshairValue, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 438, 439
5
/**

   * Returns the crosshair value.

   */
4
  public double getCrosshairValue() {

    return this.crosshairValue;

###
3618, getMaximumAxisValue, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 250, 251
5
/**

   * Returns the maximum value for the axis.

   */
4
  public double getMaximumAxisValue() {

  return maximumAxisValue;

###
3619, setAxisRange, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 275, 280
9
/**

   * Sets the axis range.

   * @param lower The lower axis limit.

   * @param upper The upper axis limit.

   */
10
  public void setAxisRange(double lower, double upper) {

    this.autoRange = false;

    this.minimumAxisValue = lower;

    this.maximumAxisValue = upper;

    notifyListeners(new AxisChangeEvent(this));

###
3620, isCrosshairVisible, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 397, 398
5
/**

   * Returns a flag indicating whether or not a crosshair is visible for this axis.

   */
4
  public boolean isCrosshairVisible() {

    return this.crosshairVisible;

###
3621, setGridPaint, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 369, 376
9
/**

   * Sets the Paint used to color the grid lines (if visible) and notifies registered listeners

   * that the axis has been modified.

   * @param paint The new grid paint.

   */
14
  public void setGridPaint(Paint paint) {

    // check arguments...

    if (paint==null) {

      throw new IllegalArgumentException("ValueAxis.setGridPaint(...): null not permitted");

    }

  gridPaint = paint;

  notifyListeners(new AxisChangeEvent(this));

###
3622, isAutoTickUnitSelection, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 289, 290
9
/**

   * Returns a flag indicating whether or not the tick unit is automatically selected from a

   * range of standard tick units.

   * @return A flag indicating whether or not the tick unit is automatically selected.

   */
4
  public boolean isAutoTickUnitSelection() {

  return autoTickUnitSelection;

###
3623, setGridStroke, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 343, 352
9
/**

   * Sets the Stroke used to draw the grid lines (if visible) and notifies registered listeners

   * that the axis has been modified.

   * @param stroke The new grid line stroke.

   */
16
  public void setGridStroke(Stroke stroke) {

    // check arguments...

    if (stroke==null) {

      throw new IllegalArgumentException("ValueAxis.setGridStroke(...): null not permitted");

    }

    // make the change...

    gridStroke = stroke;

  notifyListeners(new AxisChangeEvent(this));

###
3625, getGridStroke, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 334, 335
5
/**

   * Returns the Stroke used to draw the grid lines (if visible).

   */
4
  public Stroke getGridStroke() {

  return gridStroke;

###
3626, setMinimumAxisValue, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 237, 242
11
/**

   * Sets the minimum value for the axis.

   * <P>

   * Registered listeners are notified that the axis has been modified.

   * @param value The new minimum.

   */
10
  public void setMinimumAxisValue(double value) {

  if (this.minimumAxisValue!=value) {

    this.minimumAxisValue = value;

      this.autoRange = false;

      notifyListeners(new AxisChangeEvent(this));

###
3627, setAutoRange, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 213, 218
9
/**

   * Sets a flag that determines whether or not the axis range is automatically adjusted to fit

   * the data, and notifies registered listeners that the axis has been modified.

   * @param auto Flag indicating whether or not the axis is automatically scaled to fit the data.

   */
10
  public void setAutoRange(boolean auto) {

  if (this.autoRange!=auto) {

    this.autoRange=auto;

    if (autoRange) autoAdjustRange();

    notifyListeners(new AxisChangeEvent(this));

###
3628, setCrosshairLockedOnData, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 426, 430
7
/**

   * Sets the flag indicating whether or not the crosshair should "lock-on" to actual data

   * values.

   */
8
  public void setCrosshairLockedOnData(boolean flag) {

    if (this.crosshairLockedOnData!=flag) {

      this.crosshairLockedOnData=flag;

      notifyListeners(new AxisChangeEvent(this));

###
3629, setCrosshairPaint, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 485, 487
9
/**

   * Sets the Paint used to color the grid lines (if visible) and notifies registered listeners

   * that the axis has been modified.

   * @param paint The new grid paint.

   */
6
  public void setCrosshairPaint(Paint paint) {

  crosshairPaint = paint;

  notifyListeners(new AxisChangeEvent(this));

###
3630, ValueAxis, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 173, 196
45
/**

   * Constructs a value axis.

   * @param label The axis label.

   * @param labelFont The font for displaying the axis label.

   * @param labelPaint The paint used to draw the axis label.

   * @param labelInsets Determines the amount of blank space around the label.

   * @param tickLabelsVisible Flag indicating whether or not the tick labels are visible.

   * @param tickLabelFont The font used to display tick labels.

   * @param tickLabelPaint The paint used to draw tick labels.

   * @param tickLabelInsets Determines the amount of blank space around tick labels.

   * @param tickMarksVisible Flag indicating whether or not the tick marks are visible.

   * @param tickMarkStroke The stroke used to draw tick marks (if visible).

   * @param autoRange Flag indicating whether or not the axis range is automatically adjusted to

   *          fit the data.

   * @param autoTickUnitSelection A flag indicating whether or not the tick unit is automatically

   *                selected.

   * @param gridLinesVisible Flag indicating whether or not grid lines are visible.

   * @param gridStroke The Stroke used to display grid lines (if visible).

   * @param gridPaint The Paint used to display grid lines (if visible).

   * @param crosshairValue The value at which to draw an optional crosshair (null permitted).

   * @param crosshairStroke The pen/brush used to draw the crosshair.

   * @param crosshairPaint The color used to draw the crosshair.

   */
44
  protected ValueAxis(String label,

            Font labelFont, Paint labelPaint, Insets labelInsets,

        boolean tickLabelsVisible,

            Font tickLabelFont, Paint tickLabelPaint, Insets tickLabelInsets,

        boolean tickMarksVisible, Stroke tickMarkStroke,

        boolean autoRange, boolean autoTickUnitSelection,

        boolean gridLinesVisible, Stroke gridStroke, Paint gridPaint,

            double crosshairValue,

            Stroke crosshairStroke, Paint crosshairPaint) {

  super(label,

        labelFont, labelPaint, labelInsets,

      tickLabelsVisible,

        tickLabelFont, tickLabelPaint, tickLabelInsets,

      tickMarksVisible, tickMarkStroke);

  this.autoRange = autoRange;

  this.autoTickUnitSelection = autoTickUnitSelection;

  this.gridLinesVisible = gridLinesVisible;

  this.gridStroke = gridStroke;

  this.gridPaint = gridPaint;

    this.crosshairValue = crosshairValue;

    this.crosshairStroke = crosshairStroke;

    this.crosshairPaint = crosshairPaint;

###
3631, isAutoRange, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 204, 205
7
/**

   * Returns true if the axis range is automatically adjusted to fit the data, and false

   * otherwise.

   */
4
  public boolean isAutoRange() {

  return autoRange;

###
3632, isCrosshairLockedOnData, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 418, 419
7
/**

   * Returns a flag indicating whether or not the crosshair should "lock-on" to actual data

   * values.

   */
4
  public boolean isCrosshairLockedOnData() {

    return this.crosshairLockedOnData;

###
3633, getAnchorValue, ValueAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ValueAxis.java, 382, 383
5
/**

   * Returns the anchor value for this axis.

   */
4
  public double getAnchorValue() {

    return anchorValue;

###
3635, getNearestTickUnit, TickUnits, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/TickUnits.java, 74, 82
9
/**

   * Returns the tick unit in the collection that is closest in size to the specified unit.

   * @param unit The unit.

   * @returns The unit in the collection that is closest in size to the specified unit.

   */
16
  public TickUnit getNearestTickUnit(TickUnit unit) {

    int index = Collections.binarySearch(units, unit);

    if (index>=0) {

      return (TickUnit)units.get(index);

    }

    else {

      index = -(index + 1);

      return (TickUnit)units.get(Math.min(index, units.size()));

###
3636, TickUnits, TickUnits, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/TickUnits.java, 53, 54
5
/**

   * Constructs a new collection of tick units.

   */
4
  public TickUnits() {

    this.units = new ArrayList();

###
3637, add, TickUnits, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/TickUnits.java, 62, 65
9
/**

   * Adds a tick unit to the collection.

   * <P>

   * The tick units are maintained in ascending order.

   */
6
  public void add(TickUnit unit) {

    units.add(unit);

    Collections.sort(units);

###
3638, drawBar, VerticalBarRenderer3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarRenderer3D.java, 78, 177
7
/**

   * Renders an individual bar...there are bug-fixes that have been applied to VerticalBarRenderer

   * that need to be applied here too.

   */
174
  public Shape drawBar(Graphics2D g2, Rectangle2D dataArea, BarPlot plot, ValueAxis valueAxis,

             CategoryDataset data, int series, Object category, int categoryIndex,

             double translatedZero, double itemWidth,

             double categorySpan, double categoryGapSpan,

             double itemSpan, double itemGapSpan) {

    Shape result = null;

    // check the value we are plotting...

    Number value = data.getValue(series, category);

    if (value!=null) {

      // BAR X

      double rectX = dataArea.getX()+dataArea.getWidth()*plot.getIntroGapPercent();

      int categories = data.getCategoryCount();

      int seriesCount = data.getSeriesCount();

      if (categories>1) {

        rectX = rectX

            // bars in completed categories

            + categoryIndex*(categorySpan/categories)

            // gaps between completed categories

            + (categoryIndex*(categoryGapSpan/(categories-1))

            // bars+gaps completed in current category

            + (series*itemSpan/(categories*seriesCount)));

        if (seriesCount>1) {

          rectX = rectX

              + (series*itemGapSpan/(categories*(seriesCount-1)));

        }

      }

      else {

        rectX = rectX

            // bars+gaps completed in current category

            + (series*itemSpan/(categories*seriesCount));

        if (seriesCount>1) {

          rectX = rectX

              + (series*itemGapSpan/(categories*(seriesCount-1)));

        }

      }

      // BAR Y

      double translatedValue = valueAxis.translateValueToJava2D(value.doubleValue(), dataArea);

      double rectY = Math.min(translatedZero, translatedValue);

      // BAR WIDTH

      double rectWidth = itemWidth;

      // BAR HEIGHT

      double rectHeight = Math.abs(translatedValue-translatedZero);

      Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, rectHeight);

      Paint seriesPaint = plot.getSeriesPaint(series);

      g2.setPaint(seriesPaint);

      g2.fill(bar);

      result = bar;

      GeneralPath bar3dRight = null;

      GeneralPath bar3dTop = null;

      double effect3d = 0.00;

      VerticalAxis vAxis = plot.getVerticalAxis();

      if (rectHeight != 0 && vAxis instanceof VerticalNumberAxis3D) {

        effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();

        bar3dRight = new GeneralPath();

        bar3dRight.moveTo((float)(rectX+rectWidth), (float)rectY);

        bar3dRight.lineTo((float)(rectX+rectWidth), (float)(rectY+rectHeight));

        bar3dRight.lineTo((float)(rectX+rectWidth+effect3d),

                  (float)(rectY+rectHeight-effect3d));

        bar3dRight.lineTo((float)(rectX+rectWidth+effect3d), (float)(rectY-effect3d));

        if (seriesPaint instanceof Color) {

          g2.setPaint( ((Color) seriesPaint).darker());

        }

        g2.fill(bar3dRight);

        bar3dTop = new GeneralPath();

        bar3dTop.moveTo( (float) rectX, (float) rectY);

        bar3dTop.lineTo((float) (rectX+effect3d), (float) (rectY-effect3d));

        bar3dTop.lineTo((float) (rectX+rectWidth+effect3d), (float) (rectY-effect3d));

        bar3dTop.lineTo((float) (rectX+rectWidth), (float) (rectY) );

        if (seriesPaint instanceof Color) {

          g2.setPaint( ((Color) seriesPaint)); //.brighter());

        }

        g2.fill(bar3dTop);

      }

      if (itemWidth>3) {

        g2.setStroke(plot.getSeriesOutlineStroke(series));

        //g2.setStroke(new BasicStroke(0.25f));

        g2.setPaint(plot.getSeriesOutlinePaint(series));

        g2.draw(bar);

        if (bar3dRight != null) {

          g2.draw(bar3dRight);

        }

        if (bar3dTop != null) {

          g2.draw(bar3dTop);

        }

      }

    }

    return result;

###
3639, hasItemGaps, VerticalBarRenderer3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarRenderer3D.java, 62, 63
5
/**

   * Returns true, since there are (potentially) gaps between bars in this representation.

   */
4
  public boolean hasItemGaps() {

    return true;

###
3641, barWidthsPerCategory, VerticalBarRenderer3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarRenderer3D.java, 70, 71
7
/**

   * This will be a method in the renderer that tells whether there is one bar width per category

   * or onebarwidth per series per category.

   */
4
  public int barWidthsPerCategory(CategoryDataset data) {

    return data.getSeriesCount();

###
3642, drawBar, VerticalBarRenderer, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarRenderer.java, 92, 154
37
/**

   * Handles the rendering of a single bar.

   * @param g2

   * @param dataArea

   * @param plot

   * @param valueAxis

   * @param data

   * @param series

   * @param category

   * @param categoryIndex

   * @param translatedZero

   * @param itemWidth

   * @param categorySpan

   * @param categoryGapSpan

   * @param itemSpan

   * @param itemGapSpan

   * @return A shape representing the area in which the bar is drawn (one use for this is

   *     supporting tooltips).

   */
108
  public Shape drawBar(Graphics2D g2, Rectangle2D dataArea, BarPlot plot, ValueAxis valueAxis,

             CategoryDataset data, int series, Object category, int categoryIndex,

             double translatedZero, double itemWidth,

             double categorySpan, double categoryGapSpan,

             double itemSpan, double itemGapSpan) {

    Shape result = null;

    // first check the value we are plotting...

    Number value = data.getValue(series, category);

    if (value!=null) {

      // BAR X

      double rectX = dataArea.getX()+dataArea.getWidth()*plot.getIntroGapPercent();

      int categories = data.getCategoryCount();

      int seriesCount = data.getSeriesCount();

      if (categories>1) {

        rectX = rectX

            // bars in completed categories

            + categoryIndex*(categorySpan/categories)

            // gaps between completed categories

            + (categoryIndex*(categoryGapSpan/(categories-1))

            // bars+gaps completed in current category

            + (series*itemSpan/(categories*seriesCount)));

        if (seriesCount>1) {

          rectX = rectX

              + (series*itemGapSpan/(categories*(seriesCount-1)));

        }

      }

      else {

        rectX = rectX

            // bars+gaps completed in current category

            + (series*itemSpan/(categories*seriesCount));

        if (seriesCount>1) {

          rectX = rectX

              + (series*itemGapSpan/(categories*(seriesCount-1)));

        }

      }

      // BAR Y

      double translatedValue = valueAxis.translateValueToJava2D(value.doubleValue(), dataArea);

      double rectY = Math.min(translatedZero, translatedValue);

      // BAR WIDTH

      double rectWidth = itemWidth;

      // BAR HEIGHT

      double rectHeight = Math.abs(translatedValue-translatedZero);

      Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, rectHeight);

      Paint seriesPaint = plot.getSeriesPaint(series);

      g2.setPaint(seriesPaint);

      g2.fill(bar);

      if (itemWidth>3) {

        g2.setStroke(plot.getSeriesStroke(series));

        g2.setPaint(plot.getSeriesOutlinePaint(series));

        g2.draw(bar);

      }

      result = bar;

    }

    return result;

###
3643, hasItemGaps, VerticalBarRenderer, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarRenderer.java, 61, 62
5
/**

   * Returns true, since for this renderer there are gaps between the items in one category.

   */
4
  public boolean hasItemGaps() {

    return true;

###
3644, barWidthsPerCategory, VerticalBarRenderer, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarRenderer.java, 69, 70
7
/**

   * Returns the number of bar-widths displayed in each category.  For this renderer, there is one

   * bar per series, so we return the number of series.

   */
4
  public int barWidthsPerCategory(CategoryDataset data) {

    return data.getSeriesCount();

###
3645, draw, VerticalCategoryAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalCategoryAxis.java, 118, 151
11
/**

   * Draws the CategoryAxis on a Java 2D graphics device (such as the screen or a printer).

   * @param g2 The graphics device.

   * @param drawArea The area within which the axis should be drawn.

   * @param plotArea The area within which the plot is being drawn.

   */
64
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

  // draw the axis label

  if (label!=null) {

      g2.setFont(labelFont);

    g2.setPaint(labelPaint);

    FontRenderContext frc = g2.getFontRenderContext();

    LineMetrics metrics = labelFont.getLineMetrics(label, frc);

    Rectangle2D labelBounds = labelFont.getStringBounds(label, frc);

    if (verticalLabel) {

      double xx = drawArea.getX()+labelInsets.left

                       +metrics.getHeight()

                       -metrics.getDescent()

                   -metrics.getLeading();

      double yy = plotArea.getY()+plotArea.getHeight()/2

                       +(labelBounds.getWidth()/2);

      drawVerticalString(label, g2, (float)xx, (float)yy);

    }

    else {

      double xx = drawArea.getX()+labelInsets.left;

      double yy = drawArea.getY()+drawArea.getHeight()/2-labelBounds.getHeight()/2;

      g2.drawString(label, (float)xx, (float)yy);

    }

    }

  // draw the category labels

  if (this.tickLabelsVisible) {

    g2.setFont(tickLabelFont);

    g2.setPaint(tickLabelPaint);

    this.refreshTicks(g2, drawArea, plotArea);

    Iterator iterator = ticks.iterator();

    while (iterator.hasNext()) {

    Tick tick = (Tick)iterator.next();

    g2.drawString(tick.getText(), tick.getX(), tick.getY());

###
3646, isCompatiblePlot, VerticalCategoryAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalCategoryAxis.java, 263, 265
7
/**

   * Returns true if the specified plot is compatible with the axis, and false otherwise.

   * @param plot The plot;

   */
6
  protected boolean isCompatiblePlot(Plot plot) {

    if (plot instanceof CategoryPlot) return true;

    else return false;

###
3647, refreshTicks, VerticalCategoryAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalCategoryAxis.java, 163, 185
11
/**

   * Creates a temporary list of ticks that can be used when drawing the axis.

   * @param g2 The graphics device (used to get font measurements).

   * @param drawArea The area where the plot and axes will be drawn.

   * @param plotArea The area inside the axes.

   */
42
  public void refreshTicks(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

  this.ticks.clear();

  CategoryPlot categoryPlot = (CategoryPlot)plot;

    Dataset data = categoryPlot.getDataset();

    if (data!=null) {

      Font font = this.getTickLabelFont();

    g2.setFont(font);

    FontRenderContext frc = g2.getFontRenderContext();

    int categoryIndex = 0;

    Iterator iterator = categoryPlot.getDataset().getCategories().iterator();

      while (iterator.hasNext()) {

      Object category = iterator.next();

      String label = category.toString();

      Rectangle2D labelBounds = font.getStringBounds(label, frc);

      LineMetrics metrics = font.getLineMetrics(label, frc);

      float xx = (float)(plotArea.getX()-tickLabelInsets.right-labelBounds.getWidth());

      float yy = (float)(categoryPlot.getCategoryCoordinate(categoryIndex, plotArea)

                  -metrics.getStrikethroughOffset()+0.5f);

      Tick tick = new Tick(category, label, xx, yy);

      ticks.add(tick);

      categoryIndex = categoryIndex+1;

###
3648, VerticalCategoryAxis, VerticalCategoryAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalCategoryAxis.java, 96, 108
27
/**

   * Full constructor: returns a new VerticalCategoryAxis with attributes as specified by the

   * caller.

   * @param label The axis label.

   * @param labelFont The font for displaying the axis label.

   * @param labelPaint The paint used to draw the axis label.

   * @param labelInsets Determines the amount of blank space around the label.

   * @param verticalLabel Flag indicating whether or not the axis label is drawn vertically.

   * @param categoryLabelsVisible Flag indicating whether or not category labels are visible.

   * @param categoryLabelFont The font used to display category labels.

   * @param categoryLabelPaint The paint used to draw category labels.

   * @param tickMarksVisible Flag indicating whether or not tick marks are visible.

   * @param tickMarkStroke The stroke used to draw tick marks (if visible).

   */
22
  public VerticalCategoryAxis(String label,

                Font labelFont, Paint labelPaint, Insets labelInsets,

        boolean verticalLabel,

        boolean categoryLabelsVisible,

                Font categoryLabelFont, Paint categoryLabelPaint,

                Insets categoryLabelInsets,

        boolean tickMarksVisible, Stroke tickMarkStroke) {

  super(label, labelFont, labelPaint, labelInsets,

      categoryLabelsVisible, categoryLabelFont, categoryLabelPaint, categoryLabelInsets,

      tickMarksVisible, tickMarkStroke);

  this.verticalLabel = verticalLabel;

###
3649, VerticalCategoryAxis, VerticalCategoryAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalCategoryAxis.java, 66, 78
7
/**

   * Constructs a VerticalCategoryAxis, using default attributes where necessary.

   * @param label The axis label.

   */
24
  public VerticalCategoryAxis(String label) {

    this(label,

       Axis.DEFAULT_AXIS_LABEL_FONT,

       Axis.DEFAULT_AXIS_LABEL_PAINT,

       Axis.DEFAULT_TICK_LABEL_INSETS,

       true, // vertical label

       true, // category labels visible

       Axis.DEFAULT_TICK_LABEL_FONT,

       Axis.DEFAULT_TICK_LABEL_PAINT,

       Axis.DEFAULT_TICK_LABEL_INSETS,

       false, // tick marks visible

       Axis.DEFAULT_TICK_STROKE);

###
3650, reserveWidth, VerticalCategoryAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalCategoryAxis.java, 199, 221
17
/**

   * Estimates the height required for the axis, given a specific drawing area, without any

   * information about the width of the vertical axis.

   * <P>

   * Supports the HorizontalAxisLead interface.

   * @param g2 The graphics device (used to obtain font information).

   * @param drawArea The area within which the axis should be drawn.

   * @param plot The plot that the axis belongs to.

   */
42
  public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

  // calculate the width of the axis label...

    double labelWidth = 0.0;

    if (label!=null) {

    Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());

    labelWidth = this.labelInsets.left+labelInsets.right;

    if (this.verticalLabel) {

      // assume width == height before rotation

        labelWidth = labelWidth + labelBounds.getHeight();

    }

    else {

      labelWidth = labelWidth + labelBounds.getWidth();

    }

    }

  // calculate the width required for the tick labels (if visible);

  double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;

  if (tickLabelsVisible) {

    this.refreshTicks(g2, drawArea, drawArea);

    tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);

  }

  return labelWidth+tickLabelWidth;

###
3651, reserveAxisArea, VerticalCategoryAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalCategoryAxis.java, 231, 256
11
/**

   * Returns the area required to draw the axis in the specified draw area.

   * @param g2 The graphics device;

   * @param drawArea The area within which the plot should be drawn;

   * @param reservedHeight The height reserved by the horizontal axis.

   */
46
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,

             double reservedHeight) {

    // calculate the width of the axis label...

    double labelWidth = 0.0;

    if (label!=null) {

    Rectangle2D labelBounds = labelFont.getStringBounds(label, g2.getFontRenderContext());

    labelWidth = this.labelInsets.left+labelInsets.right;

    if (this.verticalLabel) {

        // assume width == height before rotation

      labelWidth = labelWidth + labelBounds.getHeight();

    }

    else {

      labelWidth = labelWidth + labelBounds.getWidth();

    }

    }

  // calculate the width required for the tick labels (if visible);

  double tickLabelWidth = tickLabelInsets.left+tickLabelInsets.right;

  if (tickLabelsVisible) {

    this.refreshTicks(g2, drawArea, drawArea);

    tickLabelWidth = tickLabelWidth+getMaxTickLabelWidth(g2, drawArea);

  }

  return new Rectangle2D.Double(drawArea.getX(), drawArea.getY(), labelWidth+tickLabelWidth,

            drawArea.getHeight()-reservedHeight);

###
3652, isCompatibleVerticalAxis, VerticalBarPlot3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot3D.java, 102, 106
9
/**

   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with

   * the plot, and false otherwise.

   * @param axis The vertical axis;

   */
10
  public boolean isCompatibleVerticalAxis(Axis axis) {

  if (axis instanceof VerticalNumberAxis3D) {

    return true;

  }

  else return false;

###
3653, VerticalBarPlot3D, VerticalBarPlot3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot3D.java, 65, 70
9
/**

   * Constructs a vertical bar plot with 3D effect.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   */
10
  public VerticalBarPlot3D(CategoryAxis horizontalAxis, ValueAxis verticalAxis) {

  this(horizontalAxis, verticalAxis,

       Plot.DEFAULT_INSETS,

       0.1, 0.1, 0.2, 0.0,

       null);

###
3654, calculateBackgroundPlotArea, VerticalBarPlot3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot3D.java, 112, 132
5
/**

   * Returns the shape of the background for the 3D-effect bar plot.

   */
36
  protected Shape calculateBackgroundPlotArea(Rectangle2D plotArea) {

  VerticalAxis vAxis = getVerticalAxis();

  double effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();

    GeneralPath backgroundPlotArea = new GeneralPath();

    backgroundPlotArea.moveTo((float) plotArea.getX(), (float)plotArea.getY());

    backgroundPlotArea.lineTo((float)(plotArea.getX()+effect3d),

                  (float)(plotArea.getY()-effect3d));

    backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()),

                  (float)(plotArea.getY()-effect3d));

    backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()),

                  (float)(plotArea.getY()+plotArea.getHeight()-effect3d));

    backgroundPlotArea.lineTo((float)(plotArea.getX()+plotArea.getWidth()-effect3d),

                  (float)(plotArea.getY()+plotArea.getHeight()));

    backgroundPlotArea.lineTo((float) plotArea.getX(),

                  (float)(plotArea.getY()+plotArea.getHeight()));

    backgroundPlotArea.lineTo((float) plotArea.getX(),

                  (float) plotArea.getY());

    return backgroundPlotArea;

###
3655, VerticalBarPlot3D, VerticalBarPlot3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot3D.java, 84, 93
19
/**

   * Constructs a vertical bar plot with 3D effect.

   * @param horizontalAxis The horizontal axis.

   * @param verticalAxis The vertical axis.

   * @param introGap The gap before the first bar in the plot.

   * @param trailGap The gap after the last bar in the plot.

   * @param categoryGap The gap between the last bar in one category and the first bar in the next

   *          category.

   * @param seriesGap The gap between bars within the same category.

   */
18
  public VerticalBarPlot3D(CategoryAxis horizontalAxis, ValueAxis verticalAxis,

               Insets insets,

         double introGap, double trailGap,

               double categoryGap, double seriesGap,

               CategoryToolTipGenerator toolTipGenerator) {

  super(horizontalAxis, verticalAxis,

        insets,

      introGap, trailGap, categoryGap, seriesGap,

        toolTipGenerator);

###
3656, drawBars, VerticalBarPlot3D, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/VerticalBarPlot3D.java, 139, 157
5
/**

   * Draws the bars...

   */
36
  protected void drawBars(Graphics2D g2, Shape backgroundPlotArea, Rectangle2D plotArea,

              DrawInfo info) {

    VerticalAxis vAxis = getVerticalAxis();

  double effect3d = ((VerticalNumberAxis3D) vAxis).getEffect3d();

    // draw far 3d axis

  if ((outlineStroke!=null) && (outlinePaint!=null)) {

    g2.setStroke(outlineStroke);

    g2.setPaint(outlinePaint);

    g2.draw(new Line2D.Double(plotArea.getX()+effect3d, plotArea.getY()-effect3d,

              plotArea.getX()+effect3d, plotArea.getY()+plotArea.getHeight()-effect3d));

    g2.draw(new Line2D.Double(plotArea.getX(), plotArea.getY()+plotArea.getHeight(),

              plotArea.getX()+effect3d, plotArea.getY()+plotArea.getHeight()-effect3d));

    g2.draw(new Line2D.Double(plotArea.getX()+effect3d,

                    plotArea.getY()+plotArea.getHeight()-effect3d,

                    plotArea.getX()+plotArea.getWidth(),

                    plotArea.getY()+plotArea.getHeight()-effect3d));

  }

  super.drawBars(g2, backgroundPlotArea, plotArea, info);

###
3657, getTitle, Title, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Title.java, 77, 78
5
/**

   * Returns the title text.

   */
4
  public String getTitle() {

  return this.title;

###
3658, addChangeListener, Title, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Title.java, 95, 96
7
/**

   * Registers an object for notification of changes to the title.

   * @param listener The object that is being registered.

   */
4
  public void addChangeListener(TitleChangeListener listener) {

  listeners.add(listener);

###
3659, Title, Title, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Title.java, 69, 71
5
/**

   * Standard constructor - builds a Title object.

   */
6
  protected Title(String title) {

  this.title = title;

  this.listeners = new java.util.ArrayList();

###
3661, removeChangeListener, Title, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Title.java, 103, 104
7
/**

   * Unregisters an object for notification of changes to the chart title.

   * @param listener The object that is being unregistered.

   */
4
  public void removeChangeListener(TitleChangeListener listener) {

  listeners.remove(listener);

###
3662, setTitle, Title, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Title.java, 86, 87
9
/**

   * Sets the title to the specified text and notifies registered listeners that the title has

   * been modified.

   * @param text The new chart title;

   */
4
  public void setTitle(String text) {

  this.title = text;

###
3663, createInstance, Title, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/Title.java, 62, 63
9
/**

   * Static factory method that returns a concrete subclass of Title.

   * @param title The chart title;

   * @param font The font for displaying the chart title;

   */
4
  public static Title createInstance(String title, Font font) {

  return new StandardTitle(title, font);

###
3664, setChart, ChartChangeEvent, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/event/ChartChangeEvent.java, 111, 112
7
/**

   * Sets the chart that generated the change event.

   * @param chart The chart that generated the event.

   */
4
  public void setChart(JFreeChart chart) {

    this.chart = chart;

###
3665, ChartChangeEvent, ChartChangeEvent, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/event/ChartChangeEvent.java, 87, 88
9
/**

   * Standard constructor: returns a new ChartChangeEvent object, type GENERAL.

   * @param source The source of the event (could be the chart, a title, an axis etc.);

   * @param chart The chart that generated the event;

   */
4
  public ChartChangeEvent(Object source, JFreeChart chart) {

    this(source, chart, GENERAL);

###
3666, ChartChangeEvent, ChartChangeEvent, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/event/ChartChangeEvent.java, 94, 97
5
/**

   * Full constructor: returns a new ChartChangeEvent object with the specified type.

   */
8
  public ChartChangeEvent(Object source, JFreeChart chart, int type) {

    super(source);

    this.chart = chart;

    this.type = type;

###
3667, ChartChangeEvent, ChartChangeEvent, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/event/ChartChangeEvent.java, 78, 79
7
/**

   * Standard constructor: returns a new ChartChangeEvent object, type GENERAL.

   * @param source The source of the event (could be the chart, a title, an axis etc.)

   */
4
  public ChartChangeEvent(Object source) {

    this(source, null, GENERAL);

###
3668, getType, ChartChangeEvent, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/event/ChartChangeEvent.java, 118, 119
5
/**

   * Returns the event type.

   */
4
  public int getType() {

    return this.type;

###
3669, getChart, ChartChangeEvent, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/event/ChartChangeEvent.java, 103, 104
5
/**

   * Returns a reference to the chart that generated the change event.

   */
4
  public JFreeChart getChart() {

    return chart;

###
3670, AxisChangeEvent, AxisChangeEvent, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/event/AxisChangeEvent.java, 55, 57
7
/**

   * Default constructor: returns a new AxisChangeEvent.

   * @param axis The axis that generated the event.

   */
6
  public AxisChangeEvent(Axis axis) {

    super(axis);

    this.axis = axis;

###
3671, setRange, CombinedHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalDateAxis.java, 214, 223
12
/**

   * Sets our AxisRange (min/max). This is done after a CombinedPlot has

   * has calculated the overall range of all CombinedAxis that share the same

   * Axis for all Plots. This makes all plots display the complete range of

   * their Datasets.

   */

18
  public void setRange(AxisRange range) {

    setAutoRange(false);

    setMinimumDate((Date)range.getMin());

    setMaximumDate((Date)range.getMax());

    if (visible) {

      HorizontalDateAxis axis = (HorizontalDateAxis)getParentAxis();

      axis.setAutoRange(false);

      axis.setMinimumDate((Date)range.getMin());

      axis.setMaximumDate((Date)range.getMax());

###
3672, setVisible, CombinedHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalDateAxis.java, 233, 234
18
/**

   * Sets the visible flag on or off for this combined axis. A visible axis will

   * display the axis title, ticks and legend depending on the parent's

   * attributes. An invisible axis will not display anything. If the invisible

   * axis isContainer(), then it occupies space on the graphic device.

   */

 --------------

//////////////////////////////////////////////////////////////////////////////

 --------------

4
  public void setVisible(boolean flag) {

    visible = flag;

###
3673, draw, CombinedHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalDateAxis.java, 118, 133
15
/**

   * If axis is not visible, just draws grid lines if needed, but no horizonatal

   * date axis labels.

   * @param g2 The graphics device;

   * @param drawArea The area within which the chart should be drawn;

   * @param plotArea The area within which the plot should be drawn (a subset of the drawArea).

   */


30
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

    if (visible) {

      axis.draw(g2, drawArea, plotArea);

    }

    else if (gridLinesVisible) {

      refreshTicks(g2, drawArea, plotArea);

      g2.setStroke(gridStroke);

      g2.setPaint(gridPaint);

      Iterator iterator = ticks.iterator();

      while (iterator.hasNext()) {

        Tick tick = (Tick)iterator.next();

        float xx = (float)translateValueToJava2D(tick.getNumericalValue(), plotArea);

        Line2D gridline = new Line2D.Float(xx, (float)plotArea.getMaxY(),

                           xx, (float)plotArea.getMinY());

        g2.draw(gridline);

###
3674, isVisible, CombinedHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalDateAxis.java, 240, 241
5
/**

   * Is this axis visible? Is is drawn?

   */
4
  public boolean isVisible() {

    return visible;

###
3675, CombinedHorizontalDateAxis, CombinedHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalDateAxis.java, 77, 103
9
/**

   * Constructs a combined horizontal date axis.

   * @param axis Parent HorizontalDateAxis to take as reference.

   * @param visible Indicates if the axis is visible.

   */
52
  public CombinedHorizontalDateAxis(HorizontalDateAxis axis, boolean visible) {

    super(axis.getLabel(),

        axis.getLabelFont(),

        axis.getLabelPaint(),

        axis.getLabelInsets(),

        axis.isTickLabelsVisible(),

        axis.getTickLabelFont(),

        axis.getTickLabelPaint(),

        axis.getTickLabelInsets(),

        axis.getVerticalTickLabels(),

        axis.isTickMarksVisible(),

        axis.getTickMarkStroke(),

        axis.isAutoRange(),

        axis.getMinimumDate(),

        axis.getMaximumDate(),

        axis.isAutoTickUnitSelection(),

        axis.getTickUnit(),

        axis.getTickLabelFormatter(),

        axis.isGridLinesVisible(),

        axis.getGridStroke(),

        axis.getGridPaint(),

        axis.getCrosshairDate(),

        axis.getCrosshairStroke(),

        axis.getCrosshairPaint());

    this.axis = axis;

    this.visible = visible;

###
3676, reserveHeight, CombinedHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalDateAxis.java, 149, 158
13
/**

   * Returns the height required to draw the axis in the specified draw area. If

   * the axis is not visible, returns zero.

   * @param g2 The graphics device;

   * @param plot The plot that the axis belongs to;

   * @param drawArea The area within which the plot should be drawn;

   */
18
  public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

    if (!visible) {

      return 0;

    }

    else if (reserveHeight > 0) {

      return reserveHeight;

    }

    else {

      return axis.reserveHeight(g2, plot, drawArea);

###
3677, getParentAxis, CombinedHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalDateAxis.java, 187, 188
5
/**

   * Returns our parent axis.

   */
4
  public Axis getParentAxis() {

    return axis;

###
3678, getRange, CombinedHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalDateAxis.java, 194, 205
5
/**

   * Returns the AxisRange (min/max) of our Axis

   */
22
  public AxisRange getRange() {

    DateAxisRange range;

    if (visible) {

      axis.autoAdjustRange();

      range = new DateAxisRange(axis.getMinimumDate(), axis.getMaximumDate());

    }

    else {

      autoAdjustRange();

      range = new DateAxisRange(getMinimumDate(), getMaximumDate());

    }

    return (range);

###
3679, reserveAxisArea, CombinedHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalDateAxis.java, 170, 176
16
/**

   * Returns area in which the axis will be displayed. If the axis is not visible

   * returns a zero size rectangle.

   * @param g2 The graphics device;

   * @param plot A reference to the plot;

   * @param drawArea The area within which the plot and axes should be drawn;

   * @param reservedWidth The space already reserved for the vertical axis;

   */

14
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,

                     double reservedWidth) {

    if (visible) {

      return axis.reserveAxisArea(g2, plot, drawArea, reservedWidth);

    }

    else {

      return new Rectangle2D.Double();

###
3680, reserveHeight, OverlaidHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidHorizontalNumberAxis.java, 110, 119
14
/**

   * Returns the height required to draw the axis in the specified draw area. The

   * list of our axes is checked and the first non zero height is returned.

   * @param g2 The graphics device;

   * @param plot The plot that the axis belongs to;

   * @param drawArea The area within which the plot should be drawn;

   */

20
  public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      HorizontalAxis axis = (HorizontalAxis)iter.next();

      double height = axis.reserveHeight(g2, plot, drawArea);

      if (height != 0) {

        return height;

      }

    }

    return 0;

###
3681, reserveAxisArea, OverlaidHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidHorizontalNumberAxis.java, 130, 141
15
/**

   * Returns area in which the axis will be displayed. The list is our axes is

   * checked and the first non zero area is returned.

   * @param g2 The graphics device;

   * @param plot A reference to the plot;

   * @param drawArea The area within which the plot and axes should be drawn;

   * @param reservedWidth The space already reserved for the vertical axis;

   */
24
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,

                     double reservedWidth) {

    Rectangle2D empty = new Rectangle2D.Double();

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      HorizontalAxis axis = (HorizontalAxis)iter.next();

      Rectangle2D area = axis.reserveAxisArea(g2, plot, drawArea, reservedWidth);

      if (!area.equals(empty)) {

        return area;

      }

    }

    return empty;

###
3682, OverlaidHorizontalNumberAxis, OverlaidHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidHorizontalNumberAxis.java, 62, 81
9
/**

   * Constructor.

   * @param plot CombinedPlot where this OverlaidHorizontalNumberAxis will be

   *    contained.

   */
38
  public OverlaidHorizontalNumberAxis(CombinedPlot plot) {

    super((HorizontalNumberAxis)plot.getHorizontalAxis(), false);

    this.plot = plot;

    this.axes = plot.getHorizontalAxes();

    // validate type of axes and tell each axis that it is overlaid

    boolean oneVisible = false;

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      Object axis = iter.next();

      if ((axis instanceof CombinedHorizontalNumberAxis)) {

        CombinedHorizontalNumberAxis combAxis = (CombinedHorizontalNumberAxis)axis;

        oneVisible |= combAxis.isVisible();

        if (iter.hasNext() || oneVisible) {

          combAxis.setGridLinesVisible(false);

          //combAxis.setOverlaid(true);

        }

      } else {

        throw new IllegalArgumentException("Can not combine " + axis.getClass()

                     + " into " + this.getClass() );

###
3684, getRange, OverlaidHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidHorizontalNumberAxis.java, 151, 152
5
/**

   * Returns the AxisRange (min/max) of our Axis

   */
4
  public AxisRange getRange() {

    return plot.getRange(axes);

###
3685, setVisible, CombinedVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedVerticalNumberAxis.java, 238, 239
11
/**

   * Sets the visible flag on or off for this combined axis. A visible axis will

   * display the axis title, ticks and legend depending on the parent's

   * attributes. An invisible axis will not display anything. If the invisible

   * axis isContainer(), then it occupies space on the graphic device.

   */
4
  public void setVisible(boolean flag) {

    visible = flag;

###
3686, draw, CombinedVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedVerticalNumberAxis.java, 126, 140
11
/**

   * Draws the plot on a Java 2D graphics device (such as the screen or a printer).

   * @param g2 The graphics device;

   * @param drawArea The area within which the chart should be drawn.

   * @param plotArea The area within which the plot should be drawn (a subset of the drawArea).

   */
28
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

    if (visible) {

      axis.draw(g2, drawArea, plotArea);

    } else if (gridLinesVisible) {

      refreshTicks(g2, drawArea, plotArea);

      g2.setStroke(gridStroke);

      g2.setPaint(gridPaint);

      double xx = plotArea.getX();

      Iterator iterator = ticks.iterator();

      while (iterator.hasNext()) {

        Tick tick = (Tick)iterator.next();

        float yy = (float)this.translateValueToJava2D(tick.getNumericalValue(), plotArea);

        Line2D gridline = new Line2D.Double(xx, yy, plotArea.getMaxX(), yy);

        g2.draw(gridline);

###
3687, getRange, CombinedVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedVerticalNumberAxis.java, 206, 209
5
/**

   * Returns the AxisRange (min/max) of our Axis

   */
8
  public AxisRange getRange() {

    autoAdjustRange();

    return (new NumberAxisRange(new Double(getMinimumAxisValue()),

        new Double(getMaximumAxisValue())));

###
3688, setReserveDimension, CombinedVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedVerticalNumberAxis.java, 152, 153
13
/**

   * The CombinedPlot will calculate the maximim of all reserveWidth or reserveHeight

   * depending on the type of CombinedPlot and inform all CombinedXXXXXAxis to store

   * this value.

   * @param dimension If the axis is vertical, this is width. If axis is

   *  horizontal, then this is height

   */
4
  public void setReserveDimension(double dimension) {

    this.reserveWidth = dimension;

###
3689, CombinedVerticalNumberAxis, CombinedVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedVerticalNumberAxis.java, 83, 112
9
/**

   * Constructs a combined vertical number axis.

   * @param axis Parent VerticalNumberAxis to take as reference.

   * @param visible Is this axis visible?

   */
56
  public CombinedVerticalNumberAxis(VerticalNumberAxis axis, boolean visible) {

    super(axis.getLabel(),

        axis.getLabelFont(),

        axis.getLabelPaint(),

        axis.getLabelInsets(),

        axis.isLabelDrawnVertical(),

        axis.isTickLabelsVisible(),

        axis.getTickLabelFont(),

        axis.getTickLabelPaint(),

        axis.getTickLabelInsets(),

        axis.isTickMarksVisible(),

        axis.getTickMarkStroke(),

        axis.isAutoRange(),

        axis.autoRangeIncludesZero(),

        axis.getAutoRangeMinimumSize(),

        axis.getMinimumAxisValue(),

        axis.getMaximumAxisValue(),

        axis.isInverted(),

        axis.isAutoTickUnitSelection(),

        axis.getTickUnit(),

        axis.isGridLinesVisible(),

        axis.getGridStroke(),

        axis.getGridPaint(),

        axis.getCrosshairValue(),

        axis.getCrosshairStroke(),

        axis.getCrosshairPaint());

    this.axis = axis;

    this.visible = visible;

###
3690, reserveAxisArea, CombinedVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedVerticalNumberAxis.java, 183, 189
13
/**

   * Returns area in which the axis will be displayed.

   * @param g2 The graphics device;

   * @param plot A reference to the plot;

   * @param drawArea The area in which the plot and axes should be drawn;

   * @param reservedHeight The height reserved for the horizontal axis;

   */
12
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,

                     double reservedHeight) {

    return new Rectangle2D.Double(drawArea.getX(),

                    drawArea.getY(),

                    reserveWidth(g2, plot, drawArea),

                    drawArea.getHeight()-reservedHeight);

###
3691, getParentAxis, CombinedVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedVerticalNumberAxis.java, 199, 200
5
/**

   * Returns our parent axis.

   */
4
  public Axis getParentAxis() {

    return axis;

###
3692, CombinedVerticalNumberAxis, CombinedVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedVerticalNumberAxis.java, 74, 75
7
/**

   * Constructs a visible combined vertical number axis.

   * @param axis Parent VerticalNumberAxis to take as reference.

   */
4
  public CombinedVerticalNumberAxis(VerticalNumberAxis axis) {

    this(axis, true);

###
3693, setRange, CombinedVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedVerticalNumberAxis.java, 218, 228
12
/**

   * Sets our AxisRange (min/max). This is done after a CombinedPlot has

   * has calculated the overall range of all CombinedAxis that share the same

   * Axis for all Plots. This makes all plots display the complete range of

   * their Datasets.

   */

22
  public void setRange(AxisRange range) {

    setAutoRange(false);

    Number min = (Number)range.getMin();

    Number max = (Number)range.getMax();

    setMinimumAxisValue(min.doubleValue());

    setMaximumAxisValue(max.doubleValue());

    if (visible) {

      VerticalNumberAxis axis = (VerticalNumberAxis)getParentAxis();

      axis.setAutoRange(false);

      axis.setMinimumAxisValue(min.doubleValue());

      axis.setMaximumAxisValue(max.doubleValue());

###
3694, reserveWidth, CombinedVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedVerticalNumberAxis.java, 165, 172
17
/**

   * Returns the width required to draw the biggest axis of all the combined

   * vertical axis in the specified draw area. If the width was set via

   * setReserveWidth, then this value is returned instead of a calculation.

   *

   * @param g2 The graphics device;

   * @param plot A reference to the plot;

   * @param drawArea The area within which the plot should be drawn.

   */
14
  public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

    if (!visible) {

      return 0;

    } else if (reserveWidth > 0) {

      return reserveWidth;

    } else {

      return axis.reserveWidth(g2, plot, drawArea);

###
3695, getPrimitive, Performance2, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/Performance2.java, 40, 41
5
/**

   * Just use double value - should be fast.

   */
4
  public double getPrimitive() {

    return primitive;

###
3696, getPrimitiveAsObject, Performance2, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/Performance2.java, 47, 48
5
/**

   * Creates a Number object every time the primitive is accessed - should be really slow.

   */
4
  public Number getPrimitiveAsObject() {

    return new Double(primitive);

###
3697, getObjectAsPrimitive, Performance2, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/Performance2.java, 62, 63
7
/**

   * Returns a double value generated from the Object - should be similar to previous method,

   * but is not!

   */
4
  public double getObjectAsPrimitive() {

    return object.doubleValue();

###
3698, getObject, Performance2, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/Performance2.java, 54, 55
5
/**

   * Returns the object - caller has to use doubleValue() method.

   */
4
  public Number getObject() {

    return object;

###
3699, adjustForInsets, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 370, 378
5
/**

   * Utility method to adjust a Rectangle2D for Insets

   */
16
  protected Rectangle2D adjustForInsets(Rectangle2D drawArea, Insets insets) {

    if (insets != null) {

      return new Rectangle2D.Double(drawArea.getX()+insets.left,

                      drawArea.getY()+insets.top,

                      drawArea.getWidth()-insets.left-insets.right,

                      drawArea.getHeight()-insets.top-insets.bottom);

    } else {

      return drawArea;

###
3700, getXValue, SampleXYDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleXYDataset.java, 79, 80
11
/**

   * Returns the x-value for the specified series and item.  Series are numbered 0, 1, ...

   * @param series The index (zero-based) of the series;

   * @param item The index (zero-based) of the required item;

   * @return The x-value for the specified series and item.

   */
4
  public Number getXValue(int series, int item) {

    return new Double(-10.0+translate+(item*0.2));

###
3701, getPlotArea, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 613, 614
7
/**

   * Returns the last plotArea calculated.

   * // TODO: is this useful?

   */
4
  public Rectangle2D getPlotArea() {

    return plotArea;

###
3702, getSeriesName, SampleXYDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleXYDataset.java, 109, 116
9
/**

   * Returns the name of the series.

   * @param series The index (zero-based) of the series;

   * @return The name of the series.

   */
16
  public String getSeriesName(int series) {

    if (series==0) {

      return "y = cosine(x)";

    }

    else if (series==1) {

      return "y = 2*sine(x)";

    }

    else return "Error";

###
3703, CombinedPlot, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 128, 135
15
/**

   * Creates a HORIZONTAL or VERTICAL CombinedPlot. If type is HORIZONTAL, then

   * axis should contain the shared vertical axis. If type if VERTICAL, then

   * axis should contain the shared horizontal axis.

   *

   * @param axis Shared axis to use for all sub-plots.

   * @param type Type of CombinedPlot (HORIZONTAL or VERTICAL).

   */
14
  public CombinedPlot(Axis axis, int type) {

    super((type == VERTICAL ? axis : null), (type == HORIZONTAL ? axis : null));

    if (type != HORIZONTAL && type != VERTICAL) {

      throw new IllegalArgumentException("Invalid type (" + type + ")");

    }

    this.type = type;

    setInsets(new Insets(0, 0, 0, 0));

###
3704, getYValue, SampleXYDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleXYDataset.java, 89, 93
11
/**

   * Returns the y-value for the specified series and item.  Series are numbered 0, 1, ...

   * @param series The index (zero-based) of the series;

   * @param item The index (zero-based) of the required item;

   * @return The y-value for the specified series and item.

   */
10
  public Number getYValue(int series, int item) {

    if (series==0) {

      return new Double(Math.cos(-10.0+translate+(item/10.0)));

    }

    else return new Double(2*(Math.sin(-10.0+translate+(item/10.0))));

###
3705, adjustPlotsMinMax, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 781, 782
5
/**

   * Adjusts both of our axes ranges.

   */
4
  protected void adjustPlotsMinMax() {

    adjustPlotsMinMax((type != HORIZONTAL), (type != VERTICAL));

###
3706, getSeriesCount, SampleXYDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleXYDataset.java, 100, 101
7
/**

   * Returns the number of series in the data source.

   * @return The number of series in the data source.

   */
4
  public int getSeriesCount() {

    return 2;

###
3707, CombinedPlot, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 145, 149
11
/**

   * Creates an OVERLAID CombinedPlot.

   *

   * @param horizontal Shared horizontal axis to use for all sub-plots.

   * @param vertical Shared vertical axis to use for all sub-plots.

   */
8
  public CombinedPlot(Axis horizontal, Axis vertical) {

    super(horizontal, vertical);

    type = OVERLAID;

    setInsets(new Insets(0, 0, 0, 0));

###
3708, SampleXYDataset, SampleXYDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleXYDataset.java, 60, 61
5
/**

   * Default constructor.

   */
4
  public SampleXYDataset() {

    this.translate = 0.0;

###
3709, add, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 179, 213
23
/**

   * Adds a CombinedChart to the CombinedPlot. Verifies that the shared axes are

   * the same.

   *

   * @param chart The chart to add

   * @param weight Weight of this chart relative to the rest. Must be greater than one.

   *      For an OVERLAID CombinedPlot, weight must be one.

   * @exception AxisNotCompatibleException If common axis is not the same as

   *      previous charts, or if the other axes is not compatible.

   * @exception IllegalArgumentException if weight is <= 0 for HORIZONTAL or

   *      VERTICAL plots, or weight != 0 for OVERLAID plots.

   */
60
  public void add(CombinedChart chart, int weight)

    throws AxisNotCompatibleException, IllegalArgumentException {

    // verify valid horizontal and vertical axis

    Plot p = chart.getPlot();

    if (getHorizontalAxis() != p.getHorizontalAxis() && type != HORIZONTAL) {

      throw new AxisNotCompatibleException("Can't combine with different horizontal axis");

    } else if (getVerticalAxis() != p.getVerticalAxis() && type != VERTICAL) {

      throw new AxisNotCompatibleException("Can't combine with different vertical axis");

    } else if (!isCompatibleHorizontalAxis((Axis)p.getHorizontalAxis())) {

      throw new AxisNotCompatibleException("Incompatible horizontal axis");

    } else if (!isCompatibleVerticalAxis((Axis)p.getVerticalAxis())) {

      throw new AxisNotCompatibleException("Incompatible vertical axis");

    }

    // verify valid weight

    if (weight <= 0 && type != OVERLAID) {

      throw new IllegalArgumentException("weight must be positive");

    } else if (weight != 1 && type == OVERLAID) {

      throw new IllegalArgumentException("weight must 1");

    }

    // only first chart of overlaid chart will draw background and outline

    if (charts.size() > 0 && type == OVERLAID) {

      p.setBackgroundPaint(null);

      p.setOutlineStroke(null);

      p.setOutlinePaint(null);

    }

    // store the chartot and its weight

    ChartInfo chartInfo = new ChartInfo(chart, weight);

    charts.add(chartInfo);

    // keep track of total weights

    weights += weight;

###
3710, adjustPlots, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 513, 521
9
/**

   * Adjusts the charts to combine changing their axis and rescaling them to

   * take into account combined plots. Should be called after adding all

   * sub-charts to the CombinedPlot.

   */
14
  public void adjustPlots() {

    // adjust plot axes: wrap with CombinedXXXXXAxis/OverlaidXXXXAxis objects

    adjustPlotsAxis();

    // adjust plot axis min and max values to display all plots

    adjustPlotsMinMax();

    // adjust all paints and strokes for each plot

    adjustSeriesPaintAndStroke();

###
3711, setRange, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 601, 605
9
/**

   * Sets the AxisRange (min/max) for all the axes in the List.

   * @param range Range to set.

   * @parem axes List of axes to set.

   */
10
  public void setRange(AxisRange range, java.util.List axes) {

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      CombinableAxis axis = (CombinableAxis)iter.next();

      axis.setRange(range);

###
3712, getMaximumHorizontalDataValue, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 447, 461
16
/**

   * Returns the maximum value in the domain of all the charts, since this is plotted

   * against the horizontal axis for a combined plot.

   * @return The maximum value to be plotted against the horizontal axis.

   */

 --------------

// From HorizontalValuePlot and VerticalValuePlot

 --------------

30
  public Number getMaximumHorizontalDataValue() {

    if (charts.size() == 0) {

      return null;

    }

    Number max = new Double(Double.MIN_VALUE);

    Iterator iter = charts.iterator();

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      HorizontalValuePlot plot = (HorizontalValuePlot)chartInfo.plot;

      Number x = plot.getMaximumHorizontalDataValue();

      if (x.doubleValue() > max.doubleValue()) {

        max = x;

      }

    }

    return max;

###
3713, isCompatibleVerticalAxis, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 232, 233
11
/**

   * Checks the compatibility of a vertical axis, returning true if the axis is compatible with

   * the plot, and false otherwise.  The vertical axis for this plot must be an instance of

   * VerticalNumberAxis.

   * @param axis The vertical axis.

   */
4
  public boolean isCompatibleVerticalAxis(Axis axis) {

    return (axis instanceof VerticalNumberAxis);

###
3714, isCompatibleHorizontalAxis, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 221, 223
9
/**

   * Checks the compatibility of a horizontal axis, returning true if the axis is

   * compatible with the plot, and false otherwise.

   * @param axis The horizontal axis.

   */
6
  public boolean isCompatibleHorizontalAxis(Axis axis) {

    return ((axis instanceof HorizontalNumberAxis) ||

        (axis instanceof HorizontalDateAxis));

###
3715, getMinimumHorizontalDataValue, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 425, 439
10
/**

   * Returns the minimum value in the domain of all the charts, since this is plotted

   * against the horizontal axis for a combined plot.

   * @return The minimum value to be plotted against the horizontal axis.

   */

30
  public Number getMinimumHorizontalDataValue() {

    if (charts.size() == 0) {

      return null;

    }

    Number min = new Double(Double.MAX_VALUE);

    Iterator iter = charts.iterator();

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      HorizontalValuePlot plot = (HorizontalValuePlot)chartInfo.plot;

      Number x = plot.getMinimumHorizontalDataValue();

      if (x.doubleValue() < min.doubleValue()) {

        min = x;

      }

    }

    return min;

###
3716, add, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 163, 164
19
/**

   * Adds a CombinedChart to the CombinedPlot. Verifies that the shared axes are

   * the same and assigns a weight of 1 to this chart.

   *

   * @param chart The chart to add

   * @exception AxisNotCompatibleException If horizontal axis is not the same as

   *      previous charts, or if vertical axis is not compatible.

   * @exception IllegalArgumentException if weight is <= 0 for HORIZONTAL or

   *      VERTICAL plots, or weight != 0 for OVERLAID plots.

   */
4
  public void add(CombinedChart chart) throws AxisNotCompatibleException {

    add(chart, 1);

###
3717, adjustPlotsAxis, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 691, 693
11
/**

   * Adjusts the internal charts to allow automatic rendering of their conponents.

   * This includes setting all HorizontalAxis to a CombinedHorizontalXXXXAxis or

   * OverlaidHorizontalXXXXAxis, and setting all VerticalAxis to a CombinedVerticalXXXXAxis or

   * OverlaidVerticalXXXXAxis.

   */
6
  protected void adjustPlotsAxis() {

    if (!isAdjusted) {

      adjustPlotsAxis(true, true);

###
3718, adjustPlotsMinMax, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 791, 807
11
/**

   * Adjusts our axes ranges.

   *

   * @param adjustHorizontal Adjust the range of our horizontal axes?

   * @param adjustVertical Adjust the range of our vertical axes?

   */
28
  protected void adjustPlotsMinMax(boolean adjustHorizontal, boolean adjustVertical) {

    java.util.List axes;

    AxisRange range;

    if (adjustHorizontal && !axisRangeSet[HORIZONTAL]) {

      axes = getHorizontalAxes(true);

      range = getRange(axes);

      setRange(range, axes);

      setAxisRangeSet(HORIZONTAL, true);

    }

    if (adjustVertical && !axisRangeSet[VERTICAL]) {

      axes = getVerticalAxes(true);

      range = getRange(axes);

      setRange(range, axes);

      setAxisRangeSet(VERTICAL, true);

###
3719, getHorizontalAxes, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 536, 548
7
/**

   * Returns a List of all our Horizontal Axes.

   * @param recursive true indicates to traverse all included sub-plots recursivelly.

   */
26
  public java.util.List getHorizontalAxes(boolean recursive) {

    ArrayList axes = new ArrayList();

    Iterator iter = charts.iterator();

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      axes.add(chartInfo.plot.getHorizontalAxis());

      if (recursive && chartInfo.plot instanceof CombinedPlot) {

        CombinedPlot subPlot = (CombinedPlot)chartInfo.plot;

        java.util.List moreAxes = subPlot.getHorizontalAxes(true);

        axes.addAll(moreAxes);

      }

    }

    return axes;

###
3720, readjustPlotsMinMax, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 648, 677
27
/**

   * Readjust the plot axes min and max as needed.  After readjusting the plot axes,

   * it will readjust recursively contained combined plots that were missed.

   *

   * @param doHorizontalAxis Hint that we need to adjust the horizontal axis.

   *  In order to adjust the axis, in addition to the hint being true, the

   *  axisRangeSet[HORIZONTAL] flag for this plot must be true indicating that the

   *  plot does indeed adjust it's horizontal axis.

   * @param doVerticalAxis Hint that we need to adjust the vertical axis.

   *  In order to adjust the axis, in addition to the hint being true, the

   *  axisRangeSet[VERTICAL] flag for this plot must be true indicating that the

   *  plot does indeed adjust it's vertical axis.

   *

   */
50
   private void readjustPlotsMinMax(boolean doHorizontalAxis, boolean doVerticalAxis) {

    if (inReadjustPlotsMinMax) return;

    doHorizontalAxis &= axisRangeSet[HORIZONTAL];

    doVerticalAxis &= axisRangeSet[VERTICAL];

    // adjust plot axis min and max values to display all plots if needed

    if (doHorizontalAxis || doVerticalAxis) {

      if (doHorizontalAxis) {

        setAxisRangeSet(HORIZONTAL, false);

      }

      if (doVerticalAxis) {

        setAxisRangeSet(VERTICAL, false);

      }

      adjustPlotsMinMax(doHorizontalAxis, doVerticalAxis);

    }

    // recursively readjust any internal CombinedPlots we missed.

    inReadjustPlotsMinMax = true;  // prevents StackOverflow

    Iterator iter = charts.iterator();

    while(iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      Plot plot = chartInfo.plot;

      if (plot instanceof CombinedPlot) {

        ((CombinedPlot)plot).readjustPlotsMinMax(!doHorizontalAxis, !doVerticalAxis);

      }

    }

    inReadjustPlotsMinMax = false;

###
3721, draw, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 258, 362
15
/**

   * Draws the CombinedPlot on a Java 2D graphics device (such as the screen or a printer).

   * Will perform all the placement calculations for each sub-plots and then tell these

   * to draw themselves.

   * <P>

   * @param g2 The graphics device;

   * @param drawArea The area within which the plot (including axis labels) should be drawn;

   */
184
  public void draw(Graphics2D g2, Rectangle2D drawArea, DrawInfo info) {

    int n = charts.size();

    int verticalGap = 0;

    int horizontalGap = 0;

    // adjust plot axis if needed

    adjustPlots();

    // adjust the drawing area for plot insets. insets are added as a border

    // and between sub-charts. For in-between space between sub-charts, the

    // max of insets.top and insets.bottom is used for VERTICAL plots and the

    // max of insets.right and insets.left for HORIZONTAL plots.

    drawArea = adjustForInsets(drawArea, insets);

    if (insets != null && type != OVERLAID) {

      verticalGap = Math.max(insets.top, insets.bottom);

      horizontalGap = Math.max(insets.right, insets.left);

    }

    // calculate shared axis height and width

    double hAxisAreaHeight = 0;

    double vAxisAreaWidth = 0;

    if (type != HORIZONTAL) {

      // all plots share the same horizontal axis, reserve the height

      hAxisAreaHeight = getHorizontalAxis().reserveHeight(g2, this, drawArea);

    }

    if (type != VERTICAL) {

      // all plots share the same vertical axis, reserve the width

      vAxisAreaWidth = getVerticalAxis().reserveWidth(g2, this, drawArea);

    }

    // make plotArea without shared axis areas

    Rectangle2D plotArea = new Rectangle2D.Double(drawArea.getX(),

                            drawArea.getY(),

                            drawArea.getWidth()-vAxisAreaWidth,

                            drawArea.getHeight()-hAxisAreaHeight);

    // calculate plotAreas of all sub-plots, maximum vertical/horizontal axis width/height

    Rectangle2D[] subPlotArea = new Rectangle2D[n];

    double x = plotArea.getX();

    double y = plotArea.getY();

    double usableWidth = plotArea.getWidth()-horizontalGap*(charts.size()-1);

    double usableHeight = plotArea.getHeight()-verticalGap*(charts.size()-1);

    double maxAxisWidth = Double.MIN_VALUE;

    double maxAxisHeight = Double.MIN_VALUE;

    for (int i=0; i<n; i++) {

      ChartInfo chartInfo = (ChartInfo)charts.get(i);

      Plot plot = chartInfo.plot;

      // calculate sub-plot height

      double subPlotAreaHeight = usableHeight;

      if (type == VERTICAL) {

        subPlotAreaHeight *= (double)chartInfo.weight/weights;

      }

      if (i == n-1) {

        // last plot has the visible horizontal axis

        subPlotAreaHeight += hAxisAreaHeight;

      }

      // calculate sub-plot width

      double subPlotAreaWidth = usableWidth;

      if (type == HORIZONTAL) {

        subPlotAreaWidth *= (double)chartInfo.weight/weights;

      }

      if (i == 0) {

        // first plot has the visible vertical axis

        subPlotAreaWidth += vAxisAreaWidth;

      }

      // calculate sub-plot area

      subPlotArea[i] = new Rectangle2D.Double(x, y, subPlotAreaWidth, subPlotAreaHeight);

      // calculate sub-plot max axis width and height if needed

      if (type != OVERLAID) {

        Rectangle2D tempArea = adjustForInsets(subPlotArea[i], plot.getInsets());

        if (type == VERTICAL) {

          maxAxisWidth = Math.max(maxAxisWidth,

                       plot.getVerticalAxis().reserveWidth(g2, plot, tempArea));

        } else if (type == HORIZONTAL) {

          maxAxisHeight = Math.max(maxAxisHeight,

                    plot.getHorizontalAxis().reserveHeight(g2, plot, tempArea));

        }

      }

      // calculat next (x, y)

      if (type == VERTICAL) {

        y += subPlotAreaHeight + verticalGap;

      } else if (type == HORIZONTAL) {

        x += subPlotAreaWidth + horizontalGap;

      } if (type == OVERLAID && i == 0) {

        x += vAxisAreaWidth;

      }

    }

    // set the width and height of non-shared axis of all sub-plots

    if (type == VERTICAL) {

      setVerticalAxisWidth(maxAxisWidth);

    } else if (type == HORIZONTAL) {

      setHorizontalAxisHeight(maxAxisHeight);

    }

    // draw all the charts

    for (int i=0; i<n; i++) {

      ChartInfo chartInfo = (ChartInfo)charts.get(i);

      chartInfo.chart.draw(g2, subPlotArea[i], null);

###
3722, getVerticalAxes, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 555, 556
7
/**

   * Returns a List of all our Vertical Axes. Does not traverse recursivelly the

   * sub-chart structure.

   */
4
  public java.util.List getVerticalAxes() {

    return getVerticalAxes(false);

###
3723, getRange, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 582, 593
7
/**

   * Returns the AxisRange (min/max) of the axes list.

   * @param axes List of axes to use in calculation

   */
24
  public AxisRange getRange(java.util.List axes) {

    AxisRange range = null;

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      CombinableAxis axis = (CombinableAxis)iter.next();

      if (range == null) {

        range = axis.getRange();

      } else {

        range.combine(axis.getRange());

      }

    }

    return range;

###
3724, horizontalAxisVisible, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 749, 755
17
/**

   * Returns true if a horizontal axis is visible. Sub-classes can overwrite this

   * method to implement additional logic. This implementation returns true for

   * HORIZONTAL plots or if the plot under analysis is the first of the combination.

   *

   * @param firstPlot Are we the first plot of the CombinedPlot?

   * @param lastPlot Are we the last plot of the CombinedPlot?

   * @param subPlot Plot under analysis.

   */
14
  protected boolean horizontalAxisVisible(boolean firstPlot, boolean lastPlot, Plot subPlot) {

    if (type == HORIZONTAL) {

      return true;

    } else if (lastPlot) {

      return true;

    } else {

      return false;

###
3725, setHorizontalAxisHeight, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 386, 394
7
/**

   * Sets the height of the non-shared horizontal axis of all combined sub-plots

   * @param height Height to

   */
18
  protected void setHorizontalAxisHeight(double height) {

    Iterator iter = charts.iterator();

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      Plot plot = chartInfo.plot;

      CombinableAxis axis = (CombinableAxis)plot.getHorizontalAxis();

      axis.setReserveDimension(height);

      if (plot instanceof CombinedPlot) {

        ((CombinedPlot)plot).setHorizontalAxisHeight(height);

###
3726, getMaximumVerticalDataValue, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 487, 501
5
/**

   * Returns the maximum value displayed against the vertical axis.

   */
30
  public Number getMaximumVerticalDataValue() {

    if (charts.size() == 0) {

      return null;

    }

    Number max = new Double(Double.MIN_VALUE);

    Iterator iter = charts.iterator();

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      VerticalValuePlot plot = (VerticalValuePlot)chartInfo.plot;

      Number x = plot.getMaximumVerticalDataValue();

      if (x.doubleValue() > max.doubleValue()) {

        max = x;

      }

    }

    return max;

###
3727, adjustSeriesPaintAndStroke, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 848, 872
15
/**

   * Adjusts the Stroke and Paint objects associated with each Plot's Series

   * that use the CombinedDataset so that each series is always drawn using the same

   * rendering objects, no matter on what plot it appears.

   * @param masterPlot Outermost plot that defines all the Stroke and Paint object

   *    to use

   * @param masterData Dataset

   */
46
  private void adjustSeriesPaintAndStroke(Plot masterPlot, Dataset masterData) {

    Iterator iter = charts.iterator();

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      Plot plot = chartInfo.plot;

      Dataset data = chartInfo.chart.getDataset();

      if (data instanceof CombinationDataset) {

        CombinationDataset childData = (CombinationDataset)data;

        if (childData.getParent() == masterData) {

          int[] map = childData.getMap();

          Stroke[] childStroke = new Stroke[map.length];

          Paint[] childPaint = new Paint[map.length];

          for (int j=0; j<map.length; j++) {

            childStroke[j] = masterPlot.getSeriesStroke(map[j]);

            childPaint[j] = masterPlot.getSeriesPaint(map[j]);

          }

          plot.setSeriesStroke(childStroke);

          plot.setSeriesPaint(childPaint);

        }

      }

      // adjust recursivelly any internal CombinedPlot

      if (plot instanceof CombinedPlot) {

        ((CombinedPlot)plot).adjustSeriesPaintAndStroke(masterPlot, masterData);

###
3728, getMinimumVerticalDataValue, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 467, 481
5
/**

   * Returns the minimum value displayed against the vertical axis.

   */
30
  public Number getMinimumVerticalDataValue() {

    if (charts.size() == 0) {

      return null;

    }

    Number min = new Double(Double.MAX_VALUE);

    Iterator iter = charts.iterator();

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      VerticalValuePlot plot = (VerticalValuePlot)chartInfo.plot;

      Number x = plot.getMinimumVerticalDataValue();

      if (x.doubleValue() < min.doubleValue()) {

        min = x;

      }

    }

    return min;

###
3729, getVerticalAxes, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 563, 575
7
/**

   * Returns a List of all our Vertical Axes.

   * @param recursive true indicates to traverse all included sub-plots recursivelly.

   */
26
  public java.util.List getVerticalAxes(boolean recursive) {

    ArrayList axes = new ArrayList();

    Iterator iter = charts.iterator();

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      axes.add(chartInfo.plot.getVerticalAxis());

      if (recursive && chartInfo.plot instanceof CombinedPlot) {

        CombinedPlot subPlot = (CombinedPlot)chartInfo.plot;

        java.util.List moreAxes = subPlot.getVerticalAxes(true);

        axes.addAll(moreAxes);

      }

    }

    return axes;

###
3730, getHorizontalAxes, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 528, 529
7
/**

   * Returns a List of all our Horizontal Axes. Does not traverse recursivelly the

   * sub-chart structure.

   */
4
  public java.util.List getHorizontalAxes() {

    return getHorizontalAxes(false);

###
3731, getSeriesName, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 165, 169
9
/**

   * Returns the name of the series.

   * @param series The index (zero-based) of the series;

   * @return The name of the series.

   */
10
  public String getSeriesName(int series) {

    if (series==0) {

      return "IBM";

    }

    else return "Error";

###
3732, adjustPlotsAxis, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 706, 737
17
/**

   * Adjusts the internal charts to allow automatic rendering of their conponents.

   * This includes setting all HorizontalAxis to a CombinedHorizontalXXXXAxis or

   * OverlaidHorizontalXXXXAxis, and setting all VerticalAxis to a CombinedVerticalXXXXAxis or

   * OverlaidVerticalXXXXAxis.

   *

   * @param hVisible Indicates if the horizontal axis is visible for this plot

   * @parem vVisible Indicates if the vertical axis is visible for this plot

   */
50
  protected void adjustPlotsAxis(boolean hVisible, boolean vVisible) {

    Iterator iter = charts.iterator();

    boolean hAxisVisible, vAxisVisible;

    boolean first = true;

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      Plot plot = chartInfo.plot;

      if (plot instanceof CombinedPlot) {

        // adjust recursivelly any combined plots first

        hAxisVisible = (hVisible && horizontalAxisVisible(first, !iter.hasNext(), plot));

        vAxisVisible = (vVisible && verticalAxisVisible(first, !iter.hasNext(), plot));

        ((CombinedPlot)plot).adjustPlotsAxis(hAxisVisible, vAxisVisible);

      }

      // create combined horizontal axis

      hAxisVisible = (hVisible && horizontalAxisVisible(first, !iter.hasNext(), plot));

      Axis h = createCombinedAxis(plot, (Axis)plot.getHorizontalAxis(), hAxisVisible);

      // create combined vertical axis

      vAxisVisible = (vVisible && verticalAxisVisible(first, !iter.hasNext(), plot));

      Axis v = createCombinedAxis(plot, (Axis)plot.getVerticalAxis(), vAxisVisible);

      // adjust plot with new axes

      plot.setHorizontalAxis(h);

      plot.setVerticalAxis(v);

      first = false;

    }

    isAdjusted = true;

###
3733, getPlotType, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 241, 246
9
/**

   * Returns the plot type as a string. This implementation returns "Overlaid Plot",

   * "Horizontal Combined Plot", "Vertical Combined Plot" or "Unknown Combined Plot"

   * depending of the type of CombinedPlot.

   */
12
  public String getPlotType() {

    switch (type) {

      case OVERLAID:   return "Overlaid Plot";

      case HORIZONTAL: return "Horizontal Combined Plot";

      case VERTICAL:   return "Vertical Combined Plot";

      default:     return "Unknown Combined Plot";

###
3734, adjustSeriesPaintAndStroke, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 833, 836
9
/**

   * Adjusts the Stroke and Paint objects associated with each Plot's Series

   * that use the CombinedDataset so that each series is always drawn using the same

   * rendering objects, no matter on what plot it appears.

   */
8
  private void adjustSeriesPaintAndStroke() {

    if (chart != null) {

      SeriesDataset masterData = (SeriesDataset)chart.getDataset();

      adjustSeriesPaintAndStroke(this, masterData);

###
3735, verticalAxisVisible, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 768, 774
17
/**

   * Returns true is a vertical axis is visible. Sub-classes can overwrite this

   * method to implement additional logic. This implementation returns true for

   * VERTICAL plots or if the plot under analysis is the first of the combination.

   *

   * @param firstPlot Are we the first plot of the CombinedPlot?

   * @param lastPlot Are we the last plot of the CombinedPlot?

   * @param subPlot Plot under analysis.

   */
14
  protected boolean verticalAxisVisible(boolean firstPlot, boolean lastPlot, Plot subPlot) {

    if (type == VERTICAL) {

      return true;

    } else if (firstPlot) {

      return true;

    } else {

      return false;

###
3736, setAxisRangeSet, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 816, 823
9
/**

   * Recursively sets the axisRangeSet[type] flag to true for this and all its

   * CombinedPlot sub-plots.

   * @param type Indicates the flag to set (HORIZONTAL or VERTICAL).

   */
16
  private void setAxisRangeSet(int type, boolean flag) {

    axisRangeSet[type] = flag;

    Iterator iter = charts.iterator();

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      Plot plot = chartInfo.plot;

      if (plot instanceof CombinedPlot) {

        ((CombinedPlot)plot).setAxisRangeSet(type, flag);

###
3737, setVerticalAxisWidth, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 403, 411
7
/**

   * Sets the width of the vertical axis of all combined sub-charts.

   * @param width Width to set

   */
18
  protected void setVerticalAxisWidth(double width) {

    Iterator iter = charts.iterator();

    while (iter.hasNext()) {

      ChartInfo chartInfo = (ChartInfo)iter.next();

      Plot plot = chartInfo.plot;

      CombinableAxis axis = (CombinableAxis)plot.getVerticalAxis();

      axis.setReserveDimension(width);

      if (plot instanceof CombinedPlot) {

        ((CombinedPlot)plot).setVerticalAxisWidth(width);

###
3738, chartChanged, CombinedPlot, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedPlot.java, 627, 628
11
/**

   * Receives notification of a change to a (the) chart.

   * <P>

   * Reacts to dataset changes by reconfiguring the axes.

   * @param event Information about the chart change event.

   */
4
  public void chartChanged(ChartChangeEvent event) {

    readjustPlotsMinMax(axisRangeSet[HORIZONTAL], axisRangeSet[VERTICAL]);

###
3739, NumberAxisRange, NumberAxisRange, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/NumberAxisRange.java, 56, 57
11
/**

   * Creates an NumberAxisRange object.

   *

   * @param min Minimum Number value

   * @param max Maximum Number value

   */
4
  public NumberAxisRange(Number min, Number max) {

    super(min, max);

###
3740, DateAxisRange, DateAxisRange, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/DateAxisRange.java, 58, 59
11
/**

   * Creates an DateAxisRange object.

   *

   * @param min Minimum date value

   * @param max Maximum date value

   */
4
  public DateAxisRange(Date min, Date max) {

    super(min, max);

###
3741, reserveAxisArea, CombinedHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalNumberAxis.java, 172, 179
16
/**

   * Returns area in which the axis will be displayed. If the axis is not visible

   * returns a zero size rectangle.

   * @param g2 The graphics device;

   * @param plot A reference to the plot;

   * @param drawArea The area within which the plot and axes should be drawn;

   * @param reservedWidth The space already reserved for the vertical axis;

   */

14
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,

                     double reservedWidth) {

    if (visible) {

      return axis.reserveAxisArea(g2, plot, drawArea, reservedWidth);

    }

    else {

      return new Rectangle2D.Double();

###
3742, isVisible, CombinedHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalNumberAxis.java, 238, 239
5
/**

   * Is this axis visible? Is is drawn?

   */
4
  public boolean isVisible() {

    return visible;

###
3743, initialiseData, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 184, 472
5
/**

   * Sets up the data for the sample data source.

   */
482
  private void initialiseData() {

    dates = new Date[47];

    highs = new Double[47];

    lows = new Double[47];

    opens = new Double[47];

    closes = new Double[47];

    dates[0]  = createDate(2001, Calendar.JANUARY,4);

    highs[0]  = new Double(47.0);

    lows[0]   = new Double(33.0);

    opens[0]  = new Double(35.0);

    closes[0] = new Double(33.0);

    dates[1]  = createDate(2001, Calendar.JANUARY,5);

    highs[1]  = new Double(47.0);

    lows[1]   = new Double(32.0);

    opens[1]  = new Double(41.0);

    closes[1] = new Double(37.0);

    dates[2]  = createDate(2001, Calendar.JANUARY,6);

    highs[2]  = new Double(49.0);

    lows[2]   = new Double(43.0);

    opens[2]  = new Double(46.0);

    closes[2] = new Double(48.0);

    dates[3]  = createDate(2001, Calendar.JANUARY,7);

    highs[3]  = new Double(51.0);

    lows[3]   = new Double(39.0);

    opens[3]  = new Double(40.0);

    closes[3] = new Double(47.0);

    dates[4]  = createDate(2001, Calendar.JANUARY,8);

    highs[4]  = new Double(60.0);

    lows[4]   = new Double(40.0);

    opens[4]  = new Double(46.0);

    closes[4] = new Double(53.0);

    dates[5]  = createDate(2001, Calendar.JANUARY,9);

    highs[5]  = new Double(62.0);

    lows[5]   = new Double(55.0);

    opens[5]  = new Double(57.0);

    closes[5] = new Double(61.0);

    dates[6]  = createDate(2001, Calendar.JANUARY,10);

    highs[6]  = new Double(65.0);

    lows[6]   = new Double(56.0);

    opens[6]  = new Double(62.0);

    closes[6] = new Double(59.0);

    dates[7]  = createDate(2001, Calendar.JANUARY,11);

    highs[7]  = new Double(55.0);

    lows[7]   = new Double(43.0);

    opens[7]  = new Double(45.0);

    closes[7] = new Double(47.0);

    dates[8]  = createDate(2001, Calendar.JANUARY,12);

    highs[8]  = new Double(54.0);

    lows[8]   = new Double(33.0);

    opens[8]  = new Double(40.0);

    closes[8] = new Double(51.0);

    dates[9]  = createDate(2001, Calendar.JANUARY,13);

    highs[9]  = new Double(47.0);

    lows[9]   = new Double(33.0);

    opens[9]  = new Double(35.0);

    closes[9] = new Double(33.0);

    dates[10]  = createDate(2001, Calendar.JANUARY,14);

    highs[10]  = new Double(54.0);

    lows[10]   = new Double(38.0);

    opens[10]  = new Double(43.0);

    closes[10] = new Double(52.0);

    dates[11]  = createDate(2001, Calendar.JANUARY,15);

    highs[11]  = new Double(48.0);

    lows[11]   = new Double(41.0);

    opens[11]  = new Double(44.0);

    closes[11] = new Double(41.0);

    dates[12]  = createDate(2001, Calendar.JANUARY,17);

    highs[12]  = new Double(60.0);

    lows[12]   = new Double(30.0);

    opens[12]  = new Double(34.0);

    closes[12] = new Double(44.0);

    dates[13]  = createDate(2001, Calendar.JANUARY,18);

    highs[13]  = new Double(58.0);

    lows[13]   = new Double(44.0);

    opens[13]  = new Double(54.0);

    closes[13] = new Double(56.0);

    dates[14]  = createDate(2001, Calendar.JANUARY,19);

    highs[14]  = new Double(54.0);

    lows[14]   = new Double(32.0);

    opens[14]  = new Double(42.0);

    closes[14] = new Double(53.0);

    dates[15]  = createDate(2001, Calendar.JANUARY,20);

    highs[15]  = new Double(53.0);

    lows[15]   = new Double(39.0);

    opens[15]  = new Double(50.0);

    closes[15] = new Double(49.0);

    dates[16]  = createDate(2001, Calendar.JANUARY,21);

    highs[16]  = new Double(47.0);

    lows[16]   = new Double(33.0);

    opens[16]  = new Double(41.0);

    closes[16] = new Double(40.0);

    dates[17]  = createDate(2001, Calendar.JANUARY,22);

    highs[17]  = new Double(55.0);

    lows[17]   = new Double(37.0);

    opens[17]  = new Double(43.0);

    closes[17] = new Double(45.0);

    dates[18]  = createDate(2001, Calendar.JANUARY,23);

    highs[18]  = new Double(54.0);

    lows[18]   = new Double(42.0);

    opens[18]  = new Double(50.0);

    closes[18] = new Double(42.0);

    dates[19]  = createDate(2001, Calendar.JANUARY,24);

    highs[19]  = new Double(48.0);

    lows[19]   = new Double(37.0);

    opens[19]  = new Double(37.0);

    closes[19] = new Double(47.0);

    dates[20]  = createDate(2001, Calendar.JANUARY,25);

    highs[20]  = new Double(58.0);

    lows[20]   = new Double(33.0);

    opens[20]  = new Double(39.0);

    closes[20] = new Double(41.0);

    dates[21]  = createDate(2001, Calendar.JANUARY,26);

    highs[21]  = new Double(47.0);

    lows[21]   = new Double(31.0);

    opens[21]  = new Double(36.0);

    closes[21] = new Double(41.0);

    dates[22]  = createDate(2001, Calendar.JANUARY,27);

    highs[22]  = new Double(58.0);

    lows[22]   = new Double(44.0);

    opens[22]  = new Double(49.0);

    closes[22] = new Double(44.0);

    dates[23]  = createDate(2001, Calendar.JANUARY,28);

    highs[23]  = new Double(46.0);

    lows[23]   = new Double(41.0);

    opens[23]  = new Double(43.0);

    closes[23] = new Double(44.0);

    dates[24]  = createDate(2001, Calendar.JANUARY,29);

    highs[24]  = new Double(56.0);

    lows[24]   = new Double(39.0);

    opens[24]  = new Double(39.0);

    closes[24] = new Double(51.0);

    dates[25]  = createDate(2001, Calendar.JANUARY,30);

    highs[25]  = new Double(56.0);

    lows[25]   = new Double(39.0);

    opens[25]  = new Double(47.0);

    closes[25] = new Double(49.0);

    dates[26]  = createDate(2001, Calendar.JANUARY,31);

    highs[26]  = new Double(53.0);

    lows[26]   = new Double(39.0);

    opens[26]  = new Double(52.0);

    closes[26] = new Double(47.0);

    dates[27]  = createDate(2001, Calendar.FEBRUARY,1);

    highs[27]  = new Double(51.0);

    lows[27]   = new Double(30.0);

    opens[27]  = new Double(45.0);

    closes[27] = new Double(47.0);

    dates[28]  = createDate(2001, Calendar.FEBRUARY,2);

    highs[28]  = new Double(47.0);

    lows[28]   = new Double(30.0);

    opens[28]  = new Double(34.0);

    closes[28] = new Double(46.0);

    dates[29]  = createDate(2001, Calendar.FEBRUARY,3);

    highs[29]  = new Double(57.0);

    lows[29]   = new Double(37.0);

    opens[29]  = new Double(44.0);

    closes[29] = new Double(56.0);

    dates[30]  = createDate(2001, Calendar.FEBRUARY,4);

    highs[30]  = new Double(49.0);

    lows[30]   = new Double(40.0);

    opens[30]  = new Double(47.0);

    closes[30] = new Double(44.0);

    dates[31]  = createDate(2001, Calendar.FEBRUARY,5);

    highs[31]  = new Double(46.0);

    lows[31]   = new Double(38.0);

    opens[31]  = new Double(43.0);

    closes[31] = new Double(40.0);

    dates[32]  = createDate(2001, Calendar.FEBRUARY,6);

    highs[32]  = new Double(55.0);

    lows[32]   = new Double(38.0);

    opens[32]  = new Double(39.0);

    closes[32] = new Double(53.0);

    dates[33]  = createDate(2001, Calendar.FEBRUARY,7);

    highs[33]  = new Double(50.0);

    lows[33]   = new Double(33.0);

    opens[33]  = new Double(37.0);

    closes[33] = new Double(37.0);

    dates[34]  = createDate(2001, Calendar.FEBRUARY,8);

    highs[34]  = new Double(59.0);

    lows[34]   = new Double(34.0);

    opens[34]  = new Double(57.0);

    closes[34] = new Double(43.0);

    dates[35]  = createDate(2001, Calendar.FEBRUARY,9);

    highs[35]  = new Double(48.0);

    lows[35]   = new Double(39.0);

    opens[35]  = new Double(46.0);

    closes[35] = new Double(47.0);

    dates[36]  = createDate(2001, Calendar.FEBRUARY,10);

    highs[36]  = new Double(55.0);

    lows[36]   = new Double(30.0);

    opens[36]  = new Double(37.0);

    closes[36] = new Double(30.0);

    dates[37]  = createDate(2001, Calendar.FEBRUARY,11);

    highs[37]  = new Double(60.0);

    lows[37]   = new Double(32.0);

    opens[37]  = new Double(56.0);

    closes[37] = new Double(36.0);

    dates[38]  = createDate(2001, Calendar.FEBRUARY,12);

    highs[38]  = new Double(56.0);

    lows[38]   = new Double(42.0);

    opens[38]  = new Double(53.0);

    closes[38] = new Double(54.0);

    dates[39]  = createDate(2001, Calendar.FEBRUARY,13);

    highs[39]  = new Double(49.0);

    lows[39]   = new Double(42.0);

    opens[39]  = new Double(45.0);

    closes[39] = new Double(42.0);

    dates[40]  = createDate(2001, Calendar.FEBRUARY,14);

    highs[40]  = new Double(55.0);

    lows[40]   = new Double(42.0);

    opens[40]  = new Double(47.0);

    closes[40] = new Double(54.0);

     dates[41]  = createDate(2001, Calendar.FEBRUARY,15);

    highs[41]  = new Double(49.0);

    lows[41]   = new Double(35.0);

    opens[41]  = new Double(38.0);

    closes[41] = new Double(35.0);

    dates[42]  = createDate(2001, Calendar.FEBRUARY,16);

    highs[42]  = new Double(47.0);

    lows[42]   = new Double(38.0);

    opens[42]  = new Double(43.0);

    closes[42] = new Double(42.0);

    dates[43]  = createDate(2001, Calendar.FEBRUARY,17);

    highs[43]  = new Double(53.0);

    lows[43]   = new Double(42.0);

    opens[43]  = new Double(47.0);

    closes[43] = new Double(48.0);

    dates[44]  = createDate(2001, Calendar.FEBRUARY,18);

    highs[44]  = new Double(47.0);

    lows[44]   = new Double(44.0);

    opens[44]  = new Double(46.0);

    closes[44] = new Double(44.0);

    dates[45]  = createDate(2001, Calendar.FEBRUARY,19);

    highs[45]  = new Double(46.0);

    lows[45]   = new Double(40.0);

    opens[45]  = new Double(43.0);

    closes[45] = new Double(44.0);

    dates[46]  = createDate(2001, Calendar.FEBRUARY,20);

    highs[46]  = new Double(48.0);

    lows[46]   = new Double(41.0);

    opens[46]  = new Double(46.0);

    closes[46] = new Double(41.0);

###
3744, setRange, CombinedHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalNumberAxis.java, 210, 221
12
/**

   * Sets our AxisRange (min/max). This is done after a CombinedPlot has

   * has calculated the overall range of all CombinedAxis that share the same

   * Axis for all Plots. This makes all plots display the complete range of

   * their Datasets.

   */

22
  public void setRange(AxisRange range) {

    setAutoRange(false);

    Number min = (Number)range.getMin();

    Number max = (Number)range.getMax();

    setMinimumAxisValue(min.doubleValue());

    setMaximumAxisValue(max.doubleValue());

    if (visible) {

      HorizontalNumberAxis axis = (HorizontalNumberAxis)getParentAxis();

      axis.setAutoRange(false);

      axis.setMinimumAxisValue(min.doubleValue());

      axis.setMaximumAxisValue(max.doubleValue());

###
3745, reserveHeight, CombinedHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalNumberAxis.java, 152, 160
14
/**

   * Returns the height required to draw the axis in the specified draw area. If

   * the axis is not visible, returns zero.

   * @param g2 The graphics device;

   * @param plot The plot that the axis belongs to;

   * @param drawArea The area within which the plot should be drawn;

   */

18
  public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

    if (!visible) {

      return 0;

    }

    else if (reserveHeight > 0) {

      return reserveHeight;

    }

    else {

      return axis.reserveHeight(g2, plot, drawArea);

###
3746, setVisible, CombinedHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalNumberAxis.java, 231, 232
18
/**

   * Sets the visible flag on or off for this combined axis. A visible axis will

   * display the axis title, ticks and legend depending on the parent's

   * attributes. An invisible axis will not display anything. If the invisible

   * axis isContainer(), then it occupies space on the graphic device.

   */

 --------------

//////////////////////////////////////////////////////////////////////////////

 --------------

4
  public void setVisible(boolean flag) {

    visible = flag;

###
3747, getRange, CombinedHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalNumberAxis.java, 198, 201
5
/**

   * Returns the AxisRange (min/max) of our Axis

   */
8
  public AxisRange getRange() {

    autoAdjustRange();

    return (new NumberAxisRange(new Double(getMinimumAxisValue()),

                  new Double(getMaximumAxisValue())));

###
3748, getLowValue, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 119, 123
11
/**

   * Returns the low-value for the specified series and item.  Series are numbered 0, 1, ...

   * @param series The index (zero-based) of the series;

   * @param item The index (zero-based) of the required item;

   * @return The low-value for the specified series and item.

   */
10
  public Number getLowValue(int series, int item) {

    if (series==0) {

      return lows[item];

    }

    else return null;

###
3749, getOpenValue, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 132, 136
11
/**

   * Returns the open-value for the specified series and item.  Series are numbered 0, 1, ...

   * @param series The index (zero-based) of the series;

   * @param item The index (zero-based) of the required item;

   * @return The open-value for the specified series and item.

   */
10
  public Number getOpenValue(int series, int item) {

    if (series==0) {

      return opens[item];

    }

    else return null;

###
3750, getHighValue, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 106, 110
11
/**

   * Returns the high-value for the specified series and item.  Series are numbered 0, 1, ...

   * @param series The index (zero-based) of the series;

   * @param item The index (zero-based) of the required item;

   * @return The high-value for the specified series and item.

   */
10
  public Number getHighValue(int series, int item) {

    if (series==0) {

      return highs[item];

    }

    else return null;

###
3751, CombinedHorizontalNumberAxis, CombinedHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalNumberAxis.java, 75, 104
9
/**

   * Constructs a blank horizontal number axis.

   * @param axis Parent HorizontalNumberAxis to take as reference.

   * @param display Indicates if the axis is visible

   */
56
  public CombinedHorizontalNumberAxis(HorizontalNumberAxis axis, boolean visible) {

    super(axis.getLabel(),

        axis.getLabelFont(),

        axis.getLabelPaint(),

        axis.getLabelInsets(),

        axis.isTickLabelsVisible(),

        axis.getTickLabelFont(),

        axis.getTickLabelPaint(),

        axis.getTickLabelInsets(),

        axis.getVerticalTickLabels(),

        axis.isTickMarksVisible(),

        axis.getTickMarkStroke(),

        axis.isAutoRange(),

        axis.autoRangeIncludesZero(),

        axis.getAutoRangeMinimumSize(),

        axis.getMinimumAxisValue(),

        axis.getMaximumAxisValue(),

        axis.isInverted(),

        axis.isAutoTickUnitSelection(),

        axis.getTickUnit(),

        axis.isGridLinesVisible(),

        axis.getGridStroke(),

        axis.getGridPaint(),

        axis.getCrosshairValue(),

        axis.getCrosshairStroke(),

        axis.getCrosshairPaint());

    this.axis = axis;

    this.visible = visible;

###
3752, getYValue, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 93, 97
11
/**

   * Returns the y-value for the specified series and item.  Series are numbered 0, 1, ...

   * @param series The index (zero-based) of the series;

   * @param item The index (zero-based) of the required item;

   * @return The y-value for the specified series and item.

   */
10
  public Number getYValue(int series, int item) {

    if (series==0) {

      return closes[item];

    }

    else return null;

###
3753, getParentAxis, CombinedHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalNumberAxis.java, 191, 192
5
/**

   * Returns our parent axis.

   */
4
  public Axis getParentAxis() {

    return axis;

###
3754, getItemCount, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 177, 178
9
/**

   * Returns the number of items in the specified series.

   * @param series The index (zero-based) of the series;

   * @return The number of items in the specified series.

   */
4
  public int getItemCount(int series) {

    return 47;  // one series with 47 items in this sample

###
3755, SampleHighLowDataset, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 65, 66
5
/**

   * Default constructor.

   */
4
  public SampleHighLowDataset() {

    this.initialiseData();

###
3756, getSeriesCount, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 156, 157
7
/**

   * Returns the number of series in the data source, ONE in this sample.

   * @return The number of series in the data source.

   */
4
  public int getSeriesCount() {

    return 1;

###
3757, draw, CombinedHorizontalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/CombinedHorizontalNumberAxis.java, 119, 135
15
/**

   * If the axis is not visible, just draws grid lines if needed, but no

   * horizontal axis labels.

   * @param g2 The graphics device;

   * @param drawArea The area within which the chart should be drawn;

   * @param plotArea The area within which the plot should be drawn (a subset of the drawArea);

   */


32
  public void draw(Graphics2D g2, Rectangle2D drawArea, Rectangle2D plotArea) {

    if (visible) {

      axis.draw(g2, drawArea, plotArea);

    }

    else {

      if (gridLinesVisible) {

        refreshTicks(g2, drawArea, plotArea);

        Iterator iterator = ticks.iterator();

        while (iterator.hasNext()) {

          Tick tick = (Tick)iterator.next();

          float xx = (float)translateValueToJava2D(tick.getNumericalValue(), plotArea);

          g2.setStroke(gridStroke);

          g2.setPaint(gridPaint);

          Line2D gridline = new Line2D.Float(xx, (float)plotArea.getMaxY(), xx,

                               (float)plotArea.getMinY());

          g2.draw(gridline);

###
3758, getCloseValue, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 145, 149
11
/**

   * Returns the close-value for the specified series and item.  Series are numbered 0, 1, ...

   * @param series The index (zero-based) of the series;

   * @param item The index (zero-based) of the required item;

   * @return The close-value for the specified series and item.

   */
10
  public Number getCloseValue(int series, int item) {

    if (series==0) {

      return closes[item];

    }

    else return null;

###
3759, getXValue, SampleHighLowDataset, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleHighLowDataset.java, 75, 76
11
/**

   * Returns the x-value for the specified series and item.  Series are numbered 0, 1, ...

   * @param series The index (zero-based) of the series;

   * @param item The index (zero-based) of the required item;

   * @return The x-value for the specified series and item.

   */
4
  public Number getXValue(int series, int item) {

    return new Long(dates[item].getTime());

###
3760, reserveAxisArea, OverlaidVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidVerticalNumberAxis.java, 132, 144
15
/**

   * Returns area in which the axis will be displayed. The list is our axes is

   * checked and the first non zero area is returned.

   * @param g2 The graphics device;

   * @param plot A reference to the plot;

   * @param drawArea The area within which the plot and axes should be drawn;

   * @param reservedWidth The space already reserved for the vertical axis;

   */
24
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,

                     double reservedWidth) {

    Rectangle2D empty = new Rectangle2D.Double();

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      VerticalAxis axis = (VerticalAxis)iter.next();

      Rectangle2D area = axis.reserveAxisArea(g2, plot, drawArea, reservedWidth);

      if (!area.equals(empty)) {

        return area;

      }

    }

    return empty;

###
3762, reserveWidth, OverlaidVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidVerticalNumberAxis.java, 111, 121
13
/**

   * Returns the width required to draw the axis in the specified draw area. The

   * list of our axes is checked and the first non zero width is returned.

   * @param g2 The graphics device;

   * @param plot The plot that the axis belongs to;

   * @param drawArea The area within which the plot should be drawn;

   */
20
  public double reserveWidth(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      VerticalAxis axis = (VerticalAxis)iter.next();

      double width = axis.reserveWidth(g2, plot, drawArea);

      if (width != 0) {

        return width;

      }

    }

    return 0;

###
3763, OverlaidVerticalNumberAxis, OverlaidVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidVerticalNumberAxis.java, 62, 82
9
/**

   * Constructor.

   * @param plot CombinedPlot where this OverlaidVerticalNumberAxis will be

   *    contained.

   */
36
  public OverlaidVerticalNumberAxis(CombinedPlot plot) {

    super((VerticalNumberAxis)plot.getVerticalAxis(), false);

    this.plot = plot;

    this.axes = plot.getVerticalAxes();

    // validate type of axes and tell each axis that they are overlaid

    boolean oneVisible = false;

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      Object axis = iter.next();

      if ((axis instanceof CombinedVerticalNumberAxis)) {

        CombinedVerticalNumberAxis combAxis = (CombinedVerticalNumberAxis)axis;

        oneVisible |= combAxis.isVisible();

        if (iter.hasNext() || oneVisible) {

          combAxis.setGridLinesVisible(false);

        }

      } else {

        throw new IllegalArgumentException("Can not combine " + axis.getClass()

                     + " into " + this.getClass() );

###
3764, getRange, OverlaidVerticalNumberAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidVerticalNumberAxis.java, 155, 156
5
/**

   * Returns the AxisRange (min/max) of our Axis

   */
4
  public AxisRange getRange() {

    return plot.getRange(axes);

###
3765, OverlaidHorizontalDateAxis, OverlaidHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidHorizontalDateAxis.java, 65, 83
9
/**

   * Constructor.

   * @param plot CombinedPlot where this OverlaidHorizontalDateAxis will be

   *    contained.

   */
36
  public OverlaidHorizontalDateAxis(CombinedPlot plot) {

    super((HorizontalDateAxis)plot.getHorizontalAxis(), false);

    this.plot = plot;

    this.axes = plot.getHorizontalAxes();

    // validate type of axes and tell each axis that it's overlaid

    boolean oneVisible = false;

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      Object axis = iter.next();

      if ((axis instanceof CombinedHorizontalDateAxis)) {

        CombinedHorizontalDateAxis combAxis = (CombinedHorizontalDateAxis)axis;

        oneVisible |= combAxis.isVisible();

        if (iter.hasNext() || oneVisible) {

          combAxis.setGridLinesVisible(false);

        }

      } else {

      throw new IllegalArgumentException("Can not combine " + axis.getClass()

                         + " into " + this.getClass() );

###
3766, reserveAxisArea, OverlaidHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidHorizontalDateAxis.java, 132, 143
15
/**

   * Returns area in which the axis will be displayed. The list is our axes is

   * checked and the first non zero area is returned.

   * @param g2 The graphics device;

   * @param plot A reference to the plot;

   * @param drawArea The area within which the plot and axes should be drawn;

   * @param reservedWidth The space already reserved for the vertical axis;

   */
24
  public Rectangle2D reserveAxisArea(Graphics2D g2, Plot plot, Rectangle2D drawArea,

                     double reservedWidth) {

    Rectangle2D empty = new Rectangle2D.Double();

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      HorizontalAxis axis = (HorizontalAxis)iter.next();

      Rectangle2D area = axis.reserveAxisArea(g2, plot, drawArea, reservedWidth);

      if (!area.equals(empty)) {

        return area;

      }

    }

    return empty;

###
3767, getRange, OverlaidHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidHorizontalDateAxis.java, 153, 154
5
/**

   * Returns the AxisRange (min/max) of our Axis

   */
4
  public AxisRange getRange() {

    return plot.getRange(axes);

###
3768, reserveHeight, OverlaidHorizontalDateAxis, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/combination/OverlaidHorizontalDateAxis.java, 112, 121
13
/**

   * Returns the height required to draw the axis in the specified draw area. The

   * list of our axes is checked and the first non zero height is returned.

   * @param g2 The graphics device;

   * @param plot The plot that the axis belongs to;

   * @param drawArea The area within which the plot should be drawn;

   */
20
  public double reserveHeight(Graphics2D g2, Plot plot, Rectangle2D drawArea) {

    Iterator iter = axes.iterator();

    while (iter.hasNext()) {

      HorizontalAxis axis = (HorizontalAxis)iter.next();

      double height = axis.reserveHeight(g2, plot, drawArea);

      if (height != 0) {

        return height;

      }

    }

    return 0;

###
3770, createHighLowDataset, JFreeChartServletDemo, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/JFreeChartServletDemo.java, 150, 389
5
/**

   * Creates and returns a sample high-low dataset for the demo.  Added by Andrzej Porebski.

   */
384
  public HighLowDataset createHighLowDataset() {

    Object[][][] data = new Object[][][] { {

      { createDate(1999, Calendar.JANUARY,4), new Double(47) },

      { createDate(1999, Calendar.JANUARY,4), new Double(33) },

      { createDate(1999, Calendar.JANUARY,4), new Double(35) },

      { createDate(1999, Calendar.JANUARY,4), new Double(33) },

      { createDate(1999, Calendar.JANUARY,5), new Double(47) },

      { createDate(1999, Calendar.JANUARY,5), new Double(32) },

      { createDate(1999, Calendar.JANUARY,5), new Double(41) },

      { createDate(1999, Calendar.JANUARY,5), new Double(37) },

      { createDate(1999, Calendar.JANUARY,6), new Double(49) },

      { createDate(1999, Calendar.JANUARY,6), new Double(43) },

      { createDate(1999, Calendar.JANUARY,6), new Double(46) },

      { createDate(1999, Calendar.JANUARY,6), new Double(48) },

      { createDate(1999, Calendar.JANUARY,7), new Double(51) },

      { createDate(1999, Calendar.JANUARY,7), new Double(39) },

      { createDate(1999, Calendar.JANUARY,7), new Double(40) },

      { createDate(1999, Calendar.JANUARY,7), new Double(47) },

      { createDate(1999, Calendar.JANUARY,8), new Double(60) },

      { createDate(1999, Calendar.JANUARY,8), new Double(40) },

      { createDate(1999, Calendar.JANUARY,8), new Double(46) },

      { createDate(1999, Calendar.JANUARY,8), new Double(53) },

      { createDate(1999, Calendar.JANUARY,9), new Double(62) },

      { createDate(1999, Calendar.JANUARY,9), new Double(55) },

      { createDate(1999, Calendar.JANUARY,9), new Double(57) },

      { createDate(1999, Calendar.JANUARY,9), new Double(61) },

      { createDate(1999, Calendar.JANUARY,10), new Double(65) },

      { createDate(1999, Calendar.JANUARY,10), new Double(56) },

      { createDate(1999, Calendar.JANUARY,10), new Double(62) },

      { createDate(1999, Calendar.JANUARY,10), new Double(59) },

      { createDate(1999, Calendar.JANUARY,11), new Double(55) },

      { createDate(1999, Calendar.JANUARY,11), new Double(43) },

      { createDate(1999, Calendar.JANUARY,11), new Double(45) },

      { createDate(1999, Calendar.JANUARY,11), new Double(47) },

      { createDate(1999, Calendar.JANUARY,12), new Double(54) },

      { createDate(1999, Calendar.JANUARY,12), new Double(33) },

      { createDate(1999, Calendar.JANUARY,12), new Double(40) },

      { createDate(1999, Calendar.JANUARY,12), new Double(51) },

      { createDate(1999, Calendar.JANUARY,13), new Double(58) },

      { createDate(1999, Calendar.JANUARY,13), new Double(42) },

      { createDate(1999, Calendar.JANUARY,13), new Double(44) },

      { createDate(1999, Calendar.JANUARY,13), new Double(57) },

      { createDate(1999, Calendar.JANUARY,14), new Double(54) },

      { createDate(1999, Calendar.JANUARY,14), new Double(38) },

      { createDate(1999, Calendar.JANUARY,14), new Double(43) },

      { createDate(1999, Calendar.JANUARY,14), new Double(52) },

      { createDate(1999, Calendar.JANUARY,15), new Double(48) },

      { createDate(1999, Calendar.JANUARY,15), new Double(41) },

      { createDate(1999, Calendar.JANUARY,15), new Double(44) },

      { createDate(1999, Calendar.JANUARY,15), new Double(41) },

      { createDate(1999, Calendar.JANUARY,17), new Double(60) },

      { createDate(1999, Calendar.JANUARY,17), new Double(30) },

      { createDate(1999, Calendar.JANUARY,17), new Double(34) },

      { createDate(1999, Calendar.JANUARY,17), new Double(44) },

      { createDate(1999, Calendar.JANUARY,18), new Double(58) },

      { createDate(1999, Calendar.JANUARY,18), new Double(44) },

      { createDate(1999, Calendar.JANUARY,18), new Double(54) },

      { createDate(1999, Calendar.JANUARY,18), new Double(56) },

      { createDate(1999, Calendar.JANUARY,19), new Double(54) },

      { createDate(1999, Calendar.JANUARY,19), new Double(32) },

      { createDate(1999, Calendar.JANUARY,19), new Double(42) },

      { createDate(1999, Calendar.JANUARY,19), new Double(53) },

      { createDate(1999, Calendar.JANUARY,20), new Double(53) },

      { createDate(1999, Calendar.JANUARY,20), new Double(39) },

      { createDate(1999, Calendar.JANUARY,20), new Double(50) },

      { createDate(1999, Calendar.JANUARY,20), new Double(49) },

      { createDate(1999, Calendar.JANUARY,21), new Double(47) },

      { createDate(1999, Calendar.JANUARY,21), new Double(38) },

      { createDate(1999, Calendar.JANUARY,21), new Double(41) },

      { createDate(1999, Calendar.JANUARY,21), new Double(40) },

      { createDate(1999, Calendar.JANUARY,22), new Double(55) },

      { createDate(1999, Calendar.JANUARY,22), new Double(37) },

      { createDate(1999, Calendar.JANUARY,22), new Double(43) },

      { createDate(1999, Calendar.JANUARY,22), new Double(45) },

      { createDate(1999, Calendar.JANUARY,23), new Double(54) },

      { createDate(1999, Calendar.JANUARY,23), new Double(42) },

      { createDate(1999, Calendar.JANUARY,23), new Double(50) },

      { createDate(1999, Calendar.JANUARY,23), new Double(42) },

      { createDate(1999, Calendar.JANUARY,24), new Double(48) },

      { createDate(1999, Calendar.JANUARY,24), new Double(37) },

      { createDate(1999, Calendar.JANUARY,24), new Double(37) },

      { createDate(1999, Calendar.JANUARY,24), new Double(47) },

      { createDate(1999, Calendar.JANUARY,25), new Double(58) },

      { createDate(1999, Calendar.JANUARY,25), new Double(33) },

      { createDate(1999, Calendar.JANUARY,25), new Double(39) },

      { createDate(1999, Calendar.JANUARY,25), new Double(41) },

      { createDate(1999, Calendar.JANUARY,26), new Double(47) },

      { createDate(1999, Calendar.JANUARY,26), new Double(31) },

      { createDate(1999, Calendar.JANUARY,26), new Double(36) },

      { createDate(1999, Calendar.JANUARY,26), new Double(41) },

      { createDate(1999, Calendar.JANUARY,27), new Double(58) },

      { createDate(1999, Calendar.JANUARY,27), new Double(44) },

      { createDate(1999, Calendar.JANUARY,27), new Double(49) },

      { createDate(1999, Calendar.JANUARY,27), new Double(44) },

      { createDate(1999, Calendar.JANUARY,28), new Double(46) },

      { createDate(1999, Calendar.JANUARY,28), new Double(41) },

      { createDate(1999, Calendar.JANUARY,28), new Double(43) },

      { createDate(1999, Calendar.JANUARY,28), new Double(44) },

      { createDate(1999, Calendar.JANUARY,29), new Double(56) },

      { createDate(1999, Calendar.JANUARY,29), new Double(39) },

      { createDate(1999, Calendar.JANUARY,29), new Double(39) },

      { createDate(1999, Calendar.JANUARY,29), new Double(51) },

      { createDate(1999, Calendar.JANUARY,30), new Double(56) },

      { createDate(1999, Calendar.JANUARY,30), new Double(39) },

      { createDate(1999, Calendar.JANUARY,30), new Double(47) },

      { createDate(1999, Calendar.JANUARY,30), new Double(49) },

      { createDate(1999, Calendar.JANUARY,31), new Double(53) },

      { createDate(1999, Calendar.JANUARY,31), new Double(39) },

      { createDate(1999, Calendar.JANUARY,31), new Double(52) },

      { createDate(1999, Calendar.JANUARY,31), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,1), new Double(51) },

      { createDate(1999, Calendar.FEBRUARY,1), new Double(30) },

      { createDate(1999, Calendar.FEBRUARY,1), new Double(45) },

      { createDate(1999, Calendar.FEBRUARY,1), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,2), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,2), new Double(30) },

      { createDate(1999, Calendar.FEBRUARY,2), new Double(34) },

      { createDate(1999, Calendar.FEBRUARY,2), new Double(46) },

      { createDate(1999, Calendar.FEBRUARY,3), new Double(57) },

      { createDate(1999, Calendar.FEBRUARY,3), new Double(37) },

      { createDate(1999, Calendar.FEBRUARY,3), new Double(44) },

      { createDate(1999, Calendar.FEBRUARY,3), new Double(56) },

      { createDate(1999, Calendar.FEBRUARY,4), new Double(49) },

      { createDate(1999, Calendar.FEBRUARY,4), new Double(40) },

      { createDate(1999, Calendar.FEBRUARY,4), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,4), new Double(44) },

      { createDate(1999, Calendar.FEBRUARY,5), new Double(46) },

      { createDate(1999, Calendar.FEBRUARY,5), new Double(38) },

      { createDate(1999, Calendar.FEBRUARY,5), new Double(43) },

      { createDate(1999, Calendar.FEBRUARY,5), new Double(40) },

      { createDate(1999, Calendar.FEBRUARY,6), new Double(55) },

      { createDate(1999, Calendar.FEBRUARY,6), new Double(38) },

      { createDate(1999, Calendar.FEBRUARY,6), new Double(39) },

      { createDate(1999, Calendar.FEBRUARY,6), new Double(53) },

      { createDate(1999, Calendar.FEBRUARY,7), new Double(50) },

      { createDate(1999, Calendar.FEBRUARY,7), new Double(33) },

      { createDate(1999, Calendar.FEBRUARY,7), new Double(37) },

      { createDate(1999, Calendar.FEBRUARY,7), new Double(37) },

      { createDate(1999, Calendar.FEBRUARY,8), new Double(59) },

      { createDate(1999, Calendar.FEBRUARY,8), new Double(34) },

      { createDate(1999, Calendar.FEBRUARY,8), new Double(57) },

      { createDate(1999, Calendar.FEBRUARY,8), new Double(43) },

      { createDate(1999, Calendar.FEBRUARY,9), new Double(48) },

      { createDate(1999, Calendar.FEBRUARY,9), new Double(39) },

      { createDate(1999, Calendar.FEBRUARY,9), new Double(46) },

      { createDate(1999, Calendar.FEBRUARY,9), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,10), new Double(55) },

      { createDate(1999, Calendar.FEBRUARY,10), new Double(30) },

      { createDate(1999, Calendar.FEBRUARY,10), new Double(37) },

      { createDate(1999, Calendar.FEBRUARY,10), new Double(30) },

      { createDate(1999, Calendar.FEBRUARY,11), new Double(60) },

      { createDate(1999, Calendar.FEBRUARY,11), new Double(32) },

      { createDate(1999, Calendar.FEBRUARY,11), new Double(56) },

      { createDate(1999, Calendar.FEBRUARY,11), new Double(36) },

      { createDate(1999, Calendar.FEBRUARY,12), new Double(56) },

      { createDate(1999, Calendar.FEBRUARY,12), new Double(42) },

      { createDate(1999, Calendar.FEBRUARY,12), new Double(53) },

      { createDate(1999, Calendar.FEBRUARY,12), new Double(54) },

      { createDate(1999, Calendar.FEBRUARY,13), new Double(49) },

      { createDate(1999, Calendar.FEBRUARY,13), new Double(42) },

      { createDate(1999, Calendar.FEBRUARY,13), new Double(45) },

      { createDate(1999, Calendar.FEBRUARY,13), new Double(42) },

      { createDate(1999, Calendar.FEBRUARY,14), new Double(55) },

      { createDate(1999, Calendar.FEBRUARY,14), new Double(42) },

      { createDate(1999, Calendar.FEBRUARY,14), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,14), new Double(54) },

      { createDate(1999, Calendar.FEBRUARY,15), new Double(49) },

      { createDate(1999, Calendar.FEBRUARY,15), new Double(35) },

      { createDate(1999, Calendar.FEBRUARY,15), new Double(38) },

      { createDate(1999, Calendar.FEBRUARY,15), new Double(35) },

      { createDate(1999, Calendar.FEBRUARY,16), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,16), new Double(38) },

      { createDate(1999, Calendar.FEBRUARY,16), new Double(43) },

      { createDate(1999, Calendar.FEBRUARY,16), new Double(42) },

      { createDate(1999, Calendar.FEBRUARY,17), new Double(53) },

      { createDate(1999, Calendar.FEBRUARY,17), new Double(42) },

      { createDate(1999, Calendar.FEBRUARY,17), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,17), new Double(48) },

      { createDate(1999, Calendar.FEBRUARY,18), new Double(47) },

      { createDate(1999, Calendar.FEBRUARY,18), new Double(44) },

      { createDate(1999, Calendar.FEBRUARY,18), new Double(46) },

      { createDate(1999, Calendar.FEBRUARY,18), new Double(44) },

      { createDate(1999, Calendar.FEBRUARY,19), new Double(46) },

      { createDate(1999, Calendar.FEBRUARY,19), new Double(40) },

      { createDate(1999, Calendar.FEBRUARY,19), new Double(43) },

      { createDate(1999, Calendar.FEBRUARY,19), new Double(44) },

      { createDate(1999, Calendar.FEBRUARY,20), new Double(48) },

      { createDate(1999, Calendar.FEBRUARY,20), new Double(41) },

      { createDate(1999, Calendar.FEBRUARY,20), new Double(46) },

      { createDate(1999, Calendar.FEBRUARY,20), new Double(41) } }

    };

    return null;  // broken, needs fixing...

###
3771, getColor, JFreeChartServletDemo, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/JFreeChartServletDemo.java, 70, 84
7
/**

   * Utility method to return a color.  Corresponds to the color selection in the

   * HTML form.

   */
28
  protected Color getColor(int color) {

    switch (color % 11) {

      case 0: return Color.white;

      case 1: return Color.black;

      case 2: return Color.blue;

      case 3: return Color.green;

      case 4: return Color.red;

      case 5: return Color.yellow;

      case 6: return Color.gray;

      case 7 : return Color.orange;

      case 8: return Color.cyan;

      case 9: return Color.magenta;

      case 10: return Color.pink;

      default: return Color.white;

###
3772, createCategoryDataset, JFreeChartServletDemo, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/JFreeChartServletDemo.java, 92, 107
5
/**

   * Creates and returns a category dataset for the demo charts.

   */
26
  public CategoryDataset createCategoryDataset() {

    Number[][] data = new Integer[][] {

      { new Integer(10), new Integer(4), new Integer(15), new Integer(14) },

      { new Integer(5), new Integer(7), new Integer(14), new Integer(3) },

      { new Integer(6), new Integer(17), new Integer(12), new Integer(7) },

      { new Integer(7), new Integer(15), new Integer(11), new Integer(0) },

      { new Integer(8), new Integer(6), new Integer(10), new Integer(9) },

      { new Integer(9), new Integer(8), new Integer(8), new Integer(6) },

      { new Integer(10), new Integer(9), new Integer(7), new Integer(7) },

      { new Integer(11), new Integer(13), new Integer(9), new Integer(9) },

      { new Integer(3), new Integer(7), new Integer(11), new Integer(10) }

    };

    return new DefaultCategoryDataset(data);

###
3773, createDateTime, JFreeChartServletDemo, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/JFreeChartServletDemo.java, 122, 124
5
/**

   * Returns a java.util.Date for the specified year, month, day, hour and minute.

   */
6
  private Date createDateTime(int year, int month, int day, int hour, int minute) {

    GregorianCalendar calendar = new GregorianCalendar(year, month, day, hour, minute);

    return calendar.getTime();

###
3774, doGet, JFreeChartServletDemo, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/JFreeChartServletDemo.java, 570, 609
9
/**

   * Basic servlet method, answers requests fromt the browser.

   * @param request HTTPServletRequest

   * @param response HTTPServletResponse

   */
70
  public void doGet(HttpServletRequest request,

           HttpServletResponse response) throws ServletException, IOException {

    response.setContentType("image/jpeg");

    int type = 1;

    try {

      type = Integer.parseInt( request.getParameter( "type" ) );

    }

    catch (Exception e) {

    }

    int  initGradColor= 0;

    int  finalGradColor= 0;

    try {

      initGradColor = Integer.parseInt( request.getParameter( "initGradColor" ) );

      finalGradColor = Integer.parseInt( request.getParameter( "finalGradColor" ) );

    }

    catch (Exception e) {

    }

    JFreeChart chart = createChart( type, initGradColor, finalGradColor );

    int width = 400;

    int height = 300;

    try {

      width = Integer.parseInt( request.getParameter( "width" ) );

      height = Integer.parseInt( request.getParameter( "height" ) );

    }

    catch (Exception e) {

    }

    //BufferedImage img = draw( chart, width, height );

    OutputStream out = response.getOutputStream();

//    BufferedImage image = chart.createBufferedImage(width, height);

//    JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);

//    JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(image);

//    param.setQuality(1.0f, true);

//    encoder.encode(image, param);

    ChartUtilities.writeChartAsJPEG(out, chart, width, height);

    out.close();

###
3775, createTestXYDataset, JFreeChartServletDemo, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/JFreeChartServletDemo.java, 130, 143
5
/**

   * Creates and returns a XYDataset for the demo charts.

   */
24
  public XYDataset createTestXYDataset() {

    Object[][][] data = new Object[][][] { {

      { createDateTime(2000, Calendar.OCTOBER, 18, 9, 5), new Double(10921.0) },

      { createDateTime(2000, Calendar.OCTOBER, 18, 10, 6), new Double(10886.7) },

      { createDateTime(2000, Calendar.OCTOBER, 18, 11, 6), new Double(10846.6) },

      { createDateTime(2000, Calendar.OCTOBER, 18, 12, 6), new Double(10843.7) },

      { createDateTime(2000, Calendar.OCTOBER, 18, 13, 6), new Double(10841.2) },

      { createDateTime(2000, Calendar.OCTOBER, 18, 14, 6), new Double(10830.7) },

      { createDateTime(2000, Calendar.OCTOBER, 18, 15, 6), new Double(10795.8) },

      { createDateTime(2000, Calendar.OCTOBER, 18, 16, 7), new Double(10733.8) }

    } };

    return new DefaultXYDataset(data);

###
3776, init, JFreeChartServletDemo, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/JFreeChartServletDemo.java, 558, 562
5
/**

   * Override init() to set up data used by invocations of this servlet.

   */
8
  public void init(ServletConfig config) throws ServletException {

    super.init(config);

    // save servlet context

    context = config.getServletContext();

###
3778, createDate, JFreeChartServletDemo, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/JFreeChartServletDemo.java, 114, 116
5
/**

   * Returns a java.util.Date for the specified year, month and day.

   */
6
  private Date createDate(int year, int month, int day) {

    GregorianCalendar calendar = new GregorianCalendar(year, month, day);

    return calendar.getTime();

###
3779, SampleXYDataset2, SampleXYDataset2, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleXYDataset2.java, 62, 68
5
/**

   * Default constructor.

   */
12
  public SampleXYDataset2() {

    for (int series=0; series<SERIES_COUNT; series++) {

      for (int item=0; item<ITEM_COUNT; item++) {

        double x = (Math.random()-0.5) * RANGE;

        xValues[series][item] = new Double(x);

        yValues[series][item] = new Double((Math.random() - 0.5) * x * x);

###
3780, getYValue, SampleXYDataset2, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleXYDataset2.java, 90, 91
11
/**

   * Returns the y-value for the specified series and item.  Series are numbered 0, 1, ...

   * @param series The index (zero-based) of the series;

   * @param item The index (zero-based) of the required item;

   * @return The y-value for the specified series and item.

   */
4
  public Number getYValue(int series, int item) {

    return yValues[series][item];

###
3781, getXValue, SampleXYDataset2, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleXYDataset2.java, 80, 81
11
/**

   * Returns the x-value for the specified series and item.  Series are numbered 0, 1, ...

   * @param series The index (zero-based) of the series;

   * @param item The index (zero-based) of the required item;

   * @return The x-value for the specified series and item.

   */
4
  public Number getXValue(int series, int item) {

    return xValues[series][item];

###
3782, getSeriesName, SampleXYDataset2, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleXYDataset2.java, 107, 108
9
/**

   * Returns the name of the series.

   * @param series The index (zero-based) of the series;

   * @return The name of the series.

   */
4
  public String getSeriesName(int series) {

    return "Sample "+series;

###
3783, getSeriesCount, SampleXYDataset2, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/demo/SampleXYDataset2.java, 98, 99
7
/**

   * Returns the number of series in the data source.

   * @return The number of series in the data source.

   */
4
  public int getSeriesCount() {

    return SERIES_COUNT;

###
3784, ToolTip, ToolTip, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/tooltips/ToolTip.java, 59, 65
9
/**

   * Constructs a new tooltip.

   * @param text The tooltip text.

   * @param area The area that the tooltip is relevant to.

   */
10
  public ToolTip(String text, Shape area) {

    // check arguments...

    if (area==null) throw new IllegalArgumentException("ToolTip(...): null area.");

    this.text = text;

    this.area = area;

###
3785, getText, ToolTip, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/tooltips/ToolTip.java, 72, 73
7
/**

   * Returns the tooltip text.

   * @return The tooltip text.

   */
4
  public String getText() {

    return this.text;

###
3786, StandardToolTipsCollection, StandardToolTipsCollection, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/tooltips/StandardToolTipsCollection.java, 55, 56
5
/**

   * Constructs a new tooltip collection (initially empty).

   */
4
  public StandardToolTipsCollection() {

    tooltips = new ArrayList();

###
3787, addToolTip, StandardToolTipsCollection, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/tooltips/StandardToolTipsCollection.java, 71, 73
9
/**

   * Adds a tooltip.

   * @param text The tooltip text.

   * @param area The area that the tooltip is relevant to.

   */
6
  public void addToolTip(String text, Shape area) {

    ToolTip tooltip = new ToolTip(text, area);

    tooltips.add(tooltip);

###
3788, clearToolTips, StandardToolTipsCollection, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/tooltips/StandardToolTipsCollection.java, 62, 63
5
/**

   * Clears the tooltips.

   */
4
  public void clearToolTips() {

    tooltips.clear();

###
3789, getPlotPropertyEditPanel, ChartPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 177, 178
5
/**

   * Returns a reference to the plot property sub-panel.

   */
4
  public PlotPropertyEditPanel getPlotPropertyEditPanel() {

    return plotPropertiesPanel;

###
3790, getTitlePropertyEditPanel, ChartPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 163, 164
5
/**

   * Returns a reference to the title property sub-panel.

   */
4
  public TitlePropertyEditPanel getTitlePropertyEditPanel() {

    return titlePropertiesPanel;

###
3791, actionPerformed, ChartPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 198, 201
5
/**

   * Handles user interactions with the panel.

   */
8
  public void actionPerformed(ActionEvent event) {

    String command = event.getActionCommand();

    if (command.equals("BackgroundPaint")) {

      attemptModifyBackgroundPaint();

###
3792, getBackgroundPaint, ChartPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 191, 192
5
/**

   * Returns the current background paint.

   */
4
  public Paint getBackgroundPaint() {

    return background.getPaint();

###
3793, getAntiAlias, ChartPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 184, 185
5
/**

   * Returns the current setting of the anti-alias flag.

   */
4
  public boolean getAntiAlias() {

    return antialias.isSelected();

###
3794, getLegendPropertyEditPanel, ChartPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 170, 171
5
/**

   * Returns a reference to the legend property sub-panel.

   */
4
  public LegendPropertyEditPanel getLegendPropertyEditPanel() {

    return legendPropertiesPanel;

###
3795, ChartPropertyEditPanel, ChartPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 71, 157
7
/**

   * Standard constructor - the property panel is made up of a number of sub-panels that are

   * displayed in the tabbed pane.

   */
142
  public ChartPropertyEditPanel(JFreeChart chart) {

    setLayout(new BorderLayout());

    JPanel other = new JPanel(new BorderLayout());

    other.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

    JPanel general = new JPanel(new BorderLayout());

    general.setBorder(BorderFactory.createTitledBorder(

                BorderFactory.createEtchedBorder(), "General:"));

    JPanel interior = new JPanel(new LCBLayout(6));

    interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    antialias = new JCheckBox("Draw anti-aliased");

    antialias.setSelected(chart.getAntiAlias());

    interior.add(antialias);

    interior.add(new JLabel(""));

    interior.add(new JLabel(""));

    interior.add(new JLabel("Background paint:"));

    background = new PaintSample(chart.getChartBackgroundPaint());

    interior.add(background);

    JButton button = new JButton("Select...");

    button.setActionCommand("BackgroundPaint");

    button.addActionListener(this);

    interior.add(button);

    interior.add(new JLabel("Series Paint:"));

    JTextField info = new JTextField("No editor implemented");

    info.setEnabled(false);

    interior.add(info);

    button = new JButton("Edit...");

    button.setEnabled(false);

    interior.add(button);

    interior.add(new JLabel("Series Stroke:"));

    info = new JTextField("No editor implemented");

    info.setEnabled(false);

    interior.add(info);

    button = new JButton("Edit...");

    button.setEnabled(false);

    interior.add(button);

    interior.add(new JLabel("Series Outline Paint:"));

    info = new JTextField("No editor implemented");

    info.setEnabled(false);

    interior.add(info);

    button = new JButton("Edit...");

    button.setEnabled(false);

    interior.add(button);

    interior.add(new JLabel("Series Outline Stroke:"));

    info = new JTextField("No editor implemented");

    info.setEnabled(false);

    interior.add(info);

    button = new JButton("Edit...");

    button.setEnabled(false);

    interior.add(button);

    general.add(interior, BorderLayout.NORTH);

    other.add(general, BorderLayout.NORTH);

    JPanel parts = new JPanel(new BorderLayout());

    //Title title = chart.getTitle();

    Legend legend = chart.getLegend();

    Plot plot = chart.getPlot();

    JTabbedPane tabs = new JTabbedPane();

    //StandardTitle t = (StandardTitle)title;

    //titlePropertiesPanel = new TitlePropertyEditPanel(t);

    //titlePropertiesPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

    //tabs.addTab("Title", titlePropertiesPanel);

    if (legend!=null) {

      legendPropertiesPanel = new LegendPropertyEditPanel(legend);

      legendPropertiesPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

      tabs.addTab("Legend", legendPropertiesPanel);

    }

    plotPropertiesPanel = new PlotPropertyEditPanel(plot);

    plotPropertiesPanel.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

    tabs.addTab("Plot", plotPropertiesPanel);

    tabs.add("Other", other);

    parts.add(tabs, BorderLayout.NORTH);

    add(parts);

###
3796, attemptModifyBackgroundPaint, ChartPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/ChartPropertyEditPanel.java, 209, 213
7
/**

   * Allows the user the opportunity to select a new background paint.  Uses JColorChooser,

   * so we are only allowing a subset of all Paint objects to be selected (fix later).

   */
10
  private void attemptModifyBackgroundPaint() {

    Color c;

    c = JColorChooser.showDialog(this, "Background Color", Color.blue);

    if (c!=null) {

      background.setPaint(c);

###
3799, getLabelFont, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 227, 228
5
/**

   * Returns the current label font.

   */
4
  public Font getLabelFont() {

    return labelFont;

###
3800, attemptLabelFontSelection, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 316, 324
5
/**

   * Presents a font selection dialog to the user.

   */
14
  private void attemptLabelFontSelection() {

    FontChooserPanel panel = new FontChooserPanel(labelFont);

    int result = JOptionPane.showConfirmDialog(this, panel, "Font Selection",

      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {

      labelFont = panel.getSelectedFont();

      labelFontField.setText(labelFont.getFontName()+" "+labelFont.getSize());

###
3801, getLabelInsets, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 277, 278
5
/**

   * Returns the current label insets value

   */
4
  public Insets getLabelInsets() {

    return (_labelInsets == null) ? new Insets(0,0,0,0) : _labelInsets;

###
3802, isTickMarksVisible, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 263, 264
7
/**

   * Returns the current value of the flag that determines whether or not tick marks are

   * visible.

   */
4
  public boolean isTickMarksVisible() {

    return showTickMarksCheckBox.isSelected();

###
3803, getTickLabelPaint, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 255, 256
5
/**

   * Returns the current tick label paint.

   */
4
  public Paint getTickLabelPaint() {

    return tickLabelPaintSample.getPaint();

###
3804, getLabelPaint, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 234, 235
5
/**

   * Returns the current label paint.

   */
4
  public Paint getLabelPaint() {

    return labelPaintSample.getPaint();

###
3805, attemptModifyLabelPaint, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 332, 336
5
/**

   * Allows the user the opportunity to change the outline paint.

   */
10
  private void attemptModifyLabelPaint() {

    Color c;

    c = JColorChooser.showDialog(this, "Label Color", Color.blue);

    if (c!=null) {

      labelPaintSample.setPaint(c);

###
3806, attemptTickLabelFontSelection, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 343, 351
5
/**

   * Presents a tick label font selection dialog to the user.

   */
14
  public void attemptTickLabelFontSelection() {

    FontChooserPanel panel = new FontChooserPanel(tickLabelFont);

    int result = JOptionPane.showConfirmDialog(this, panel, "Font Selection",

      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {

      tickLabelFont = panel.getSelectedFont();

      tickLabelFontField.setText(tickLabelFont.getFontName()+" "+tickLabelFont.getSize());

###
3807, getInstance, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 98, 107
7
/**

   * A static method that returns a panel that is appropriate for the axis type.

   * @param axis The axis whose properties are to be displayed/edited in the panel;

   */
18
  public static AxisPropertyEditPanel getInstance(Axis axis) {

    if (axis!=null) {

      // figure out what type of axis we have and instantiate the appropriate panel

      if (axis instanceof NumberAxis) {

        return new NumberAxisPropertyEditPanel((NumberAxis)axis);

      }

      else return new AxisPropertyEditPanel(axis);

    }

    else return null;

###
3808, getLabel, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 220, 221
5
/**

   * Returns the current axis label.

   */
4
  public String getLabel() {

    return label.getText();

###
3809, getOtherTabs, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 284, 285
5
/**

   * Returns a reference to the tabbed pane.

   */
4
  public JTabbedPane getOtherTabs() {

    return otherTabs;

###
3810, editTickLabelInsets, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 361, 369
9
/**

   * Presents insets chooser panel allowing user to modify tick label's

   * individual insets values. Updates the current insets text field if edit

   * is accepted.

   */
16
  private void editTickLabelInsets() {

    InsetsChooserPanel panel = new InsetsChooserPanel(_tickLabelInsets);

    int result =

      JOptionPane.showConfirmDialog(this, panel, "Edit Insets",

                      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {

      _tickLabelInsets = panel.getInsets();

      tickLabelInsetsTextField.setInsets(_tickLabelInsets);

###
3811, editLabelInsets, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 378, 386
9
/**

   * Presents insets chooser panel allowing user to modify label's

   * individual insets values. Updates the current insets text field if edit

   * is accepted.

   */
16
  private void editLabelInsets() {

    InsetsChooserPanel panel = new InsetsChooserPanel(_labelInsets);

    int result =

      JOptionPane.showConfirmDialog(this, panel, "Edit Insets",

                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {

      _labelInsets = panel.getInsets();

      labelInsetsTextField.setInsets(_labelInsets);

###
3812, AxisPropertyEditPanel, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 116, 213
9
/**

   * Standard constructor: builds a panel for displaying/editing the properties of the specified

   * axis.

   * @param axis The axis whose properties are to be displayed/edited in the panel;

   */
152
  public AxisPropertyEditPanel(Axis axis) {

    labelFont = axis.getLabelFont();

    labelPaintSample = new PaintSample(axis.getLabelPaint());

    tickLabelFont = axis.getTickLabelFont();

    tickLabelPaintSample = new PaintSample(axis.getTickLabelPaint());

    // Insets values

    _tickLabelInsets = axis.getTickLabelInsets();

    _labelInsets = axis.getLabelInsets();

    setLayout(new BorderLayout());

    JPanel general = new JPanel(new BorderLayout());

    general.setBorder(BorderFactory.createTitledBorder(

              BorderFactory.createEtchedBorder(), "General:"));

    JPanel interior = new JPanel(new LCBLayout(5));

    interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    interior.add(new JLabel("Label:"));

    label = new JTextField(axis.getLabel());

    interior.add(label);

    interior.add(new JPanel());

    interior.add(new JLabel("Font:"));

    labelFontField = new FontDisplayField(labelFont);

    interior.add(labelFontField);

    JButton b = new JButton("Select...");

    b.setActionCommand("SelectLabelFont");

    b.addActionListener(this);

    interior.add(b);

    interior.add(new JLabel("Paint:"));

    interior.add(labelPaintSample);

    b = new JButton("Select...");

    b.setActionCommand("SelectLabelPaint");

    b.addActionListener(this);

    interior.add(b);

    interior.add(new JLabel("Label Insets:"));

    b = new JButton("Edit...");

    b.setActionCommand("LabelInsets");

    b.addActionListener(this);

    labelInsetsTextField = new InsetsTextField(_labelInsets);

    interior.add(labelInsetsTextField);

    interior.add(b);

    interior.add(new JLabel("Tick Label Insets:"));

    b = new JButton("Edit...");

    b.setActionCommand("TickLabelInsets");

    b.addActionListener(this);

    tickLabelInsetsTextField = new InsetsTextField(_tickLabelInsets);

    interior.add(tickLabelInsetsTextField);

    interior.add(b);

    general.add(interior);

    add(general, BorderLayout.NORTH);

    slot1 = new JPanel(new BorderLayout());

    JPanel other = new JPanel(new BorderLayout());

    other.setBorder(BorderFactory.createTitledBorder(

               BorderFactory.createEtchedBorder(), "Other:"));

    otherTabs = new JTabbedPane();

    otherTabs.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    JPanel ticks = new JPanel(new LCBLayout(3));

    ticks.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

    showTickLabelsCheckBox = new JCheckBox("Show tick labels", axis.isTickLabelsVisible());

    ticks.add(showTickLabelsCheckBox);

    ticks.add(new JPanel());

    ticks.add(new JPanel());

    ticks.add(new JLabel("Tick label font:"));

    tickLabelFontField = new FontDisplayField(tickLabelFont);

    ticks.add(tickLabelFontField);

    b = new JButton("Select...");

    b.setActionCommand("SelectTickLabelFont");

    b.addActionListener(this);

    ticks.add(b);

    showTickMarksCheckBox = new JCheckBox("Show tick marks", axis.isTickMarksVisible());

    ticks.add(showTickMarksCheckBox);

    ticks.add(new JPanel());

    ticks.add(new JPanel());

    otherTabs.add("Ticks", ticks);

    other.add(otherTabs);

    slot1.add(other);

    slot2 = new JPanel(new BorderLayout());

    slot2.add(slot1, BorderLayout.NORTH);

    add(slot2);

###
3813, getTickLabelInsets, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 270, 271
5
/**

   * Returns the current tick label insets value

   */
4
  public Insets getTickLabelInsets() {

    return (_tickLabelInsets == null) ? new Insets(0,0,0,0) : _tickLabelInsets;

###
3814, setAxisProperties, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 393, 403
5
/**

   * Sets the properties of the specified axis to match the properties defined on this panel.

   */
22
  public void setAxisProperties(Axis axis) {

    axis.setLabel(this.getLabel());

    axis.setLabelFont(this.getLabelFont());

    axis.setLabelPaint(this.getLabelPaint());

    axis.setTickMarksVisible(this.isTickMarksVisible());

    // axis.setTickMarkStroke(this.getTickMarkStroke());

    axis.setTickLabelsVisible(this.isTickLabelsVisible());

    axis.setTickLabelFont(this.getTickLabelFont());

    axis.setTickLabelPaint(this.getTickLabelPaint());

    axis.setTickLabelInsets(this.getTickLabelInsets());

    axis.setLabelInsets(this.getLabelInsets());

###
3815, isTickLabelsVisible, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 241, 242
5
/**

   * Returns a flag that indicates whether or not the tick labels are visible.

   */
4
  public boolean isTickLabelsVisible() {

    return showTickLabelsCheckBox.isSelected();

###
3816, actionPerformed, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 292, 309
7
/**

   * Handles user interaction with the property panel.

   * @param event Information about the event that triggered the call to this method.

   */
36
  public void actionPerformed(ActionEvent event) {

    String command = event.getActionCommand();

    if (command.equals("SelectLabelFont")) {

      attemptLabelFontSelection();

    }

    else if (command.equals("SelectLabelPaint")) {

      attemptModifyLabelPaint();

    }

    else if (command.equals("SelectTickLabelFont")) {

      attemptTickLabelFontSelection();

    }

    else if (command.equals("LabelInsets"))

    {

      editLabelInsets();

    }

    else if (command.equals("TickLabelInsets"))

    {

      editTickLabelInsets();

###
3817, getTickLabelFont, AxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/AxisPropertyEditPanel.java, 248, 249
5
/**

   * Returns the font used to draw the tick labels (if they are showing).

   */
4
  public Font getTickLabelFont() {

    return tickLabelFont;

###
3818, PlotPropertyEditPanel, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 80, 159
13
/**

   * Standard constructor - constructs a panel for editing the properties of the specified plot.

   * <P>

   * In designing the panel, we need to be aware that subclasses of Plot will need to implement

   * subclasses of PlotPropertyEditPanel - so we need to leave one or two 'slots' where the

   * subclasses can extend the user interface.

   */
128
  public PlotPropertyEditPanel(Plot plot) {

    _insets = plot.getInsets();

    backgroundPaintSample = new PaintSample(plot.getBackgroundPaint());

    outlineStrokeSample = new StrokeSample(plot.getOutlineStroke());

    outlinePaintSample = new PaintSample(plot.getOutlinePaint());

    setLayout(new BorderLayout());

    availableStrokeSamples = new StrokeSample[3];

    availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));

    availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));

    availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));

    // create a panel for the settings...

    JPanel panel = new JPanel(new BorderLayout());

    panel.setBorder(BorderFactory.createTitledBorder(

              BorderFactory.createEtchedBorder(), plot.getPlotType()+":"));

    JPanel general = new JPanel(new BorderLayout());

    general.setBorder(BorderFactory.createTitledBorder(

                BorderFactory.createEtchedBorder(), "General:"));

    JPanel interior = new JPanel(new LCBLayout(4));

    interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    interior.add(new JLabel("Insets:"));

    JButton button = new JButton("Edit...");

    button.setActionCommand("Insets");

    button.addActionListener(this);

    insetsTextField = new InsetsTextField(_insets);

    insetsTextField.setEnabled(false);

    interior.add(insetsTextField);

    interior.add(button);

    interior.add(new JLabel("Outline stroke:"));

    button = new JButton("Select...");

    button.setActionCommand("OutlineStroke");

    button.addActionListener(this);

    interior.add(outlineStrokeSample);

    interior.add(button);

    interior.add(new JLabel("Outline paint:"));

    button = new JButton("Select...");

    button.setActionCommand("OutlinePaint");

    button.addActionListener(this);

    interior.add(outlinePaintSample);

    interior.add(button);

    interior.add(new JLabel("Background paint:"));

    button = new JButton("Select...");

    button.setActionCommand("BackgroundPaint");

    button.addActionListener(this);

    interior.add(backgroundPaintSample);

    interior.add(button);

    general.add(interior, BorderLayout.NORTH);

    JPanel appearance = new JPanel(new BorderLayout());

    appearance.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

    appearance.add(general, BorderLayout.NORTH);

    JTabbedPane tabs = new JTabbedPane();

    tabs.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    verticalAxisPropertyPanel = AxisPropertyEditPanel.getInstance(plot.getAxis(Plot.VERTICAL_AXIS));

    if (verticalAxisPropertyPanel!=null) {

      verticalAxisPropertyPanel.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));

      tabs.add("Vertical Axis", verticalAxisPropertyPanel);

    }

    horizontalAxisPropertyPanel = AxisPropertyEditPanel.getInstance(plot.getAxis(Plot.HORIZONTAL_AXIS));

    if (horizontalAxisPropertyPanel!=null) {

      horizontalAxisPropertyPanel.setBorder(BorderFactory.createEmptyBorder(2,2,2,2));

      tabs.add("Horizontal Axis", horizontalAxisPropertyPanel);

    }

    tabs.add("Appearance", appearance);

    panel.add(tabs);

    add(panel);

###
3819, getOutlinePaint, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 188, 189
5
/**

   * Returns the current outline paint.

   */
4
  public Paint getOutlinePaint() {

    return outlinePaintSample.getPaint();

###
3820, getOutlineStroke, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 181, 182
5
/**

   * Returns the current outline stroke.

   */
4
  public Stroke getOutlineStroke() {

    return outlineStrokeSample.getStroke();

###
3821, attemptOutlinePaintSelection, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 254, 258
7
/**

   * Allow the user to change the outline paint.  We use JColorChooser, so the user can only

   * choose colors (a subset of all possible paints).

   */
10
  private void attemptOutlinePaintSelection() {

    Color c;

    c = JColorChooser.showDialog(this, "Outline Color", Color.blue);

    if (c!=null) {

      outlinePaintSample.setPaint(c);

###
3822, getPlotInsets, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 165, 168
5
/**

   * Returns the current plot insets.

   */
8
  public Insets getPlotInsets() {

    if (_insets == null)

      _insets = new Insets(0,0,0,0);

    return _insets;

###
3823, getBackgroundPaint, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 174, 175
5
/**

   * Returns the current background paint.

   */
4
  public Paint getBackgroundPaint() {

    return backgroundPaintSample.getPaint();

###
3824, getVerticalAxisPropertyEditPanel, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 195, 196
5
/**

   * Returns a reference to the panel for editing the properties of the vertical axis.

   */
4
  public AxisPropertyEditPanel getVerticalAxisPropertyEditPanel() {

    return verticalAxisPropertyPanel;

###
3825, attemptOutlineStrokeSelection, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 240, 246
5
/**

   * Allow the user to change the outline stroke.

   */
12
  private void attemptOutlineStrokeSelection() {

    StrokeChooserPanel panel = new StrokeChooserPanel(null, availableStrokeSamples);

    int result = JOptionPane.showConfirmDialog(this, panel, "Stroke Selection",

      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {

      outlineStrokeSample.setStroke(panel.getSelectedStroke());

###
3826, attemptBackgroundPaintSelection, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 229, 233
5
/**

   * Allow the user to change the background paint.

   */
10
  private void attemptBackgroundPaintSelection() {

    Color c;

    c = JColorChooser.showDialog(this, "Background Color", Color.blue);

    if (c!=null) {

      backgroundPaintSample.setPaint(c);

###
3827, getHorizontalAxisPropertyEditPanel, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 202, 203
5
/**

   * Returns a reference to the panel for editing the properties of the horizontal axis.

   */
4
  public AxisPropertyEditPanel getHorizontalAxisPropertyEditPanel() {

    return horizontalAxisPropertyPanel;

###
3828, editInsets, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 265, 273
5
/**

   * Allow the user to edit the individual insets' values.

   */
16
  private void editInsets() {

    InsetsChooserPanel panel = new InsetsChooserPanel(_insets);

    int result =

      JOptionPane.showConfirmDialog(this, panel, "Edit Insets",

                      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {

      _insets = panel.getInsets();

      insetsTextField.setInsets(_insets);

###
3829, updatePlotProperties, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 282, 296
7
/**

   * Updates the plot properties to match the properties defined on the panel.

   * @param plot The plot.

   */
24
  public void updatePlotProperties(Plot plot) {

    // set the plot properties...

    plot.setOutlinePaint(this.getOutlinePaint());

    plot.setOutlineStroke(this.getOutlineStroke());

    plot.setBackgroundPaint(this.getBackgroundPaint());

    plot.setInsets(this.getPlotInsets());

    // then the axis properties...

    if (this.horizontalAxisPropertyPanel!=null) {

      this.horizontalAxisPropertyPanel.setAxisProperties(plot.getAxis(Plot.HORIZONTAL_AXIS));

    }

    if (this.verticalAxisPropertyPanel!=null) {

      this.verticalAxisPropertyPanel.setAxisProperties(plot.getAxis(Plot.VERTICAL_AXIS));

###
3830, actionPerformed, PlotPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/PlotPropertyEditPanel.java, 209, 221
5
/**

   * Handles user actions generated within the panel.

   */
26
  public void actionPerformed(ActionEvent event) {

    String command = event.getActionCommand();

    if (command.equals("BackgroundPaint")) {

      attemptBackgroundPaintSelection();

    }

    else if (command.equals("OutlineStroke")) {

      attemptOutlineStrokeSelection();

    }

    else if (command.equals("OutlinePaint")) {

      attemptOutlinePaintSelection();

    }

    else if (command.equals("Insets")) {

      editInsets();

###
3831, attemptGridStrokeSelection, NumberAxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 210, 216
5
/**

   * Handle a grid stroke selection.

   */
12
  private void attemptGridStrokeSelection() {

    StrokeChooserPanel panel = new StrokeChooserPanel(null, availableStrokeSamples);

    int result = JOptionPane.showConfirmDialog(this, panel, "Stroke Selection",

      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {

      gridStrokeSample.setStroke(panel.getSelectedStroke());

###
3832, actionPerformed, NumberAxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 187, 204
5
/**

   * Handles actions from within the property panel.

   */
36
  public void actionPerformed(ActionEvent event) {

    String command = event.getActionCommand();

    if (command.equals("GridStroke")) {

      attemptGridStrokeSelection();

    }

    else if (command.equals("GridPaint")) {

      attemptGridPaintSelection();

    }

    else if (command.equals("AutoRangeOnOff")) {

      toggleAutoRange();

    }

    else if (command.equals("MinimumRange")) {

      validateMinimum();

    }

    else if (command.equals("MaximumRange")) {

      validateMaximum();

    }

    else super.actionPerformed(event);  // pass to the super-class for handling

###
3834, getMaximumValue, NumberAxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 180, 181
5
/**

   * Returns the current setting of the maximum value in the axis range.

   */
4
  public double getMaximumValue() {

    return maximumValue;

###
3835, NumberAxisPropertyEditPanel, NumberAxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 89, 159
5
/**

   * Standard constructor: builds a property panel for the specified axis.

   */
112
  public NumberAxisPropertyEditPanel(NumberAxis axis) {

    super(axis);

    autoRange = axis.isAutoRange();

    minimumValue = axis.getMinimumAxisValue();

    maximumValue = axis.getMaximumAxisValue();

    gridPaintSample = new PaintSample(axis.getGridPaint());

    gridStrokeSample = new StrokeSample(axis.getGridStroke());

    availableStrokeSamples = new StrokeSample[3];

    availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));

    availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));

    availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));

    JTabbedPane other = getOtherTabs();

    JPanel range = new JPanel(new LCBLayout(3));

    range.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));

    range.add(new JPanel());

    autoRangeCheckBox = new JCheckBox("Auto-adjust range:", autoRange);

    autoRangeCheckBox.setActionCommand("AutoRangeOnOff");

    autoRangeCheckBox.addActionListener(this);

    range.add(autoRangeCheckBox);

    range.add(new JPanel());

    range.add(new JLabel("Minimum range value:"));

    minimumRangeValue = new JTextField(Double.toString(minimumValue));

    minimumRangeValue.setEnabled(!autoRange);

    minimumRangeValue.setActionCommand("MinimumRange");

    minimumRangeValue.addActionListener(this);

    minimumRangeValue.addFocusListener(this);

    range.add(minimumRangeValue);

    range.add(new JPanel());

    range.add(new JLabel("Maximum range value:"));

    maximumRangeValue = new JTextField(Double.toString(maximumValue));

    maximumRangeValue.setEnabled(!autoRange);

    maximumRangeValue.setActionCommand("MaximumRange");

    maximumRangeValue.addActionListener(this);

    maximumRangeValue.addFocusListener(this);

    range.add(maximumRangeValue);

    range.add(new JPanel());

    other.add("Range", range);

    JPanel grid = new JPanel(new LCBLayout(3));

    grid.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));

    grid.add(new JPanel());

    showGridLinesCheckBox = new JCheckBox("Show grid lines", axis.isGridLinesVisible());

    grid.add(showGridLinesCheckBox);

    grid.add(new JPanel());

    grid.add(new JLabel("Grid stroke:"));

    JButton button = new JButton("Set stroke...");

    button.setActionCommand("GridStroke");

    button.addActionListener(this);

    grid.add(gridStrokeSample);

    grid.add(button);

    grid.add(new JLabel("Grid paint:"));

    button = new JButton("Set paint...");

    button.setActionCommand("GridPaint");

    button.addActionListener(this);

    grid.add(gridPaintSample);

    grid.add(button);

    other.add("Grid", grid);

###
3837, getMinimumValue, NumberAxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 173, 174
5
/**

   * Returns the current setting of the minimum value in the axis range.

   */
4
  public double getMinimumValue() {

    return minimumValue;

###
3839, attemptGridPaintSelection, NumberAxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 223, 227
5
/**

   * Handle a grid paint selection.

   */
10
  private void attemptGridPaintSelection() {

    Color c;

    c = JColorChooser.showDialog(this, "Grid Color", Color.blue);

    if (c!=null) {

      gridPaintSample.setPaint(c);

###
3840, isAutoRange, NumberAxisPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/NumberAxisPropertyEditPanel.java, 166, 167
5
/**

   * Returns the current setting of the auto-range property.

   */
4
  public boolean isAutoRange() {

    return autoRange;

###
3843, actionPerformed, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 173, 188
5
/**

   * Handles user interactions with the panel.

   */
32
  public void actionPerformed(ActionEvent event) {

    String command = event.getActionCommand();

    if (command.equals("OutlineStroke")) {

      attemptModifyOutlineStroke();

    }

    else if (command.equals("OutlinePaint")) {

      attemptModifyOutlinePaint();

    }

    else if (command.equals("BackgroundPaint")) {

      attemptModifyBackgroundPaint();

    }

    else if (command.equals("SeriesFont")) {

      attemptModifySeriesFont();

    }

    else if (command.equals("SeriesPaint")) {

      attemptModifySeriesPaint();

###
3844, attemptModifySeriesPaint, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 246, 250
5
/**

   * Allows the user the opportunity to change the series label paint.

   */
10
  private void attemptModifySeriesPaint() {

    Color c;

    c = JColorChooser.showDialog(this, "Series Label Color", Color.blue);

    if (c!=null) {

      seriesPaint.setPaint(c);

###
3845, attemptModifySeriesFont, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 230, 237
5
/**

   * Allows the user the opportunity to change the series label font.

   */
12
  public void attemptModifySeriesFont() {

    FontChooserPanel panel = new FontChooserPanel(seriesFont);

    int result = JOptionPane.showConfirmDialog(this, panel, "Font Selection",

      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {

      seriesFont = panel.getSelectedFont();

###
3846, attemptModifyBackgroundPaint, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 219, 223
5
/**

   * Allows the user the opportunity to change the background paint.

   */
10
  private void attemptModifyBackgroundPaint() {

    Color c;

    c = JColorChooser.showDialog(this, "Background Color", Color.blue);

    if (c!=null) {

      backgroundPaint.setPaint(c);

###
3847, getSeriesPaint, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 166, 167
5
/**

   * Returns the current series label paint.

   */
4
  public Paint getSeriesPaint() {

    return seriesPaint.getPaint();

###
3848, getOutlinePaint, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 145, 146
5
/**

   * Returns the current outline paint.

   */
4
  public Paint getOutlinePaint() {

    return outlinePaint.getPaint();

###
3849, LegendPropertyEditPanel, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 71, 132
5
/**

   * Standard constructor: builds a panel based on the specified legend.

   */
102
  public LegendPropertyEditPanel(Legend legend) {

    StandardLegend l = (StandardLegend)legend;

    outlineStroke = new StrokeSample(l.getOutlineStroke());

    outlinePaint = new PaintSample(l.getOutlinePaint());

    backgroundPaint = new PaintSample(l.getBackgroundPaint());

    seriesFont = l.getSeriesFont();

    seriesPaint = new PaintSample(l.getSeriesPaint());

    availableStrokeSamples = new StrokeSample[4];

    availableStrokeSamples[0] = new StrokeSample(new BasicStroke(1.0f));

    availableStrokeSamples[1] = new StrokeSample(new BasicStroke(2.0f));

    availableStrokeSamples[2] = new StrokeSample(new BasicStroke(3.0f));

    availableStrokeSamples[3] = new StrokeSample(new BasicStroke(4.0f));

    setLayout(new BorderLayout());

    JPanel general = new JPanel(new BorderLayout());

    general.setBorder(BorderFactory.createTitledBorder(

                BorderFactory.createEtchedBorder(), "General:"));

    JPanel interior = new JPanel(new LCBLayout(5));

    interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    JLabel titleLabel = new JLabel("Text:");

    interior.add(new JLabel("Outline:"));

    interior.add(outlineStroke);

    JButton button = new JButton("Select...");

    button.setActionCommand("OutlineStroke");

    button.addActionListener(this);

    interior.add(button);

    interior.add(new JLabel("Outline Paint:"));

    button = new JButton("Select...");

    button.setActionCommand("OutlinePaint");

    button.addActionListener(this);

    interior.add(outlinePaint);

    interior.add(button);

    interior.add(new JLabel("Background:"));

    button = new JButton("Select...");

    button.setActionCommand("BackgroundPaint");

    button.addActionListener(this);

    interior.add(backgroundPaint);

    interior.add(button);

    interior.add(new JLabel("Series label font:"));

    button = new JButton("Select...");

    button.setActionCommand("SeriesFont");

    button.addActionListener(this);

    interior.add(new FontDisplayField(seriesFont));

    interior.add(button);

    interior.add(new JLabel("Series label paint:")) ;

    button = new JButton("Select...");

    button.setActionCommand("SeriesPaint");

    button.addActionListener(this);

    interior.add(seriesPaint) ;

    interior.add(button) ;

    general.add(interior);

    add(general, BorderLayout.NORTH);

###
3850, attemptModifyOutlinePaint, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 208, 212
5
/**

   * Allows the user the opportunity to change the outline paint.

   */
10
  private void attemptModifyOutlinePaint() {

    Color c;

    c = JColorChooser.showDialog(this, "Outline Color", Color.blue);

    if (c!=null) {

      outlinePaint.setPaint(c);

###
3851, getBackgroundPaint, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 152, 153
5
/**

   * Returns the current background paint.

   */
4
  public Paint getBackgroundPaint() {

    return backgroundPaint.getPaint();

###
3852, getOutlineStroke, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 138, 139
5
/**

   * Returns the current outline stroke.

   */
4
  public Stroke getOutlineStroke() {

    return outlineStroke.getStroke();

###
3853, getSeriesFont, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 159, 160
5
/**

   * Returns the current series label font.

   */
4
  public Font getSeriesFont() {

    return seriesFont;

###
3854, setLegendProperties, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 257, 264
5
/**

   * Sets the properties of the specified legend to match the properties defined on this panel.

   */
16
  public void setLegendProperties(Legend legend) {

    if (legend instanceof StandardLegend) {  // only supports StandardLegend at present

      StandardLegend standard = (StandardLegend)legend;

      standard.setOutlineStroke(this.getOutlineStroke());

      standard.setOutlinePaint(this.getOutlinePaint());

      standard.setBackgroundPaint(this.getBackgroundPaint());

      standard.setSeriesFont(this.getSeriesFont());

      standard.setSeriesPaint(this.getSeriesPaint());

###
3855, attemptModifyOutlineStroke, LegendPropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/LegendPropertyEditPanel.java, 195, 201
5
/**

   * Allows the user the opportunity to change the outline stroke.

   */
12
  private void attemptModifyOutlineStroke() {

    StrokeChooserPanel panel = new StrokeChooserPanel(outlineStroke, availableStrokeSamples);

    int result = JOptionPane.showConfirmDialog(this, panel, "Pen/Stroke Selection",

      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {

      outlineStroke.setStroke(panel.getSelectedStroke());

###
3856, setTitleProperties, TitlePropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 176, 181
5
/**

   * Sets the properties of the specified title to match the properties defined on this panel.

   */
12
  public void setTitleProperties(Title title) {

    if (title instanceof StandardTitle) {  // only supports StandardTitle at present

      StandardTitle standard = (StandardTitle)title;

      standard.setTitle(this.getTitle());

      standard.setTitleFont(this.getTitleFont());

      standard.setTitlePaint(this.getTitlePaint());

###
3857, attemptPaintSelection, TitlePropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 166, 169
9
/**

   * Allow the user the opportunity to select a Paint object.  For now, we just use the

   * standard color chooser - all colors are Paint objects, but not all Paint objects are

   * colors (later we can implement a more general Paint chooser).

   */
8
  public void attemptPaintSelection() {

    Color c = JColorChooser.showDialog(this, "Title Color", Color.blue);

    if (c!=null) {

      titlePaint.setPaint(c);

###
3858, attemptFontSelection, TitlePropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 148, 156
5
/**

   * Presents a font selection dialog to the user.

   */
14
  public void attemptFontSelection() {

    FontChooserPanel panel = new FontChooserPanel(titleFont);

    int result = JOptionPane.showConfirmDialog(this, panel, "Font Selection",

      JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

    if (result==JOptionPane.OK_OPTION) {

      titleFont = panel.getSelectedFont();

      fontfield.setText(titleFont.getFontName()+" "+titleFont.getSize());

###
3859, TitlePropertyEditPanel, TitlePropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 66, 105
7
/**

   * Standard constructor: builds a panel for displaying/editing the properties of the specified

   * title.

   */
62
  public TitlePropertyEditPanel(StandardTitle title) {

    // initialise local selections

    titleFont = title.getTitleFont();

    titlePaint = new PaintSample(title.getTitlePaint());

    setLayout(new BorderLayout());

    JPanel general = new JPanel(new BorderLayout());

    general.setBorder(BorderFactory.createTitledBorder(

              BorderFactory.createEtchedBorder(), "General:"));

    JPanel interior = new JPanel(new LCBLayout(3));

    interior.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

    JLabel titleLabel = new JLabel("Text:");

    titleField = new JTextField(title.getTitle());

    interior.add(titleLabel);

    interior.add(titleField);

    interior.add(new JPanel());

    interior.add(new JLabel("Font:"));

    fontfield = new FontDisplayField(titleFont);

    JButton b = new JButton("Select...");

    b.setActionCommand("SelectFont");

    b.addActionListener(this);

    interior.add(fontfield);

    interior.add(b);

    interior.add(new JLabel("Color:"));

    titlePaint = new PaintSample(title.getTitlePaint());

    b = new JButton("Select...");

    b.setActionCommand("SelectPaint");

    b.addActionListener(this);

    interior.add(titlePaint);

    interior.add(b);

    general.add(interior);

    add(general, BorderLayout.NORTH);

###
3860, getTitle, TitlePropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 111, 112
5
/**

   * Returns the title entered in the panel.

   */
4
  public String getTitle() {

    return titleField.getText();

###
3861, getTitleFont, TitlePropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 118, 119
5
/**

   * Returns the font selected in the panel.

   */
4
  public Font getTitleFont() {

    return titleFont;

###
3862, getTitlePaint, TitlePropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 125, 126
5
/**

   * Returns the paint selected in the panel.

   */
4
  public Paint getTitlePaint() {

    return titlePaint.getPaint();

###
3863, actionPerformed, TitlePropertyEditPanel, JFreeChart071
jfreechart-0.7.1/source/com/jrefinery/chart/ui/TitlePropertyEditPanel.java, 132, 140
5
/**

   * Handles button clicks by passing control to an appropriate handler method.

   */
14
  public void actionPerformed(ActionEvent event) {

    String command = event.getActionCommand();

    if (command.equals("SelectFont")) {

      attemptFontSelection();

    }

    else if (command.equals("SelectPaint")) {

      attemptPaintSelection();

###
