#end
#end
#No. 182249
#File: E:\bishe\1\VMFilterOptions.java
#Comment:
    /**
     * Matches a virtual machine against the criteria in this set of filter options.
     *
     * @param vm the virtual machine to test
     * @return true if the VM matches all criteria
     */

#Code:
    public boolean matches( @Nonnull VirtualMachine vm ) {
        if( regex != null ) {
            boolean matches = ( vm.getName().matches(regex) || vm.getDescription().matches(regex) );

            if( !matches ) {
                for( Map.Entry<String, String> tag : vm.getTags().entrySet() ) {
                    String value = tag.getValue();

                    if( value != null && value.matches(regex) ) {
                        matches = true;
                        break;
                    }
                }
            }
            if( !matches && !matchesAny ) {
                return false;
            }
            else if( matches && matchesAny ) {
                return true;
            }
        }

#end
#end
#No. 182250
#File: E:\bishe\1\VmImage.java
#Comment:
   /**
    * Created dummy setters so Json deserialization does not fail.
    * Marking them protected to reduce visibility and avoid IDE warnings.
    * @param dummy
    */

#Code:
   @JsonIgnore
   protected void setPercent(int dummy) {
      // Adding this so jackson deserialization ignores it.
   }

#end
#end
#No. 182251
#File: E:\bishe\1\VmImage.java
#Comment:
   /**
    * @return the lastError
    */

#Code:
   public String getLastError() {
      return lastError;
   }

#end
#end
#No. 182252
#File: E:\bishe\1\VmImage.java
#Comment:
   /**
    * @param lastError the lastError to set
    */

#Code:
   public void setLastError(String lastError) {
      this.lastError = lastError;
   }

#end
#end
#No. 182253
#File: E:\bishe\1\VMImageDao.java
#Comment:
    /**
     * 
     * @param info
     * @param region
     * @return
     */

#Code:
    @Nonnull
    public VMInstance addImageFromInfo(String jobId, @Nonnull VMInformation info, @Nonnull VMRegion region) {
        // persist the VMImages to database:
        VMInstance image = VMInstance.builder()
                .amiId(info.getImageId())
                .instanceId(info.getInstanceId())
                .startTime(info.getLaunchTime() != null ? info.getLaunchTime().getTime() : new Date())
                .status(info.getState())
                .size(info.getSize())
                .region(region)
                .jobId(jobId)
                .build();
        return saveOrUpdate(image);
    }

}
}

#end
#end
#No. 182254
#File: E:\bishe\1\VMImageType.java
#Comment:
    /**
     * @param configName
     */

#Code:
    private VMImageType(String configName) {
        this.configName = configName;
    }

#end
#end
#No. 182255
#File: E:\bishe\1\VMImageType.java
#Comment:
    /**
     * @return the configName
     */

#Code:
    public String getConfigName() {
        return configName;
    }

#end
#end
#No. 182256
#File: E:\bishe\1\VMInfo.java
#Comment:
    /**
     * @return null or vmInfo. null is something error, job no care it.
     */

#Code:
    public static VMInfo getVmInfo() {
        if (vmInfo == null) {
            synchronized (lock) {
                if (vmInfo == null) {
                    try {
                        vmInfo = new VMInfo();
                    } catch (Exception e) {
                        LOG.warn("no need care, the fail is ignored : vmInfo init failed " + e.getMessage(), e);
                    }
                }
            }

        }
        return vmInfo;
    }

#end
#end
#No. 182258
#File: E:\bishe\1\VMInformation.java
#Comment:
    /**
     * Set the virtual machine provider
     * 
     * @param data
     *            The virtual machine provider
     */

#Code:
    public void setProvider(VMProvider data) {
        this.items.put("provider", data);
    }

#end
#end
#No. 182259
#File: E:\bishe\1\VMInformation.java
#Comment:
    /**
     * Get the virtual machine provider
     * 
     * @return The virtual machine provider
     */

#Code:
    public VMProvider getProvider() {
        return (VMProvider) this.items.get("provider");
    }

#end
#end
#No. 182260
#File: E:\bishe\1\VMInformation.java
#Comment:
    /**
     * Set the virtual machine public URL
     * 
     * @param data
     *            The virtual machine's public URL
     */

#Code:
    public void setPublicDNS(String data) {
        this.items.put("publicDns", data);
    }

#end
#end
#No. 182261
#File: E:\bishe\1\VMInformation.java
#Comment:
    /**
     * Get the virtual machine public URL
     * 
     * @return The virtual machine's public URL
     */

#Code:
    public String getPublicDNS() {
        return (String) this.items.get("publicDns");
    }

#end
#end
#No. 182262
#File: E:\bishe\1\VMInformation.java
#Comment:
    /**
     * Set the virtual machine private DNS
     * 
     * @param data
     *            The virtual machine's private DNS
     */

#Code:
    public void setPrivateDNS(String data) {
        this.items.put("privateDns", data);
    }

#end
#end
#No. 182263
#File: E:\bishe\1\VMInformation.java
#Comment:
    /**
     * Get the virtual machine private DNS
     * 
     * @return The virtual machine's private DNS
     */

#Code:
    public String getPrivateDNS() {
        return (String) this.items.get("privateDns");
    }

#end
#end
#No. 182264
#File: E:\bishe\1\VMInformation.java
#Comment:
    /**
     * @{inheritDoc
     */

#Code:
    @Override
    public String toString() {
        return ToStringBuilder.reflectionToString(this);
    }


#end
#end
#No. 182267
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * 
     * @param useEips
     */

#Code:
    public void setUserEips(boolean useEips) {
        this.items.put(TankConstants.KEY_USE_EIPS, useEips);
    }

#end
#end
#No. 182268
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public boolean isUseEips() {
        if (this.items.get(TankConstants.KEY_USE_EIPS) != null) {
            return (Boolean) this.items.get(TankConstants.KEY_USE_EIPS);
        }
        return new TankConfig().getVmManagerConfig().isUseElasticIps();
    }

#end
#end
#No. 182269
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * @param ami
     */

#Code:
    public void setInstanceDescription(InstanceDescription description) {
        this.items.put(TankConstants.KEY_DESCRIPTION, description);
    }

#end
#end
#No. 182270
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * @param ami
     */

#Code:
    public void setSubnetId(String subnetId) {
        this.items.put(TankConstants.KEY_SUBNET_ID, subnetId);
    }

#end
#end
#No. 182271
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * @param reuseStoppedInstances
     */

#Code:
    public void setReuseStoppedInstance(boolean reuseStoppedInstances) {
        this.items.put(TankConstants.KEY_REUSE_STOPPED_INSTANCE, reuseStoppedInstances);
    }

#end
#end
#No. 182272
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public boolean getReuseStoppedInstance() {
        Boolean result = (Boolean) this.items.get(TankConstants.KEY_REUSE_STOPPED_INSTANCE);
        return result != null ? result : false;
    }

#end
#end
#No. 182273
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * @param reuseStoppedInstances
     */

#Code:
    public void setZone(String zone) {
        this.items.put(TankConstants.KEY_ZONE, zone);
    }

#end
#end
#No. 182274
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public String getZone() {
        return (String) this.items.get(TankConstants.KEY_ZONE);
    }

#end
#end
#No. 182275
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public Set<String> getAssociatedIps() {
        @SuppressWarnings("unchecked") Set<String> ips = (Set<String>) this.items.get(TankConstants.KEY_IPS);
        if (ips == null) {
            ips = new HashSet<String>();
            this.items.put(TankConstants.KEY_IPS, ips);
        }
        return ips;
    }

#end
#end
#No. 182276
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * 
     * @param ipAddress
     */

#Code:
    public void addAssociatedIp(String ipAddress) {
        getAssociatedIps().add(ipAddress);
    }

#end
#end
#No. 182277
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * @param hashMap
     */

#Code:
    public Map<String, String> getUserData() {
        @SuppressWarnings("unchecked") HashMap<String, String> userDataMap = (HashMap<String, String>) this.items
                .get("userData");
        if (userDataMap == null) {
            userDataMap = new HashMap<String, String>();
            this.items.put("userData", userDataMap);
        }
        return userDataMap;
    }



#end
#end
#No. 182279
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Get the job id
     * 
     * @return The job id
     */

#Code:
    public String getJobId() {
        return (String) this.items.get(TankConstants.KEY_JOB_ID);
    }

#end
#end
#No. 182280
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Set the job id
     * 
     * @param data
     *            The job id
     */

#Code:
    public void setLoggingProfile(String data) {
        this.items.put(TankConstants.KEY_LOGGING_PROFILE, data);
    }

#end
#end
#No. 182281
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Get the job id
     * 
     * @return The job id
     */

#Code:
    public String getLoggingProfile() {
        return (String) this.items.get(TankConstants.KEY_LOGGING_PROFILE);
    }

#end
#end
#No. 182282
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Set the job id
     * 
     * @param data
     *            The job id
     */

#Code:
    public void setStopBehavior(String data) {
        this.items.put(TankConstants.KEY_STOP_BEHAVIOR, data);
    }

#end
#end
#No. 182283
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Get the job id
     * 
     * @return The job id
     */

#Code:
    public String getStopBehavior() {
        return (String) this.items.get(TankConstants.KEY_STOP_BEHAVIOR);
    }

#end
#end
#No. 182284
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Set the virtual machine region
     * 
     * @param data
     *            The virtual machine region
     */

#Code:
    public void setRegion(VMRegion data) {
        this.items.put(TankConstants.KEY_REGION, data);
    }

#end
#end
#No. 182285
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Get the virtual machine region
     * 
     * @return The virtual machine region
     */

#Code:
    public VMRegion getRegion() {
        return (VMRegion) this.items.get(TankConstants.KEY_REGION);
    }

#end
#end
#No. 182286
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Set the virtual machine size
     * 
     * @param data
     *            The virtual machine size
     */

#Code:
    public void setSize(String data) {
        this.items.put(TankConstants.KEY_SIZE, data);
    }

#end
#end
#No. 182287
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Get the virtual machine size
     * 
     * @return The virtual machine size
     */

#Code:
    public String getSize() {
        return (String) this.items.get(TankConstants.KEY_SIZE);
    }

#end
#end
#No. 182288
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public int getNumUsersPerAgent() {
        if (!this.items.containsKey(TankConstants.KEY_NUM_USERS_PER_AGENT)) {
            return 0;
        }
        return (Integer) this.items.get(TankConstants.KEY_NUM_USERS_PER_AGENT);
    }

#end
#end
#No. 182289
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * 
     * @param data
     */

#Code:
    public void setNumUsersPerAgent(int data) {
        this.items.put(TankConstants.KEY_NUM_USERS_PER_AGENT, data);
    }

#end
#end
#No. 182290
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Set the image type
     * 
     * @param data
     *            The image type
     */

#Code:
    public void setImage(VMImageType data) {
        this.items.put(TankConstants.KEY_IMAGE, data);
    }

#end
#end
#No. 182291
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Get the image type
     * 
     * @return The image type
     */

#Code:
    public VMImageType getImage() {
        return (VMImageType) this.items.get(TankConstants.KEY_IMAGE);
    }

#end
#end
#No. 182292
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Set the number of instances requested
     * 
     * @param data
     *            The number of instances requested
     */

#Code:
    public void setNumberOfInstances(int data) {
        this.items.put(TankConstants.KEY_NUMBER_OF_INSTANCES, Integer.toString(data));
    }

#end
#end
#No. 182293
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * Get the number of instances requested
     * 
     * @return The number of instances requested
     */

#Code:
    public int getNumberOfInstances() {
        if (!this.items.containsKey(TankConstants.KEY_NUMBER_OF_INSTANCES)) {
            return -1;
        }
        return Integer.valueOf((String) this.items.get(TankConstants.KEY_NUMBER_OF_INSTANCES));
    }

#end
#end
#No. 182294
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * 
     * @param reportingMode
     */

#Code:
    public void setReportingMode(String reportingMode) {
        this.items.put(TankConstants.KEY_REPORTING_MODE, reportingMode);
    }

#end
#end
#No. 182295
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public String getReportingMode() {
        return (String) this.items.get(TankConstants.KEY_REPORTING_MODE);
    }

#end
#end
#No. 182296
#File: E:\bishe\1\VMInstanceRequest.java
#Comment:
    /**
     * @{inheritDoc
     */

#Code:
    @Override
    public String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

#end
#end
#No. 182297
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
	 * 
	 */

#Code:
    private static final long serialVersionUID = -6022543863819975533L;

    public VMJobRequest(String jobId, String reportingMode, String loggingProfile, int numberOfUsers,
            VMRegion region, String stopBehavior, String vmInstanceType, int numUsersPerAgent) {
        this.items = new HashMap<String, Object>();
        this.setJobId(jobId);
        this.setReportingMode(reportingMode);
        this.setNumberOfUsers(numberOfUsers);
        this.setLoggingProfile(loggingProfile);
        this.setRegion(region);
        this.setStopBehavior(stopBehavior);
        this.setVmInstanceType(vmInstanceType);
        this.setNumUsersPerAgent(numUsersPerAgent);
    }

#end
#end
#No. 182298
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * Set the job id
     * 
     * @param data
     *            The job id
     */

#Code:
    public void setJobId(String data) {
        this.items.put(TankConstants.KEY_JOB_ID, data);
    }

#end
#end
#No. 182299
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * Get the job id
     * 
     * @return The job id
     */

#Code:
    public String getJobId() {
        return (String) this.items.get(TankConstants.KEY_JOB_ID);
    }

#end
#end
#No. 182300
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * 
     * @param useEips
     */

#Code:
    public void setUserEips(boolean useEips) {
        this.items.put(TankConstants.KEY_USE_EIPS, useEips);
    }

#end
#end
#No. 182301
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public boolean isUseEips() {
        if (this.items.get(TankConstants.KEY_USE_EIPS) != null) {
            return (Boolean) this.items.get(TankConstants.KEY_USE_EIPS);
        }
        return new TankConfig().getVmManagerConfig().isUseElasticIps();
    }

#end
#end
#No. 182302
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * Set the job id
     * 
     * @param data
     *            The job id
     */

#Code:
    public void setStopBehavior(String data) {
        this.items.put(TankConstants.KEY_STOP_BEHAVIOR, data);
    }

#end
#end
#No. 182303
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * Get the job id
     * 
     * @return The job id
     */

#Code:
    public String getStopBehavior() {
        return (String) this.items.get(TankConstants.KEY_STOP_BEHAVIOR);
    }

#end
#end
#No. 182304
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * Set the image type
     * 
     * @param data
     *            The image type
     */

#Code:
    public void setImage(VMImageType data) {
        this.items.put(TankConstants.KEY_IMAGE, data);
    }

#end
#end
#No. 182305
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * Get the image type
     * 
     * @return The image type
     */

#Code:
    public VMImageType getImage() {
        return (VMImageType) this.items.get(TankConstants.KEY_IMAGE);
    }

#end
#end
#No. 182306
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * Set the number of instances requested
     * 
     * @param data
     *            The number of instances requested
     */

#Code:
    public void setNumberOfUsers(int data) {
        this.items.put(TankConstants.KEY_NUMBER_OF_USERS, Integer.toString(data));
    }

#end
#end
#No. 182307
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * Get the number of instances requested
     * 
     * @return The number of instances requested
     */

#Code:
    public int getNumberOfUsers() {
        if (!this.items.containsKey(TankConstants.KEY_NUMBER_OF_USERS)) {
            return -1;
        }
        return Integer.valueOf((String) this.items.get(TankConstants.KEY_NUMBER_OF_USERS));
    }

#end
#end
#No. 182308
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * Set the virtual machine region
     * 
     * @param data
     *            The virtual machine region
     */

#Code:
    public void setRegion(VMRegion data) {
        this.items.put(TankConstants.KEY_REGION, data);
    }

#end
#end
#No. 182309
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * Get the virtual machine region
     * 
     * @return The virtual machine region
     */

#Code:
    public VMRegion getRegion() {
        return (VMRegion) this.items.get(TankConstants.KEY_REGION);
    }

#end
#end
#No. 182310
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * 
     * @param reportingMode
     */

#Code:
    public void setReportingMode(String reportingMode) {
        this.items.put(TankConstants.KEY_REPORTING_MODE, reportingMode);
    }

#end
#end
#No. 182311
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public String getReportingMode() {
        return (String) this.items.get(TankConstants.KEY_REPORTING_MODE);
    }

#end
#end
#No. 182312
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public String getLoggingProfile() {
        return (String) this.items.get(TankConstants.KEY_LOGGING_PROFILE);
    }

#end
#end
#No. 182313
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * 
     * @param reportingMode
     */

#Code:
    public void setLoggingProfile(String data) {
        this.items.put(TankConstants.KEY_LOGGING_PROFILE, data);
    }

#end
#end
#No. 182314
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public String getVmInstanceType() {
        return (String) this.items.get(TankConstants.KEY_VM_INSTANCE_TYPE);
    }

#end
#end
#No. 182315
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * 
     * @param reportingMode
     */

#Code:
    public void setVmInstanceType(String data) {
        this.items.put(TankConstants.KEY_VM_INSTANCE_TYPE, data);
    }

#end
#end
#No. 182316
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public int getNumUsersPerAgent() {
        if (!this.items.containsKey(TankConstants.KEY_NUM_USERS_PER_AGENT)) {
            return 0;
        }
        return (Integer) this.items.get(TankConstants.KEY_NUM_USERS_PER_AGENT);
    }

#end
#end
#No. 182317
#File: E:\bishe\1\VMJobRequest.java
#Comment:
    /**
     * 
     * @param reportingMode
     */

#Code:
    public void setNumUsersPerAgent(int data) {
        this.items.put(TankConstants.KEY_NUM_USERS_PER_AGENT, data);
    }


#end
#end
#No. 182319
#File: E:\bishe\1\VMKillRequest.java
#Comment:
    /**
     * Constructor
     * 
     * @param provider
     *            The virtual machine environment
     * @param region
     *            The region for the virtual machine
     * @param size
     *            The size of the virtual machine
     */

#Code:
    public VMKillRequest(VMProvider provider, String instanceId) {
        super(provider);
        List<String> instances = new ArrayList<String>();
        instances.add(instanceId);
        this.setInstances(instances);
    }

#end
#end
#No. 182320
#File: E:\bishe\1\VMKillRequest.java
#Comment:
    /**
     * Constructor
     * 
     * @param provider
     *            The virtual provider
     * @param instanceIds
     *            A list of instance ids
     */

#Code:
    public VMKillRequest(VMProvider provider, List<String> instanceIds) {
        super(provider);
        this.setInstances(instanceIds);
    }

#end
#end
#No. 182321
#File: E:\bishe\1\VMKillRequest.java
#Comment:
    /**
     * Set the list of instance ids
     * 
     * @param data
     *            A list of instance ids
     */

#Code:
    public void setInstances(List<String> data) {
        this.items.put("instances", data);
    }

#end
#end
#No. 182322
#File: E:\bishe\1\VMKillRequest.java
#Comment:
    /**
     * Get the list of instance ids
     * 
     * @return The list of instance ids
     */

#Code:
    @SuppressWarnings("unchecked")
    public List<String> getInstances() {
        return (List<String>) this.items.get("instances");
    }

#end
#end
#No. 182323
#File: E:\bishe\1\VMLauncher.java
#Comment:
    /**
     * Create a VMStarter that uses the given options and main class to launch
     * a process for debugging.  By default, this initializes a shutdown hook
     * that attempts to kill the created VM when the debugging VM dies.
     * To override this behavior, use the alternate constructor.
     *
     * @param options
     * @param main
     */

#Code:
    public VMLauncher(String options, String main) {
        this(options, main, true, System.out, System.err);
    }

#end
#end
#No. 182324
#File: E:\bishe\1\VMLauncher.java
#Comment:
    /**
     * Alternate constructor giving control over the initialization of a
     * shutdown hook that attempts to kill the created VM when the debugging
     * VM dies.
     *
     * @param options
     * @param main
     * @param killOnShutdown
     */

#Code:
    public VMLauncher(String options, String main, boolean killOnShutdown,
                      OutputStream out, OutputStream err)
    {
        this.options = options;
        this.main = main;
        this.killOnShutdown = killOnShutdown;
        this.out = out;
        this.err = err;
    }

#end
#end
#No. 182325
#File: E:\bishe\1\VMLauncher.java
#Comment:
    /**
     * safeStart wrapped to throw RuntimeException.
     */

#Code:
    public VirtualMachine start() {
        try {
            return safeStart();
        } catch(Exception e) {
            throw new RuntimeException(e);
        }
    }

#end
#end
#No. 182326
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * Launches a virtual machine based on the current contents of this set of VM launch options.
     * @param provider the cloud provider in which the VM should be provisioned
     * @return the unique ID of the provisioned virtual machine
     * @throws CloudException an error occurred within the cloud provider while building the VM
     * @throws InternalException an error occurred within Dasein Cloud in preparing the API call
     * @throws OperationNotSupportedException the cloud does not support virtual machines
     */

#Code:
    public @Nonnull String build(@Nonnull CloudProvider provider) throws CloudException, InternalException {
        ComputeServices services = provider.getComputeServices();

        if( services == null ) {
            throw new OperationNotSupportedException(provider.getCloudName() + " does not support compute services.");
        }

#end
#end
#No. 182327
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * Launches multiple virtual machines based on the current contents of this set of launch options. The method is a success
     * if any one virtual machine is provisioned even if any errors occurred provisioning others.
     * @param provider the cloud provider in which the VM should be provisioned
     * @param count the number of virtual machines to provision
     * @return the IDs of the virtual machines that were provisioned
     * @throws CloudException an error occurred within the cloud provider that prevented the provisioning of any VMs
     * @throws InternalException an error occurred within Dasein Cloud in preparing the API call (can happen even if a VM gets provisioned)
     * @throws OperationNotSupportedException the cloud does not support virtual machines
     */

#Code:
    public @Nonnull Iterable<String> buildMany(@Nonnull CloudProvider provider, int count) throws CloudException, InternalException {
        ComputeServices services = provider.getComputeServices();

        if( services == null ) {
            throw new OperationNotSupportedException(provider.getCloudName() + " does not support compute services.");
        }

#end
#end
#No. 182328
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * Copies the meaningful aspects of this set of VM launch options to be used in a second set of VM launch options. The only
     * things NOT copied are attributes that are inherently instance specific such as IP address, volume attachments,
     * private IP, and NICs. Any volumes and/or NICs to be created, however, are preserved.
     * @param havingHostName a host name special for this new set of VM create options
     * @param havingFriendlyName a friendly name special for this new set of VM create options
     * @return a copy of this set of VM launch options minus any instance-specific elements
     */

#Code:
    public @Nonnull VMLaunchOptions copy(@Nonnull String havingHostName, @Nonnull String havingFriendlyName) {
        VMLaunchOptions options = new VMLaunchOptions(standardProductId, machineImageId, havingHostName, havingFriendlyName, description);

        options.bootstrapKey = bootstrapKey;
        options.bootstrapPassword = bootstrapPassword;
        options.bootstrapUser = bootstrapUser;
        options.dataCenterId = dataCenterId;
        options.extendedAnalytics = extendedAnalytics;
        options.firewallIds = (firewallIds == null ? new String[0] : Arrays.copyOf(options.firewallIds, options.firewallIds.length));
        options.ioOptimized = ioOptimized;
        options.ipForwardingAllowed = ipForwardingAllowed;
        options.kernelId = kernelId;
        options.virtualMachineGroup = virtualMachineGroup;
        options.resourcePoolId = resourcePoolId;
        if( metaData != null ) {
            options.metaData = new HashMap<String, Object>();
            options.metaData.putAll(metaData);
        }


#end
#end
#No. 182331
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * @return all configuration data for networking interfaces to which the VM will be attached
     */

#Code:
    public NICConfig[] getNetworkInterfaces() {
        return networkInterfaces;
    }

#end
#end
#No. 182332
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * @return the provider ID of the ramdisk image to use in launching the virtual machine
     */

#Code:
    public String getRamdiskId() {
        return ramdiskId;
    }

#end
#end
#No. 182333
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * @return the resource pool id to use in launching the vm
     */

#Code:
    public String getResourcePoolId() {
        return resourcePoolId;
    }

#end
#end
#No. 182335
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * Indicates which firewalls this configuration will support. This call adds to any configured firewall IDs.
     * You can therefore call it multiple times if it makes sense to your code logic.
     * @param firewallIds one or more firewall IDs to protect the new VM
     * @return this
     */

#Code:
    public @Nonnull VMLaunchOptions behindFirewalls(@Nonnull String ... firewallIds) {
        if( this.firewallIds == null || this.firewallIds.length < 1 ) {
            this.firewallIds = firewallIds;
        }

#end
#end
#No. 182336
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * Specifies any labels to be added to the virtual machine at launch time
     * @param labels one or more labels to be added to new VM
     * @return this
     */

#Code:
    public @Nonnull VMLaunchOptions withLabels(String... labels) {
        if (labels != null) {
            this.labels = Arrays.copyOf(labels, labels.length);
        }

#end
#end
#No. 182337
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * Identifies which volumes which will be attached to this virtual machine post-launch. 
     * These are all volumes that will be created. The order of the volumes matters. This call is
     * accretive, meaning you can call it again to add more attachments.
     * @param toBeCreated the options to be used in creating new volumes
     * @return this
     */

#Code:
    public @Nonnull VMLaunchOptions withAttachments(@Nonnull VolumeCreateOptions ... toBeCreated) {
        int i = 0;
        
        if( volumes != null && volumes.length > 0 ) {
            VolumeAttachment[] tmp = new VolumeAttachment[volumes.length + toBeCreated.length];
            
            for( VolumeAttachment a : volumes ) {
                tmp[i++] = a;
            }
            volumes = tmp;
        }

#end
#end
#No. 182338
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * Identifies a specific, existing volume to attach post-launch. This call is accretive, meaning that you can
     * call it multiple times to add additional volumes (order matters)
     * @param existingVolumeId the cloud provider volume ID for the volume to attach
     * @param withDeviceId the device ID to use in making the attachment
     * @return this
     */

#Code:
    public @Nonnull VMLaunchOptions withAttachment(@Nonnull String existingVolumeId, @Nonnull String withDeviceId) {
        VolumeAttachment a = new VolumeAttachment();
        
        a.deviceId = withDeviceId;
        a.existingVolumeId = existingVolumeId;
        if( volumes == null || volumes.length < 1 ) {
            volumes = new VolumeAttachment[] { a };
        }

#end
#end
#No. 182339
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * Specifies meta-data to add onto any existing meta-data being associated with this virtual machine at launch time.
     * This method is accretive, meaning that it adds to any existing meta-data (or replaces an existing keys).
     * Though Dasein Cloud allows the ability to retain type in meta-data, the reality is that most clouds will convert
     * values to strings.
     * @param metaData the meta-data to be set for the new VM
     * @return this
     */

#Code:
    public @Nonnull VMLaunchOptions withMetaData(@Nonnull Map<String,Object> metaData) {
        if( this.metaData == null ) {
            this.metaData = new HashMap<String, Object>();
        }

#end
#end
#No. 182340
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * Indicates the network interfaces to be attached to this virtual machine at launch time. This method is accretive,
     * meaning it will add to any existing network interface configurations.
     * @param nicIds the unique cloud provider IDs for the network interfaces to be attached
     * @return this
     */

#Code:
    public @Nonnull VMLaunchOptions withNetworkInterfaces(String ... nicIds) {
        if( networkInterfaces == null || networkInterfaces.length < 1 ) {
            int i = 0;
            
            networkInterfaces = new NICConfig[nicIds.length];
            for( String id : nicIds ) {
                NICConfig cfg = new NICConfig();
                
                cfg.nicId = id;
                networkInterfaces[i++] = cfg;
            }
        }

#end
#end
#No. 182341
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * Indicates configuration options for network interfaces to be created and added onto the virtual machine
     * when it is launched. This method is accretive, meaning it will add to any existing network interface configurations.
     * @param options the options for creating the new network interfaces
     * @return this
     */

#Code:
    public @Nonnull VMLaunchOptions withNetworkInterfaces(NICCreateOptions ... options) {
        if( networkInterfaces == null || networkInterfaces.length < 1 ) {
            int i = 0;

            networkInterfaces = new NICConfig[options.length];
            for( NICCreateOptions opt : options ) {
                NICConfig cfg = new NICConfig();

                cfg.nicToCreate = opt;
                networkInterfaces[i++] = cfg;
            }
        }



#end
#end
#No. 182344
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * @see #withAssociatePublicIpAddress(Boolean)
     */

#Code:
    public Boolean isAssociatePublicIpAddress() {
      return associatePublicIpAddress;
    }

#end
#end
#No. 182345
#File: E:\bishe\1\VMLaunchOptions.java
#Comment:
    /**
     * @see #withAffinityGroupId(String)
     */

#Code:
    public String getAffinityGroupId() {
        return affinityGroupId;
    }


#end
#end
#No. 182348
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * @return the instanceTypes
     */

#Code:
    public List<VmInstanceType> getInstanceTypes() {
        return instanceTypes;
    }

#end
#end
#No. 182349
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * @param instanceTypes
     *            the instanceTypes to set
     */

#Code:
    public void setInstanceTypes(List<VmInstanceType> instanceTypes) {
        this.instanceTypes = instanceTypes;
    }

#end
#end
#No. 182350
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    @Nonnull
    public Set<String> getReservedElasticIps() {
        return reservedElasticIps;
    }


#end
#end
#No. 182352
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * 
     * @param name
     * @return
     */

#Code:
    public VmInstanceType getInstanceType(String name) {
        VmInstanceType ret = null;
        for (VmInstanceType type : instanceTypes) {
            if (type.getName().equalsIgnoreCase(name)) {
                ret = type;
                break;
            }
            if (type.isDefault()) {
                ret = type;
            }
        }
        return ret;
    }

#end
#end
#No. 182353
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * 
     * @param defaultMills
     * @return
     */

#Code:
    public long getMaxAgentStartMills(long defaultMills) {
        String string = config.getString("watchdog/max-time-for-agent-start");
        if (string != null) {
            try {
                return TimeUtil.parseTimeString(string);
            } catch (Exception e) {
                LOG.error(e.toString());
            }
        }
        return defaultMills;
    }

#end
#end
#No. 182354
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * 
     * @return the provider classname. should be an instance of IDatabase
     */

#Code:
    public String getResultsProvider() {
        String string = config.getString("results/provider");
        if (string != null) {
            try {
                return string;
            } catch (Exception e) {
                LOG.error(e.toString());
            }
        }
        return "com.intuit.tank.persistence.databases.AmazonDynamoDatabaseDocApi";
    }

#end
#end
#No. 182355
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * @return the read capacity for dynamoDB tables.
     */

#Code:
    public HierarchicalConfiguration getResultsProviderConfig() {
        SubnodeConfiguration ret = config.configurationAt("results/config");

        return ret;
    }

#end
#end
#No. 182356
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * @return the write capacity for dynamoDB tables.
     */

#Code:
    public long getResultsWriteCapacity() {
        String string = config.getString("results/write-capacity");
        if (string != null) {
            try {
                return Long.parseLong(string);
            } catch (Exception e) {
                LOG.error(e.toString());
            }
        }
        return 50L;
    }

#end
#end
#No. 182357
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * 
     * @param defaultMills
     * @return
     */

#Code:
    public long getMaxAgentReportMills(long defaultMills) {
        String string = config.getString("watchdog/max-time-for-agent-report");
        if (string != null) {
            try {
                return TimeUtil.parseTimeString(string);
            } catch (Exception e) {
                LOG.error(e.toString());
            }
        }
        return defaultMills;
    }

#end
#end
#No. 182358
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * 
     * @param defaultMills
     * @return
     */

#Code:
    public long getWatchdogSleepTime(long defaultMills) {
        String string = config.getString("watchdog/sleep-time-between-check");
        if (string != null) {
            try {
                return TimeUtil.parseTimeString(string);
            } catch (Exception e) {
                LOG.error(e.toString());
            }
        }
        return defaultMills;
    }

#end
#end
#No. 182359
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * 
     * @param defaultResult
     * @return
     */

#Code:
    public boolean isUseElasticIps() {
        return config.getBoolean("use-agent-elastic-ips", false);
    }

#end
#end
#No. 182360
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * 
     * @param defaultResult
     * @return
     */

#Code:
    public int getMaxRestarts(int defaultResult) {
        return config.getInt("watchdog/max-restarts", defaultResult);
    }


#end
#end
#No. 182362
#File: E:\bishe\1\VmManagerConfig.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    public Set<VMRegion> getRegions() {
        return regionMap.keySet();
    }

#end
#end
#No. 182363
#File: E:\bishe\1\VMNodeBean.java
#Comment:
    /**
     * @{inheritDoc
     */

#Code:
    @Override
    public String getType() {
        return "vm";
    }

#end
#end
#No. 182364
#File: E:\bishe\1\VMPCEngine.java
#Comment:
    /*
     * variables to hold the state of the VMPC engine during encryption and
     * decryption
     */

#Code:
    protected byte n = 0;
    protected byte[] P = null;
    protected byte s = 0;

    protected byte[] workingIV;
    protected byte[] workingKey;

    public String getAlgorithmName()
    {
        return "VMPC";
    }

#end
#end
#No. 182365
#File: E:\bishe\1\VMPCEngine.java
#Comment:
    /**
     * initialise a VMPC cipher.
     * 
     * @param forEncryption
     *    whether or not we are for encryption.
     * @param params
     *    the parameters required to set up the cipher.
     * @exception IllegalArgumentException
     *    if the params argument is inappropriate.
     */

#Code:
    public void init(boolean forEncryption, CipherParameters params)
    {
        if (!(params instanceof ParametersWithIV))
        {
            throw new IllegalArgumentException(
                "VMPC init parameters must include an IV");
        }

        ParametersWithIV ivParams = (ParametersWithIV) params;
        KeyParameter key = (KeyParameter) ivParams.getParameters();

        if (!(ivParams.getParameters() instanceof KeyParameter))
        {
            throw new IllegalArgumentException(
                "VMPC init parameters must include a key");
        }

        this.workingIV = ivParams.getIV();

        if (workingIV == null || workingIV.length < 1 || workingIV.length > 768)
        {
            throw new IllegalArgumentException("VMPC requires 1 to 768 bytes of IV");
        }

        this.workingKey = key.getKey();

        initKey(this.workingKey, this.workingIV);
    }

#end
#end
#No. 182366
#File: E:\bishe\1\VMPCRandomGenerator.java
#Comment:
    /**
     * Value generated in the same way as {@link VMPCRandomGenerator#P};
     */

#Code:
    private byte s = (byte) 0xbe;

    public VMPCRandomGenerator()
    {
    }

#end
#end
#No. 182367
#File: E:\bishe\1\VMRequest.java
#Comment:
    /**
     * 
     */

#Code:
    private static final String KEY_PROVIDER = "provider";
    /**
	 * 
	 */
    private static final long serialVersionUID = -2090082179155920305L;
    protected HashMap<String, Object> items = null;

    protected VMRequest() {
        items = new HashMap<String, Object>();
    }

#end
#end
#No. 182368
#File: E:\bishe\1\VMRequest.java
#Comment:
    /**
     * Set the virtual machine provider
     * 
     * @param data
     *            The virtual machine provider
     */

#Code:
    public void setProvider(VMProvider data) {
        this.items.put(KEY_PROVIDER, data);
    }

#end
#end
#No. 182369
#File: E:\bishe\1\VMRequest.java
#Comment:
    /**
     * Get the virtual machine provider
     * 
     * @return The virtual machine provider
     */

#Code:
    public VMProvider getProvider() {
        return (VMProvider) this.items.get(KEY_PROVIDER);
    }

#end
#end
#No. 182370
#File: E:\bishe\1\VMRole.java
#Comment:
/**
 * VMRole
 * 
 * @author dangleton
 * 
 */

#Code:
public enum VMRole {
    Broker,
    Agent,
    Controller,
    Logging
}


#end
#end
#No. 182372
#File: E:\bishe\1\VMScalingCapabilities.java
#Comment:
    /**
     * This indicates the scalability of distinct, named products.
     * @return true if you can scale up/down product
     */

#Code:
    public boolean isSupportsProductChanges() {
        return supportsProductChanges;
    }

#end
#end
#No. 182373
#File: E:\bishe\1\VMScalingCapabilities.java
#Comment:
    /**
     * This indicates the scalability of non-distinct, non-named product sizes
     * @return true if you can scale the product size up/down
     */

#Code:
    public boolean isSupportsProductSizeChanges(){
        return supportsProductSizeChanges;
    }

#end
#end
#No. 182375
#File: E:\bishe\1\VMSize.java
#Comment:
/*
 * Large							:  4 ECUs, 2 Cores, 7.5 GB
 * ExtraLarge						:  8 ECUs, 4 Cores, 15 GB
 * HighMemoryExtraLarge				:  6.5 ECUs, 2 Cores, 17.1 GB
 * HighMemoryDoubleExtraLarge		:  13 ECUs, 4 Cores, 34.2 GB
 * HighMemoryQuadrupleExtraLarge	:  26 ECUs, 8 Cores, 68.4 GB
 * HighCPUExtraLarge				:  20 ECUs, 8 Cores, 7 GB
 */

#Code:

public enum VMSize {
    Micro("t1.micro"), // $0.020 / hour
    Small("m1.small"), // $0.080 / hour
    Medium("m1.medium"), // $0.160 / hour
    Large("m1.large"), // $0.32 / hour
    ExtraLarge("m1.xlarge"), // $0.640 / hour
    HighMemoryExtraLarge("m2.xlarge"), // $0.450 / hour
    HighMemoryDoubleExtraLarge("m2.2xlarge"), // $0.900 / hour
    HighMemoryQuadrupleExtraLarge("m2.4xlarge"), // $1.800 / hour
    HighCPUMedium("c1.medium"), // $0.165 / hour
    HighCPUExtraLarge("c1.xlarge"), // $0.660 / hour
    HighIOExtraLarge("hi1.4xlarge")// $3.100 / hour
    ;

    private String representation;

    /**
     * @param representation
     */
    private VMSize(String representation) {
        this.representation = representation;
    }

    /**
     * @return the representation
     */
    public String getRepresentation() {
        return representation;
    }

    public static VMSize fromRepresentation(String representation) {
        for (VMSize s : VMSize.values()) {
            if (s.representation.equalsIgnoreCase(representation)) {
                return s;
            }
        }
        return null;
    }
}



#end
#end
#No. 182377
#File: E:\bishe\1\VmStatus.java
#Comment:
/**
 * <p>
 * The various possible status a server can have. Implementors should do their best to
 * map cloud-specific states to these states.
 * </p>
 */

#Code:
public enum VmStatus {
  /**
   * The server is functioning as expected - set by provider.
   */
  OK,
  /**
   * The server is not functioning as expected - set by provider.
   */
  IMPAIRED,
  /**
   * Not enough data to detect status - set by provider.
   */
  INSUFFICIENT_DATA,
  /**
   * VM status cannot be applied to this type of server - set by provider.
   */
  NOT_APPLICABLE,
  /**
   * Could not get status from provider.  Set by dasein.  Should be used in cases of null or empty
   * values from provider
   */
  STATUS_UNAVAILABLE
}


#end
#end
#No. 182379
#File: E:\bishe\1\VmstaxContext.java
#Comment:
	/**
	 * @param p_sMessage
	 */

#Code:
	public void addMessage( String p_sMessage ) {
		messages.add(p_sMessage);
	}

#end
#end
#No. 182380
#File: E:\bishe\1\VmstaxContext.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public String messageToString() {
		StringBuilder sMessages = new StringBuilder();
		for( String sMessage : messages ) {
			sMessages.append(sMessage);
		}
		
		return sMessages.toString();
	}

#end
#end
#No. 182384
#File: E:\bishe\1\VmstaxServiceImpl.java
#Comment:
	/**
	 * @param p_oContent
	 * @param p_sFormat
	 * @param p_sFileName
	 * @return
	 * @throws IOException
	 * @throws VmstaxParseException
	 * @throws Exception
	 */

#Code:
	private List<VmstaxData> parseLogFile(byte[] p_oContent, String p_sFormat,
			String p_sFileName, VmstaxContext p_oVmstaxContext ) throws IOException, VmstaxParseException,
			Exception {

		InputStream oIs = new ByteArrayInputStream(p_oContent);
		List<String> listLines = null;
		try {
			listLines = IOUtils.readLines(oIs);
		} finally {
			oIs.close();
		}

		List<VmstaxData> r_listVmstaxData = new ArrayList<VmstaxData>();
		VmstaxParser oVmstaxParser = (VmstaxParser) this.vmstaxParsers
				.get(p_sFormat);
		if (oVmstaxParser != null) {
			r_listVmstaxData.addAll(oVmstaxParser.parse(listLines, p_oVmstaxContext));
			for( VmstaxData oVmstaxData : r_listVmstaxData ) {
				oVmstaxData.setFileName(p_sFileName);
			}
		} else {
			throw new Exception("Can't find parser for format : " + p_sFormat);
		}

		return r_listVmstaxData;
	}

#end
#end
#No. 182385
#File: E:\bishe\1\VmstaxServiceImpl.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public List<VmstaxParser> getParsers() {
		return this.parsers;
	}

#end
#end
#No. 182386
#File: E:\bishe\1\VmstaxServiceImpl.java
#Comment:
	/**
	 * @param parsers
	 */

#Code:
	public void setParsers(List<VmstaxParser> parsers) {
		this.parsers = parsers;
	}

#end
#end
#No. 182388
#File: E:\bishe\1\VMTrackerImpl.java
#Comment:
    /**
     * @{inheritDoc
     */

#Code:
    @Override
    public void publishEvent(JobEvent event) {
        try {
            jobEventProducer.fire(event);
        } catch (Exception e) {
            LOG.error("Error firing Event: " + e, e);
        }
    }

#end
#end
#No. 182389
#File: E:\bishe\1\VMTrackerImpl.java
#Comment:
    /**
     * @param status
     * @return
     */

#Code:
    private JobQueueStatus getQueueStatus(JobQueueStatus oldStatus, JobStatus jobSatatus) {
        try {
            return JobQueueStatus.valueOf(jobSatatus.name());
        } catch (Exception e) {
            LOG.error("Error converting status from " + jobSatatus);
        }
        return oldStatus;
    }

#end
#end
#No. 182390
#File: E:\bishe\1\VMTrackerImpl.java
#Comment:
    /**
     * @param curentStatus
     * @return
     */

#Code:
    private boolean shouldUpdateStatus(CloudVmStatus curentStatus) {
        if (curentStatus != null) {
            VMStatus status = curentStatus.getVmStatus();
            return (status == VMStatus.shutting_down
            		|| status == VMStatus.stopped
            		|| status == VMStatus.stopping
                    || status == VMStatus.terminated) 
            		? false : true;
        }
        return true;
    }

#end
#end
#No. 182391
#File: E:\bishe\1\VMTrackerImpl.java
#Comment:
    /**
     * 
     * @{inheritDoc
     */

#Code:
    @Override
    public void removeStatusForInstance(String instanceId) {
        statusMap.remove(instanceId);
    }

#end
#end
#No. 182392
#File: E:\bishe\1\VMTrackerImpl.java
#Comment:
    /**
     * 
     * @{inheritDoc
     */

#Code:
    @Override
    public void removeStatusForJob(String jobId) {
        CloudVmStatusContainer cloudVmStatusContainer = jobMap.get(jobId);
        if (cloudVmStatusContainer != null) {
            for (CloudVmStatus s : cloudVmStatusContainer.getStatuses()) {
                removeStatusForInstance(s.getInstanceId());
            }
            jobMap.remove(jobId);
        }
    }

#end
#end
#No. 182393
#File: E:\bishe\1\VMTrackerImpl.java
#Comment:
    /**
     * @{inheritDoc
     */

#Code:
    @Override
    public CloudVmStatusContainer getVmStatusForJob(String jobId) {
        return jobMap.get(jobId);
    }

#end
#end
#No. 182394
#File: E:\bishe\1\VMTrackerImpl.java
#Comment:
    /**
     * @{inheritDoc
     */

#Code:
    @Override
    public boolean isDevMode() {
        return devMode;
    }

#end
#end
#No. 182395
#File: E:\bishe\1\VMTrackerImpl.java
#Comment:
    /**
     * @{inheritDoc
     */

#Code:
    @Override
    public Set<CloudVmStatusContainer> getAllJobs() {
        return new HashSet<CloudVmStatusContainer>(jobMap.values());
    }

#end
#end
#No. 182396
#File: E:\bishe\1\VMTrackerImpl.java
#Comment:
    /**
     * @param jobId
     * @return
     */

#Code:
    private JobInstance getJob(String jobId) {
        JobInstanceDao dao = new JobInstanceDao();
        JobInstance job = null;
        try {
            int id = Integer.parseInt(jobId);
            job = dao.findById(id);
        } catch (NumberFormatException e) {
            // dev mode. using synthetic jobID
            LOG.warn("Using Local mode ignoring job status.");
        }
        return job;
    }


#end
#end
#No. 182398
#File: E:\bishe\1\VMUpdateStateRequest.java
#Comment:
    /**
     * Constructor
     * 
     * @param provider
     *            The virtual machine environment
     * @param region
     *            The region for the virtual machine
     * @param size
     *            The size of the virtual machine
     */

#Code:
    public VMUpdateStateRequest(VMProvider provider, String instanceId) {
        super(provider);
        String[] instances = new String[] { instanceId };
        this.setInstances(instances);
    }

#end
#end
#No. 182399
#File: E:\bishe\1\VMUpdateStateRequest.java
#Comment:
    /**
     * Constructor
     * 
     * @param provider
     *            The virtual provider
     * @param instanceIds
     *            A list of instance ids
     */

#Code:
    public VMUpdateStateRequest(VMProvider provider, String... instanceIds) {
        super(provider);
        this.setInstances(instanceIds);
    }

#end
#end
#No. 182400
#File: E:\bishe\1\VMUpdateStateRequest.java
#Comment:
    /**
     * Set the array of instance ids
     * 
     * @param instances
     *            The instance ids to update
     */

#Code:
    public void setInstances(String... instances) {
        this.items.put("instances", instances);
    }

#end
#end
#No. 182401
#File: E:\bishe\1\VMUpdateStateRequest.java
#Comment:
    /**
     * Get the array of instance ids
     * 
     * @return The array of instance ids
     */

#Code:
    public String[] getInstances() {
        return (String[]) this.items.get("instances");
    }

#end
#end
#No. 182402
#File: E:\bishe\1\VMWareExecutorConfiguration.java
#Comment:
	/**
	 * @param rootDir
	 * @param propNames
	 */

#Code:
	public VMWareExecutorConfiguration(File rootDir, String[] propNames) {
		super(rootDir, propNames);
	}


#end
#end
#No. 182404
#File: E:\bishe\1\VMWareSandBoxEnvironment.java
#Comment:
	/**
	 * @throws ExecutorException
	 * @throws IOException
	 */

#Code:
	private void copyFilesFromVMToHost(String pathOnVM, String pathOnHost) throws ExecutorException, IOException {
		buildAndRunProcess(commandFactory.createCopyFromGuestCommand(pathOnVM, pathOnHost),
				"Could not copy file.");
	}

#end
#end
#No. 182405
#File: E:\bishe\1\VncCanvas.java
#Comment:
	/**
	 * Apply scroll offset and scaling to convert touch-space coordinates to the corresponding
	 * point on the full frame.
	 * @param e MotionEvent with the original, touch space coordinates.  This event is altered in place.
	 * @return e -- The same event passed in, with the coordinates mapped
	 */

#Code:
	MotionEvent changeTouchCoordinatesToFullFrame(MotionEvent e)
	{
		//Log.v(TAG, String.format("tap at %f,%f", e.getX(), e.getY()));
		float scale = getScale();
		
		// Adjust coordinates for Android notification bar.
		e.offsetLocation(0, -1f * getTop());

		e.setLocation(absoluteXPosition + e.getX() / scale, absoluteYPosition + e.getY() / scale);
		
		return e;
	}

#end
#end
#No. 182406
#File: E:\bishe\1\VncCanvas.java
#Comment:
	/**
	 * Convert Android mouse button codes to RFB PointerEvent codes.
	 * @param e Original MotionEvent.
	 * @return -- The RFB button state.
	 */

#Code:
	int convertMouseButtons(MotionEvent e)
	{
		int buttons = e.getButtonState();
		int result = 0;
		for (int i=0; i<31; i++) {
			int mask = 1 << i;
			if ((buttons & mask) != 0) {
				switch (mask) {
					case MotionEvent.BUTTON_PRIMARY:
						result |= MOUSE_BUTTON_LEFT;
						break;
					case MotionEvent.BUTTON_SECONDARY:
						result |= MOUSE_BUTTON_RIGHT;
						break;
					case MotionEvent.BUTTON_TERTIARY:
						result |= MOUSE_BUTTON_MIDDLE;
						break;
					case MotionEvent.BUTTON_BACK:
						result |= MOUSE_BUTTON_BACK;
						break;
					case MotionEvent.BUTTON_FORWARD:
						result |= MOUSE_BUTTON_FORWARD;
						break;
				}
			}
		}
		return result;
	}

#end
#end
#No. 182407
#File: E:\bishe\1\VncCanvas.java
#Comment:
	/**
	 * Warp the mouse to x, y in the RFB coordinates
	 * @param x
	 * @param y
	 */

#Code:
	void warpMouse(int x, int y)
	{
		bitmapData.invalidateMousePosition();
		mouseX=x;
		mouseY=y;
		bitmapData.invalidateMousePosition();
		try
		{
			rfb.writePointerEvent(x, y, 0, MOUSE_BUTTON_NONE);
		}
		catch ( IOException ioe)
		{
			Log.w(TAG,ioe);
		}
	}


#end
#end
#No. 182409
#File: E:\bishe\1\VncCanvas.java
#Comment:
	/**
	 * Pan by a number of pixels (relative pan)
	 * @param dX
	 * @param dY
	 * @return True if the pan changed the view (did not move view out of bounds); false otherwise
	 */

#Code:
	boolean pan(int dX, int dY) {
		
		double scale = getScale();
		
		double sX = (double)dX / scale;
		double sY = (double)dY / scale;
		
		if (absoluteXPosition + sX < 0)
			// dX = diff to 0
			sX = -absoluteXPosition;
		if (absoluteYPosition + sY < 0)
			sY = -absoluteYPosition;

		// Prevent panning right or below desktop image
		if (absoluteXPosition + getVisibleWidth() + sX > getImageWidth())
			sX = getImageWidth() - getVisibleWidth() - absoluteXPosition;
		if (absoluteYPosition + getVisibleHeight() + sY > getImageHeight())
			sY = getImageHeight() - getVisibleHeight() - absoluteYPosition;

		absoluteXPosition += sX;
		absoluteYPosition += sY;
		if (sX != 0.0 || sY != 0.0)
		{
			scrollToAbsolute();
			return true;
		}
		return false;
	}


#end
#end
#No. 182411
#File: E:\bishe\1\VncCanvas.java
#Comment:
	/**
	 * Convert a motion event to a format suitable for sending over the wire
	 * @param evt motion event; x and y must already have been converted from screen coordinates
	 * to remote frame buffer coordinates.
	 * @param downEvent True if "mouse button" (touch or trackball button) is down when this happens
	 * @param useRightButton If true, event is interpreted as happening with right mouse button
	 * @return true if event was actually sent
	 */

#Code:
	public boolean processPointerEvent(MotionEvent evt,boolean downEvent,boolean useRightButton) {
		return processPointerEvent((int)evt.getX(),(int)evt.getY(), evt.getAction(), evt.getMetaState(), downEvent, useRightButton);
	}

#end
#end
#No. 182412
#File: E:\bishe\1\VncCanvas.java
#Comment:
	/**
	 * Moves the scroll while the volume key is held down
	 * @author Michael A. MacDonald
	 */

#Code:
	class MouseScrollRunnable implements Runnable
	{
		int delay = 100;
		
		int scrollButton = 0;
		
		/* (non-Javadoc)
		 * @see java.lang.Runnable#run()
		 */
		@Override
		public void run() {
			try
			{
				rfb.writePointerEvent(mouseX, mouseY, 0, scrollButton);
				rfb.writePointerEvent(mouseX, mouseY, 0, 0);
				
				handler.postDelayed(this, delay);
			}
			catch (IOException ioe)
			{
				
			}
		}		
	}

#end
#end
#No. 182413
#File: E:\bishe\1\VNFComponentManagment.java
#Comment:
  /**
   * Return the list of VNFComponent
   *
   * @return Iterable<VNFComponent>
   */

#Code:
  public Iterable<VNFComponent> query() {
    return vnfcRepository.findAll();
  }

#end
#end
#No. 182414
#File: E:\bishe\1\VNFComponentManagment.java
#Comment:
  /**
   * Returns the VNFComponent selected by id
   *
   * @param id of VNFComponent
   * @return VNFComponent
   */

#Code:
  @Override
  public VNFComponent query(String id) {
    return vnfcRepository.findFirstById(id);
  }



#end
#end
#No. 182417
#File: E:\bishe\1\VnfmSpringHelper.java
#Comment:
  /**
   * This method should be used for receiving text message from EMS
   *
   * <p>resp = { 'output': out, // the output of the command 'err': err, // the error outputs of the
   * commands 'status': status // the exit status of the command }
   *
   * @param queueName
   * @return
   * @throws JMSException
   */

#Code:
  public String receiveTextFromQueue(String queueName)
      throws JMSException, ExecutionException, InterruptedException, VnfmSdkException {
    String res;

    Connection connection = connectionFactory.createConnection();
    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    MessageConsumer consumer = session.createConsumer(session.createQueue(queueName));
    connection.start();
    String scriptMaxTime = properties.getProperty("script-max-time");
    if (scriptMaxTime != null) {
      TextMessage textMessage = (TextMessage) consumer.receive(Long.parseLong(scriptMaxTime));
      if (textMessage != null) res = textMessage.getText();
      else
        throw new VnfmSdkException(
            "No message got from queue " + queueName + " after " + scriptMaxTime);
    } else res = ((TextMessage) consumer.receive()).getText();
    log.debug("Received Text from " + queueName + ": " + res);
    consumer.close();
    session.close();
    connection.close();
    return res;
  }


#end
#end
#No. 182419
#File: E:\bishe\1\VocabElementListState.java
#Comment:
  /**
   * Map a RDF resource that represents a vocabulary element to a GedcomX vocabulary element
   *
   * @param resourceDescribingElement the RDF resource that represents a vocabulary element
   * @return a GedcomX vocabulary element that corresponds to the given RDF resource
   */

#Code:
  private VocabElement mapToVocabElement(Resource resourceDescribingElement) {

    VocabElement vocabElement = new VocabElement();
    Model model = resourceDescribingElement.getModel();

    // Map required attributes into the VocabElement
    vocabElement.setId(resourceDescribingElement.getRequiredProperty(model.createProperty(VocabConstants.DC_NAMESPACE, "identifier")).getString());
    vocabElement.setUri(URI.create(resourceDescribingElement.getURI()));

    // Get optional attributes into the VocabElement
    Property property = model.createProperty(VocabConstants.RDFS_NAMESPACE, "subClassOf");
    if (resourceDescribingElement.hasProperty(property)) {
      vocabElement.setSubclass(URI.create(resourceDescribingElement.getRequiredProperty(model.createProperty(VocabConstants.RDFS_NAMESPACE, "subClassOf")).getResource().getURI()));
    }
    property = model.createProperty(VocabConstants.DC_NAMESPACE, "type");
    if (resourceDescribingElement.hasProperty(property)) {
      vocabElement.setType(URI.create(resourceDescribingElement.getRequiredProperty(model.createProperty(VocabConstants.DC_NAMESPACE, "type")).getResource().getURI()));
    }

    // Map the labels into the VocabElement
    StmtIterator labels = resourceDescribingElement.listProperties(model.createProperty(VocabConstants.RDFS_NAMESPACE, "label"));
    while (labels.hasNext()) {
      Statement next = labels.next();
      vocabElement.addLabel(next.getString(), next.getLanguage().toLowerCase());
    }

    // Map the descriptions into the VocabElement
    StmtIterator descriptions = resourceDescribingElement.listProperties(model.createProperty(VocabConstants.RDFS_NAMESPACE, "comment"));
    while (descriptions.hasNext()) {
      Statement next = descriptions.next();
      vocabElement.addDescription(next.getString(), next.getLanguage().toLowerCase());
    }
    return vocabElement;
  }

#end
#end
#No. 182420
#File: E:\bishe\1\VocabularyService.java
#Comment:
  /**
   * @summary Perform a lookup of an array of concept identifiers returning the
   * matching concepts with their detailed properties.
   * @param sourceKey path parameter specifying the source key identifying the
   * source to use for access to the set of vocabulary tables
   * @param identifiers an array of concept identifiers
   * @return collection of concepts
   */

#Code:
  @Path("{sourceKey}/lookup/identifiers")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeIdentifierLookup(@PathParam("sourceKey") String sourceKey, long[] identifiers) {
    if (identifiers.length == 0) {
      return new ArrayList<>();
    }

#end
#end
#No. 182421
#File: E:\bishe\1\VocabularyService.java
#Comment:
  /**
   * @summary Perform a lookup of an array of concept identifiers returning the
   * matching concepts with their detailed properties, using the default source.
   * @param identifiers an array of concept identifiers
   * @return collection of concepts
   */

#Code:
  @Path("lookup/identifiers")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeIdentifierLookup(long[] identifiers) {
    String defaultSourceKey = getDefaultVocabularySourceKey();
    
    if (defaultSourceKey == null)
      throw new WebApplicationException(new Exception("No vocabulary or cdm daimon was found in configured sources.  Search failed."), Response.Status.SERVICE_UNAVAILABLE); // http 503      

    return executeIdentifierLookup(defaultSourceKey, identifiers);   
  }  

#end
#end
#No. 182422
#File: E:\bishe\1\VocabularyService.java
#Comment:
  /**
   * @summary Lookup source codes in the specified vocabulary
   * @param sourceKey path parameter specifying the source key identifying the
   * source to use for access to the set of vocabulary tables
   * @param sourcecodes array of source codes
   * @return collection of concepts
   */

#Code:
  @Path("{sourceKey}/lookup/sourcecodes")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeSourcecodeLookup(@PathParam("sourceKey") String sourceKey, String[] sourcecodes) {
    if (sourcecodes.length == 0) {
      return new ArrayList<>();
    }

#end
#end
#No. 182423
#File: E:\bishe\1\VocabularyService.java
#Comment:
  /**
   * @summary Lookup source codes in the specified vocabulary using the default source.
   * @param sourcecodes array of source codes
   * @return collection of concepts
   */

#Code:
  @Path("lookup/sourcecodes")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeSourcecodeLookup(String[] sourcecodes) {
    String defaultSourceKey = getDefaultVocabularySourceKey();
    
    if (defaultSourceKey == null)
      throw new WebApplicationException(new Exception("No vocabulary or cdm daimon was found in configured sources.  Search failed."), Response.Status.SERVICE_UNAVAILABLE); // http 503      

    return executeSourcecodeLookup(defaultSourceKey, sourcecodes);
  }

#end
#end
#No. 182424
#File: E:\bishe\1\VocabularyService.java
#Comment:
  /**
   * @summary find all concepts mapped to the identifiers provided
   * @param sourceKey path parameter specifying the source key identifying the
   * source to use for access to the set of vocabulary tables
   * @param identifiers an array of concept identifiers
   * @return collection of concepts
   */

#Code:
  @Path("{sourceKey}/lookup/mapped")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeMappedLookup(@PathParam("sourceKey") String sourceKey, long[] identifiers) {
    if (identifiers.length == 0) {
      return new ArrayList<>();
    }

#end
#end
#No. 182425
#File: E:\bishe\1\VocabularyService.java
#Comment:
  /**
   * @summary find all concepts mapped to the identifiers provided using the default vocabulary source.
   * @param identifiers an array of concept identifiers
   * @return collection of concepts
   */

#Code:
  @Path("lookup/mapped")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeMappedLookup(long[] identifiers) {
    String defaultSourceKey = getDefaultVocabularySourceKey();
    
    if (defaultSourceKey == null)
      throw new WebApplicationException(new Exception("No vocabulary or cdm daimon was found in configured sources.  Search failed."), Response.Status.SERVICE_UNAVAILABLE); // http 503      

    return executeMappedLookup(defaultSourceKey, identifiers);
  }

#end
#end
#No. 182426
#File: E:\bishe\1\VocabularyService.java
#Comment:
  /**
   * Perform a search using the default vocabulary source.
   * @param search
   * @return 
   */

#Code:
  @Path("search")
  @POST
  @Produces(MediaType.APPLICATION_JSON)
  @Consumes(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeSearch(ConceptSearch search) {
    String defaultSourceKey = getDefaultVocabularySourceKey();
    
    if (defaultSourceKey == null)
      throw new WebApplicationException(new Exception("No vocabulary or cdm daimon was found in configured sources.  Search failed."), Response.Status.SERVICE_UNAVAILABLE); // http 503      

    return executeSearch(defaultSourceKey, search);    
  }

#end
#end
#No. 182427
#File: E:\bishe\1\VocabularyService.java
#Comment:
  /**
   * @param query
   * @return
   */

#Code:
  @Path("{sourceKey}/search/{query}")
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  public Collection<Concept> executeSearch(@PathParam("sourceKey") String sourceKey, @PathParam("query") String query) {
    Tracker.trackActivity(ActivityType.Search, query);

    // escape single quote for queries
    query = query.replace("'", "''");
    query = query.replace("[", "[[]");

    Source source = getSourceRepository().findBySourceKey(sourceKey);
    String tableQualifier = source.getTableQualifier(SourceDaimon.DaimonType.Vocabulary);

    String sql_statement = ResourceHelper.GetResourceAsString("/resources/vocabulary/sql/search.sql");
    sql_statement = SqlRender.renderSql(sql_statement, new String[]{"query", "CDM_schema", "filters"}, new String[]{
      query.toLowerCase(), tableQualifier, ""});
    sql_statement = SqlTranslate.translateSql(sql_statement, "sql server", source.getSourceDialect());

    return getSourceJdbcTemplate(source).query(sql_statement, this.rowMapper);
  }




#end
#end
#No. 182431
#File: E:\bishe\1\VOffset.java
#Comment:
    /**
     * Move text vertically by N pixels
     *
     * @param pixels the number of pixels
     */

#Code:
    public VOffset(String pixels) throws ParseException {
        try {
            this.mPixels = Integer.parseInt(pixels);
        } catch (NumberFormatException e) {
            throw new ParseException(String.format("Invalid pixels: '%s'", pixels));
        }
    }

#end
#end
#No. 182432
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalize.java
#Comment:
    /**
     * Extract normalize vendor option.
     *
     * @param contrastEnhancement the contrast enhancement
     */

#Code:
    protected void extractNormalizeVendorOption(ContrastEnhancement contrastEnhancement) {
        if (contrastEnhancement != null) {
            Map<String, Expression> options = contrastEnhancement.getOptions();
            options.clear();

            if (contrastEnhancement.getMethod() != null) {
                String method = contrastEnhancement.getMethod().name();
                if (method.compareToIgnoreCase(ContrastMethod.NORMALIZE.name()) == 0) {
                    Expression algorithmExpression = fieldConfigVisitor
                            .getExpression(algorithmFieldId);
                    if (algorithmExpression != null) {
                        options.put(ALGORITHM_OPTION, algorithmExpression);
                    }

                    Expression minValueExpression = fieldConfigVisitor
                            .getExpression(minValueFieldId);
                    if (minValueExpression != null) {
                        options.put(MIN_VALUE_OPTION, minValueExpression);
                    }

                    Expression maxValueExpression = fieldConfigVisitor
                            .getExpression(maxValueFieldId);
                    if (maxValueExpression != null) {
                        options.put(MAX_VALUE_OPTION, maxValueExpression);
                    }
                }
            }
        }
    }

#end
#end
#No. 182433
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalizeBlueTest.java
#Comment:
    /**
     * Creates the channel selection object.
     *
     * @param styleFactory the style factory
     * @param contrastMethod the contrast method
     * @return the channel selection
     */

#Code:
    private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement =
                (ContrastEnhancement) styleFactory.contrastEnhancement(null, 
                contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put("algorithm", ff.literal("StretchToMinimumMaximum"));
        options.put("minValue", ff.literal("1"));
        options.put("maxValue", ff.literal("5"));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType("channel name", 
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }

#end
#end
#No. 182434
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalizeBlueTest.java
#Comment:
    /**
     * Creates the channel selection error object.
     *
     * @param styleFactory the style factory
     * @param contrastMethod the contrast method
     * @return the channel selection
     */

#Code:
    private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = 
                (ContrastEnhancement) styleFactory.contrastEnhancement(null, 
                contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put("algorithm", ff.literal("TestStretchToMinimumMaximum"));
        options.put("minValue", ff.literal("1.0"));
        options.put("maxValue", ff.literal("5.0"));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType("channel name",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }

#end
#end
#No. 182435
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalizeGreenTest.java
#Comment:
    /**
     * Creates the channel selection object.
     *
     * @param styleFactory the style factory
     * @param contrastMethod the contrast method
     * @return the channel selection
     */

#Code:
    private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = (ContrastEnhancement) styleFactory
                .contrastEnhancement(null, contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put("algorithm", ff.literal("StretchToMinimumMaximum"));
        options.put("minValue", ff.literal("1"));
        options.put("maxValue", ff.literal("5"));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType("channel name",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }

#end
#end
#No. 182436
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalizeGreenTest.java
#Comment:
    /**
     * Creates the channel selection error object.
     *
     * @param styleFactory the style factory
     * @param contrastMethod the contrast method
     * @return the channel selection
     */

#Code:
    private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = (ContrastEnhancement) styleFactory
                .contrastEnhancement(null, contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put("algorithm", ff.literal("TestStretchToMinimumMaximum"));
        options.put("minValue", ff.literal("1.0"));
        options.put("maxValue", ff.literal("5.0"));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType("channel name",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }

#end
#end
#No. 182437
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalizeGreyTest.java
#Comment:
    /**
     * Creates the channel selection object.
     *
     * @param styleFactory the style factory
     * @param contrastMethod the contrast method
     * @return the channel selection
     */

#Code:
    private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = (ContrastEnhancement) styleFactory
                .contrastEnhancement(null, contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put("algorithm", ff.literal("StretchToMinimumMaximum"));
        options.put("minValue", ff.literal("1"));
        options.put("maxValue", ff.literal("5"));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType("channel name",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }

#end
#end
#No. 182438
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalizeGreyTest.java
#Comment:
    /**
     * Creates the channel selection error object.
     *
     * @param styleFactory the style factory
     * @param contrastMethod the contrast method
     * @return the channel selection
     */

#Code:
    private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = (ContrastEnhancement) styleFactory
                .contrastEnhancement(null, contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put("algorithm", ff.literal("TestStretchToMinimumMaximum"));
        options.put("minValue", ff.literal("1.0"));
        options.put("maxValue", ff.literal("5.0"));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType("channel name",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }

#end
#end
#No. 182439
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalizeOverallTest.java
#Comment:
    /**
     * Creates the channel selection object.
     *
     * @param styleFactory the style factory
     * @param contrastMethod the contrast method
     * @return the channel selection
     */

#Code:
    private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = (ContrastEnhancement) styleFactory
                .contrastEnhancement(null, contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put("algorithm", ff.literal("StretchToMinimumMaximum"));
        options.put("minValue", ff.literal("1"));
        options.put("maxValue", ff.literal("5"));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType("channel name",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }

#end
#end
#No. 182440
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalizeOverallTest.java
#Comment:
    /**
     * Creates the channel selection error object.
     *
     * @param styleFactory the style factory
     * @param contrastMethod the contrast method
     * @return the channel selection
     */

#Code:
    private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = (ContrastEnhancement) styleFactory
                .contrastEnhancement(null, contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put("algorithm", ff.literal("TestStretchToMinimumMaximum"));
        options.put("minValue", ff.literal("1.0"));
        options.put("maxValue", ff.literal("5.0"));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType("channel name",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }

#end
#end
#No. 182441
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalizeRedTest.java
#Comment:
    /**
     * Creates the channel selection object.
     *
     * @param styleFactory the style factory
     * @param contrastMethod the contrast method
     * @return the channel selection
     */

#Code:
    private ChannelSelection createChannelSelection(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = (ContrastEnhancement) styleFactory
                .contrastEnhancement(null, contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put("algorithm", ff.literal("StretchToMinimumMaximum"));
        options.put("minValue", ff.literal("1"));
        options.put("maxValue", ff.literal("5"));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType("channel name",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }

#end
#end
#No. 182442
#File: E:\bishe\1\VOGeoServerContrastEnhancementNormalizeRedTest.java
#Comment:
    /**
     * Creates the channel selection error object.
     *
     * @param styleFactory the style factory
     * @param contrastMethod the contrast method
     * @return the channel selection
     */

#Code:
    private ChannelSelection createChannelSelectionError(StyleFactoryImpl styleFactory,
            ContrastMethod contrastMethod) {
        ContrastEnhancement contrastEnhancement = (ContrastEnhancement) styleFactory
                .contrastEnhancement(null, contrastMethod.name());

        FilterFactory ff = CommonFactoryFinder.getFilterFactory();

        Map<String, Expression> options = contrastEnhancement.getOptions();
        options.put("algorithm", ff.literal("TestStretchToMinimumMaximum"));
        options.put("minValue", ff.literal("1.0"));
        options.put("maxValue", ff.literal("5.0"));

        SelectedChannelType channelType = styleFactory.createSelectedChannelType("channel name",
                contrastEnhancement);
        SelectedChannelType[] channels = new SelectedChannelType[3];
        channels[0] = channelType;
        channels[1] = channelType;
        channels[2] = channelType;
        ChannelSelection channelSelection = styleFactory.createChannelSelection(channels);
        return channelSelection;
    }

#end
#end
#No. 182443
#File: E:\bishe\1\VoiceAdd.java
#Comment:
/**
 * Creates a {@link Voice} in a {@link Measure}.
 * 
 * For each voice x in a measure, there is also a voice x-1 (for x>0).
 * So maybe more than one voice is created.
 * If already existing, a {@link UselessException} is thrown.
 * 
 * @author Andreas Wenger
 */

#Code:
public class VoiceAdd
	implements Command {

	//data
	private Measure measure;
	private int voiceIndex;
	//backup
	private int lastExistingVoiceIndex;
	
	
	public VoiceAdd(Measure measure, int voiceIndex) {
		this.measure = measure;
		this.voiceIndex = voiceIndex;
	}
	
	
	@Override public void execute() {
		if (measure.getVoices().size() > voiceIndex)
			throw new UselessException();
		lastExistingVoiceIndex = measure.getVoices().size() - 1;
		for (int i = lastExistingVoiceIndex + 1; i <= voiceIndex; i++) {
			Voice voice = voice();
			voice.setParent(measure);
			measure.getVoices().add(voice);
		}
	}

#end
#end
#No. 182444
#File: E:\bishe\1\VoiceCommands.java
#Comment:
    /**
     * Handle the action of the button being clicked
     */

#Code:
    public void speakButtonClicked(View v) {
        startVoiceRecognitionActivity();
    }

#end
#end
#No. 182445
#File: E:\bishe\1\VoiceCommands.java
#Comment:
    /**
     * Fire an intent to start the voice recognition activity.
     */

#Code:
    private void startVoiceRecognitionActivity() {
        Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
                RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
        intent.putExtra(RecognizerIntent.EXTRA_PROMPT, "Voice recognition test...");
        startActivityForResult(intent, REQUEST_CODE);

    }

#end
#end
#No. 182446
#File: E:\bishe\1\VoiceCommands.java
#Comment:
    /**
     * Handle the results from the voice recognition activity.
     */

#Code:
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REQUEST_CODE && resultCode == RESULT_OK) {
            // Populate the wordsList with the String values the recognition engine thought it heard
            ArrayList<String> matches = data.getStringArrayListExtra(
                    RecognizerIntent.EXTRA_RESULTS);

            if (Config.IS_DEV_BUILD && matches.contains("hello")) {
                Toast.makeText(this, "Hi!", Toast.LENGTH_LONG).show();

                /* So what we're doing above is basically checking to first see if this is a developer build
                 * (in the config class, there is a boolean that states that it is, and we're seeing if the
                 * word *only* contains "hello", and so if both of those end up being true, we display a Toast
                 * saying "Hi!". Nice and simple, but you get the point. */

            }
        }
        super.onActivityResult(requestCode, resultCode, data);
    }


#end
#end
#No. 182448
#File: E:\bishe\1\VoiceDetection.java
#Comment:
	/**
	 * Commit changes to the enabled phrases
	 *
	 * Current implementation, always leaves all phrases active, only hides them, so update of VoiceConfig is never necessary
	 * (This is included to be compatible to implementations that actually change VoiceConfig)
	 *
	 * @return false if no changes were made
	 */

#Code:
	public boolean update() {
		return false;
	}

#end
#end
#No. 182449
#File: E:\bishe\1\VoiceDetection.java
#Comment:
	/**
	 * If the VoiceService is ready, refresh our Config
	 *
	@Override
	public void onVoiceServiceConnected() {
		super.onVoiceServiceConnected();
		mVoiceInputHelper.setVoiceConfig(mVoiceConfig);
	}*/

#Code:

	@Override
	public VoiceConfig onVoiceCommand(VoiceCommand vc) {
		String literal = vc.getLiteral();

//		if (mListener == null) {
//			mVoiceInputHelper.removeVoiceServiceListener();
//			return null;
//		}

		if (literal.equalsIgnoreCase(hotword)) { // Hotword
			Log.i(THIS, "Hotword detected");
			mListener.onHotwordDetected();

			if (hotwordOnlyMode) {
				hotwordOnly = false;
			}

			return null;
		}

		if (!hotwordOnly) {
			for (int i = 0; i < phrases.length; ++i) {
				String item = phrases[i];
				if (item.equalsIgnoreCase(literal) && enabled[i]) {// XE21 definitively converts the first letter to upper case!
					Log.i(THIS, String.format("command %s", item));
					mListener.onPhraseDetected(i, item);

					//if (hotwordOnlyMode)
					//	hotwordOnly = true;

					return null;
				}
			}
		}

		return null;
	}


#end
#end
#No. 182451
#File: E:\bishe\1\VoiceElementIterator.java
#Comment:
/**
 * An iterator over all {@link VoiceElement}s in a score.
 * 
 * Iterates over the staves, measures, voices and its voice elements.
 * 
 * @author Andreas Wenger
 */

#Code:
public class VoiceElementIterator
	implements Iterator<VoiceElement>, Iterable<VoiceElement> {
	
	private final Score score;
	
	@Getter private MP mp = unknownMp;
	
	private List<VoiceElement> elements;
	private MP nextMp = mp0;

	
	public VoiceElementIterator(Score score) {
		this.score = score;
		elements = score.getVoice(nextMp).getElements();
		findNext();
	}

	@Override public boolean hasNext() {
		return nextMp != null;
	}

#end
#end
#No. 182452
#File: E:\bishe\1\VoiceElementIteratorTest.java
#Comment:
	/**
	 * Test score with 4 staves and 4 measures. In staves 1 and 3, the measures 1 and 3 have each
	 * two voices with 4 quarter rests. The other measures have a single voice and
	 * a full rest.
	 */

#Code:
	public static Score createTestScore() {
		Score score = new Score();
		Cursor cursor = new Cursor(score, MP.mp0, true);
		for (int staff : range(4)) {
			for (int measure : range(4)) {
				if ((staff == 1 || staff == 3) && (measure == 1 || measure == 3)) {
					//2 voices with each 4 quarter notes
					for (int voice : range(2)) {
						cursor.setMp(atElement(staff, measure, voice, 0));
						for (int i = 0; i < 4; i++)
							cursor.write(new Rest(fr(1, 4)));
					}
				}
				else {
					//full rest
					cursor.setMp(atElement(staff, measure, 0, 0));
					cursor.write(new Rest(fr(1)));
				}
			}
		}
		return score;
	}

#end
#end
#No. 182453
#File: E:\bishe\1\VoiceElementRemove.java
#Comment:
/**
 * Removes the given {@link VoiceElement}.
 * 
 * All {@link Slur}s, the {@link Beam} and the {@link Tuplet} belonging to this element
 * are removed, too.
 * 
 * @author Andreas Wenger
 */

#Code:
@Untested public class VoiceElementRemove
	implements Command {
	
	//data
	private VoiceElement element;
	//backup data
	private int elementIndex = 0;
	private List<Command> backupCmds = null;
	
	
	public VoiceElementRemove(VoiceElement element) {
		this.element = element;
	}


	@Override public void execute() {
		Voice voice = element.getParent();
		if (voice == null)
			throw new IllegalStateException("element is not part of a voice");
		
		//remove slurs, beam and tuplet, if it is a chord
		if (element instanceof Chord) {
			Chord chord = (Chord) element;
			//remove slurs
			for (int i : rangeReverse(chord.getSlurs()))
				executeAndRemember(new SlurRemove(chord.getSlurs().get(i)));
			//remove beam
			if (chord.getBeam() != null)
				executeAndRemember(new BeamRemove(chord.getBeam()));
			//remove tuplet
			if (chord.getTuplet() != null)
				executeAndRemember(new TupletRemove(chord.getTuplet()));
		}
		
		//remove element, and remember its position
		elementIndex = voice.removeElement(element);
	}

#end
#end
#No. 182454
#File: E:\bishe\1\VoiceElementWriteTest.java
#Comment:
	/**
	 * Creates a score with a single staff, a single measure,
	 * two voices with each 8 quarter notes which are beamed.
	 */

#Code:
	private Score createTestScoreEighths() {
		Score score = ScoreFactory.create1Staff();
		new VoiceAdd(score.getMeasure(atMeasure(0, 0)), 1).execute();
		for (int iVoice : range(2)) {
			Voice voice = score.getVoice(atVoice(0, 0, iVoice));
			List<Chord> beamChords = new ArrayList<>();
			for (int i = 0; i < 8; i++) {
				Chord chord = new Chord(new Note(pi(0, 0, 4)), fr(1, 8));
				//add elements by hand, since the corresonding command is tested itself in this class
				chord.setParent(voice);
				voice.getElements().add(chord);
				beamChords.add(chord);
			}
			//create beam
			beamFromChords(beamChords);
		}
		//ensure that assert method works correctly. if not, fail now
		assertTestScoreEighthsOriginalState(score);
		return score;
	}

#end
#end
#No. 182455
#File: E:\bishe\1\VoiceElementWriteTest.java
#Comment:
	/**
	 * Asserts that the score created by {@link #createTestScoreEighths()} is in its original
	 * state again. Useful after undo.
	 */

#Code:
	private void assertTestScoreEighthsOriginalState(Score score) {
		for (int iVoice : range(2)) {
			Voice voice = score.getVoice(atVoice(0, 0, iVoice));
			assertEquals(8, voice.getElements().size());
			for (int i : range(8))
				assertEquals(fr(1, 8), getDur(voice, i));
		}
	}

#end
#end
#No. 182456
#File: E:\bishe\1\VoiceElementWriteTest.java
#Comment:
	/**
	 * Creates a score with a single staff, one measure and one voice:
	 * <pre>..aaaa...bbbb.cccc..</pre> (. are grace notes, a-c are rests)
	 */

#Code:
	private Score createTestScoreGraces()
	{
		Score score = ScoreFactory.create1Staff();
		Voice voice = score.getVoice(atVoice(0, 0, 0));
		voice.addElement(grace(0));
		voice.addElement(grace(1));
		voice.addElement(new Rest(fr(1, 4)));
		voice.addElement(grace(2));
		voice.addElement(grace(3));
		voice.addElement(grace(4));
		voice.addElement(new Rest(fr(1, 4)));
		voice.addElement(grace(5));
		voice.addElement(new Rest(fr(1, 4)));
		voice.addElement(grace(6));
		voice.addElement(grace(0));
		//ensure that assert method works correctly. if not, fail now
		assertTestScoreGracesOriginalState(score);
		return score;
	}

#end
#end
#No. 182457
#File: E:\bishe\1\VoiceElementWriteTest.java
#Comment:
	/**
	 * Asserts that the score created by {@link #createTestScoreGraces()} is in its original
	 * state again. Useful after undo.
	 */

#Code:
	private void assertTestScoreGracesOriginalState(Score score) {
		Voice voice = score.getVoice(atVoice(0, 0, 0));
		assertEquals(11, voice.getElements().size());
		assertEquals(0, getStep(voice, 0));
		assertEquals(1, getStep(voice, 1));
		assertEquals(fr(1, 4), getDur(voice, 2));
		assertEquals(2, getStep(voice, 3));
		assertEquals(3, getStep(voice, 4));
		assertEquals(4, getStep(voice, 5));
		assertEquals(fr(1, 4), getDur(voice, 6));
		assertEquals(5, getStep(voice, 7));
		assertEquals(fr(1, 4), getDur(voice, 8));
		assertEquals(6, getStep(voice, 9));
		assertEquals(0, getStep(voice, 10));
	}

#end
#end
#No. 182458
#File: E:\bishe\1\VoiceFeedback.java
#Comment:
	/**
	 * Average cadence by last 20 samples. If it isn't running, reset average to zero.
	 * 
	 * @param cadence - current cadence
	 */

#Code:
	private void updateAverageCadence(int cadence) {
		if (cadence == 0) {
			averageCadence = 0;
			return;
		}

		if (averageCadence == 0) {
			averageCadence = cadence;
		} else {
			averageCadence = (averageCadence * 19 + cadence) / 20;
		}
	}



#end
#end
#No. 182460
#File: E:\bishe\1\VoiceFirebaseInstanceIDService.java
#Comment:
    /**
     * Persist token to third-party servers.
     *
     * Modify this method to associate the user's FCM InstanceID token with any server-side account
     * maintained by your application.
     *
     * @param token The new token.
     */

#Code:
    private void sendRegistrationToServer(String token) {
        // TODO: Implement this method to send token to your app server.
    }

#end
#end
#No. 182461
#File: E:\bishe\1\VoiceFirebaseMessagingService.java
#Comment:
    /*
     * Send the IncomingCallMessage to the TwilioVoiceModule
     */

#Code:
    private void sendIncomingCallMessageToActivity(
            ReactApplicationContext context,
            CallInvite callInvite,
            int notificationId
    ) {
        Intent intent = new Intent(ACTION_INCOMING_CALL);
        intent.putExtra(INCOMING_CALL_NOTIFICATION_ID, notificationId);
        intent.putExtra(INCOMING_CALL_INVITE, callInvite);
        LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
    }

#end
#end
#No. 182462
#File: E:\bishe\1\VoiceFirebaseMessagingService.java
#Comment:
    /*
     * Show the notification in the Android notification drawer
     */

#Code:
    @TargetApi(Build.VERSION_CODES.KITKAT_WATCH)
    private void showNotification(ReactApplicationContext context,
                                  CallInvite callInvite,
                                  int notificationId,
                                  Intent launchIntent
    ) {
        if (callInvite != null && callInvite.getState() == CallInvite.State.PENDING) {
            callNotificationManager.createIncomingCallNotification(context, callInvite, notificationId, launchIntent);
        } else {
            SoundPoolManager.getInstance(context.getBaseContext()).stopRinging();
            callNotificationManager.removeIncomingCallNotification(context, callInvite, 0);
        }
    }

#end
#end
#No. 182463
#File: E:\bishe\1\VoiceImpl.java
#Comment:
    /**
     * Gets the Unique Identifier for this file
     *
     * @return The files ID
     */

#Code:
    @Override
    public String getFileId() {
        return file_id;
    }

#end
#end
#No. 182464
#File: E:\bishe\1\VoiceImpl.java
#Comment:
    /**
     * Gets the size of the file
     *
     * @return The file size
     */

#Code:
    @Override
    public int getSize() {
        return file_size;
    }

#end
#end
#No. 182465
#File: E:\bishe\1\Voicemail.java
#Comment:
	/**
	 * 
	 * @param title
	 * @param date
	 * @param contact
	 * @param transcript
	 */

#Code:
	public Voicemail(String id, String title, Date date, Contact contact, Transcript transcript, boolean read) {
		super(id, title, date, contact, read);
		this.transcript = transcript;
		this.mp3Url = "https://www.google.com/voice/media/send_voicemail/"+id;
	}

#end
#end
#No. 182466
#File: E:\bishe\1\Voicemail.java
#Comment:
	/**
	 * @return the transcript
	 */

#Code:
	public Transcript getTransscript() {
		return transcript;
	}

#end
#end
#No. 182467
#File: E:\bishe\1\Voicemail.java
#Comment:
	/**
	 * @param transcript the transcript to set
	 */

#Code:
	public void setTransscript(Transcript transcript) {
		this.transcript = transcript;
	}

#end
#end
#No. 182468
#File: E:\bishe\1\Voicemail.java
#Comment:
	/**
	 * @return the mp3Url
	 */

#Code:
	public String getMp3Url() {
		return mp3Url;
	}

#end
#end
#No. 182469
#File: E:\bishe\1\Voicemail.java
#Comment:
	/**
	 * @param mp3Url the mp3Url to set
	 */

#Code:
	public void setMp3Url(String mp3Url) {
		this.mp3Url = mp3Url;
	}

#end
#end
#No. 182470
#File: E:\bishe\1\VoiceMenuDialogFragment.java
#Comment:
	/**
	 *
	 * @param fm
	 * @param hotword
	 * @param phraseIDs
	 * @param phrases
	 * @return
	 */

#Code:
	public static VoiceMenuDialogFragment getInstance(FragmentManager fm, String hotword, int[] phraseIDs, String... phrases) {
		VoiceMenuDialogFragment f = (VoiceMenuDialogFragment) fm.findFragmentByTag(VoiceMenuDialogFragment.FRAGMENT_TAG);
		if (f == null)
			f = new VoiceMenuDialogFragment();
		Bundle args = new Bundle();
		args.putString(VoiceMenuDialogFragment.HOTWORD, hotword);
		args.putIntArray(VoiceMenuDialogFragment.PHRASE_IDS, phraseIDs);
		args.putStringArray(VoiceMenuDialogFragment.PHRASES, phrases);

		f.setArguments(args);

		return f;
	}

#end
#end
#No. 182471
#File: E:\bishe\1\VoiceMessageReceivedEvent.java
#Comment:
    /**
     * Gets the Voice Recording that was received that triggered this Event
     *
     * @return The Voice Recording that was received that triggered this Event
     */

#Code:
    @Override
    public VoiceContent getContent() {

        return (VoiceContent) getMessage().getContent();
    }

#end
#end
#No. 182472
#File: E:\bishe\1\VoicePlayClickListener.java
#Comment:
	/**
	 * 
	 * @param message
	 * @param v
	 * @param iv_read_status
	 * @param context
	 * @param activity
	 * @param user
	 * @param chatType
	 */

#Code:
	public VoicePlayClickListener(EMMessage message, ImageView v, ImageView iv_read_status, BaseAdapter adapter, Activity activity,
			String username) {
		this.message = message;
		voiceBody = (VoiceMessageBody) message.getBody();
		this.iv_read_status = iv_read_status;
		this.adapter = adapter;
		voiceIconView = v;
		this.activity = activity;
		this.chatType = message.getChatType();
	}

#end
#end
#No. 182473
#File: E:\bishe\1\VoiceRecognitionProxy.java
#Comment:
    /**
     * Fire an intent to start the speech recognition activity.
     */

#Code:
    private void startVoiceRecognitionActivity(KrollDict options) {
        //
        //  You can override callback functions.
        //
        if (callback == null && options != null
         && options.containsKey("callback")
         && (options.get("callback") instanceof KrollFunction)) {
            Log.d(TAG, "overriding callback value");
            callback = (KrollFunction)options.get("callback");
        }
        
        //
        //  overriding option value
        //
        Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
        if (options != null) {
            if (options.containsKey(RecognizerIntent.EXTRA_LANGUAGE_MODEL)) {
                String extraVal = (String)options.get(RecognizerIntent.EXTRA_LANGUAGE_MODEL);
                Log.d(TAG, "overriding RecognizerIntent.EXTRA_LANGUAGE_MODEL value -> " + extraVal);
                intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, extraVal);
            }
            if (options.containsKey(RecognizerIntent.EXTRA_PROMPT)) {
                String extraVal = (String)options.get(RecognizerIntent.EXTRA_PROMPT);
                Log.d(TAG, "overriding RecognizerIntent.EXTRA_PROMPT value");
                   intent.putExtra(RecognizerIntent.EXTRA_PROMPT, extraVal);
            }
        }
        TiApplication.getInstance().getRootActivity().launchActivityForResult(intent, VOICE_RECOGNITION_REQUEST_CODE, this);
    }



#end
#end
#No. 182477
#File: E:\bishe\1\VoicesBeatOffsetterTest.java
#Comment:
	/**
	 * Create {@link VoiceSpacing}s for the first measure column
	 * of the given {@link Score}.
	 */

#Code:
	private LinkedList<VoiceSpacing> createVoiceSpacings(Score score) {
		LinkedList<VoiceSpacing> ret = new LinkedList<>();
		for (int iStaff : range(0, score.getStavesCount() - 1)) {
			Measure measure = score.getMeasure(atMeasure(iStaff, 0));
			for (Voice voice : measure.getVoices()) {
				Fraction beat = fr(0);
				ArrayList<ElementSpacing> se = alist();
				float offset = 0;
				for (VoiceElement e : voice.getElements()) {
					//compute width
					float width = 0;
					if (e.getDuration().equals(_0))
						width = width_grace;
					else if (e.getDuration().equals(dur_1_8))
						width = width_1_8;
					else if (e.getDuration().equals(dur_1_6))
						width = width_1_6;
					else if (e.getDuration().equals(dur_1_4))
						width = width_1_4;
					else if (e.getDuration().equals(dur_3_8))
						width = width_3_8;
					else if (e.getDuration().equals(dur_1_2))
						width = width_1_2;
					else if (e.getDuration().equals(dur_1_1))
						width = width_1_1;
					//create spacing element with offset
					se.add(new ChordSpacing(new ChordNotation((Chord) e), beat, offset));
					beat = beat.add(e.getDuration());
					offset += width;
				}
				se.add(new BorderSpacing(beat, offset));
				ret.add(new VoiceSpacing(voice, score.getFormat().getInterlineSpace(), se));
			}
		}
		return ret;
	}


#end
#end
#No. 182480
#File: E:\bishe\1\VoidDataset.java
#Comment:
    /**
     * Add string value with given language tag if the given string is not empty.
     *
     * @param predicate
     * @param value
     * @param language Is not used if null.
     */

#Code:
    private void addStringIfNotBlank(IRI subject, IRI predicate, String value,
            String language) {
        if (isBlank(value)) {
            return;
        }
        final Value object;
        if (language == null) {
            object = valueFactory.createLiteral(value);
        } else {
            object = valueFactory.createLiteral(value, language);
        }
        statements
                .add(valueFactory.createStatement(subject, predicate, object));
    }

#end
#end
#No. 182481
#File: E:\bishe\1\VoidDataset.java
#Comment:
    /**
     * Execute given SPARQL select and return the first result.
     *
     * @param queryAsString
     * @param bindingName Name of property to return.
     * @return
     */

#Code:
    private String querySingleResult(final String queryAsString,
            String bindingName) throws LpException {
        return inputDistribution.execute((connection) -> {
            final TupleQuery preparedQuery = connection.prepareTupleQuery(
                    QueryLanguage.SPARQL, queryAsString);
            final SimpleDataset dataset = new SimpleDataset();
            dataset.addDefaultGraph(inputDistribution.getReadGraph());
            preparedQuery.setDataset(dataset);
            //
            final TupleQueryResult result = preparedQuery.evaluate();
            //
            if (!result.hasNext()) {
                return null;
            }
            final Value value = result.next().getValue(bindingName);
            if (value == null) {
                return null;
            }
            return value.stringValue();
        });
    }

#end
#end
#No. 182482
#File: E:\bishe\1\VoidDeserializer.java
#Comment:
    /**
     * @inheritDoc
     */

#Code:
    public <T> T deserialize(Class<T> type, Type genericType, InputStream stream, Charset charset) {
        IOs.close(stream);
        return null;
    }

#end
#end
#No. 182483
#File: E:\bishe\1\VoidElementTest.java
#Comment:
  /**
   * Voids of size 2 to 9 should be all header, no body
   */

#Code:
  @Test
  public void test2To9()
  {
    for (int i = 2; i < 10; ++i)
    {
      VoidElement voidz = new VoidElement(i);
      MockWriter mw = new MockWriter();
      voidz.writeElement(mw);
      Assert.assertEquals(i, mw.getBuff().position());
    }
  }


#end
#end
#No. 182485
#File: E:\bishe\1\VoidEnum.java
#Comment:
/**
 * A placeholder {@link Enum} which could be specified as a type parameter of
 * {@link ReplayingDecoder} when a user wants to manage the decoder state or
 * there's no state to manage.
 */

#Code:
public enum VoidEnum {
    // No state is defined.
}

#end
#end
#No. 182486
#File: E:\bishe\1\VoidTypeImpl.java
#Comment:
/**
 * Implementation of VoidType.
 */

#Code:

class VoidTypeImpl extends TypeMirrorImpl implements VoidType {

    VoidTypeImpl(AptEnv env) {
	super(env, env.symtab.voidType);
    }

    /**
     * {@inheritDoc}
     */
    public void accept(TypeVisitor v) {
	v.visitVoidType(this);
    }
}

#end
#end
#No. 182487
#File: E:\bishe\1\VoidValueReader.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public Void read(InputStream inputStream) throws IOException {
		final String content = IOUtils.toString(inputStream, ENCODING);
		log.debug("Parsing: {}", content);

		return null;
	}




#end
#end
#No. 182491
#File: E:\bishe\1\VolcanoHelper.java
#Comment:
    /**
     * Replaces wood with charred wood and deletes leaves
     * @param start a block of the tree to char
     */

#Code:
    public static void charTree(World world, BlockCoord start)
    {
        start.setBlock(world, ArtificeBlocks.blockCharredLog, start.getMeta(world), false);
        for (BlockCoord b : start.getRadiusBlocks(2))
        {
            if (b.getBlock(world).isWood(world, b.x, b.y, b.z))
                charTree(world, b);
            else if (b.getBlock(world).isLeaves(world, b.x, b.y, b.z))
                b.setBlock(world, Blocks.air, 0, false);
        }
    }

#end
#end
#No. 182493
#File: E:\bishe\1\VoldemortClient.java
#Comment:
    /**
     * Initialize the DB layer. This accepts all properties allowed by the Voldemort client.
     * A store maps to a table.
     * Required : bootstrap_urls
     * Additional property : store_name -> to preload once, should be same as -t <table>
     * 
     * {@linktourl http://project-voldemort.com/javadoc/client/voldemort/client/ClientConfig.html}
     */

#Code:
	public void init() throws DBException {
		ClientConfig clientConfig = new ClientConfig(getProperties());
		socketFactory = new SocketStoreClientFactory(clientConfig);
		
		// Retrieve store name
		storeName = getProperties().getProperty("store_name", "usertable");
		
		// Use store name to retrieve client
		storeClient = socketFactory.getStoreClient(storeName);
		if ( storeClient == null )
			throw new DBException("Unable to instantiate store client");
		
	}

#end
#end
#No. 182494
#File: E:\bishe\1\VoldLocation.java
#Comment:
    /**
     * UUID of the node hosting the VOLD.
     * 
     * @return UUID of the node
     */

#Code:
    public final UUID getNode() {
        return node;
    }

#end
#end
#No. 182495
#File: E:\bishe\1\VoldLocation.java
#Comment:
    /**
     * IP address and port of the VOLD.
     * 
     * @return address and port to connect to the VOLD.
     */

#Code:
    public final InetSocketAddress getSockAddr() {
        return sockAddr;
    }

#end
#end
#No. 182496
#File: E:\bishe\1\VoldLocation.java
#Comment:
    /**
     * Parse a {@link VoldLocation} from a string. Format:
     * <code>&#x3C;UUID of the node&#x3E;&#x40;&#x3C;IP address&#x3E;:&#x3C;port&#x3E;</code>.
     * 
     * @param value
     *            string to parse
     * @return new {@link VoldLocation}
     * @throws IllegalArgumentException
     *             if the string if not valid
     */

#Code:
    static final VoldLocation fromString(final String value) throws IllegalArgumentException {
        final int uuidEndIndex = value.indexOf('@');
        if (uuidEndIndex < 0) {
            throw new IllegalArgumentException(value);
        }
        final String uuidStr = value.substring(0, uuidEndIndex);
        final UUID uuid = UUID.fromString(uuidStr);
        final String sockAddrStr = value.substring(uuidEndIndex + 1);

        final int addrEndIndex = sockAddrStr.indexOf(':');
        if (addrEndIndex < 0) {
            throw new IllegalArgumentException(value);
        }
        final String host = sockAddrStr.substring(0, addrEndIndex);
        if (host.isEmpty()) {
            throw new IllegalArgumentException(value);
        }
        int port;
        try {
            port = Integer.valueOf(sockAddrStr.substring(addrEndIndex + 1)).intValue();
        }
        catch (final NumberFormatException e) {
            throw new IllegalArgumentException(value, e);
        }
        final InetSocketAddress addr = new InetSocketAddress(host, port);
        return new VoldLocation(uuid, addr);
    }

#end
#end
#No. 182497
#File: E:\bishe\1\VoldPeers.java
#Comment:
    /**
     * Construct new list of peers for addition of a node
     * 
     * @param node
     * @param addr
     * @param peers
     * @return
     */

#Code:
    private final static ArrayList<VoldLocation> constructNewPeersListForAdd(@Nonnull final UUID node,
            @Nonnull final InetSocketAddress addr, final List<VoldLocation> peers) {
        final ArrayList<VoldLocation> newPeers = new ArrayList<>();
        if (peers != null) {
            for (final VoldLocation oldLocation : peers) {
                if (oldLocation.getNode().equals(node)) {
                    final String warnMsg = "uuid='" + node + "' already in peers list";
                    LOGGER.warn(warnMsg);
                    throw new IllegalArgumentException(warnMsg);
                }
                newPeers.add(oldLocation);
            }
        }

#end
#end
#No. 182498
#File: E:\bishe\1\VoldPeers.java
#Comment:
    /**
     * Construct new list of peers for deletion of a node
     * 
     * @param uuid
     * @param peers
     * @param returnList
     * @return
     */

#Code:
    private final static VoldLocation constructNewPeersListForDel(@Nonnull final UUID uuid,
            final List<VoldLocation> peers, final List<VoldLocation> returnList) {
        final List<VoldLocation> newPeers = new ArrayList<VoldLocation>();
        VoldLocation nodeToRemove = null;
        if (peers != null) {
            for (final VoldLocation oldLocation : peers) {
                if (oldLocation.getNode().equals(uuid)) {
                    // Node to remove
                    nodeToRemove = new VoldLocation(oldLocation.getNode(), oldLocation.getSockAddr());
                }
                else {
                    newPeers.add(oldLocation);
                }
            }
        }
        returnList.clear();
        returnList.addAll(newPeers);
        return nodeToRemove;
    }

#end
#end
#No. 182499
#File: E:\bishe\1\VoldPeers.java
#Comment:
    /**
     * Save new peers list in configuration. Configuration is always consistent.
     * 
     * @param newPeers
     * @throws IllegalStateException
     */

#Code:
    private void saveNewPeers(@Nonnull final List<VoldLocation> newPeers) {
        final String newValue = constructPeers(newPeers);
        LOGGER.debug("Vold peers new list=" + newValue);
        final Map<AbstractConfigKey, Object> newKeyValueMap = new HashMap<>();
        newKeyValueMap.put(PeersConfigKey.getInstance(), newPeers);
        try {
            vold.updateConfiguration(newKeyValueMap);
        }

#end
#end
#No. 182500
#File: E:\bishe\1\VoldPeers.java
#Comment:
    /**
     * Check port range according to RFC6335
     * 
     * @see http://tools.ietf.org/html/rfc6335#section-8.1
     * 
     * @param port
     */

#Code:
    private static void checkPortRange(final int port) {
        if (port < 0 || port > 65535) {
            throw new IllegalArgumentException("Port=" + port + " is not in [0-65535] range!");
        }
        if (port < 1024) {
            throw new IllegalArgumentException("Can not use port=" + port + " in [0-1024] system range!");
        }
    }

#end
#end
#No. 182501
#File: E:\bishe\1\VoldPeers.java
#Comment:
    /**
     * Add a new peer to the {@link Vold}.
     * 
     * @param uuid
     * @param address
     * @param port
     * @throws JMException
     */

#Code:
    final void addPeer(@Nonnull final String uuid, @Nonnull final String address, @Nonnegative final int port,
            final DtxTaskApi dtxTaskApi) throws JMException {
        // 1) check parameters
        Objects.requireNonNull(uuid, "Uuid parameter not provided !");
        Objects.requireNonNull(address, "Ip address parameter not provided !");
        checkPortRange(port);
        final VoldLocation localPeer = vold.getVoldLocation();
        if (UUID.fromString(uuid) == localPeer.getNode()) {
            throw new IllegalArgumentException("Can't add local peer='" + uuid + "' !");
        }

        final String newPeer = uuid + "@" + address + ":" + port;
        final VoldLocation location = VoldLocation.fromString(newPeer);

        final InetAddress addrTmp = location.getSockAddr().getAddress();
        if (addrTmp == null) {
            throw new IllegalArgumentException("address='" + addrTmp + "' unresolved !");
        }

        // 2) Submit transaction
        if (dtxTaskApi == null) {
            throw new IllegalArgumentException("Can't start transaction without DTX manager !");
        }
        submitAddPeerTask(location.getNode(), location.getSockAddr(), dtxTaskApi);
    }

#end
#end
#No. 182502
#File: E:\bishe\1\VoldPeers.java
#Comment:
    /**
     * Add a new peer to the {@link Vold}.
     * 
     * @param uuid
     * @param address
     * @param port
     * @throws JMException
     * @return The {@link UUID} of the task handling the operation as a String
     */

#Code:
    final String addPeerNoWait(final String uuid, final String address, final int port, final DtxTaskApi dtxTaskApi)
            throws JMException {
        // 1) check parameters
        Objects.requireNonNull(uuid, "Uuid parameter not provided !");
        Objects.requireNonNull(address, "Ip address parameter not provided !");
        checkPortRange(port);
        final VoldLocation localPeer = vold.getVoldLocation();
        if (UUID.fromString(uuid) == localPeer.getNode()) {
            throw new IllegalArgumentException("Can't add local peer='" + uuid + "' !");
        }

        final String newPeer = uuid + "@" + address + ":" + port;
        final VoldLocation location = VoldLocation.fromString(newPeer);

        final InetAddress addrTmp = location.getSockAddr().getAddress();
        if (addrTmp == null) {
            throw new IllegalArgumentException("address='" + addrTmp + "' unresolved !");
        }

        // 2) Submit transaction
        if (dtxTaskApi == null) {
            throw new IllegalArgumentException("Can't start transaction without DTX manager !");
        }
        return submitAddPeerTaskNoWait(location.getNode(), location.getSockAddr(), dtxTaskApi).toString();
    }

#end
#end
#No. 182503
#File: E:\bishe\1\VoldPeers.java
#Comment:
    /**
     * Remove a peer from the {@link Vold}.
     * 
     * @param peer
     * @throws JMException
     */

#Code:
    final void removePeer(@Nonnull final String uuid, final DtxTaskApi dtxTaskApi) throws JMException {
        // 1) check parameters
        Objects.requireNonNull(uuid, "Uuid parameter not provided !");
        final UUID node = UUID.fromString(uuid);
        final VoldLocation localPeer = vold.getVoldLocation();
        if (UUID.fromString(uuid) == localPeer.getNode()) {
            LOGGER.debug("Will remove local peer='" + uuid + "' !");
        }

#end
#end
#No. 182504
#File: E:\bishe\1\VoldPeers.java
#Comment:
    /**
     * Remove a peer from the {@link Vold}.
     * 
     * @param peer
     * @throws JMException
     * @return The {@link UUID} of the task handling the operation as a String
     */

#Code:
    final String removePeerNoWait(final String uuid, final DtxTaskApi dtxTaskApi) throws JMException {
        // 1) check parameters
        Objects.requireNonNull(uuid, "Uuid parameter not provided !");
        final UUID node = UUID.fromString(uuid);
        final VoldLocation localPeer = vold.getVoldLocation();
        if (UUID.fromString(uuid) == localPeer.getNode()) {
            LOGGER.debug("Will remove local peer='" + uuid + "' !");
        }

        // 2) Submit transaction
        if (dtxTaskApi == null) {
            throw new IllegalArgumentException("Can't start transaction without DTX manager !");
        }
        return submitRemovePeerTaskNoWait(node, dtxTaskApi).toString();
    }

#end
#end
#No. 182505
#File: E:\bishe\1\VoldPeers.java
#Comment:
    /**
     * Wait for a task end.
     * 
     * @param taskId
     */

#Code:
    private final void waitTaskEnd(@Nonnull final UUID taskId, @Nonnull final DtxTaskApi dtxTaskApi) {

        // Wait for task end
        final DtxTaskFutureVoid future = new DtxTaskFutureVoid(taskId, dtxTaskApi);
        try {
            future.get();
        }

#end
#end
#No. 182506
#File: E:\bishe\1\VoldPeers.java
#Comment:
    /**
     * Submit a SET transaction
     * 
     * @param opBuilder
     * @return
     */

#Code:
    private final UUID submitSetTransaction(@Nonnull final RemoteOperation.Builder opBuilder,
            @Nonnull final DtxTaskApi dtxTaskApi) {
        final UUID ownerUuid = vold.getOwnerUuid();
        final UUID nodeUuid = vold.getNodeUuid();
        final Uuid msgSource = VvrRemoteUtils.newUuid(nodeUuid);
        final UUID resourceId = ownerUuid;

        // for debug message in exceptions only
        opBuilder.setUuid(msgSource);

        final UUID taskId = VvrRemoteUtils.submitTransaction(opBuilder, dtxTaskApi, resourceId, msgSource, Type.VOLD,
                OpCode.SET);
        return taskId;
    }

}
}

#end
#end
#No. 182507
#File: E:\bishe\1\VoldTargetType.java
#Comment:
/**
 * Type of the target for a task.
 * 
 * @author oodrive
 * @author jmcaba
 */

#Code:
public enum VoldTargetType {
    VOLD;
}

#end
#end
#No. 182508
#File: E:\bishe\1\VoldTaskInfo.java
#Comment:
    /**
     * Gets the Operation of the task. May be not be null.
     * 
     * @return the operation of the task
     */

#Code:
    public final VoldTaskOperation getOperation() {
        return this.operation;
    }

#end
#end
#No. 182509
#File: E:\bishe\1\VoldTaskInfo.java
#Comment:
    /**
     * Gets the target type of the task. May be not be null.
     * 
     * @return the type of the target
     */

#Code:
    public final VoldTargetType getTargetType() {
        return this.targetType;
    }

#end
#end
#No. 182510
#File: E:\bishe\1\VoldTaskInfo.java
#Comment:
    /**
     * Gets the target ID of the task. May be not be null.
     * 
     * @return the ID of the target
     */

#Code:
    public final String getTargetId() {
        return this.targetId;
    }

#end
#end
#No. 182511
#File: E:\bishe\1\VoldTaskOperation.java
#Comment:
/**
 * Operation of a vold manager task
 * 
 * @author oodrive
 * @author jmcaba
 */

#Code:
public enum VoldTaskOperation {
    ADD_PEER, REMOVE_PEER;
}

#end
#end
#No. 182512
#File: E:\bishe\1\Volley.java
#Comment:
    /**
     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.
     * You may set a maximum size of the disk cache in bytes.
     *
     * @param context A {@link Context} to use for creating the cache dir.
     * @param stack An {@link HttpStack} to use for the network, or null for default.
     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.
     * @return A started {@link RequestQueue} instance.
     */

#Code:
    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {
        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);

        String userAgent = "volley/0";
        try {
            String packageName = context.getPackageName();
            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
            userAgent = packageName + "/" + info.versionCode;
        } catch (NameNotFoundException e) {
        }

        if (stack == null) {
            if (Build.VERSION.SDK_INT >= 9) {
                stack = new HurlStack();
            } else {
                // Prior to Gingerbread, HttpUrlConnection was unreliable.
                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));
            }
        }

        Network network = new BasicNetwork(stack);
        
        RequestQueue queue;
        if (maxDiskCacheBytes <= -1)
        {
        	// No maximum size specified
        	queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
        }
        else
        {
        	// Disk cache size specified
        	queue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network);
        }

        queue.start();

        return queue;
    }

#end
#end
#No. 182513
#File: E:\bishe\1\Volley.java
#Comment:
    /**
     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.
     * You may set a maximum size of the disk cache in bytes.
     *
     * @param context A {@link Context} to use for creating the cache dir.
     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.
     * @return A started {@link RequestQueue} instance.
     */

#Code:
    public static RequestQueue newRequestQueue(Context context, int maxDiskCacheBytes) {
        return newRequestQueue(context, null, maxDiskCacheBytes);
    }

#end
#end
#No. 182514
#File: E:\bishe\1\Volley.java
#Comment:
    /**
     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.
     *
     * @param context A {@link Context} to use for creating the cache dir.
     * @param stack An {@link HttpStack} to use for the network, or null for default.
     * @return A started {@link RequestQueue} instance.
     */

#Code:
    public static RequestQueue newRequestQueue(Context context, HttpStack stack)
    {
    	return newRequestQueue(context, stack, -1);
    }

#end
#end
#No. 182515
#File: E:\bishe\1\Volley.java
#Comment:
    /**
     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.
     *
     * @param context A {@link Context} to use for creating the cache dir.
     * @return A started {@link RequestQueue} instance.
     */

#Code:
    public static RequestQueue newRequestQueue(Context context) {
        return newRequestQueue(context, null);
    }

#end
#end
#No. 182516
#File: E:\bishe\1\VolleyBall.java
#Comment:
    /**
     * Creates a default instance of the worker pool and calls {@link com.android.volley.RequestQueue#start()} on it.
     *
     * @param context A {@link android.content.Context} to use for creating the cache dir.
     * @param stack An {@link com.android.volley.toolbox.HttpStack} to use for the network, or null for default.
     * @return A started {@link com.android.volley.RequestQueue} instance.
     */

#Code:
    public static BallRequestQueue newRequestQueue(Context context, HttpStack stack) {
        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);

        String userAgent = "volley/0";
        try {
            String packageName = context.getPackageName();
            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
            userAgent = packageName + "/" + info.versionCode;
        } catch (NameNotFoundException e) {
        }

        if (stack == null) {
            if (Build.VERSION.SDK_INT >= 9) {
                stack = new HurlStack();
            } else {
                // Prior to Gingerbread, HttpUrlConnection was unreliable.
                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));
            }
        }

        Network network = new BasicNetwork(stack);

        BallRequestQueue queue = new BallRequestQueue(new DiskBasedCache(cacheDir), network);
        queue.start();

        return queue;
    }

#end
#end
#No. 182517
#File: E:\bishe\1\VolleyBall.java
#Comment:
    /**
     * Creates a default instance of the worker pool and calls {@link com.android.volley.RequestQueue#start()} on it.
     *
     * @param context A {@link android.content.Context} to use for creating the cache dir.
     * @return A started {@link com.android.volley.RequestQueue} instance.
     */

#Code:
    public static BallRequestQueue newRequestQueue(Context context) {
        return newRequestQueue(context, null);
    }

#end
#end
#No. 182518
#File: E:\bishe\1\VolleyDemoFragment.java
#Comment:
  /**
   * Creates and returns an observable generated from the Future returned from {@code
   * getRouteData()}. The observable can then be subscribed to as shown in {@code
   * startVolleyRequest()}
   *
   * @return Observable<JSONObject>
   */

#Code:
  public Flowable<JSONObject> newGetRouteData() {
    return Flowable.defer(
        () -> {
          try {
            return Flowable.just(getRouteData());
          } catch (InterruptedException | ExecutionException e) {
            Log.e("routes", e.getMessage());
            return Flowable.error(e);
          }
        });
  }

#end
#end
#No. 182519
#File: E:\bishe\1\VolleyDemoFragment.java
#Comment:
  /**
   * Converts the Asynchronous Request into a Synchronous Future that can be used to block via
   * {@code Future.get()}. Observables require blocking/synchronous functions
   *
   * @return JSONObject
   * @throws ExecutionException
   * @throws InterruptedException
   */

#Code:
  private JSONObject getRouteData() throws ExecutionException, InterruptedException {
    RequestFuture<JSONObject> future = RequestFuture.newFuture();
    String url = "http://www.weather.com.cn/adat/sk/101010100.html";
    JsonObjectRequest req = new JsonObjectRequest(Request.Method.GET, url, future, future);
    MyVolley.getRequestQueue().add(req);
    return future.get();
  }


#end
#end
#No. 182521
#File: E:\bishe\1\VolleyHttpClient.java
#Comment:
    /**
     *
     * @param url
     * @param clazz
     * @param listener
     * @param errorListener
     * @param keys
     * @param values
     */

#Code:
    public  void getWithParams(String url, Class clazz, Response.Listener listener,  Response.ErrorListener errorListener, String[] keys, String[] values){

        Map<String, String> params = new HashMap<String, String>();
        for (int i = 0; i < keys.length; i++) {
            params.put(keys[i], values[i]);
        }

        GsonRequest request = new GsonRequest(Request.Method.GET, getAbsoluteUrl(url), clazz, null, params, listener, errorListener);



        HttpService.httpQueue.getCache().invalidate(getAbsoluteUrl(url), true);
        if(!NetWorkUtils.detect(httpService.getContext()))
        {

            if (HttpService.httpQueue.getCache().get(getAbsoluteUrl(url)) !=null){
                String cacheStr = new String(HttpService.httpQueue.getCache().get(getAbsoluteUrl(url)).data);

                if (cacheStr != null){

                    try {

                        listener.onResponse(gson.fromJson(cacheStr, clazz));

                    } catch (JsonSyntaxException e) {
                        e.printStackTrace();
                    }

                    return;
                }


            }


            return;

        }
        httpService.addToRequestQueue(request);
    }

#end
#end
#No. 182522
#File: E:\bishe\1\VolleyHttpClient.java
#Comment:
    /**
     *
     * @param url
     * @param clazz
     * @param listener
     * @param errorListener
     */

#Code:
    public  void post(String url, Class clazz, Response.Listener listener,  Response.ErrorListener errorListener) {


        postWithHeader(url, clazz, null, listener, errorListener);

    }

#end
#end
#No. 182523
#File: E:\bishe\1\VolleyHttpClient.java
#Comment:
    /**
     *
     * @param url
     * @param clazz
     * @param params
     * @param listener
     * @param errorListener
     */

#Code:
    public  void postWithParams(String url, Class clazz, Map<String, String> params, Response.Listener listener,  Response.ErrorListener errorListener){

        GsonRequest request = new GsonRequest(Request.Method.POST, getAbsoluteUrl(url), clazz, null, params, listener, errorListener);

        httpService.addToRequestQueue(request);
    }

#end
#end
#No. 182524
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * get scaled bitmap
     * @param filePath  local file path
     * @param maxWidth  scaled bitmap width you desired, if maxWidth < maxHeight, then scaled
     *                  bitmap width is maxWidth while bitmap height is maxWidth * ratio
     * @param maxHeight scaled bitmap height you desired, if maxHeight < maxWidth, then scaled
     *                  bitmap height is maxHeight while bitmap width is maxHeight / ratio.
     * @return scaled bitmap
     */

#Code:
    public static Bitmap getScaledBitmap(String filePath, int maxWidth, int maxHeight) {
        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();
        Bitmap bitmap;
        // If we have to resize this image, first get the natural bounds.
        decodeOptions.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(filePath, decodeOptions);
        int actualWidth = decodeOptions.outWidth;
        int actualHeight = decodeOptions.outHeight;
        Log.d(TAG, "Actual width: " + actualWidth + ", actual height: " + actualHeight);
        // Then compute the dimensions we would ideally like to decode to.
        int desiredWidth = getResizedDimension(maxWidth, maxHeight,
                actualWidth, actualHeight);
        int desiredHeight = getResizedDimension(maxHeight, maxWidth,
                actualHeight, actualWidth);
        Log.d(TAG, "Desired width: " + desiredWidth + ", desired height: " + desiredHeight);

        // Decode to the nearest power of two scaling factor.
        decodeOptions.inJustDecodeBounds = false;
        // TODO(ficus): Do we need this or is it okay since API 8 doesn't support it?
        // decodeOptions.inPreferQualityOverSpeed = PREFER_QUALITY_OVER_SPEED;
        decodeOptions.inSampleSize =
                findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);
        Bitmap tempBitmap = BitmapFactory.decodeFile(filePath, decodeOptions);
        // If necessary, scale down to the maximal acceptable size.
        if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth ||
                tempBitmap.getHeight() > desiredHeight)) {
            bitmap = Bitmap.createScaledBitmap(tempBitmap,
                    desiredWidth, desiredHeight, true);
            tempBitmap.recycle();
        } else {
            bitmap = tempBitmap;
        }
        return bitmap;
    }

#end
#end
#No. 182525
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * get scaled bitmap
     * @param imageResId image resource id
     * @param maxWidth  scaled bitmap width you desired, if maxWidth < maxHeight, then scaled
     *                  bitmap width is maxWidth while bitmap height is maxWidth * ratio
     * @param maxHeight scaled bitmap height you desired, if maxHeight < maxWidth, then scaled
     *                  bitmap height is maxHeight while bitmap width is maxHeight / ratio.
     * @return scaled bitmap
     */

#Code:
    public static Bitmap getScaledBitmap(Context context, int imageResId, int maxWidth, int maxHeight) {
        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();
        Bitmap bitmap = null;
        // If we have to resize this image, first get the natural bounds.
        decodeOptions.inJustDecodeBounds = true;
        BitmapFactory.decodeResource(context.getResources(), imageResId, decodeOptions);
        int actualWidth = decodeOptions.outWidth;
        int actualHeight = decodeOptions.outHeight;
        Log.d(TAG, "Actual width: " + actualWidth + ", actual height: " + actualHeight);

        // Then compute the dimensions we would ideally like to decode to.
        int desiredWidth = getResizedDimension(maxWidth, maxHeight,
                actualWidth, actualHeight);
        int desiredHeight = getResizedDimension(maxHeight, maxWidth,
                actualHeight, actualWidth);
        Log.d(TAG, "Desired width: " + desiredWidth + ", desired height: " + desiredHeight);

        // Decode to the nearest power of two scaling factor.
        decodeOptions.inJustDecodeBounds = false;
        // TODO(ficus): Do we need this or is it okay since API 8 doesn't support it?
        // decodeOptions.inPreferQualityOverSpeed = PREFER_QUALITY_OVER_SPEED;
        decodeOptions.inSampleSize =
                findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);
        Bitmap tempBitmap = BitmapFactory.decodeResource(context.getResources(), imageResId, decodeOptions);
        // If necessary, scale down to the maximal acceptable size.
        if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth ||
                tempBitmap.getHeight() > desiredHeight)) {
            bitmap = Bitmap.createScaledBitmap(tempBitmap,
                    desiredWidth, desiredHeight, true);
            tempBitmap.recycle();
        } else {
            bitmap = tempBitmap;
        }
        return bitmap;
    }

#end
#end
#No. 182526
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * Returns the largest power-of-two divisor for use in downscaling a bitmap
     * that will not result in the scaling past the desired dimensions.
     *
     * @param actualWidth Actual width of the bitmap
     * @param actualHeight Actual height of the bitmap
     * @param desiredWidth Desired width of the bitmap
     * @param desiredHeight Desired height of the bitmap
     */

#Code:
    // Visible for testing.
    private static int findBestSampleSize(
            int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) {
        double wr = (double) actualWidth / desiredWidth;
        double hr = (double) actualHeight / desiredHeight;
        double ratio = Math.min(wr, hr);
        float n = 1.0f;
        while ((n * 2) <= ratio) {
            n *= 2;
        }

        return (int) n;
    }

#end
#end
#No. 182527
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * Scales one side of a rectangle to fit aspect ratio.
     *
     * @param maxPrimary Maximum size of the primary dimension (i.e. width for
     *        max width), or zero to maintain aspect ratio with secondary
     *        dimension
     * @param maxSecondary Maximum size of the secondary dimension, or zero to
     *        maintain aspect ratio with primary dimension
     * @param actualPrimary Actual size of the primary dimension
     * @param actualSecondary Actual size of the secondary dimension
     */

#Code:
    private static int getResizedDimension(int maxPrimary, int maxSecondary, int actualPrimary,
                                          int actualSecondary) {
        // If no dominant value at all, just return the actual.
        if (maxPrimary == 0 && maxSecondary == 0) {
            return actualPrimary;
        }

        // If primary is unspecified, scale primary to match secondary's scaling ratio.
        if (maxPrimary == 0) {
            double ratio = (double) maxSecondary / (double) actualSecondary;
            return (int) (actualPrimary * ratio);
        }

        if (maxSecondary == 0) {
            return maxPrimary;
        }

        double ratio = (double) actualSecondary / (double) actualPrimary;
        int resized = maxPrimary;
        if (resized * ratio > maxSecondary) {
            resized = (int) (maxSecondary / ratio);
        }
        return resized;
    }

#end
#end
#No. 182528
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * get actual image dimension
     * @param imagePath local file path
     * @return
     */

#Code:
    public static int[] getActualImageDimension(String imagePath) {
        int[] imageSize = new int[2];
        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();
        // If we have to resize this image, first get the natural bounds.
        decodeOptions.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(imagePath, decodeOptions);
        int actualWidth = decodeOptions.outWidth;
        int actualHeight = decodeOptions.outHeight;
        imageSize[0] = actualWidth;
        imageSize[1] = actualHeight;
        return imageSize;
    }

#end
#end
#No. 182529
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * get actual image dimension
     * @param imageResId image resource id
     * @return
     */

#Code:
    public static int[] getActualImageDimension(Context context, int imageResId) {
        int[] imageSize = new int[2];
        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();
        // If we have to resize this image, first get the natural bounds.
        decodeOptions.inJustDecodeBounds = true;
        BitmapFactory.decodeResource(context.getResources(), imageResId, decodeOptions);
        int actualWidth = decodeOptions.outWidth;
        int actualHeight = decodeOptions.outHeight;
        imageSize[0] = actualWidth;
        imageSize[1] = actualHeight;
        return imageSize;
    }

#end
#end
#No. 182530
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * compress the image file, create a scaled compressed image file, and overwrite the origin one.
     * @param path  origin image file path
     * @param maxWidth
     * @param maxHeight
     * @param quality
     */

#Code:
    public static void compress(String path, int maxWidth, int maxHeight, int quality) {
        FileOutputStream out;
        try {
            Bitmap scaledBitmap = getScaledBitmap(path, maxWidth, maxHeight);
            Bitmap rotatedBitmap = rotateBitmap(getBitmapDegree(path), scaledBitmap);
            out = new FileOutputStream(path);
            Bitmap mutableBitmap = rotatedBitmap.copy(Bitmap.Config.ARGB_8888, true);

            // write the compressed bitmap at the destination specified by filename.
            mutableBitmap.compress(Bitmap.CompressFormat.JPEG, quality, out);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

#end
#end
#No. 182531
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * compress the image file, create a scaled compressed image file, and overwrite the origin one.
     * @param path  origin image file path
     * @param maxWidth
     * @param maxHeight
     * @param quality
     */

#Code:
    public static void compress(String originPath, String outputPath, int maxWidth, int maxHeight, int quality) {
        FileOutputStream out;
        try {
            Bitmap scaledBitmap = getScaledBitmap(originPath, maxWidth, maxHeight);
            Bitmap rotatedBitmap = rotateBitmap(getBitmapDegree(originPath), scaledBitmap);
            out = new FileOutputStream(outputPath);
            Bitmap mutableBitmap = rotatedBitmap.copy(Bitmap.Config.ARGB_8888, true);

            // write the compressed bitmap at the destination specified by filename.
            mutableBitmap.compress(Bitmap.CompressFormat.JPEG, quality, out);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

#end
#end
#No. 182532
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * add water mark at the left top of image.
     * @param context
     * @param srcPath   local image file path
     * @param watermarkRes  watermark resource
     * @param maxWidth scaled bitmap width you desired, if maxWidth < maxHeight, then scaled
     *                  bitmap width is maxWidth while bitmap height is maxWidth * ratio
     * @param maxHeight scaled bitmap height you desired, if maxHeight < maxWidth, then scaled
     *                  bitmap height is maxHeight while bitmap width is maxHeight / ratio.
     * @param quality compress quality
     */

#Code:
    // http://developer.android.com/training/displaying-bitmaps/load-bitmap.html
    public static void watermark(Context context, String srcPath, int watermarkRes, int maxWidth, int maxHeight, int quality) {

        FileOutputStream out;
        try {
            Bitmap scaledBitmap = getScaledBitmap(srcPath, maxWidth, maxHeight);
            Bitmap rotatedBitmap = rotateBitmap(getBitmapDegree(srcPath), scaledBitmap);
            Bitmap scaledWatermark = getScaledBitmap(context, watermarkRes, maxWidth, maxHeight);
            out = new FileOutputStream(srcPath);

            Bitmap mutableBitmap = rotatedBitmap.copy(Bitmap.Config.ARGB_8888, true);
            Canvas canvas = new Canvas(mutableBitmap);
            canvas.drawBitmap(scaledWatermark, 0, 0, null);

            // write the compressed bitmap at the destination specified by filename.
            mutableBitmap.compress(Bitmap.CompressFormat.JPEG, quality, out);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (OutOfMemoryError e) {
            Log.e(TAG, "Add watermark result in OOM");
            e.printStackTrace();
        }
    }

#end
#end
#No. 182533
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * add watermark at the right bottom of the image
     * @param context
     * @param srcPath   local image file path
     * @param watermarkRes  watermark resource
     * @param maxWidth scaled bitmap width you desired, if maxWidth < maxHeight, then scaled
     *                  bitmap width is maxWidth while bitmap height is maxWidth * ratio
     * @param maxHeight scaled bitmap height you desired, if maxHeight < maxWidth, then scaled
     *                  bitmap height is maxHeight while bitmap width is maxHeight / ratio.
     * @param quality compress quality
     */

#Code:
    public static void watermarkAtRightBottom(Context context, String srcPath, int watermarkRes, int maxWidth, int maxHeight, int quality) {

        FileOutputStream out;
        try {
            Bitmap scaledBitmap = getScaledBitmap(srcPath, maxWidth, maxHeight);
            Bitmap rotatedBitmap = rotateBitmap(getBitmapDegree(srcPath), scaledBitmap);
            Bitmap scaledWatermark = getScaledBitmap(context, watermarkRes, maxWidth, maxHeight);
            out = new FileOutputStream(srcPath);

            int left = rotatedBitmap.getWidth() - scaledWatermark.getWidth();
            int top = rotatedBitmap.getHeight() - scaledWatermark.getHeight();

            Bitmap mutableBitmap = rotatedBitmap.copy(Bitmap.Config.ARGB_8888, true);
            Canvas canvas = new Canvas(mutableBitmap);
            canvas.drawBitmap(scaledWatermark, left, top, null);

            // write the compressed bitmap at the destination specified by filename.
            mutableBitmap.compress(Bitmap.CompressFormat.JPEG, quality, out);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (OutOfMemoryError e) {
            Log.e(TAG, "Add watermark result in OOM");
            e.printStackTrace();
        }
    }

#end
#end
#No. 182534
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * get bitmap degree, you may get an rotated photo when you take a picture in some devices.
     * @param path local image file path
     * @return
     */

#Code:
    public static int getBitmapDegree(String path) {
        int degree  = 0;
        try {
            ExifInterface exifInterface = new ExifInterface(path);
            int orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
            switch (orientation) {
                case ExifInterface.ORIENTATION_ROTATE_90:
                    degree = 90;
                    break;
                case ExifInterface.ORIENTATION_ROTATE_180:
                    degree = 180;
                    break;
                case ExifInterface.ORIENTATION_ROTATE_270:
                    degree = 270;
                    break;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return degree;
    }

#end
#end
#No. 182535
#File: E:\bishe\1\VolleyImageUtils.java
#Comment:
    /**
     * rotate bitmap
     * @param angle rotate angle
     * @param bitmap origin bitmap
     * @return rotated bitmap
     */

#Code:
    public static Bitmap rotateBitmap(int angle, Bitmap bitmap) {
        Matrix matrix = new Matrix();
        matrix.postRotate(angle);
        return Bitmap.createBitmap(bitmap, 0, 0,
                bitmap.getWidth(), bitmap.getHeight(), matrix, true);
    }



#end
#end
#No. 182542
#File: E:\bishe\1\Volta.java
#Comment:
	/**
	 * Gets the index of the measure, where this volta ends (inclusive).
	 */

#Code:
	public int getEndMeasureIndex() {
		return getMP().measure + length - 1;
	}

#end
#end
#No. 182543
#File: E:\bishe\1\VoltageDecryptor.java
#Comment:
    /**
     * @param socialSecurityNumber
     * @return returns java.lang.String
     * @throws FaultResponse
     */

#Code:
    @Override
    public String accessSocialSecurityNumber(String socialSecurityNumber) throws FaultResponse {
        return service.accessSocialSecurityNumber(socialSecurityNumber, IDENTITY, "", false, com.kunai.keyvault.crypto.voltage.vibesimple.AuthMethod.SHARED_SECRET, AUTHINFO);
    }

#end
#end
#No. 182544
#File: E:\bishe\1\VoltageDecryptor.java
#Comment:
    /**
     * @param dataIn
     * @param format
     * @return returns java.lang.String
     * @throws FaultResponse
     */

#Code:
    @Override
    public String accessFormattedData(String dataIn, String format) throws FaultResponse {
        return service.accessFormattedData(dataIn, format, IDENTITY, "", com.kunai.keyvault.crypto.voltage.vibesimple.AuthMethod.SHARED_SECRET, AUTHINFO);
    }

#end
#end
#No. 182545
#File: E:\bishe\1\VoltageDecryptor.java
#Comment:
    /**
     * @param dataIn
     * @return returns byte[]
     * @throws FaultResponse
     */

#Code:
    @Override
    public String accessGenericData(String dataIn) throws FaultResponse {
        return service.accessGenericStringData(dataIn, IDENTITY, "", false, com.kunai.keyvault.crypto.voltage.vibesimple.AuthMethod.SHARED_SECRET, AUTHINFO);
    }

#end
#end
#No. 182546
#File: E:\bishe\1\VoltageEncryptor.java
#Comment:
    /**
     * @param socialSecurityNumber
     * @return returns java.lang.String
     * @throws FaultResponse
     */

#Code:
    @Override
    public String protectSocialSecurityNumber(String socialSecurityNumber) throws FaultResponse {
        return service.protectSocialSecurityNumber(socialSecurityNumber, IDENTITY, "", com.kunai.keyvault.crypto.voltage.vibesimple.AuthMethod.SHARED_SECRET, AUTHINFO);
    }

#end
#end
#No. 182547
#File: E:\bishe\1\VoltageEncryptor.java
#Comment:
    /**
     * @param dataIn
     * @param format
     * @return returns java.lang.String
     * @throws FaultResponse
     */

#Code:
    @Override
    public String protectFormattedData(String dataIn, String format) throws FaultResponse {
        return service.protectFormattedData(dataIn, format, IDENTITY, "", com.kunai.keyvault.crypto.voltage.vibesimple.AuthMethod.SHARED_SECRET, AUTHINFO);
    }

#end
#end
#No. 182548
#File: E:\bishe\1\VoltageEncryptor.java
#Comment:
    /**
     * @param dataIn
     * @return returns byte[]
     * @throws FaultResponse
     */

#Code:
    @Override
    public String protectGenericData(String dataIn) throws FaultResponse {
        return service.protectGenericStringData(dataIn, IDENTITY, false, com.kunai.keyvault.crypto.voltage.vibesimple.AuthMethod.SHARED_SECRET, AUTHINFO, "");
    }

#end
#end
#No. 182549
#File: E:\bishe\1\VoltageValue.java
#Comment:
/**
 * Represents Voltage Value Object.
 */

#Code:
class VoltageValue extends AbstractSensorCommandValue {

	VoltageValue(CommandResult commandResult) {
		super(commandResult);
	}

	@Override
	protected float calculateValue() {
		return 0;
	}
}

#end
#end
#No. 182550
#File: E:\bishe\1\VoltaGroup.java
#Comment:
	/**
	 * Returns whether this time is the last time to repeat.
	 * @deprecated unneeded
	 */

#Code:
	private boolean isLastTime(int repeatTime) {
		return (repeatTime == getRepeatCount());
	}

#end
#end
#No. 182551
#File: E:\bishe\1\VoltaGroup.java
#Comment:
	/**
	 * Gets the number of repetitions.
	 * See {@link Volta} for the playback rules.
	 * Notice, that the actual playback could be different,
	 * e.g. when a volta contains a jump (e.g. coda) to another
	 * measure.
	 */

#Code:
	public int getRepeatCount() {
		//find maximum repeat number (+1, if the last volta is a default volta)
		int maxRepeatTime = 0;
		for (val v : voltasStartMeasures) {
			if (false == v.volta.isDefault())
				maxRepeatTime = max(maxRepeatTime, v.volta.getNumbers().getStop());
			else
				maxRepeatTime = max(maxRepeatTime, 1); //enter default volta at least one time
		}
		if (voltasStartMeasures.size() > 1 && //when there is at least one other volta before a final default volta
				voltasStartMeasures.getLast().volta.isDefault()) {
			maxRepeatTime += 1;
		}
		return maxRepeatTime;
	}

#end
#end
#No. 182552
#File: E:\bishe\1\VoltaGroup.java
#Comment:
	/**
	 * Gets the volta and start measure where to jump into when
	 * the volta group is reached the given time.
	 * When there is no repeat for the given time, null is returned.
	 */

#Code:
	@MaybeNull public VoltaStartMeasure findVolta(int repeatTime) {
		if (repeatTime < 1 || repeatTime > getRepeatCount())
			return null;
		//find explicit number in voltas first
		for (val v : voltasStartMeasures) {
			if (false == v.volta.isDefault() && v.volta.getNumbers().isInRange(repeatTime))
				return v;
		}

#end
#end
#No. 182553
#File: E:\bishe\1\VoltaGroup.java
#Comment:
	/**
	 * Returns the number of measures in the group.
	 */

#Code:
	public int getMeasuresCount() {
		int length = 0;
		for (val v : voltasStartMeasures)
			length += v.volta.getLength();
		return length;
	}

#end
#end
#No. 182554
#File: E:\bishe\1\VoltaGroups.java
#Comment:
	/**
	 * Gets the {@link Volta} and its start measure over the given measure.
	 */

#Code:
	@MaybeNull public VoltaStartMeasure getVoltaAt(int measure) {
		val group = getVoltaGroupAt(measure);
		if (group == null)
			return null;
		VoltaStartMeasure volta = null;
		for (val v : group.voltasStartMeasures) {
			volta = v;
			if (measure < v.startMeasure + v.volta.getLength())
				break;
		}


#end
#end
#No. 182556
#File: E:\bishe\1\VoltaStamping.java
#Comment:
/**
 * Class for a volta stamping belonging to a staff.
 * 
 * It has a vertical position (line position of the
 * horizontal volta line), and optionally a left downward
 * hook and a right downward hook. Optionally, there may
 * be a {@link FormattedText} left-aligned under the
 * volta line.
 * 
 * Many values are optional, since voltas can contain
 * line breaks, and e.g. a left hook and text is only used
 * in the first system, but not in the following ones.
 *
 * @author Andreas Wenger
 */

#Code:
@Const @AllArgsConstructor @Getter
public final class VoltaStamping
	extends Stamping {

	/** The stamped element. */
	public final Volta element;
	/** The line position of the horizontal line. */
	public final float lp;
	/** The horizontal start position in mm relative to the beginning of the staff. */
	public final float leftXMm;
	/** The horizontal end position in mm relative to the beginning of the staff. */
	public final float rightXMm;
	/** The caption of the volta (or null). */
	@MaybeNull public final FormattedText text;
	/** True, if there is a left downward hook, else false. */
	public final boolean leftHook;
	/** True, if there is a right downward hook, else false. */
	public final boolean rightHook;
	/** The parent staff. */
	public final StaffStamping parentStaff;
	

	@Override public StampingType getType() {
		return StampingType.VoltaStamping;
	}

#end
#end
#No. 182557
#File: E:\bishe\1\VolumeAttachmentStatus.java
#Comment:
/**
 * Created by sandorr
 * 2/14/2017.
 */

#Code:
public enum VolumeAttachmentStatus {
    ATTACHING,
    ATTACHED,
    DETACHING,
    DETACHED;

    public static final String INVALID_ATTACHMENT_STATUS_VALUE_FORMAT = "Invalid attachment.status value: [%s]. Valid values: attaching, attached, detaching, detached.";

    public static String getValue(@NotNull final String input) {
        if (isBlank(input)) {
            return NOT_RELEVANT;
        }

        for (final VolumeAttachmentStatus volumeAttachmentStatus : VolumeAttachmentStatus.values()) {
            if (volumeAttachmentStatus.name().equalsIgnoreCase(input)) {
                return volumeAttachmentStatus.name().toLowerCase();
            }
        }

        throw new RuntimeException(String.format(INVALID_ATTACHMENT_STATUS_VALUE_FORMAT, input));
    }

#end
#end
#No. 182558
#File: E:\bishe\1\VolumeButtonsListener.java
#Comment:
	/**
	* 	Constructor of the VolumeButtonsListener class
	* 
	* 	@date		27/02/2014
	* 	@version	0.0.1
	* 	@author	ManuelDeveloper(manueldeveloper@gmail.com) 
	*/

#Code:
	public VolumeButtonsListener(){
		volumeCallbackContext= null;
	}

#end
#end
#No. 182559
#File: E:\bishe\1\VolumeButtonsListener.java
#Comment:
	/**
	* 	Method which executes the Javascript request
	*
	*	@param		action: String object with the action to execute
	*	@param		args: JSONArray object with the arguments of the request
	*	@param		callbackContext: CallbackContext object for call back into Javascript
	*
	*	@return		"boolean" which indicates if the action is valid (true) or not (false)
	* 
	* 	@date		10/12/2016
	* 	@version	0.0.3
	* 	@author	ManuelDeveloper(manueldeveloper@gmail.com) 
	*/

#Code:
	public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException {

		// Check the action
		if( action.equals("start") ){

			// Check if the plugin is listening the volume button events
			if( this.volumeCallbackContext != null ){

				callbackContext.error("Volume buttons listener already running");
				return true;	
			}

			// Get the reference to the callbacks and start the listening process
			this.volumeCallbackContext= callbackContext;
			this.webView.getView().setOnKeyListener(this);

			// Don't return any result now
			PluginResult pluginResult= new PluginResult(PluginResult.Status.NO_RESULT);
			pluginResult.setKeepCallback(true);
			this.volumeCallbackContext.sendPluginResult(pluginResult);
			return true;
		}
		else if( action.equals("stop") ){

			// Erase the callbacks reference and stop the listening process
			sendSignal(new JSONObject(), false); // release status callback in Javascript side
			this.volumeCallbackContext= null;
			this.webView.getView().setOnKeyListener(null);
			callbackContext.success();
			return true;			
		}

		return false;
	}

#end
#end
#No. 182560
#File: E:\bishe\1\VolumeButtonsListener.java
#Comment:
	/**
	* 	Overwritten method for Android application lifecycle. It stops the key events listening process
	* 
	* 	@date		10/12/2016
	* 	@version	0.0.3
	* 	@author	ManuelDeveloper(manueldeveloper@gmail.com) 
	*/

#Code:
	public void onDestroy(){

		// Stop the listening process
		this.webView.getView().setOnKeyListener(null);
	}

#end
#end
#No. 182561
#File: E:\bishe\1\VolumeButtonsListener.java
#Comment:
	/**
	* 	Overwritten method for Android application lifecycle. It stops the key events listening process
	* 
	* 	@date		10/12/2016
	* 	@version	0.0.3
	* 	@author	ManuelDeveloper(manueldeveloper@gmail.com) 
	*/

#Code:
	public void onReset(){
		
		// Stop the listening process
		this.webView.getView().setOnKeyListener(null);
	}

#end
#end
#No. 182562
#File: E:\bishe\1\VolumeButtonsListener.java
#Comment:
	/**
	* 	Overwritten method to receive the Android key events
	*
	*	@param		view: View object who emit the signal (CordovaWebView)
	*	@param		keyCode: int with the identifier of the pressed key
	*	@param		keyEvent: KeyEvent object with the information of the event
	*
	*	@return		"boolean" which indicates if the listener has consumed the event (true) or not (false) [Always false to allow that the event spreading]
	* 
	* 	@date		10/12/2016
	* 	@version	0.0.3
	* 	@author	ManuelDeveloper(manueldeveloper@gmail.com) 
	*/

#Code:
	public boolean onKey(View view, int keyCode, KeyEvent keyEvent) {

		// Check if the event is equal to KEY_DOWN
		if( keyEvent.getAction() == KeyEvent.ACTION_DOWN )
		{
			// Check what button has been pressed
			if( keyCode == KeyEvent.KEYCODE_VOLUME_UP ){

				// Create a new JSONObject with the information and send it
				JSONObject info= new JSONObject();
				try{
					info.put("signal", new String("volume-up"));
					sendSignal(info, true);
					return true;
				}
				catch(JSONException ex){
					Log.e(VolumeButtonsListener_LOG, ex.getMessage());
				}
			}
			else if( keyCode == KeyEvent.KEYCODE_VOLUME_DOWN  ){

				// Create a new JSONObject with the information and send it
				JSONObject info= new JSONObject();
				try{
					info.put("signal", new String("volume-down"));
					sendSignal(info, true);
					return true;
				}
				catch(JSONException ex){
					Log.e(VolumeButtonsListener_LOG, ex.getMessage());
				}
			}
		}

		return false;
	}

#end
#end
#No. 182563
#File: E:\bishe\1\VolumeButtonsListener.java
#Comment:
	/**
	* 	Method which sends back a new PluginResult to Javascript
	*
	*	@param		info: JSONObject object with the information to send back
	*	@param		keepCallback: boolean which indicates if there will be more results
	* 
	* 	@date		27/02/2014
	* 	@version	0.0.1
	* 	@author	ManuelDeveloper(manueldeveloper@gmail.com) 
	*/

#Code:
	private void sendSignal(JSONObject info, boolean keepCallback)
	{
		if( this.volumeCallbackContext != null ){
			PluginResult result= new PluginResult(PluginResult.Status.OK, info);
			result.setKeepCallback(keepCallback);
			this.volumeCallbackContext.sendPluginResult(result);
		}
	}

#end
#end
#No. 182564
#File: E:\bishe\1\VolumeChangeEvent.java
#Comment:
/**
 * Represents a change in the volume of a MPD player.
 *
 * @author Bill
 * @version 1.0
 */

#Code:
public class VolumeChangeEvent
        extends java.util.EventObject {
    private int volume;

    /**
     * Creates a new instance of MusicPlayerStatusChangedEvent
     *
     * @param source the object on which the Event initially occurred
     * @param volume the new volume
     */
    public VolumeChangeEvent(Object source, int volume) {
        super(source);
        this.volume = volume;
    }

    /**
     * Returns the new volume level.
     *
     * @return the new volume
     */
    public int getVolume() {
        return volume;
    }
}

#end
#end
#No. 182566
#File: E:\bishe\1\VolumeCreateOptions.java
#Comment:
    /**
     * Provisions a volume in the specified cloud based on the options defined in this object.
     * @param provider the cloud provider in which the volume should be provisioned
     * @return the unique ID of the newly provisioned volume
     * @throws CloudException an error occurred with the cloud provider while provisioning the volume
     * @throws InternalException an error occurred within Dasein Cloud while preparing the API call
     * @throws OperationNotSupportedException the cloud does not support volumes
     */

#Code:
    public @Nonnull String build(@Nonnull CloudProvider provider) throws CloudException, InternalException {
        ComputeServices services = provider.getComputeServices();

        if( services == null ) {
            throw new OperationNotSupportedException(provider.getCloudName() + " does not have support for compute services");
        }

#end
#end
#No. 182567
#File: E:\bishe\1\VolumeCreateOptions.java
#Comment:
    /**
     * Makes a copy of these creation options so that individual values may be altered as needed.
     * @return a copy of these creation options
     */

#Code:
    public @Nonnull VolumeCreateOptions copy(@Nonnull String withName) {
        VolumeCreateOptions options = new VolumeCreateOptions(volumeProductId, snapshotId, volumeSize, withName, description, iops);

        options.dataCenterId = dataCenterId;
        options.providerVirtualMachineId = providerVirtualMachineId;
        options.deviceId = deviceId;
        options.format = format;
        options.virtualMachineId = virtualMachineId;
        options.vlanId = vlanId;
        if( metaData != null ) {
            options.metaData = new HashMap<String, Object>();
            options.metaData.putAll(metaData);
        }

#end
#end
#No. 182568
#File: E:\bishe\1\VolumeCreateOptions.java
#Comment:
    /**
     * Specifies meta-data to add onto any existing meta-data being associated with this volume at launch time.
     * This method is accretive, meaning that it adds to any existing meta-data (or replaces an existing keys).
     * Though Dasein Cloud allows the ability to retain type in meta-data, the reality is that most clouds will convert
     * values to strings.
     * @param metaData the meta-data to be set for the new volume
     * @return this
     */

#Code:
    public @Nonnull VolumeCreateOptions withMetaData(@Nonnull Map<String,Object> metaData) {
        if( this.metaData == null ) {
            this.metaData = new HashMap<String, Object>();
        }

#end
#end
#No. 182569
#File: E:\bishe\1\VolumeDialog.java
#Comment:
	/**
	 * Provides access to the seek bar
	 * @return VolumeDialog's SeekBar
	 */

#Code:
	public SeekBar volumeBar(){
		return (SeekBar)findViewById(R.id.volume_seek);
	}

#end
#end
#No. 182570
#File: E:\bishe\1\VolumeDialog.java
#Comment:
	/**
	 * Set listener which is fired when the volume is changed
	 * @param volumeChangeListener
	 */

#Code:
	public void setVolumeChangeListener(OnSeekBarChangeListener volumeChangeListener) {
		this.volumeChangeListener = volumeChangeListener;
	}

#end
#end
#No. 182571
#File: E:\bishe\1\VolumeDialog.java
#Comment:
	/** 
	 * SeekBar change, update volume
	 */

#Code:
	@Override
	public void onProgressChanged(SeekBar seekBar, int progress,
			boolean fromUser) {
		volumeChangeListener.onProgressChanged(seekBar, progress, fromUser);
	}



#end
#end
#No. 182574
#File: E:\bishe\1\VolumeFilterOptions.java
#Comment:
    /**
     * Indicates whether these options can match a single criterion (<code>true</code>) or if all criteria must be
     * matched in order for the volume to pass the filter (<code>false</code>).
     * @return whether matching any single criterion is sufficient to consider a volume a match
     */

#Code:
    public boolean isMatchesAny() {
        return matchesAny;
    }

#end
#end
#No. 182575
#File: E:\bishe\1\VolumeFilterOptions.java
#Comment:
    /**
     * Matches a volume against the criteria in this set of filter options.
     * @param volume the volume to test
     * @return true if the volume matches all criteria
     */

#Code:
    public boolean matches(@Nonnull Volume volume) {
        if( attachedTo != null ) {
            if( attachedTo.equals(volume.getProviderVirtualMachineId()) ) {
                if( matchesAny ) {
                    return true;
                }
            }
            else if( !matchesAny ) {
                return false;
            }
        }

#end
#end
#No. 182576
#File: E:\bishe\1\VolumeFormat.java
#Comment:
/**
 * The format in which a cloud volume takes (not the file system format).
 * <p>Created by George Reese: 11/20/12 7:24 PM</p>
 * @author George Reese
 * @version 2013.01 initial version
 * @since 2013.01
 */

#Code:
public enum VolumeFormat {
    BLOCK, NFS
}


#end
#end
#No. 182578
#File: E:\bishe\1\VolumePreference.java
#Comment:
	/**
	 * @param context
	 * @param attrs
	 */

#Code:
	public VolumePreference(Context context, AttributeSet attrs) {
		super(context, attrs);

		setupLayout(context, attrs);
	}

#end
#end
#No. 182582
#File: E:\bishe\1\VomsAuthorisationStrategy.java
#Comment:
		/**
		 * @return the isAuthorised
		 */

#Code:
		public boolean isAuthorised() {
			return isAuthorised;
		}

#end
#end
#No. 182583
#File: E:\bishe\1\VomsAuthorisationStrategy.java
#Comment:
		/**
		 * @return the usersDN
		 */

#Code:
		public List<String> getUsersDN() {
			return usersDN;
		}



#end
#end
#No. 182586
#File: E:\bishe\1\VOMSMessages.java
#Comment:
	/**
	 * @param workerProviderClientID
	 * @param requestId
	 * @param errorMessage
	 * @return
	 */

#Code:
	public static String getErrorOnConnectingToVOMSMessage(
			String workerProviderClientContainerID, long requestId, String errorMessage) {
		return "Request "+requestId+": request from ["+ workerProviderClientContainerID + "] ignored because " +
			"there was an error while connecting to VOMS. Error cause: " + errorMessage;
	}

#end
#end
#No. 182587
#File: E:\bishe\1\VOMSMessages.java
#Comment:
	/**
	 * @param workerProviderID
	 * @param errorMessage
	 * @return
	 */

#Code:
	public static String getErrorOnConnectingToVOMSMessage(
			DeploymentID workerProviderID, String errorMessage) {
		return "Disposing worker provider [" + workerProviderID + "] because there was an error while connecting to VOMS. " +
				"Error cause: " + errorMessage;
	}

#end
#end
#No. 182588
#File: E:\bishe\1\VOMSMessages.java
#Comment:
	/**
	 * @param workerProviderClientID
	 * @param requestId
	 * @return
	 */

#Code:
	public static String getNonAuthorisedConsumerMessage(String workerProviderClientContainerID, long requestId) {
		return "Request "+requestId+": request ignored because ["+ workerProviderClientContainerID + "] " +
				" is not authorized at VOMS.";
	}

#end
#end
#No. 182589
#File: E:\bishe\1\VOMSMessages.java
#Comment:
	/**
	 * @param deploymentID
	 * @return
	 */

#Code:
	public static String getNonAuthorisedProviderMessage(DeploymentID deploymentID) {
		return "Disposing worker provider [" + deploymentID + "] because it " +
			"is not authorized at VOMS.";
	}

#end
#end
#No. 182590
#File: E:\bishe\1\VOMSMessages.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public static String getNullVOMSUrlMessage() {
		return "Property " + PeerConfiguration.PROP_VOMS_URL + " should not be null.";
	}





#end
#end
#No. 182594
#File: E:\bishe\1\VorbisCommentChapter.java
#Comment:
    /**
     * Return the id of a vorbiscomment chapter from a string like CHAPTERxxx*
     *
     * @return the id of the chapter key or -1 if the id couldn't be read.
     * @throws VorbisCommentReaderException
     */

#Code:
    public static int getIDFromKey(String key)
            throws VorbisCommentReaderException {
        if (key.length() >= CHAPTERXXX_LENGTH) { // >= CHAPTERxxx
            try {
                String strId = key.substring(8, 10);
                return Integer.parseInt(strId);
            } catch (NumberFormatException e) {
                throw new VorbisCommentReaderException(e);
            }
        }
        throw new VorbisCommentReaderException("key is too short (" + key + ")");
    }

#end
#end
#No. 182595
#File: E:\bishe\1\VorbisCommentChapter.java
#Comment:
    /**
     * Get the string that comes after 'CHAPTERxxx', for example 'name' or
     * 'url'.
     */

#Code:
    public static String getAttributeTypeFromKey(String key) {
        if (key.length() > CHAPTERXXX_LENGTH) {
            return key.substring(CHAPTERXXX_LENGTH, key.length());
        }
        return null;
    }

#end
#end
#No. 182596
#File: E:\bishe\1\VorbisCommentReader.java
#Comment:
    /**
     * Looks for an identification header in the first page of the file. If an
     * identification header is found, it will be skipped completely and the
     * method will return true, otherwise false.
     *
     * @throws IOException
     */

#Code:
    private boolean findIdentificationHeader(InputStream input)
            throws IOException {
        byte[] buffer = new byte[FIRST_PAGE_LENGTH];
        IOUtils.readFully(input, buffer);
        int i;
        for (i = 6; i < buffer.length; i++) {
            if (buffer[i - 5] == 'v' && buffer[i - 4] == 'o'
                    && buffer[i - 3] == 'r' && buffer[i - 2] == 'b'
                    && buffer[i - 1] == 'i' && buffer[i] == 's'
                    && buffer[i - 6] == PACKET_TYPE_IDENTIFICATION) {
                return true;
            }
        }
        return false;
    }

#end
#end
#No. 182598
#File: E:\bishe\1\VoStreamCallback.java
#Comment:
	/**
	 * 
	 * @param controller
	 */

#Code:
	public VoStreamCallback(IMangoVoRestController<VO, MODEL, DAO> controller){
		this.controller = controller;
	}

#end
#end
#No. 182599
#File: E:\bishe\1\VoStreamCallback.java
#Comment:
	/**
	 * Do the work of writing the VO
	 * @param vo
	 * @throws IOException
	 */

#Code:
	@Override
	protected void writeJson(VO vo) throws IOException{
		MODEL model = this.controller.createModel(vo);
		this.jgen.writeObject(model);
	}



#end
#end
#No. 182602
#File: E:\bishe\1\VoterCheckDialog.java
#Comment:
    /*
     * OnClick Listener for ReCheck Button Click Event.
     */

#Code:
    private class RecheckClickListener implements View.OnClickListener
    {
        @Override
        public void onClick(View view) {
            final UserPrefUtils userPrefUtils = new UserPrefUtils(mActivity);
            userPrefUtils.setSKIP(false);

            Intent i = new Intent(mActivity, MainActivity.class);
            mActivity.startActivity(i);
        }
    }

#end
#end
#No. 182603
#File: E:\bishe\1\VoterCheckDialog.java
#Comment:
    /*
    * OnClick Listener for Ok Button Click Event.
    */

#Code:
    private class OkClickListener implements View.OnClickListener
    {
        private boolean isValid =false;

        public OkClickListener(boolean validBoolean) {
            isValid = validBoolean;
        }

        @Override
        public void onClick(View view) {
            if (mDialog.isShowing()) {
                mDialog.dismiss();
                mListener.onClickOkFromDialog(view, isValid);
            }
        }
    }

#end
#end
#No. 182605
#File: E:\bishe\1\VoteStartMethod.java
#Comment:
    /**
     * @param question The question
     * @param options  Possible answers
     * @param duration Duration of the poll, in seconds
     */

#Code:
    public static VoteStartMethod from(String question, String[] options, int duration) {
        VoteStartMethod m = new VoteStartMethod();
        m.arguments = new Object[]{
                question,
                options,
                duration,
        };
        return m;
    }



#end
#end
#No. 182614
#File: E:\bishe\1\VpnConnectingError.java
#Comment:
/**
 * Exception thrown when a connecting attempt fails.
 */

#Code:
class VpnConnectingError extends IOException {
    private int mErrorCode;

    VpnConnectingError(int errorCode) {
        super("Connecting error: " + errorCode);
        mErrorCode = errorCode;
    }

    int getErrorCode() {
        return mErrorCode;
    }
}

#end
#end
#No. 182615
#File: E:\bishe\1\VPNConnectionState.java
#Comment:
/**
 * Represents the current state of a connection between a cloud VPN and a physical VPN gateway.
 * <p>Created by George Reese: 6/26/12 2:48 PM</p>
 * @author George Reese (george.reese@imaginary.com)
 * @since 2012-07
 * @version 2012-07 initial version
 */

#Code:
public enum VPNConnectionState {
    PENDING, AVAILABLE, DELETING, DELETED
}

#end
#end
#No. 182616
#File: E:\bishe\1\VPNPayload.java
#Comment:
/**
 * An MDM payload for VPN.
 *
 * @author Sylvain Pedneault
 */

#Code:
class VPNPayload extends MobileConfigPayload {
  public static final String VPNTYPE_L2TP = "L2TP";
  public static final String VPNTYPE_PPTP = "PPTP";
  public static final String VPNTYPE_IP_SEC = "IPSec";

  public VPNPayload(final int payloadVersion, final String payloadOrganization, final String payloadIdentifier, final String payloadDisplayName, final String userDefinedName, final boolean overridePrimary, final String vpnType) throws JSONException {
    super(payloadVersion, "com.apple.vpn.managed", payloadOrganization, payloadIdentifier, payloadDisplayName);
    final JSONObject payload = getPayload();
    payload.put("UserDefinedName", userDefinedName);
    payload.put("OverridePrimary", overridePrimary);
    payload.put("VPNType", vpnType);
  }

  public JSONObject addPPP() throws JSONException {
    final JSONObject object = new JSONObject();
    getPayload().put("PPP", object);
    return object;
  }

  public JSONObject addIPSec() throws JSONException {
    final JSONObject object = new JSONObject();
    getPayload().put("IPSec", object);
    return object;
  }
}

#end
#end
#No. 182617
#File: E:\bishe\1\VpnProfileDataSource.java
#Comment:
	/**
	 * Construct a new VPN profile data source. The context is used to
	 * open/create the database.
	 * @param context context used to access the database
	 */

#Code:
	public VpnProfileDataSource(Context context)
	{
		this.mContext = context;
	}

#end
#end
#No. 182618
#File: E:\bishe\1\VpnProfileDataSource.java
#Comment:
	/**
	 * Open the VPN profile data source. The database is automatically created
	 * if it does not yet exist. If that fails an exception is thrown.
	 * @return itself (allows to chain initialization calls)
	 * @throws SQLException if the database could not be opened or created
	 */

#Code:
	public VpnProfileDataSource open() throws SQLException
	{
		if (mDbHelper == null)
		{
			mDbHelper = new DatabaseHelper(mContext);
			mDatabase = mDbHelper.getWritableDatabase();
		}
		return this;
	}

#end
#end
#No. 182619
#File: E:\bishe\1\VpnProfileDataSource.java
#Comment:
	/**
	 * Close the data source.
	 */

#Code:
	public void close()
	{
		if (mDbHelper != null)
		{
			mDbHelper.close();
			mDbHelper = null;
		}
	}

#end
#end
#No. 182620
#File: E:\bishe\1\VpnProfileDataSource.java
#Comment:
	/**
	 * Insert the given VPN profile into the database.  On success the Id of
	 * the object is updated and the object returned.
	 *
	 * @param profile the profile to add
	 * @return the added VPN profile or null, if failed
	 */

#Code:
	public VpnProfile insertProfile(VpnProfile profile)
	{
		ContentValues values = ContentValuesFromVpnProfile(profile);
		long insertId = mDatabase.insert(TABLE_VPNPROFILE, null, values);
		if (insertId == -1)
		{
			return null;
		}
		profile.setId(insertId);
		return profile;
	}

#end
#end
#No. 182621
#File: E:\bishe\1\VpnProfileDataSource.java
#Comment:
	/**
	 * Updates the given VPN profile in the database.
	 * @param profile the profile to update
	 * @return true if update succeeded, false otherwise
	 */

#Code:
	public boolean updateVpnProfile(VpnProfile profile)
	{
		long id = profile.getId();
		ContentValues values = ContentValuesFromVpnProfile(profile);
		return mDatabase.update(TABLE_VPNPROFILE, values, KEY_ID + " = " + id, null) > 0;
	}

#end
#end
#No. 182622
#File: E:\bishe\1\VpnProfileDataSource.java
#Comment:
	/**
	 * Delete the given VPN profile from the database.
	 * @param profile the profile to delete
	 * @return true if deleted, false otherwise
	 */

#Code:
	public boolean deleteVpnProfile(VpnProfile profile)
	{
		long id = profile.getId();
		return mDatabase.delete(TABLE_VPNPROFILE, KEY_ID + " = " + id, null) > 0;
	}

#end
#end
#No. 182623
#File: E:\bishe\1\VpnProfileDataSource.java
#Comment:
	/**
	 * Get a single VPN profile from the database.
	 * @param id the ID of the VPN profile
	 * @return the profile or null, if not found
	 */

#Code:
	public VpnProfile getVpnProfile(long id)
	{
		VpnProfile profile = null;
		Cursor cursor = mDatabase.query(TABLE_VPNPROFILE, ALL_COLUMNS,
										KEY_ID + "=" + id, null, null, null, null);
		if (cursor.moveToFirst())
		{
			profile = VpnProfileFromCursor(cursor);
		}
		cursor.close();
		return profile;
	}

#end
#end
#No. 182624
#File: E:\bishe\1\VpnProfileDataSource.java
#Comment:
	/**
	 * Get a list of all VPN profiles stored in the database.
	 * @return list of VPN profiles
	 */

#Code:
	public List<VpnProfile> getAllVpnProfiles()
	{
		List<VpnProfile> vpnProfiles = new ArrayList<VpnProfile>();

		Cursor cursor = mDatabase.query(TABLE_VPNPROFILE, ALL_COLUMNS, null, null, null, null, null);
		cursor.moveToFirst();
		while (!cursor.isAfterLast())
		{
			VpnProfile vpnProfile = VpnProfileFromCursor(cursor);
			vpnProfiles.add(vpnProfile);
			cursor.moveToNext();
		}
		cursor.close();
		return vpnProfiles;
	}

#end
#end
#No. 182625
#File: E:\bishe\1\VpnProfileDetailActivity.java
#Comment:
	/**
	 * Update the UI to enter credentials depending on the type of VPN currently selected
	 */

#Code:
	private void updateCredentialView()
	{
		mUsernamePassword.setVisibility(mVpnType.has(VpnTypeFeature.USER_PASS) ? View.VISIBLE : View.GONE);
		mUserCertificate.setVisibility(mVpnType.has(VpnTypeFeature.CERTIFICATE) ? View.VISIBLE : View.GONE);
		mTncNotice.setVisibility(mVpnType.has(VpnTypeFeature.BYOD) ? View.VISIBLE : View.GONE);

		if (mVpnType.has(VpnTypeFeature.CERTIFICATE))
		{
			if (mUserCertLoading != null)
			{
				((TextView)mSelectUserCert.findViewById(android.R.id.text1)).setText(mUserCertLoading);
				((TextView)mSelectUserCert.findViewById(android.R.id.text2)).setText(R.string.loading);
			}
			else if (mUserCertEntry != null)
			{	/* clear any errors and set the new data */
				((TextView)mSelectUserCert.findViewById(android.R.id.text1)).setError(null);
				((TextView)mSelectUserCert.findViewById(android.R.id.text1)).setText(mUserCertEntry.getAlias());
				((TextView)mSelectUserCert.findViewById(android.R.id.text2)).setText(mUserCertEntry.getCertificate().getSubjectDN().toString());
			}
			else
			{
				((TextView)mSelectUserCert.findViewById(android.R.id.text1)).setText(R.string.profile_user_select_certificate_label);
				((TextView)mSelectUserCert.findViewById(android.R.id.text2)).setText(R.string.profile_user_select_certificate);
			}
		}
	}

#end
#end
#No. 182626
#File: E:\bishe\1\VpnProfileDetailActivity.java
#Comment:
	/**
	 * Show an alert in case the previously selected certificate is not found anymore
	 * or the user did not select a certificate in the spinner.
	 */

#Code:
	private void showCertificateAlert()
	{
		AlertDialog.Builder adb = new AlertDialog.Builder(VpnProfileDetailActivity.this);
		adb.setTitle(R.string.alert_text_nocertfound_title);
		adb.setMessage(R.string.alert_text_nocertfound);
		adb.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
			@Override
			public void onClick(DialogInterface dialog, int id)
			{
				dialog.cancel();
			}
		});
		adb.show();
	}

#end
#end
#No. 182627
#File: E:\bishe\1\VpnProfileDetailActivity.java
#Comment:
	/**
	 * Update the CA certificate selection UI depending on whether the
	 * certificate should be automatically selected or not.
	 */

#Code:
	private void updateCertificateSelector()
	{
		if (!mCheckAuto.isChecked())
		{
			mSelectCert.setEnabled(true);
			mSelectCert.setVisibility(View.VISIBLE);

			if (mCertEntry != null)
			{
				((TextView)mSelectCert.findViewById(android.R.id.text1)).setText(mCertEntry.getSubjectPrimary());
				((TextView)mSelectCert.findViewById(android.R.id.text2)).setText(mCertEntry.getSubjectSecondary());
			}
			else
			{
				((TextView)mSelectCert.findViewById(android.R.id.text1)).setText(R.string.profile_ca_select_certificate_label);
				((TextView)mSelectCert.findViewById(android.R.id.text2)).setText(R.string.profile_ca_select_certificate);
			}
		}
		else
		{
			mSelectCert.setEnabled(false);
			mSelectCert.setVisibility(View.GONE);
		}
	}

#end
#end
#No. 182628
#File: E:\bishe\1\VpnProfileDetailActivity.java
#Comment:
	/**
	 * Save or update the profile depending on whether we actually have a
	 * profile object or not (this was created in updateProfileData)
	 */

#Code:
	private void saveProfile()
	{
		if (verifyInput())
		{
			if (mProfile != null)
			{
				updateProfileData();
				mDataSource.updateVpnProfile(mProfile);
			}
			else
			{
				mProfile = new VpnProfile();
				updateProfileData();
				mDataSource.insertProfile(mProfile);
			}
			setResult(RESULT_OK, new Intent().putExtra(VpnProfileDataSource.KEY_ID, mProfile.getId()));
			finish();
		}
	}

#end
#end
#No. 182629
#File: E:\bishe\1\VpnProfileDetailActivity.java
#Comment:
	/**
	 * Verify the user input and display error messages.
	 * @return true if the input is valid
	 */

#Code:
	private boolean verifyInput()
	{
		boolean valid = true;
		if (mGateway.getText().toString().trim().isEmpty())
		{
			mGateway.setError(getString(R.string.alert_text_no_input_gateway));
			valid = false;
		}
		if (mVpnType.has(VpnTypeFeature.USER_PASS))
		{
			if (mUsername.getText().toString().trim().isEmpty())
			{
				mUsername.setError(getString(R.string.alert_text_no_input_username));
				valid = false;
			}
		}
		if (mVpnType.has(VpnTypeFeature.CERTIFICATE) && mUserCertEntry == null)
		{	/* let's show an error icon */
			((TextView)mSelectUserCert.findViewById(android.R.id.text1)).setError("");
			valid = false;
		}
		if (!mCheckAuto.isChecked() && mCertEntry == null)
		{
			showCertificateAlert();
			valid = false;
		}
		return valid;
	}

#end
#end
#No. 182630
#File: E:\bishe\1\VpnProfileDetailActivity.java
#Comment:
	/**
	 * Update the profile object with the data entered by the user
	 */

#Code:
	private void updateProfileData()
	{
		/* the name is optional, we default to the gateway if none is given */
		String name = mName.getText().toString().trim();
		String gateway = mGateway.getText().toString().trim();
		mProfile.setName(name.isEmpty() ? gateway : name);
		mProfile.setGateway(gateway);
		mProfile.setVpnType(mVpnType);
		if (mVpnType.has(VpnTypeFeature.USER_PASS))
		{
			mProfile.setUsername(mUsername.getText().toString().trim());
			String password = mPassword.getText().toString().trim();
			password = password.isEmpty() ? null : password;
			mProfile.setPassword(password);
		}
		if (mVpnType.has(VpnTypeFeature.CERTIFICATE))
		{
			mProfile.setUserCertificateAlias(mUserCertEntry.getAlias());
		}
		String certAlias = mCheckAuto.isChecked() ? null : mCertEntry.getAlias();
		mProfile.setCertificateAlias(certAlias);
	}

#end
#end
#No. 182631
#File: E:\bishe\1\VpnProfileDetailActivity.java
#Comment:
	/**
	 * Dialog with notification message if EAP-TNC is used.
	 */

#Code:
	public static class TncNoticeDialog extends DialogFragment
	{
		@Override
		public Dialog onCreateDialog(Bundle savedInstanceState)
		{
			return new AlertDialog.Builder(getActivity())
				.setTitle(R.string.tnc_notice_title)
				.setMessage(Html.fromHtml(getString(R.string.tnc_notice_details)))
				.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int id)
					{
						dialog.dismiss();
					}
				}).create();
		}
	}


#end
#end
#No. 182633
#File: E:\bishe\1\VpnService.java
#Comment:
    /**
     * Returns the daemons management class for this service object.
     */

#Code:
    protected VpnDaemons getDaemons() {
        return mDaemons;
    }

#end
#end
#No. 182634
#File: E:\bishe\1\VpnService.java
#Comment:
    /**
     * Returns the VPN profile associated with the connection.
     */

#Code:
    protected E getProfile() {
        return mProfile;
    }

#end
#end
#No. 182635
#File: E:\bishe\1\VpnService.java
#Comment:
    /**
     * Returns the IP address of the specified host name.
     */

#Code:
    protected String getIp(String hostName) throws IOException {
        return InetAddress.getByName(hostName).getHostAddress();
    }

#end
#end
#No. 182636
#File: E:\bishe\1\VpnState.java
#Comment:
/**
 * Enumeration of all VPN states.
 *
 * A normal VPN connection lifetime starts in {@link IDLE}. When a new
 * connection is about to be set up, it goes to {@link CONNECTING} and then
 * {@link CONNECTED} if successful; back to {@link IDLE} if failed.
 * When the connection is about to be torn down, it goes to
 * {@link DISCONNECTING} and then {@link IDLE}.
 * {@link CANCELLED} is a state when a VPN connection attempt is aborted, and
 * is in transition to {@link IDLE}.
 * The {@link UNUSABLE} state indicates that the profile is not in a state for
 * connecting due to possibly the integrity of the fields or another profile is
 * connecting etc.
 * The {@link UNKNOWN} state indicates that the profile state is to be
 * determined.
 * {@hide}
 */

#Code:
public enum VpnState {
    CONNECTING, DISCONNECTING, CANCELLED, CONNECTED, IDLE, UNUSABLE, UNKNOWN
}

#end
#end
#No. 182637
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Listener interface for bound clients that are interested in changes to
	 * this Service.
	 */

#Code:
	public interface VpnStateListener
	{
		public void stateChanged();
	}

#end
#end
#No. 182638
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Simple Binder that allows to directly access this Service class itself
	 * after binding to it.
	 */

#Code:
	public class LocalBinder extends Binder
	{
		public VpnStateService getService()
		{
			return VpnStateService.this;
		}
	}


#end
#end
#No. 182640
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Register a listener with this Service. We assume this is called from
	 * the main thread so no synchronization is happening.
	 *
	 * @param listener listener to register
	 */

#Code:
	public void registerListener(VpnStateListener listener)
	{
		mListeners.add(listener);
	}

#end
#end
#No. 182641
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Unregister a listener from this Service.
	 *
	 * @param listener listener to unregister
	 */

#Code:
	public void unregisterListener(VpnStateListener listener)
	{
		mListeners.remove(listener);
	}

#end
#end
#No. 182642
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Get the current VPN profile.
	 *
	 * @return profile
	 */

#Code:
	public VpnProfile getProfile()
	{	/* only updated from the main thread so no synchronization needed */
		return mProfile;
	}

#end
#end
#No. 182643
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Get the current connection ID.  May be used to track which state
	 * changes have already been handled.
	 *
	 * Is increased when startConnection() is called.
	 *
	 * @return connection ID
	 */

#Code:
	public long getConnectionID()
	{	/* only updated from the main thread so no synchronization needed */
		return mConnectionID;
	}

#end
#end
#No. 182644
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Get the current state.
	 *
	 * @return state
	 */

#Code:
	public State getState()
	{	/* only updated from the main thread so no synchronization needed */
		return mState;
	}

#end
#end
#No. 182645
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Get the current error, if any.
	 *
	 * @return error
	 */

#Code:
	public ErrorState getErrorState()
	{	/* only updated from the main thread so no synchronization needed */
		return mError;
	}

#end
#end
#No. 182646
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Get the current IMC state, if any.
	 *
	 * @return imc state
	 */

#Code:
	public ImcState getImcState()
	{	/* only updated from the main thread so no synchronization needed */
		return mImcState;
	}

#end
#end
#No. 182647
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Get the remediation instructions, if any.
	 *
	 * @return read-only list of instructions
	 */

#Code:
	public List<RemediationInstruction> getRemediationInstructions()
	{	/* only updated from the main thread so no synchronization needed */
		return Collections.unmodifiableList(mRemediationInstructions);
	}

#end
#end
#No. 182648
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Disconnect any existing connection and shutdown the daemon, the
	 * VpnService is not stopped but it is reset so new connections can be
	 * started.
	 */

#Code:
	public void disconnect()
	{
		/* as soon as the TUN device is created by calling establish() on the
		 * VpnService.Builder object the system binds to the service and keeps
		 * bound until the file descriptor of the TUN device is closed.  thus
		 * calling stopService() here would not stop (destroy) the service yet,
		 * instead we call startService() with an empty Intent which shuts down
		 * the daemon (and closes the TUN device, if any) */
		Context context = getApplicationContext();
		Intent intent = new Intent(context, CharonVpnService.class);
		context.startService(intent);
	}

#end
#end
#No. 182649
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Update state and notify all listeners about the change. By using a Handler
	 * this is done from the main UI thread and not the initial reporter thread.
	 * Also, in doing the actual state change from the main thread, listeners
	 * see all changes and none are skipped.
	 *
	 * @param change the state update to perform before notifying listeners, returns true if state changed
	 */

#Code:
	private void notifyListeners(final Callable<Boolean> change)
	{
		mHandler.post(new Runnable() {
			@Override
			public void run()
			{
				try
				{
					if (change.call())
					{	/* otherwise there is no need to notify the listeners */
						for (VpnStateListener listener : mListeners)
						{
							listener.stateChanged();
						}
					}
				}
				catch (Exception e)
				{
					e.printStackTrace();
				}
			}
		});
	}

#end
#end
#No. 182650
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Called when a connection is started.  Sets the currently active VPN
	 * profile, resets IMC and Error state variables, sets the State to
	 * CONNECTING, increases the connection ID, and notifies all listeners.
	 *
	 * May be called from threads other than the main thread.
	 *
	 * @param profile current profile
	 */

#Code:
	public void startConnection(final VpnProfile profile)
	{
		notifyListeners(new Callable<Boolean>() {
			@Override
			public Boolean call() throws Exception
			{
				VpnStateService.this.mConnectionID++;
				VpnStateService.this.mProfile = profile;
				VpnStateService.this.mState = State.CONNECTING;
				VpnStateService.this.mError = ErrorState.NO_ERROR;
				VpnStateService.this.mImcState = ImcState.UNKNOWN;
				VpnStateService.this.mRemediationInstructions.clear();
				return true;
			}
		});
	}

#end
#end
#No. 182651
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Update the state and notify all listeners, if changed.
	 *
	 * May be called from threads other than the main thread.
	 *
	 * @param state new state
	 */

#Code:
	public void setState(final State state)
	{
		notifyListeners(new Callable<Boolean>() {
			@Override
			public Boolean call() throws Exception
			{
				if (VpnStateService.this.mState != state)
				{
					VpnStateService.this.mState = state;
					return true;
				}
				return false;
			}
		});
	}

#end
#end
#No. 182652
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Set the current error state and notify all listeners, if changed.
	 *
	 * May be called from threads other than the main thread.
	 *
	 * @param error error state
	 */

#Code:
	public void setError(final ErrorState error)
	{
		notifyListeners(new Callable<Boolean>() {
			@Override
			public Boolean call() throws Exception
			{
				if (VpnStateService.this.mError != error)
				{
					VpnStateService.this.mError = error;
					return true;
				}
				return false;
			}
		});
	}

#end
#end
#No. 182653
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Set the current IMC state and notify all listeners, if changed.
	 *
	 * Setting the state to UNKNOWN clears all remediation instructions.
	 *
	 * May be called from threads other than the main thread.
	 *
	 * @param error error state
	 */

#Code:
	public void setImcState(final ImcState state)
	{
		notifyListeners(new Callable<Boolean>() {
			@Override
			public Boolean call() throws Exception
			{
				if (state == ImcState.UNKNOWN)
				{
					VpnStateService.this.mRemediationInstructions.clear();
				}
				if (VpnStateService.this.mImcState != state)
				{
					VpnStateService.this.mImcState = state;
					return true;
				}
				return false;
			}
		});
	}

#end
#end
#No. 182654
#File: E:\bishe\1\VpnStateService.java
#Comment:
	/**
	 * Add the given remediation instruction to the internal list.  Listeners
	 * are not notified.
	 *
	 * Instructions are cleared if the IMC state is set to UNKNOWN.
	 *
	 * May be called from threads other than the main thread.
	 *
	 * @param instruction remediation instruction
	 */

#Code:
	public void addRemediationInstruction(final RemediationInstruction instruction)
	{
		mHandler.post(new Runnable() {
			@Override
			public void run()
			{
				VpnStateService.this.mRemediationInstructions.add(instruction);
			}
		});
	}

#end
#end
#No. 182655
#File: E:\bishe\1\VpnType.java
#Comment:
/**
 * Enumeration of all supported VPN types.
 * {@hide}
 */

#Code:
public enum VpnType {

    PPTP("PPTP", R.string.pptp_vpn_description, PptpProfile.class),
    L2TP("L2TP", R.string.l2tp_vpn_description, L2tpProfile.class),
    L2TP_IPSEC_PSK("L2TP/IPSec PSK", R.string.l2tp_ipsec_psk_vpn_description,
            L2tpIpsecPskProfile.class),
    L2TP_IPSEC("L2TP/IPSec CRT", R.string.l2tp_ipsec_crt_vpn_description,
            L2tpIpsecProfile.class);
   
    VpnType(String displayName, int descriptionId,
            Class<? extends VpnProfile> klass) {
        mDisplayName = displayName;
        mDescriptionId = descriptionId;
        mClass = klass;
    }
    
    private String mDisplayName;
    private int mDescriptionId;
    private Class<? extends VpnProfile> mClass;

    public String getDisplayName() {
        return mDisplayName;
    }

    public int getDescriptionId() {
        return mDescriptionId;
    }

    public Class<? extends VpnProfile> getProfileClass() {
        return mClass;
    }
}

#end
#end
#No. 182656
#File: E:\bishe\1\VPTreeGeospatialIndex.java
#Comment:
    /**
     * Calculates the minimum eastward angle traveled from a meridian to a point. If the point is coincident with the
     * meridian, this method returns 360 degrees.
     *
     * @param longitude the line of longitude at which to begin travel
     * @param point the point to which to travel
     *
     * @return the eastward-traveling distance between the line and the point in degrees
     */

#Code:
    private double getDegreesEastFromMeridian(final double longitude, final E point) {
        return point.getLongitude() > longitude ?
                point.getLongitude() - longitude : Math.abs(360 - (point.getLongitude() - longitude));
    }

#end
#end
#No. 182657
#File: E:\bishe\1\VPTreeGeospatialIndex.java
#Comment:
    /**
     * Calculates the minimum westward angle traveled from a meridian to a point. If the point is coincident with the
     * meridian, this method returns 360 degrees.
     *
     * @param longitude the line of longitude at which to begin travel
     * @param point the point to which to travel
     *
     * @return the westward-traveling distance between the line and the point in degrees
     */

#Code:
    private double getDegreesWestFromMeridian(final double longitude, final E point) {
        return point.getLongitude() < longitude ?
                longitude - point.getLongitude() : Math.abs(360 - (longitude - point.getLongitude()));
    }

#end
#end
#No. 182658
#File: E:\bishe\1\VRaptorTestResult.java
#Comment:
	/**
	 * 
	 * @return redirected url or jsp path
	 */

#Code:
	public String getLastPath() {
		if(response.getRedirectedUrl()!=null){
			return response.getRedirectedUrl();
		}
		return response.getForwardedUrl();
	}

#end
#end
#No. 182659
#File: E:\bishe\1\VRDeepLinkHelper.java
#Comment:
  /**
   * Helper function to create an intent to launch 360 photos/videos in Oculus Video/360Photo app.
   * If such app doesn't exist, we'll fallback to FB4A or m-site depending on application availability.
   *
   * @param context an android context
   * @param param A VRDeepLinkParam object that contains the fbid of the deeplink media and its type
   * @return an Intent object to launch the deeplinked content.
   */

#Code:
  public static Intent createDeepLinkIntent(Context context, VRDeepLinkParam param) {
    if (param == null ||
            isStringNullOrEmpty(param.mediaFbId)) {
      return null;
    }

    if (IsVideoDeepLink(param)) {
      return createDeepLinkIntentForVideoContent(context, param);
    }
    return createDeepLinkIntentForPhotoContent(context, param);
  }

#end
#end
#No. 182660
#File: E:\bishe\1\VRDeepLinkHelper.java
#Comment:
  /**
   * Checks whether any of the support oculus app is installed.
   *
   * @param context an android context
   * @param packageName an android app package name
   * @return whether an app with the given package name is installed
   */

#Code:
  @VisibleForTesting
  static boolean hasAppInstalled(Context context, String packageName) {
    try {
      context.getPackageManager().getPackageInfo(packageName, 0);
      return true;
    } catch (PackageManager.NameNotFoundException e) {
      return false;
    }
  }

#end
#end
#No. 182661
#File: E:\bishe\1\VSlider.java
#Comment:
	/**
	 * 
	 * @param my 
	 */

#Code:
	@Override
	protected void setValue(float my) {
		// only the "inside" (i.e. without the outline) of the rect is used to represent the value
		// the point on the lower outline (y+height-1) represents 0/min 
		// the point below the upper outline (y+1) represents 1/max
		value = PApplet.map(my, y+height-1, y+1, min, max);
		value = PApplet.constrain(value, min, max);
		onValueFloat.fire(value);
		onValue.fire(this);
	}


#end
#end
#No. 182663
#File: E:\bishe\1\VSphere.java
#Comment:
    /**
     * Deploys a new VM from an existing (named) Template.
     *
     * @param cloneName - name of VM to be created
     * @param sourceName - name of VM or template to be cloned
     * @param linkedClone - true if you want to re-use disk backings
     * @param resourcePoolName - resource pool to use
     * @param cluster - ComputeClusterResource to use
     * @param datastoreName - Datastore to use
     * @param folderName - Folder name or path to use
     * @param powerOn - If true the VM will be powered on.
     * @param customizationSpec - Customization spec to use for this VM
     * @param jLogger - Where to log to.
     * @throws VSphereException If an error occurred.
     */

#Code:
    public void deployVm(String cloneName, String sourceName, boolean linkedClone, String resourcePoolName, String cluster, String datastoreName, String folderName, boolean powerOn, String customizationSpec, PrintStream jLogger) throws VSphereException {
        final boolean useCurrentSnapshotIsFALSE = false;
        final String namedSnapshotIsNULL = null;
        logMessage(jLogger, "Deploying new vm \""+ cloneName + "\" from template \""+sourceName+"\"");
        cloneOrDeployVm(cloneName, sourceName, linkedClone, resourcePoolName, cluster, datastoreName, folderName, useCurrentSnapshotIsFALSE, namedSnapshotIsNULL, powerOn, customizationSpec, jLogger);
    }

#end
#end
#No. 182664
#File: E:\bishe\1\VSphere.java
#Comment:
    /**
     * Clones a new VM from an existing (named) VM.
     *
     * @param cloneName - name of VM to be created
     * @param sourceName - name of VM or template to be cloned
     * @param linkedClone - true if you want to re-use disk backings
     * @param resourcePoolName - resource pool to use
     * @param cluster - ComputeClusterResource to use
     * @param datastoreName - Datastore to use
     * @param folderName - Folder name or path to use
     * @param powerOn - If true the VM will be powered on.
     * @param customizationSpec - Customization spec to use for this VM
     * @param jLogger - Where to log to.
     * @throws VSphereException If an error occurred.
     */

#Code:
    public void cloneVm(String cloneName, String sourceName, boolean linkedClone, String resourcePoolName, String cluster, String datastoreName, String folderName, boolean powerOn, String customizationSpec, PrintStream jLogger) throws VSphereException {
        final boolean useCurrentSnapshotIsTRUE = true;
        final String namedSnapshotIsNULL = null;
        logMessage(jLogger, "Creating a " + (linkedClone?"shallow":"deep") + " clone of \"" + sourceName + "\" to \"" + cloneName + "\"");
        cloneOrDeployVm(cloneName, sourceName, linkedClone, resourcePoolName, cluster, datastoreName, folderName, useCurrentSnapshotIsTRUE, namedSnapshotIsNULL, powerOn, customizationSpec, jLogger);
    }

#end
#end
#No. 182665
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * Asks vSphere for the IP address used by a VM.
	 * 
	 * @param vm VirtualMachine name whose IP is to be returned.
	 * @param timeout How long to wait (in seconds) for the IP address to known to vSphere.
	 * @return String containing IP address.
	 * @throws VSphereException If an error occurred.
	 */

#Code:
	public String getIp(VirtualMachine vm, int timeout) throws VSphereException {

		if (vm==null)
			throw new VSphereException("VM is null");

		//Determine how many attempts will be made to fetch the IP address
		final int waitSeconds = 5;
		final int maxTries;
		if (timeout<=waitSeconds)
			maxTries = 1;
		else
			maxTries = (int) Math.round((double)timeout / waitSeconds);

		for(int count=0; count<maxTries; count++){

            GuestInfo guestInfo = vm.getGuest();

            // guest info can be null sometimes
			if (guestInfo != null && guestInfo.getIpAddress() != null){
				return guestInfo.getIpAddress();
			}

			try {
				//wait
				Thread.sleep(waitSeconds * 1000);
			} catch (InterruptedException e) { // build aborted
				Thread.currentThread().interrupt(); // pass interrupt upwards
				break; // and abort our activities now.
			}
		}
		return null;
	}

#end
#end
#No. 182666
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * @param vmName - name of VM object to retrieve
	 * @return - VirtualMachine object
	 * @throws VSphereException If an error occurred.
	 */

#Code:
	public VirtualMachine getVmByName(String vmName) throws VSphereException {
		try {
			return (VirtualMachine) new InventoryNavigator(
					getServiceInstance().getRootFolder()).searchManagedEntity(
							"VirtualMachine", vmName);
		} catch (Exception e) {
			throw new VSphereException(e);
		}
	}

#end
#end
#No. 182667
#File: E:\bishe\1\VSphere.java
#Comment:
    /*
     Check if folder exists along all the vSphere folders
     */

#Code:
    public Boolean folderExists(String folderPath) throws VSphereException {
        try {
            String[] folderHierarchy = folderPath.split("/");
            ManagedEntity folder = null;

            for (int i = 0; i < folderHierarchy.length; i++) {
                if (i == 0) {
                    folder = new InventoryNavigator(getServiceInstance().getRootFolder()).searchManagedEntity("Folder", folderHierarchy[i]);
                } else {
                    folder = new InventoryNavigator(folder).searchManagedEntity(null, folderHierarchy[i]);
                }
                if (folder == null) {
                    return false;
                }
            }
            return true;
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Failed while checking if folder exists");
            throw new VSphereException(e);
        }
    }

#end
#end
#No. 182668
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * @return - ManagedEntity array of Datastore
	 * @throws VSphereException If an error occurred.
	 */

#Code:
	public ManagedEntity[] getDatastores() throws VSphereException {
		try {
			return new InventoryNavigator(
					getServiceInstance().getRootFolder()).searchManagedEntities(
							"Datastore");
		} catch (Exception e) {
			throw new VSphereException(e);
		}
	}

#end
#end
#No. 182669
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * @param poolName - Name of pool to use
	 * @return - ResourcePool object
	 * @throws InvalidProperty
	 * @throws RuntimeFault
	 * @throws RemoteException
	 * @throws MalformedURLException
	 * @throws VSphereException
	 */

#Code:
	private ResourcePool getResourcePoolByName(final String poolName, ManagedEntity rootEntity) throws InvalidProperty, RuntimeFault, RemoteException, MalformedURLException {
		if (rootEntity==null) rootEntity=getServiceInstance().getRootFolder();

		return (ResourcePool) new InventoryNavigator(
				rootEntity).searchManagedEntity(
						"ResourcePool", poolName);
	}

#end
#end
#No. 182670
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * @param clusterName - Name of cluster name to find
	 * @param rootEntity - managed entity to search
	 * @return - ClusterComputeResource object
	 * @throws InvalidProperty
	 * @throws RuntimeFault
	 * @throws RemoteException
	 * @throws MalformedURLException 
	 * @throws VSphereException 
	 */

#Code:
	private ClusterComputeResource getClusterByName(final String clusterName, ManagedEntity rootEntity) throws InvalidProperty, RuntimeFault, RemoteException, MalformedURLException {
		if (rootEntity==null) rootEntity=getServiceInstance().getRootFolder();

		return (ClusterComputeResource) new InventoryNavigator(
				rootEntity).searchManagedEntity(
						"ClusterComputeResource", clusterName);
	}

#end
#end
#No. 182671
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * @param clusterName - Name of cluster name to find
	 * @return - ClusterComputeResource object
	 * @throws InvalidProperty
	 * @throws RuntimeFault
	 * @throws RemoteException
	 * @throws MalformedURLException 
	 * @throws VSphereException 
	 */

#Code:
	private ClusterComputeResource getClusterByName(final String clusterName) throws InvalidProperty, RuntimeFault, RemoteException, MalformedURLException {
		return getClusterByName(clusterName, null);
	}

#end
#end
#No. 182672
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * Detroys the VM in vSphere
	 * @param name - VM object to destroy
	 * @param failOnNoExist If true and the VM does not exist then a VSphereException will be thrown.
	 * @throws VSphereException If an error occurred.
	 */

#Code:
	public void destroyVm(String name, boolean failOnNoExist) throws VSphereException{
		try{
			VirtualMachine vm = getVmByName(name);
			if(vm==null){
				if(failOnNoExist) throw new VSphereException("VM \"" + name + "\" does not exist");

				LOGGER.log(Level.FINER, "VM \"" + name + "\" does not exist, or already deleted!");
				return;
			}


			if(!vm.getConfig().template) {
                powerOffVm(vm, true, false);
            }

			final Task task = vm.destroy_Task();
			String status = task.waitForTask();
			if(status.equals(Task.SUCCESS))
			{
				LOGGER.log(Level.FINER, "VM \"" + name + "\" was deleted successfully.");
				return;
			}
			throw newVSphereException(task.getTaskInfo(), "Could not delete VM \""+ name +"\"!");

		} catch(RuntimeException | VSphereException e){
			throw e;
		}catch(Exception e){
			throw new VSphereException(e.getMessage(), e);
		}
	}

#end
#end
#No. 182673
#File: E:\bishe\1\VSphere.java
#Comment:
    /**
     * Renames a VM Snapshot
     * @param vmName the name of the VM whose snapshot is being renamed.
     * @param oldName the current name of the VM's snapshot.
     * @param newName the new name of the VM's snapshot.
     * @param newDescription the new description of the VM's snapshot.
     * @throws VSphereException If an error occurred.
     */

#Code:
    public void renameVmSnapshot(String vmName, String oldName, String newName, String newDescription) throws VSphereException{
        try{
            VirtualMachine vm = getVmByName(vmName);
            if(vm==null){
                throw new VSphereException("VM \"" + vmName + "\" does not exist");
            }

            VirtualMachineSnapshot snapshot = getSnapshotInTree(vm, oldName);

            snapshot.renameSnapshot(newName, newDescription);

            LOGGER.log(Level.FINER, "VM Snapshot was renamed successfully.");
            return;

        } catch(RuntimeException | VSphereException e){
            throw e;
        }catch(Exception e){
            throw new VSphereException(e.getMessage(), e);
        }
    }

#end
#end
#No. 182674
#File: E:\bishe\1\VSphere.java
#Comment:
    /**
     * Renames the VM vSphere
     * @param oldName the current name of the vm
     * @param newName the new name of the vm
     * @throws VSphereException If an error occurred.
     */

#Code:
    public void renameVm(String oldName, String newName) throws VSphereException{
        try{
            VirtualMachine vm = getVmByName(oldName);
            if(vm==null){
                throw new VSphereException("VM \"" + oldName + "\" does not exist");
            }

            final Task task = vm.rename_Task(newName);
            final String status = task.waitForTask();
            if(status.equals(Task.SUCCESS))
            {
                LOGGER.log(Level.FINER, "VM was renamed successfully.");
                return;
            }
            throw newVSphereException(task.getTaskInfo(), "Could not rename VM \""+ oldName +"\"!");

        } catch(RuntimeException | VSphereException e){
            throw e;
        }catch(Exception e){
            throw new VSphereException(e.getMessage(), e);
        }
    }

#end
#end
#No. 182675
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * Private helper functions that finds the datanceter a VirtualMachine belongs to
	 * @param managedEntity - VM object
	 * @return returns Datacenter object
	 */

#Code:
	private Datacenter getDataCenter(ManagedEntity managedEntity)
	{
		if (managedEntity != null) {
			ManagedEntity parent = managedEntity.getParent();
			if (parent.getMOR().getType().equals("Datacenter")) {
				return (Datacenter) parent;
			} else {
				return getDataCenter(managedEntity.getParent());
			}
		} else {
			return null;
		}
	}

#end
#end
#No. 182676
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * Find Distributed Virtual Port Group name in the same Datacenter as the VM
	 * @param virtualMachine - VM object
	 * @param name - the name of the Port Group
	 * @return returns DistributedVirtualPortgroup object for the provided vDS PortGroup
	 * @throws VSphereException If an error occurred.
	 */

#Code:
	public Network getNetworkPortGroupByName(VirtualMachine virtualMachine,
														String name) throws VSphereException
	{
		try {
			Datacenter datacenter = getDataCenter(virtualMachine);
			for (Network network : datacenter.getNetworks())
			{
				if (network instanceof Network &&
						(name.isEmpty() || network.getName().contentEquals(name)))
				{
					return network;
				}
			}
		} catch (Exception e) {
			throw new VSphereException(e);
		}
		return null;
	}

#end
#end
#No. 182677
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * Find Distributed Virtual Port Group name in the same Datacenter as the VM
	 * @param virtualMachine - VM object
	 * @param name - the name of the Port Group
	 * @return returns DistributedVirtualPortgroup object for the provided vDS PortGroup
	 * @throws VSphereException If an error occurred.
	 */

#Code:
	public DistributedVirtualPortgroup getDistributedVirtualPortGroupByName(VirtualMachine virtualMachine,
																			 String name) throws VSphereException
	{
		try {
			Datacenter datacenter = getDataCenter(virtualMachine);
			for (Network network : datacenter.getNetworks())
			{
				if (network instanceof DistributedVirtualPortgroup &&
						(name.isEmpty() || network.getName().contentEquals(name)))
				{
					return (DistributedVirtualPortgroup)network;
				}
			}
		} catch (Exception e) {
			throw new VSphereException(e);
		}
		return null;
	}

#end
#end
#No. 182678
#File: E:\bishe\1\VSphere.java
#Comment:
	/**
	 * Find Distributed Virtual Switch from the provided Distributed Virtual Portgroup
	 * @param distributedVirtualPortgroup - DistributedVirtualPortgroup object for the provided vDS PortGroup
	 * @return returns DistributedVirtualSwitch object that represents the vDS Switch
	 * @throws VSphereException If an error occurred.
	 */

#Code:
	public DistributedVirtualSwitch getDistributedVirtualSwitchByPortGroup(
			DistributedVirtualPortgroup distributedVirtualPortgroup) throws VSphereException
	{
		try
		{
			ManagedObjectReference managedObjectReference = new ManagedObjectReference();
			managedObjectReference.setType("DistributedVirtualSwitch");
			managedObjectReference.setVal(distributedVirtualPortgroup.getConfig().getDistributedVirtualSwitch().getVal());
			return new DistributedVirtualSwitch(getServiceInstance().getServerConnection(), managedObjectReference);
		}
		catch (Exception e)
		{
			throw new VSphereException(e);
		}
	}

#end
#end
#No. 182679
#File: E:\bishe\1\VSphere.java
#Comment:
    /**
     * Passes data to a VM's "guestinfo" object. This data can then be read by
     * the VMware Tools on the guest.
     * <p>
     * e.g. a variable named "Foo" with value "Bar" could be read on the guest
     * using the command-line <tt>vmtoolsd --cmd "info-get guestinfo.Foo"</tt>.
     * </p>
     * 
     * @param vmName
     *            The name of the VM.
     * @param variables
     *            A {@link Map} of variable name to variable value.
     * @throws VSphereException
     *             If an error occurred.
     */

#Code:
    public void addGuestInfoVariable(String vmName, Map<String, String> variables) throws VSphereException {
        VirtualMachineConfigSpec cs = new VirtualMachineConfigSpec();
        OptionValue[] ourOptionValues = new OptionValue[variables.size()];
        List<OptionValue> optionValues = new ArrayList<>();
        for (Map.Entry<String, String> eachVariable : variables.entrySet()) {
            OptionValue ov = new OptionValue();
            ov.setKey("guestinfo." + eachVariable.getKey());
            ov.setValue(eachVariable.getValue());
            optionValues.add(ov);
        }
        for (int i = 0; i < optionValues.size(); i++) {
            ourOptionValues[i] = optionValues.get(i);
        }
        cs.setExtraConfig(ourOptionValues);
        reconfigureVm(vmName, cs);
    }

#end
#end
#No. 182680
#File: E:\bishe\1\VSphere.java
#Comment:
    /**
     * Creates a {@link VSphereException} whose cause is the {@link TaskInfo}'s
     * exception. This provides an exception that is much more informative than
     * what is said by the <code>message</code> alone.
     * 
     * @param taskInfo
     *            The vSphere task that failed.
     * @param message
     *            A line of text that says what the task was trying to achieve.
     * @return An exception that includes the cause of the failure.
     */

#Code:
    private static VSphereException newVSphereException(TaskInfo taskInfo, final String message) {
        final com.vmware.vim25.LocalizedMethodFault error = taskInfo == null ? null : taskInfo.getError();
        final String faultMsg = error == null ? null : error.getLocalizedMessage();
        final Exception fault = error == null ? null : error.getFault();
        final String combinedMsg = message + (faultMsg == null ? "" : ("\n" + faultMsg));
        if (fault != null) {
            return new VSphereException(combinedMsg, fault);
        } else {
            return new VSphereException(combinedMsg);
        }
    }



#end
#end
#No. 182682
#File: E:\bishe\1\vSphereCloudSlave.java
#Comment:
            /* We may be called on any slave type so check that we should
             * be in here. */

#Code:
            if (!(c.getNode() instanceof vSphereCloudSlave)) {
                return;
            }

#end
#end
#No. 182683
#File: E:\bishe\1\vSphereCloudSlaveTemplate.java
#Comment:
    /**
     * Gets the old (deprecated) credentialsId field.
     * 
     * @return the old, deprecated, credentialsId field.
     * @deprecated credentials are now in the {@link #getLauncher()} property.
     */

#Code:
    @Deprecated()
    public String getCredentialsId() {
        return this.credentialsId;
    }

#end
#end
#No. 182684
#File: E:\bishe\1\VSphereLogger.java
#Comment:
	/**
	 * This is simply a wrapper method to clean up this class.  This method
	 * checks the verboseOutput flag and writes to the logger as appropriate.
	 * 
     * @param logger - logger that should receive the information
     * @param str - The text to be logged.
	 */

#Code:
	public static void vsLogger(PrintStream logger, String str){
		if(logger!=null){
			logger.println("["+Messages.VSphereLogger_title()+"] "+str);
		}
	}

#end
#end
#No. 182685
#File: E:\bishe\1\VSphereScannerTest.java
#Comment:
	/*
	 * @Test public void testCreateSetClause() { VSphereScanner scanner = new
	 * VSphereScanner();
	 * 
	 * String clause = scanner.createSetClause("x", mapper.createObjectNode()
	 * .put("a", "1").put("foo", "bar"));
	 * 
	 * assertThat(clause).contains("x.a={a}").contains("x.foo={foo}")
	 * .contains(",");
	 * 
	 * }
	 */

#Code:
	@Test
	public void testComputeMacId() {
		ManagedObjectReference mor = new ManagedObjectReference();
		mor.setType("HostSystem");
		mor.setVal("host-123");

		VMWareScanner s = Mockito.mock(VMWareScanner.class);
		when(s.getVCenterId()).thenReturn("abcdef");
		Mockito.when(s.computeUniqueId(mor)).thenCallRealMethod();

		assertThat(mor.getType()).isEqualTo("HostSystem");
		assertThat(s.computeUniqueId(mor)).isEqualTo("21b23eae3d48797d8d057329705825e637e35d81");

		VMWareScanner s2 = Mockito.mock(VMWareScanner.class);

		when(s2.getVCenterId()).thenReturn("another");
		Mockito.when(s2.computeUniqueId(mor)).thenCallRealMethod();
		assertThat(s.computeUniqueId(mor)).isNotEqualTo(s2.computeUniqueId(mor));
		/*
		 * try { new VSphereScanner().computeMacId(null); } catch (Exception e)
		 * { assertThat(e) .isExactlyInstanceOf(NullPointerException.class)
		 * .hasMessageContaining("cannot be null"); }
		 * 
		 * mor = new ManagedObjectReference(); mor.setType("VirtualMachine");
		 * mor.setVal("vm-123"); try { new VSphereScanner().computeMacId(mor);
		 * fail(); } catch (Exception e) { assertThat(e).isInstanceOf(
		 * IllegalArgumentException.class); }
		 */
	}

#end
#end
#No. 182686
#File: E:\bishe\1\VT100.java
#Comment:
	/**
	 * Clean all screen ( ESC [ 2 J )
	 */

#Code:
	public void cleanScreen() {
		for (int i = 0; i < screenHight; i++) {
			for (int j = 0; j < screenWidth; j++) {
				screen[i][j] = ' ';
			}
		}

	}

#end
#end
#No. 182687
#File: E:\bishe\1\VT100.java
#Comment:
	/**
	 * Clean screen from the begining [0][0] to the current cursot position
	 */

#Code:
	public void cleanToCorsor() {
		for (int i = 0; i <= currentRow; i++) {
			if (i == currentRow) {
				for (int j = 0; j <= currentColumn; j++) {
					screen[i][j] = ' ';
				}
			} else {
				for (int j = 0; j < screenWidth; j++) {
					screen[i][j] = ' ';
				}
			}
		}
	}

#end
#end
#No. 182688
#File: E:\bishe\1\VT100.java
#Comment:
	/**
	 * Get the screen as String
	 */

#Code:
	public String getScreen() {
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i < screenHight; i++) {
			for (int j = 0; j < screenWidth; j++) {
				buf.append(screen[i][j]);
			}
			buf.append("\n");

		}
		return buf.toString();
	}


#end
#end
#No. 182704
#File: E:\bishe\1\Vvr.java
#Comment:
    /**
     * Register the snapshots and the devices to the given {@link MBeanServer}.
     * 
     * @param server
     * @throws JMException
     */

#Code:
    private final void registerElements() throws JMException {
        final UUID vvrUuid = getUuidUuid();

        // Register snapshots
        {
            final Set<UUID> snapshots = vvrInstance.getSnapshots();
            for (final UUID uuid : snapshots) {
                final Snapshot snapshot = vvrInstance.getSnapshot(uuid);
                final VvrSnapshot mbean = new VvrSnapshot(snapshot);
                final ObjectName objectName = VvrObjectNameFactory.newSnapshotObjectName(owner, vvrUuid, uuid);
                server.registerMBean(mbean, objectName);
            }
        }

        // Register devices
        {
            final Set<UUID> devices = vvrInstance.getDevices();
            for (final UUID uuid : devices) {
                final Device device = vvrInstance.getDevice(uuid);
                final VvrDevice mbean = VvrDevice.loadVvrDevice(device, iscsiServer, nbdServer, node);
                devicesMXBeans.put(uuid, new WeakReference<>(mbean));
                final ObjectName objectName = VvrObjectNameFactory.newDeviceObjectName(owner, vvrUuid, uuid);
                server.registerMBean(mbean, objectName);
            }
        }
    }



#end
#end
#No. 182706
#File: E:\bishe\1\Vvr.java
#Comment:
    /**
     * Persist the state <code>deleted</code>.
     */

#Code:
    final void delete() {
        this.vvrInstance.delete();
    }

#end
#end
#No. 182707
#File: E:\bishe\1\VvrDevice.java
#Comment:
    /**
     * Compute the default iSCSI iqn for the given device.
     * 
     * @param vvrDevice
     * @return default iqn.
     */

#Code:
    private static final String getDefaultIqn(final VvrDevice vvrDevice) {
        String name = vvrDevice.getName();
        if (name == null || name.equals("")) {
            name = vvrDevice.getUuid();
        }
        return Constants.IQN_PREFIX + name;
    }

#end
#end
#No. 182708
#File: E:\bishe\1\VvrDevice.java
#Comment:
    /**
     * Compute the default iSCSI alias for the given device.
     * 
     * @param vvrDevice
     * @return default iSCSI alias.
     */

#Code:
    private static final String getDefaultAlias(final VvrDevice vvrDevice) {
        return getDefaultIqn(vvrDevice);
    }

#end
#end
#No. 182709
#File: E:\bishe\1\VvrDevice.java
#Comment:
    /**
     * Take care of activating a device if the according state was persisted.
     */

#Code:
    private final void handleStateOnLoad() {
        activationLock.writeLock().lock();
        try {
            // Could be ro, rw or null
            final String activeState = deviceInstance.getUserProperty(ACTIVE_PROP_NAME_NODE);
            if (activeState != null) {
                if (activeState.equals(ACTIVE_PROP_VALUE_RO)) {
                    doActivate(false);
                }
                else if (activeState.equals(ACTIVE_PROP_VALUE_RW)) {
                    doActivate(true);
                }
            }
        }
        finally {
            activationLock.writeLock().unlock();
        }
    }

#end
#end
#No. 182710
#File: E:\bishe\1\VvrDevice.java
#Comment:
    /*
     * Should be getUuidString(), but, in this case, the JMX attribute would be 'uuidString'
     * 
     * @see io.eguan.vold.model.DeviceMXBean#getUuid()
     */

#Code:
    @Override
    public final String getUuid() {
        return getUuidUuid().toString();
    }

#end
#end
#No. 182711
#File: E:\bishe\1\VvrDevice.java
#Comment:
    /**
     * Open the device and create the iSCSI target.
     * 
     * @param rw
     *            <code>true</code> to open read-write
     */

#Code:
    private final void doActivate(final boolean rw) {
        // TODO create a local task to register target in background after the end of the activation
        try {
            deviceInstance.activate().get();
        }
        catch (InterruptedException | ExecutionException e) {
            // Failed to activate the device
            throw new IllegalStateException(e);
        }
        final ReadWriteHandle rwHandle = deviceInstance.open(rw);

        // Implementation of protocol interface
        protocolDeviceImpl = new ProtocolDeviceImpl(rwHandle, !rw, getIscsiBlockSize());

        // iSCSI target
        final IscsiTarget iScsiTarget = IscsiTarget.newIscsiTarget(getIqn(), getIscsiAlias(), protocolDeviceImpl);
        iscsiServer.addTarget(iScsiTarget);

        // NBD export
        nbdExportName = getName();
        final NbdExport nbdExport = new NbdExport(nbdExportName, protocolDeviceImpl);
        nbdServer.addTarget(nbdExport);
    }

#end
#end
#No. 182712
#File: E:\bishe\1\VvrDevice.java
#Comment:
    /**
     * Set the given properties in the device.
     * 
     * @param keyValues
     *            key/value pairs
     */

#Code:
    private final FutureVoid setDeviceProperties(final String... keyValues) {
        return deviceInstance.setUserProperties(keyValues);
    }

#end
#end
#No. 182713
#File: E:\bishe\1\VvrDevice.java
#Comment:
    /**
     * Remove the given keys from the device properties.
     * 
     * @param keys
     *            property keys
     */

#Code:
    private final FutureVoid removeDeviceProperties(final String... keys) {
        return deviceInstance.unsetUserProperties(keys);
    }

#end
#end
#No. 182714
#File: E:\bishe\1\VvrDevice.java
#Comment:
    /**
     * Check if the item can be changed on the current node. Need activation lock.
     */

#Code:
    private final void checkModifyItem() {
        // No need to take a snapshot if the device is activated RO
        if (ACTIVE_PROP_VALUE_RO.equals(deviceInstance.getUserProperty(ACTIVE_PROP_NAME))) {
            throw new IllegalStateException("Activated read-only");
        }
        // Activated read-write?
        if (ACTIVE_PROP_VALUE_RW.equals(deviceInstance.getUserProperty(ACTIVE_PROP_NAME))) {
            if (!ACTIVE_PROP_VALUE_RW.equals(deviceInstance.getUserProperty(ACTIVE_PROP_NAME_NODE))) {
                throw new IllegalStateException("Activated read-write");
            }
        }
    }

#end
#end
#No. 182715
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Delete a {@link Vvr}.
     * 
     * @see {@link VvrManager#delete(String)}.
     * 
     * @param uuid
     */

#Code:
    private final void delete(final UUID uuid) {
        vvrsLock.writeLock().lock();
        try {
            // Get the requested VVR
            final Vvr vvr = vvrs.get(uuid);
            if (vvr == null) {
                throw new IllegalArgumentException("VVR not found: " + uuid);
            }

            // Flag as deleted (may fail if the VVR is started)
            vvr.delete();

            // Release VVR
            try {
                releaseVvr(vvr, true);
            }
            catch (final Throwable t) {
                // Ignored
                LOGGER.warn("Error while releasing " + vvr, t);
            }

            // Purge requested
            vvrs.remove(uuid);
            if (purger != null) {
                purger.purgeVvr(vvr);
            }
            LOGGER.info("VVR '" + vvr.getName() + "', uuid=" + vvr.getUuid() + " to purge");
        }
        finally {
            vvrsLock.writeLock().unlock();
        }
    }

#end
#end
#No. 182716
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Starts or stops the given VVR. If the source node is set, start/stop on ther source only.
     * 
     * @param uuid
     *            VVR
     * @param node
     *            UUID of the node or <code>null</code> for all nodes
     * @param start
     *            <code>true</code> to start, <code>false</code> to stop
     */

#Code:
    private final void startStop(final UUID uuid, final Uuid node, final boolean start) {
        vvrsLock.readLock().lock();
        try {
            final Vvr vvr = vvrs.get(uuid);
            if (vvr == null) {
                throw new IllegalArgumentException("VVR not found: " + uuid);
            }
            if (node == null || VvrRemoteUtils.equalsUuid(node, msgSource)) {
                if (start) {
                    try {
                        vvr.doStart();
                    }
                    catch (final JMException e) {
                        throw new IllegalStateException("Failed to start " + uuid, e);
                    }
                }
                else {
                    vvr.doStop();
                }
            }
        }
        finally {
            vvrsLock.readLock().unlock();
        }
    }

#end
#end
#No. 182717
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Launch a task to delete the given VVR.
     * 
     * @param uuid
     *            uuid of the VVR to delete
     * @return uuid of the task.
     */

#Code:
    private final UUID createDeleteTask(final String uuid) {
        final RemoteOperation.Builder opBuilder = RemoteOperation.newBuilder();

        // UUID of the VVR to delete
        opBuilder.setUuid(VvrRemoteUtils.newUuid(UUID.fromString(Objects.requireNonNull(uuid, "uuid"))));

        // Submit transaction
        final DtxTaskApi dtxTaskApi = dtxTaskApiRef.get();
        final UUID taskId = VvrRemoteUtils.submitTransaction(opBuilder, dtxTaskApi, owner, msgSource, Type.VVR,
                OpCode.DELETE);
        return taskId;
    }

#end
#end
#No. 182718
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Load a persisted VVR (NrsRepository implementation) from a directory.
     * 
     * @param vvrDir
     *            the path where the VVR is stored
     * @return the loaded Vvr or <code>null</code>
     */

#Code:
    private final Vvr loadVvr(final File vvrDir) {

        final String vvrPath = vvrDir.getAbsolutePath();
        final UUID vvrUuid;
        try {
            vvrUuid = UUID.fromString(vvrDir.getName());
        }
        catch (final Throwable t) {
            LOGGER.warn("Unexpected directory: '" + vvrPath + "' (ignored)", t);
            return null;
        }

        final NrsRepository repository;
        try {
            final NrsRepository.Builder builder = new NrsRepository.Builder();
            builder.repositoryPath(vvrDir).ownerId(owner).nodeId(node).syncClientRef(syncClientRef)
                    .dtxTaskApiRef(dtxTaskApiRef).uuid(vvrUuid);
            repository = builder.load();
        }
        catch (final Throwable t) {
            LOGGER.warn("Failed to load VVR in '" + vvrPath + "' (ignored)", t);
            return null;
        }

        // // Check vvr owner
        // MetaConfiguration configuration = repository.getConfiguration();
        // UUID ownerConfig = OwnerConfigKey.getInstance().getTypedValue(configuration);
        // if(!ownerConfig.equals(owner)){
        // LOGGER.warn("Wrong owner: '" + vvrPath + "', owner expected=" + owner + ", actual=" + ownerConfig +
        // " (ignored)");
        // return null;
        // }

        LOGGER.info("VVR loaded (path='" + vvrPath + "', name='" + repository.getName() + "')");
        return new Vvr(owner, repository, dtxTaskApiRef, iscsiServer, nbdServer, node);
    }

#end
#end
#No. 182719
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Release resources allocated by the {@link Vvr}.
     * 
     * @param vvr
     * @param full
     *            <code>true</code> when the vvr must be completely released
     */

#Code:
    private final void releaseVvr(final Vvr vvr, final boolean full) {
        // Unregister MXBean
        try {
            unregisterVvrMXBean(vvr);
        }
        catch (final Throwable t) {
            // Ignored
            LOGGER.warn("Error while unregistering " + vvr, t);
        }

        // Stop the VVR (if started)
        stopVvr(vvr);

        // Unregister VVR from DTX
        try {
            vvr.dtxUnregister((DtxManager) this.dtxTaskApiRef.get());
        }
        catch (final Throwable t) {
            // Ignored
            LOGGER.warn("Error while unregistering " + vvr, t);
        }

        // Uninitialize the VVR (if initialized)
        if (full) {
            if (vvr.isInitialized()) {
                try {
                    vvr.fini();
                }
                catch (final Throwable t) {
                    // Ignored
                    LOGGER.warn("Error while uninitializing " + vvr, t);
                }
            }
        }
    }

#end
#end
#No. 182720
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Start the VVR provided according to its started flag afterward the function
     */

#Code:
    private final void startVvr(final Vvr vvr) {
        // Start VVR if requested
        final boolean start = vvr.wasStarted();
        if (start) {
            try {
                vvr.doStart(false);
            }
            catch (final Throwable t) {
                LOGGER.error("VVR '" + vvr.getName() + "', uuid=" + vvr.getUuid() + " failed to start");
            }
        }
    }

#end
#end
#No. 182721
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Stop the VVR provided according to its started flag afterward the function
     */

#Code:
    private final void stopVvr(final Vvr vvr) {
        // Stop the VVR (if started)
        if (vvr.isStarted()) {
            try {
                vvr.doStop(false);
            }
            catch (final Throwable t) {
                // Ignored
                LOGGER.warn("Error while stopping " + vvr, t);
            }
        }
    }

#end
#end
#No. 182722
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Register a VVR manager in the MBean server.
     * 
     * @param vvr
     *            VVR to register
     * @throws JMException
     */

#Code:
    private final void registerVvrManagerMXbean(final UUID uid) throws JMException {
        jmxLock.lock();
        try {
            vvrManagerObjName = VvrObjectNameFactory.newVvrManagerObjectName(uid);
            mbeanServer.registerMBean(this, vvrManagerObjName);
        }
        finally {
            jmxLock.unlock();
        }
    }

#end
#end
#No. 182723
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Unregister a VVR in the MBean server.
     * 
     * @param vvr
     *            VVR to unregister
     */

#Code:
    private final void unregisterVvrManagerMXBean() {
        jmxLock.lock();
        try {
            if (vvrManagerObjName != null) {
                mbeanServer.unregisterMBean(vvrManagerObjName);
                vvrManagerObjName = null;
            }
        }
        catch (final Throwable t) {
            // Ignored
            LOGGER.warn("Error while unregistering the VVR manager MXBean", t);
        }
        finally {
            jmxLock.unlock();
        }
    }

#end
#end
#No. 182724
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Register a VVR in the MBean server.
     * 
     * @param vvr
     *            VVR to register
     * @throws JMException
     */

#Code:
    private final void registerVvrMXBean(final Vvr vvr) throws JMException {
        final ObjectName objectName = VvrObjectNameFactory.newVvrObjectName(owner, vvr.getUuidUuid());
        mbeanServer.registerMBean(vvr, objectName);
        LOGGER.info("VVR " + vvr.getUuid() + " registered");
    }

#end
#end
#No. 182725
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Unregister a VVR in the MBean server.
     * 
     * @param vvr
     *            VVR to unregister
     */

#Code:
    private final void unregisterVvrMXBean(final Vvr vvr) {
        try {
            final ObjectName objectName = VvrObjectNameFactory.newVvrObjectName(owner, vvr.getUuidUuid());
            mbeanServer.unregisterMBean(objectName);
            LOGGER.info("VVR " + vvr.getUuid() + " unregistered");
        }
        catch (final InstanceNotFoundException e) {
            // Ignored
            LOGGER.debug(vvr + " not found");
        }
        catch (final Throwable t) {
            // Ignored
            LOGGER.warn("Error while unregistering " + vvr, t);
        }
    }

#end
#end
#No. 182726
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Handle a message on a VVR item.
     * 
     * @param op
     */

#Code:
    private final MessageLite handleMessageItem(final RemoteOperation op) {
        // VVR id should be set
        if (!op.hasVvr()) {
            throw new IllegalArgumentException("VVR not set");
        }
        final UUID vvrId = VvrRemoteUtils.fromUuid(op.getVvr());

        final Vvr vvr;
        vvrsLock.readLock().lock();
        try {
            vvr = vvrs.get(vvrId);
        }
        finally {
            vvrsLock.readLock().unlock();
        }
        if (vvr == null) {
            LOGGER.warn("VVR " + vvrId + " not found, op=" + op.getOp() + ", type=" + op.getType());
            return null;
        }
        return vvr.handleMsg(op);
    }

#end
#end
#No. 182727
#File: E:\bishe\1\VvrManager.java
#Comment:
    /**
     * Constructs information for vvr manager task.
     * 
     * @param operation
     *            The complete operation used to construct the task info
     */

#Code:
    public final DtxTaskInfo createTaskInfo(final RemoteOperation operation) {
        VvrManagerTaskOperation op;
        VvrManagerTargetType targetType;

        final String source = VvrRemoteUtils.fromUuid(operation.getSource()).toString();
        final String targetId = VvrRemoteUtils.fromUuid(operation.getUuid()).toString();

        switch (operation.getType()) {
        case VVR:
            targetType = VvrManagerTargetType.VVR;
            break;
        default:
            throw new AssertionError("type=" + operation.getType());
        }

        switch (operation.getOp()) {
        case CREATE:
            op = VvrManagerTaskOperation.CREATE;
            break;
        case DELETE:
            op = VvrManagerTaskOperation.DELETE;
            break;
        case START:
            op = VvrManagerTaskOperation.START;
            break;
        case STOP:
            op = VvrManagerTaskOperation.STOP;
            break;
        default:
            throw new AssertionError("type=" + operation.getOp());
        }
        return new VvrManagerTaskInfo(source, op, targetType, targetId);
    }

#end
#end
#No. 182728
#File: E:\bishe\1\VvrManagerTargetType.java
#Comment:
/**
 * Type of the target for a task.
 * 
 * @author oodrive
 * @author ebredzinski
 * 
 */

#Code:
public enum VvrManagerTargetType {
    VVR;
}

#end
#end
#No. 182729
#File: E:\bishe\1\VvrManagerTaskInfo.java
#Comment:
    /**
     * Gets the Operation of the task. May be not be null.
     * 
     * @return the operation of the task
     */

#Code:
    public final VvrManagerTaskOperation getOperation() {
        return this.operation;
    }

#end
#end
#No. 182730
#File: E:\bishe\1\VvrManagerTaskInfo.java
#Comment:
    /**
     * Gets the target type of the task. May be not be null.
     * 
     * @return the type of the target
     */

#Code:
    public final VvrManagerTargetType getTargetType() {
        return this.targetType;
    }

#end
#end
#No. 182731
#File: E:\bishe\1\VvrManagerTaskInfo.java
#Comment:
    /**
     * Gets the target ID of the task. May be not be null.
     * 
     * @return the ID of the target
     */

#Code:
    public final String getTargetId() {
        return this.targetId;
    }

#end
#end
#No. 182732
#File: E:\bishe\1\VvrManagerTaskOperation.java
#Comment:
/**
 * Operation of a vvr manager task
 * 
 * @author oodrive
 * @author ebredzinski
 * 
 */

#Code:
public enum VvrManagerTaskOperation {
    CREATE, DELETE, START, STOP;
}

#end
#end
#No. 182733
#File: E:\bishe\1\VvrManagerTestUtils.java
#Comment:
    /**
     * Create a {@link VvrManager} instance using {@link DummyMBeanServer} as the MBeanServer.
     * 
     * @param voldTestHelper
     * 
     * @return A {@link VvrManager} object.
     */

#Code:
    public final static VvrManager createVvrManager(final VoldTestHelper voldTestHelper) throws NullPointerException,
            IllegalArgumentException, IOException, ConfigValidationException {

        final InetAddress bindAddr = InetAddress.getLoopbackAddress();
        return createVvrManager(DummyMBeanServer.getMBeanServer1(), voldTestHelper, null, new IscsiServer(bindAddr),
                new NbdServer(bindAddr));
    }

#end
#end
#No. 182734
#File: E:\bishe\1\VvrManagerTestUtils.java
#Comment:
    /**
     * Create a {@link VvrManager} instance using {@link DummyMBeanServer} as the MBeanServer.
     * 
     * @param voldTestHelper
     * 
     * @return A {@link VvrManager} object.
     */

#Code:
    public final static VvrManager createVvrManager(final VoldTestHelper voldTestHelper,
            final DummyMBeanServer dummyMBeanServer) throws NullPointerException, IllegalArgumentException,
            IOException, ConfigValidationException {

        final InetAddress bindAddr = InetAddress.getLoopbackAddress();
        return createVvrManager(dummyMBeanServer, voldTestHelper, null, new IscsiServer(bindAddr), new NbdServer(
                bindAddr));
    }

#end
#end
#No. 182735
#File: E:\bishe\1\VvrManagerTestUtils.java
#Comment:
    /**
     * Create a {@link VvrManager}
     * 
     * @param voldTestHelper
     * @param dummyMBeanServer
     * @param nodeId
     *            the node ID to set
     * @param iscsi
     *            server
     * 
     * @return A {@link VvrManager} object.
     */

#Code:
    public final static VvrManager createVvrManager(final DummyMBeanServer dummyMBeanServer,
            final VoldTestHelper voldTestHelper, final String nodeId, final IscsiServer iscsiServer,
            final NbdServer nbdServer) throws NullPointerException, IllegalArgumentException, IOException,
            ConfigValidationException {
        // Create the MetaConfiguration from the VVR template file
        final File voldDir = voldTestHelper.getVoldFile();

        final MetaConfiguration vvrTemplate = MetaConfiguration.newConfiguration(new File(voldDir,
                VoldTestHelper.VVR_TEMPLATE), CommonConfigurationContext.getInstance(), FileMapperConfigurationContext
                .getInstance(), IbsConfigurationContext.getInstance(), NrsConfigurationContext.getInstance(),
                PersistenceConfigurationContext.getInstance());

        // Create the MetaConfiguration from the VOLD file
        final MetaConfiguration metaConfiguration = MetaConfiguration.newConfiguration(new File(voldDir,
                VoldTestHelper.VOLD_CONFIG_FILE), VoldConfigurationContext.getInstance(),
                IscsiServerConfigurationContext.getInstance(), NbdServerConfigurationContext.getInstance(),
                DtxConfigurationContext.getInstance());

        final UUID nodeUuid = (nodeId == null) ? NodeConfigKey.getInstance().getTypedValue(metaConfiguration) : UUID
                .fromString(nodeId);
        final VvrManager vvrManager = new VvrManager(dummyMBeanServer, OwnerConfigKey.getInstance().getTypedValue(
                metaConfiguration), nodeUuid, voldTestHelper.getVvrsFile(), vvrTemplate, iscsiServer, nbdServer);

        return vvrManager;
    }

#end
#end
#No. 182736
#File: E:\bishe\1\VvrManagerTestUtils.java
#Comment:
    /**
     * Wait for the apparition of MXBeans.
     * 
     * @param server
     *            a dummyMBeanServer
     * @param nbMXBean
     *            the wanted number of mx beans
     * 
     * @return true if there are at least nbMXBean registered MXBeans, otherwise false.
     */

#Code:
    public final static boolean waitMXBeanNumber(final DummyMBeanServer server, final int nbMXBean)
            throws InterruptedException {
        int i = 0;
        int currentNumber = 0;
        while ((currentNumber = server.getNbMXBeans()) < nbMXBean && i < 100) {
            Thread.sleep(200);
            i++;
        }
        if (currentNumber >= nbMXBean) {
            return true;
        }
        else {
            return false;
        }
    }

#end
#end
#No. 182737
#File: E:\bishe\1\VvrRemoteUtils.java
#Comment:
    /**
     * Sends a {@link VvrRemote} message to the given destinations. The source, type and opCode are filled. Nothing is
     * sent if <code>startpoint</code> or <code>source</code> is <code>null</code>.
     * 
     * @param opBuilder
     *            message builder
     * @param startpoint
     *            message destination
     * @param source
     *            message source
     * @param type
     *            type of object
     * @param opCode
     *            operation on object
     * @return status of sync request or <code>null</code> for async messages or stand alone mode
     * @throws InterruptedException
     * @throws MsgServerTimeoutException
     * @throws ConnectException
     *             if peer != null
     */

#Code:
    public static final Collection<MsgServerRemoteStatus> sendMessage(final RemoteOperation.Builder opBuilder,
            final MsgClientStartpoint startpoint, final Uuid source, final Type type, final OpCode opCode,
            final boolean async, final UUID peer) throws MsgServerTimeoutException, InterruptedException,
            ConnectException {
        // Stand alone?
        if (startpoint == null) {
            return null;
        }

        // Source is immutable, no need to make a defensive copy
        opBuilder.setVersion(ProtocolVersion.VERSION_1);
        opBuilder.setSource(Objects.requireNonNull(source));
        opBuilder.setType(type);
        opBuilder.setOp(opCode);
        final RemoteOperation operation = opBuilder.build();
        if (async) {
            try {
                startpoint.sendAsyncMessage(operation);
            }
            catch (final Exception e) {
                LOGGER.warn(
                        "Failed to send message type=" + type + ", uuid="
                                + (operation == null ? "?" : fromUuid(operation.getUuid()).toString()) + ", op="
                                + opCode, e);
            }
            return null;
        }
        else {
            if (peer == null) {
                return startpoint.sendSyncMessage(operation);
            }
            else {
                final MsgServerRemoteStatus status = startpoint.sendSyncMessageNewChannel(peer, operation);
                final Collection<MsgServerRemoteStatus> result = new ArrayList<>(1);
                result.add(status);
                return result;
            }
        }
    }

#end
#end
#No. 182738
#File: E:\bishe\1\VvrRemoteUtils.java
#Comment:
    /**
     * Submit a {@link VvrRemote} message to the given destinations as a transaction. The source, type and opCode are
     * filled.
     * 
     * @param opBuilder
     *            message builder
     * @param dtxTaskApi
     *            dtx manager
     * @param resourceId
     *            id of resource manager
     * @param source
     *            message source
     * @param type
     *            type of object
     * @param opCode
     *            operation on object
     * @return the task ID or null if on mode stand alone
     */

#Code:
    public static final UUID submitTransaction(final RemoteOperation.Builder opBuilder, final DtxTaskApi dtxTaskApi,
            final UUID resourceId, final Uuid source, final Type type, final OpCode opCode) {

        // Fill builder
        // source is immutable, no need to make a defensive copy
        opBuilder.setVersion(ProtocolVersion.VERSION_1);
        opBuilder.setSource(source);
        opBuilder.setType(type);
        opBuilder.setOp(opCode);

        // Submit transaction in mode distributed
        RemoteOperation operation = null;
        try {
            operation = opBuilder.build();
            final byte[] payload = operation.toByteArray();
            return dtxTaskApi.submit(resourceId, payload);
        }
        catch (final Error | IllegalStateException e) {
            LOGGER.warn("Failed to submit transaction resourceId=" + resourceId + ", type=" + type + ", uuid="
                    + (operation == null ? "?" : fromUuid(operation.getUuid()).toString()) + ", op=" + opCode, e);
            throw e;
        }
        catch (final Exception e) {
            LOGGER.warn("Failed to submit transaction resourceId=" + resourceId + ", type=" + type + ", uuid="
                    + (operation == null ? "?" : fromUuid(operation.getUuid()).toString()) + ", op=" + opCode, e);
            throw new IllegalStateException(e);
        }
    }

#end
#end
#No. 182739
#File: E:\bishe\1\VvrRemoteUtils.java
#Comment:
    /**
     * Create dtx context containing the deserialized payload.
     */

#Code:
    public static final DtxResourceManagerContext createDtxContext(final UUID resourceManagerId, final byte[] payload)
            throws InvalidProtocolBufferException {
        final RemoteOperation operation = RemoteOperation.parseFrom(payload);
        return new VvrDtxRmContext(resourceManagerId, operation);
    }

#end
#end
#No. 182740
#File: E:\bishe\1\VvrTargetType.java
#Comment:
/**
 * Target type of a VVR task.
 * 
 * @author oodrive
 * @author ebredzinski
 * 
 */

#Code:
public enum VvrTargetType {
    VVR, SNAPSHOT, DEVICE;
}



#end
#end
#No. 182742
#File: E:\bishe\1\VvrTask.java
#Comment:
    /**
     * Gets the status of the task.
     * 
     * @return the status of the task.
     */

#Code:
    public final DtxTaskStatus getStatus() {
        return status;
    }

#end
#end
#No. 182743
#File: E:\bishe\1\VvrTask.java
#Comment:
    /**
     * Gets the info of the task. May be null.
     * 
     * @return a {@link VvrTaskInfo} representing the additionnal info of this task
     */

#Code:
    public final VvrTaskInfo getInfo() {
        return info;
    }


#end
#end
#No. 182745
#File: E:\bishe\1\VvrTaskInfo.java
#Comment:
    /**
     * Gets the target type of the task. May be not be null.
     * 
     * @return the type of the target
     */

#Code:
    public final VvrTargetType getTargetType() {
        return this.targetType;
    }

#end
#end
#No. 182746
#File: E:\bishe\1\VvrTaskInfo.java
#Comment:
    /**
     * Gets the target ID of the task. May be not be null.
     * 
     * @return the ID of the target
     */

#Code:
    public final String getTargetId() {
        return targetId;
    }

#end
#end
#No. 182747
#File: E:\bishe\1\VvrTaskOperation.java
#Comment:
/**
 * Operation of a VVR task.
 * 
 * @author oodrive
 * @author ebredzinski
 * 
 */

#Code:
public enum VvrTaskOperation {
    CREATE, DELETE, SET, CLONE;
}




#end
#end
#No. 182757
#File: E:\bishe\1\Wad.java
#Comment:
  /*
   * bundle the WadC source into the WAD
   * XXX: Issues:
   *    * include directives are expanded, so need to be commented out
   *    * we might need to insert an extra newline between files
   */

#Code:
  int writewadcsource() throws IOException {
      byte[] nl = "\n".getBytes("UTF-8");
      int l = 0;

      for(String s : Arrays.asList(
        "-- generated with WadC version ", getVersion(), "\n",
        mf.getText() )) {

        byte[] v = s.getBytes("UTF-8");
        f.write(v);
        l += v.length;
      }

      // append local included files (not from JAR)
      for(String s : wp.includes) {
          if(Files.isRegularFile(wp.resolveinclude(s))) {
              byte[] b = wp.loadinclude(s).getBytes("UTF-8");
              f.write(nl); l += nl.length;
              f.write(b);  l += b.length;
          }
      }

      return l;
  }



#end
#end
#No. 182759
#File: E:\bishe\1\WadLoader.java
#Comment:
	/** Try to guess a realistic wad size limit based only on the number of lumps and their
	 *  STATED contents, in case it's not possible to get an accurate stream size otherwise.
	 *  Of course, they may be way off with deliberately malformed files etc.
	 *  
	 * @param header
	 * @param lumpinfo2
	 * @return
	 */

#Code:
	
	private long estimateWadSize(wadinfo_t header, lumpinfo_t[] lumpinfo) {
	    
	    long maxsize=header.infotableofs+header.numlumps*16;
	    
	    for (int i=0;i<lumpinfo.length;i++){
	        if ((lumpinfo[i].position+lumpinfo[i].size) >maxsize){
	            maxsize=lumpinfo[i].position+lumpinfo[i].size;
	        }
	    }
	    
        return maxsize;
    }

#end
#end
#No. 182760
#File: E:\bishe\1\WadLoader.java
#Comment:
    /**
     * @param s
     * @param type
     * @throws IOException
     * @throws Exception
     */

#Code:
    protected void addZipFile(String s, int type)
            throws IOException, Exception {
        // Get entries				        
        BufferedInputStream is=new BufferedInputStream(
            InputStreamSugar.createInputStreamFromURI(s, null, type)
            );
        ZipInputStream zip=new ZipInputStream(is);
        List<ZipEntry> zes=InputStreamSugar.getAllEntries(zip);
        zip.close();
        for (ZipEntry zz:zes){
            // The name of a zip file will be used as an identifier
            if (!zz.isDirectory())
            this.AddFile(s,zz, type);
        }
    }

#end
#end
#No. 182761
#File: E:\bishe\1\WadLoader.java
#Comment:
	/** Tells us if a class implements a certain interface.
	 *  If you know of a better way, be my guest.
	 * 
	 * @param what
	 * @param which
	 * @return
	 */

#Code:
	
	protected boolean implementsInterface(Class<?> what, Class<?> which) {
		Class<?>[] shit = what.getInterfaces();
		for (int i = 0; i < shit.length; i++) {
			if (shit[i].equals(which))
				return true;
		}

		return false;
	}





#end
#end
#No. 182765
#File: E:\bishe\1\WagonCancelledException.java
#Comment:
/**
 * Unchecked exception to allow the checked {@link TransferCancelledException} to bubble up from a wagon.
 */

#Code:
class WagonCancelledException
    extends RuntimeException
{

    public WagonCancelledException( TransferCancelledException cause )
    {
        super( cause );
    }

    public static Exception unwrap( Exception e )
    {
        if ( e instanceof WagonCancelledException )
        {
            e = (Exception) e.getCause();
        }
        return e;
    }

}


#end
#end
#No. 182767
#File: E:\bishe\1\Wait.java
#Comment:
    /**
     * Waits the given amount of seconds.
     * <p>
     * If the given value is 0 or negative, the method returns immediately. If an <tt>InterruptedException</tt>
     * is thrown while waiting, the method will return immediately but ignore the exception.
     *
     * @param secondsToWait the number of seconds to wait
     */

#Code:
    public static void seconds(double secondsToWait) {
        millis((int) Math.round(1000 * secondsToWait));
    }

#end
#end
#No. 182768
#File: E:\bishe\1\Wait.java
#Comment:
    /**
     * Waits for an random amount of millisecond within the given bounds.
     * <p>
     * Note that minWaitMillis may be negative. This can be used to only block the thread in a given percentage of
     * all calls. So if the thread should wait between 0 and 500ms in 50% of all calls
     * {@code randomMillis(-500, 500)} can be invoked. Using this bounds, the expected wait time will be
     * between -500ms and 0ms in 50% of all calls (on average). As negative delays are ignored, the method
     * will return immediately.
     *
     * @param minWaitMillis the minimal time to wait in millis.
     * @param maxWaitMillis the maximal time to wait in millis. This must be &gt;= minWaitMillis and also &gt; 0 or the
     *                      method will always return immediately
     */

#Code:
    public static void randomMillis(int minWaitMillis, int maxWaitMillis) {
        if (minWaitMillis > maxWaitMillis || maxWaitMillis < 0) {
            return;
        }
        int pauseInMillis = minWaitMillis + rnd.nextInt(maxWaitMillis - minWaitMillis);
        millis(pauseInMillis);
    }

#end
#end
#No. 182769
#File: E:\bishe\1\Wait.java
#Comment:
    /**
     * Waits for a random amount of seconds within the given bounds.
     * <p>
     * See {@link #randomMillis(int, int)} for a detailed description on using a negative lower bound.
     *
     * @param minWaitSeconds the minimal time to wait in seconds.
     * @param maxWaitSeconds the maximal time to wait in seconds. This must be &gt;= minWaitSeconds and also &gt; 0
     *                       or the
     *                       method will always return immediately
     */

#Code:
    public static void randomSeconds(double minWaitSeconds, double maxWaitSeconds) {
        randomMillis((int) Math.round(1000 * minWaitSeconds), (int) Math.round(1000 * maxWaitSeconds));
    }

#end
#end
#No. 182770
#File: E:\bishe\1\WaitableBoolean.java
#Comment:
/**
 * Not as efficient as AtomicBoolean but you can wait on it.
 *
 * @author TimW
 */

#Code:
class WaitableBoolean {
	
	private boolean val;
	
	public WaitableBoolean(boolean b) {
		this.val = b;
	}
	
	synchronized void set(boolean value) {
		this.val = value;
		notifyAll();
	}
	
	synchronized boolean get() {
		return this.val;
	}
	
	synchronized public void waitFor(long millis) throws InterruptedException {
		super.wait(millis);
	}
}
#end
#end
#No. 182771
#File: E:\bishe\1\WaitCanvas.java
#Comment:
    /** Creates a new instance of WaitCanvas 
     * @param controller    Application controller.
     * @param task          Task to be executed.
     */

#Code:
    public WaitCanvas(IdenticaController controller, AbstractTask task) {
        this.setFullScreenMode(true);
        this.controller = controller;
        this.waitText = "Please wait...";
        this.task = task;
        this.talkBalloon = new TalkBalloon(getWidth(), getHeight());
        this.loadingImage = ImageUtil.loadImage("/images/loading.png");
        loadingImageIndex = 0;
        statusFont = Font.getFont(Font.FACE_SYSTEM, Font.STYLE_BOLD, Font.SIZE_SMALL);
        thread = new Thread(this);
        thread.start();           
    }





#end
#end
#No. 182788
#File: E:\bishe\1\WaitForInstanceToReachStateTask.java
#Comment:
    /**
     * Set the ID of the instance to wait for.
     * 
     * @param instanceId
     *            The ID of the instance to wait for.
     */

#Code:
    public void setInstanceId(String instanceId) {
        this.instanceId = instanceId;
    }

#end
#end
#No. 182789
#File: E:\bishe\1\WaitForInstanceToReachStateTask.java
#Comment:
    /**
     * Set the state to wait for the instance to reach.
     * 
     * @param state
     *            The state to wait for the instance to reach.
     */

#Code:
    public void setState(String state) {
        this.state = state;
    }

#end
#end
#No. 182790
#File: E:\bishe\1\WaitForMenu.java
#Comment:
/**
 * Condition that waits for a shell with the specified text to appear.
 *
 * @see Conditions
 * @author Ketan Padegaonkar &lt;KetanPadegaonkar [at] gmail [dot] com&gt;
 * @version $Id$
 */

#Code:
class WaitForMenu extends WaitForObjectCondition<MenuItem> {

	private final SWTBotShell	shell;

	/**
	 * @param shell the shell to search for the menu.
	 * @param matcher the matcher used for matching the menu items.
	 */
	public WaitForMenu(SWTBotShell shell, Matcher<MenuItem> matcher) {
		super(matcher);
		this.shell = shell;
	}

	public String getFailureMessage() {
		return "Could not find a menu within the shell '" + shell + "' matching '" + matcher + "'"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
	}

	protected List<MenuItem> findMatches() {
		return new MenuFinder().findMenus(shell.widget, matcher, true);
	}

}


#end
#end
#No. 182794
#File: E:\bishe\1\WaitForNatTablePopupMenu.java
#Comment:
	/**
	 * Get popupMenuAction from ui Binding Registry of NatTable by creating
	 * MouseDown event. The private variable menu is obtained by using Java
	 * reflection.
	 *
	 * @return Menu of NatTable for the given cell
	 */

#Code:
	private Menu getNatTableMenu() {
		Event event = NatTableContextMenuFinder.createMouseEvent(control, x, y, 3, SWT.NONE, 1);
		MouseEvent mouseevent = new MouseEvent(event);
		IMouseAction action = ((NatTable) control).getUiBindingRegistry().getMouseDownAction(mouseevent);
		if (action instanceof PopupMenuAction) {
			PopupMenuAction popupMenuAction = (PopupMenuAction) action;
			Field privateMenu = null;
			try {
				privateMenu = PopupMenuAction.class.getDeclaredField("menu");
			} catch (NoSuchFieldException e) {
				return null;
			} catch (SecurityException e) {
				return null;
			}
			privateMenu.setAccessible(true);
			try {
				return (Menu) privateMenu.get(popupMenuAction);
			} catch (IllegalArgumentException e) {
				return null;
			} catch (IllegalAccessException e) {
				return null;
			}
		}
		return null;
	}

#end
#end
#No. 182795
#File: E:\bishe\1\WaitForObjectCondition.java
#Comment:
	/**
	 * @return all objects that matched the matcher.
	 */

#Code:
	public List<T> getAllMatches() {
		return this.matches;
	}

#end
#end
#No. 182796
#File: E:\bishe\1\WaitForObjectCondition.java
#Comment:
	/**
	 * @param index the index of the object.
	 * @return the element at the specified index in the list of matched objects.
	 */

#Code:
	public T get(int index) {
		return this.matches.get(index);
	}




#end
#end
#No. 182804
#File: E:\bishe\1\WaitForServiceDiscoveryRes.java
#Comment:
	/**
	 * According to [V2G2-422] a ServiceDetailsReq is needed in case VAS (value added services)
	 * such as certificate installation/update are to be used and offered by the SECC. 
	 * Furthermore, it must be checked if VAS are allowed (-> only if TLS connection is used)
	 */

#Code:
	private boolean useVAS(ServiceDiscoveryResType serviceDiscoveryRes) {
		if (serviceDiscoveryRes.getServiceList() != null && 
			getCommSessionContext().getTransportLayerClient() instanceof TLSClient) {
			// Check if certificate service is needed
			if (isCertificateServiceOffered(serviceDiscoveryRes.getServiceList())) { 
				getCommSessionContext().setContractCertStatus(SecurityUtils.getContractCertificateStatus());
				
				if (getCommSessionContext().getContractCertStatus().equals(ContractCertificateStatus.INSTALLATION_NEEDED))
					addSelectedService(2, (short) 1); 
				else if (getCommSessionContext().getContractCertStatus().equals(ContractCertificateStatus.UPDATE_NEEDED))
					addSelectedService(2, (short) 2); 
			}
			
			// Optionally, other value added services can be checked for here ...
		} else return false;
		
		return (getCommSessionContext().getServiceDetailsToBeRequested().size() > 0) ? true : false;
	}



#end
#end
#No. 182808
#File: E:\bishe\1\WaitForShell.java
#Comment:
/**
 * Condiion that waits for a shell with the specified text to appear.
 *
 * @see Conditions
 * @author Ketan Padegaonkar &lt;KetanPadegaonkar [at] gmail [dot] com&gt;
 * @version $Id$
 * @since 2.0
 */

#Code:
class WaitForShell extends WaitForObjectCondition<Shell> {

	WaitForShell(Matcher<Shell> matcher) {
		super(matcher);
	}

	public String getFailureMessage() {
		return "Could not find shell matching: " + matcher; //$NON-NLS-1$
	}

	protected List<Shell> findMatches() {
		Shell[] shells = findShells();
		ArrayList<Shell> matchingShells = new ArrayList<Shell>();
		for (Shell shell : shells) {
			if (matcher.matches(shell)) {
				matchingShells.add(shell);
			}
		}
		return matchingShells;
	}

	/**
	 * Subclasses may override to find other shells.
	 */
	Shell[] findShells() {
		return bot.getFinder().getShells();
	}

}

#end
#end
#No. 182809
#File: E:\bishe\1\WaitForShellInParent.java
#Comment:
/**
 * A contdition that waits until a shell matching the matcher appears in the parent shell.
 *
 * @see Conditions
 * @author Ketan Patel &lt;ktp420@live.com&gt;
 * @author Ketan Padegaonkar &lt;KetanPadegaonkar [at] gmail [dot] com&gt;
 * @version $Id$
 */

#Code:
class WaitForShellInParent extends WaitForShell {
	private final Shell	parent;

	WaitForShellInParent(Shell parent, Matcher<Shell> matcher) {
		super(matcher);
		this.parent = parent;
	}

	protected Shell[] findShells() {
		return UIThreadRunnable.syncExec(new ArrayResult<Shell>() {
			public Shell[] run() {
				return parent.getShells();
			}
		});
	}

}

#end
#end
#No. 182810
#File: E:\bishe\1\WaitForStackToReachStateTask.java
#Comment:
    /**
     * Set the name of this stack. Required.
     * 
     * @param stackName
     *            The stack name
     */

#Code:
    public void setStackName(String stackName) {
        this.stackName = stackName;
    }

#end
#end
#No. 182811
#File: E:\bishe\1\WaitForStackToReachStateTask.java
#Comment:
    /**
     * Set the status to wait for this stack to reach. Should not contain
     * "FAILED"
     * 
     * @param status
     *            The status to wait for this stack to reach.
     */

#Code:
    public void setStatus(String status) {
        this.status = status;
    }

#end
#end
#No. 182812
#File: E:\bishe\1\WaitForStackToReachStateTask.java
#Comment:
    /**
     * Waits for the specified stack to reach the specified status. Returns true
     * if it does, returns false if it reaches a status with "FAILED", or if 30
     * minutes pass without reaching the desired status.
     */

#Code:
    private void checkParams() {
        boolean areMissingParams = false;
        StringBuilder errors = new StringBuilder("");

        if (stackName == null) {
            areMissingParams = true;
            errors.append("Missing parameter: stackName is required \n");
        }

        if (status == null) {
            areMissingParams = true;
            errors.append("Missing parameter: stackName is required \n");
        }

        if (areMissingParams) {
            throw new BuildException(errors.toString());
        }
    }



#end
#end
#No. 182815
#File: E:\bishe\1\WaitForSupportedAppProtocolReq.java
#Comment:
	/**
	 * All supported versions of the ISO/IEC 15118-2 protocol are listed here.
	 * Currently, only IS version of April 2014 is supported (see [V2G2-098]), more could be provided here.
	 * The values for priority and schema ID do not need to be set since these values are provided by
	 * the EVCC.
	 * 
	 * @return A list of supported of AppProtocol entries 
	 */

#Code:
	private List<AppProtocolType> getSupportedAppProtocols() {
		List<AppProtocolType> supportedAppProtocols = new ArrayList<AppProtocolType>();
		
		AppProtocolType appProtocol1 = new AppProtocolType();
		appProtocol1.setProtocolNamespace(GlobalValues.V2G_CI_MSG_DEF_NAMESPACE.toString());
		appProtocol1.setVersionNumberMajor(2);
		appProtocol1.setVersionNumberMinor(0);
		
		supportedAppProtocols.add(appProtocol1);
		
		return supportedAppProtocols;
	}




#end
#end
#No. 182819
#File: E:\bishe\1\WaitForWidget.java
#Comment:
/**
 * @author Ketan Padegaonkar &lt;KetanPadegaonkar [at] gmail [dot] com&gt;
 * @see Conditions
 * @version $Id$
 * @since 2.0
 */

#Code:
class WaitForWidget<T extends Widget> extends WaitForObjectCondition<T> {

	WaitForWidget(Matcher<T> matcher) {
		super(matcher);
	}

	public String getFailureMessage() {
		return "Could not find widget matching: " + matcher; //$NON-NLS-1$
	}

	protected List<T> findMatches() {
		return bot.getFinder().findControls(matcher);
	}

}

#end
#end
#No. 182820
#File: E:\bishe\1\WaitForWidgetInParent.java
#Comment:
/**
 * @author Ketan Padegaonkar &lt;KetanPadegaonkar [at] gmail [dot] com&gt;
 * @see Conditions
 * @version $Id$
 * @since 2.0
 */

#Code:
class WaitForWidgetInParent<T extends Widget> extends WaitForObjectCondition<T> {

	private final Widget	parent;

	WaitForWidgetInParent(Matcher<T> matcher, Widget parent) {
		super(matcher);
		this.parent = parent;
	}

	public String getFailureMessage() {
		return "Could not find widget matching: " + matcher; //$NON-NLS-1$
	}

	protected List<T> findMatches() {
		return bot.getFinder().findControls(parent, matcher, true);
	}

}


#end
#end
#No. 182822
#File: E:\bishe\1\WaitingFragmentDialog.java
#Comment:
	/**
	 * Title: show
	 * Description:android.support.v4.app.FragmentManager.getSupportFragmentManager()
	 * @param manager
	 */

#Code:
	public void show(FragmentManager manager){
		show(manager, "waitingDialog");
	}



#end
#end
#No. 182832
#File: E:\bishe\1\WaitProvider.java
#Comment:
	/**
	 * Gets wrapped wait with wait while flag.
	 * 
	 * @param waitCondition condition to wait while
	 * @return wrapped wait
	 */

#Code:
	public static WaitWrapper waitWhile(WaitCondition waitCondition) {
		return new WaitWrapper(waitCondition, WaitType.WHILE);
	}

#end
#end
#No. 182833
#File: E:\bishe\1\WaitProvider.java
#Comment:
	/**
	 * Gets wrapped wait with wait until flag.
	 * 
	 * @param waitCondition condition to wait until
	 * @return wrapped wait
	 */

#Code:
	public static WaitWrapper waitUntil(WaitCondition waitCondition) {
		return new WaitWrapper(waitCondition, WaitType.UNTIL);
	}




#end
#end
#No. 182836
#File: E:\bishe\1\WaitUntilNotifiedTest.java
#Comment:
  /**
   * Fails the test unless the time from start until now is duration, accepting differences in
   * -50..+450 milliseconds.
   */

#Code:
  private void assertElapsed(double duration, double start) {
    assertEquals(duration, now() - start - 200d, 250.0);
  }

#end
#end
#No. 182837
#File: E:\bishe\1\WakefulBroadcastReceiver.java
#Comment:
    /**
     * Finish the execution from a previous {@link #startWakefulService}.  Any wake lock
     * that was being held will now be released.
     *
     * @param intent The Intent as originally generated by {@link #startWakefulService}.
     * @return Returns true if the intent is associated with a wake lock that is
     * now released; returns false if there was no wake lock specified for it.
     */

#Code:
    public static boolean completeWakefulIntent(Intent intent) {
        final int id = intent.getIntExtra(EXTRA_WAKE_LOCK_ID, 0);
        if (id == 0) {
            return false;
        }
        synchronized (mActiveWakeLocks) {
            PowerManager.WakeLock wl = mActiveWakeLocks.get(id);
            if (wl != null) {
                wl.release();
                mActiveWakeLocks.remove(id);
                return true;
            }
            // We return true whether or not we actually found the wake lock
            // the return code is defined to indicate whether the Intent contained
            // an identifier for a wake lock that it was supposed to match.
            // We just log a warning here if there is no wake lock found, which could
            // happen for example if this function is called twice on the same
            // intent or the process is killed and restarted before processing the intent.
            Log.w("WakefulBroadcastReceive", "No active wake lock id #" + id);
            return true;
        }
    }

#end
#end
#No. 182838
#File: E:\bishe\1\Wakelock.java
#Comment:
	/**
	 * Substracts the values from a previous object
	 * found in myList from the current Process
	 * in order to obtain an object containing only the data since a referenc
	 * @param myList
	 */

#Code:
	public void substractFromRef(List<StatElement> myList )
	{
		if (myList != null)
		{
			for (int i = 0; i < myList.size(); i++)
			{
				try
				{
					Wakelock myRef = (Wakelock) myList.get(i);
					if ( (this.getName().equals(myRef.getName())) && (this.getuid() == myRef.getuid()) )
					{
						Log.i(TAG, "Substraction " + myRef.toString() + " from " + this.toString());
						this.m_duration	-= myRef.getDuration();
						this.setTotal( getTotal() - myRef.getTotal());
						this.m_count	-= myRef.getCount();
						Log.i(TAG, "Result: " + this.toString());
						if ((m_count < 0) || (m_duration < 0) || (getTotal() < 0))
						{
							Log.e(TAG, "substractFromRef generated negative values (" + this.toString() + " - " + myRef.toString() + ")");
						}
						break;
					}
				}
				catch (ClassCastException e)
				{
					// just log as it is no error not to change the process
					// being substracted from to do nothing
					Log.e(TAG, "substractFromRef was called with a wrong list type");
				}
				
			}
		}
	}

#end
#end
#No. 182839
#File: E:\bishe\1\Wakelock.java
#Comment:
	/**
	 * @return the wakeType
	 */

#Code:
	public int getWakeType() {
		return m_wakeType;
	}

#end
#end
#No. 182840
#File: E:\bishe\1\Wakelock.java
#Comment:
	/**
	 * @return the name
	 */

#Code:
	public String getName() {
		return m_name;
	}

#end
#end
#No. 182841
#File: E:\bishe\1\Wakelock.java
#Comment:
	/**
	 * @return the duration
	 */

#Code:
	public long getDuration() {
		return m_duration;
	}

#end
#end
#No. 182842
#File: E:\bishe\1\Wakelock.java
#Comment:
	/**
	 * @return the count
	 */

#Code:
	public int getCount() {
		return m_count;
	}

#end
#end
#No. 182843
#File: E:\bishe\1\Wakelock.java
#Comment:
	 /**
     * Compare a given Wakelock with this object.
     * If the duration of this object is 
     * greater than the received object,
     * then this object is greater than the other.
     */

#Code:
	public int compareTo(Wakelock o)
	{
		// we want to sort in descending order
		return ((int)(o.getDuration() - this.getDuration()));
	}

#end
#end
#No. 182844
#File: E:\bishe\1\Wakelock.java
#Comment:
	/**
	 * returns a string representation of the data
	 */

#Code:
	public String getData(long totalTime)
	{
		return this.formatDuration(getDuration()) 
			+ " Count:" + getCount()
			+ " " + this.formatRatio(getDuration(), totalTime);
	}

#end
#end
#No. 182845
#File: E:\bishe\1\Wakelock.java
#Comment:
	/** 
	 * returns the values of the data
	 */

#Code:
	public double[] getValues()
	{
		double[] retVal = new double[2];
		retVal[0] = getDuration();
		return retVal;
	}

#end
#end
#No. 182846
#File: E:\bishe\1\WakeLockUtil.java
#Comment:
    /**
     * Do a {@link android.content.Context#startService(android.content.Intent)
     * Context.startService}, but holding a wake lock while the service starts.
     * This will modify the Intent to hold an extra identifying the wake lock;
     * when the service receives it in {@link android.app.Service#onStartCommand
     * Service.onStartCommand}, it should pass back the Intent it receives there to
     * {@link #completeWakefulIntent(android.content.Intent)} in order to release
     * the wake lock.
     *
     * @param context The Context in which it operate.
     * @param intent The Intent with which to start the service, as per
     * {@link android.content.Context#startService(android.content.Intent)
     * Context.startService}.
     */

#Code:
    public static ComponentName startWakefulService(Context context, Intent intent) {
        synchronized (ACTIVE_WAKE_LOCKS) {
            int id = nextId;
            nextId++;
            if (nextId <= 0) {
                nextId = 1;
            }

            intent.putExtra(EXTRA_WAKE_LOCK_ID, id);
            ComponentName comp = context.startService(intent);
            if (comp == null) {
                return null;
            }

            String tag = "wake:" + comp.flattenToShortString();
            PowerManager.WakeLock wakeLock = acquireWakeLock(context, tag, TimeUnit.MINUTES.toMillis(3));
            if (wakeLock != null) {
                ACTIVE_WAKE_LOCKS.put(id, wakeLock);
            }

            return comp;
        }
    }

#end
#end
#No. 182847
#File: E:\bishe\1\WakeLockUtil.java
#Comment:
    /**
     * Finish the execution from a previous {@link #startWakefulService}.  Any wake lock
     * that was being held will now be released.
     *
     * @param intent The Intent as originally generated by {@link #startWakefulService}.
     * @return Returns true if the intent is associated with a wake lock that is
     * now released; returns false if there was no wake lock specified for it.
     */

#Code:
    public static boolean completeWakefulIntent(Intent intent) {
        if (intent == null) {
            return false;
        }

        final int id = intent.getIntExtra(EXTRA_WAKE_LOCK_ID, 0);
        if (id == 0) {
            return false;
        }
        synchronized (ACTIVE_WAKE_LOCKS) {
            releaseWakeLock(ACTIVE_WAKE_LOCKS.get(id));
            ACTIVE_WAKE_LOCKS.remove(id);
            return true;
        }
    }


#end
#end
#No. 182849
#File: E:\bishe\1\WAL.java
#Comment:
	/**
	 * Write an entry to the WAL in HBase. If doCasCheck is true, this does a
	 * compare-and-swap so that the database will only change if the existing
	 * entry's entry.n is equal to casCheckEntry.n .
	 * 
	 * @param casCheckEntry
	 *            The write won't occur unless the entry.n in the database is
	 *            equal to casCheckEntry.n . Pass "null" to require that the
	 *            database value not exist.
	 */

#Code:
	synchronized protected void putWAL(HTableInterface hTable, byte[] entityGroup, 
	long walIndex, WALEntry entry, boolean doCasCheck, WALEntry casCheckEntry) 
	throws IOException {
		ByteArrayOutputStream bao = new ByteArrayOutputStream();
		BinaryEncoder e = EncoderFactory.get().binaryEncoder(bao, null);
		
		writer.write(entry.toAvro(), e);
		e.flush();
		byte[] serializedWALEntry = bao.toByteArray();

		byte[] row = ArrayUtils.addAll(entityGroup, Util.longToBytes(walIndex)); 
		Put put = new Put(row);
		put.add(cf, ENTRY_BYTES, serializedWALEntry);
		put.add(cf, N_BYTES, Util.longToBytes(entry.n));
		if (doCasCheck) {
			// Atomic compare and swap: write the new value if and only if the
			// n value hasn't changed since we read it.
			byte[] casNBytes;
			if (casCheckEntry == null) {
				casNBytes = null;
			} else {
				casNBytes = Util.longToBytes(casCheckEntry.n);
			}
			if (!hTable.checkAndPut(row, cf, N_BYTES, casNBytes, put)) {
				throw new CasChanged();
			}
		} else {
			hTable.put(put);
		}
	}

#end
#end
#No. 182850
#File: E:\bishe\1\WAL.java
#Comment:
	/**
	 * Attempt a Paxos accept on behalf of the local data center.
	 * 
	 * @return true if the entry had the highest n seen yet and was written to
	 *         the WAL. false otherwise.
	 */

#Code:
	synchronized boolean acceptLocal(byte[] entityGroup, long walIndex, 
	WALEntry entry) throws IOException {
		int tries = 0;
		while (true) {
			try {
				WALEntry existingEntry = read(entityGroup, walIndex);
				if (existingEntry != null && existingEntry.n > entry.n) {
					return false;
				} else {
					putWAL(entityGroup, walIndex, entry, true, existingEntry);
					return true;
				}
			} catch (CasChanged e) {
				tries++;
				if (tries >= MAX_ACCEPT_TRIES) {
					logger.debug("acceptLocal too many CAS retries");
					throw new TooConcurrent();
				}
				logger.debug("acceptLocal CAS failed, retrying");
			}
		}
	}

#end
#end
#No. 182851
#File: E:\bishe\1\WALEditCodec.java
#Comment:
  /**
   * Create and setup a {@link WALEditCodec} from the {@link Configuration}, if one has been
   * specified. Fully prepares the codec for use in serialization.
   * @param conf {@link Configuration} to read for the user-specified codec. If none is specified,
   *          uses a {@link WALEditCodec}.
   * @param compressionContext compression to setup on the codec.
   * @return a {@link WALEditCodec} ready for use.
   * @throws IOException if the codec cannot be created
   */

#Code:
  public static WALEditCodec create(Configuration conf, CompressionContext compressionContext)
      throws IOException {
    Class<? extends WALEditCodec> codecClazz = conf.getClass(WALEditCodec.WAL_EDIT_CODEC_CLASS_KEY,
      WALEditCodec.class, WALEditCodec.class);
    try {
      WALEditCodec codec = codecClazz.newInstance();
      codec.init(conf);
      codec.setCompression(compressionContext);
      return codec;
    } catch (InstantiationException e) {
      throw new IOException("Couldn't instantiate the configured WALEditCodec!", e);
    } catch (IllegalAccessException e) {
      throw new IOException("Couldn't instantiate the configured WALEditCodec!", e);
    }
  }

#end
#end
#No. 182852
#File: E:\bishe\1\WalkFSABoolean.java
#Comment:
    /**
     * Check if state have an annotation transitiion
     * (transition with annotation label)
     * @param state state to check
     */

#Code:
    public boolean hasAnnotStart(int state) {
        return next(state, ANNOTATION_LABEL) != Constants.INVALID_STATE;
    }

#end
#end
#No. 182853
#File: E:\bishe\1\WalkFSABoolean.java
#Comment:
    /**
     * Collect annotations starting at the state
     * @param state start state
     * @param needSep true if needed a separator to output list
     * @param sepValue separator value
     *
     * @return annotation data
     */

#Code:
    public TIntArrayList collectAnnotationsSimple(int state, boolean needSep, int sepValue) {
        TIntArrayList annots = new TIntArrayList();

        if(!hasAnnotStart(state))
            return annots;

        AnnotationCollector proc = new AnnotationCollector(annots, needSep, sepValue);

        TIntArrayList data = new TIntArrayList();
        collectAnnotations(next(state, 0), data, true, proc);
        return annots;
    }

#end
#end
#No. 182854
#File: E:\bishe\1\WalkFSABoolean.java
#Comment:
    /**
     * Collect annotations starting at this (or at any descendent) state
     * @param state start state
     * @param annots output list for annotations
     * @param addSep if true, add specified separator to the output list
     * @param sepValue separator value for output list
     *
     * @return annotation data
     */

#Code:
    public TIntArrayList collectAnnotations(int state, TIntArrayList annots, boolean addSep, int sepValue) {
        AnnotationCollector proc = new AnnotationCollector(annots, addSep, sepValue);

        collectAnnotations(state, new TIntArrayList(), false, proc);
        return annots;
    }

#end
#end
#No. 182855
#File: E:\bishe\1\WalkFSABoolean.java
#Comment:
    /**
     * Recursively collect annotation from the FSA
     * @param state start state
     * @param data current annotation data
     * @param passedAnnotChar flag of passing the annotation char in the FSA
     * @param proc annotation processor
     *
     * @return annotation data
     */

#Code:
    public void collectAnnotations(int state, TIntArrayList data, boolean passedAnnotChar, AnnotationProcessor proc) {

        if(finals.get(state)) {
            boolean res = proc.process(data);
            if(res)
                return;
        }

        int start = stateStart.get(state);
        int end = state < stateStart.size() - 1? stateStart.get(state + 1) : stateStart.size();

        while(start < end) {
            int input = labels.get(start);
            if(passedAnnotChar)
                data.add(labels.get(start));

            collectAnnotations(dest.get(start), data, input == 0? true : passedAnnotChar, proc);

            if(passedAnnotChar)
                data.removeAt((data.size() - 1));
            start++;
        }

    }

#end
#end
#No. 182856
#File: E:\bishe\1\WalkieService.java
#Comment:
                /* Base64.decode() can throw an exception,
                 * will be better to handle it.
                 */

#Code:
                Log.w( LOG_TAG, ex.toString() );
            }
        }

        public void onServiceLost( NsdServiceInfo nsdServiceInfo )
        {
            try
            {
                final String[] ss = nsdServiceInfo.getServiceName().split( SERVICE_NAME_SEPARATOR );
                final String channelName = new String( Base64.decode( ss[0], 0 ) );
                Log.i( LOG_TAG, "service lost: " + channelName + " [" + nsdServiceInfo + "]" );
                if (channelName.compareTo( SERVICE_NAME ) == 0)
                    m_channel.onServiceLost( nsdServiceInfo );
            }
            catch (final IllegalArgumentException ex)
            {
                /* Base64.decode() can throw an exception, will be better to handle it. */
                Log.w( LOG_TAG, ex.toString() );
            }
        }

#end
#end
#No. 182857
#File: E:\bishe\1\WalkieService.java
#Comment:
        /* Channel has 2 possible operations to stop:
         *    - service registration
         *    - service resolve
         */

#Code:
        final CountDownLatch stopLatch = new CountDownLatch( 2 );
        m_channel.stop( stopLatch );

        try
        {
            stopLatch.await();
        }

#end
#end
#No. 182858
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param difficulty
     * @return
     */

#Code:
    @Override
    public int getMinDamage(Integer difficulty) {
        if (difficulty == null || difficulty > 3 || difficulty < 0) {
            difficulty = Server.getInstance().getDifficulty();
        }
        return this.minDamage[difficulty];
    }

#end
#end
#No. 182859
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param damage
     */

#Code:
    @Override
    public void setDamage(int damage) {
        this.setDamage(damage, Server.getInstance().getDifficulty());
    }

#end
#end
#No. 182860
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param damage
     * @param difficulty
     */

#Code:
    @Override
    public void setDamage(int damage, int difficulty) {
        if (difficulty >= 1 && difficulty <= 3) {
            this.minDamage[difficulty] = damage;
            this.maxDamage[difficulty] = damage;
        }
    }

#end
#end
#No. 182861
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param damage
     */

#Code:
    @Override
    public void setDamage(int[] damage) {
        if (damage.length < 4) {
            return;
        }

        if (minDamage == null || minDamage.length < 4) {
            minDamage = new int[]{0, 0, 0, 0};
        }

        if (maxDamage == null || maxDamage.length < 4) {
            maxDamage = new int[]{0, 0, 0, 0};
        }

        for (int i = 0; i < 4; i++) {
            this.minDamage[i] = damage[i];
            this.maxDamage[i] = damage[i];
        }
    }

#end
#end
#No. 182862
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param damage
     */

#Code:
    @Override
    public void setMinDamage(int[] damage) {
        if (damage.length < 4) {
            return;
        }

        for (int i = 0; i < 4; i++) {
            this.setMinDamage(Math.min(damage[i], this.getMaxDamage(i)), i);
        }
    }

#end
#end
#No. 182863
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param damage
     */

#Code:
    @Override
    public void setMinDamage(int damage) {
        this.setMinDamage(damage, Server.getInstance().getDifficulty());
    }

#end
#end
#No. 182864
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param damage
     * @param difficulty
     */

#Code:
    @Override
    public void setMinDamage(int damage, int difficulty) {
        if (difficulty >= 1 && difficulty <= 3) {
            this.minDamage[difficulty] = Math.min(damage, this.getMaxDamage(difficulty));
        }
    }

#end
#end
#No. 182865
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param damage
     */

#Code:
    @Override
    public void setMaxDamage(int[] damage) {
        if (damage.length < 4)
            return;

        for (int i = 0; i < 4; i++) {
            this.setMaxDamage(Math.max(damage[i], this.getMinDamage(i)), i);
        }
    }

#end
#end
#No. 182866
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param damage
     */

#Code:
    @Override
    public void setMaxDamage(int damage) {
        setMinDamage(damage, Server.getInstance().getDifficulty());
    }

#end
#end
#No. 182867
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param damage
     * @param difficulty
     */

#Code:
    @Override
    public void setMaxDamage(int damage, int difficulty) {
        if (difficulty >= 1 && difficulty <= 3) {
            this.maxDamage[difficulty] = Math.max(damage, this.getMinDamage(difficulty));
        }
    }

#end
#end
#No. 182868
#File: E:\bishe\1\WalkingMonster.java
#Comment:
    /**
     * @param currentTick
     * @return
     */

#Code:
    @Override
    public boolean onUpdate(int currentTick) {
        if (this.closed) {
            return false;
        }

        if (this.server.getDifficulty() < 1) {
            this.close();
            return false;
        }

        if (!this.isAlive()) {
            if (++this.deadTicks >= 23) {
                this.close();
                return false;
            }
            return true;
        }

        int tickDiff = currentTick - this.lastUpdate;
        this.lastUpdate = currentTick;
        this.entityBaseTick(tickDiff);

        Vector3 target = this.updateMove(tickDiff);
        if ((!this.isFriendly() || !(target instanceof Player)) && target instanceof Entity) {
            if (target != this.followTarget || this.canAttack) {
                this.attackEntity((Entity) target);
            }
        } else if (target != null && (Math.pow(this.x - target.x, 2) + Math.pow(this.z - target.z, 2)) <= 1) {
            this.moveTime = 0;
        }
        return true;
    }

#end
#end
#No. 182869
#File: E:\bishe\1\WalkthroughPagerAdapter.java
#Comment:
    /*
     * Mandatory constructor.
     */

#Code:
    public WalkthroughPagerAdapter(FragmentManager fragmentManager) {
        super(fragmentManager);
    }

#end
#end
#No. 182870
#File: E:\bishe\1\WalkthroughPagerAdapter.java
#Comment:
    /*
     * This method is responsible for creating and returning "pages" for the
     * `ViewPager`. You can return any `Fragment` based on the position. It's not
     * necessary to return the same type of `Fragment` all the time.
     */

#Code:
    @Override
    public Fragment getItem(int position) {
        return new WalkthroughItemFragment();
    }

#end
#end
#No. 182871
#File: E:\bishe\1\WalkthroughPagerAdapter.java
#Comment:
    /*
     * The number of pages in the `ViewPager` will be equal to the count
     * that is returned by this method.
     */

#Code:
    @Override
    public int getCount() {
        return 4;
    }

#end
#end
#No. 182872
#File: E:\bishe\1\WalledMazeRandomizer.java
#Comment:
    /**
     * Evaluates if the Provided Cells X,Z is surrounded by other walls
     * 
     * @param allCells
     * @param currentX
     * @param currentZ
     * @return
     */

#Code:
    protected boolean isCellSurrounded(MazeCell[][] allCells, int currentX, int currentZ) {
        int numberOfSidesOccupied = 0;

        for (Direction direction : Direction.getCardinals()) {
            int neighbourX = currentX + direction.x;
            int neighbourZ = currentZ + direction.z;

            if (isCellOutOfBounds(allCells, neighbourX, neighbourZ)) {
                continue;
            }

            if (allCells[neighbourX][neighbourZ].rawState == 1) {
                numberOfSidesOccupied++;
            }
        }

        return numberOfSidesOccupied < 4 ? false : true;
    }

#end
#end
#No. 182873
#File: E:\bishe\1\WalledMazeRandomizer.java
#Comment:
    /**
     * Evaluates if the Cell is Out of Bounds
     * 
     * @param allCells
     * @param currentX
     * @param currentZ
     * @return
     */

#Code:
    private boolean isCellOutOfBounds(MazeCell[][] allCells, int currentX, int currentZ) {
        return currentX < 0 || currentX >= allCells.length || currentZ < 0 || currentZ >= allCells[0].length;
    }

#end
#end
#No. 182874
#File: E:\bishe\1\WalletPrecheckoutDataRequest.java
#Comment:
        /**
         * Gets the value of the pairingDataType property.
         * 
         * @return
         *     possible object is
         *     {@link WalletPrecheckoutDataRequest.PairingDataTypes.PairingDataType }
         *     
         */

#Code:
        public WalletPrecheckoutDataRequest.PairingDataTypes.PairingDataType getPairingDataType() {
            return pairingDataType;
        }

#end
#end
#No. 182875
#File: E:\bishe\1\WalletPrecheckoutDataRequest.java
#Comment:
        /**
         * Sets the value of the pairingDataType property.
         * 
         * @param value
         *     allowed object is
         *     {@link WalletPrecheckoutDataRequest.PairingDataTypes.PairingDataType }
         *     
         */

#Code:
        public void setPairingDataType(WalletPrecheckoutDataRequest.PairingDataTypes.PairingDataType value) {
            this.pairingDataType = value;
        }

#end
#end
#No. 182876
#File: E:\bishe\1\WallGenerator.java
#Comment:
    /**
     * Builds a wall in the world.
     *
     * @param world      The world the wall will be built in.
     * @param diameter   The diameter of the wall.
     * @param wallHeight The height of the wall.
     */

#Code:
    public abstract void build(World world, int diameter, int wallHeight);


    /**
     * Sets a block according to his environment.
     * If the block replaces a "air/tree" block, or if it is next to a transparent block, it needs to be a
     * "wall.block.replaceAir" block.
     * In all other cases, it needs to be a "wall.block.replaceSolid" one.
     *
     * @param block The block to set.
     * @param position The position of the current wall in the world
     */
    protected void setBlock(Block block, WallPosition position)
    {
        // The block is a transparent block or a tree
        if (isBlockTransparentOrNatural(block.getType()))
        {
            block.setType(wallBlockAir);
        }
        // We set the block according to the block near it inside the border.
        else
        {
            Material innerMaterial = getInnerBlock(block, position).getType();
            if (isBlockTransparentOrNatural(innerMaterial))
            {
                block.setType(wallBlockAir);
            }
            else
            {
                block.setType(wallBlockSolid);
            }
        }

        this.blocksSet++;
    }

#end
#end
#No. 182877
#File: E:\bishe\1\WallGenerator.java
#Comment:
    /**
     * Gets the block left to the given block inside the border.
     *
     * @param block The reference block.
     * @param position The position of the wall currently build.
     */

#Code:
    protected Block getInnerBlock(Block block, WallPosition position)
    {
        // Just for readability.
        World world = block.getWorld();
        Integer x = block.getX();
        Integer y = block.getY();
        Integer z = block.getZ();

        switch (position)
        {
            case EAST:
                return world.getBlockAt(x - 1, y, z);
            case NORTH:
                return world.getBlockAt(x, y, z + 1);
            case SOUTH:
                return world.getBlockAt(x, y, z - 1);
            case WEST:
                return world.getBlockAt(x + 1, y, z);
            default: // wait what?
                return null;
        }
    }

#end
#end
#No. 182878
#File: E:\bishe\1\WallImageActivity.java
#Comment:
    /**
     * Loads the {@link red.yelo.fragments.ImageViewFragment} into the fragment container
     * and opens the image through the url supplied
     */

#Code:
    public void loadWallImageScreen(String wall_image) {


        Bundle args = new Bundle();
        args.putString(AppConstants.Keys.WALL_IMAGES, wall_image);
        loadFragment(R.id.frame_content, (AbstractYeloFragment) Fragment
                        .instantiate(this, ImageViewFragment.class
                                .getName(), args), AppConstants.FragmentTags.SEARCH, false,
                null
        );

    }



#end
#end
#No. 182880
#File: E:\bishe\1\WallpaperCropActivity.java
#Comment:
    /**
     * The maximum bitmap size we allow to be returned through the intent.
     * Intents have a maximum of 1MB in total size. However, the Bitmap seems to
     * have some overhead to hit so that we go way below the limit here to make
     * sure the intent stays below 1MB.We should consider just returning a byte
     * array instead of a Bitmap instance to avoid overhead.
     */

#Code:
    public static final int MAX_BMAP_IN_INTENT = 750000;
    private static final float WALLPAPER_SCREENS_SPAN = 2f;

    protected CropView mCropView;
    protected Uri mUri;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        init();
        if (!enableRotation()) {
            setRequestedOrientation(Configuration.ORIENTATION_PORTRAIT);
        }
    }

#end
#end
#No. 182881
#File: E:\bishe\1\WallPosition.java
#Comment:
/**
 * Used to determine in witch wall we are, to get the "inner" block.
 *
 * North: small Z
 * South: big Z
 * East:  big X
 * West:  small X
 */

#Code:
public enum WallPosition
{
    NORTH,
    SOUTH,
    EAST,
    WEST
}

#end
#end
#No. 182882
#File: E:\bishe\1\WallPostActivity.java
#Comment:
    /**
     * Loads the {@link red.yelo.fragments.WallPostFragment} into the fragment container
     */

#Code:
    public void loadWallPostScreen() {


        Intent intent = getIntent();

        Bundle args = new Bundle();

        args.putString(AppConstants.Keys.ID, intent.getStringExtra(AppConstants.Keys.ID));
        args.putString(AppConstants.Keys.NOTIFICATION_ID, intent.getStringExtra(AppConstants.Keys.NOTIFICATION_ID));
        args.putBoolean(AppConstants.Keys.FROM_PROFILE, intent.getBooleanExtra(AppConstants.Keys.FROM_PROFILE, false));
        if (intent.hasExtra(AppConstants.Keys.FROM_TAG)) {
            args.putBoolean(AppConstants.Keys.FROM_TAG, intent.getBooleanExtra(AppConstants.Keys.FROM_TAG, false));
        }
        if (intent.hasExtra(AppConstants.Keys.FROM_NOTIFICATIONS)) {
            args.putBoolean(AppConstants.Keys.FROM_NOTIFICATIONS, intent.getBooleanExtra(AppConstants.Keys.FROM_NOTIFICATIONS, false));
        }

        if(intent.hasExtra(AppConstants.Keys.COMMENT)){
            args.putBoolean(AppConstants.Keys.COMMENT, true);

        }


        /**
         * TODO: Uncomment the below
         */

        loadFragment(R.id.frame_content, (AbstractYeloFragment) Fragment
                        .instantiate(this, WallPostFragment.class
                                .getName(), args), AppConstants.FragmentTags.WALL_POST, false,
                null
        );



    }

#end
#end
#No. 182883
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * This sets all the UI ids for the fragment
     *
     * @param contentView main fragment view
     * @param headerView  header view for the listView
     */

#Code:
    private void getSetViewIds(View contentView, View headerView) {
        mChatButton = (TextView) contentView.findViewById(R.id.connect_button);
        mRecommendFriendButton = (TextView) contentView.findViewById(R.id.recommend_button);
        mNameText = (TextView) headerView.findViewById(R.id.text_user_name);
        mDateText = (TextView) headerView.findViewById(R.id.post_time);
        mMessageText = (TextView) headerView.findViewById(R.id.text_post_message);
        mImageUser = (OkulusImageView) headerView.findViewById(R.id.image_user);
        mWallImage = (ImageView) headerView.findViewById(R.id.wall_image);
        mProgressWheel = (ProgressBar) contentView.findViewById(R.id.progress_wheel);
        mToolbarTransparent = (Toolbar) contentView.findViewById(R.id.my_awesome_toolbar_transparent);
        mToolbar = (Toolbar) contentView.findViewById(R.id.my_awesome_toolbar);
        mGroupNameText = (TextView) headerView.findViewById(R.id.group_name);
        mSubCategoryNameText = (TextView) headerView.findViewById(R.id.subcategory_name);
        mConnectCountText = (TextView) headerView.findViewById(R.id.connect_count);
        mAskFriendsLayout = (LinearLayout) headerView.findViewById(R.id.ask_friends_layout);
        mCommentList = (CustomListView) contentView.findViewById(R.id.wall_post_list);
        mGradientView = headerView.findViewById(R.id.gradient_view);
        mSendCommentLayout = contentView.findViewById(R.id.comment_edit_layout);
        mSendCommentLayout.setVisibility(View.GONE);
        mSendCommentButton = (Button) contentView.findViewById(R.id.button_send);
        mCommentText = (EditText) contentView.findViewById(R.id.comment_edit);
        mCommentButton = (TextView) contentView.findViewById(R.id.comment_button);
    }

#end
#end
#No. 182884
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * it sets all the listeners we are using in this fragment
     */

#Code:
    private void setListeners() {
        mAskFriendsLayout.setOnClickListener(this);
        mChatButton.setOnClickListener(this);
        mRecommendFriendButton.setOnClickListener(this);
        mSendCommentButton.setOnClickListener(this);
        mCommentButton.setOnClickListener(this);
        mCommentText.setOnClickListener(this);
        mSendCommentButton.setEnabled(false);
        mCommentText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
            }

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {

                if (s != null && !s.equals("") && !TextUtils.isEmpty(s)) {
                    mSendCommentButton.setEnabled(true);
                } else {
                    mSendCommentButton.setEnabled(false);
                }
            }

            @Override
            public void afterTextChanged(Editable s) {
            }
        });

    }

#end
#end
#No. 182885
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * start the loaders for the fragment view
     */

#Code:
    private void startLoaders() {
        loadWall();
        loadWallComments();
    }

#end
#end
#No. 182886
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * loader which starts loading the wall comments for the wall
     */

#Code:
    private void loadWallComments() {
        getLoaderManager().restartLoader(AppConstants.Loaders.LOAD_WALL_COMMENTS, null, this);

    }

#end
#end
#No. 182887
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * this loader loads the wall details
     */

#Code:
    private void loadWall() {
        getLoaderManager().restartLoader(AppConstants.Loaders.LOAD_WALL, null, this);
    }

#end
#end
#No. 182888
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * reference for the fragment to be called in any other fragment or pagers
     *
     * @return
     */

#Code:
    public static WallPostFragment newInstance() {
        WallPostFragment f = new WallPostFragment();
        return f;
    }

#end
#end
#No. 182889
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Report abuse
     *
     * @param selectedWallId The id of the post to report
     */

#Code:
    private void reportAbuse(final String selectedWallId) {

        ReportAbuseRequestModel reportAbuseRequestModel = new ReportAbuseRequestModel();
        reportAbuseRequestModel.setType(AppConstants.TYPE);
        reportAbuseRequestModel.setId(selectedWallId);

        RetroCallback retroCallback;
        retroCallback = new RetroCallback(this);
        retroCallback.setRequestId(HttpConstants.ApiResponseCodes.REPORT_ABUSE);
        retroCallbackList.add(retroCallback);

        mYeloApi.reportAbuse(reportAbuseRequestModel, retroCallback);
    }

#end
#end
#No. 182890
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Open a post for editing
     *
     * @param selectedWallId The id of the post to edit
     */

#Code:
    private void editPost(final String selectedWallId) {

        final Intent editWallPostIntent = new Intent(getActivity(), EditWallPostActivity.class);
        editWallPostIntent.putExtra(AppConstants.Keys.EDIT_POST, true);
        editWallPostIntent.putExtra(AppConstants.Keys.WALL_ID, selectedWallId);

        startActivity(editWallPostIntent);
    }

#end
#end
#No. 182891
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Delete a post, along with a confirmation
     *
     * @param selectedWallId The id of the post to delete
     */

#Code:
    private void deletePost(final String selectedWallId) {

        final AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(getActivity());

        // set title
        alertDialogBuilder.setTitle("Confirm");

        // set dialog message
        alertDialogBuilder.setMessage(getResources().getString(R.string.delete_wall_alert_message)).setCancelable(false).setPositiveButton("Yes", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(final DialogInterface dialog, final int id) {

                callDeleteApi(selectedWallId);
                dialog.dismiss();
            }
        }).setNegativeButton("No", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(final DialogInterface dialog, final int id) {
                // if this button is clicked, just close
                // the dialog box and do nothing
                dialog.cancel();
            }
        });

        // create alert dialog
        final AlertDialog alertDialog = alertDialogBuilder.create();

        // show it
        alertDialog.show();
    }

#end
#end
#No. 182892
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Api to call for delete particular wall
     *
     * @param wallId id of the wall to be deleted
     */

#Code:
    private void callDeleteApi(String wallId) {
        RetroCallback retroCallback;
        retroCallback = new RetroCallback(this);
        retroCallback.setRequestId(HttpConstants.ApiResponseCodes.DELETE_WALL);
        retroCallbackList.add(retroCallback);

        mYeloApi.deleteWall(wallId, retroCallback);
        String selection = DatabaseColumns.ID + SQLConstants.EQUALS_ARG;

        getActivity().setProgressBarIndeterminate(true);
        DBInterface.deleteAsync(AppConstants.QueryTokens.DELETE_WALL_POST, getTaskTag(), null, TableWallPosts.NAME, selection, new String[]{wallId}, true, this);

        DBInterface.deleteAsync(AppConstants.QueryTokens.DELETE_MY_WALL_POST, getTaskTag(), null, TableMyWallPosts.NAME, selection, new String[]{wallId}, true, this);

    }

#end
#end
#No. 182893
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Api call to close the wall
     *
     * @param wallId id of the wall to be closed
     */

#Code:
    private void closeWall(String wallId) {
        RetroCallback retroCallback;
        retroCallback = new RetroCallback(this);
        retroCallback.setRequestId(HttpConstants.ApiResponseCodes.CLOSE_WALL);
        Bundle args = new Bundle();
        args.putString(AppConstants.Keys.WALL_ID, wallId);
        retroCallback.setExtras(args);
        retroCallbackList.add(retroCallback);

        CloseWallRequestModel closeWallRequestModel = new CloseWallRequestModel();
        closeWallRequestModel.setIs_solved("1");
        getActivity().finish();
        mYeloApi.closeWall(wallId, closeWallRequestModel, retroCallback);


    }

#end
#end
#No. 182894
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Loads the user profile
     *
     * @param userId id of the user whose profile we want to see
     * @param name   name of the user
     */

#Code:
    private void loadProfile(String userId, String name) {
        final Intent userProfileIntent = new Intent(getActivity(), UserProfileActivity.class);

        userProfileIntent.putExtra(AppConstants.Keys.USER_ID, userId);
        userProfileIntent.putExtra(AppConstants.Keys.USER_NAME, name);
        userProfileIntent.putExtra(AppConstants.Keys.SERVICE_SCREEN_TYPE, AppConstants.ServiceScreenType.PROFILE);
        startActivity(userProfileIntent);
    }

#end
#end
#No. 182895
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Loads the actual chat screen. This is used in the case where the user taps on an item in the
     * list of chats
     *
     * @param userId The user Id of the chat to load
     * @param wallId The ID of the wallId
     */

#Code:
    private void loadChat(String userId, String wallId, String chatName, String tags, String image, String tagName) {

        final String chatId = Utils.generateChatId(userId, AppConstants.UserInfo.INSTANCE.getId());
        final Intent chatScreenActivity = new Intent(getActivity(), ChatScreenActivity.class);
        chatScreenActivity.putExtra(AppConstants.Keys.USER_ID, userId);
        chatScreenActivity.putExtra(AppConstants.Keys.CHAT_ID, chatId);
        chatScreenActivity.putExtra(AppConstants.Keys.WALL_ID, wallId);
        chatScreenActivity.putExtra(AppConstants.Keys.CHAT_TITLE, chatName);
        chatScreenActivity.putExtra(AppConstants.Keys.PROFILE_IMAGE, image);
        chatScreenActivity.putExtra(AppConstants.Keys.FROM_WALL, true);
        chatScreenActivity.putExtra(AppConstants.Keys.TAG_NAME, tagName);


        chatScreenActivity.putExtra(AppConstants.Keys.MY_ID, AppConstants.UserInfo.INSTANCE.getId());
        startActivity(chatScreenActivity);
    }

#end
#end
#No. 182896
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Show fragment for tagging users
     */

#Code:
    public void loadTagFragment() {

        final Intent tagUserActivityIntent = new Intent(getActivity(), TagUserActivity.class);
        tagUserActivityIntent.putExtra(AppConstants.Keys.WALL_ID, mWallId);
        tagUserActivityIntent.putExtra(AppConstants.Keys.USER_ID, mUserId);
        tagUserActivityIntent.putExtra(AppConstants.Keys.TAG_USER_COUNT, Integer.parseInt(mConnection));
        tagUserActivityIntent.putExtra(AppConstants.Keys.FROM_WALL, true);
        startActivity(tagUserActivityIntent);

    }

#end
#end
#No. 182897
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Show fragment for tagging users
     */

#Code:
    public void loadAskFriend() {

        final Intent askFriendActivity = new Intent(getActivity(), AskFriendActivity.class);
        askFriendActivity.putExtra(AppConstants.Keys.WALL_ID, mWallId);
        askFriendActivity.putExtra(AppConstants.Keys.FROM_WALL, true);
        startActivity(askFriendActivity);

    }

#end
#end
#No. 182898
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Loads the {@link red.yelo.fragments.HomeScreenFragment} into the fragment container
     */

#Code:
    public void loadHomeScreen() {

        final Intent homeActivity = new Intent(getActivity(), HomeActivity.class);
        startActivity(homeActivity);


    }



#end
#end
#No. 182900
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Call the number of the user
     *
     * @param number
     * @param userId
     * @param userName
     * @param category
     */

#Code:
    private void callNumber(String number, String userId, String userName, String category) {


        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + number));
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        getActivity().startActivity(intent);
    }

#end
#end
#No. 182901
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Loads a chat directly. This is used in the case where the user directly taps on a chat button
     * on another user's profile page
     */

#Code:

    private void loadChatFromComment(String taggedUserId, String chatName, String tags, String image, String userId, String userName, String category) {
        final String chatId = Utils.generateChatId(taggedUserId, AppConstants.UserInfo.INSTANCE.getId());

        loadChat(taggedUserId, chatId, chatName, tags, image);
    }

#end
#end
#No. 182902
#File: E:\bishe\1\WallPostFragment.java
#Comment:
    /**
     * Loads the actual chat screen. This is used in the case where the user taps on an item in the
     * list of chats
     *
     * @param userId The user Id of the chat to load
     * @param chatId The ID of the chat
     */

#Code:
    private void loadChat(String userId, String chatId, String chatName, String tags, String image) {

        final Intent chatScreenActivity = new Intent(getActivity(), ChatScreenActivity.class);
        chatScreenActivity.putExtra(AppConstants.Keys.USER_ID, userId);
        chatScreenActivity.putExtra(AppConstants.Keys.CHAT_ID, chatId);
        chatScreenActivity.putExtra(AppConstants.Keys.CHAT_TITLE, chatName);
        chatScreenActivity.putExtra(AppConstants.Keys.PROFILE_IMAGE, image);
        chatScreenActivity.putExtra(AppConstants.Keys.FROM_WALL, true);

        chatScreenActivity.putExtra(AppConstants.Keys.MY_ID, AppConstants.UserInfo.INSTANCE.getId());
        getActivity().startActivity(chatScreenActivity);
    }

#end
#end
#No. 182903
#File: E:\bishe\1\WallsViewActivity.java
#Comment:
    /**
     * Loads the {@link red.yelo.fragments.WallPostFragment} into the fragment container
     */

#Code:
    public void loadWalls(Bundle args) {


        loadFragment(R.id.frame_content, (AbstractYeloFragment) Fragment
                        .instantiate(this, YeloBoardFragment.class
                                .getName(), args), AppConstants.FragmentTags.WALLS, false,
                null
        );

    }


#end
#end
#No. 182906
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Create the connection transmitting leg writer.
    */

#Code:
   protected void createWriter() {

      mWriterThread = new HandlerThread("AutobahnWriter");
      mWriterThread.start();
      mWriter = new WampWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mOptions);

      if (DEBUG) Log.d(TAG, "writer created and started");
   }

#end
#end
#No. 182907
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Create the connection receiving leg reader.
    */

#Code:
   protected void createReader() {
      mReader = new WampReader(mCalls, mSubs, mMasterHandler, mTransportChannel, mOptions, "AutobahnReader");
      mReader.start();

      if (DEBUG) Log.d(TAG, "reader created and started");
   }

#end
#end
#No. 182908
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Create new random ID. This is used, i.e. for use in RPC calls to correlate
    * call message with result message.
    *
    * @param len    Length of ID.
    * @return       New random ID of given length.
    */

#Code:
   private String newId(int len) {
      char[] buffer = new char[len];
      for (int i = 0; i < len; i++) {
         buffer[i] = mBase64Chars[mRng.nextInt(mBase64Chars.length)];
      }
      return new String(buffer);
   }

#end
#end
#No. 182909
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Create new random ID of default length.
    *
    * @return    New random ID of default length.
    */

#Code:
   private String newId() {
      return newId(8);
   }

#end
#end
#No. 182910
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Issue a remote procedure call (RPC).
    *
    * @param procUri       URI or CURIE of procedure to call.
    * @param resultMeta    Call result metadata.
    * @param arguments     Call arguments.
    */

#Code:
   private void call(String procUri, CallMeta resultMeta, Object... arguments) {

      WampMessage.Call call = new WampMessage.Call(newId(), procUri, arguments.length);
      for (int i = 0; i < arguments.length; ++i) {
         call.mArgs[i] = arguments[i];
      }
      mCalls.put(call.mCallId, resultMeta);
      mWriter.forward(call);
   }

#end
#end
#No. 182911
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Issue a remote procedure call (RPC). This version should be used with
    * primitive Java types and simple composite (class) types.
    *
    * @param procUri          URI or CURIE of procedure to call.
    * @param resultType       Type we want the call result to be converted to.
    * @param resultHandler    Call handler to process call result or error.
    * @param arguments        Call arguments.
    */

#Code:
   public void call(String procUri, Class<?> resultType, CallHandler resultHandler, Object... arguments) {

      call(procUri, new CallMeta(resultHandler, resultType), arguments);
   }

#end
#end
#No. 182912
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Issue a remote procedure call (RPC). This version should be used with
    * result types which are containers, i.e. List<> or Map<>.
    *
    * @param procUri          URI or CURIE of procedure to call.
    * @param resultType       Type we want the call result to be converted to.
    * @param resultHandler    Call handler to process call result or error.
    * @param arguments        Call arguments.
    */

#Code:
   public void call(String procUri, TypeReference<?> resultType, CallHandler resultHandler, Object... arguments) {

      call(procUri, new CallMeta(resultHandler, resultType), arguments);
   }

#end
#end
#No. 182913
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Subscribe to topic to receive events for.
    *
    * @param topicUri         URI or CURIE of topic to subscribe to.
    * @param meta             Subscription metadata.
    */

#Code:
   private void subscribe(String topicUri, SubMeta meta) {

      String uri = mOutgoingPrefixes.resolveOrPass(topicUri);

      if (!mSubs.containsKey(uri)) {

         mSubs.put(uri, meta);

         WampMessage.Subscribe msg = new WampMessage.Subscribe(mOutgoingPrefixes.shrink(topicUri));
         mWriter.forward(msg);
      }
   }

#end
#end
#No. 182914
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Subscribe to topic to receive events for. This version should be used with
    * result types which are containers, i.e. List<> or Map<>.
    *
    * @param topicUri         URI or CURIE of topic to subscribe to.
    * @param eventType        The type we want events to be converted to.
    * @param eventHandler     The event handler to process received events.
    */

#Code:
   public void subscribe(String topicUri, Class<?> eventType, EventHandler eventHandler) {

      subscribe(topicUri, new SubMeta(eventHandler, eventType));
   }

#end
#end
#No. 182915
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Subscribe to topic to receive events for.  This version should be used with
    * primitive Java types and simple composite (class) types.
    *
    * @param topicUri         URI or CURIE of topic to subscribe to.
    * @param eventType        The type we want events to be converted to.
    * @param eventHandler     The event handler to process received events.
    */

#Code:
   public void subscribe(String topicUri, TypeReference<?> eventType, EventHandler eventHandler) {

      subscribe(topicUri, new SubMeta(eventHandler, eventType));
   }

#end
#end
#No. 182916
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Unsubscribe from topic.
    *
    * @param topicUri      URI or CURIE of topic to unsubscribe from.
    */

#Code:
   public void unsubscribe(String topicUri) {

      if (mSubs.containsKey(topicUri)) {

         WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
         mWriter.forward(msg);
         
         mSubs.remove(topicUri);
      }
   }

#end
#end
#No. 182917
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Unsubscribe from any subscribed topic.
    */

#Code:
   public void unsubscribe() {

      for (String topicUri : mSubs.keySet()) {

         WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
         mWriter.forward(msg);
      }
      mSubs.clear();
   }

#end
#end
#No. 182918
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Establish a prefix to be used in CURIEs.
    *
    * @param prefix     The prefix to be used in CURIEs.
    * @param uri        The full URI this prefix shall resolve to.
    */

#Code:
   public void prefix(String prefix, String uri) {

      String currUri = mOutgoingPrefixes.get(prefix);

      if (currUri == null || !currUri.equals(uri)) {

         mOutgoingPrefixes.set(prefix, uri);

         WampMessage.Prefix msg = new WampMessage.Prefix(prefix, uri);
         mWriter.forward(msg);
      }
   }

#end
#end
#No. 182919
#File: E:\bishe\1\WampConnection.java
#Comment:
   /**
    * Publish an event to a topic.
    *
    * @param topicUri   URI or CURIE of topic to publish event on.
    * @param event      Event to be published.
    */

#Code:
   public void publish(String topicUri, Object event) {

      WampMessage.Publish msg = new WampMessage.Publish(mOutgoingPrefixes.shrink(topicUri), event);
      mWriter.forward(msg);
   }









#end
#end
#No. 182970
#File: E:\bishe\1\WantStyleAssertion.java
#Comment:
	/**
	 * a file argument asserter
	 * 
	 * @param filename
	 * @return
	 */

#Code:
	public IFileAssert file(String filename) {
		File file = new File(filename.replace("file:", ""));
		return new FileAssert(file);
	}



#end
#end
#No. 182974
#File: E:\bishe\1\WapRequestBase.java
#Comment:
    /** Default sign adapter
     * It will grab <code>sign_type</code> and <code>sign</code>
     */

#Code:
    public RequestBase sign(List<String> paramNames)
        throws UnsupportedEncodingException
    {
        String signType = this.getProperty(KEY_SIGN_TYPE);
        //String charset = this.getProperty(KEY_CHARSET);
        String key = this.getProperty(KEY_KEY);

        String sign = this.sign(paramNames, signType, key, "utf-8");

        this.setProperty(KEY_SIGN, sign);

        return(this);
    }

#end
#end
#No. 182975
#File: E:\bishe\1\WapRequestBase.java
#Comment:
    /** default url constructors
     */

#Code:
    protected String toUnsignedURL(List<String> paramNames, String charset)
        throws UnsupportedEncodingException
    {
        URLBuilder ub = new URLBuilder();

        ub.appendPath(URL_ALIPAY_GATEWAY);
        for (String key:paramNames)
            ub.appendParamEncode(key, this.getProperty(key), charset);

        return(ub.toString());
    }



#end
#end
#No. 182977
#File: E:\bishe\1\WarcFileInputFormat.java
#Comment:
  /**
   * Don't allow the files to be split!
   */

#Code:
  @Override
  protected boolean isSplitable(FileSystem fs, Path filename) {
    // ensure the input files are not splittable!
    return false;
  }

#end
#end
#No. 182978
#File: E:\bishe\1\WarcFileInputFormat.java
#Comment:
  /**
   * Just return the record reader
   */

#Code:
public RecordReader getRecordReader(InputSplit split, JobConf conf, Reporter reporter) throws IOException {
    return new WarcFileRecordReader(conf, split);
  }

#end
#end
#No. 182979
#File: E:\bishe\1\WARCRecordWriter.java
#Comment:
  /** 
   * Write the headers and contents as a WARC record to the given
   * output stream.
   *
   * WARC record format:
   * <pre>warc-file = 1*warc-record
   * warc-record = header CRLF block CRLF CRLF
   * header = version warc-fields
   * version = "WARC/0.18" CRLF
   * warc-fields = *named-field CRLF
   * block = *OCTET</pre>
   */

#Code:
  private void writeRecord( OutputStream out, 
                            HttpHeaders headers, 
                            byte[] contents) throws IOException
  {
    if ( contents == null ) 
      {
        headers.add(CONTENT_LENGTH, "0");
      }
    else
      {
        headers.add(CONTENT_LENGTH,String.valueOf(contents.length));
      }
    
    out.write(WARC_ID.getBytes(DEFAULT_ENCODING));
    out.write(CR);
    out.write(LF);

    // NOTE: HttpHeaders.write() method includes the trailing CRLF.
    //       So we don't need to write it out here.
    headers.write(out);
  
    if ( contents != null ) 
      {
        out.write( contents );
      }

    // Emit the 2 trailing CRLF sequences.
    out.write(CR);
    out.write(LF);
    out.write(CR);
    out.write(LF);
  }

#end
#end
#No. 182980
#File: E:\bishe\1\WarmerStats.java
#Comment:
    /**
     * The total number of warmer executed.
     */

#Code:
    public long total() {
        return this.total;
    }

#end
#end
#No. 182981
#File: E:\bishe\1\WarmerStats.java
#Comment:
    /**
     * The total time warmer have been executed (in milliseconds).
     */

#Code:
    public long totalTimeInMillis() {
        return this.totalTimeInMillis;
    }

#end
#end
#No. 182982
#File: E:\bishe\1\WarmerStats.java
#Comment:
    /**
     * The total time warmer have been executed.
     */

#Code:
    public TimeValue totalTime() {
        return new TimeValue(totalTimeInMillis);
    }

#end
#end
#No. 182983
#File: E:\bishe\1\WarmUpResultClassifierEvent.java
#Comment:
    /**
     * Possible warm-up results for Myo.
     */

#Code:
    public enum WarmUpResult {
        UNKNOWN((byte) 0x00), SUCCESS((byte) 0x01), FAILED_TIMEOUT((byte) 0x02);
        private final byte mValue;

        WarmUpResult(byte value) {
            mValue = value;
        }

        public byte getValue() {
            return mValue;
        }
    }



#end
#end
#No. 182985
#File: E:\bishe\1\WarmupUtils.java
#Comment:
    /**
     * checksum is across the body from start of tag 35 to the delimiter at end of tag before checksum
     * 
     * @param data
     * @param offset
     * @param maxIdx    upto not including maxIdx
     * @return
     */

#Code:
    public static int calcCheckSum( byte[] data, int offset, int maxIdx ) {
        int val = 0;
        
        for( int idx=offset ; idx < maxIdx ; ) {
            val += data[ idx++ ];
        }
        
        val = val & 0xFF;
        
        return val;
    }


#end
#end
#No. 182987
#File: E:\bishe\1\WarnChecksumPolicy.java
#Comment:
/**
 * Implements {@link org.eclipse.aether.repository.RepositoryPolicy#CHECKSUM_POLICY_WARN}.
 */

#Code:
final class WarnChecksumPolicy
    extends AbstractChecksumPolicy
{

    public WarnChecksumPolicy( LoggerFactory loggerFactory, TransferResource resource )
    {
        super( loggerFactory, resource );
    }

    public boolean onTransferChecksumFailure( ChecksumFailureException exception )
    {
        String msg =
            "Could not validate integrity of download from " + resource.getRepositoryUrl() + resource.getResourceName();
        if ( logger.isDebugEnabled() )
        {
            logger.warn( msg, exception );
        }
        else
        {
            logger.warn( msg + ": " + exception.getMessage() );
        }
        return true;
    }

}

#end
#end
#No. 182988
#File: E:\bishe\1\WarningSymbol.java
#Comment:
/**
 * Warning symbol, that can for example be used if other symbols
 * are missing.
 * 
 * Usually it is shown on screen, but not printed.
 *
 * @author Andreas Wenger
 */

#Code:
public final class WarningSymbol
	extends Symbol {

	public WarningSymbol() {
		super("warning", new Rectangle2f(0, 0, 0, 0), null, null, 0f, 0f);
	}

	/**
	 * Gets the type of this symbol.
	 */
	@Override public SymbolType getType() {
		return SymbolType.WarningSymbol;
	}



#end
#end
#No. 182993
#File: E:\bishe\1\WarriorRepository.java
#Comment:
    /**
     * Reads all warrior data files from the warriors' directory.
     *
     * @throws IOException
     */

#Code:
    private void readWarriorFiles() throws IOException {
        readWarriorsFileFromPath(WARRIOR_DIRECTORY);
        readZombiesFiles();
    }

#end
#end
#No. 182994
#File: E:\bishe\1\WarriorRepository.java
#Comment:
    /**
     * @param groupIndices Required warrior groups indices.
     * @return the warrior groups corresponding to a given list of indices, and
     * the zombies group.
     */

#Code:
    public WarriorGroup[] createGroupList(int[] groupIndices) {
        ArrayList<WarriorGroup> groupsList = new ArrayList<WarriorGroup>();

        // add requested warrior groups
        for (int i = 0; i < groupIndices.length; ++i) {
            groupsList.add(warriorGroups.get(groupIndices[i]));
        }

        // add zombies (if exist)
        if (zombieGroup != null) {
            groupsList.add(zombieGroup);
        }

        WarriorGroup[] groups = new WarriorGroup[groupsList.size()];
        groupsList.toArray(groups);
        return groups;
    }



#end
#end
#No. 182996
#File: E:\bishe\1\WAStorageClientUploadIT.java
#Comment:
    /**
     * Test of validateStorageAccount method, of class WAStorageClient.
     */

#Code:
    @Test
    public void testValidateStorageAccount() throws Exception {
        System.out.println("validateStorageAccount");
        StorageAccountInfo storageAccount = testEnv.sampleStorageAccount;
        boolean result = AzureUtils.validateStorageAccount(storageAccount);
        assertEquals(true, result);
        assertEquals(true, AzureUtils.validateStorageAccount(new StorageAccountInfo(testEnv.azureStorageAccountName, testEnv.azureStorageAccountKey1, "")));
        testEnv.container.deleteIfExists();
    }

#end
#end
#No. 182997
#File: E:\bishe\1\WAStorageClientUploadIT.java
#Comment:
    /**
     * Test of validateStorageAccount method, of class WAStorageClient.
     */

#Code:
    @Test(expected = WAStorageException.class)
    public void testInvalidateStorageAccount1() throws Exception {
        System.out.println("Testing Invalid StorageAccount");
        AzureUtils.validateStorageAccount(new StorageAccountInfo(testEnv.azureStorageAccountName, "asdhasdh@asdas!@234=", testEnv.blobURL));
        testEnv.container.deleteIfExists();
    }

#end
#end
#No. 182998
#File: E:\bishe\1\WAStorageClientUploadIT.java
#Comment:
    /**
     * Test of validateStorageAccount method, of class WAStorageClient.
     */

#Code:
    @Test(expected = WAStorageException.class)
    public void testInvalidateStorageAccount2() throws Exception {
        System.out.println("Testing Invalid StorageAccount");
        AzureUtils.validateStorageAccount(new StorageAccountInfo("rfguthio123", testEnv.azureStorageAccountKey2, testEnv.blobURL));
        testEnv.container.deleteIfExists();
    }

#end
#end
#No. 182999
#File: E:\bishe\1\WAStorageClientUploadIT.java
#Comment:
    /**
     * Test of validateStorageAccount method, of class WAStorageClient.
     */

#Code:
    @Test(expected = WAStorageException.class)
    public void testInvalidateStorageAccount3() throws Exception {
        System.out.println("Testing Invalid StorageAccount");
        AzureUtils.validateStorageAccount(new StorageAccountInfo(null, null, null));
        testEnv.container.deleteIfExists();
    }



#end
#end
#No. 183001
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * Files path. Ant glob syntax.
     */

#Code:

    public String getFilesPath() {
        return filesPath;
    }

#end
#end
#No. 183002
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * Files to exclude from archival. Ant glob syntax
     */

#Code:
    public String getExcludeFilesPath() {
        return excludeFilesPath;
    }

#end
#end
#No. 183003
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * Windows Azure storage container name.
     */

#Code:
    public String getContainerName() {
        return containerName;
    }

#end
#end
#No. 183004
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * Windows Azure storage blob properties.
     */

#Code:
    public AzureBlobProperties getBlobProperties() {
        return blobProperties;
    }

#end
#end
#No. 183005
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * Windows Azure storage container access.
     */

#Code:
    public boolean isPubAccessible() {
        return pubAccessible;
    }

#end
#end
#No. 183006
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * Windows Azure storage container cleanup option.
     */

#Code:
    public boolean isCleanUpContainerOrShare() {
        return cleanUpContainerOrShare;
    }

#end
#end
#No. 183007
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * Allowing anonymous access for links generated by jenkins.
     */

#Code:
    public boolean isAllowAnonymousAccess() {
        return allowAnonymousAccess;
    }

#end
#end
#No. 183008
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * If true, build will not be changed to UNSTABLE if archiving returns
     * nothing.
     */

#Code:
    public boolean isDoNotFailIfArchivingReturnsNothing() {
        return doNotFailIfArchivingReturnsNothing;
    }

#end
#end
#No. 183009
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * If true, uploads artifacts only if the build passed.
     */

#Code:
    public boolean isUploadArtifactsOnlyIfSuccessful() {
        return uploadArtifactsOnlyIfSuccessful;
    }

#end
#end
#No. 183010
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * If true, artifacts will also be uploaded as a zip rollup.
     */

#Code:
    public boolean isUploadZips() {
        return uploadZips;
    }

#end
#end
#No. 183011
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * If true, artifacts will not be uploaded as individual files.
     */

#Code:
    public boolean isDoNotUploadIndividualFiles() {
        return doNotUploadIndividualFiles;
    }

#end
#end
#No. 183012
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * Windows Azure Storage Account Name.
     */

#Code:
    public String getStorageAccName() {
        return storageAccName;
    }

#end
#end
#No. 183013
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * File Path prefix.
     */

#Code:
    public String getVirtualPath() {
        return virtualPath;
    }

#end
#end
#No. 183014
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
    /**
     * Returns storage account object based on the name selected in job
     * configuration.
     *
     * @return StorageAccount
     */

#Code:
    public StorageAccountInfo getStorageAccount() {
        StorageAccountInfo storageAcc = null;
        for (StorageAccountInfo sa : getDescriptor().getStorageAccounts()) {
            if (sa.getStorageAccName().equals(storageAccName)) {
                storageAcc = sa;
                storageAcc.setBlobEndPointURL(Utils.getBlobEP(
                        storageAcc.getBlobEndPointURL()));
                break;
            }
        }

        return storageAcc;
    }

#end
#end
#No. 183015
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
        /**
         * Validates storage account details.
         *
         * @param was_storageAccName
         * @param was_storageAccountKey
         * @param was_blobEndPointURL
         * @return
         * @throws IOException
         * @throws ServletException
         */

#Code:
        public FormValidation doCheckAccount(
                //CHECKSTYLE:OFF
                @QueryParameter final String was_storageAccName,
                @QueryParameter final String was_storageAccountKey,
                @QueryParameter final String was_blobEndPointURL) throws IOException,
                //CHECKSTYLE:ON
                ServletException {

            if (StringUtils.isBlank(was_storageAccName)) {
                return FormValidation.error(Messages
                        .WAStoragePublisher_storage_name_req());
            }

            if (StringUtils.isBlank(was_storageAccountKey)) {
                return FormValidation.error(Messages
                        .WAStoragePublisher_storage_key_req());
            }

            String blobEndPointURL = was_blobEndPointURL;
            try {
                // Get formatted blob end point URL.
                blobEndPointURL = Utils.getBlobEP(blobEndPointURL);
                StorageAccountInfo storageAccount = new StorageAccountInfo(
                        was_storageAccName, was_storageAccountKey, blobEndPointURL);
                AzureUtils.validateStorageAccount(storageAccount);
            } catch (Exception e) {
                return FormValidation.error("Error : " + e.getMessage());
            }
            return FormValidation.ok(Messages.WAStoragePublisher_SA_val());
        }

#end
#end
#No. 183016
#File: E:\bishe\1\WAStoragePublisher.java
#Comment:
        /**
         * Checks for valid container name.
         *
         * @param request
         * @return FormValidation result
         * @throws IOException
         * @throws ServletException
         */

#Code:
        public FormValidation doCheckContainerName(final StaplerRequest request)
                throws IOException, ServletException {
            final String containerName = request.getParameter("val");
            if (!StringUtils.isBlank(containerName)) {
                // Token resolution happens dynamically at runtime , so for
                // basic validations
                // if text contain tokens considering it as valid input.
                if (Utils.containTokens(containerName) || Utils.validateContainerName(containerName)) {
                    return FormValidation.ok();
                } else {
                    return FormValidation.error(Messages.WAStoragePublisher_container_name_invalid());
                }
            } else {
                return FormValidation.error(Messages.WAStoragePublisher_container_name_req());
            }
        }

#end
#end
#No. 183017
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /**
     * Tests the <code>export()</code> method.
     *
     ** @throws Exception if the test fails
     */

#Code:
    @Test public void testExport() throws Exception {
        final int N = 3;
        Integer[] counts = new Integer[N];
        for (int i = 0; i < N; i++) {
            counts[i] = i;
        }

#end
#end
#No. 183018
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /**
     * Tests the <code>unexport()</code> method.
     *
     * @throws Exception if the test fails
     */

#Code:
    @Test public void testUnexport() throws Exception {
        final int N = 3;
        Integer[] counts = new Integer[N];
        for (int i = 0; i < N; i++) {
            counts[i] = i;
        }

#end
#end
#No. 183019
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /**
     * Tests the <code>getProxy()</code> method.
     *
     * @throws Exception if the test fails
     */

#Code:
    @Test public void testGetProxy() throws Exception {
        final int N = 5;
        Integer[] counts = new Integer[N];
        for (int i = 0; i < N; i++) {
            counts[i] = i;
        }



#end
#end
#No. 183022
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /**
     * Tests the <code>setMaxSize(int)</code> method.
     *
     * @throws Exception if the test fails
     */

#Code:
    @Test public void testSetSize() throws Exception {
        final int DCS = WatchDataSourceImpl.DEFAULT_COLLECTION_SIZE;
        final int MCS = WatchDataSourceImpl.MAX_COLLECTION_SIZE;
        final int[] sizes = new int[] {-100, -2, -1, 0, 1, 2, DCS,
                MCS - 1, MCS, MCS + 1, MCS + 5};

#end
#end
#No. 183023
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /**
     * Tests the <code>clear()</code> method.
     *
     * @throws Exception if the test fails
     */

#Code:
    @Test public void testClear() throws Exception {
        final int DCS = WatchDataSourceImpl.DEFAULT_COLLECTION_SIZE;
        WatchDataSourceImpl impl = new WatchDataSourceImpl();
        impl.setID("watch");
        impl.setConfiguration(EmptyConfiguration.INSTANCE);

        for (int j = 0; j < DCS; j++) {
            impl.addCalculable(new Calculable());
        }

#end
#end
#No. 183024
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /**
     * Tests the <code>getCurrentSize()</code> method.
     *
     * @throws Exception if the test fails
     */

#Code:
    @Test public void testGetCurrentSize() throws Exception {
        final int DCS = WatchDataSourceImpl.DEFAULT_COLLECTION_SIZE;
        WatchDataSourceImpl impl = new WatchDataSourceImpl();
        impl.setID("watch");
        impl.setConfiguration(EmptyConfiguration.INSTANCE);

        for (int j = 0; j < DCS; j++) {
            impl.addCalculable(new Calculable());
        }

#end
#end
#No. 183025
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /**
     * Tests the <code>getLastCalculable()<code> method.
     *
     * @throws Exception if the test fails
     */

#Code:
    @Test public void testGetLastCalculable1() throws Exception {
        final int DCS = WatchDataSourceImpl.DEFAULT_COLLECTION_SIZE;
        WatchDataSourceImpl impl = new WatchDataSourceImpl();
        impl.setID("watch");
        impl.setConfiguration(EmptyConfiguration.INSTANCE);
        Calculable expected = null;
        for (int j = 0; j < DCS; j++) {
            Calculable c = new Calculable();
            impl.addCalculable(c);
            expected = c;
        }

#end
#end
#No. 183026
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /*
     * Asserts that a given object is a actually a proxy to a given
     * implementation object.
     */

#Code:
    private void assertValidProxy(WatchDataSource proxy,
                                  LoggingWatchDataSourceImpl impl)
            throws RemoteException {
        impl.log().delete(0, impl.log().length());
        proxy.clear();
        proxy.getCalculable();
        proxy.getCurrentSize();
        proxy.getID();
        proxy.getLastCalculable();
        proxy.getMaxSize();
        proxy.getThresholdValues();
        proxy.getView();
        //proxy.setMaxSize(1);
        proxy.setView("aaa");
        checkLog(impl.log, "clear()"
                           + "getCalculable()"
                           //+ "getCalculable(0,1)"
                           //+ "getCalculable(watch,0,1)"
                           + "getCurrentSize()"
                           + "getID()"
                           + "getLastCalculable()"
                           + "getMaxSize()"
                           + "getThresholdValues()"
                           + "getView()"
                           //+ "setMaxSize(1)"
                           + "setView(aaa)");
    }

#end
#end
#No. 183027
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /*
     * Asserts that a given object is not a working proxy
     * (e.g. closed proxy) to a given implementation object.
     */

#Code:
    private void assertInvalidProxy(WatchDataSource proxy,
                                    LoggingWatchDataSourceImpl impl)
            throws RemoteException {
        impl.log().delete(0, impl.log().length());
        try {
            proxy.getID();
            Assert.fail("Exception expected but not thrown");
        } catch (NoSuchObjectException e) {
        } catch (ConnectException e) {
        } catch (ConnectIOException e) {            
        }
        checkLog(impl.log(), "");
    }

#end
#end
#No. 183028
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /*
     * Checks that a given string buffer (used as a log) holds a given
     * string, and clears the string buffer.
     */

#Code:
    private void checkLog(StringBuffer log, String s) {
        Assert.assertEquals(s, log.toString());
        log.delete(0, log.length());
    }

#end
#end
#No. 183029
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /*
     * Asserts that all objects in a given collection are same.
     */

#Code:
    private void assertAllSame(Collection collection) {
        if (collection.isEmpty()) {
            return;
        }
        Iterator i = collection.iterator();
        Object obj = i.next();
        while (i.hasNext()) {
            Assert.assertSame(obj, i.next());
        }
    }

#end
#end
#No. 183030
#File: E:\bishe\1\WatchDataSourceImplTest.java
#Comment:
    /*
     * Asserts that the <code>addCalculable</code> method really works for
     * the current state of a given data source, that is, calculables get
     * into the history. The method verifies this by calling
     * <code>addCalculable</code> the specified number of times and
     * checking the history.
     *
     * @param ds    the data source to verify
     * @param count the required number of calls to <code>addCalculable</code>
     * @param works specifies whether <code>addCalculable</code> should
     *              work or not
     */

#Code:
    private void assertAddCalculableWorks(WatchDataSource ds,
                                          int count,
                                          boolean works) throws RemoteException {
        ds.clear();
        List<Calculable> expected = new ArrayList<Calculable>();
        Calculable expectedLast = null;
        for (int j = 0; j < count; j++) {
            Calculable c = new Calculable();
            ds.addCalculable(c);
            if (works) {
                expected.add(c);
                expectedLast = c;
            }
        }

        DataSourceMonitor detector = new DataSourceMonitor(ds);
        detector.waitFor(works ? count : 0);

        List calculables = Arrays.asList(ds.getCalculable());
        Utils.assertSameContents(expected, calculables);
        Assert.assertEquals(expected.size(), ds.getCurrentSize());
        Assert.assertSame(expectedLast, ds.getLastCalculable());
        ds.clear();
    }

#end
#end
#No. 183031
#File: E:\bishe\1\WatchDir.java
#Comment:
    /**
     * Register the given directory with the WatchService
     */

#Code:
    private void register(Path dir) throws IOException {
        WatchKey key = dir.register(watcher, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);
        if (trace) {
            Path prev = keys.get(key);
            if (prev == null) {
                System.out.format("register: %s\n", dir);
            } else {
                if (!dir.equals(prev)) {
                    System.out.format("update: %s -> %s\n", prev, dir);
                }
            }
        }
        keys.put(key, dir);
    }

#end
#end
#No. 183032
#File: E:\bishe\1\WatchDir.java
#Comment:
    /**
     * Register the given directory, and all its sub-directories, with the
     * WatchService.
     */

#Code:
    private void registerAll(final Path start) throws IOException {
        // register directory and sub-directories
        Files.walkFileTree(start, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)
                    throws IOException
            {
                register(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }

#end
#end
#No. 183033
#File: E:\bishe\1\WatchDir.java
#Comment:
    /**
     * Creates a WatchService and registers the given directory
     */

#Code:
    WatchDir(Path dir, boolean recursive) throws IOException {
        this.watcher = FileSystems.getDefault().newWatchService();
        this.keys = new HashMap<WatchKey,Path>();
        this.recursive = recursive;

        if (recursive) {
            System.out.format("Scanning %s ...\n", dir);
            registerAll(dir);
            System.out.println("Done.");
        } else {
            register(dir);
        }

        // enable trace after initial registration
        this.trace = true;
    }

#end
#end
#No. 183034
#File: E:\bishe\1\Watchdog.java
#Comment:
	/**
	 * Initiates a Watchdog for specific resource. File must be located within
	 * the resources location of a dev machine or within
	 * {@code {catalina.home}/properties}
	 * 
	 */

#Code:
	public Watchdog(final DynamicLoadable loader, final boolean startImmediately) {
		if (loader == null) {
			throw new IllegalArgumentException("loader must be set");
		}
		resource = loader.getResourceFilename();
		if (resource == null) {
			throw new IllegalArgumentException("resource in loader must be set");
		}
		autostart = startImmediately;
		this.loader = loader;
		try {
			watchService = FileSystems.getDefault().newWatchService();
			final String path = loader.getResourceLocation();
			logger.info("Watchdog [" + path + "]");
			logger.info("INFO: Watchdog [" + path + resource + "]");
			Paths.get(path).register(watchService, ENTRY_MODIFY);
		} catch (final IOException e) {
			logger.warning(e.getMessage());
		}
	}



#end
#end
#No. 183037
#File: E:\bishe\1\Watcher.java
#Comment:
	/**
	 * Returns number of files found during initial scan.
	 */

#Code:
	private long registerRecursive (final File rootDir, final File dir) throws IOException {
		if (!dir.exists()) throw new FileNotFoundException("Unable to watch dir '" + dir + "' as it does not exist.");
		final RegisterRecursiveHiker hiker = new RegisterRecursiveHiker(this, rootDir);
		new TreeWalker(dir, this.filter, hiker).walk();
		return hiker.getTotalFiles();
	}


#end
#end
#No. 183039
#File: E:\bishe\1\WatchObject.java
#Comment:
	/**
	 * Enable (true) or disable (false) watcher mode. Default is true.
	 *
	 * @param enable the enable to set
	 */

#Code:
	public void setEnable(final boolean enable) {
		this.enable = enable;
	}

#end
#end
#No. 183040
#File: E:\bishe\1\WatchObject.java
#Comment:
	/**
	 * Enable (true) or disable (false) dumping of JSON reports. Default is false.
	 *
	 * @return the json
	 */

#Code:
	public boolean isDump() {
		return this.dump;
	}

#end
#end
#No. 183041
#File: E:\bishe\1\WatchObject.java
#Comment:
	/**
	 * Enable (true) or disable (false) dumping of JSON reports. Default is false.
	 *
	 * @param dump the dump to set
	 */

#Code:
	public void setDump(final boolean dump) {
		this.dump = dump;
	}



#end
#end
#No. 183048
#File: E:\bishe\1\Waterfall.java
#Comment:
  /**
   * Initializing constructor.
   *
   * @param executor
   * @param tasks
   */

#Code:
  public Waterfall (Executor executor, Task ... tasks)
  {
    this.executor_ = executor;
    this.tasks_ = tasks;
  }

#end
#end
#No. 183049
#File: E:\bishe\1\Waterfall.java
#Comment:
  /**
   * Execute the waterfall.
   *
   * @param seed              Value to provide first task
   * @param callback          Callback for the task
   * @return                  Future for managing tasks
   */

#Code:
  public Future execute (Object seed, CompletionCallback callback)
  {
    if (callback == null)
      throw new IllegalArgumentException ("Callback cannot be null");

    TaskManagerImpl taskManager = new TaskManagerImpl (this.executor_, this.tasks_, seed, callback);
    this.executor_.execute (taskManager);

    return new Future (taskManager);
  }

#end
#end
#No. 183050
#File: E:\bishe\1\Waterfall.java
#Comment:
  /**
   * Execute the waterfall.
   *
   * @param callback          Callback for the task
   * @return
   */

#Code:
  public Future execute (CompletionCallback <Object> callback)
  {
    return this.execute (null, callback);
  }



#end
#end
#No. 183052
#File: E:\bishe\1\WaterfallAbsListView.java
#Comment:
    /**
     * used in order to determine fill list more or not.
     * @return 
     */

#Code:
    protected int getScrollChildTop() {
        final int count = getChildCount();
        if( count == 0 )
            return 0;
        return getChildAt(0).getTop();
    }

#end
#end
#No. 183053
#File: E:\bishe\1\WaterfallAbsListView.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    protected int getFillChildTop() {
        final int count = getChildCount();
        if( count == 0 )
            return 0;
        return getChildAt(0).getTop();
    }    

#end
#end
#No. 183054
#File: E:\bishe\1\WaterfallAbsListView.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    protected int getFillChildBottom() {
        final int count = getChildCount();
        if( count == 0 )
            return 0;
        return getChildAt(count - 1).getBottom();
    }

#end
#end
#No. 183055
#File: E:\bishe\1\WaterfallAbsListView.java
#Comment:
    /**
     * 
     * @return
     */

#Code:
    protected int getScrollChildBottom() {
        final int count = getChildCount();
        if( count == 0 )
            return 0;
        return getChildAt(count - 1).getBottom();
    }


#end
#end
#No. 183060
#File: E:\bishe\1\WaterMarkCreator.java
#Comment:
    /**
     * Set the listener for listening to the background task of decoding and sampling the image.
     *
     * @param listener - listener for decode complete.
     * @return the related WaterMarkCreator
     */

#Code:
    public WaterMarkCreator setListener(OnDecodeListener listener) {
        this.mListener = listener;
        return this;
    }

#end
#end
#No. 183061
#File: E:\bishe\1\WaterMarkCreator.java
#Comment:
    /**
     * Initiates the background process to decoding and sampling the image.
     */

#Code:
    public void execute() {
        super.execute((Void[]) null);
    }


#end
#end
#No. 183063
#File: E:\bishe\1\WaterWalkA.java
#Comment:
	/**
	 * @return The percentage of a minute that the player has stood on water
	 *         for.
	 */

#Code:

	private Material getMaterialDown(Location location) {
		return location.getBlock().getRelative(BlockFace.DOWN).getType();
	}



#end
#end
#No. 183080
#File: E:\bishe\1\WATExtractorJob.java
#Comment:
	/**
	 * @param args
	 * @throws Exception 
	 */

#Code:
	public static void main(String[] args) throws Exception {
		int res = ToolRunner.run(new Configuration(), new WATExtractorJob(), args);
		System.exit(res);

	}

#end
#end
#No. 183081
#File: E:\bishe\1\WatsAgentCommand.java
#Comment:
    /**
     * @param path
     */

#Code:
    private WatsAgentCommand(String path) {
        this.path = path;
    }

#end
#end
#No. 183082
#File: E:\bishe\1\WatsAgentCommand.java
#Comment:
    /**
     * @return the representation
     */

#Code:
    public String getPath() {
        return path;
    }

#end
#end
#No. 183083
#File: E:\bishe\1\WatsAgentStartRequest.java
#Comment:
    /**
     * @return the agentInstanceNum
     */

#Code:
    public int getAgentInstanceNum() {
        return agentInstanceNum;
    }

#end
#end
#No. 183084
#File: E:\bishe\1\WatsAgentStartRequest.java
#Comment:
    /**
     * @param agentInstanceNum
     *            the agentInstanceNum to set
     */

#Code:
    public void setAgentInstanceNum(int agentInstanceNum) {
        this.agentInstanceNum = agentInstanceNum;
    }

#end
#end
#No. 183085
#File: E:\bishe\1\WatsAgentStartRequest.java
#Comment:
    /**
     * @return the scriptUrl
     */

#Code:
    public String getScriptUrl() {
        return scriptUrl;
    }

#end
#end
#No. 183086
#File: E:\bishe\1\WatsAgentStartRequest.java
#Comment:
    /**
     * @param scriptUrl
     *            the scriptUrl to set
     */

#Code:
    public void setScriptUrl(String scriptUrl) {
        this.scriptUrl = scriptUrl;
    }

#end
#end
#No. 183087
#File: E:\bishe\1\WatsAgentStartRequest.java
#Comment:
    /**
     * @return
     */

#Code:
    public int getTotalAgents() {
        return totalAgents;
    }

#end
#end
#No. 183088
#File: E:\bishe\1\WatsAgentStartRequest.java
#Comment:
    /**
     * @param totalAgents
     *            the totalAgents to set
     */

#Code:
    public void setTotalAgents(int totalAgents) {
        this.totalAgents = totalAgents;
    }

#end
#end
#No. 183089
#File: E:\bishe\1\WatsAgentStartRequest.java
#Comment:
    /**
     * @{inheritDoc
     */

#Code:
    @Override
    public String toString() {
        return ToStringBuilder.reflectionToString(this);
    }



#end
#end
#No. 183091
#File: E:\bishe\1\WatsAgentStatusResponse.java
#Comment:
    /**
     * @return kills
     */

#Code:
    public int getKills() {
        return kills;
    }

#end
#end
#No. 183092
#File: E:\bishe\1\WatsAgentStatusResponse.java
#Comment:
    /**
     * @return aborts
     */

#Code:
    public int getAborts() {
        return aborts;
    }

#end
#end
#No. 183093
#File: E:\bishe\1\WatsAgentStatusResponse.java
#Comment:
    /**
     * @return gotos
     */

#Code:
    public int getGotos() {
        return gotos;
    }

#end
#end
#No. 183094
#File: E:\bishe\1\WatsAgentStatusResponse.java
#Comment:
    /**
     * @return Skips
     */

#Code:
    public int getSkips() {
        return skips;
    }

#end
#end
#No. 183095
#File: E:\bishe\1\WatsAgentStatusResponse.java
#Comment:
    /**
     * @return SkipGroups
     */

#Code:
    public int getSkipGroups() {
        return skipGroups;
    }

#end
#end
#No. 183096
#File: E:\bishe\1\WatsAgentStatusResponse.java
#Comment:
    /**
     * @return Restarts
     */

#Code:
    public int getRestarts() {
        return restarts;
    }



#end
#end
#No. 183099
#File: E:\bishe\1\WavAudioFormat.java
#Comment:
    /**
     * if data is represented as big endian or little endian.
     */

#Code:
    protected final boolean bigEndian = false;

    private WavAudioFormat(int sampleRate, int sampleSizeInBits, int channels, boolean signed) {
        super(sampleRate, sampleSizeInBits, channels, false, signed);
    }

#end
#end
#No. 183100
#File: E:\bishe\1\WavAudioFormat.java
#Comment:
    /**
     * generates a PcmAudioFormat for wav files for 16 bits signed mono data.
     *
     * @param sampleRate sampling rate.
     * @return new PcmAudioFormat object for given wav header values. .
     */

#Code:
    public static WavAudioFormat mono16Bit(int sampleRate) {
        return new WavAudioFormat(sampleRate, 16, 1, true);
    }

#end
#end
#No. 183101
#File: E:\bishe\1\WavAudioFormat.java
#Comment:
    /**
     * Generates audio format data for Wav audio format. returning PCM format is little endian.
     *
     * @param sampleRate       sample rate
     * @param sampleSizeInBits bit amount per sample
     * @param channels         channel count. can be 1 or 2
     * @return a RawAudioFormat suitable for wav format.
     */

#Code:
    public static WavAudioFormat wavFormat(int sampleRate, int sampleSizeInBits, int channels) {
        if (sampleSizeInBits == 8)
            return new WavAudioFormat(sampleRate, sampleSizeInBits, channels, false);
        else
            return new WavAudioFormat(sampleRate, sampleSizeInBits, channels, true);
    }



#end
#end
#No. 183103
#File: E:\bishe\1\WaveDrawable.java
#Comment:
    /**
     * Set wave move distance (in pixels) in very animation frame
     * @param step distance in pixels
     */

#Code:
    public void setWaveSpeed(int step) {
        mWaveStep = Math.min(step, mWidth / 2);
    }

#end
#end
#No. 183104
#File: E:\bishe\1\WaveDrawable.java
#Comment:
    /**
     * Set wave amplitude (in pixels)
     * @param amplitude
     */

#Code:
    public void setWaveAmplitude(int amplitude) {
        amplitude = Math.max(1, Math.min(amplitude, mHeight / 2));
        int height = amplitude * 2;
        if (mWaveHeight != height) {
            mWaveHeight = height;
            updateMask(mWidth, mWaveLength, mWaveHeight);
            invalidateSelf();
        }
    }

#end
#end
#No. 183105
#File: E:\bishe\1\WaveDrawable.java
#Comment:
    /**
     * Set wave length (in pixels)
     * @param length
     */

#Code:
    public void setWaveLength(int length) {
        length = Math.max(8, Math.min(mWidth * 2, length));
        if (length != mWaveLength) {
            mWaveLength = length;
            updateMask(mWidth, mWaveLength, mWaveHeight);
            invalidateSelf();
        }
    }

#end
#end
#No. 183106
#File: E:\bishe\1\WaveDrawable.java
#Comment:
    /**
     * Set the wave loading in indeterminate mode or not
     * @param indeterminate
     */

#Code:
    public void setIndeterminate(boolean indeterminate) {
        mIndeterminate = indeterminate;
        if (mIndeterminate) {
            if (mAnimator == null) {
                mAnimator = getDefaultAnimator();
            }
            mAnimator.addUpdateListener(this);
            mAnimator.start();
        } else {
            if (mAnimator != null) {
                mAnimator.removeUpdateListener(this);
                mAnimator.cancel();
            }
            setLevel(calculateLevel());
        }
    }

#end
#end
#No. 183107
#File: E:\bishe\1\WaveDrawable.java
#Comment:
    /**
     * Set customised animator for wave loading animation
     * @param animator
     */

#Code:
    public void setIndeterminateAnimator(ValueAnimator animator) {
        if (mAnimator == animator) {
            return;
        }

        if (mAnimator != null) {
            mAnimator.removeUpdateListener(this);
            mAnimator.cancel();
        }

        mAnimator = animator;
        if (mAnimator != null) {
            mAnimator.addUpdateListener(this);
        }
    }

#end
#end
#No. 183108
#File: E:\bishe\1\WaveformAnalysis.java
#Comment:
  /**
   * This function sums up over a series of intensity/time values.
   * @param list A list of intensity/time points.
   * @return A point of summed intensities with the time set to the start of the list.
   */

#Code:
  private static XZ sumIntensityAndTimeList(List<XZ> list) {
    // We use the first value's time as a period over which the intensities are summed over. This is a conscious
    // choice to standardize the summation analysis. The trade offs are that the final output will
    // not have an accurate time period and will always underestimate the actual time, but since
    // the time period over which it is the summed is small (< 1 second), the underestimation is within comfortable
    // bounds.
    Double time = list.get(START_INDEX).getTime();
    Double intensitySum = 0.0;
    for (XZ point : list) {
      intensitySum += point.getIntensity();
    }

    return new XZ(time, intensitySum);
  }

#end
#end
#No. 183109
#File: E:\bishe\1\WaveformAnalysis.java
#Comment:
  /**
   * The noise of a given spectrum using a biased std derivation
   * @param spectrum
   * @return The relative noise of a spectrum.
   */

#Code:
  public static Double noiseOfSpectrum(List<XZ> spectrum) {
    Double movingAverage = 0.0;
    Double averageMeanSquared = 0.0;
    Double sizeOfSpectrum = spectrum.size() * 1.0;

    for (XZ point : spectrum) {
      movingAverage += point.getIntensity() / sizeOfSpectrum;
    }

    for (XZ point : spectrum) {
      averageMeanSquared += Math.pow(point.getIntensity() - movingAverage, 2) / sizeOfSpectrum;
    }

    return Math.pow(averageMeanSquared, 0.5);
  }

#end
#end
#No. 183110
#File: E:\bishe\1\WaveformAnalysis.java
#Comment:
  /**
   * This function returns the maximum noise among a map of ion to list of spectra
   * @param spectra A map of ion to spectrum
   * @return The maximum noise of the map
   */

#Code:
  public static Double maxNoiseOfSpectra(Map<String, List<XZ>> spectra) {
    Double maxNoise = Double.MIN_VALUE;
    for (Map.Entry<String, List<XZ>> ionToSpectrum : spectra.entrySet()) {
      maxNoise = Math.max(maxNoise, noiseOfSpectrum(ionToSpectrum.getValue()));
    }
    return maxNoise;
  }

#end
#end
#No. 183111
#File: E:\bishe\1\WaveformAnalysis.java
#Comment:
  /**
   * This function compresses a given list of time series data based on a period compression value.
   * @param intensityAndTime A list of intensity/time data
   * @param compressionMagnitude This value is the magnitude by which the data is compressed in the time dimension.
   * @return A pair of a list of intensity/time data that is compressed and a mapping from time to max peak intensity in
   * that window.
   */

#Code:
  public static Pair<List<XZ>, Map<Double, Double>> compressIntensityAndTimeGraphsAndFindMaxIntensityInEveryTimeWindow(
      List<XZ> intensityAndTime, int compressionMagnitude) {
    ArrayList<XZ> compressedResult = new ArrayList<>();
    Map<Double, Double> timeToIntensity = new HashMap<>();

    if (intensityAndTime == null) {
      System.out.println("intensity time is null");
      System.exit(1);
    }

    for (int i = 0; i < intensityAndTime.size() / compressionMagnitude; i++) {
      int startIndex = i * compressionMagnitude;
      int endIndex = startIndex + compressionMagnitude;
      List<XZ> subListSum = intensityAndTime.subList(startIndex,
          endIndex > intensityAndTime.size() ? intensityAndTime.size() : endIndex);

      Double maxIntensity = 0.0;
      for (XZ xz : subListSum) {
        maxIntensity = Math.max(maxIntensity, xz.getIntensity());
      }

      // Make sure that the size of the sublist has atleast one element in it.
      if (subListSum.size() > 0) {
        compressedResult.add(sumIntensityAndTimeList(subListSum));
        timeToIntensity.put(subListSum.get(START_INDEX).getTime(), maxIntensity);
      }
    }

    return Pair.of(compressedResult, timeToIntensity);
  }

#end
#end
#No. 183112
#File: E:\bishe\1\WaveformAnalysis.java
#Comment:
  /**
   * This function checks if there are overlaps between two intensity and time charts (peak values) in the time domain.
   * The algorithm itself run O(n^2), but this is OK since the inputs are peak values, which on maximum are in the order
   * of 2 magnitudes (ie count < 100).
   * @param intensityAndTimeA A list of XZ values.
   * @param intensityAndTimeB A list of XZ values.
   * @param thresholdTime This parameter is used to isolate by how much time difference between the peaks is deemed
   *                      OK for a positive detection.
   * @return True if there is an overlap in peaks between the two charts.
   */

#Code:
  public static boolean doPeaksOverlap(List<XZ> intensityAndTimeA,
                                       List<XZ> intensityAndTimeB,
                                       Double thresholdTime) {
    for (XZ point : intensityAndTimeB) {
      Double time = point.getTime();
      for (XZ referencePoint : intensityAndTimeA) {
        Double referenceTime = referencePoint.getTime();
        if ((time > referenceTime - thresholdTime) && (time < referenceTime + thresholdTime)) {
          return true;
        }
      }
    }
    return false;
  }




#end
#end
#No. 183116
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Convert a name to a name that wavefront will accept.
     *
     * Wavefront documentation specifies a metric consists of the characters
     * [-a-zA-Z_0-9.] Any disallowed characters are replaced with underscores.
     */

#Code:
    public static final String name(String name) {
        return name
                .toLowerCase(Locale.ROOT)
                .replaceAll("[^-a-zA-Z_0-9.]", "_");
    }

#end
#end
#No. 183117
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Convert a group+metric to a wavefront name.
     *
     * Concatenates the paths of a Group and a Metric, separating each path
     * element with a dot ('.').
     *
     * Example: - group path: [ 'example', 'group', 'path' ] - and metric: [
     * 'metric', 'name' ] are concatenated into
     * "example.group.path.metric.name".
     *
     * The concatenated name is cleaned to only contain characters allowed by
     * wavefront. (See the WavefrontString.name(String) function.)
     */

#Code:
    public static final String name(SimpleGroupPath group, MetricName metric) {
        return name(Stream.concat(group.getPath().stream(), metric.getPath().stream())
                .collect(Collectors.joining(".")));
    }

#end
#end
#No. 183118
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Does the escaping of tag values.
     *
     * This function assumes you'll put double quotes ('"') around your tag
     * value.
     */

#Code:
    private static String escapeTagValue(String tag_value) {
        return tag_value.replace("\"", "\\\"");
    }

#end
#end
#No. 183119
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Transform a tag entry into a wavefront tag.
     *
     * Double quotes in the tag value will be escaped.
     */

#Code:
    private static Optional<Map.Entry<String, String>> createTagEntry(Map.Entry<String, MetricValue> tag_entry) {
        final Optional<String> opt_tag_value = tag_entry.getValue().asString();
        return opt_tag_value
                .map(tag_value -> SimpleMapEntry.create(name(tag_entry.getKey()), escapeTagValue(tag_value)));
    }

#end
#end
#No. 183120
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Truncate tag keys and values, to prevent them from exceeding the max
     * length of a tag entry.
     */

#Code:
    private static Map.Entry<String, String> maybeTruncateTagEntry(Map.Entry<String, String> tag_entry) {
        String k = tag_entry.getKey();
        String v = tag_entry.getValue();
        if (k.length() + v.length() <= MAX_TAG_KEY_VAL_CHARS - 2) // 2 chars for the quotes around the value
            return tag_entry;

        if (k.length() > TRUNCATE_TAG_NAME)
            k = k.substring(0, TRUNCATE_TAG_NAME);
        if (k.length() + v.length() > MAX_TAG_KEY_VAL_CHARS - 2)
            v = v.substring(0, MAX_TAG_KEY_VAL_CHARS - 2 - k.length());
        return SimpleMapEntry.create(k, v);
    }

#end
#end
#No. 183121
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Create a map of tags for wavefront.
     *
     * The tag values are escaped and should be surrounded by double quotes.
     * This function does not put the surrounding quotes around the tag values.
     */

#Code:
    public static Map<String, String> tags(Tags tags) {
        return tags.stream()
                .map(WavefrontStrings::createTagEntry)
                .flatMap(opt -> opt.map(Stream::of).orElseGet(Stream::empty))
                .map(WavefrontStrings::maybeTruncateTagEntry)
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

#end
#end
#No. 183122
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Create a wavefront compatible string representation of the metric value.
     *
     * If the metric value is empty or not representable in wavefront, an empty
     * optional will be returned.
     */

#Code:
    public static Optional<String> wavefrontValue(MetricValue mv) {
        // Omit NaN and Inf.
        if (mv.isInfiniteOrNaN()) return Optional.empty();
        return mv.value().map(Number::toString);
    }

#end
#end
#No. 183123
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Convert a timestamp to the string representation that wavefront will
     * accept.
     */

#Code:
    public static String timestamp(DateTime ts) {
        return Long.toString(ts.getMillis() / 1000);
    }

#end
#end
#No. 183124
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Extract the 'source' tag from the tag_map.
     *
     * Wavefront requires the 'source' tag to be the first tag on the line,
     * hence the special handling. It also *must* be present, so we can never
     * return null.
     */

#Code:
    private static String extractTagSource(Map<String, String> tag_map) {
        return Optional.ofNullable(tag_map.remove("source"))
                .orElseGet(() -> {
                    return Optional.ofNullable(tag_map.get("cluster"))
                            .map(WavefrontStrings::escapeTagValue)
                            .orElseGet(() -> tag_map.getOrDefault("moncluster", "monsoon"));
                });
    }

#end
#end
#No. 183125
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Build the wavefront line from its parts.
     */

#Code:
    private static String wavefrontLine(DateTime ts, SimpleGroupPath group, MetricName metric, String value, String source, Map<String, String> tag_map) {
        return new StringBuilder()
                .append(name(group, metric))
                .append(' ')
                .append(value)
                .append(' ')
                .append(timestamp(ts))
                .append(' ')
                .append("source=").append(source)
                .append(' ')
                .append(tag_map.entrySet().stream()
                        .map(entry -> entry.getKey() + "=\"" + entry.getValue() + '\"')
                        .collect(Collectors.joining(" "))
                )
                .toString();
    }

#end
#end
#No. 183126
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Convert a metric to a wavefront string.
     *
     * Empty metrics and histograms do not emit a value.
     *
     * Note: the line is not terminated with a newline.
     */

#Code:
    public static Optional<String> wavefrontLine(DateTime ts, GroupName group, MetricName metric, MetricValue metric_value) {
        return wavefrontValue(metric_value)
                .map(value -> {
                    final Map<String, String> tag_map = tags(group.getTags());
                    final String source = extractTagSource(tag_map);  // Modifies tag_map.
                    return wavefrontLine(ts, group.getPath(), metric, value, source, tag_map);
                });
    }

#end
#end
#No. 183127
#File: E:\bishe\1\WavefrontStrings.java
#Comment:
    /**
     * Convert a time series value into the string entries for wavefront.
     *
     * Note: the line is not terminated with a newline.
     */

#Code:
    public static Stream<String> wavefrontLine(DateTime ts, TimeSeriesValue tsv) {
        final GroupName group = tsv.getGroup();

        return tsv.getMetrics().entrySet().stream()
                .flatMap(metricEntry -> wavefrontLineForMetric(ts, group, metricEntry));
    }

#end
#end
#No. 183128
#File: E:\bishe\1\WavefrontYammerMetricsReporter.java
#Comment:
  /**
   * Reporter of a Yammer metrics registry to Wavefront
   *
   * @param metricsRegistry        The registry to scan-and-report
   * @param name                   A human readable name for this reporter
   * @param hostname               The remote host where the wavefront proxy resides
   * @param port                   Listening port on Wavefront proxy of graphite-like telemetry data
   * @param wavefrontHistogramPort Listening port for Wavefront histogram data
   * @param timeSupplier           Get current timestamp, stubbed for testing
   * @param prependGroupName       If true, outgoing telemetry is of the form "group.name" rather than "name".
   * @param metricTranslator       If present, applied to each MetricName/Metric pair before flushing to Wavefront. This
   *                               is useful for adding point tags. Warning: this is called once per metric per scan, so
   *                               it should probably be performant. May be null.
   * @param clearMetrics           If true, clear histograms and timers per flush.
   * @throws IOException When we can't remotely connect to Wavefront.
   */

#Code:
  public WavefrontYammerMetricsReporter(MetricsRegistry metricsRegistry, String name, String hostname, int port,
                                        int wavefrontHistogramPort, Supplier<Long> timeSupplier,
                                        boolean prependGroupName,
                                        @Nullable MetricTranslator metricTranslator,
                                        boolean includeJvmMetrics,
                                        boolean clearMetrics) throws IOException {
    super(metricsRegistry, name);
    this.metricTranslator = metricTranslator;
    this.socketMetricProcessor = new SocketMetricsProcessor(hostname, port, wavefrontHistogramPort, timeSupplier,
        prependGroupName, clearMetrics);
    this.includeJvmMetrics = includeJvmMetrics;
    this.clearMetrics = clearMetrics;
  }

#end
#end
#No. 183129
#File: E:\bishe\1\WavefrontYammerMetricsReporter.java
#Comment:
  /**
   * @return How many metrics were processed during the last call to {@link #run()}.
   */

#Code:
  @VisibleForTesting
  int getMetricsGeneratedLastPass() {
    return metricsGeneratedLastPass;
  }



#end
#end
#No. 183131
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Constructor; initializes WaveReader to read from given file
     *
     * @param path  path to input file
     * @param name  name of input file
     */

#Code:
    public WaveReader(String path, String name) {
        this.mInFile = new File(path + File.separator + name);
    }

#end
#end
#No. 183132
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Constructor; initializes WaveReader to read from given file
     *
     * @param file  handle to input file
     */

#Code:
    public WaveReader(File file) {
        this.mInFile = file;
    }

#end
#end
#No. 183133
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Open WAV file for reading
     *
     * @throws FileNotFoundException if input file does not exist
     * @throws InvalidWaveException if input file is not a valid WAVE file
     * @throws IOException if I/O error occurred during file read
     */

#Code:
    public void openWave() throws FileNotFoundException, InvalidWaveException, IOException {
        FileInputStream fileStream = new FileInputStream(mInFile);
        mInStream = new BufferedInputStream(fileStream, STREAM_BUFFER_SIZE);

        int headerId = readUnsignedInt(mInStream);  // should be "RIFF"
        if (headerId != WAV_HEADER_CHUNK_ID) {
            throw new InvalidWaveException(String.format("Invalid WAVE header chunk ID: %d", headerId));
        }
        mFileSize = readUnsignedIntLE(mInStream);  // length of header
        int format = readUnsignedInt(mInStream);  // should be "WAVE"
        if (format != WAV_FORMAT) {
            throw new InvalidWaveException("Invalid WAVE format");
        }
        
        int formatId = readUnsignedInt(mInStream);  // should be "fmt "
        if (formatId != WAV_FORMAT_CHUNK_ID) {
            throw new InvalidWaveException("Invalid WAVE format chunk ID");
        }
        int formatSize = readUnsignedIntLE(mInStream);
        if (formatSize != 16) {
            
        }
        int audioFormat = readUnsignedShortLE(mInStream);
        if (audioFormat != 1) {
            throw new InvalidWaveException("Not PCM WAVE format");
        }
        mChannels = readUnsignedShortLE(mInStream);
        mSampleRate = readUnsignedIntLE(mInStream);
        int byteRate = readUnsignedIntLE(mInStream);
        int blockAlign = readUnsignedShortLE(mInStream);
        mSampleBits = readUnsignedShortLE(mInStream);
        
        int dataId = readUnsignedInt(mInStream);
        if (dataId != WAV_DATA_CHUNK_ID) {
            throw new InvalidWaveException("Invalid WAVE data chunk ID");
        }
        mDataSize = readUnsignedIntLE(mInStream);
    }

#end
#end
#No. 183134
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Get sample rate
     *
     * @return input file's sample rate
     */

#Code:
    public int getSampleRate() {
        return mSampleRate;
    }

#end
#end
#No. 183135
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Get number of channels
     *
     * @return number of channels in input file
     */

#Code:
    public int getChannels() {
        return mChannels;
    }

#end
#end
#No. 183136
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Get PCM format, S16LE or S8LE
     *
     * @return number of bits per sample
     */

#Code:
    public int getPcmFormat() {
        return mSampleBits;
    }

#end
#end
#No. 183137
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Get file size
     *
     * @return total input file size in bytes
     */

#Code:
    public int getFileSize() {
        return mFileSize + 8;
    }

#end
#end
#No. 183138
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Get input file's audio data size
     * Basically file size without headers included
     *
     * @return audio data size in bytes
     */

#Code:
    public int getDataSize() {
        return mDataSize;
    }

#end
#end
#No. 183139
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Get input file length
     *
     * @return length of file in seconds
     */

#Code:
    public int getLength() {
        if (mSampleRate == 0 || mChannels == 0 || (mSampleBits + 7) / 8 == 0) {
            return 0;
        } else {
            return mDataSize / (mSampleRate * mChannels * ((mSampleBits + 7) / 8));
        }
    }

#end
#end
#No. 183140
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Read audio data from input file (mono)
     *
     * @param dst  mono audio data output buffer
     * @param numSamples  number of samples to read
     *
     * @return number of samples read
     *
     * @throws IOException if file I/O error occurs
     */

#Code:
    public int read(short[] dst, int numSamples) throws IOException {
        if (mChannels != 1) {
            return -1;
        }

        byte[] buf = new byte[numSamples * 2];
        int index = 0;
        int bytesRead = mInStream.read(buf, 0, numSamples * 2);

        for (int i = 0; i < bytesRead; i+=2) {
            dst[index] = byteToShortLE(buf[i], buf[i+1]);
            index++;
        }

        return index;
    }

#end
#end
#No. 183141
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Read audio data from input file (stereo)
     *
     * @param left  left channel audio output buffer
     * @param right  right channel audio output buffer
     * @param numSamples  number of samples to read
     *
     * @return number of samples read
     *
     * @throws IOException if file I/O error occurs
     */

#Code:
    public int read(short[] left, short[] right, int numSamples) throws IOException {
        if (mChannels != 2) {
            return -1;
        }
        byte[] buf = new byte[numSamples * 4];
        int index = 0;
        int bytesRead = mInStream.read(buf, 0, numSamples * 4);

        for (int i = 0; i < bytesRead; i+=2) {
            short val = byteToShortLE(buf[0], buf[i+1]);
            if (i % 4 == 0) {
                left[index] = val;
            } else {
                right[index] = val;
                index++;
            }
        }

        return index;
    }

#end
#end
#No. 183142
#File: E:\bishe\1\WaveReader.java
#Comment:
    /**
     * Close WAV file. WaveReader object cannot be used again following this call.
     *
     * @throws IOException if I/O error occurred closing filestream
     */

#Code:
    public void closeWaveFile() throws IOException {
        if (mInStream != null) {
            mInStream.close();
        }
    }

#end
#end
#No. 183143
#File: E:\bishe\1\WavetableEnvelope.java
#Comment:
	/**
	 * Trigger the envelope to start processing. When the envelope has finished,
	 * The value of the last sample in the wavetable will be applied to the
	 * signal being processed.
	 * 
	 * @param duration
	 *           how long the envelope should last in milliseconds
	 */

#Code:
	public void trigger(long duration)
	{
		triggered = true;
		this.duration = duration;
		samplecounter = 0;
		lastsample = 0;
	}

#end
#end
#No. 183144
#File: E:\bishe\1\WaveWriter.java
#Comment:
    /**
     * Constructor; initializes WaveWriter with file name and path
     *
     * @param path  output file path
     * @param name  output file name
     * @param sampleRate  output sample rate
     * @param channels  number of channels
     * @param sampleBits  number of bits per sample (S8LE, S16LE)
     */

#Code:
    public WaveWriter(String path, String name, int sampleRate, int channels,
            int sampleBits) {
        this.mOutFile = new File(path + File.separator + name);

        this.mSampleRate = sampleRate;
        this.mChannels = channels;
        this.mSampleBits = sampleBits;

        this.mBytesWritten = 0;
    }

#end
#end
#No. 183145
#File: E:\bishe\1\WaveWriter.java
#Comment:
    /**
     * Constructor; initializes WaveWriter with file name and path
     *
     * @param file  output file handle
     * @param sampleRate  output sample rate
     * @param channels  number of channels
     * @param sampleBits  number of bits per sample (S8LE, S16LE)
     */

#Code:
    public WaveWriter(File file, int sampleRate, int channels, int sampleBits) {
        this.mOutFile = file;

        this.mSampleRate = sampleRate;
        this.mChannels = channels;
        this.mSampleBits = sampleBits;

        this.mBytesWritten = 0;
    }

#end
#end
#No. 183146
#File: E:\bishe\1\WaveWriter.java
#Comment:
    /**
     * Create output WAV file
     *
     * @return whether file creation succeeded
     *
     * @throws IOException if file I/O error occurs allocating header
     */

#Code:
    public boolean createWaveFile() throws IOException {
        if (mOutFile.exists()) {
            mOutFile.delete();
        }

        if (mOutFile.createNewFile()) {
            FileOutputStream fileStream = new FileOutputStream(mOutFile);
            mOutStream = new BufferedOutputStream(fileStream, OUTPUT_STREAM_BUFFER);
            // write 44 bytes of space for the header
            mOutStream.write(new byte[44]);
            return true;
        }
        return false;
    }

#end
#end
#No. 183147
#File: E:\bishe\1\WaveWriter.java
#Comment:
    /**
     * Write audio data to output file (mono). Does
     * nothing if output file is not mono channel.
     *
     * @param src  mono audio data input buffer
     * @param offset offset into src buffer
     * @param length  buffer size in number of samples
     *
     * @throws IOException if file I/O error occurs
     */

#Code:
    public void write(short[] src, int offset, int length) throws IOException {
        if (mChannels != 1) {
            return;
        }
        if (offset > length) {
            throw new IndexOutOfBoundsException(String.format("offset %d is greater than length %d", offset, length));
        }
        for (int i = offset; i < length; i++) {
            writeUnsignedShortLE(mOutStream, src[i]);
            mBytesWritten += 2;
        }
    }

#end
#end
#No. 183148
#File: E:\bishe\1\WaveWriter.java
#Comment:
    /**
     * Write audio data to output file (stereo). Does
     * nothing if output file is not stereo channel.
     *
     * @param left  left channel audio data buffer
     * @param right  right channel audio data buffer
     * @param offset  offset into left/right buffers
     * @param length  buffer size in number of samples
     *
     * @throws IOException if file I/O error occurs
     */

#Code:
    public void write(short[] left, short[] right, int offset, int length) throws IOException {
        if (mChannels != 2) {
            return;
        }
        if (offset > length) {
            throw new IndexOutOfBoundsException(String.format("offset %d is greater than length %d", offset, length));
        }
        for (int i = offset; i < length; i++) {
            writeUnsignedShortLE(mOutStream, left[i]);
            writeUnsignedShortLE(mOutStream, right[i]);
            mBytesWritten += 4;
        }
    }

#end
#end
#No. 183149
#File: E:\bishe\1\WaveWriter.java
#Comment:
    /**
     * Close output WAV file and write WAV header. WaveWriter
     * cannot be used again following this call.
     *
     * @throws IOException if file I/O error occurs writing WAV header
     */

#Code:
    public void closeWaveFile() throws IOException {
        if (mOutStream != null) {
            this.mOutStream.flush();
            this.mOutStream.close();
        }
        writeWaveHeader();
    }

#end
#end
#No. 183150
#File: E:\bishe\1\WAVfileFilter.java
#Comment:
	/**
	 * Method to get the extension of the file, in lowercase
	 */

#Code:
	private String getExtension(File f) {
		String s=f.getName();
		int i=s.lastIndexOf('.');
		if (i>0&&i<s.length()-1) return s.substring(i+1).toLowerCase();
		else return "";
	}




#end
#end
#No. 183154
#File: E:\bishe\1\WawlaConfiguration.java
#Comment:
    /**
     * Base constructor for a configuration handler. The purpose of this class is to provide a
     * basic wrapper for Forge's configuration, but mostly to add support for special
     * configuration based annotations.
     *
     * @param name The name of the config file to represent. This should be all lower case and
     *        have no spaces. Basic file name rules. The .cfg extension and forge config
     *        directory is added automatically.
     */

#Code:
    public WawlaConfiguration (String name) {

        this.name = name;
        this.file = new File(Loader.instance().getConfigDir(), name.toLowerCase() + ".cfg");
        this.config = new Configuration(this.file);
    }



#end
#end
#No. 183157
#File: E:\bishe\1\WaypointItem.java
#Comment:
	/**
	 * Perhaps update our icon
	 * 
	 * @return true if the icon changed
	 */

#Code:
	boolean updateIcon() {
		Drawable newIcon = w.getIcon();

		if (curIcon != newIcon) {
			curIcon = newIcon;
			marker.setDrawable(newIcon);
			return true;
		}

		return false;
	}

#end
#end
#No. 183158
#File: E:\bishe\1\WaypointItem.java
#Comment:
	/**
	 * Show human readable for debugging
	 */

#Code:
	@Override
	public String toString() {
		return String.format("WP:%s(lat %d, long %d)", getTitle(), mGeoPoint.getLatitudeE6(),
				mGeoPoint.getLongitudeE6());
	}

#end
#end
#No. 183159
#File: E:\bishe\1\WaypointOverlay.java
#Comment:
	/**
	 * Reset the bounds so the center of the drawable is at zero
	 * 
	 * @param d
	 * @return
	 */

#Code:
	public static Drawable boundCenterBottom(Drawable d) {
		// d = d.mutate();

		int width = d.getIntrinsicWidth();
		int height = d.getIntrinsicHeight();

		Rect r = new Rect();
		r.left = -width / 2;
		r.top = -height;
		r.right = r.left + width;
		r.bottom = 0;
		d.setBounds(r);

		return d;
		// busted on OSM FIXME
		// return ItemizedOverlay.boundCenterBottom(d);
	}

#end
#end
#No. 183160
#File: E:\bishe\1\WaypointOverlay.java
#Comment:
	/**
	 * Load our waypoints from the db (move this elsewhere?)
	 */

#Code:
	private void fillFromDB(Activity context) {

		cursor = db.fetchWaypointsByDistance();

		mItemList.clear();
		for (int i = 0; i < cursor.getCount(); i++) {
			cursor.moveToPosition(i);
			ExtendedWaypoint w = cursor.getWaypoint();
			WaypointItem item = new WaypointItem(w, captionPaint);
			mItemList.add(item);
		}

		// FIXME, handle the addition of waypoints after the map is already up
		// populate();
	}


#end
#end
#No. 183168
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Gets the value of the createDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getCreateDate()
   {
      return createDate;
   }

#end
#end
#No. 183169
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Sets the value of the createDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setCreateDate(Date value)
   {
      this.createDate = value;
   }

#end
#end
#No. 183170
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Gets the value of the createUser property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getCreateUser()
   {
      return createUser;
   }

#end
#end
#No. 183171
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Sets the value of the createUser property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setCreateUser(String value)
   {
      this.createUser = value;
   }

#end
#end
#No. 183172
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Gets the value of the lastUpdateDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getLastUpdateDate()
   {
      return lastUpdateDate;
   }

#end
#end
#No. 183173
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Sets the value of the lastUpdateDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setLastUpdateDate(Date value)
   {
      this.lastUpdateDate = value;
   }

#end
#end
#No. 183174
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Gets the value of the lastUpdateUser property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getLastUpdateUser()
   {
      return lastUpdateUser;
   }

#end
#end
#No. 183175
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Sets the value of the lastUpdateUser property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setLastUpdateUser(String value)
   {
      this.lastUpdateUser = value;
   }

#end
#end
#No. 183176
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Gets the value of the name property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getName()
   {
      return name;
   }

#end
#end
#No. 183177
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Sets the value of the name property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setName(String value)
   {
      this.name = value;
   }

#end
#end
#No. 183178
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Gets the value of the objectId property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getObjectId()
   {
      return objectId;
   }

#end
#end
#No. 183179
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Sets the value of the objectId property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setObjectId(Integer value)
   {
      this.objectId = value;
   }

#end
#end
#No. 183180
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Gets the value of the sequenceNumber property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getSequenceNumber()
   {
      return sequenceNumber;
   }

#end
#end
#No. 183181
#File: E:\bishe\1\WBSCategoryType.java
#Comment:
   /**
    * Sets the value of the sequenceNumber property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setSequenceNumber(Integer value)
   {
      this.sequenceNumber = value;
   }

#end
#end
#No. 183183
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the createDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getCreateDate()
   {
      return createDate;
   }

#end
#end
#No. 183184
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the createDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setCreateDate(Date value)
   {
      this.createDate = value;
   }

#end
#end
#No. 183185
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the createUser property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getCreateUser()
   {
      return createUser;
   }

#end
#end
#No. 183186
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the createUser property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setCreateUser(String value)
   {
      this.createUser = value;
   }

#end
#end
#No. 183187
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the isBaseline property.
    *
    * @return
    *     possible object is
    *     {@link Boolean }
    *
    */

#Code:
   public Boolean isIsBaseline()
   {
      return isBaseline;
   }

#end
#end
#No. 183188
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the isBaseline property.
    *
    * @param value
    *     allowed object is
    *     {@link Boolean }
    *
    */

#Code:
   public void setIsBaseline(Boolean value)
   {
      this.isBaseline = value;
   }

#end
#end
#No. 183189
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the isCompleted property.
    *
    * @return
    *     possible object is
    *     {@link Boolean }
    *
    */

#Code:
   public Boolean isIsCompleted()
   {
      return isCompleted;
   }

#end
#end
#No. 183190
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the isCompleted property.
    *
    * @param value
    *     allowed object is
    *     {@link Boolean }
    *
    */

#Code:
   public void setIsCompleted(Boolean value)
   {
      this.isCompleted = value;
   }

#end
#end
#No. 183191
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the isTemplate property.
    *
    * @return
    *     possible object is
    *     {@link Boolean }
    *
    */

#Code:
   public Boolean isIsTemplate()
   {
      return isTemplate;
   }

#end
#end
#No. 183192
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the isTemplate property.
    *
    * @param value
    *     allowed object is
    *     {@link Boolean }
    *
    */

#Code:
   public void setIsTemplate(Boolean value)
   {
      this.isTemplate = value;
   }

#end
#end
#No. 183193
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the lastUpdateDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getLastUpdateDate()
   {
      return lastUpdateDate;
   }

#end
#end
#No. 183194
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the lastUpdateDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setLastUpdateDate(Date value)
   {
      this.lastUpdateDate = value;
   }

#end
#end
#No. 183195
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the lastUpdateUser property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getLastUpdateUser()
   {
      return lastUpdateUser;
   }

#end
#end
#No. 183196
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the lastUpdateUser property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setLastUpdateUser(String value)
   {
      this.lastUpdateUser = value;
   }

#end
#end
#No. 183197
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the name property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getName()
   {
      return name;
   }

#end
#end
#No. 183198
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the name property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setName(String value)
   {
      this.name = value;
   }

#end
#end
#No. 183199
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the objectId property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getObjectId()
   {
      return objectId;
   }

#end
#end
#No. 183200
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the objectId property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setObjectId(Integer value)
   {
      this.objectId = value;
   }

#end
#end
#No. 183201
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the projectId property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getProjectId()
   {
      return projectId;
   }

#end
#end
#No. 183202
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the projectId property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setProjectId(String value)
   {
      this.projectId = value;
   }

#end
#end
#No. 183203
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the projectObjectId property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getProjectObjectId()
   {
      return projectObjectId;
   }

#end
#end
#No. 183204
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the projectObjectId property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setProjectObjectId(Integer value)
   {
      this.projectObjectId = value;
   }

#end
#end
#No. 183205
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the sequenceNumber property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getSequenceNumber()
   {
      return sequenceNumber;
   }

#end
#end
#No. 183206
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the sequenceNumber property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setSequenceNumber(Integer value)
   {
      this.sequenceNumber = value;
   }

#end
#end
#No. 183207
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the wbsCode property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getWBSCode()
   {
      return wbsCode;
   }

#end
#end
#No. 183208
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the wbsCode property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setWBSCode(String value)
   {
      this.wbsCode = value;
   }

#end
#end
#No. 183209
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the wbsName property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getWBSName()
   {
      return wbsName;
   }

#end
#end
#No. 183210
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the wbsName property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setWBSName(String value)
   {
      this.wbsName = value;
   }

#end
#end
#No. 183211
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the wbsObjectId property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getWBSObjectId()
   {
      return wbsObjectId;
   }

#end
#end
#No. 183212
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the wbsObjectId property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setWBSObjectId(Integer value)
   {
      this.wbsObjectId = value;
   }

#end
#end
#No. 183213
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Gets the value of the weight property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getWeight()
   {
      return weight;
   }

#end
#end
#No. 183214
#File: E:\bishe\1\WBSMilestoneType.java
#Comment:
   /**
    * Sets the value of the weight property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setWeight(Double value)
   {
      this.weight = value;
   }




#end
#end
#No. 183217
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the anticipatedFinishDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getAnticipatedFinishDate()
   {
      return anticipatedFinishDate;
   }

#end
#end
#No. 183218
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the anticipatedFinishDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setAnticipatedFinishDate(Date value)
   {
      this.anticipatedFinishDate = value;
   }

#end
#end
#No. 183219
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the anticipatedStartDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getAnticipatedStartDate()
   {
      return anticipatedStartDate;
   }

#end
#end
#No. 183220
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the anticipatedStartDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setAnticipatedStartDate(Date value)
   {
      this.anticipatedStartDate = value;
   }

#end
#end
#No. 183221
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the code property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getCode()
   {
      return code;
   }

#end
#end
#No. 183222
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the code property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setCode(String value)
   {
      this.code = value;
   }

#end
#end
#No. 183223
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the containsSummaryData property.
    *
    * @return
    *     possible object is
    *     {@link Boolean }
    *
    */

#Code:
   public Boolean isContainsSummaryData()
   {
      return containsSummaryData;
   }

#end
#end
#No. 183224
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the containsSummaryData property.
    *
    * @param value
    *     allowed object is
    *     {@link Boolean }
    *
    */

#Code:
   public void setContainsSummaryData(Boolean value)
   {
      this.containsSummaryData = value;
   }

#end
#end
#No. 183225
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the createDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getCreateDate()
   {
      return createDate;
   }

#end
#end
#No. 183226
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the createDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setCreateDate(Date value)
   {
      this.createDate = value;
   }

#end
#end
#No. 183227
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the createUser property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getCreateUser()
   {
      return createUser;
   }

#end
#end
#No. 183228
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the createUser property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setCreateUser(String value)
   {
      this.createUser = value;
   }

#end
#end
#No. 183229
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the currentBudget property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getCurrentBudget()
   {
      return currentBudget;
   }

#end
#end
#No. 183230
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the currentBudget property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setCurrentBudget(Double value)
   {
      this.currentBudget = value;
   }

#end
#end
#No. 183231
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the currentVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getCurrentVariance()
   {
      return currentVariance;
   }

#end
#end
#No. 183232
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the currentVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setCurrentVariance(Double value)
   {
      this.currentVariance = value;
   }

#end
#end
#No. 183233
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the distributedCurrentBudget property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getDistributedCurrentBudget()
   {
      return distributedCurrentBudget;
   }

#end
#end
#No. 183234
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the distributedCurrentBudget property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setDistributedCurrentBudget(Double value)
   {
      this.distributedCurrentBudget = value;
   }

#end
#end
#No. 183235
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the earnedValueComputeType property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getEarnedValueComputeType()
   {
      return earnedValueComputeType;
   }

#end
#end
#No. 183236
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the earnedValueComputeType property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setEarnedValueComputeType(String value)
   {
      this.earnedValueComputeType = value;
   }

#end
#end
#No. 183237
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the earnedValueETCComputeType property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getEarnedValueETCComputeType()
   {
      return earnedValueETCComputeType;
   }

#end
#end
#No. 183238
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the earnedValueETCComputeType property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setEarnedValueETCComputeType(String value)
   {
      this.earnedValueETCComputeType = value;
   }

#end
#end
#No. 183239
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the earnedValueETCUserValue property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getEarnedValueETCUserValue()
   {
      return earnedValueETCUserValue;
   }

#end
#end
#No. 183240
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the earnedValueETCUserValue property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setEarnedValueETCUserValue(Double value)
   {
      this.earnedValueETCUserValue = value;
   }

#end
#end
#No. 183241
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the earnedValueUserPercent property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getEarnedValueUserPercent()
   {
      return earnedValueUserPercent;
   }

#end
#end
#No. 183242
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the earnedValueUserPercent property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setEarnedValueUserPercent(Double value)
   {
      this.earnedValueUserPercent = value;
   }

#end
#end
#No. 183243
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the finishDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getFinishDate()
   {
      return finishDate;
   }

#end
#end
#No. 183244
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the finishDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setFinishDate(Date value)
   {
      this.finishDate = value;
   }

#end
#end
#No. 183245
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the forecastFinishDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getForecastFinishDate()
   {
      return forecastFinishDate;
   }

#end
#end
#No. 183246
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the forecastFinishDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setForecastFinishDate(Date value)
   {
      this.forecastFinishDate = value;
   }

#end
#end
#No. 183247
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the forecastStartDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getForecastStartDate()
   {
      return forecastStartDate;
   }

#end
#end
#No. 183248
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the forecastStartDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setForecastStartDate(Date value)
   {
      this.forecastStartDate = value;
   }

#end
#end
#No. 183249
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the guid property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getGUID()
   {
      return guid;
   }

#end
#end
#No. 183250
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the guid property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setGUID(String value)
   {
      this.guid = value;
   }

#end
#end
#No. 183251
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the independentETCLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getIndependentETCLaborUnits()
   {
      return independentETCLaborUnits;
   }

#end
#end
#No. 183252
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the independentETCLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setIndependentETCLaborUnits(Double value)
   {
      this.independentETCLaborUnits = value;
   }

#end
#end
#No. 183253
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the independentETCTotalCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getIndependentETCTotalCost()
   {
      return independentETCTotalCost;
   }

#end
#end
#No. 183254
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the independentETCTotalCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setIndependentETCTotalCost(Double value)
   {
      this.independentETCTotalCost = value;
   }

#end
#end
#No. 183255
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the integratedType property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getIntegratedType()
   {
      return integratedType;
   }

#end
#end
#No. 183256
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the integratedType property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setIntegratedType(String value)
   {
      this.integratedType = value;
   }

#end
#end
#No. 183257
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the isBaseline property.
    *
    * @return
    *     possible object is
    *     {@link Boolean }
    *
    */

#Code:
   public Boolean isIsBaseline()
   {
      return isBaseline;
   }

#end
#end
#No. 183258
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the isBaseline property.
    *
    * @param value
    *     allowed object is
    *     {@link Boolean }
    *
    */

#Code:
   public void setIsBaseline(Boolean value)
   {
      this.isBaseline = value;
   }

#end
#end
#No. 183259
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the isTemplate property.
    *
    * @return
    *     possible object is
    *     {@link Boolean }
    *
    */

#Code:
   public Boolean isIsTemplate()
   {
      return isTemplate;
   }

#end
#end
#No. 183260
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the isTemplate property.
    *
    * @param value
    *     allowed object is
    *     {@link Boolean }
    *
    */

#Code:
   public void setIsTemplate(Boolean value)
   {
      this.isTemplate = value;
   }

#end
#end
#No. 183261
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the lastUpdateDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getLastUpdateDate()
   {
      return lastUpdateDate;
   }

#end
#end
#No. 183262
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the lastUpdateDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setLastUpdateDate(Date value)
   {
      this.lastUpdateDate = value;
   }

#end
#end
#No. 183263
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the lastUpdateUser property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getLastUpdateUser()
   {
      return lastUpdateUser;
   }

#end
#end
#No. 183264
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the lastUpdateUser property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setLastUpdateUser(String value)
   {
      this.lastUpdateUser = value;
   }

#end
#end
#No. 183265
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the name property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getName()
   {
      return name;
   }

#end
#end
#No. 183266
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the name property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setName(String value)
   {
      this.name = value;
   }

#end
#end
#No. 183267
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the obsName property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getOBSName()
   {
      return obsName;
   }

#end
#end
#No. 183268
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the obsName property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setOBSName(String value)
   {
      this.obsName = value;
   }

#end
#end
#No. 183269
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the obsObjectId property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getOBSObjectId()
   {
      return obsObjectId;
   }

#end
#end
#No. 183270
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the obsObjectId property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setOBSObjectId(Integer value)
   {
      this.obsObjectId = value;
   }

#end
#end
#No. 183271
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the objectId property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getObjectId()
   {
      return objectId;
   }

#end
#end
#No. 183272
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the objectId property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setObjectId(Integer value)
   {
      this.objectId = value;
   }

#end
#end
#No. 183273
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the originalBudget property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getOriginalBudget()
   {
      return originalBudget;
   }

#end
#end
#No. 183274
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the originalBudget property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setOriginalBudget(Double value)
   {
      this.originalBudget = value;
   }

#end
#end
#No. 183275
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the parentObjectId property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getParentObjectId()
   {
      return parentObjectId;
   }

#end
#end
#No. 183276
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the parentObjectId property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setParentObjectId(Integer value)
   {
      this.parentObjectId = value;
   }

#end
#end
#No. 183277
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the projectId property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getProjectId()
   {
      return projectId;
   }

#end
#end
#No. 183278
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the projectId property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setProjectId(String value)
   {
      this.projectId = value;
   }

#end
#end
#No. 183279
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the projectObjectId property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getProjectObjectId()
   {
      return projectObjectId;
   }

#end
#end
#No. 183280
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the projectObjectId property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setProjectObjectId(Integer value)
   {
      this.projectObjectId = value;
   }

#end
#end
#No. 183281
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the proposedBudget property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getProposedBudget()
   {
      return proposedBudget;
   }

#end
#end
#No. 183282
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the proposedBudget property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setProposedBudget(Double value)
   {
      this.proposedBudget = value;
   }

#end
#end
#No. 183283
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the sequenceNumber property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getSequenceNumber()
   {
      return sequenceNumber;
   }

#end
#end
#No. 183284
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the sequenceNumber property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setSequenceNumber(Integer value)
   {
      this.sequenceNumber = value;
   }

#end
#end
#No. 183285
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the startDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getStartDate()
   {
      return startDate;
   }

#end
#end
#No. 183286
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the startDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setStartDate(Date value)
   {
      this.startDate = value;
   }

#end
#end
#No. 183287
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the status property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getStatus()
   {
      return status;
   }

#end
#end
#No. 183288
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the status property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setStatus(String value)
   {
      this.status = value;
   }

#end
#end
#No. 183289
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the statusReviewerName property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public String getStatusReviewerName()
   {
      return statusReviewerName;
   }

#end
#end
#No. 183290
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the statusReviewerName property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setStatusReviewerName(String value)
   {
      this.statusReviewerName = value;
   }

#end
#end
#No. 183291
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the statusReviewerObjectId property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getStatusReviewerObjectId()
   {
      return statusReviewerObjectId;
   }

#end
#end
#No. 183292
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the statusReviewerObjectId property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setStatusReviewerObjectId(Integer value)
   {
      this.statusReviewerObjectId = value;
   }

#end
#end
#No. 183293
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAccountingVarianceByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAccountingVarianceByCost()
   {
      return summaryAccountingVarianceByCost;
   }

#end
#end
#No. 183294
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAccountingVarianceByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAccountingVarianceByCost(Double value)
   {
      this.summaryAccountingVarianceByCost = value;
   }

#end
#end
#No. 183295
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAccountingVarianceByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAccountingVarianceByLaborUnits()
   {
      return summaryAccountingVarianceByLaborUnits;
   }

#end
#end
#No. 183296
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAccountingVarianceByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAccountingVarianceByLaborUnits(Double value)
   {
      this.summaryAccountingVarianceByLaborUnits = value;
   }

#end
#end
#No. 183297
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActivityCount property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getSummaryActivityCount()
   {
      return summaryActivityCount;
   }

#end
#end
#No. 183298
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActivityCount property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setSummaryActivityCount(Integer value)
   {
      this.summaryActivityCount = value;
   }

#end
#end
#No. 183299
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualDuration property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualDuration()
   {
      return summaryActualDuration;
   }

#end
#end
#No. 183300
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualDuration property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualDuration(Double value)
   {
      this.summaryActualDuration = value;
   }

#end
#end
#No. 183301
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualExpenseCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualExpenseCost()
   {
      return summaryActualExpenseCost;
   }

#end
#end
#No. 183302
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualExpenseCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualExpenseCost(Double value)
   {
      this.summaryActualExpenseCost = value;
   }

#end
#end
#No. 183303
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualFinishDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getSummaryActualFinishDate()
   {
      return summaryActualFinishDate;
   }

#end
#end
#No. 183304
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualFinishDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setSummaryActualFinishDate(Date value)
   {
      this.summaryActualFinishDate = value;
   }

#end
#end
#No. 183305
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualLaborCost()
   {
      return summaryActualLaborCost;
   }

#end
#end
#No. 183306
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualLaborCost(Double value)
   {
      this.summaryActualLaborCost = value;
   }

#end
#end
#No. 183307
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualLaborUnits()
   {
      return summaryActualLaborUnits;
   }

#end
#end
#No. 183308
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualLaborUnits(Double value)
   {
      this.summaryActualLaborUnits = value;
   }

#end
#end
#No. 183309
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualMaterialCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualMaterialCost()
   {
      return summaryActualMaterialCost;
   }

#end
#end
#No. 183310
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualMaterialCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualMaterialCost(Double value)
   {
      this.summaryActualMaterialCost = value;
   }

#end
#end
#No. 183311
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualNonLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualNonLaborCost()
   {
      return summaryActualNonLaborCost;
   }

#end
#end
#No. 183312
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualNonLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualNonLaborCost(Double value)
   {
      this.summaryActualNonLaborCost = value;
   }

#end
#end
#No. 183313
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualNonLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualNonLaborUnits()
   {
      return summaryActualNonLaborUnits;
   }

#end
#end
#No. 183314
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualNonLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualNonLaborUnits(Double value)
   {
      this.summaryActualNonLaborUnits = value;
   }

#end
#end
#No. 183315
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualStartDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getSummaryActualStartDate()
   {
      return summaryActualStartDate;
   }

#end
#end
#No. 183316
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualStartDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setSummaryActualStartDate(Date value)
   {
      this.summaryActualStartDate = value;
   }

#end
#end
#No. 183317
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualThisPeriodCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualThisPeriodCost()
   {
      return summaryActualThisPeriodCost;
   }

#end
#end
#No. 183318
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualThisPeriodCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualThisPeriodCost(Double value)
   {
      this.summaryActualThisPeriodCost = value;
   }

#end
#end
#No. 183319
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualThisPeriodLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualThisPeriodLaborCost()
   {
      return summaryActualThisPeriodLaborCost;
   }

#end
#end
#No. 183320
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualThisPeriodLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualThisPeriodLaborCost(Double value)
   {
      this.summaryActualThisPeriodLaborCost = value;
   }

#end
#end
#No. 183321
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualThisPeriodLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualThisPeriodLaborUnits()
   {
      return summaryActualThisPeriodLaborUnits;
   }

#end
#end
#No. 183322
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualThisPeriodLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualThisPeriodLaborUnits(Double value)
   {
      this.summaryActualThisPeriodLaborUnits = value;
   }

#end
#end
#No. 183323
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualThisPeriodMaterialCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualThisPeriodMaterialCost()
   {
      return summaryActualThisPeriodMaterialCost;
   }

#end
#end
#No. 183324
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualThisPeriodMaterialCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualThisPeriodMaterialCost(Double value)
   {
      this.summaryActualThisPeriodMaterialCost = value;
   }

#end
#end
#No. 183325
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualThisPeriodNonLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualThisPeriodNonLaborCost()
   {
      return summaryActualThisPeriodNonLaborCost;
   }

#end
#end
#No. 183326
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualThisPeriodNonLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualThisPeriodNonLaborCost(Double value)
   {
      this.summaryActualThisPeriodNonLaborCost = value;
   }

#end
#end
#No. 183327
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualThisPeriodNonLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualThisPeriodNonLaborUnits()
   {
      return summaryActualThisPeriodNonLaborUnits;
   }

#end
#end
#No. 183328
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualThisPeriodNonLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualThisPeriodNonLaborUnits(Double value)
   {
      this.summaryActualThisPeriodNonLaborUnits = value;
   }

#end
#end
#No. 183329
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualTotalCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualTotalCost()
   {
      return summaryActualTotalCost;
   }

#end
#end
#No. 183330
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualTotalCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualTotalCost(Double value)
   {
      this.summaryActualTotalCost = value;
   }

#end
#end
#No. 183331
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualValueByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualValueByCost()
   {
      return summaryActualValueByCost;
   }

#end
#end
#No. 183332
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualValueByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualValueByCost(Double value)
   {
      this.summaryActualValueByCost = value;
   }

#end
#end
#No. 183333
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryActualValueByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryActualValueByLaborUnits()
   {
      return summaryActualValueByLaborUnits;
   }

#end
#end
#No. 183334
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryActualValueByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryActualValueByLaborUnits(Double value)
   {
      this.summaryActualValueByLaborUnits = value;
   }

#end
#end
#No. 183335
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAtCompletionDuration property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAtCompletionDuration()
   {
      return summaryAtCompletionDuration;
   }

#end
#end
#No. 183336
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAtCompletionDuration property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAtCompletionDuration(Double value)
   {
      this.summaryAtCompletionDuration = value;
   }

#end
#end
#No. 183337
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAtCompletionExpenseCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAtCompletionExpenseCost()
   {
      return summaryAtCompletionExpenseCost;
   }

#end
#end
#No. 183338
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAtCompletionExpenseCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAtCompletionExpenseCost(Double value)
   {
      this.summaryAtCompletionExpenseCost = value;
   }

#end
#end
#No. 183339
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAtCompletionLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAtCompletionLaborCost()
   {
      return summaryAtCompletionLaborCost;
   }

#end
#end
#No. 183340
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAtCompletionLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAtCompletionLaborCost(Double value)
   {
      this.summaryAtCompletionLaborCost = value;
   }

#end
#end
#No. 183341
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAtCompletionLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAtCompletionLaborUnits()
   {
      return summaryAtCompletionLaborUnits;
   }

#end
#end
#No. 183342
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAtCompletionLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAtCompletionLaborUnits(Double value)
   {
      this.summaryAtCompletionLaborUnits = value;
   }

#end
#end
#No. 183343
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAtCompletionMaterialCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAtCompletionMaterialCost()
   {
      return summaryAtCompletionMaterialCost;
   }

#end
#end
#No. 183344
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAtCompletionMaterialCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAtCompletionMaterialCost(Double value)
   {
      this.summaryAtCompletionMaterialCost = value;
   }

#end
#end
#No. 183345
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAtCompletionNonLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAtCompletionNonLaborCost()
   {
      return summaryAtCompletionNonLaborCost;
   }

#end
#end
#No. 183346
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAtCompletionNonLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAtCompletionNonLaborCost(Double value)
   {
      this.summaryAtCompletionNonLaborCost = value;
   }

#end
#end
#No. 183347
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAtCompletionNonLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAtCompletionNonLaborUnits()
   {
      return summaryAtCompletionNonLaborUnits;
   }

#end
#end
#No. 183348
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAtCompletionNonLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAtCompletionNonLaborUnits(Double value)
   {
      this.summaryAtCompletionNonLaborUnits = value;
   }

#end
#end
#No. 183349
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAtCompletionTotalCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAtCompletionTotalCost()
   {
      return summaryAtCompletionTotalCost;
   }

#end
#end
#No. 183350
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAtCompletionTotalCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAtCompletionTotalCost(Double value)
   {
      this.summaryAtCompletionTotalCost = value;
   }

#end
#end
#No. 183351
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryAtCompletionTotalCostVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryAtCompletionTotalCostVariance()
   {
      return summaryAtCompletionTotalCostVariance;
   }

#end
#end
#No. 183352
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryAtCompletionTotalCostVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryAtCompletionTotalCostVariance(Double value)
   {
      this.summaryAtCompletionTotalCostVariance = value;
   }

#end
#end
#No. 183353
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineCompletedActivityCount property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getSummaryBaselineCompletedActivityCount()
   {
      return summaryBaselineCompletedActivityCount;
   }

#end
#end
#No. 183354
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineCompletedActivityCount property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setSummaryBaselineCompletedActivityCount(Integer value)
   {
      this.summaryBaselineCompletedActivityCount = value;
   }

#end
#end
#No. 183355
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineDuration property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryBaselineDuration()
   {
      return summaryBaselineDuration;
   }

#end
#end
#No. 183356
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineDuration property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryBaselineDuration(Double value)
   {
      this.summaryBaselineDuration = value;
   }

#end
#end
#No. 183357
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineExpenseCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryBaselineExpenseCost()
   {
      return summaryBaselineExpenseCost;
   }

#end
#end
#No. 183358
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineExpenseCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryBaselineExpenseCost(Double value)
   {
      this.summaryBaselineExpenseCost = value;
   }

#end
#end
#No. 183359
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineFinishDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getSummaryBaselineFinishDate()
   {
      return summaryBaselineFinishDate;
   }

#end
#end
#No. 183360
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineFinishDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setSummaryBaselineFinishDate(Date value)
   {
      this.summaryBaselineFinishDate = value;
   }

#end
#end
#No. 183361
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineInProgressActivityCount property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getSummaryBaselineInProgressActivityCount()
   {
      return summaryBaselineInProgressActivityCount;
   }

#end
#end
#No. 183362
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineInProgressActivityCount property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setSummaryBaselineInProgressActivityCount(Integer value)
   {
      this.summaryBaselineInProgressActivityCount = value;
   }

#end
#end
#No. 183363
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryBaselineLaborCost()
   {
      return summaryBaselineLaborCost;
   }

#end
#end
#No. 183364
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryBaselineLaborCost(Double value)
   {
      this.summaryBaselineLaborCost = value;
   }

#end
#end
#No. 183365
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryBaselineLaborUnits()
   {
      return summaryBaselineLaborUnits;
   }

#end
#end
#No. 183366
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryBaselineLaborUnits(Double value)
   {
      this.summaryBaselineLaborUnits = value;
   }

#end
#end
#No. 183367
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineMaterialCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryBaselineMaterialCost()
   {
      return summaryBaselineMaterialCost;
   }

#end
#end
#No. 183368
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineMaterialCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryBaselineMaterialCost(Double value)
   {
      this.summaryBaselineMaterialCost = value;
   }

#end
#end
#No. 183369
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineNonLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryBaselineNonLaborCost()
   {
      return summaryBaselineNonLaborCost;
   }

#end
#end
#No. 183370
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineNonLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryBaselineNonLaborCost(Double value)
   {
      this.summaryBaselineNonLaborCost = value;
   }

#end
#end
#No. 183371
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineNonLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryBaselineNonLaborUnits()
   {
      return summaryBaselineNonLaborUnits;
   }

#end
#end
#No. 183372
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineNonLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryBaselineNonLaborUnits(Double value)
   {
      this.summaryBaselineNonLaborUnits = value;
   }

#end
#end
#No. 183373
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineNotStartedActivityCount property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getSummaryBaselineNotStartedActivityCount()
   {
      return summaryBaselineNotStartedActivityCount;
   }

#end
#end
#No. 183374
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineNotStartedActivityCount property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setSummaryBaselineNotStartedActivityCount(Integer value)
   {
      this.summaryBaselineNotStartedActivityCount = value;
   }

#end
#end
#No. 183375
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineStartDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getSummaryBaselineStartDate()
   {
      return summaryBaselineStartDate;
   }

#end
#end
#No. 183376
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineStartDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setSummaryBaselineStartDate(Date value)
   {
      this.summaryBaselineStartDate = value;
   }

#end
#end
#No. 183377
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBaselineTotalCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryBaselineTotalCost()
   {
      return summaryBaselineTotalCost;
   }

#end
#end
#No. 183378
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBaselineTotalCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryBaselineTotalCost(Double value)
   {
      this.summaryBaselineTotalCost = value;
   }

#end
#end
#No. 183379
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBudgetAtCompletionByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryBudgetAtCompletionByCost()
   {
      return summaryBudgetAtCompletionByCost;
   }

#end
#end
#No. 183380
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBudgetAtCompletionByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryBudgetAtCompletionByCost(Double value)
   {
      this.summaryBudgetAtCompletionByCost = value;
   }

#end
#end
#No. 183381
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryBudgetAtCompletionByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryBudgetAtCompletionByLaborUnits()
   {
      return summaryBudgetAtCompletionByLaborUnits;
   }

#end
#end
#No. 183382
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryBudgetAtCompletionByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryBudgetAtCompletionByLaborUnits(Double value)
   {
      this.summaryBudgetAtCompletionByLaborUnits = value;
   }

#end
#end
#No. 183383
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryCompletedActivityCount property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getSummaryCompletedActivityCount()
   {
      return summaryCompletedActivityCount;
   }

#end
#end
#No. 183384
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryCompletedActivityCount property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setSummaryCompletedActivityCount(Integer value)
   {
      this.summaryCompletedActivityCount = value;
   }

#end
#end
#No. 183385
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryCostPercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryCostPercentComplete()
   {
      return summaryCostPercentComplete;
   }

#end
#end
#No. 183386
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryCostPercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryCostPercentComplete(Double value)
   {
      this.summaryCostPercentComplete = value;
   }

#end
#end
#No. 183387
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryCostPercentOfPlanned property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryCostPercentOfPlanned()
   {
      return summaryCostPercentOfPlanned;
   }

#end
#end
#No. 183388
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryCostPercentOfPlanned property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryCostPercentOfPlanned(Double value)
   {
      this.summaryCostPercentOfPlanned = value;
   }

#end
#end
#No. 183389
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryCostPerformanceIndexByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryCostPerformanceIndexByCost()
   {
      return summaryCostPerformanceIndexByCost;
   }

#end
#end
#No. 183390
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryCostPerformanceIndexByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryCostPerformanceIndexByCost(Double value)
   {
      this.summaryCostPerformanceIndexByCost = value;
   }

#end
#end
#No. 183391
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryCostPerformanceIndexByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryCostPerformanceIndexByLaborUnits()
   {
      return summaryCostPerformanceIndexByLaborUnits;
   }

#end
#end
#No. 183392
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryCostPerformanceIndexByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryCostPerformanceIndexByLaborUnits(Double value)
   {
      this.summaryCostPerformanceIndexByLaborUnits = value;
   }

#end
#end
#No. 183393
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryCostVarianceByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryCostVarianceByCost()
   {
      return summaryCostVarianceByCost;
   }

#end
#end
#No. 183394
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryCostVarianceByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryCostVarianceByCost(Double value)
   {
      this.summaryCostVarianceByCost = value;
   }

#end
#end
#No. 183395
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryCostVarianceByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryCostVarianceByLaborUnits()
   {
      return summaryCostVarianceByLaborUnits;
   }

#end
#end
#No. 183396
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryCostVarianceByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryCostVarianceByLaborUnits(Double value)
   {
      this.summaryCostVarianceByLaborUnits = value;
   }

#end
#end
#No. 183397
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryCostVarianceIndex property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryCostVarianceIndex()
   {
      return summaryCostVarianceIndex;
   }

#end
#end
#No. 183398
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryCostVarianceIndex property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryCostVarianceIndex(Double value)
   {
      this.summaryCostVarianceIndex = value;
   }

#end
#end
#No. 183399
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryCostVarianceIndexByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryCostVarianceIndexByCost()
   {
      return summaryCostVarianceIndexByCost;
   }

#end
#end
#No. 183400
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryCostVarianceIndexByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryCostVarianceIndexByCost(Double value)
   {
      this.summaryCostVarianceIndexByCost = value;
   }

#end
#end
#No. 183401
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryCostVarianceIndexByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryCostVarianceIndexByLaborUnits()
   {
      return summaryCostVarianceIndexByLaborUnits;
   }

#end
#end
#No. 183402
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryCostVarianceIndexByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryCostVarianceIndexByLaborUnits(Double value)
   {
      this.summaryCostVarianceIndexByLaborUnits = value;
   }

#end
#end
#No. 183403
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryDurationPercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryDurationPercentComplete()
   {
      return summaryDurationPercentComplete;
   }

#end
#end
#No. 183404
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryDurationPercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryDurationPercentComplete(Double value)
   {
      this.summaryDurationPercentComplete = value;
   }

#end
#end
#No. 183405
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryDurationPercentOfPlanned property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryDurationPercentOfPlanned()
   {
      return summaryDurationPercentOfPlanned;
   }

#end
#end
#No. 183406
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryDurationPercentOfPlanned property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryDurationPercentOfPlanned(Double value)
   {
      this.summaryDurationPercentOfPlanned = value;
   }

#end
#end
#No. 183407
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryDurationVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryDurationVariance()
   {
      return summaryDurationVariance;
   }

#end
#end
#No. 183408
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryDurationVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryDurationVariance(Double value)
   {
      this.summaryDurationVariance = value;
   }

#end
#end
#No. 183409
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryEarnedValueByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryEarnedValueByCost()
   {
      return summaryEarnedValueByCost;
   }

#end
#end
#No. 183410
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryEarnedValueByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryEarnedValueByCost(Double value)
   {
      this.summaryEarnedValueByCost = value;
   }

#end
#end
#No. 183411
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryEarnedValueByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryEarnedValueByLaborUnits()
   {
      return summaryEarnedValueByLaborUnits;
   }

#end
#end
#No. 183412
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryEarnedValueByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryEarnedValueByLaborUnits(Double value)
   {
      this.summaryEarnedValueByLaborUnits = value;
   }

#end
#end
#No. 183413
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryEstimateAtCompletionByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryEstimateAtCompletionByCost()
   {
      return summaryEstimateAtCompletionByCost;
   }

#end
#end
#No. 183414
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryEstimateAtCompletionByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryEstimateAtCompletionByCost(Double value)
   {
      this.summaryEstimateAtCompletionByCost = value;
   }

#end
#end
#No. 183415
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryEstimateAtCompletionByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryEstimateAtCompletionByLaborUnits()
   {
      return summaryEstimateAtCompletionByLaborUnits;
   }

#end
#end
#No. 183416
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryEstimateAtCompletionByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryEstimateAtCompletionByLaborUnits(Double value)
   {
      this.summaryEstimateAtCompletionByLaborUnits = value;
   }

#end
#end
#No. 183417
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryEstimateAtCompletionHighPercentByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryEstimateAtCompletionHighPercentByLaborUnits()
   {
      return summaryEstimateAtCompletionHighPercentByLaborUnits;
   }

#end
#end
#No. 183418
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryEstimateAtCompletionHighPercentByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryEstimateAtCompletionHighPercentByLaborUnits(Double value)
   {
      this.summaryEstimateAtCompletionHighPercentByLaborUnits = value;
   }

#end
#end
#No. 183419
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryEstimateAtCompletionLowPercentByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryEstimateAtCompletionLowPercentByLaborUnits()
   {
      return summaryEstimateAtCompletionLowPercentByLaborUnits;
   }

#end
#end
#No. 183420
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryEstimateAtCompletionLowPercentByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryEstimateAtCompletionLowPercentByLaborUnits(Double value)
   {
      this.summaryEstimateAtCompletionLowPercentByLaborUnits = value;
   }

#end
#end
#No. 183421
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryEstimateToCompleteByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryEstimateToCompleteByCost()
   {
      return summaryEstimateToCompleteByCost;
   }

#end
#end
#No. 183422
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryEstimateToCompleteByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryEstimateToCompleteByCost(Double value)
   {
      this.summaryEstimateToCompleteByCost = value;
   }

#end
#end
#No. 183423
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryEstimateToCompleteByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryEstimateToCompleteByLaborUnits()
   {
      return summaryEstimateToCompleteByLaborUnits;
   }

#end
#end
#No. 183424
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryEstimateToCompleteByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryEstimateToCompleteByLaborUnits(Double value)
   {
      this.summaryEstimateToCompleteByLaborUnits = value;
   }

#end
#end
#No. 183425
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryExpenseCostPercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryExpenseCostPercentComplete()
   {
      return summaryExpenseCostPercentComplete;
   }

#end
#end
#No. 183426
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryExpenseCostPercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryExpenseCostPercentComplete(Double value)
   {
      this.summaryExpenseCostPercentComplete = value;
   }

#end
#end
#No. 183427
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryExpenseCostVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryExpenseCostVariance()
   {
      return summaryExpenseCostVariance;
   }

#end
#end
#No. 183428
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryExpenseCostVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryExpenseCostVariance(Double value)
   {
      this.summaryExpenseCostVariance = value;
   }

#end
#end
#No. 183429
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryFinishDateVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryFinishDateVariance()
   {
      return summaryFinishDateVariance;
   }

#end
#end
#No. 183430
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryFinishDateVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryFinishDateVariance(Double value)
   {
      this.summaryFinishDateVariance = value;
   }

#end
#end
#No. 183431
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryInProgressActivityCount property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getSummaryInProgressActivityCount()
   {
      return summaryInProgressActivityCount;
   }

#end
#end
#No. 183432
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryInProgressActivityCount property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setSummaryInProgressActivityCount(Integer value)
   {
      this.summaryInProgressActivityCount = value;
   }

#end
#end
#No. 183433
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryLaborCostPercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryLaborCostPercentComplete()
   {
      return summaryLaborCostPercentComplete;
   }

#end
#end
#No. 183434
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryLaborCostPercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryLaborCostPercentComplete(Double value)
   {
      this.summaryLaborCostPercentComplete = value;
   }

#end
#end
#No. 183435
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryLaborCostVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryLaborCostVariance()
   {
      return summaryLaborCostVariance;
   }

#end
#end
#No. 183436
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryLaborCostVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryLaborCostVariance(Double value)
   {
      this.summaryLaborCostVariance = value;
   }

#end
#end
#No. 183437
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryLaborUnitsPercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryLaborUnitsPercentComplete()
   {
      return summaryLaborUnitsPercentComplete;
   }

#end
#end
#No. 183438
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryLaborUnitsPercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryLaborUnitsPercentComplete(Double value)
   {
      this.summaryLaborUnitsPercentComplete = value;
   }

#end
#end
#No. 183439
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryLaborUnitsVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryLaborUnitsVariance()
   {
      return summaryLaborUnitsVariance;
   }

#end
#end
#No. 183440
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryLaborUnitsVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryLaborUnitsVariance(Double value)
   {
      this.summaryLaborUnitsVariance = value;
   }

#end
#end
#No. 183441
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryMaterialCostPercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryMaterialCostPercentComplete()
   {
      return summaryMaterialCostPercentComplete;
   }

#end
#end
#No. 183442
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryMaterialCostPercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryMaterialCostPercentComplete(Double value)
   {
      this.summaryMaterialCostPercentComplete = value;
   }

#end
#end
#No. 183443
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryMaterialCostVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryMaterialCostVariance()
   {
      return summaryMaterialCostVariance;
   }

#end
#end
#No. 183444
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryMaterialCostVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryMaterialCostVariance(Double value)
   {
      this.summaryMaterialCostVariance = value;
   }

#end
#end
#No. 183445
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryNonLaborCostPercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryNonLaborCostPercentComplete()
   {
      return summaryNonLaborCostPercentComplete;
   }

#end
#end
#No. 183446
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryNonLaborCostPercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryNonLaborCostPercentComplete(Double value)
   {
      this.summaryNonLaborCostPercentComplete = value;
   }

#end
#end
#No. 183447
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryNonLaborCostVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryNonLaborCostVariance()
   {
      return summaryNonLaborCostVariance;
   }

#end
#end
#No. 183448
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryNonLaborCostVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryNonLaborCostVariance(Double value)
   {
      this.summaryNonLaborCostVariance = value;
   }

#end
#end
#No. 183449
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryNonLaborUnitsPercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryNonLaborUnitsPercentComplete()
   {
      return summaryNonLaborUnitsPercentComplete;
   }

#end
#end
#No. 183450
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryNonLaborUnitsPercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryNonLaborUnitsPercentComplete(Double value)
   {
      this.summaryNonLaborUnitsPercentComplete = value;
   }

#end
#end
#No. 183451
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryNonLaborUnitsVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryNonLaborUnitsVariance()
   {
      return summaryNonLaborUnitsVariance;
   }

#end
#end
#No. 183452
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryNonLaborUnitsVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryNonLaborUnitsVariance(Double value)
   {
      this.summaryNonLaborUnitsVariance = value;
   }

#end
#end
#No. 183453
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryNotStartedActivityCount property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getSummaryNotStartedActivityCount()
   {
      return summaryNotStartedActivityCount;
   }

#end
#end
#No. 183454
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryNotStartedActivityCount property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setSummaryNotStartedActivityCount(Integer value)
   {
      this.summaryNotStartedActivityCount = value;
   }

#end
#end
#No. 183455
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPerformancePercentCompleteByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPerformancePercentCompleteByCost()
   {
      return summaryPerformancePercentCompleteByCost;
   }

#end
#end
#No. 183456
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPerformancePercentCompleteByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPerformancePercentCompleteByCost(Double value)
   {
      this.summaryPerformancePercentCompleteByCost = value;
   }

#end
#end
#No. 183457
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPerformancePercentCompleteByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPerformancePercentCompleteByLaborUnits()
   {
      return summaryPerformancePercentCompleteByLaborUnits;
   }

#end
#end
#No. 183458
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPerformancePercentCompleteByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPerformancePercentCompleteByLaborUnits(Double value)
   {
      this.summaryPerformancePercentCompleteByLaborUnits = value;
   }

#end
#end
#No. 183459
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPlannedCost()
   {
      return summaryPlannedCost;
   }

#end
#end
#No. 183460
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPlannedCost(Double value)
   {
      this.summaryPlannedCost = value;
   }

#end
#end
#No. 183461
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedDuration property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPlannedDuration()
   {
      return summaryPlannedDuration;
   }

#end
#end
#No. 183462
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedDuration property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPlannedDuration(Double value)
   {
      this.summaryPlannedDuration = value;
   }

#end
#end
#No. 183463
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedExpenseCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPlannedExpenseCost()
   {
      return summaryPlannedExpenseCost;
   }

#end
#end
#No. 183464
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedExpenseCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPlannedExpenseCost(Double value)
   {
      this.summaryPlannedExpenseCost = value;
   }

#end
#end
#No. 183465
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedFinishDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getSummaryPlannedFinishDate()
   {
      return summaryPlannedFinishDate;
   }

#end
#end
#No. 183466
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedFinishDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setSummaryPlannedFinishDate(Date value)
   {
      this.summaryPlannedFinishDate = value;
   }

#end
#end
#No. 183467
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPlannedLaborCost()
   {
      return summaryPlannedLaborCost;
   }

#end
#end
#No. 183468
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPlannedLaborCost(Double value)
   {
      this.summaryPlannedLaborCost = value;
   }

#end
#end
#No. 183469
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPlannedLaborUnits()
   {
      return summaryPlannedLaborUnits;
   }

#end
#end
#No. 183470
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPlannedLaborUnits(Double value)
   {
      this.summaryPlannedLaborUnits = value;
   }

#end
#end
#No. 183471
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedMaterialCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPlannedMaterialCost()
   {
      return summaryPlannedMaterialCost;
   }

#end
#end
#No. 183472
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedMaterialCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPlannedMaterialCost(Double value)
   {
      this.summaryPlannedMaterialCost = value;
   }

#end
#end
#No. 183473
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedNonLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPlannedNonLaborCost()
   {
      return summaryPlannedNonLaborCost;
   }

#end
#end
#No. 183474
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedNonLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPlannedNonLaborCost(Double value)
   {
      this.summaryPlannedNonLaborCost = value;
   }

#end
#end
#No. 183475
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedNonLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPlannedNonLaborUnits()
   {
      return summaryPlannedNonLaborUnits;
   }

#end
#end
#No. 183476
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedNonLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPlannedNonLaborUnits(Double value)
   {
      this.summaryPlannedNonLaborUnits = value;
   }

#end
#end
#No. 183477
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedStartDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getSummaryPlannedStartDate()
   {
      return summaryPlannedStartDate;
   }

#end
#end
#No. 183478
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedStartDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setSummaryPlannedStartDate(Date value)
   {
      this.summaryPlannedStartDate = value;
   }

#end
#end
#No. 183479
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedValueByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPlannedValueByCost()
   {
      return summaryPlannedValueByCost;
   }

#end
#end
#No. 183480
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedValueByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPlannedValueByCost(Double value)
   {
      this.summaryPlannedValueByCost = value;
   }

#end
#end
#No. 183481
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryPlannedValueByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryPlannedValueByLaborUnits()
   {
      return summaryPlannedValueByLaborUnits;
   }

#end
#end
#No. 183482
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryPlannedValueByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryPlannedValueByLaborUnits(Double value)
   {
      this.summaryPlannedValueByLaborUnits = value;
   }

#end
#end
#No. 183483
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryProgressFinishDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getSummaryProgressFinishDate()
   {
      return summaryProgressFinishDate;
   }

#end
#end
#No. 183484
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryProgressFinishDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setSummaryProgressFinishDate(Date value)
   {
      this.summaryProgressFinishDate = value;
   }

#end
#end
#No. 183485
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryRemainingDuration property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryRemainingDuration()
   {
      return summaryRemainingDuration;
   }

#end
#end
#No. 183486
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryRemainingDuration property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryRemainingDuration(Double value)
   {
      this.summaryRemainingDuration = value;
   }

#end
#end
#No. 183487
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryRemainingExpenseCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryRemainingExpenseCost()
   {
      return summaryRemainingExpenseCost;
   }

#end
#end
#No. 183488
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryRemainingExpenseCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryRemainingExpenseCost(Double value)
   {
      this.summaryRemainingExpenseCost = value;
   }

#end
#end
#No. 183489
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryRemainingFinishDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getSummaryRemainingFinishDate()
   {
      return summaryRemainingFinishDate;
   }

#end
#end
#No. 183490
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryRemainingFinishDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setSummaryRemainingFinishDate(Date value)
   {
      this.summaryRemainingFinishDate = value;
   }

#end
#end
#No. 183491
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryRemainingLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryRemainingLaborCost()
   {
      return summaryRemainingLaborCost;
   }

#end
#end
#No. 183492
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryRemainingLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryRemainingLaborCost(Double value)
   {
      this.summaryRemainingLaborCost = value;
   }

#end
#end
#No. 183493
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryRemainingLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryRemainingLaborUnits()
   {
      return summaryRemainingLaborUnits;
   }

#end
#end
#No. 183494
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryRemainingLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryRemainingLaborUnits(Double value)
   {
      this.summaryRemainingLaborUnits = value;
   }

#end
#end
#No. 183495
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryRemainingMaterialCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryRemainingMaterialCost()
   {
      return summaryRemainingMaterialCost;
   }

#end
#end
#No. 183496
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryRemainingMaterialCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryRemainingMaterialCost(Double value)
   {
      this.summaryRemainingMaterialCost = value;
   }

#end
#end
#No. 183497
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryRemainingNonLaborCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryRemainingNonLaborCost()
   {
      return summaryRemainingNonLaborCost;
   }

#end
#end
#No. 183498
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryRemainingNonLaborCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryRemainingNonLaborCost(Double value)
   {
      this.summaryRemainingNonLaborCost = value;
   }

#end
#end
#No. 183499
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryRemainingNonLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryRemainingNonLaborUnits()
   {
      return summaryRemainingNonLaborUnits;
   }

#end
#end
#No. 183500
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryRemainingNonLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryRemainingNonLaborUnits(Double value)
   {
      this.summaryRemainingNonLaborUnits = value;
   }

#end
#end
#No. 183501
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryRemainingStartDate property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getSummaryRemainingStartDate()
   {
      return summaryRemainingStartDate;
   }

#end
#end
#No. 183502
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryRemainingStartDate property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setSummaryRemainingStartDate(Date value)
   {
      this.summaryRemainingStartDate = value;
   }

#end
#end
#No. 183503
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryRemainingTotalCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryRemainingTotalCost()
   {
      return summaryRemainingTotalCost;
   }

#end
#end
#No. 183504
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryRemainingTotalCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryRemainingTotalCost(Double value)
   {
      this.summaryRemainingTotalCost = value;
   }

#end
#end
#No. 183505
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summarySchedulePercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummarySchedulePercentComplete()
   {
      return summarySchedulePercentComplete;
   }

#end
#end
#No. 183506
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summarySchedulePercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummarySchedulePercentComplete(Double value)
   {
      this.summarySchedulePercentComplete = value;
   }

#end
#end
#No. 183507
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summarySchedulePercentCompleteByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummarySchedulePercentCompleteByLaborUnits()
   {
      return summarySchedulePercentCompleteByLaborUnits;
   }

#end
#end
#No. 183508
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summarySchedulePercentCompleteByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummarySchedulePercentCompleteByLaborUnits(Double value)
   {
      this.summarySchedulePercentCompleteByLaborUnits = value;
   }

#end
#end
#No. 183509
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summarySchedulePerformanceIndexByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummarySchedulePerformanceIndexByCost()
   {
      return summarySchedulePerformanceIndexByCost;
   }

#end
#end
#No. 183510
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summarySchedulePerformanceIndexByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummarySchedulePerformanceIndexByCost(Double value)
   {
      this.summarySchedulePerformanceIndexByCost = value;
   }

#end
#end
#No. 183511
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summarySchedulePerformanceIndexByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummarySchedulePerformanceIndexByLaborUnits()
   {
      return summarySchedulePerformanceIndexByLaborUnits;
   }

#end
#end
#No. 183512
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summarySchedulePerformanceIndexByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummarySchedulePerformanceIndexByLaborUnits(Double value)
   {
      this.summarySchedulePerformanceIndexByLaborUnits = value;
   }

#end
#end
#No. 183513
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryScheduleVarianceByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryScheduleVarianceByCost()
   {
      return summaryScheduleVarianceByCost;
   }

#end
#end
#No. 183514
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryScheduleVarianceByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryScheduleVarianceByCost(Double value)
   {
      this.summaryScheduleVarianceByCost = value;
   }

#end
#end
#No. 183515
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryScheduleVarianceByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryScheduleVarianceByLaborUnits()
   {
      return summaryScheduleVarianceByLaborUnits;
   }

#end
#end
#No. 183516
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryScheduleVarianceByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryScheduleVarianceByLaborUnits(Double value)
   {
      this.summaryScheduleVarianceByLaborUnits = value;
   }

#end
#end
#No. 183517
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryScheduleVarianceIndex property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryScheduleVarianceIndex()
   {
      return summaryScheduleVarianceIndex;
   }

#end
#end
#No. 183518
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryScheduleVarianceIndex property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryScheduleVarianceIndex(Double value)
   {
      this.summaryScheduleVarianceIndex = value;
   }

#end
#end
#No. 183519
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryScheduleVarianceIndexByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryScheduleVarianceIndexByCost()
   {
      return summaryScheduleVarianceIndexByCost;
   }

#end
#end
#No. 183520
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryScheduleVarianceIndexByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryScheduleVarianceIndexByCost(Double value)
   {
      this.summaryScheduleVarianceIndexByCost = value;
   }

#end
#end
#No. 183521
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryScheduleVarianceIndexByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryScheduleVarianceIndexByLaborUnits()
   {
      return summaryScheduleVarianceIndexByLaborUnits;
   }

#end
#end
#No. 183522
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryScheduleVarianceIndexByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryScheduleVarianceIndexByLaborUnits(Double value)
   {
      this.summaryScheduleVarianceIndexByLaborUnits = value;
   }

#end
#end
#No. 183523
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryStartDateVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryStartDateVariance()
   {
      return summaryStartDateVariance;
   }

#end
#end
#No. 183524
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryStartDateVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryStartDateVariance(Double value)
   {
      this.summaryStartDateVariance = value;
   }

#end
#end
#No. 183525
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryToCompletePerformanceIndexByCost property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryToCompletePerformanceIndexByCost()
   {
      return summaryToCompletePerformanceIndexByCost;
   }

#end
#end
#No. 183526
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryToCompletePerformanceIndexByCost property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryToCompletePerformanceIndexByCost(Double value)
   {
      this.summaryToCompletePerformanceIndexByCost = value;
   }

#end
#end
#No. 183527
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryTotalCostVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryTotalCostVariance()
   {
      return summaryTotalCostVariance;
   }

#end
#end
#No. 183528
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryTotalCostVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryTotalCostVariance(Double value)
   {
      this.summaryTotalCostVariance = value;
   }

#end
#end
#No. 183529
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryTotalFloat property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryTotalFloat()
   {
      return summaryTotalFloat;
   }

#end
#end
#No. 183530
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryTotalFloat property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryTotalFloat(Double value)
   {
      this.summaryTotalFloat = value;
   }

#end
#end
#No. 183531
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryUnitsPercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryUnitsPercentComplete()
   {
      return summaryUnitsPercentComplete;
   }

#end
#end
#No. 183532
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryUnitsPercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryUnitsPercentComplete(Double value)
   {
      this.summaryUnitsPercentComplete = value;
   }

#end
#end
#No. 183533
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the summaryVarianceAtCompletionByLaborUnits property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getSummaryVarianceAtCompletionByLaborUnits()
   {
      return summaryVarianceAtCompletionByLaborUnits;
   }

#end
#end
#No. 183534
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the summaryVarianceAtCompletionByLaborUnits property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setSummaryVarianceAtCompletionByLaborUnits(Double value)
   {
      this.summaryVarianceAtCompletionByLaborUnits = value;
   }

#end
#end
#No. 183535
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the totalBenefitPlan property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getTotalBenefitPlan()
   {
      return totalBenefitPlan;
   }

#end
#end
#No. 183536
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the totalBenefitPlan property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setTotalBenefitPlan(Double value)
   {
      this.totalBenefitPlan = value;
   }

#end
#end
#No. 183537
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the totalBenefitPlanTally property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getTotalBenefitPlanTally()
   {
      return totalBenefitPlanTally;
   }

#end
#end
#No. 183538
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the totalBenefitPlanTally property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setTotalBenefitPlanTally(Double value)
   {
      this.totalBenefitPlanTally = value;
   }

#end
#end
#No. 183539
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the totalSpendingPlan property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getTotalSpendingPlan()
   {
      return totalSpendingPlan;
   }

#end
#end
#No. 183540
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the totalSpendingPlan property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setTotalSpendingPlan(Double value)
   {
      this.totalSpendingPlan = value;
   }

#end
#end
#No. 183541
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the totalSpendingPlanTally property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getTotalSpendingPlanTally()
   {
      return totalSpendingPlanTally;
   }

#end
#end
#No. 183542
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the totalSpendingPlanTally property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setTotalSpendingPlanTally(Double value)
   {
      this.totalSpendingPlanTally = value;
   }

#end
#end
#No. 183543
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the unallocatedBudget property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getUnallocatedBudget()
   {
      return unallocatedBudget;
   }

#end
#end
#No. 183544
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the unallocatedBudget property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setUnallocatedBudget(Double value)
   {
      this.unallocatedBudget = value;
   }

#end
#end
#No. 183545
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the undistributedCurrentVariance property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getUndistributedCurrentVariance()
   {
      return undistributedCurrentVariance;
   }

#end
#end
#No. 183546
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the undistributedCurrentVariance property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setUndistributedCurrentVariance(Double value)
   {
      this.undistributedCurrentVariance = value;
   }

#end
#end
#No. 183547
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the wbsCategoryObjectId property.
    *
    * @return
    *     possible object is
    *     {@link Integer }
    *
    */

#Code:
   public Integer getWBSCategoryObjectId()
   {
      return wbsCategoryObjectId;
   }

#end
#end
#No. 183548
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the wbsCategoryObjectId property.
    *
    * @param value
    *     allowed object is
    *     {@link Integer }
    *
    */

#Code:
   public void setWBSCategoryObjectId(Integer value)
   {
      this.wbsCategoryObjectId = value;
   }

#end
#end
#No. 183549
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the wbsMilestonePercentComplete property.
    *
    * @return
    *     possible object is
    *     {@link Double }
    *
    */

#Code:
   public Double getWBSMilestonePercentComplete()
   {
      return wbsMilestonePercentComplete;
   }

#end
#end
#No. 183550
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the wbsMilestonePercentComplete property.
    *
    * @param value
    *     allowed object is
    *     {@link Double }
    *
    */

#Code:
   public void setWBSMilestonePercentComplete(Double value)
   {
      this.wbsMilestonePercentComplete = value;
   }

#end
#end
#No. 183551
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the udf property.
    *
    * <p>
    * This accessor method returns a reference to the live list,
    * not a snapshot. Therefore any modification you make to the
    * returned list will be present inside the JAXB object.
    * This is why there is not a <CODE>set</CODE> method for the udf property.
    *
    * <p>
    * For example, to add a new item, do as follows:
    * <pre>
    *    getUDF().add(newItem);
    * </pre>
    *
    *
    * <p>
    * Objects of the following type(s) are allowed in the list
    * {@link UDFAssignmentType }
    *
    *
    */

#Code:
   public List<UDFAssignmentType> getUDF()
   {
      if (udf == null)
      {
         udf = new ArrayList<UDFAssignmentType>();
      }
      return this.udf;
   }

#end
#end
#No. 183552
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the spread property.
    *
    * @return
    *     possible object is
    *     {@link EPSProjectWBSSpreadType }
    *
    */

#Code:
   public EPSProjectWBSSpreadType getSpread()
   {
      return spread;
   }

#end
#end
#No. 183553
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Sets the value of the spread property.
    *
    * @param value
    *     allowed object is
    *     {@link EPSProjectWBSSpreadType }
    *
    */

#Code:
   public void setSpread(EPSProjectWBSSpreadType value)
   {
      this.spread = value;
   }

#end
#end
#No. 183554
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the wbsResourceSpread property.
    *
    * <p>
    * This accessor method returns a reference to the live list,
    * not a snapshot. Therefore any modification you make to the
    * returned list will be present inside the JAXB object.
    * This is why there is not a <CODE>set</CODE> method for the wbsResourceSpread property.
    *
    * <p>
    * For example, to add a new item, do as follows:
    * <pre>
    *    getWBSResourceSpread().add(newItem);
    * </pre>
    *
    *
    * <p>
    * Objects of the following type(s) are allowed in the list
    * {@link ProjectResourceSpreadType }
    *
    *
    */

#Code:
   public List<ProjectResourceSpreadType> getWBSResourceSpread()
   {
      if (wbsResourceSpread == null)
      {
         wbsResourceSpread = new ArrayList<ProjectResourceSpreadType>();
      }
      return this.wbsResourceSpread;
   }
#end
#end
#No. 183555
#File: E:\bishe\1\WBSType.java
#Comment:
   /**
    * Gets the value of the wbsRoleSpread property.
    *
    * <p>
    * This accessor method returns a reference to the live list,
    * not a snapshot. Therefore any modification you make to the
    * returned list will be present inside the JAXB object.
    * This is why there is not a <CODE>set</CODE> method for the wbsRoleSpread property.
    *
    * <p>
    * For example, to add a new item, do as follows:
    * <pre>
    *    getWBSRoleSpread().add(newItem);
    * </pre>
    *
    *
    * <p>
    * Objects of the following type(s) are allowed in the list
    * {@link ProjectRoleSpreadType }
    *
    *
    */

#Code:
   public List<ProjectRoleSpreadType> getWBSRoleSpread()
   {
      if (wbsRoleSpread == null)
      {
         wbsRoleSpread = new ArrayList<ProjectRoleSpreadType>();
      }
      return this.wbsRoleSpread;
   }

#end
#end
#No. 183556
#File: E:\bishe\1\WcmCommandHandler.java
#Comment:
  /**
   * Activates provided asset
   *
   * @param assetPath path to asset
   * @throws IOException if response doesn't contain desired message
   */

#Code:
  public void activatePage(String assetPath) throws IOException {
    triggerAction(Maps.newHashMap(new ImmutableMap.Builder<String, String>()
        .put(PATH_PROPERTY, assetPath)
        .put(CMD_PROPERTY, ACTIVATE)
        .put(CHARSET_PROPERTY, UTF_8).build()), REPLICATE_URL,
        REPLICATION_STARTED_MESSAGE + assetPath);
  }

#end
#end
#No. 183557
#File: E:\bishe\1\WcmCommandHandler.java
#Comment:
  /**
   * Deactivates provided asset
   *
   * @param assetPath path to asset
   * @throws IOException if response doesn't contain desired message
   */

#Code:
  public void deactivatePage(String assetPath) throws IOException {
    triggerAction(Maps.newHashMap(new ImmutableMap.Builder<String, String>()
        .put(PATH_PROPERTY, assetPath)
        .put(CMD_PROPERTY, DEACTIVATE)
        .put(CHARSET_PROPERTY, UTF_8).build()), REPLICATE_URL,
        REPLICATION_STARTED_MESSAGE + assetPath);
  }

#end
#end
#No. 183558
#File: E:\bishe\1\WcmCommandHandler.java
#Comment:
  /**
   * Create page in provided location
   *
   * @param parentPath path to parent page
   * @param title page title
   * @param template page template
   * @throws IOException if response doesn't contain desired message
   */

#Code:
  public void createPage(String parentPath, String title, String template) throws IOException {
    triggerAction(Maps.newHashMap(new ImmutableMap.Builder<String, String>()
        .put(CMD_PROPERTY, CREATE_PAGE_COMMAND)
        .put(CHARSET_PROPERTY, UTF_8)
        .put(PARENT_PATH_PROPERTY, parentPath)
        .put(TITLE_PROPERTY, title)
        .put(TEMPLATE_PROPERTY, template).build()), WCM_COMMAND_URL, PAGE_CREATED_SUCCESS_MESSAGE);
  }

#end
#end
#No. 183559
#File: E:\bishe\1\WcmCommandHandler.java
#Comment:
  /**
   * Delete page from provided location
   *
   * @param path to page
   * @throws IOException if response doesn't contain desired message
   */

#Code:
  public void deletePage(String path) throws IOException {
    triggerAction(Maps.newHashMap(new ImmutableMap.Builder<String, String>()
        .put(CMD_PROPERTY, DELETE_PAGE_COMMAND)
        .put(CHARSET_PROPERTY, UTF_8)
        .put(PATH_PROPERTY, path.toLowerCase()).build()), WCM_COMMAND_URL,
        String.format(PAGE_DELETED_SUCCESS_MESSAGE_FORMAT, path.toLowerCase()));
  }

#end
#end
#No. 183560
#File: E:\bishe\1\WcmCommandHandler.java
#Comment:
  /**
   * Allows to trigger any Wcm action using provided Map as POST properties
   *
   * @param postProperties properties map to send
   * @param successMessage expected success message
   * @param commandUrl command
   * @throws IOException if response doesn't contain desired message
   */

#Code:
  public void triggerAction(Map<String, String> postProperties, String commandUrl,
      String successMessage)
      throws IOException {
    HttpPost request = new HttpPost(String.format(commandUrl, authorIp));
    List<BasicNameValuePair> params = new ArrayList<>();
    postProperties.entrySet().stream().
            forEach(property ->
              params.add(new BasicNameValuePair(property.getKey(), property.getValue()))
            );
    request.setEntity(new UrlEncodedFormEntity(params, Consts.UTF_8));
    sender.sendCrxRequest(request, successMessage);
  }

#end
#end
#No. 183561
#File: E:\bishe\1\WCursorAdapter.java
#Comment:
  /**
   * 0 prevents the CursorAdapter from doing its own observing of the Cursor,
   * which is not needed since when a change happens you will get a new Cursor
   * throw another call here.
   */

#Code:
  public WCursorAdapter(Context context, Cursor c, W wonder) {
    super(context, c, 0);
    init(context, wonder);
  }

#end
#end
#No. 183562
#File: E:\bishe\1\WeakBatchRemoteEventListener.java
#Comment:
/**
 * Used in order to weakly hold batch listeners by the Notify delegator.
 *
 * @author anna
 * @version 1.0
 * @since 7.0
 */

#Code:
@com.gigaspaces.api.InternalApi
public class WeakBatchRemoteEventListener extends WeakReference<BatchRemoteEventListener>
        implements BatchRemoteEventListener {
    public WeakBatchRemoteEventListener(BatchRemoteEventListener listener) {
        super(listener);
    }

    /**
     * Delegate the notification to the listener.
     */
    public void notify(RemoteEvent event) throws UnknownEventException, RemoteException {
        RemoteEventListener l = get();
        if (l != null) {
            l.notify(event);
        }
    }

    /* (non-Javadoc)
     * @see com.gigaspaces.events.batching.BatchRemoteEventListener#notifyBatch(com.gigaspaces.events.batching.BatchRemoteEvent)
     */
    public void notifyBatch(BatchRemoteEvent theEvents)
            throws UnknownEventException, RemoteException {
        BatchRemoteEventListener l = get();
        if (l != null) {
            l.notifyBatch(theEvents);
        }
    }
}

#end
#end
#No. 183564
#File: E:\bishe\1\WeakDelegateListObserverListener.java
#Comment:
    /**
     * Constructs a new listener which weakly references the given delegate.
     * @param delegate The delegate to weakly reference.
     */

#Code:
    public WeakDelegateListObserverListener(Delegate delegate) {
        this.weakRef = new WeakReference<Delegate>(delegate);
    }

#end
#end
#No. 183565
#File: E:\bishe\1\WeakDelegateListObserverListener.java
#Comment:
    /**
     * Called to attempt to retrieve the delegate. If it can't be reached, we
     * will attempt to remove ourselves from the given observer.
     * @param observer An observer to attempt to remove this listener from if
     *                 we can't reach the delegate.
     * @return The delegate, or null if it could not be reached.
     */

#Code:
    protected Delegate getDelegate(ListObserver<Data> observer) {
        Delegate proxy = weakRef.get();
        if (proxy != null) {
            return proxy;
        } else {
            if (observer != null) {
                observer.removeListener(this);
            }
            return null;
        }
    }

#end
#end
#No. 183566
#File: E:\bishe\1\WeakDiscoveryListener.java
#Comment:
/**
 * Used in order to weakly hold listeners by the {@link LookupDiscoveryManager}.
 *
 * @author moran
 * @version 1.0
 * @since 6.0
 */

#Code:
@com.gigaspaces.api.InternalApi
public class WeakDiscoveryListener extends WeakReference<DiscoveryListener>
        implements DiscoveryListener {
    /**
     * Weak DiscoveryListener constructor.
     *
     * @param listener the DiscoveryListener reference.
     */
    public WeakDiscoveryListener(DiscoveryListener listener) {
        super(listener);
    }

    /**
     * Delegate the notification to the listener.
     *
     * @see net.jini.discovery.DiscoveryListener#discarded(net.jini.discovery.DiscoveryEvent)
     */
    public void discarded(DiscoveryEvent event) {
        DiscoveryListener l = get();
        if (l != null) {
            l.discarded(event);
        }

    }

    /**
     * Delegate the notification to the listener.
     *
     * @see net.jini.discovery.DiscoveryListener#discovered(net.jini.discovery.DiscoveryEvent)
     */
    public void discovered(DiscoveryEvent event) {
        DiscoveryListener l = get();
        if (l != null) {
            l.discovered(event);
        }
    }
}

#end
#end
#No. 183567
#File: E:\bishe\1\WeakHashMapConverter.java
#Comment:
/**
 * Converter for {@link WeakHashMap} types.
 *
 * @since 2.0
 */

#Code:
public class WeakHashMapConverter
    extends MapConverterSupport
{
  public WeakHashMapConverter() {
    super(WeakHashMap.class);
  }

  @Override
  @SuppressWarnings({"unchecked"})
  protected Map createMap(final Map map) throws Exception {
    return new WeakHashMap(map);
  }
}

#end
#end
#No. 183568
#File: E:\bishe\1\WeakIdentityHashSet.java
#Comment:
	    /**
	     * Constructs a new, empty set; the backing <tt>HashMap</tt> instance has
	     * default initial capacity (16) and load factor (0.75).
	     */

#Code:
	    public WeakIdentityHashSet() {
	        map = new WeakIdentityHashMap<E,Object>();
	    }

#end
#end
#No. 183569
#File: E:\bishe\1\WeakIdentityHashSet.java
#Comment:
	    /**
	     * Returns the number of elements in this set (its cardinality).
	     *
	     * @return the number of elements in this set (its cardinality)
	     */

#Code:
	    public synchronized int size() {
	        return map.size();
	    }

#end
#end
#No. 183570
#File: E:\bishe\1\WeakIdentityHashSet.java
#Comment:
	    /**
	     * Returns <tt>true</tt> if this set contains no elements.
	     *
	     * @return <tt>true</tt> if this set contains no elements
	     */

#Code:
	    public synchronized boolean isEmpty() {
	        return map.isEmpty();
	    }

#end
#end
#No. 183571
#File: E:\bishe\1\WeakIdentityHashSet.java
#Comment:
	    /**
	     * Returns <tt>true</tt> if this set contains the specified element.
	     * More formally, returns <tt>true</tt> if and only if this set
	     * contains an element <tt>e</tt> such that
	     * <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>.
	     *
	     * @param o element whose presence in this set is to be tested
	     * @return <tt>true</tt> if this set contains the specified element
	     */

#Code:
	    public synchronized boolean contains(Object o) {
	        return map.containsKey(o);
	    }

#end
#end
#No. 183572
#File: E:\bishe\1\WeakIdentityHashSet.java
#Comment:
	    /**
	     * Adds the specified element to this set if it is not already present.
	     * More formally, adds the specified element <tt>e</tt> to this set if
	     * this set contains no element <tt>e2</tt> such that
	     * <tt>(e==null&nbsp;?&nbsp;e2==null&nbsp;:&nbsp;e.equals(e2))</tt>.
	     * If this set already contains the element, the call leaves the set
	     * unchanged and returns <tt>false</tt>.
	     *
	     * @param e element to be added to this set
	     * @return <tt>true</tt> if this set did not already contain the specified
	     * element
	     */

#Code:
	    public synchronized boolean add(E e) {
	        return map.put(e, PRESENT)==null;
	    }

#end
#end
#No. 183573
#File: E:\bishe\1\WeakIdentityHashSet.java
#Comment:
	    /**
	     * Removes the specified element from this set if it is present.
	     * More formally, removes an element <tt>e</tt> such that
	     * <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>,
	     * if this set contains such an element.  Returns <tt>true</tt> if
	     * this set contained the element (or equivalently, if this set
	     * changed as a result of the call).  (This set will not contain the
	     * element once the call returns.)
	     *
	     * @param o object to be removed from this set, if present
	     * @return <tt>true</tt> if the set contained the specified element
	     */

#Code:
	    public synchronized boolean remove(Object o) {
	        return map.remove(o)==PRESENT;
	    }

#end
#end
#No. 183574
#File: E:\bishe\1\WeakIdentityHashSet.java
#Comment:
	    /**
	     * Removes all of the elements from this set.
	     * The set will be empty after this call returns.
	     */

#Code:
	    public synchronized void clear() {
	        map.clear();
	    }

#end
#end
#No. 183575
#File: E:\bishe\1\WeakIdentityHashSet.java
#Comment:
	    /**
	     * Applies the ValueFunction to all values with non-null keys.
	     * 
	     * @param f	the ValueFunction
	     */

#Code:
	    public synchronized void applyToAllActiveValues(ValueFunction<E> f) {
	    	map.applyToAllActiveKeys(f);
	    }

#end
#end
#No. 183576
#File: E:\bishe\1\WeakLeaseListener.java
#Comment:
/**
 * Used in order to weakly hold listeners by the LeaseRenewalManager.
 *
 * @author Guy Korland
 * @version 1.0
 * @since 5.01
 */

#Code:
@com.gigaspaces.api.InternalApi
public class WeakLeaseListener extends WeakReference<LeaseListener>
        implements LeaseListener {
    public WeakLeaseListener(LeaseListener listener) {
        super(listener);
    }

    /**
     * Delegate the notification to the listener.
     */
    public void notify(LeaseRenewalEvent event) {
        LeaseListener l = get();
        if (l != null) {
            l.notify(event);
        }
    }

}



#end
#end
#No. 183578
#File: E:\bishe\1\WeakRemoteEventListener.java
#Comment:
/**
 * Used in order to weakly hold listeners by the Notify delegator.
 *
 * @author Guy Korland
 * @version 1.0
 * @since 5.01
 */

#Code:
@com.gigaspaces.api.InternalApi
public class WeakRemoteEventListener extends WeakReference<RemoteEventListener>
        implements RemoteEventListener {
    public WeakRemoteEventListener(RemoteEventListener listener) {
        super(listener);
    }

    /**
     * Delegate the notification to the listener.
     */
    public void notify(RemoteEvent event) throws UnknownEventException, RemoteException {
        RemoteEventListener l = get();
        if (l != null) {
            l.notify(event);
        }
    }
}

#end
#end
#No. 183579
#File: E:\bishe\1\WeakTable.java
#Comment:
	/**
	 * Self-sent message to convert a value to its weak counterpart
	 * @param value value to convert
	 * @return {@link LuaValue} that is a strong or weak reference, depending on type of {@code value}
	 */

#Code:
	protected static LuaValue weaken( LuaValue value ) {
		switch ( value.type() ) {
			case LuaValue.TFUNCTION:
			case LuaValue.TTHREAD:
			case LuaValue.TTABLE:
				return new WeakValue(value);
			case LuaValue.TUSERDATA:
				return new WeakUserdata(value);
			default:
				return value;
		}
	}

#end
#end
#No. 183580
#File: E:\bishe\1\WeakTable.java
#Comment:
	/**
	 * Unwrap a LuaValue from a WeakReference and/or WeakUserdata.
	 * @param ref reference to convert
	 * @return LuaValue or null
	 * @see #weaken(LuaValue)
	 */

#Code:
	protected static LuaValue strengthen(Object ref) {
		if ( ref instanceof WeakReference ) {
			ref = ((WeakReference) ref).get();
		}
		if ( ref instanceof WeakValue ) {
			return ((WeakValue) ref).strongvalue();
		}
		return (LuaValue) ref;
	}

#end
#end
#No. 183581
#File: E:\bishe\1\WeakWorldReference.java
#Comment:
    /**
     * Creates a new weak world reference.
     * 
     * @param world the world
     */

#Code:
    public WeakWorldReference(World world) {
        this.world = new WeakReference<>(checkNotNull(world, "world"));
        this.uniqueId = world.getUniqueId();
    }

#end
#end
#No. 183582
#File: E:\bishe\1\WeakWorldReference.java
#Comment:
    /**
     * Creates a new weak world reference with the unique id of the world.
     * 
     * @param uniqueId the unique id
     */

#Code:
    public WeakWorldReference(UUID uniqueId) {
        this.uniqueId = checkNotNull(uniqueId, "uniqueId");
    }

#end
#end
#No. 183583
#File: E:\bishe\1\WeakWorldReference.java
#Comment:
    /**
     * Gets the unique id of the world of this reference.
     * 
     * @return the unique id
     */

#Code:
    public UUID getUniqueId() {
        return this.uniqueId;
    }

#end
#end
#No. 183584
#File: E:\bishe\1\WeakWorldReference.java
#Comment:
    /**
     * Gets the world of this reference, this world may be
     * {@link Optional#empty()} if it couldn't be found.
     * 
     * @return the world if present, otherwise {@link Optional#empty()}
     */

#Code:
    public Optional<World> getWorld() {
        World world = this.world == null ? null : this.world.get();
        if (world != null) {
            return Optional.of(world);
        }
        world = Sponge.getServer().getWorld(this.uniqueId).orElse(null);
        if (world != null) {
            this.world = new WeakReference<>(world);
            return Optional.of(world);
        }
        return Optional.empty();
    }

#end
#end
#No. 183585
#File: E:\bishe\1\WeakWorldReference.java
#Comment:
    /**
     * Creates a copy of the weak world reference.
     * 
     * @return the copy
     */

#Code:
    public WeakWorldReference copy() {
        final World world = this.world == null ? null : this.world.get();
        return world != null ? new WeakWorldReference(world) : new WeakWorldReference(this.uniqueId);
    }

#end
#end
#No. 183594
#File: E:\bishe\1\WeaponTest.java
#Comment:
    /**
     * Make sure {@link Weapon#getDamagePerShot()} returns the volley damage and not projectile damage.
     */

#Code:
    @Test
    public void testGetDamagePerShot_lb10x() throws Exception {
        final Weapon lb10xac = (Weapon) ItemDB.lookup("LB 10-X AC");
        assertTrue(lb10xac.getDamagePerShot() > 5);
    }


#end
#end
#No. 183596
#File: E:\bishe\1\WeaponTest.java
#Comment:
    /**
     * When taking the quotient of two stats that are zero we're faced with interpreting 0/0. Although not strictly
     * mathematically correct, we will interpret x/y as 'x' per 'y' and if 'x' is zero we will output zero if 'y' is
     * also finite.a
     */

#Code:
    @Test
    public void testGetStatZeroOverZero() {
        // AMS has no heat.
        assertEquals(0.0, ItemDB.AMS.getHeat(null), 0.0);
        assertEquals(0.0, ItemDB.AMS.getStat("h/h", null), 0.0);
    }

#end
#end
#No. 183597
#File: E:\bishe\1\weapontype_t.java
#Comment:
/** The defined weapons,
 * including a marker indicating
 *  user has not changed weapon.
 */

#Code:
public enum weapontype_t
{
    wp_fist,
    wp_pistol,
    wp_shotgun,
    wp_chaingun,
    wp_missile,
    wp_plasma,
    wp_bfg,
    wp_chainsaw,
    wp_supershotgun,

    NUMWEAPONS,
    
    // No pending weapon change.
    wp_nochange;
    
    public String toString(){
        return this.name();
    }
    
}



#end
#end
#No. 183612
#File: E:\bishe\1\WeatherBuilder.java
#Comment:
    /**
     * Sets the aliases of the {@link LanternWeather}.
     *
     * @param aliases The aliases
     * @return This weather builder
     */

#Code:
    public WeatherBuilder aliases(String... aliases) {
        this.aliases = ImmutableSet.copyOf(aliases);
        return this;
    }

#end
#end
#No. 183613
#File: E:\bishe\1\WeatherBuilder.java
#Comment:
    /**
     * Sets the aliases of the {@link LanternWeather}.
     *
     * @param aliases The aliases
     * @return This weather builder
     */

#Code:
    public WeatherBuilder aliases(Iterable<String> aliases) {
        this.aliases = ImmutableSet.copyOf(aliases);
        return this;
    }

#end
#end
#No. 183614
#File: E:\bishe\1\WeatherBuilder.java
#Comment:
    /**
     * Sets the {@link Action} of the {@link LanternWeather}.
     *
     * @param action The action
     * @return This weather builder
     */

#Code:
    public WeatherBuilder action(Action action) {
        this.action = checkNotNull(action, "action");
        return this;
    }

#end
#end
#No. 183615
#File: E:\bishe\1\WeatherBuilder.java
#Comment:
    /**
     * Sets the {@link OptionValueMap} of the {@link LanternWeather}.
     *
     * @param optionValueMap The option value map
     * @return This weather builder
     */

#Code:
    public WeatherBuilder options(OptionValueMap optionValueMap) {
        this.options = checkNotNull(optionValueMap, "optionValueMap");
        return this;
    }

#end
#end
#No. 183616
#File: E:\bishe\1\WeatherBuilder.java
#Comment:
    /**
     * Sets a {@link Option} for the {@link LanternWeather}. The option is applied
     * to the current {@link OptionValueMap}.
     *
     * @param option The option
     * @param value The value
     * @return This weather builder
     */

#Code:
    public <T> WeatherBuilder options(Option<T> option, T value) {
        this.options.put(option, value);
        return this;
    }

#end
#end
#No. 183618
#File: E:\bishe\1\WeatherChoiceDao.java
#Comment:
	/**
	 * @return {@link List} {@link WeatherChoice}, order by active, location name, never null
	 */

#Code:
	public List<WeatherChoice> findAllWeathers() {
		Logger.d(LOG_TAG, "Finding all weathers");
		return DBUtils.executeInSafety(new Callable<List<WeatherChoice>>() {
			@Override
			public List<WeatherChoice> call() throws Exception {

				final PreparedQuery<WeatherChoice> orderBy = WeatherChoiceDao.this.dao.queryBuilder()
					.orderBy(WeatherChoice.VALID, false)
					.orderBy(WeatherChoice.ACTIVE, false)
					.orderBy(WeatherChoice.ROAMING, false)
					.orderBy(WeatherChoice.WEATHER_LOCATION, true)
					.prepare();

				Logger.d(LOG_TAG, orderBy.getStatement());

				final List<WeatherChoice> woeidChoices = WeatherChoiceDao.this.dao.query(orderBy);

				return null != woeidChoices
						? woeidChoices
						: new ArrayList<WeatherChoice>();
			}
		});
	}

#end
#end
#No. 183619
#File: E:\bishe\1\WeatherConditionVisibilityCriterionTest.java
#Comment:
  /**
   * Initialize the Mockito stubs.
   */

#Code:
  @Before
  public void initialize() {
    Mockito.when(observer.getObserverLocation()).thenReturn(location);
    Mockito.when(location.getWorld()).thenReturn(world);
    Mockito.when(world.getWeather()).thenReturn(weather);
  }



#end
#end
#No. 183621
#File: E:\bishe\1\WeatherDataParser.java
#Comment:
    /**
     * Helper method to handle insertion of a new location in the weather database.
     *
     * @param locationSetting The location string used to request updates from the server.
     * @param cityName A human-readable city name, e.g "Mountain View"
     * @param lat the latitude of the city
     * @param lon the longitude of the city
     * @return the row ID of the added location.
     */

#Code:
    private long addLocation(String locationSetting, String cityName, double lat, double lon, Context ctx) {

        Log.v(LOG_TAG, "inserting " + cityName + ", with coord: " + lat + ", " + lon);

        // First, check if the location with this city name exists in the db
        Cursor cursor = ctx.getContentResolver().query(
                WeatherContract.LocationEntry.CONTENT_URI,
                new String[]{WeatherContract.LocationEntry._ID},
                WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING + " = ?",
                new String[]{locationSetting},
                null);

        if (cursor.moveToFirst()) {
            Log.v(LOG_TAG, "Found it in the database!");
            int locationIdIndex = cursor.getColumnIndex(WeatherContract.LocationEntry._ID);
            return cursor.getLong(locationIdIndex);
        } else {
            Log.v(LOG_TAG, "Didn't find it in the database, inserting now!");
            ContentValues locationValues = new ContentValues();
            locationValues.put(WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING, locationSetting);
            locationValues.put(WeatherContract.LocationEntry.COLUMN_CITY_NAME, cityName);
            locationValues.put(WeatherContract.LocationEntry.COLUMN_COORD_LAT, lat);
            locationValues.put(WeatherContract.LocationEntry.COLUMN_COORD_LONG, lon);

            Uri locationInsertUri = ctx.getContentResolver()
                    .insert(WeatherContract.LocationEntry.CONTENT_URI, locationValues);

            return ContentUris.parseId(locationInsertUri);
        }
    }

#end
#end
#No. 183622
#File: E:\bishe\1\WeatherDataProvider.java
#Comment:
/**
 * A dummy class that we are going to use internally to store weather data.  Generally, this data
 * will be stored in an external and persistent location (ie. File, Database, SharedPreferences) so
 * that the data can persist if the process is ever killed.  For simplicity, in this sample the
 * data will only be stored in memory.
 */

#Code:
class WeatherDataPoint {
    String city;
    int degrees;

    WeatherDataPoint(String c, int d) {
        city = c;
        degrees = d;
    }
}

#end
#end
#No. 183632
#File: E:\bishe\1\WeatherManager.java
#Comment:
        /**
         * Create request handler.
         */

#Code:

        final ApiClient.CurrentWeatherRequestHandler requestHandler = new ApiClient.CurrentWeatherRequestHandler() {
            @Override
            public void onFinishedRequestWithSuccess(ApiClient apiClient, Weather weather) {
                if (handler != null) {
                    handler.onReceivedCurrentWeather(
                            WeatherManager.this,
                            weather
                    );
                }
            }

            @Override
            public void onFinishedRequestWithError(ApiClient apiClient) {
                if (handler != null) {
                    handler.onFailedToReceiveCurrentWeather(
                            WeatherManager.this
                    );
                }
            }
        };




#end
#end
#No. 183636
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Check if the user only wants to download when on wifi
	 * 
	 * @param context
	 * @return true if the user want measurements from the nearest station
	 */

#Code:
	public static boolean getDownloadOnlyOnWifi(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		return settings.getBoolean(PREFS_DOWNLOAD_ONLY_ON_WIFI_KEY,
				PREFS_DOWNLOAD_ONLY_ON_WIFI_DEFAULT);

	}

#end
#end
#No. 183637
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Gets the date when the last downloaded measurement was measured.
	 * 
	 * @param context
	 * @return time for last measurement
	 */

#Code:
	public static Date getLastUpdateTime(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		final long result = settings.getLong(PREFS_LAST_UPDATE_TIME_KEY, 0l);
		if (result == 0l)
			return null;
		else
			return new Date(result);
	}

#end
#end
#No. 183638
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Get saved last temperature. If there has been any successfully downloads
	 * of temperature since the station was set, it returns the last measurement
	 * of temperature. It does not download any new temperature.
	 * 
	 * @param context
	 * @return last downloaded temperature
	 */

#Code:
	public static String getSavedLastTemperature(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		final String key = PREFS_LAST_WEATHER_KEY;
		final String defaultV = "empty";
		final String result = settings.getString(key, defaultV);
		if (result == defaultV)
			return null;
		else
			return result;
	}

#end
#end
#No. 183639
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Gets the station id for where the measurement is taken. If the user want
	 * the nearest station this return the last used station.
	 * 
	 * @param context
	 * @return station id
	 */

#Code:
	public static int getStationId(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		return settings.getInt(PREFS_STATION_ID_KEY, PREFS_STATION_ID_DEFAULT);
	}

#end
#end
#No. 183640
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Gets the station name for where the measurement is taken. If the user
	 * want the nearest station this return the last used station.
	 * 
	 * @param context
	 * @return station name
	 */

#Code:
	public static String getStationName(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		return settings.getString(PREFS_STATION_NAME_KEY,
				PREFS_STATION_NAME_DEFAULT);
	}

#end
#end
#No. 183641
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Gets how often the user wants to update the notification, the alarm is
	 * handeled in WeatherNotificationService. TODO: move to
	 * WeatherNotificationService
	 * 
	 * @param context
	 * @return interval in minutes between each update
	 */

#Code:
	public static int getUpdateRate(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		return settings
				.getInt(PREFS_UPDATE_RATE_KEY, PREFS_UPDATE_RATE_DEFAULT);
	}

#end
#end
#No. 183642
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Check if the user want measurements from the nearest station
	 * 
	 * @param context
	 * @return true if the user want measurements from the nearest station
	 */

#Code:
	public static boolean isUsingNearestStation(Context context) {
		final SharedPreferences settings = context.getSharedPreferences(
				PREFS_NAME, 0);
		return settings.getBoolean(PREFS_USE_NEAREST_STATION_KEY,
				PREFS_USE_NEAREST_STATION_DEFAULT);

	}

#end
#end
#No. 183643
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Save the last measurements
	 * 
	 * @param context
	 * @param value
	 * @param time
	 */

#Code:
	static void setLastTemperature(Context context, String value, Long time) {
		final Editor settings = context.getSharedPreferences(PREFS_NAME, 0)
				.edit();
		settings.putLong(PREFS_LAST_UPDATE_TIME_KEY, time);
		settings.putString(PREFS_LAST_WEATHER_KEY, value);
		settings.commit();
	}

#end
#end
#No. 183644
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Set the station to be used for updating measurement and delete saved
	 * measurement. If the id is the same as before, nothing is done. NOTE:
	 * {@link WsKlimaProxy#setUseNearestStation(Context, boolean)} must also be
	 * set.
	 * 
	 * 
	 * @param context
	 * @param name
	 * @param id
	 */

#Code:
	public static void setStation(Context context, String name, int id) {
		final SharedPreferences preferences = context.getSharedPreferences(
				PREFS_NAME, 0);

		// Do nothing if ids are equal
		final int oldId = preferences.getInt(PREFS_STATION_ID_KEY,
				PREFS_STATION_ID_DEFAULT);
		if (oldId == id)
			return;

		final Editor settings = preferences.edit();
		settings.putInt(PREFS_STATION_ID_KEY, id);
		settings.putString(PREFS_STATION_NAME_KEY, name);
		settings.remove(PREFS_LAST_UPDATE_TIME_KEY);
		settings.remove(PREFS_LAST_WEATHER_KEY);
		settings.commit();
	}

#end
#end
#No. 183645
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Set how often {@link WeatherNotificationService} should update the
	 * notification
	 * 
	 * @param context
	 * @param updateRate
	 *            in minutes
	 */

#Code:
	public static void setUpdateRate(Context context, int updateRate) {
		final Editor settings = context.getSharedPreferences(PREFS_NAME, 0)
				.edit();
		settings.putInt(PREFS_UPDATE_RATE_KEY, updateRate);
		settings.commit();
		updateAlarm(context);
	}

#end
#end
#No. 183646
#File: E:\bishe\1\WeatherNotificationSettings.java
#Comment:
	/**
	 * Set if the user wants to use the nearest station when updating
	 * measurement.
	 * 
	 * @param context
	 * @param useNearestStation
	 */

#Code:
	public static void setUseNearestStation(Context context,
			boolean useNearestStation) {
		final Editor settings = context.getSharedPreferences(PREFS_NAME, 0)
				.edit();
		settings.putBoolean(PREFS_USE_NEAREST_STATION_KEY, useNearestStation);
		settings.commit();
	}

#end
#end
#No. 183648
#File: E:\bishe\1\WeatherOutput.java
#Comment:
    /**
     * 
     * @param query
     */

#Code:
    public WeatherOutput(Query query) {
        super();
        this.query = query;
    }


#end
#end
#No. 183651
#File: E:\bishe\1\WeatherUtils.java
#Comment:
    /**
     * Helper method to provide the icon resource id according to the weather condition id returned
     * by the OpenWeatherMap call.
     *
     * @param weatherId from OpenWeatherMap API response
     * @return resource id for the corresponding icon. -1 if no relation is found.
     */

#Code:
    public static int getIconResourceForWeatherCondition(int weatherId) {
        // Based on weather code data found at:
        // http://bugs.openweathermap.org/projects/api/wiki/Weather_Condition_Codes
        if (weatherId >= 200 && weatherId <= 232) {
            return R.drawable.ic_storm;
        } else if (weatherId >= 300 && weatherId <= 321) {
            return R.drawable.ic_light_rain;
        } else if (weatherId >= 500 && weatherId <= 504) {
            return R.drawable.ic_rain;
        } else if (weatherId == 511) {
            return R.drawable.ic_snow;
        } else if (weatherId >= 520 && weatherId <= 531) {
            return R.drawable.ic_rain;
        } else if (weatherId >= 600 && weatherId <= 622) {
            return R.drawable.ic_snow;
        } else if (weatherId >= 701 && weatherId <= 761) {
            return R.drawable.ic_fog;
        } else if (weatherId == 761 || weatherId == 781) {
            return R.drawable.ic_storm;
        } else if (weatherId == 800) {
            return R.drawable.ic_clear;
        } else if (weatherId == 801) {
            return R.drawable.ic_light_clouds;
        } else if (weatherId >= 802 && weatherId <= 804) {
            return R.drawable.ic_cloudy;
        }
        return -1;
    }

#end
#end
#No. 183652
#File: E:\bishe\1\WeatherUtils.java
#Comment:
    /**
     * Helper method to provide the art resource id according to the weather condition id returned
     * by the OpenWeatherMap call.
     *
     * @param weatherId from OpenWeatherMap API response
     * @return resource id for the corresponding icon. -1 if no relation is found.
     */

#Code:
    public static int getArtResourceForWeatherCondition(int weatherId) {
        // Based on weather code data found at:
        // http://bugs.openweathermap.org/projects/api/wiki/Weather_Condition_Codes
        if (weatherId >= 200 && weatherId <= 232) {
            return R.drawable.art_storm;
        } else if (weatherId >= 300 && weatherId <= 321) {
            return R.drawable.art_light_rain;
        } else if (weatherId >= 500 && weatherId <= 504) {
            return R.drawable.art_rain;
        } else if (weatherId == 511) {
            return R.drawable.art_snow;
        } else if (weatherId >= 520 && weatherId <= 531) {
            return R.drawable.art_rain;
        } else if (weatherId >= 600 && weatherId <= 622) {
            return R.drawable.art_snow;
        } else if (weatherId >= 701 && weatherId <= 761) {
            return R.drawable.art_fog;
        } else if (weatherId == 761 || weatherId == 781) {
            return R.drawable.art_storm;
        } else if (weatherId == 800) {
            return R.drawable.art_clear;
        } else if (weatherId == 801) {
            return R.drawable.art_light_clouds;
        } else if (weatherId >= 802 && weatherId <= 804) {
            return R.drawable.art_clouds;
        }
        return -1;
    }

#end
#end
#No. 183654
#File: E:\bishe\1\WeaveBookmarksListActivity.java
#Comment:
	/**
	 * Set the list loading animation.
	 */

#Code:
    private void setAnimation() {
    	AnimationSet set = new AnimationSet(true);

        Animation animation = new AlphaAnimation(0.0f, 1.0f);
        animation.setDuration(75);
        set.addAnimation(animation);

        animation = new TranslateAnimation(
            Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f,
            Animation.RELATIVE_TO_SELF, -1.0f, Animation.RELATIVE_TO_SELF, 0.0f
        );
        animation.setDuration(50);
        set.addAnimation(animation);

        LayoutAnimationController controller =
                new LayoutAnimationController(set, 0.5f);

        mListView.setLayoutAnimation(controller);
    }

#end
#end
#No. 183655
#File: E:\bishe\1\WeaveCryptoUtil.java
#Comment:
  /**
   * This code basically inlines usage of the BouncyCastle private API and is equivalent to the following code.
   * <pre>
   * {@code
   * PBEParametersGenerator generator = new PKCS5S2ParametersGenerator();
   * generator.init(PBEParametersGenerator.PKCS5PasswordToBytes(secret), salt, 4096);
   * CipherParameters keyParam = generator.generateDerivedParameters(256);
   * return ((KeyParameter)keyParam).getKey();
   * }
   * </pre>
   */

#Code:
  private static byte[] derivePKCS5S2(char[] secret, byte[] salt) throws GeneralSecurityException {
    byte[] secretBytes = passwordPKCS5ToBytes(secret);
    int keySizeInBytes = 256 / 8;
    final int iterations = 4096;
    Mac hMac = Mac.getInstance("HMACSHA1");
    int hLen = hMac.getMacLength();
    int l = (keySizeInBytes + hLen - 1) / hLen;
    byte[] iBuf = new byte[4];
    byte[] dKey = new byte[l * hLen];
    for (int i = 1; i <= l; i++) {
      intToOctet(iBuf, i);
      derivePKCS5S2Helper(hMac, secretBytes, salt, iterations, iBuf, dKey, (i - 1) * hLen);
    }
    byte[] retval = new byte[keySizeInBytes];
    System.arraycopy(dKey, 0, retval, 0, keySizeInBytes);
    return retval;
  }


#end
#end
#No. 183661
#File: E:\bishe\1\WebAirMapViewBuilder.java
#Comment:
  /**
   * Build the map fragment with the requested options
   *
   * @return The {@link WebViewMapFragment} map fragment.
   */

#Code:
  @Override public WebViewMapFragment build() {
    if (options == null) {
      options = new GoogleWebMapType();
    }

#end
#end
#No. 183663
#File: E:\bishe\1\WebApiIT.java
#Comment:
    /**
     * @return the restTemplate
     */

#Code:
    public RestTemplate getRestTemplate() {
        return this.restTemplate.getRestTemplate();
    }

#end
#end
#No. 183664
#File: E:\bishe\1\WebApiIT.java
#Comment:
    /**
     * @return the baseUri
     */

#Code:
    public String getBaseUri() {
        return this.baseUri;
    }

#end
#end
#No. 183665
#File: E:\bishe\1\WebApiIT.java
#Comment:
    /**
     * @param baseUri the baseUri to set
     */

#Code:
    public void setBaseUri(final String baseUri) {
        this.baseUri = baseUri;
    }

#end
#end
#No. 183666
#File: E:\bishe\1\WebApplicationMetaData.java
#Comment:
    /**
     * Override to return false to prevent WebApplicationDefaultsProcessor 
     * from setting an empty context to /
     */

#Code:
    public boolean forceDefaultContext() {
        return true;
    }

#end
#end
#No. 183667
#File: E:\bishe\1\WebApplicationMetaData.java
#Comment:
    /**
     * Override to return false to prevent WebApplicationDefaultsProcessor 
     * from setting the static path prefix to public/
     */

#Code:
    public boolean forceDefaultStaticPathPrefix() {
        return true;
    }

#end
#end
#No. 183668
#File: E:\bishe\1\WebApplicationMetaData.java
#Comment:
    /**
     * Set the session timeout for inactive web sessions.
     * 
     * <p>
     * Pass a negative interval for the timeout value to indicate <b>never</b>.
     * Not recommended.
     * </p>
     * 
     */

#Code:
    public void setSessionTimeout(TimeInterval timeout) {
        this.sessionTimeout = timeout;
    }

#end
#end
#No. 183669
#File: E:\bishe\1\WebApplicationMetaData.java
#Comment:
    /**
     * Retrieve the session timeout for inactive web sessions, as seconds.
     * 
     * @return The timeout, as seconds, or <code>-1</code> indicating no
     *         timeout.
     */

#Code:
    public int getSessionTimeout() {
        return (int) this.sessionTimeout.valueAs( TimeUnit.SECONDS );
    }

#end
#end
#No. 183671
#File: E:\bishe\1\WebappManager.java
#Comment:
    /**
     * Reads the data from the file and converts them to List.
     * 
     * @param file
     * @return a List of the data of the file.
     * @throws FileNotFoundException
     */

#Code:
    private static List<String> readData(final File file)
            throws FileNotFoundException {
        List<String> list = new ArrayList<String>();
        Scanner scanner = new Scanner(file);
        while (scanner.hasNextLine()) {
            list.add(scanner.nextLine());
        }
        return list;
    }

#end
#end
#No. 183672
#File: E:\bishe\1\WebappManager.java
#Comment:
    /**
     * Writes the data from the List to the file.
     * 
     * @param file
     * @param list
     * @throws IOException
     */

#Code:
    private static void writeData(final List<String> list, final File file)
            throws IOException {
        FileWriter fileWriter = new FileWriter(file);
        for (String str : list) {
            fileWriter.write(str + "\n");
        }
        fileWriter.flush();
        fileWriter.close();
    }

#end
#end
#No. 183673
#File: E:\bishe\1\WebAppPathLabelProvider.java
#Comment:
    /**
     * {@inheritDoc}
     * 
     * @see org.eclipse.jface.viewers.ILabelProvider#getImage(java.lang.Object)
     */

#Code:
    public Image getImage(Object element)
    {
        return JettyPlugin.getIcon(JettyPlugin.FOLDER_ICON);
    }

#end
#end
#No. 183674
#File: E:\bishe\1\WebAppPathLabelProvider.java
#Comment:
    /**
     * {@inheritDoc}
     * 
     * @see org.eclipse.jface.viewers.ILabelProvider#getText(java.lang.Object)
     */

#Code:
    public String getText(Object element)
    {
        return String.valueOf(element);
    }




#end
#end
#No. 183677
#File: E:\bishe\1\WebAppType.java
#Comment:
    /**
     * Gets the value of the descriptionAndDisplayNameAndIcon property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the descriptionAndDisplayNameAndIcon property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDescriptionAndDisplayNameAndIcon().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DisplayNameType }
     * {@link FilterType }
     * {@link ResourceRefType }
     * {@link ServletMappingType }
     * {@link ParamValueType }
     * {@link EmptyType }
     * {@link JspConfigType }
     * {@link ServiceRefType }
     * {@link LocaleEncodingMappingListType }
     * {@link ResourceEnvRefType }
     * {@link DescriptionType }
     * {@link SecurityConstraintType }
     * {@link MessageDestinationRefType }
     * {@link ListenerType }
     * {@link EnvEntryType }
     * {@link EjbLocalRefType }
     * {@link MimeMappingType }
     * {@link LoginConfigType }
     * {@link IconType }
     * {@link SessionConfigType }
     * {@link ServletType }
     * {@link MessageDestinationType }
     * {@link FilterMappingType }
     * {@link ErrorPageType }
     * {@link EjbRefType }
     * {@link WelcomeFileListType }
     * {@link SecurityRoleType }
     * 
     * 
     */

#Code:
    public List<Object> getDescriptionAndDisplayNameAndIcon() {
        if (descriptionAndDisplayNameAndIcon == null) {
            descriptionAndDisplayNameAndIcon = new ArrayList<Object>();
        }
        return this.descriptionAndDisplayNameAndIcon;
    }

#end
#end
#No. 183678
#File: E:\bishe\1\WebAppType.java
#Comment:
    /**
     * Gets the value of the version property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String }
     *     
     */

#Code:
    public java.lang.String getVersion() {
        return version;
    }

#end
#end
#No. 183679
#File: E:\bishe\1\WebAppType.java
#Comment:
    /**
     * Sets the value of the version property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String }
     *     
     */

#Code:
    public void setVersion(java.lang.String value) {
        this.version = value;
    }

#end
#end
#No. 183680
#File: E:\bishe\1\WebAppType.java
#Comment:
    /**
     * Gets the value of the id property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String }
     *     
     */

#Code:
    public java.lang.String getId() {
        return id;
    }

#end
#end
#No. 183681
#File: E:\bishe\1\WebAppType.java
#Comment:
    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String }
     *     
     */

#Code:
    public void setId(java.lang.String value) {
        this.id = value;
    }

#end
#end
#No. 183682
#File: E:\bishe\1\WebAppUtil.java
#Comment:
  /**
   * Use session attribute: APP_USER
   * @param req
   * @return
   */

#Code:
  public static String findUserFromRequest(HttpServletRequest req)
  {
    if(req.getUserPrincipal()!=null)
	  return req.getUserPrincipal().getName();//find from security login JAAS
	if(req.getSession()!=null)
	{
	  try
	  {
	    return AppUser.class.cast(req.getSession().getAttribute(AppUser.SESSION_ATTRIBUTE)).getName();//find from session
	  }catch(Exception ex){}
	}
	return null;
  }


#end
#end
#No. 183685
#File: E:\bishe\1\WebBrowserType.java
#Comment:
/**
 * Represents the type of Browser being created.
 * TODO: Add support for Safari by creating a SafariBrowser class and figure out the correct DesiredCapabilities for configuring Safari.
 */

#Code:
public enum WebBrowserType {
    IE, CHROME, FIREFOX, SAFARI, MOBILE;

    public static WebBrowserType forName(String name) {
        for (WebBrowserType type: WebBrowserType.values()) {
            if (type.toString().equalsIgnoreCase(name)) {
                return type;
            }
        }
        throw new IllegalArgumentException("WebBrowserType must be 'IE', 'CHROME', 'FIREFOX', 'SAFARI', or 'MOBILE'");
    }
}

#end
#end
#No. 183686
#File: E:\bishe\1\WebClipPayload.java
#Comment:
/**
 * An MDM payload for WebClip.
 *
 * @author Sylvain Pedneault
 */

#Code:
class WebClipPayload extends MobileConfigPayload {
  public WebClipPayload(final int payloadVersion, final String payloadOrganization, final String payloadIdentifier, final String payloadDisplayName, final String url, final String label) throws JSONException {
    super(payloadVersion, "com.apple.webClip.managed", payloadOrganization, payloadIdentifier, payloadDisplayName);
    final JSONObject payload = getPayload();
    payload.put("URL", url);
    payload.put("Label", label);
  }

  public void setIcon(final Object data) throws JSONException {
    getPayload().put("Icon", data);
  }

  public void setIsRemovable(final boolean value) throws JSONException {
    getPayload().put("IsRemovable", value);
  }
}

#end
#end
#No. 183688
#File: E:\bishe\1\WebConnectionBuilder.java
#Comment:
    /**
     * Adds a non encoded HTTP request header
     *
     * @param key   - The header key
     * @param value - The header value
     */

#Code:
    public WebConnectionBuilder addHeader(String key, String value) {
        this.headers.put(key, value);
        return this;
    }

#end
#end
#No. 183689
#File: E:\bishe\1\WebConnectionBuilder.java
#Comment:
    /**
     * Sets the location prefix of the remote server
     * (String format %s...)
     * This only for urls that need it
     *
     * @param prefix - The prefix of the server EG: bs1-
     */

#Code:
    public WebConnectionBuilder locationPrefix(String prefix) {
        this.url = String.format(url, prefix);
        return this;
    }

#end
#end
#No. 183690
#File: E:\bishe\1\WebConnectionBuilder.java
#Comment:
    /**
     * Adds a encrypted post parameter to the request
     *
     * @param key   - The key
     * @param value - The value, will be encrypted
     */

#Code:
    public WebConnectionBuilder addEncodedPostData(String key, String value) {
        try {
            addPostData(key, URLEncoder.encode(value, "UTF-8"));
        } catch (UnsupportedEncodingException ignored) {
        }
        return this;
    }

#end
#end
#No. 183691
#File: E:\bishe\1\WebConnectionBuilder.java
#Comment:
    /**
     * Adds a post parameter to the request
     *
     * @param key   - The key
     * @param value - The value, will be encrypted
     */

#Code:
    public WebConnectionBuilder addPostData(String key, String value) {
        if (postData.length() != 0) {
            postData.append("&");
        }
        postData.append(key).append("=").append(value);
        return this;
    }

#end
#end
#No. 183692
#File: E:\bishe\1\WebConnectionBuilder.java
#Comment:
    /**
     * Sets the data to post if the request type is POST
     *
     * @param postData - The data to be posted, must be encrypted first
     */

#Code:
    public WebConnectionBuilder setPostData(String postData) {
        this.postData = new StringBuilder(postData);
        return this;
    }


#end
#end
#No. 183695
#File: E:\bishe\1\WebdavServlet.java
#Comment:
    /**
     * Returns the <code>DavLocatorFactory</code>. If no locator factory has
     * been set or created a new instance of {@link org.apache.jackrabbit.webdav.simple.LocatorFactoryImpl} is
     * returned.
     *
     * @return the locator factory
     * @see AbstractWebdavServlet#getLocatorFactory()
     */

#Code:
    @Override
    public DavLocatorFactory getLocatorFactory() {
        if (locatorFactory == null) {
            locatorFactory = new LocatorFactoryImpl(resourcePathPrefix);
        }
        return locatorFactory;
    }

#end
#end
#No. 183696
#File: E:\bishe\1\WebdavServlet.java
#Comment:
    /**
     * Sets the <code>DavLocatorFactory</code>.
     *
     * @param locatorFactory
     * @see AbstractWebdavServlet#setLocatorFactory(DavLocatorFactory)
     */

#Code:
    @Override
    public void setLocatorFactory(DavLocatorFactory locatorFactory) {
        this.locatorFactory = locatorFactory;
    }

#end
#end
#No. 183697
#File: E:\bishe\1\WebdavServlet.java
#Comment:
    /**
     * Returns the <code>DavResourceFactory</code>. If no request factory has
     * been set or created a new instance of {@link ResourceFactoryImpl} is
     * returned.
     *
     * @return the resource factory
     * @see org.apache.jackrabbit.server.AbstractWebdavServlet#getResourceFactory()
     */

#Code:
    @Override
    public DavResourceFactory getResourceFactory() {
        if (resourceFactory == null) {
            resourceFactory = new FSDavResourceFactory(getResourceConfig(),
                                                       getConf(getServletContext()));
        }
        return resourceFactory;
    }

#end
#end
#No. 183698
#File: E:\bishe\1\WebdavServlet.java
#Comment:
    /**
     * Sets the <code>DavResourceFactory</code>.
     *
     * @param resourceFactory
     * @see AbstractWebdavServlet#setResourceFactory(org.apache.jackrabbit.webdav.DavResourceFactory)
     */

#Code:
    @Override
    public void setResourceFactory(DavResourceFactory resourceFactory) {
        this.resourceFactory = resourceFactory;
    }

#end
#end
#No. 183699
#File: E:\bishe\1\WebdavServlet.java
#Comment:
    /**
     * Returns the <code>DavSessionProvider</code>. If no session provider has
     * been set or created a new instance of {@link FakeDavSessionProvider}
     * is returned.
     *
     * @return the session provider
     */

#Code:
    @Override
    public synchronized DavSessionProvider getDavSessionProvider() {
        if (davSessionProvider == null) {
            davSessionProvider = new FakeDavSessionProvider();
        }
        return davSessionProvider;
    }

#end
#end
#No. 183700
#File: E:\bishe\1\WebdavServlet.java
#Comment:
    /**
     * Sets the <code>DavSessionProvider</code>.
     *
     * @param sessionProvider
     * @see AbstractWebdavServlet#setDavSessionProvider(org.apache.jackrabbit.webdav.DavSessionProvider)
     */

#Code:
    @Override
    public synchronized void setDavSessionProvider(DavSessionProvider sessionProvider) {
        this.davSessionProvider = sessionProvider;
    }

#end
#end
#No. 183701
#File: E:\bishe\1\WebdavServlet.java
#Comment:
    /**
     * Returns the header value retrieved from the {@link #INIT_PARAM_AUTHENTICATE_HEADER}
     * init parameter. If the parameter is missing, the value defaults to
     * {@link #DEFAULT_AUTHENTICATE_HEADER}.
     *
     * @return the header value retrieved from the corresponding init parameter
     * or {@link #DEFAULT_AUTHENTICATE_HEADER}.
     * @see org.apache.jackrabbit.server.AbstractWebdavServlet#getAuthenticateHeaderValue()
     */

#Code:
    @Override
    public String getAuthenticateHeaderValue() {
        return authenticate_header;
    }

#end
#end
#No. 183702
#File: E:\bishe\1\WebdavServlet.java
#Comment:
    /**
     * Returns the resource configuration to be applied
     *
     * @return the resource configuration.
     */

#Code:
    private ResourceConfig getResourceConfig() {
        // fallback if no config present
        if (config == null) {
            config = new ResourceConfig();
        }
        return config;
    }


#end
#end
#No. 183704
#File: E:\bishe\1\WebdavServlet.java
#Comment:
    /**
     * This is a cheesy way to set the value of the hadoop config
     * @param config
     */

#Code:
    public static void setConf(Configuration config) {
        hadoopConfig = config;   
    }



#end
#end
#No. 183707
#File: E:\bishe\1\WebDriverElement.java
#Comment:
    /**
     * Looks up the underlying source {@link org.openqa.selenium.WebElement}. If the element is no
     * longer present, a {@link org.openqa.selenium.NoSuchElementException} may be thrown.
     */

#Code:
    @Override
    public WebElement getWrappedElement() {
        return source.lookup();
    }

#end
#end
#No. 183708
#File: E:\bishe\1\WebDriverElement.java
#Comment:
    /**
     * Retrieve the ElementContext that this element was found in. Intended to allow element types
     * to find other elements within the same context, most likely by nesting within themselves. For
     * example, {@code return By.nested(this, By.htmlTag("option")).findAll(SelectOption.class,
     * getContext());}.
     */

#Code:
    public ElementContext getContext() {
        return context;
    }

#end
#end
#No. 183709
#File: E:\bishe\1\WebDriverElement.java
#Comment:
    /**
     * Expected way for sub element types to interact with their corresponding WebElement. This
     * attempts the desired action, and will throw appropriate exceptions should the element not be
     * able to be interacted with, for whatever reason. If the WebElement is stale when the action
     * is attempted, the cached WebElement will be cleared and looked up again, which may lookup a
     * fresh reference to the equivalent element.
     *
     * @param action A function that wraps the action to be performed. Accepts the source WebElement
     * as its only parameter and returns nothing.
     */

#Code:
    protected void attempt(Consumer<WebElement> action) {
        try {
            action.accept(webElement());
        } catch (StaleElementReferenceException e) {
            invalidateCache();

            try {
                action.accept(webElement());
            } catch (ElementNotVisibleException e1) {
                throw new ElementNotDisplayedException(this, e1);
            }
        } catch (ElementNotVisibleException e) {
            throw new ElementNotDisplayedException(this, e);
        }
    }

#end
#end
#No. 183710
#File: E:\bishe\1\WebDriverElement.java
#Comment:
    /**
     * Expected way for sub element types to interact with their corresponding WebElement. This
     * attempts the desired action, and will throw appropriate exceptions should the element not be
     * able to be interacted with, for whatever reason. If the WebElement is stale when the action
     * is attempted, the cached WebElement will be cleared and looked up again, which may lookup a
     * fresh reference to the equivalent element.
     *
     * @param action A function that wraps the action to be performed. Accepts the source WebElement
     * as its only parameter and returns the result of this action.
     * @param <T> Return type of the action.
     * @return Whatever the action returns.
     */

#Code:
    protected <T> T attemptAndGet(Function<WebElement, T> action) {
        try {
            return action.apply(webElement());
        } catch (StaleElementReferenceException e) {
            invalidateCache();

            try {
                return action.apply(webElement());
            } catch (ElementNotVisibleException e1) {
                throw new ElementNotDisplayedException(this, e1);
            }
        } catch (ElementNotVisibleException e) {
            throw new ElementNotDisplayedException(this, e);
        }
    }


#end
#end
#No. 183721
#File: E:\bishe\1\WebDriverModifyingCollector.java
#Comment:
/**
 * Collector that applies WebDriverModifiers to WebDriver.
 */

#Code:
public class WebDriverModifyingCollector
    implements Collector<WebDriverModifier, WebDriver, WebDriver> {
  
  private final WebDriver webdriver;

  public WebDriverModifyingCollector(WebDriver webdriver) {
    this.webdriver = webdriver;
  }

  @Override
  public Supplier<WebDriver> supplier() {
    return () -> webdriver;
  }

  @Override
  public BiConsumer<WebDriver, WebDriverModifier> accumulator() {
    return (wd, wdMod) -> wd = wdMod.modify(wd);
  }

  @Override
  public BinaryOperator<WebDriver> combiner() {
    return (webDriver, webDriver2) -> {
      throw new UnsupportedOperationException();
    };
  }

  @Override
  public Function<WebDriver, WebDriver> finisher() {
    return webDriver -> webDriver;
  }

  @Override
  public Set<Characteristics> characteristics() {
    return Collections.emptySet();
  }
}

#end
#end
#No. 183723
#File: E:\bishe\1\WebDriverUtils.java
#Comment:
	/**
	 * Print internal Logger status
	 */

#Code:
	public static void returnLoggerState() {
		LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
		StatusPrinter.print(lc);
	}

#end
#end
#No. 183724
#File: E:\bishe\1\WebDriverUtils.java
#Comment:
	/**
	 * Loops to determine if WebDriver.getWindowHandles() returns any
	 *  additional windows that the allHandles cache does not currently
	 *  contain. If new windows are found, switch to latest window and
	 *  update allHandles cache.
	 */

#Code:
	public static String handleNewWindow() {
		String newHandle = "";
		printHandles();
		Set<String> updatedHandles = driver.getWindowHandles();
		if ( updatedHandles.size() <= handleCache.size() ) {
			mainHandle = "";
			throw new IllegalStateException("This method handleNewWindow is not appropriate\n" +
					"in this case.  You are probably looking for the\n"+
					"use of the updateHandleCache method.");
		} else {
			if ( !updatedHandles.isEmpty() ) {
				for ( String windowId : updatedHandles ) {
					if ( !windowId.equals( mainHandle ) ) { // for all windows except main window
						if ( !handleCache.contains( windowId) ) { // for child windows not in allHandles cache
							newHandle = windowId; // set value of newly found window handle						
							LOGGER.info("-- Open window handle: " + newHandle + " (new window)" );
						}
					}
				}
				if ( !newHandle.equals("") ) { // outside loop so it catches latest window handle if there are multiple
					LOGGER.info("Switch to new window.");
					driver.switchTo().window( newHandle ); // switch to new window handle
				}
			} else {
				mainHandle = "";
				throw new IllegalStateException("No browser window handles are open.");
			}
		}
		handleCache = updatedHandles; // updates remembered set of open windows
		return newHandle;
	}

#end
#end
#No. 183725
#File: E:\bishe\1\WebElementScopedLocatorFactory.java
#Comment:
/**
 * Locator factory where the scope is defined by the provided webElement.
 */

#Code:
public class WebElementScopedLocatorFactory
    implements ElementLocatorFactory, ParentElementLocatorProvider {

  private final WebDriver webDriver;

  private final WebElement webElement;

  /**
   * Constructs WebElementScopedLocatorFactory.
   *
   * @param webDriver  WebDriver instance.
   * @param webElement Defines scope for the objects that this factory is going to produce.
   */
  public WebElementScopedLocatorFactory(WebDriver webDriver, WebElement webElement) {
    this.webDriver = webDriver;
    this.webElement = webElement;
  }

  /**
   * Returns scope represented by this locator factory.
   */
  @Override
  public ElementLocator getCurrentScope() {
    return new WebElementLocator(webElement);
  }

  /**
   * Return a DefaultElementLocator.
   */
  @Override
  public ElementLocator createLocator(Field field) {
    return new DefaultElementLocator(resolveContext(field), field);
  }

  private SearchContext resolveContext(Field field) {
    return field.isAnnotationPresent(Global.class) ? webDriver : webElement;
  }

}


#end
#end
#No. 183730
#File: E:\bishe\1\WebHdfsHaDispatch.java
#Comment:
   /**
   * @throws javax.servlet.ServletException
   */

#Code:
  public WebHdfsHaDispatch() throws ServletException {
    super();
  }

#end
#end
#No. 183731
#File: E:\bishe\1\WebHdfsHaDispatch.java
#Comment:
   /**
    * Checks for specific outbound response codes/content to trigger a retry or failover
    */

#Code:
   @Override
   protected void writeOutboundResponse(HttpUriRequest outboundRequest, HttpServletRequest inboundRequest, HttpServletResponse outboundResponse, HttpResponse inboundResponse) throws IOException {
      if (inboundResponse.getStatusLine().getStatusCode() == 403) {
         BufferedHttpEntity entity = new BufferedHttpEntity(inboundResponse.getEntity());
         inboundResponse.setEntity(entity);
         ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
         inboundResponse.getEntity().writeTo(outputStream);
         String body = new String(outputStream.toByteArray());
         if (body.contains("StandbyException")) {
            throw new StandbyException();
         }
         if (body.contains("SafeModeException") || body.contains("RetriableException")) {
            throw new SafeModeException();
         }
      }
      super.writeOutboundResponse(outboundRequest, inboundRequest, outboundResponse, inboundResponse);
   }

#end
#end
#No. 183732
#File: E:\bishe\1\WebHdfsHaFuncTest.java
#Comment:
   /**
    * Creates a deployment of a gateway instance that all test methods will share.  This method also creates a
    * registry of sorts for all of the services that will be used by the test methods.
    * The createTopology method is used to create the topology file that would normally be read from disk.
    * The driver.setupGateway invocation is where the creation of GATEWAY_HOME occurs.
    * <p/>
    * This would normally be done once for this suite but the failure tests start affecting each other depending
    * on the state the last 'active' url
    *
    * @throws Exception Thrown if any failure occurs.
    */

#Code:
   @Before
   public void setup() throws Exception {
      LOG_ENTER();
      //Log.setLog(new NoOpLogger());
      masterServer = new MockServer("master", true);
      standbyServer = new MockServer("standby", true);
      GatewayTestConfig config = new GatewayTestConfig();
      config.setGatewayPath("gateway");
      driver.setResourceBase(WebHdfsHaFuncTest.class);
      driver.setupLdap(0);
      driver.setupService("WEBHDFS", "http://vm.local:50070/webhdfs", "/cluster/webhdfs", USE_MOCK_SERVICES);
      driver.setupGateway(config, "cluster", createTopology(), USE_GATEWAY);
      LOG_EXIT();
   }

#end
#end
#No. 183733
#File: E:\bishe\1\WebhookBuilder.java
#Comment:
/**
 * A builder that automatically provides/validates parameters surrounding webhooks.
 */

#Code:
public abstract class WebhookBuilder<B extends FCRequest.BaseBuilder<B,R>, R extends FCRequest>
        extends FCRequest.BaseBuilder<B,R> {

    public B webhookUrl(String url) {
        params.put(FCConstants.PARAM_WEBHOOK_URL, url);
        return self();
    }

    public B webhookId(String id) {
        params.put(FCConstants.PARAM_WEBHOOK_ID, id);
        return self();
    }

    public B webhookBody(Boolean rawJson) {
        if(rawJson) {
            params.put(FCConstants.PARAM_WEBHOOK_BODY, "json");
        } else {
            params.remove(FCConstants.PARAM_WEBHOOK_BODY);
        }
        return self();
    }

    protected void validate() {
       if(!hasParam(FCConstants.PARAM_WEBHOOK_URL) &&
               ( hasParam(FCConstants.PARAM_WEBHOOK_BODY) || hasParam(FCConstants.PARAM_WEBHOOK_ID) )) {
           throw new IllegalArgumentException("Request has some webhook parameters set, but no webhook URL.");
       }
        try {
            String url = params.get(FCConstants.PARAM_WEBHOOK_URL);
            if(url != null) {
                URL webUrl = new URL(url);
            }
        } catch(MalformedURLException e) {
            throw new IllegalArgumentException("The webhook URL is not a valid URL");
        }
    }
}

#end
#end
#No. 183734
#File: E:\bishe\1\WebHookPayload.java
#Comment:
    /**
     * {@link System#currentTimeMillis()} when this object's constructor was called.
     *
     * @return the object's creation time/when the payload was received.
     */

#Code:
    public long getReceived() {
        return received;
    }

#end
#end
#No. 183735
#File: E:\bishe\1\WebIntent.java
#Comment:
	/**
	 * Returns the web URL to be loaded into web browser.
	 *
	 * @return Valid URL or empty string if not specified yet.
	 * @see #url(String)
	 */

#Code:
	@NonNull
	public String url() {
		return mUrl == null ? "" : mUrl;
	}


#end
#end
#No. 183737
#File: E:\bishe\1\WebLinkView.java
#Comment:
    /**
     * @param context
     * @param url
     */

#Code:
    public WebLinkView(Context context, String url)
    {
        super(context);
        throw new RuntimeException(
                "Please pass custom Parameters icon_img and link");

    }

#end
#end
#No. 183738
#File: E:\bishe\1\WebLinkView.java
#Comment:
    /**
     * @param context
     * @param attrs
     */

#Code:
    public WebLinkView(Context context, AttributeSet attrs)
    {
        super(context, attrs);
        init(attrs);
    }

#end
#end
#No. 183739
#File: E:\bishe\1\WebLinkView.java
#Comment:
    /**
     * @param context
     * @param attrs
     * @param defStyle
     */

#Code:
    public WebLinkView(Context context, AttributeSet attrs, int defStyle)
    {
        super(context, attrs, defStyle);
        init(attrs);
    }

#end
#end
#No. 183740
#File: E:\bishe\1\WebLinkView.java
#Comment:
    /**
     * @param attrs
     */

#Code:
    private void init(AttributeSet attrs)
    {
        TypedArray a = getContext().obtainStyledAttributes(attrs,
                com.bearstouch.android.core.R.styleable.WebLinkView);
        String url = a.getString(R.styleable.WebLinkView_link);

        this.http_url = url;

        setOnClickListener(new OnClickListener()
        {

            public void onClick(View arg0)
            {
                Intent intent = new Intent(Intent.ACTION_VIEW);
                intent.setData(Uri.parse(http_url));
                getContext().startActivity(intent);

            }
        });

    }

#end
#end
#No. 183741
#File: E:\bishe\1\WebLogicJMXLibClassLoader.java
#Comment:
/**
 * A {@link ClassLoader} that is used to load classes
 * from <code>WL_HOME/server/lib/weblogic.jar</code>.
 * <p>
 * Classloading is delegated to the parent first, before
 * attempting to load from the weblogic.jar file.
 *
 * @author Vineet Reynolds
 */

#Code:
class WebLogicJMXLibClassLoader extends URLClassLoader {
    private static final Logger logger = Logger.getLogger(WebLogicJMXLibClassLoader.class.getName());

    public WebLogicJMXLibClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory) {
        super(urls, parent, factory);
    }

    public WebLogicJMXLibClassLoader(URL[] urls, ClassLoader parent) {
        super(urls, parent);
    }

    public WebLogicJMXLibClassLoader(URL[] urls) {
        super(urls);
    }

    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        logger.log(Level.FINEST, "Loading class: {0}", name);
        return super.loadClass(name);
    }
}


#end
#end
#No. 183744
#File: E:\bishe\1\WebLogicServerControl.java
#Comment:
        /**
         * Returns the shell interpret command and a list of arguments to be passed to the interpreter. The list of
         * arguments
         * includes the path to the script file to be executed.
         *
         * @return A {@link List} containing the shell script interpreter for the OS environment and the script to be
         * executed.
         */

#Code:
        protected final List<String> getCommand() {
            List<String> command = new ArrayList<String>();
            command.addAll(getShellInterpreter());
            command.add(getScript());
            return command;
        }

#end
#end
#No. 183745
#File: E:\bishe\1\WebLogicServerControl.java
#Comment:
        /**
         * Returns the name of the executable for the shell interpreter and parameters to allow for executing a shell
         * script
         * file. The executable is assumed to be present in any of the directories in the PATH. An absolute path to the
         * shell
         * interpreter will not be returned.
         *
         * @return A {@link List} of strings representing the name of the executable for the shell interpreter, and a
         * parameter
         * to allow a shell script file to be passed as an argument to the shell interpreter.
         */

#Code:
        private List<String> getShellInterpreter() {
            List<String> shellCommands = new ArrayList<String>();
            String os = System.getProperty("os.name").toLowerCase();
            if (os.startsWith("windows")) {
                shellCommands.add("cmd.exe");
                shellCommands.add("/c");
            } else {
                String shell = System.getenv("SHELL");
                if (shell == null) {
                    shellCommands.add("sh");
                    shellCommands.add("-c");
                } else {
                    shellCommands.add(shell);
                    shellCommands.add("-c");
                }
            }
            return shellCommands;
        }


#end
#end
#No. 183756
#File: E:\bishe\1\WebModulesContainer.java
#Comment:
    /**
     * Constructs new WebModulesContainer object from the given configuration.
     * @param configuration The configuration to take the web modules from.
     */

#Code:
    public WebModulesContainer(TelemetryConfiguration configuration) {
        buildWebModules(configuration);
        this.modulesCount = modules.size();
    }

#end
#end
#No. 183757
#File: E:\bishe\1\WebModulesContainer.java
#Comment:
    /**
     * Invokes onBeginRequest on each of the telemetry modules
     * @param req The request to process
     * @param res The response to process
     */

#Code:
    public void invokeOnBeginRequest(ServletRequest req, ServletResponse res) {
        for (WebTelemetryModule module : modules) {
            try {
                module.onBeginRequest(req, res);
            } catch (Exception e) {
                InternalLogger.INSTANCE.error(
                        "Web module " + module.getClass().getSimpleName() + " failed on BeginRequest with exception: %s", e.getMessage());
            }
        }
    }

#end
#end
#No. 183758
#File: E:\bishe\1\WebModulesContainer.java
#Comment:
    /**
     * Invokes onEndRequest on each of the telemetry modules
     * @param req The request to process
     * @param res The response to process
     */

#Code:
    public void invokeOnEndRequest(ServletRequest req, ServletResponse res) {
        for (WebTelemetryModule module : modules) {
            try {
                module.onEndRequest(req, res);
            } catch (Exception e) {
                InternalLogger.INSTANCE.error(
                        "Web module " + module.getClass().getSimpleName() + " failed on EndRequest with exception: %s", e.getMessage());
            }
        }
    }

#end
#end
#No. 183759
#File: E:\bishe\1\WebModulesContainer.java
#Comment:
    /**
     * Gets the modules count
     * @return The modules count
     */

#Code:
    public int getModulesCount() {
        return modulesCount;
    }

#end
#end
#No. 183760
#File: E:\bishe\1\WebModulesContainer.java
#Comment:
    /**
     * Builds the web telemetry modules from the given configuration.
     * @param configuration The configuration
     */

#Code:
    private void buildWebModules(TelemetryConfiguration configuration) {

        for (TelemetryModule module : configuration.getTelemetryModules()) {
            if (module instanceof WebTelemetryModule) {
                modules.add((WebTelemetryModule)module);
            }
        }
    }


#end
#end
#No. 183763
#File: E:\bishe\1\WebMvcConfiguration.java
#Comment:
    /**
     * In Internet Explorer http requests are cached by default. It's a problem when we want to provide a REST API. This interceptor
     * adds headers in the responses to desactivate the cache. NB :  static resources are cached but managed by the resource handlers
     *
     * @param registry
     */

#Code:
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        WebContentInterceptor interceptor = new WebContentInterceptor();
        interceptor.setCacheSeconds(0);
        interceptor.setUseExpiresHeader(true);
        interceptor.setUseCacheControlHeader(true);
        interceptor.setUseCacheControlNoStore(true);

        registry.addInterceptor(interceptor);
    }

#end
#end
#No. 183764
#File: E:\bishe\1\WebMvcConfiguration.java
#Comment:
    /**
     * Add resources handler to help Spring to manage our static resources (from frontend and backend)
     */

#Code:
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {

        if (!registry.hasMappingForPattern("/i18n/*")) {
            registry.addResourceHandler("/i18n/*")
                    .addResourceLocations("classpath:/i18n/");
        }

        if (!registry.hasMappingForPattern("/widgets/**")) {
            registry.addResourceHandler("/widgets/**")
                    .addResourceLocations(WIDGETS_RESOURCES);
        }

        if (!registry.hasMappingForPattern("/**")) {
            registry.addResourceHandler("/**")
                    .addResourceLocations(CLASSPATH_RESOURCE_LOCATIONS);
        }
    }

#end
#end
#No. 183765
#File: E:\bishe\1\WebMvcConfiguration.java
#Comment:
    /**
     * Spring MVC use a default objectMapper. Objects passed to and returned from the controllers are converted to and from HTTP messages by HttpMessageConverter
     * instances. We must use our {{@link #objectMapper}} because of the subtypes.... So we declare two message converters
     * <ul>
     * <li>StringHttpMessageConverter to format the String sent by HTTP like a JSON object representation</li>
     * <li>MappingJackson2HttpMessageConverter to use our {{@link #objectMapper}}</li>
     * </ul>To declare a JacksonHttpMessageConvet
     */

#Code:
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        //Add a converter for the String sent via HTTP
        StringHttpMessageConverter stringConverter = new StringHttpMessageConverter(Charset.forName("UTF-8"));
        stringConverter.setWriteAcceptCharset(false);  // see SPR-7316
        converters.add(stringConverter);

        //Use our custom Jackson serializer
        MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(objectMapper);
        mappingJackson2HttpMessageConverter.setSupportedMediaTypes(supportedMediaTypes());
        converters.add(mappingJackson2HttpMessageConverter);

    }

#end
#end
#No. 183767
#File: E:\bishe\1\WebOperationIdTelemetryInitializer.java
#Comment:
    /**
     * Initializes the properties of the given telemetry.
     */

#Code:
    @Override
    protected void onInitializeTelemetry(Telemetry telemetry) {
        RequestTelemetryContext telemetryContext = ThreadContext.getRequestTelemetryContext();

        if (CommonUtils.isNullOrEmpty(telemetry.getContext().getOperation().getId())) {
            telemetry.getContext().getOperation().setId(telemetryContext.getHttpRequestTelemetry().getId());
        }
    }

#end
#end
#No. 183768
#File: E:\bishe\1\WebOperationNameTelemetryInitializer.java
#Comment:
    /**
     * Initializes the properties of the given telemetry.
     *
     * @param telemetry The {@link com.microsoft.applicationinsights.telemetry.Telemetry} to initialize.
     */

#Code:
    @Override
    protected void onInitializeTelemetry(Telemetry telemetry) {
        RequestTelemetryContext telemetryContext = ThreadContext.getRequestTelemetryContext();
        String operationName = telemetryContext.getHttpRequestTelemetry().getName();

        updateRequestNameIfRequestTelemetry(telemetry, operationName);

        telemetry.getContext().getOperation().setName(operationName);
    }


#end
#end
#No. 183774
#File: E:\bishe\1\WebPageExtractionHelper.java
#Comment:
	/**
	 * Try to find a likely chord chard from the "pre" section of a page
	 * Returns null if it doesn't find anything likely to be a chord chart
	 * @param html
	 * @return
	 */

#Code:
	public static String extractLikelyChordChart(String html, NoteNaming noteNaming) {
		
		Matcher matcher = prePattern.matcher(html);
		
		while (matcher.find()) {
			String preHtml = matcher.group(1);
			String preTxt = convertHtmlToText(preHtml);
			if (ChordParser.containsLineWithChords(preTxt, noteNaming)) {
				return cleanUpText(preTxt);
			}
		}
		return null;
		
	}

#end
#end
#No. 183776
#File: E:\bishe\1\WebPageImpl.java
#Comment:
	/**
	 * Get a new Infobox but do not add it to the page. Can be used for putting Infoboxes inside Infoboxes.
	 * @param title The title of the desired Infobox
	 * @return the contentNode of the newly created Infobox
	 */

#Code:
	protected final HTMLNode getContentBox(String title) {
		InfoboxNode infobox = mPM.getInfobox(title);
		return infobox.outer;
	}

#end
#end
#No. 183777
#File: E:\bishe\1\WebPageImpl.java
#Comment:
	/**
	 * @param name The name of the input-element of the combo box.
	 * @param entries The entries of the combo box. The key of an entry in the map is the text which is displayed in the combo box to the user,
	 * 					the value of on entry is the value which is passed over http if the user submits the form with that entry selected.
	 * @param defaultValue The value (= the value of the map entry) of the entry which should be selected by default
	 */

#Code:
	protected static HTMLNode getComboBox(String name, SortedMap<String, String> entries, String defaultValue) {
		HTMLNode result = new HTMLNode("select", "name", name);
		
		for(Entry<String, String> entry : entries.entrySet()) {
			if(entry.getValue().equals(defaultValue)) {
				result.addChild("option", 
						new String[] { "value", "selected" }, 
						new String[] { entry.getValue(), "selected" },
						entry.getKey());
			} else {
				result.addChild("option", "value", entry.getValue(), entry.getKey());
			}
		}
		
		return result;
	}

#end
#end
#No. 183778
#File: E:\bishe\1\WebpageOpener.java
#Comment:
	/**
	 * Takes an input URL and opens it in the device's default web browser
	 * 
	 * @param url
	 *            The URL to open on the device
	 */

#Code:
	public void openPage(Context context, String url) {
		try {
			// Make sure it starts with http:// or https://
			if (!url.startsWith("http://") && !url.startsWith("https://")) {
				url = "http://" + url;

			}
			Intent browserIntent = new Intent(Intent.ACTION_VIEW,
					Uri.parse(url));
			browserIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
			context.startActivity(browserIntent);
		}
		catch (ActivityNotFoundException e) {
		}
	}

#end
#end
#No. 183780
#File: E:\bishe\1\WebpageUtils.java
#Comment:
    /**
     * Checks if the flyver webpage files have been copied to sdcard/co.flyver/webpage/
     * Copies them if not
     * @param assetManager the asset manager associated with the application context
     */

#Code:
    public static void deployWebpage(AssetManager assetManager) {
        String path = getWebpageLocation();
        File webpageDir = new File(path);
        //TODO:: commented for debugging purposes, uncomment later
        if (!webpageDir.exists()) {
            webpageDir.mkdirs();
            copyWebpage(path, assetManager);
        }
    }

#end
#end
#No. 183781
#File: E:\bishe\1\WebpageUtils.java
#Comment:
    /**
     * Copies the files for the webpage from the assets dir, to the /co.flyver/webpage/ dir on the sdcard
     *
     * @param destinationPath
     */

#Code:
    private static void copyWebpage(String destinationPath, AssetManager assetManager) {
        String[] files = null;
        try {
            files = assetManager.list("webpage");
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (files != null) {
            for (String file : files) {
                InputStream inputStream;
                OutputStream outputStream;

                try {
                    inputStream = assetManager.open("webpage/" + file);
                    outputStream = new FileOutputStream(destinationPath.concat(file));
                    byte[] buffer = new byte[1024];
                    int read;
                    while ((read = inputStream.read(buffer)) != -1) {
                        outputStream.write(buffer, 0, read);
                    }
                    inputStream.close();
                    outputStream.flush();
                    outputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }



#end
#end
#No. 183784
#File: E:\bishe\1\WebpSupportStatus.java
#Comment:
    /**
     * Checks if imageHeaderBytes contains WEBP_RIFF_BYTES and WEBP_NAME_BYTES and if the
     * header is long enough to be WebP's header.
     * WebP file format can be found here:
     * <a href="https://developers.google.com/speed/webp/docs/riff_container">
     *   https://developers.google.com/speed/webp/docs/riff_container</a>
     * @param imageHeaderBytes image header bytes
     * @return true if imageHeaderBytes contains a valid webp header
     */

#Code:
    public static boolean isWebpHeader(
            final byte[] imageHeaderBytes,
            final int offset,
            final int headerSize) {
        return headerSize >= SIMPLE_WEBP_HEADER_LENGTH &&
                matchBytePattern(imageHeaderBytes, offset, WEBP_RIFF_BYTES) &&
                matchBytePattern(imageHeaderBytes, offset + 8, WEBP_NAME_BYTES);
    }


#end
#end
#No. 183787
#File: E:\bishe\1\WebRequestBase.java
#Comment:
    /** Default sign adapter
     * It will grab <code>sign_type</code> and <code>sign</code>
     */

#Code:
    public RequestBase sign(List<String> paramNames)
        throws UnsupportedEncodingException
    {
        String signType = this.getProperty(KEY_SIGN_TYPE);
        String charset = this.getProperty(KEY_CHARSET);
        String key = this.getProperty(KEY_KEY);

        String sign = this.sign(paramNames, signType, key, charset);

        this.setProperty(KEY_SIGN, sign);

        return(this);
    }

#end
#end
#No. 183788
#File: E:\bishe\1\WebRequestBase.java
#Comment:
    /** default url constructors
     */

#Code:
    protected String toUnsignedURL(List<String> paramNames, String charset)
        throws UnsupportedEncodingException
    {
        URLBuilder ub = new URLBuilder();

        ub.appendPath(URL_ALIPAY_GATEWAY);
        for (String key:paramNames)
            ub.appendParamEncode(key, this.getProperty(key), charset);

        return(ub.toString());
    }

#end
#end
#No. 183789
#File: E:\bishe\1\WebRequestContext.java
#Comment:
	/**
	 * @param requestUri
	 * @param servletExtension
	 */

#Code:
	private void parseFriendlyURL(String requestUri, String servletExtension) 
	{
		requestUri = requestUri.substring(0, requestUri.length() - servletExtension.length());
		String[] urlModel = requestUri.split("/");
		
		int moduleIndex = 1;
		int actionIndex = 2;
		int baseLen = 3;
		
		UrlPattern url = null;
		
		if (urlModel.length >= baseLen) {
			// <moduleName>.<actionName>.<numberOfParameters>
			StringBuffer sb = new StringBuffer(64)
				.append(urlModel[moduleIndex])
				.append('.')
				.append(urlModel[actionIndex])
				.append('.')
				.append(urlModel.length - baseLen);
			
			url = UrlPatternCollection.findPattern(sb.toString());
		}

		if (url != null) {
			if (url.getSize() >= urlModel.length - baseLen) {
				for (int i = 0; i < url.getSize(); i++) {
					this.addParameter(url.getVars()[i], urlModel[i + baseLen]);
				}
			}
			
			this.addOrReplaceParameter("module", urlModel[moduleIndex]);
			this.addParameter("action", urlModel[actionIndex]);
		}
		else {
			this.addOrReplaceParameter("module", null);
			this.addParameter("action", null);
		}
	}

#end
#end
#No. 183790
#File: E:\bishe\1\WebRequestContext.java
#Comment:
	/**
	 * @see javax.servlet.ServletRequestWrapper#getParameterValues(java.lang.String)
	 */

#Code:
	public String[] getParameterValues(String name) 
	{
		Object value = this.getObjectParameter(name);
		
		if (value instanceof String) {
			return new String[] { (String)value };
		}
		
		List l = (List)value;
		
		return l == null
			? super.getParameterValues(name)
			: (String[])l.toArray(new String[0]);
	}

#end
#end
#No. 183791
#File: E:\bishe\1\WebRequestContext.java
#Comment:
	/**
	 * @see javax.servlet.ServletRequest#getParameter(java.lang.String)
	 */

#Code:
	public String getParameter(String parameter) 
	{
		return (String)this.query.get(parameter);
	}

#end
#end
#No. 183792
#File: E:\bishe\1\WebRequestContext.java
#Comment:
	/**
	 * Gets an parameter that is a number.
	 * A call to <code>Integer#parseInt(String)</code> is made
	 * to do the conversion
	 * @param parameter The parameter name to get the value
	 * @return int
	 */

#Code:
	public int getIntParameter(String parameter)
	{
		return Integer.parseInt(this.getParameter(parameter));
	}

#end
#end
#No. 183793
#File: E:\bishe\1\WebRequestContext.java
#Comment:
	/**
	 * Gets some request parameter as <code>Object</code>.
	 * This method may be used when you have to get some value
	 * of a <i>multipart/form-data</i> request, like a image
	 * of file. <br>
	 * 
	 * @param parameter String
	 * @return Object
	 */

#Code:
	public Object getObjectParameter(String parameter)
	{
		return this.query.get(parameter);
	}

#end
#end
#No. 183794
#File: E:\bishe\1\WebRequestContext.java
#Comment:
	/**
	 * Gets the <i>action</i> of the current request.
	 * 
	 * An <i>Action</i> is the parameter name which specifies
	 * what next action should be done by the system. It may be
	 * add or edit a post, editing the groups, whatever. In the URL, the
	 * Action can the represented in two forms:
	 * <p>
	 * <blockquote>
	 * <code>
	 * http://www.host.com/webapp/servletName?module=groups&action=list
	 * </code>
	 * </blockquote>
	 * <p>
	 * or
	 * <p>
	 * <blockquote>
	 * <code>
	 * http://www.host.com/webapp/servletName/groups/list
	 * </code>
	 * </blockquote>
	 * <p>
	 * In both situations, the action's name is "list".
	 * 
	 * @return String representing the action name
	 */

#Code:
	public String getAction()
	{
		return this.getParameter("action");
	}

#end
#end
#No. 183795
#File: E:\bishe\1\WebRequestContext.java
#Comment:
	/**
	 * Gets the <i>module</i> of the current request.
	 * 
	 * A <i>Module</i> is the parameter name which specifies
	 * what module the user is requesting. It may be the group
	 * administration, the topics or anything else configured module.
	 *In the URL, the Module can the represented in two forms:
	 * <p>
	 * <blockquote>
	 * <code>
	 * http://www.host.com/webapp/servletName?module=groups&action=list
	 * </code>
	 * </blockquote>
	 * <p>
	 * or
	 * <p>
	 * <blockquote>
	 * <code>
	 * http://www.host.com/webapp/servletName/groups/list
	 * </code>
	 * </blockquote>
	 * <p>
	 * In both situations, the module's name is "groups".
	 * 
	 * @return String representing the module name
	 */

#Code:
	public String getModule()
	{
		return this.getParameter("module");
	}

#end
#end
#No. 183796
#File: E:\bishe\1\WebRequestContext.java
#Comment:
	/**
	 * @see javax.servlet.http.HttpServletRequestWrapper#getContextPath()
	 */

#Code:
	public String getContextPath() 
	{
		String contextPath = super.getContextPath();
		String proxiedContextPath = SystemGlobals.getValue(ConfigKeys.PROXIED_CONTEXT_PATH);
		
		if (!StringUtils.isEmpty(proxiedContextPath)) {
			contextPath = proxiedContextPath;
		}
		
		return contextPath;
	}

#end
#end
#No. 183797
#File: E:\bishe\1\WebRequestContext.java
#Comment:
	/**
	 * @see javax.servlet.ServletRequestWrapper#getRemoteAddr()
	 */

#Code:
	public String getRemoteAddr()
	{
		// We look if the request is forwarded
		// If it is not call the older function.
        String ip = super.getHeader("x-forwarded-for");
        
        if (ip == null) {
        	ip = super.getRemoteAddr();
        }
        else {
        	// Process the IP to keep the last IP (real ip of the computer on the net)
            StringTokenizer tokenizer = new StringTokenizer(ip, ",");

            // Ignore all tokens, except the last one
            for (int i = 0; i < tokenizer.countTokens() -1 ; i++) {
            	tokenizer.nextElement();
            }
            
            ip = tokenizer.nextToken().trim();
            
            if (ip.equals("")) {
            	ip = null;
            }
        }
        
        // If the ip is still null, we put 0.0.0.0 to avoid null values
        if (ip == null) {
        	ip = "0.0.0.0";
        }
        
        return ip;
	}


#end
#end
#No. 183799
#File: E:\bishe\1\WebRequestTrackingFilter.java
#Comment:
    /**
     * Processing the given request and response.
     * @param req The servlet request.
     * @param res The servlet response.
     * @param chain The filters chain
     * @throws IOException Exception that can be thrown from invoking the filters chain.
     * @throws ServletException Exception that can be thrown from invoking the filters chain.
     */

#Code:
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        ApplicationInsightsHttpResponseWrapper response = new ApplicationInsightsHttpResponseWrapper((HttpServletResponse)res);
        setKeyOnTLS(key);

        boolean isRequestProcessedSuccessfully = invokeSafeOnBeginRequest(req, response);

        try {
            chain.doFilter(req, response);
            invokeSafeOnEndRequest(req, response, isRequestProcessedSuccessfully);
        } catch (ServletException se) {
            onException(se, req, response,isRequestProcessedSuccessfully);
            throw se;
        } catch (IOException ioe) {
            onException(ioe, req, response, isRequestProcessedSuccessfully);
            throw ioe;
        } catch (RuntimeException re) {
            onException(re, req, response, isRequestProcessedSuccessfully);
            throw re;
        } finally {
            cleanup();
        }
    }

#end
#end
#No. 183800
#File: E:\bishe\1\WebRequestTrackingFilter.java
#Comment:
    /**
     * Initializes the filter from the given config.
     * @param config The filter configuration.
     */

#Code:
    public void init(FilterConfig config){
        try {
            initialize(config);

            TelemetryConfiguration configuration = TelemetryConfiguration.getActive();

            if (configuration == null) {
                InternalLogger.INSTANCE.error(
                        "Java SDK configuration cannot be null. Web request tracking filter will be disabled.");

                return;
            }

            telemetryClient = new TelemetryClient(configuration);
            webModulesContainer = new WebModulesContainer(configuration);
            isInitialized = true;
        } catch (Exception e) {
            String filterName = this.getClass().getSimpleName();
            InternalLogger.INSTANCE.info(
                    "Application Insights filter %s has been failed to initialized.\n" +
                            "Web request tracking filter will be disabled. Exception: %s", filterName, e.getMessage());
        }
    }

#end
#end
#No. 183801
#File: E:\bishe\1\WebRequestTrackingFilter.java
#Comment:
    /**
     * Destroy the filter by releases resources.
     */

#Code:
    public void destroy() {
        //add code to release any resource
    }

#end
#end
#No. 183802
#File: E:\bishe\1\WebRequestTrackingTelemetryModule.java
#Comment:
    /**
     * Begin request processing.
     * @param req The request to process
     * @param res The response to modify
     */

#Code:
    @Override
    public void onBeginRequest(ServletRequest req, ServletResponse res) {
        if (!isInitialized) {
            // Avoid logging to not spam the log. It is sufficient that the module initialization failure
            // has been logged.
            return;
        }

        try {
            RequestTelemetryContext context = ThreadContext.getRequestTelemetryContext();
            RequestTelemetry telemetry = context.getHttpRequestTelemetry();

            HttpServletRequest request = (HttpServletRequest) req;
            String method = request.getMethod();
            String rURI = request.getRequestURI();
            String scheme = request.getScheme();
            String host = request.getHeader("Host");
            String query = request.getQueryString();
            String userAgent = request.getHeader("User-Agent");

            telemetry.setHttpMethod(method);
            if (!CommonUtils.isNullOrEmpty(query)) {
                telemetry.setUrl(String.format("%s://%s%s?%s", scheme, host, rURI, query));
            }
            else {
                telemetry.setUrl(String.format("%s://%s%s", scheme, host, rURI));
            }

            // TODO: this is a very naive implementation, which doesn't take into account various MVC f/ws implementation.
            // Next step is to implement the smart request name calculation which will support the leading MVC f/ws.
            String rUriWithoutSessionId = removeSessionIdFromUri(rURI);
            telemetry.setName(String.format("%s %s", method, rUriWithoutSessionId));
            telemetry.getContext().getUser().setUserAgent(userAgent);
            telemetry.setTimestamp(new Date(context.getRequestStartTimeTicks()));
        } catch (Exception e) {
            String moduleClassName = this.getClass().getSimpleName();
            InternalLogger.INSTANCE.error("Telemetry module " + moduleClassName + " onBeginRequest failed with exception: %s", e.getMessage());
        }
    }

#end
#end
#No. 183803
#File: E:\bishe\1\WebRequestTrackingTelemetryModule.java
#Comment:
    /**
     * End request processing.
     * @param req The request to process
     * @param res The response to modify
     */

#Code:
    @Override
    public void onEndRequest(ServletRequest req, ServletResponse res) {
        if (!isInitialized) {
            // Avoid logging to not spam the log. It is sufficient that the module initialization failure
            // has been logged.
            return;
        }

        try {
            RequestTelemetryContext context = ThreadContext.getRequestTelemetryContext();
            RequestTelemetry telemetry = context.getHttpRequestTelemetry();

            long endTime = new Date().getTime();

            ApplicationInsightsHttpResponseWrapper response = ((ApplicationInsightsHttpResponseWrapper)res);
            if (response != null) {
                telemetry.setSuccess(response.getStatus() < 400 || response.getStatus() == 401 );
                telemetry.setResponseCode(Integer.toString(response.getStatus()));
            } else {
                InternalLogger.INSTANCE.error("Failed to get response status for request ID: %s", telemetry.getId());
            }

            telemetry.setDuration(new Duration(endTime - context.getRequestStartTimeTicks()));

            telemetryClient.track(telemetry);
        } catch (Exception e) {
            String moduleClassName = this.getClass().getSimpleName();
            InternalLogger.INSTANCE.error("Telemetry module " + moduleClassName + " onEndRequest failed with exception: %s", e.getMessage());
        }
    }

#end
#end
#No. 183804
#File: E:\bishe\1\WebRequestTrackingTelemetryModule.java
#Comment:
    /**
     * Initializes the telemetry module with the given telemetry configuration.
     * @param configuration The telemetry configuration.
     */

#Code:
    @Override
    public void initialize(TelemetryConfiguration configuration) {
        try {
            telemetryClient = new TelemetryClient(configuration);
            isInitialized = true;
        } catch (Exception e) {
            InternalLogger.INSTANCE.error(
                    "Failed to initialize telemetry module " + this.getClass().getSimpleName() + ". Exception: %s.", e.getMessage());
        }
    }

#end
#end
#No. 183805
#File: E:\bishe\1\WebRequestTrackingTelemetryModule.java
#Comment:
    /*
     * Servlets sometimes rewrite the request url to include a session id represented by ';jsessionid=<some_string>',
     * in order to cope with client which have cookies disabled.
     * We want to strip the url from any unique identifiers.
     */

#Code:
    private String removeSessionIdFromUri(String uri) {
        int separatorIndex = uri.indexOf(';');

        if (separatorIndex == -1) {
            return uri;
        }

        String urlWithoutSessionId = uri.substring(0, separatorIndex);

        return urlWithoutSessionId;
    }



#end
#end
#No. 183808
#File: E:\bishe\1\WebResourceCollectionMetaData.java
#Comment:
    /**
     * Get http methods in ALL_HTTP_METHODS not in the argument httpMethods.
     *
     * @param httpMethods a set of http method names
     * @return possibly empty http methods in ALL_HTTP_METHODS not in
     *         httpMethods.
     */

#Code:
    public static String[] getMissingHttpMethods(Collection<String> httpMethods) {
        String[] methods = {};
        if (httpMethods.size() > 0 && httpMethods.containsAll(ALL_HTTP_METHODS) == false) {
            HashSet<String> missingMethods = new HashSet<String>(ALL_HTTP_METHODS);
            missingMethods.removeAll(httpMethods);
            methods = new String[missingMethods.size()];
            missingMethods.toArray(methods);
        }
        return methods;
    }

#end
#end
#No. 183809
#File: E:\bishe\1\WebResourceFactory.java
#Comment:
    /**
     * Creates a new client-side representation of a resource described by
     * the interface passed in the first argument.
     *
     * @param <C>                Type of the resource to be created.
     * @param resourceInterface  Interface describing the resource to be created.
     * @param target             WebTarget pointing to the resource or the parent of the resource.
     * @param ignoreResourcePath If set to true, ignores path annotation on the resource interface (this is used when creating
     *                           sub-resources)
     * @param headers            Header params collected from parent resources (used when creating a sub-resource)
     * @param cookies            Cookie params collected from parent resources (used when creating a sub-resource)
     * @param form               Form params collected from parent resources (used when creating a sub-resource)
     * @param invoker            Method invoker
     * @return Instance of a class implementing the resource interface that can
     * be used for making requests to the server.
     */

#Code:
    @SuppressWarnings("unchecked")
    public static <C> C newResource(final Class<C> resourceInterface,
                                    final WebTarget target,
                                    final boolean ignoreResourcePath,
                                    final MultivaluedMap<String, Object> headers,
                                    final List<Cookie> cookies,
                                    final Form form,
                                    final ClientMethodInvoker invoker) {

        return (C) Proxy.newProxyInstance(AccessController.doPrivileged(ReflectionHelper.getClassLoaderPA(resourceInterface)),
                new Class[]{resourceInterface},
                new WebResourceFactory(ignoreResourcePath ? target : addPathFromAnnotation(resourceInterface, target),
                        headers, cookies, form, invoker));
    }

#end
#end
#No. 183810
#File: E:\bishe\1\WebResourceKind.java
#Comment:
/**
 * Web resource kind :
 * 
 * <ul>
 * <li>{@link #WebResourceKind#ECLIPSE_RESOURCE} : eclipse {@link IResource}. *
 * <li>{@link #WebResourceKind#FILESYSTEM} : file system {@link File}.
 * </ul>
 *
 */

#Code:
public enum WebResourceKind {

	ECLIPSE_RESOURCE, FILESYSTEM;
}

#end
#end
#No. 183811
#File: E:\bishe\1\WebResourceName.java
#Comment:
    /**
     * Gets the value of the id property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

#Code:
    public String getId() {
        return id;
    }

#end
#end
#No. 183812
#File: E:\bishe\1\WebResourceName.java
#Comment:
    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

#Code:
    public void setId(String value) {
        try {
            support.fireVetoableChange("Id",id, value);
        } catch (PropertyVetoException _x) {
            return;
        }
        this.id = value;
    }

#end
#end
#No. 183813
#File: E:\bishe\1\WebResourceName.java
#Comment:
    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

#Code:
    public String getvalue() {
        return value;
    }

#end
#end
#No. 183814
#File: E:\bishe\1\WebResourceName.java
#Comment:
    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

#Code:
    public void setvalue(String value) {
        try {
            support.fireVetoableChange("value",value, value);
        } catch (PropertyVetoException _x) {
            return;
        }
        this.value = value;
    }

#end
#end
#No. 183815
#File: E:\bishe\1\WebResourcesBrowserInformationControl.java
#Comment:
/**
 * Browser information control for Web Resources.
 *
 */

#Code:
public class WebResourcesBrowserInformationControl extends
		BrowserInformationControl {

	public WebResourcesBrowserInformationControl(Shell parent,
			String symbolicFontName, ToolBarManager toolBarManager) {
		super(parent, symbolicFontName, toolBarManager);
	}

	@Override
	public IInformationControlCreator getInformationPresenterControlCreator() {
		// Hack: We don't wan't to have auto-enrichment when the mouse moves
		// into the hover,
		// but we do want F2 to persist the hover. The framework has no way to
		// distinguish the
		// two requests, so we have to implement this aspect.
		for (StackTraceElement element : Thread.currentThread().getStackTrace()) {
			if ("canMoveIntoInformationControl".equals(element.getMethodName()) //$NON-NLS-1$
					&& "org.eclipse.jface.text.AbstractHoverInformationControlManager".equals(element.getClassName())) //$NON-NLS-1$
				return null; // do not enrich bracket hover
		}
		return super.getInformationPresenterControlCreator();
	}

}

#end
#end
#No. 183816
#File: E:\bishe\1\WebResourcesContext.java
#Comment:
	/**
	 * Constructor for web resources context.
	 * 
	 * @param htmlNode
	 *            the HTML node which have triggers this provider.
	 * @param resourceType
	 *            the resource type (css, js, img);
	 */

#Code:
	public WebResourcesContext(IDOMNode htmlNode,
			WebResourcesFinderType resourceType) {
		this(htmlNode, resourceType, false);
	}

#end
#end
#No. 183817
#File: E:\bishe\1\WebResourcesContext.java
#Comment:
	/**
	 * Constructor for web resources context.
	 * 
	 * @param htmlNode
	 *            the HTML node which have triggers this provider.
	 * @param resourceType
	 *            the resource type (css, js, img);
	 * @param hasExternalCSS
	 */

#Code:
	public WebResourcesContext(IDOMNode htmlNode,
			WebResourcesFinderType resourceType, boolean hasExternalCSS) {
		this.htmlNode = htmlNode;
		this.htmlFile = null;
		this.resourceType = resourceType;
		this.hasExternalCSS = hasExternalCSS;
	}

#end
#end
#No. 183818
#File: E:\bishe\1\WebResourcesFinderType.java
#Comment:
/**
 * Web resources finder type.
 *
 */

#Code:
public enum WebResourcesFinderType {

	CSS_ID(WebResourceType.css), CSS_CLASS_NAME(WebResourceType.css), SCRIPT_SRC(
			WebResourceType.js), LINK_HREF(WebResourceType.css), IMG_SRC(
			WebResourceType.img);

	private final WebResourceType type;

	private WebResourcesFinderType(WebResourceType type) {
		this.type = type;
	}

	public WebResourceType getType() {
		return type;
	}

	public static WebResourcesFinderType get(String value) {
		WebResourcesFinderType[] types = WebResourcesFinderType.values();
		WebResourcesFinderType type;
		for (int i = 0; i < types.length; i++) {
			type = types[i];
			if (type.name().equalsIgnoreCase(value)) {
				return type;
			}
		}
		return null;
	}

}

#end
#end
#No. 183819
#File: E:\bishe\1\WebResourcesMainPropertyPage.java
#Comment:
/**
 * Web resources Main page for project properties.
 * 
 */

#Code:
public class WebResourcesMainPropertyPage extends PropertyPage implements
		IWorkbenchPropertyPage {

	public WebResourcesMainPropertyPage() {
	}

	protected Control createContents(Composite parent) {
		Composite composite = new Composite(parent, SWT.NONE);
		composite.setLayoutData(new GridData(4, 4, true, true));
		composite.setLayout(new GridLayout());
		return composite;
	}

}

#end
#end
#No. 183820
#File: E:\bishe\1\WebResourcesSourceValidator.java
#Comment:
	/**
	 * This validate call is for the ISourceValidator partial document
	 * validation approach
	 * 
	 * @param dirtyRegion
	 * @param helper
	 * @param reporter
	 * @see org.eclipse.wst.sse.ui.internal.reconcile.validator.ISourceValidator
	 */

#Code:
	@Override
	public void validate(IRegion dirtyRegion, IValidationContext helper,
			IReporter reporter) {

		if (helper == null || fDocument == null)
			return;

		if ((reporter != null) && (reporter.isCancelled() == true)) {
			throw new OperationCanceledException();
		}

		IStructuredModel model = StructuredModelManager.getModelManager()
				.getExistingModelForRead(fDocument);
		if (model == null)
			return; // error

		try {

			IDOMDocument document = null;
			if (model instanceof IDOMModel) {
				document = ((IDOMModel) model).getDocument();
			}

			if (document == null /* || !hasHTMLFeature(document) */) {
				// handled in finally clause
				return; // ignore
			}

			if (fDocument instanceof IStructuredDocument) {
				IFile file = DOMHelper.getFile(model);
				IStructuredDocumentRegion[] regions = ((IStructuredDocument) fDocument)
						.getStructuredDocumentRegions(dirtyRegion.getOffset(),
								dirtyRegion.getLength());
				validateRegions(reporter, model, file, regions);
			}

		} finally {
			releaseModel(model);
		}
	}


#end
#end
#No. 183827
#File: E:\bishe\1\WebRtcChannel.java
#Comment:
/**
 * Type of channel in WebRTC communications (audio, video, or both).
 * 
 * @author Boni Garcia (bgarcia@gsyc.es)
 * @since 4.2.3
 */

#Code:
public enum WebRtcChannel {
	VIDEO_ONLY, AUDIO_ONLY, AUDIO_AND_VIDEO;

	public boolean getAudio() {
		switch (this) {
		case VIDEO_ONLY:
			return false;
		case AUDIO_ONLY:
			return true;
		case AUDIO_AND_VIDEO:
		default:
			return true;
		}
	}

	public boolean getVideo() {
		switch (this) {
		case VIDEO_ONLY:
			return true;
		case AUDIO_ONLY:
			return false;
		case AUDIO_AND_VIDEO:
		default:
			return true;
		}
	}
}



#end
#end
#No. 183830
#File: E:\bishe\1\WebRtcDataStreamListener.java
#Comment:
    /**
     * Fired when new WebRTC data channel is opened.
     *
     * @param channel the <tt>WebRtcDataStream</tt> that represents opened
     * WebRTC data channel.
     */

#Code:
    public void onChannelOpened(
            WebRtcDataStream channel);
}
}

#end
#end
#No. 183832
#File: E:\bishe\1\WebScarabWrapper.java
#Comment:
	/**
	 * Disables logging to the console normally done by WebScarab.
	 */

#Code:
	private void disableConsoleLogging() {
		Logger l = Logger.getLogger("org.owasp.webscarab.plugin.Framework");
		l.setLevel(Level.OFF);
		l = Logger.getLogger("org.owasp.webscarab.httpclient.URLFetcher");
		l.setLevel(Level.OFF);
		l = Logger.getLogger("org.owasp.webscarab.plugin.proxy.Listener");
		l.setLevel(Level.OFF);

		/* disable all logging */
		l = Logger.getLogger("");
		l.setLevel(Level.OFF);
	}

#end
#end
#No. 183833
#File: E:\bishe\1\WebScarabWrapper.java
#Comment:
	/**
	 * Start the HTTP proxy on the specified port. Also starts the request buffer plugin.
	 * 
	 * @param config
	 *            ProxyConfiguration object.
	 * @throws IOException
	 *             When error reading writing.
	 * @throws StoreException
	 *             When error storing preference.
	 */

#Code:
	private void startProxy(ProxyConfiguration config) throws IOException, StoreException {
		disableConsoleLogging();

		Framework framework = new Framework();

		/* set listening port before creating the object to avoid warnings */
		Preferences.setPreference("Proxy.listeners", "127.0.0.1:" + config.getPort());

		this.proxy = new Proxy(framework);

		/* add the plugins to the proxy */
		for (ProxyPlugin p : plugins) {
			proxy.addPlugin(p);
		}

		framework.setSession("BlackHole", null, "");

		/* start the proxy */
		this.proxy.run();
	}

#end
#end
#No. 183834
#File: E:\bishe\1\WebScarabWrapper.java
#Comment:
	/**
	 * Add a plugin to the proxy. IMPORTANT: call this before the proxy is actually started.
	 * 
	 * @param plugin
	 *            The plugin to add.
	 */

#Code:
	public void addPlugin(ProxyPlugin plugin) {
		plugins.add(plugin);
	}

#end
#end
#No. 183835
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets templateid.
     *
     * @return Value of templateid.
     */

#Code:
    public Integer getTemplateid() {
        return templateid;
    }

#end
#end
#No. 183836
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new templateid.
     *
     * @param templateid New value of templateid.
     */

#Code:
    public void setTemplateid(Integer templateid) {
        this.templateid = templateid;
    }

#end
#end
#No. 183837
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets http_user.
     *
     * @return Value of http_user.
     */

#Code:
    public String getHttp_user() {
        return http_user;
    }

#end
#end
#No. 183838
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new http_user.
     *
     * @param http_user New value of http_user.
     */

#Code:
    public void setHttp_user(String http_user) {
        this.http_user = http_user;
    }

#end
#end
#No. 183839
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets status.
     *
     * @return Value of status.
     */

#Code:
    public Integer getStatus() {
        return status;
    }

#end
#end
#No. 183840
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new status.
     *
     * @param status New value of status.
     */

#Code:
    public void setStatus(Integer status) {
        this.status = status;
    }

#end
#end
#No. 183841
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets variables.
     *
     * @return Value of variables.
     */

#Code:
    public String getVariables() {
        return variables;
    }

#end
#end
#No. 183842
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new variables.
     *
     * @param variables New value of variables.
     */

#Code:
    public void setVariables(String variables) {
        this.variables = variables;
    }

#end
#end
#No. 183843
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets name.
     *
     * @return Value of name.
     */

#Code:
    public String getName() {
        return name;
    }

#end
#end
#No. 183844
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new name.
     *
     * @param name New value of name.
     */

#Code:
    public void setName(String name) {
        this.name = name;
    }

#end
#end
#No. 183845
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets hostid.
     *
     * @return Value of hostid.
     */

#Code:
    public Integer getHostid() {
        return hostid;
    }

#end
#end
#No. 183846
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new hostid.
     *
     * @param hostid New value of hostid.
     */

#Code:
    public void setHostid(Integer hostid) {
        this.hostid = hostid;
    }

#end
#end
#No. 183847
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets retries.
     *
     * @return Value of retries.
     */

#Code:
    public Integer getRetries() {
        return retries;
    }

#end
#end
#No. 183848
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new retries.
     *
     * @param retries New value of retries.
     */

#Code:
    public void setRetries(Integer retries) {
        this.retries = retries;
    }

#end
#end
#No. 183849
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets delay.
     *
     * @return Value of delay.
     */

#Code:
    public Integer getDelay() {
        return delay;
    }

#end
#end
#No. 183850
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new delay.
     *
     * @param delay New value of delay.
     */

#Code:
    public void setDelay(Integer delay) {
        this.delay = delay;
    }

#end
#end
#No. 183851
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets applicationid.
     *
     * @return Value of applicationid.
     */

#Code:
    public Integer getApplicationid() {
        return applicationid;
    }

#end
#end
#No. 183852
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new applicationid.
     *
     * @param applicationid New value of applicationid.
     */

#Code:
    public void setApplicationid(Integer applicationid) {
        this.applicationid = applicationid;
    }

#end
#end
#No. 183853
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets httptestid.
     *
     * @return Value of httptestid.
     */

#Code:
    public Integer getHttptestid() {
        return httptestid;
    }

#end
#end
#No. 183854
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new httptestid.
     *
     * @param httptestid New value of httptestid.
     */

#Code:
    public void setHttptestid(Integer httptestid) {
        this.httptestid = httptestid;
    }

#end
#end
#No. 183855
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets authentication.
     *
     * @return Value of authentication.
     */

#Code:
    public Integer getAuthentication() {
        return authentication;
    }

#end
#end
#No. 183856
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new authentication.
     *
     * @param authentication New value of authentication.
     */

#Code:
    public void setAuthentication(Integer authentication) {
        this.authentication = authentication;
    }

#end
#end
#No. 183857
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets http_proxy.
     *
     * @return Value of http_proxy.
     */

#Code:
    public String getHttp_proxy() {
        return http_proxy;
    }

#end
#end
#No. 183858
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new http_proxy.
     *
     * @param http_proxy New value of http_proxy.
     */

#Code:
    public void setHttp_proxy(String http_proxy) {
        this.http_proxy = http_proxy;
    }

#end
#end
#No. 183859
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets http_password.
     *
     * @return Value of http_password.
     */

#Code:
    public String getHttp_password() {
        return http_password;
    }

#end
#end
#No. 183860
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new http_password.
     *
     * @param http_password New value of http_password.
     */

#Code:
    public void setHttp_password(String http_password) {
        this.http_password = http_password;
    }

#end
#end
#No. 183861
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets nextcheck.
     *
     * @return Value of nextcheck.
     */

#Code:
    public Long getNextcheck() {
        return nextcheck;
    }

#end
#end
#No. 183862
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new nextcheck.
     *
     * @param nextcheck New value of nextcheck.
     */

#Code:
    public void setNextcheck(Long nextcheck) {
        this.nextcheck = nextcheck;
    }

#end
#end
#No. 183863
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Gets agent.
     *
     * @return Value of agent.
     */

#Code:
    public String getAgent() {
        return agent;
    }

#end
#end
#No. 183864
#File: E:\bishe\1\WebScenarioObject.java
#Comment:
    /**
     * Sets new agent.
     *
     * @param agent New value of agent.
     */

#Code:
    public void setAgent(String agent) {
        this.agent = agent;
    }


#end
#end
#No. 183870
#File: E:\bishe\1\WebSensor.java
#Comment:
  /**
   * Create PageScanner with Visitors.
   */

#Code:
  private HtmlAstScanner setupScanner(SensorContext context) {
    HtmlAstScanner scanner = new HtmlAstScanner(ImmutableList.of(
      new WebTokensVisitor(context),
      new PageCountLines(),
      new ComplexityVisitor(),
      new NoSonarScanner(noSonarFilter)));

    for (Object check : checks.all()) {
      ((AbstractPageCheck) check).setRuleKey(checks.ruleKey(check));
      scanner.addVisitor((AbstractPageCheck) check);
    }
    return scanner;
  }

#end
#end
#No. 183871
#File: E:\bishe\1\WebSensorTest.java
#Comment:
  /**
   * Unit test which is more kind of an integration test. The purpose of this test is to get early feedback on changes in
   * the number of issues.
   */

#Code:
  @Test
  public void testSensor() throws Exception {
    DefaultInputFile inputFile = new DefaultInputFile("key", "user-properties.jsp")
      .setLanguage(WebConstants.LANGUAGE_KEY)
      .setType(InputFile.Type.MAIN)
      .initMetadata(new FileMetadata().readMetadata(new FileReader(new File(TEST_DIR, "user-properties.jsp"))));

    tester.fileSystem().add(inputFile);

    sensor.execute(tester);

    String componentKey = inputFile.key();
    assertThat(tester.measure(componentKey, CoreMetrics.NCLOC).value()).isEqualTo(227);
    assertThat(tester.measure(componentKey, CoreMetrics.COMMENT_LINES).value()).isEqualTo(14);
    assertThat(tester.measure(componentKey, CoreMetrics.COMPLEXITY).value()).isEqualTo(1);

    assertThat(tester.cpdTokens(componentKey)).hasSize(224);

    assertThat(tester.highlightingTypeAt(componentKey, 1, 0)).containsOnly(TypeOfText.COMMENT);
    assertThat(tester.highlightingTypeAt(componentKey, 18, 0)).containsOnly(TypeOfText.COMMENT);
    assertThat(tester.highlightingTypeAt(componentKey, 19, 0)).containsOnly(TypeOfText.ANNOTATION);
    assertThat(tester.highlightingTypeAt(componentKey, 29, 17)).containsOnly(TypeOfText.STRING);
    assertThat(tester.highlightingTypeAt(componentKey, 29, 0)).containsOnly(TypeOfText.KEYWORD);

    assertThat(tester.allIssues()).hasSize(84);
  }

#end
#end
#No. 183873
#File: E:\bishe\1\WebService.java
#Comment:
	/**
	 * Debug Mode is disabled by default. This method can be used to enable Debug Mode, and print useful data such as the API url to the console.
	 * @param debug
	 */

#Code:
	public void setDebug( boolean debug )
	{
		this.DEBUG = debug;
	}

#end
#end
#No. 183874
#File: E:\bishe\1\WebServiceResponse.java
#Comment:
    /**
     * @return Returns the content.
     */

#Code:
    public byte[] getContent()
    {
        if (content == null) 
        	return "<NOOP/>".getBytes();
        return content;
    }

#end
#end
#No. 183875
#File: E:\bishe\1\WebServiceResponse.java
#Comment:
    /**
     * @param content The content to set.
     */

#Code:
    public void setContent(byte[] content)
    {
        this.content = content;
    }

#end
#end
#No. 183876
#File: E:\bishe\1\WebServiceTracker.java
#Comment:
/**
 * A simple BTrace program that prints a class name
 * and method name whenever a webservice is called and
 * also prints time taken by service method. WebService 
 * entry points are annotated javax.jws.WebService and 
 * javax.jws.WebMethod. We insert tracing actions into 
 * every class and method annotated by these annotations. 
 * This way we don't need to know actual webservice 
 * implementor class name.
 */

#Code:
@BTrace public class WebServiceTracker {
   @OnMethod(
     clazz="@javax.jws.WebService", 
     method="@javax.jws.WebMethod"
   )   
   public static void onWebserviceEntry(@ProbeClassName String pcn, @ProbeMethodName String pmn) {
       print("entering webservice ");
       println(pcn + "." + pmn);
   }

   @OnMethod(
     clazz="@javax.jws.WebService", 
     method="@javax.jws.WebMethod",
     location=@Location(Kind.RETURN)
   )   
   public static void onWebserviceReturn(@ProbeClassName String pcn , @ProbeMethodName String pmn, @Duration long d) {
       print("leaving web service ");
       println(pcn + "." + pmn);
       println("Time taken (msec) " + str(d / 1000));
       println("==========================");
   }

}
}

#end
#end
#No. 183877
#File: E:\bishe\1\WebSessionTelemetryInitializer.java
#Comment:
    /**
     * Initializes the properties of the given telemetry.
     *
     * @param telemetry The {@link com.microsoft.applicationinsights.telemetry.Telemetry} to initialize.
     */

#Code:
    @Override
    protected void onInitializeTelemetry(Telemetry telemetry) {
        SessionContext session = telemetry.getContext().getSession();

        if (!CommonUtils.isNullOrEmpty(session.getId())) {
            return;
        }

        RequestTelemetry requestTelemetry = ThreadContext.getRequestTelemetryContext().getHttpRequestTelemetry();
        SessionContext requestSessionContext = requestTelemetry.getContext().getSession();
        if (requestSessionContext == null) {
            return;
        }

        session.setId(requestSessionContext.getId());

        Boolean isFirst = requestSessionContext.getIsFirst();
        session.setIsFirst(isFirst != null ? isFirst : false);
    }

#end
#end
#No. 183878
#File: E:\bishe\1\WebSessionTrackingTelemetryModule.java
#Comment:
    /**
     * Initializes the telemetry module.
     *
     * @param configuration The configuration to used to initialize the module.
     */

#Code:
    @Override
    public void initialize(TelemetryConfiguration configuration) {
    }

#end
#end
#No. 183879
#File: E:\bishe\1\WebSessionTrackingTelemetryModule.java
#Comment:
    /**
     * Begin request processing.
     *
     * @param req The request to process
     * @param res The response to modify
     */

#Code:
    @Override
    public void onBeginRequest(ServletRequest req, ServletResponse res) {
        HttpServletRequest request = (HttpServletRequest)req;
        RequestTelemetryContext context = ThreadContext.getRequestTelemetryContext();

        SessionCookie sessionCookie =
                com.microsoft.applicationinsights.web.internal.cookies.Cookie.getCookie(
                        SessionCookie.class, request, SessionCookie.COOKIE_NAME);

        if (sessionCookie == null) {
            return;
        }

        context.setSessionCookie(sessionCookie);

        String sessionId = sessionCookie.getSessionId();
        getTelemetrySessionContext(context).setId(sessionId);
    }

#end
#end
#No. 183880
#File: E:\bishe\1\WebSessionTrackingTelemetryModule.java
#Comment:
    /**
     * End request processing.
     * This method checks if the session cookie should be updated before sent back to the client.
     * The session cookie is updated when the session is new or current session already expired.
     *
     * @param req The request to process
     * @param res The response to modify
     */

#Code:
    @Override
    public void onEndRequest(ServletRequest req, ServletResponse res) {
    }

#end
#end
#No. 183881
#File: E:\bishe\1\WebsiteChooserFragment.java
#Comment:
    /**
     * Set the adapter data by copying the given data to a new object and removing already added website.
     * It will also sort the list by the most liked website first
     *
     * @param websites data to display
     */

#Code:
    private void setAdapterData(List<Website> websites) {
        List<Website> websites1 = new ArrayList<>();
        websites1.addAll(websites);
        if (!websites1.isEmpty()) {
            if (!TextUtils.isEmpty(mMode) && !mMode.equals(BUNDLE_MODE_RESTORE)) {
                // We want to add some websites : remove duplicates or already added ones
                List<Website> savedWebsites = SpStorage.getWebsites(getActivity());

                // We cannot iterate on a list and remove item at the same time, need an array
                for (Website website : websites1.toArray(new Website[websites1.size()])) {
                    if (savedWebsites.contains(website)) {
                        websites1.remove(website);
                    }
                }
            }

            Collections.sort(websites1, new Comparator<Website>() {
                @Override
                public int compare(Website website, Website website2) {
                    if (website.like > website2.like) {
                        return -1;
                    } else if (website.like < website2.like) {
                        return 1;
                    }
                    return 0;
                }
            });

            mAdapter.setData(websites1);
        }
    }

#end
#end
#No. 183887
#File: E:\bishe\1\WebsiteOpen.java
#Comment:
/**
 * Opens the given website in the default browser.
 *
 * @author Andreas Wenger
 */

#Code:
@AllArgsConstructor
public class WebsiteOpen
	extends TransparentCommand {
	
	private String uri;

	/**
	 * Execute or redo the command.
	 */
	@Override public void execute() {
		try {
			if (false == uri.contains("://"))
				uri = "http://" + uri;
			Desktop.getDesktop().browse(new URI(uri));
		} catch (Exception ex) {
			log(warning("Could not open URI: " + uri + " (" + ex.getMessage() + ")"));
		}
	}

#end
#end
#No. 183888
#File: E:\bishe\1\WebsitePage.java
#Comment:
    /**
     * Validate inner data to prevent usage when using it
     */

#Code:
    public void validate() {
        if(TextUtils.isEmpty(slug)){
            slug = "local-" + name;
        }
        if(content == null){
            content = new Content();
        }
    }

#end
#end
#No. 183892
#File: E:\bishe\1\WebSocketChannel.java
#Comment:
    /**
     * The number of bytes queued to be sent
     */

#Code:
    public int getBufferedAmount() {
        return this.bufferedAmount;
    }

#end
#end
#No. 183893
#File: E:\bishe\1\WebSocketConnection.java
#Comment:
   /**
    * Reconnect to the server with the latest options 
    * @return true if reconnection performed
    */

#Code:
   public boolean reconnect() {
	   if (!isConnected() && (mWsUri != null)) {
		   new WebSocketConnector().start();
		   return true;
	   }
	   return false;
   }

#end
#end
#No. 183894
#File: E:\bishe\1\WebSocketConnection.java
#Comment:
   /**
    * Perform reconnection
    * 
    * @return true if reconnection was scheduled
    */

#Code:
   protected boolean scheduleReconnect() {
	   /**
	    * Reconnect only if:
	    *  - connection active (connected but not disconnected)
	    *  - has previous success connections
	    *  - reconnect interval is set
	    */
	   int interval = mOptions.getReconnectInterval();
	   boolean need = mActive && mPrevConnected && (interval > 0);
	   if (need) {
		   if (DEBUG) Log.d(TAG, "Reconnection scheduled");
		   mMasterHandler.postDelayed(new Runnable() {
			
			public void run() {
				if (DEBUG) Log.d(TAG, "Reconnecting...");
				reconnect();
			}
		}, interval);
	   }
	   return need;
   }

#end
#end
#No. 183895
#File: E:\bishe\1\WebSocketConnection.java
#Comment:
   /**
    * Common close handler
    * 
    * @param code       Close code.
	* @param reason     Close reason (human-readable).
    */

#Code:
   private void onClose(int code, String reason) {
	   boolean reconnecting = false;
	   
	   if ((code == ConnectionHandler.CLOSE_CANNOT_CONNECT) ||
			   (code == ConnectionHandler.CLOSE_CONNECTION_LOST)) {
		   reconnecting = scheduleReconnect();
	   }
	   
	   
	   if (mWsHandler != null) {
		   try {
			   if (reconnecting) {
				   mWsHandler.onClose(ConnectionHandler.CLOSE_RECONNECT, reason);
			   } else {
				   mWsHandler.onClose(code, reason);
			   }
		   } catch (Exception e) {
			   if (DEBUG) e.printStackTrace();
		   }
		   //mWsHandler = null;
	   } else {
		   if (DEBUG) Log.d(TAG, "mWsHandler already NULL");
	   }
   }

#end
#end
#No. 183896
#File: E:\bishe\1\WebSocketConnection.java
#Comment:
   /**
    * Create WebSockets background writer.
    */

#Code:
   protected void createWriter() {

      mWriterThread = new HandlerThread("WebSocketWriter");
      mWriterThread.start();
      mWriter = new WebSocketWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mOptions);

      if (DEBUG) Log.d(TAG, "WS writer created and started");
   }

#end
#end
#No. 183897
#File: E:\bishe\1\WebSocketConnection.java
#Comment:
   /**
    * Create WebSockets background reader.
    */

#Code:
   protected void createReader() {

      mReader = new WebSocketReader(mMasterHandler, mTransportChannel, mOptions, "WebSocketReader");
      mReader.start();

      if (DEBUG) Log.d(TAG, "WS reader created and started");
   }


#end
#end
#No. 183902
#File: E:\bishe\1\WebSocketController.java
#Comment:
	/**
	 * Opens a websocket for the given user nation and their current home region.
	 * 
	 * @param user nation that is opening the websocket.
	 * @param userRegion name of the region the user currently resides in.
	 * @param reconnect whether this is the first time opening the websocket, or a reconnection attempt.
	 * 
	 * @return websocket
	 */

#Code:
	public WebSocket<JsonNode> index(String user, String userRegion, boolean reconnect) {
		if (user.isEmpty() || userRegion.isEmpty()) return null;
		return new NationStatesWebSocket(this.getDatabase(), new DefaultPage(), sanitizeName(user), sanitizeName(userRegion), reconnect);
	}

#end
#end
#No. 183903
#File: E:\bishe\1\WebSocketController.java
#Comment:
	/**
	 * Opens a websocket for the given user nation and their current home region, when a user is viewing a region page (which may or may not be their own).
	 * 
	 * @param nation nation that is opening the websocket.
	 * @param userRegion name of the region the user currently resides in.
	 * @param region the name of the region that the user currently is looking at.
	 * @param reconnect whether this is the first time opening the websocket, or a reconnection attempt.
	 * 
	 * @return websocket
	 */

#Code:
	public WebSocket<JsonNode> region(String nation, String userRegion, String region, boolean reconnect) {
		if (nation.isEmpty() || userRegion.isEmpty() || region.isEmpty()) return null;
		region = sanitizeName(region);
		return new NationStatesWebSocket(this.getDatabase(), new RegionPage(region, getDatabase().getRegionId(region)), sanitizeName(nation), sanitizeName(userRegion), reconnect);
	}

#end
#end
#No. 183904
#File: E:\bishe\1\WebSocketController.java
#Comment:
	/**
	 * Opens a websocket for the given user nation and their current home region, when a user is viewing a nation page (which may or may not be their own).
	 * 
	 * @param nation nation that is opening the websocket.
	 * @param userRegion name of the region the user currently resides in.
	 * @param visibleNation the name of the nation that the user currently is looking at.
	 * @param reconnect whether this is the first time opening the websocket, or a reconnection attempt.
	 * 
	 * @return websocket
	 */

#Code:
	public WebSocket<JsonNode> nation(String nation, String userRegion, String visibleNation, boolean reconnect) {
		if (nation.isEmpty() || userRegion.isEmpty() || visibleNation.isEmpty()) return null;
		visibleNation = sanitizeName(visibleNation);
		return new NationStatesWebSocket(this.getDatabase(), new NationPage(visibleNation, getDatabase().getNationId(visibleNation)), sanitizeName(nation), sanitizeName(userRegion), reconnect);
	}

#end
#end
#No. 183905
#File: E:\bishe\1\WebSocketController.java
#Comment:
	/**
	 * Opens a websocket for the given user nation and their current home region, and the region they are viewing the regional controls page for.
	 * 
	 * @param nation nation that is opening the websocket.
	 * @param userRegion name of the region the user currently resides in.
	 * @param adminRegion the name of the region that the user currently is looking at in the regional controls.
	 * @param reconnect whether this is the first time opening the websocket, or a reconnection attempt.
	 * 
	 * @return websocket
	 */

#Code:
	public WebSocket<JsonNode> recruitmentAdmin(String nation, String userRegion, String adminRegion, boolean reconnect) {
		if (nation.isEmpty() || userRegion.isEmpty() || adminRegion.isEmpty()) return null;
		return new NationStatesWebSocket(this.getDatabase(), new RecruitmentAdministrationPage(adminRegion, getDatabase().getRegionId(adminRegion)), sanitizeName(nation), sanitizeName(userRegion), reconnect);
	}

#end
#end
#No. 183906
#File: E:\bishe\1\WebSocketDebugSessionsBridgeServlet.java
#Comment:
	/**
	 * On message received handler
	 *
	 * @param message
	 * @param session
	 */

#Code:
	@OnMessage
	public void onMessage(String message, Session session) {
		callInternal("onMessage", session, message);
	}

#end
#end
#No. 183907
#File: E:\bishe\1\WebSocketDebugSessionsBridgeServlet.java
#Comment:
	/**
	 * On error raised handler
	 *
	 * @param session
	 * @param t
	 */

#Code:
	@OnError
	public void onError(Session session, Throwable t) {
		callInternal("onError", session, t.getMessage());
		logger.error(t.getMessage(), t);
	}



#end
#end
#No. 183910
#File: E:\bishe\1\WebSocketDelegateImpl.java
#Comment:
    /**
     * WebSocket Java API for use in Java Web Start applications
     * 
     * @param url
     *            WebSocket URL location
     * @param origin
     *            the codebase+hostname from the JNLP of the Java Web Start app
     * @param protocol
     *            WebSocket protocol
     * @throws Exception
     */

#Code:
    public WebSocketDelegateImpl(URI url, URI origin, String[] protocols, long connectTimeout) {
        LOG.entering(CLASS_NAME, "<init>", new Object[] {url, origin, protocols});
        if (origin == null) {
            throw new IllegalArgumentException("Please specify the origin for the WebSocket connection");
        }

        if (url == null) {
            throw new IllegalArgumentException("Please specify the target for the WebSocket connection");
        }
        this.url = url;

        if ((origin.getScheme() == null) || (origin.getHost() == null)) {
            this.origin = "null";
        }
        else {
            String originScheme = origin.getScheme();
            String originHost = origin.getHost();
            int originPort = origin.getPort();
            if (originPort == -1) {
                originPort = (originScheme.equals("https")) ? 443 : 80;
            }
            this.origin = originScheme + "://" + originHost + ":" + originPort;
        }

        this.requestedProtocols = protocols;
        secure = url.getScheme().equalsIgnoreCase("wss");
        this.connectTimeout = connectTimeout;
    }

#end
#end
#No. 183911
#File: E:\bishe\1\WebSocketDelegateImpl.java
#Comment:
        /**
         * Compute the Sec-WebSocket-Accept key (RFC-6455)
         * 
         * @param key
         * @return
         * @throws NoSuchAlgorithmException 
         * @throws Exception
         */

#Code:
        public String AcceptHash(String key) throws NoSuchAlgorithmException {
            String input = key + WEBSOCKET_GUID;
            
            MessageDigest sha1 = MessageDigest.getInstance("SHA-1");

            byte[] hash = sha1.digest(input.getBytes());;
            return Base64Util.encode(ByteBuffer.wrap(hash));
        }

#end
#end
#No. 183912
#File: E:\bishe\1\WebSocketDelegateTest.java
#Comment:
        /**
         * Create a new StringPrefixMatcher matching prefix specified
         * @param prefix prefix to match
         */

#Code:
        public StringPrefixMatcher(String prefix) {
            this.prefix = prefix;
        }

#end
#end
#No. 183913
#File: E:\bishe\1\WebSocketDelegateTest.java
#Comment:
        /**
         * Create a new URLPrefixMatcher matching prefix specified
         * @param prefix prefix to match
         */

#Code:
        public URLPrefixMatcher(String prefix) {
            this.prefix = prefix;
        }

#end
#end
#No. 183914
#File: E:\bishe\1\WebSocketEmulatedDecoderImpl.java
#Comment:
    /*
     * Processing state machine
     */

#Code:
    enum DecodingState {
        START_OF_FRAME,
        READING_TEXT_FRAME,
        READING_COMMAND_FRAME,
        READING_BINARY_FRAME_HEADER,
        READING_BINARY_FRAME,
        READING_PING_FRAME
    };


#end
#end
#No. 183916
#File: E:\bishe\1\WebsocketEndpointHandlerDefault.java
#Comment:
    /**
     * Creates a peer specific manager from the endpoint manager.
     */

#Code:
    protected WebsocketPeerManager createWebsocketPeerManager(final String peerId) {

        final WebsocketEndpointManager endpointManager = getEndpointManager();

        return new WebsocketPeerManager() {

            @Override
            public void sendMessage(String message) {
                endpointManager.sendMessage(peerId, message);
            }

            @Override
            public void sendMessage(byte[] bytes) {
                endpointManager.sendMessage(peerId, bytes);
            }

            @Override
            public void closeConnection() {

                try {
                    endpointManager.closePeer(peerId);
                } finally {
                    // Clears cache
                    getPeerContextesMap().remove(peerId);
                }
            }
        };
    }


#end
#end
#No. 183918
#File: E:\bishe\1\WebSocketError.java
#Comment:
/**
 * Enum for possible errors in the proxy
 * <p>
 * Enum has error code and description of the error.
 * </p>
 */

#Code:
public enum WebSocketError {

    FailedToCreateProducer(1, "Failed to create producer"), //
    FailedToSubscribe(2, "Failed to subscribe"), //
    FailedToDeserializeFromJSON(3, "Failed to de-serialize from JSON"), //
    FailedToSerializeToJSON(4, "Failed to serialize to JSON"), //
    AuthenticationError(5, "Failed to authenticate client"), //
    NotAuthorizedError(6, "Client is not authorized"), //
    PayloadEncodingError(7, "Invalid payload encoding"), //
    UnknownError(8, "Unknown error"); //

    private final int code;
    private final String description;

    public String getDescription() {
        return description;
    }

    private WebSocketError(int code, String description) {
        this.code = code;
        this.description = description;
    }

    public int getCode() {
        return code;
    }

    @Override
    public String toString() {
        return description;
    }
}

#end
#end
#No. 183919
#File: E:\bishe\1\WebSocketEvent.java
#Comment:
/**
 * WebSocket event enumeration.
 * 
 * @author Paul Gregoire
 */

#Code:
public enum WebSocketEvent {

    SCOPE_CREATED, SCOPE_ADDED, SCOPE_REMOVED;

}

#end
#end
#No. 183920
#File: E:\bishe\1\WebSocketExtensionFactory.java
#Comment:
    /**
     * Creates and returns {@link WebSocketExtensionSpi} instance representing the extension using the registered
     * {@link WebSocketExtensionFactorySpi}. The format of the specified extensionWithParams is as shown below:
     *
     * {@code}
     *      extension-name[;param1=value1;param2;param3=value3]
     * {@code}
     *
     * @param extensionWithParams  String representation of the extension in request header format
     *
     * @return WebSocketExtensionSpi instance
     */

#Code:
    public WebSocketExtensionSpi createExtension(String extensionWithParams) throws IOException {
        Matcher extensionMatcher = PATTERN_EXTENSION_FORMAT.matcher(extensionWithParams);
        if (!extensionMatcher.matches()) {
            throw new IllegalStateException(format("Bad extension syntax: %s", extensionWithParams));
        }

        String extensionName = extensionMatcher.group(1);

        WebSocketExtensionFactorySpi factory = factoriesRO.get(extensionName);
        if (factory == null) {
            throw new IllegalArgumentException("Unsupported extension: " + extensionName);
        }

        return factory.createExtension(extensionWithParams);
    }

#end
#end
#No. 183921
#File: E:\bishe\1\WebSocketExtensionFactory.java
#Comment:
    /**
     * Returns the names of all the supported/discovered extensions.
     *
     * @return Collection of extension names
     */

#Code:
    public Collection<String> getExtensionNames() {
        return factoriesRO.keySet();
    }

#end
#end
#No. 183922
#File: E:\bishe\1\WebSocketExtensionFactory.java
#Comment:
    /**
     * Validates the extension name, parameter names and values in the specified string. The format of the specified
     * extensionWithParams is as shown below:
     *
     * {@code}
     *      extension-name[;param1=value1;param2;param3=value3]
     * {@code}
     * @param extensionWithParams  String representation of the extension in request header format
     * @return WebSocketExtensionSpi instance
     */

#Code:
    public void validateExtension(String extensionWithParams) throws IOException {
        Matcher extensionMatcher = PATTERN_EXTENSION_FORMAT.matcher(extensionWithParams);
        if (!extensionMatcher.matches()) {
            throw new IllegalStateException(format("Bad extension syntax: %s", extensionWithParams));
        }

        String extensionName = extensionMatcher.group(1);

        WebSocketExtensionFactorySpi factory = factoriesRO.get(extensionName);
        if (factory == null) {
            throw new IllegalArgumentException("Unsupported extension: " + extensionName);
        }

        factory.validateExtension(extensionWithParams);
    }

#end
#end
#No. 183923
#File: E:\bishe\1\WebSocketExtensionFactory.java
#Comment:
    /**
     * Creates a new instance of WebSocketExtensionFactory. It uses the default {@link ClassLoader} to load
     * {@link WebSocketExtensionFactorySpi} objects that are registered using META-INF/services.
     *
     * @return WebSocketExtensionFactory
     */

#Code:
    public static WebSocketExtensionFactory newInstance() {
        ServiceLoader<WebSocketExtensionFactorySpi> services = load(WebSocketExtensionFactorySpi.class);
        return newInstance(services);
    }

#end
#end
#No. 183924
#File: E:\bishe\1\WebSocketExtensionFactory.java
#Comment:
    /**
     * Creates a new instance of WebSocketExtensionFactory. It uses the specified {@link ClassLoader} to load
     * {@link WebSocketExtensionFactorySpi} objects that are registered using META-INF/services.
     *
     * @return WebSocketExtensionFactory
     */

#Code:
    public static WebSocketExtensionFactory newInstance(ClassLoader cl) {
        ServiceLoader<WebSocketExtensionFactorySpi> services = load(WebSocketExtensionFactorySpi.class, cl);
        return newInstance(services);
    }


#end
#end
#No. 183926
#File: E:\bishe\1\WebSocketFrameType.java
#Comment:
/**
 * Type of web socket frames
 */

#Code:
public enum WebSocketFrameType {
    TEXT, BINARY, PING, PONG, CLOSE, CONTINUATION
}

#end
#end
#No. 183927
#File: E:\bishe\1\WebSocketHandlerAdapter.java
#Comment:
    /**
     * Process connect request to uri and protocol specified
     */

#Code:
    @Override
    public void processConnect(WebSocketChannel channel, WSURI location, String[] protocols) {
        nextHandler.processConnect(channel, location, protocols);
    }

#end
#end
#No. 183928
#File: E:\bishe\1\WebSocketHandlerAdapter.java
#Comment:
    /**
     * Send authorize token to the Gateway
     */

#Code:
    @Override
    public synchronized void processAuthorize(WebSocketChannel channel, String authorizeToken) {
        nextHandler.processAuthorize(channel, authorizeToken); 
    }

#end
#end
#No. 183929
#File: E:\bishe\1\WebSocketHandlerAdapter.java
#Comment:
    /**
     * Disconnect the WebSocket
     */

#Code:
    @Override
    public synchronized void processClose(WebSocketChannel channel, int code, String reason) {
        nextHandler.processClose(channel, code, reason);        
    }

#end
#end
#No. 183930
#File: E:\bishe\1\WebSocketHandshakeObject.java
#Comment:
    /**
     * @return the name
     */

#Code:
    public String getName() {
        return name;
    }

#end
#end
#No. 183931
#File: E:\bishe\1\WebSocketHandshakeObject.java
#Comment:
    /**
     * @param name the name to set
     */

#Code:
    public void setName(String name) {
        this.name = name;
    }

#end
#end
#No. 183932
#File: E:\bishe\1\WebSocketHandshakeObject.java
#Comment:
    /**
     * @return the escape
     */

#Code:
    public String getEscape() {
        return escape;
    }

#end
#end
#No. 183933
#File: E:\bishe\1\WebSocketHandshakeObject.java
#Comment:
    /**
     * @param escape the escape to set
     */

#Code:
    public void setEscape(String escape) {
        this.escape = escape;
    }

#end
#end
#No. 183934
#File: E:\bishe\1\WebSocketHandshakeObject.java
#Comment:
    /**
     * @return the status
     */

#Code:
    public HandshakeStatus getStatus() {
        return status;
    }

#end
#end
#No. 183935
#File: E:\bishe\1\WebSocketHandshakeObject.java
#Comment:
    /**
     * @param status the status to set
     */

#Code:
    public void setStatus(HandshakeStatus status) {
        this.status = status;
    }

#end
#end
#No. 183936
#File: E:\bishe\1\WebsocketIntegrationTestNoAppDefaultContextsBase.java
#Comment:
/**
 * Base class for WebSocket tests without an existing
 * application and using the default request context and
 * the default WebSocket context.
 */

#Code:
public abstract class WebsocketIntegrationTestNoAppDefaultContextsBase extends
                                                                       WebsocketIntegrationTestNoAppBase<DefaultRequestContext, DefaultWebsocketContext> {
    // nothing required
}

#end
#end
#No. 183937
#File: E:\bishe\1\WebSocketMessageType.java
#Comment:
/**
 * {@link WebSocketMessageType} represents the types of the messages that are
 * received by the {@link WebSocketMessageReader}. WebSocketMessageType.EOS
 * represents end-of-stream.
 */

#Code:
public enum WebSocketMessageType { 
    EOS, TEXT, BINARY;
}
#end
#end
#No. 183938
#File: E:\bishe\1\WebSocketNativeBalancingHandlerTest.java
#Comment:
    /*
     * wait receive balancer message for kaazing gateway
     */

#Code:
    @Test
    public void testWaitBalancerMessage() throws URISyntaxException {

        Mockery context = new Mockery();
        final WebSocketHandler nextHandler = context.mock(WebSocketHandler.class);
        final WebSocketHandlerListener listener = context.mock(WebSocketHandlerListener.class);
        final String[] requestedProtocols = new String[] { "x-kaazing-handshake" };

        context.checking(new Expectations() {
            {
                oneOf(nextHandler).setListener(with(aNonNull(WebSocketHandlerListener.class)));
                will(saveParameter("listener", 0));
                oneOf(nextHandler).processConnect(with(aNonNull(WebSocketChannel.class)), with(aNonNull(WSURI.class)), with(equal(requestedProtocols)));
                will(new CustomAction("will fire connectionOpen") {

                    @Override
                    public Object invoke(Invocation invocation) {
                        WebSocketHandlerListener listener = (WebSocketHandlerListener)lookup("listener");
                        WebSocketChannel channel = (WebSocketChannel)invocation.getParameter(0);
                        listener.connectionOpened(channel, requestedProtocols[0]);
                        return null;
                    }
                });
               
            }
        });

        WSURI uri = new WSURI("ws://locationhost:8001/echo");

        WebSocketChannel channel = new WebSocketNativeChannel(uri);

        WebSocketNativeBalancingHandler handler = new WebSocketNativeBalancingHandler();
        handler.setNextHandler(nextHandler);
        handler.setListener(listener);

        handler.processConnect(channel, uri, requestedProtocols);
        context.assertIsSatisfied();
    }

#end
#end
#No. 183942
#File: E:\bishe\1\WebSocketNativeBalancingHandlerTest.java
#Comment:
    /*
     * check message leading byte, 
     * if it starts with '\uf0ff'R, redirect 
     */

#Code:
    @Test
    public void testProcessBalancerRedirectMessage() throws URISyntaxException, UnsupportedEncodingException {
        Mockery context = new Mockery();
        final WebSocketHandler nextHandler = context.mock(WebSocketHandler.class);
        final WebSocketHandlerListener listener = context.mock(WebSocketHandlerListener.class);
        final String balancerRedirectMessage = '\uf0ff' + "Rws://localhost/echo";
        
        context.checking(new Expectations() {
            {
                oneOf(nextHandler).setListener(with(aNonNull(WebSocketHandlerListener.class)));
                will(saveParameter("listener", 0));
                oneOf(nextHandler).processTextMessage(with(aNonNull(WebSocketChannel.class)), with("test message"));
                will(new CustomAction("will fire redirect message") {

                    @Override
                    public Object invoke(Invocation invocation) {
                        WebSocketHandlerListener listener = (WebSocketHandlerListener)lookup("listener");
                        WebSocketChannel channel = (WebSocketChannel)invocation.getParameter(0);
                        listener.textMessageReceived(channel, balancerRedirectMessage);
                        return null;
                    }
                });
                oneOf(nextHandler).processClose(with(aNonNull(WebSocketChannel.class)), with(0), with(aNull(String.class)));
                
            }
        });

        WSURI uri = new WSURI("ws://locationhost:8001/echo");
        WebSocketChannel channel = getNativeChannel(uri);

        WebSocketNativeBalancingHandler handler = new WebSocketNativeBalancingHandler();
        handler.setNextHandler(nextHandler);
        handler.setListener(listener);
        handler.processTextMessage(channel, "test message");
        context.assertIsSatisfied();
    }

#end
#end
#No. 183943
#File: E:\bishe\1\WebSocketNativeEncoderImpl.java
#Comment:
    /**
     * Performs an in-situ masking of the readable buf bytes.
     * Preserves the position of the buffer whilst masking all the readable bytes,
     * such that the masked bytes will be readable after this invocation.
     *
     * @param buf   the buffer containing readable bytes to be masked.
     * @param mask  the mask to apply against the readable bytes of buffer.
     */

#Code:
    public static void mask(WrappedByteBuffer buf, int mask) {
        // masking is the same as unmasking due to the use of bitwise XOR.
        unmask(buf, mask);
    }

#end
#end
#No. 183944
#File: E:\bishe\1\WebSocketNativeEncoderImpl.java
#Comment:
    /**
     * Performs an in-situ unmasking of the readable buf bytes.
     * Preserves the position of the buffer whilst unmasking all the readable bytes,
     * such that the unmasked bytes will be readable after this invocation.
     *
     * @param buf   the buffer containing readable bytes to be unmasked.
     * @param mask  the mask to apply against the readable bytes of buffer.
     */

#Code:
    public static void unmask(WrappedByteBuffer buf, int mask) {
        byte b;
        int remainder = buf.remaining() % 4;
        int remaining = buf.remaining() - remainder;
        int end = remaining + buf.position();

        // xor a 32bit word at a time as long as possible
        while (buf.position() < end) {
            int plaintext = buf.getIntAt(buf.position()) ^ mask;
            buf.putInt(plaintext);
        }

        // xor the remaining 3, 2, or 1 bytes
        switch (remainder) {
        case 3:
            b = (byte) (buf.getAt(buf.position()) ^ ((mask >> 24) & 0xff));
            buf.put(b);
            b = (byte) (buf.getAt(buf.position()) ^ ((mask >> 16) & 0xff));
            buf.put(b);
            b = (byte) (buf.getAt(buf.position()) ^ ((mask >> 8) & 0xff));
            buf.put(b);
            break;
        case 2:
            b = (byte) (buf.getAt(buf.position()) ^ ((mask >> 24) & 0xff));
            buf.put(b);
            b = (byte) (buf.getAt(buf.position()) ^ ((mask >> 16) & 0xff));
            buf.put(b);
            break;
        case 1:
            b = (byte) (buf.getAt(buf.position()) ^ (mask >> 24));
            buf.put(b);
            break;
        case 0:
        default:
                break;
        }
        //buf.position(start);
    }





#end
#end
#No. 183949
#File: E:\bishe\1\WebsocketOperation.java
#Comment:
/**
 * This is a helper class used by {@link DefaultFrontController} to handle incoming Websocket messages.
 * <p/>
 * Created on: 2011-09-25 11:59:43 <br/>
 *
 * @author Wojciech Niemiec
 */

#Code:
public enum WebsocketOperation {

  TEXT_FRAME(OperationCode.TEXT_FRAME_CODE) {
    public void performOperation(WebsocketConnector connector, UsersContainer usersContainer, Object data) {
      UserContext userContext = usersContainer.getUserContext(connector);
      connector.getDataController().processTextData((String) data, userContext);
    }
  },

  BINARY_FRAME(OperationCode.BINARY_FRAME_CODE) {
    public void performOperation(WebsocketConnector connector, UsersContainer usersContainer, Object data) {
      UserContext userContext = usersContainer.getUserContext(connector);
      connector.getDataController().processBinaryData((byte[]) data, userContext);
    }
  },

  CLOSE_FRAME(OperationCode.CLOSE_FRAME_CODE) {
    public void performOperation(WebsocketConnector connector, UsersContainer usersContainer, Object data) {
      connector.stop();
    }
  };

  private OperationCode operationCode;

  WebsocketOperation(OperationCode operationCode) {
    this.operationCode = operationCode;
  }

  public OperationCode getOperationCode() {
    return operationCode;
  }

  public abstract void performOperation(WebsocketConnector connector, UsersContainer usersContainer, Object data);

}

#end
#end
#No. 183950
#File: E:\bishe\1\WebSocketReader.java
#Comment:
  /**
   * Reads a message body into across one or more frames. Control frames that occur between
   * fragments will be processed. If the message payload is masked this will unmask as it's being
   * processed.
   */

#Code:
  private void readMessage(Buffer sink) throws IOException {
    while (true) {
      if (closed) throw new IOException("closed");

      if (frameBytesRead == frameLength) {
        if (isFinalFrame) return; // We are exhausted and have no continuations.

        readUntilNonControlFrame();
        if (opcode != OPCODE_CONTINUATION) {
          throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
        }
        if (isFinalFrame && frameLength == 0) {
          return; // Fast-path for empty final frame.
        }
      }

      long toRead = frameLength - frameBytesRead;

      long read;
      if (isMasked) {
        toRead = Math.min(toRead, maskBuffer.length);
        read = source.read(maskBuffer, 0, (int) toRead);
        if (read == -1) throw new EOFException();
        toggleMask(maskBuffer, read, maskKey, frameBytesRead);
        sink.write(maskBuffer, 0, (int) read);
      } else {
        read = source.read(sink, toRead);
        if (read == -1) throw new EOFException();
      }

      frameBytesRead += read;
    }
  }



#end
#end
#No. 183953
#File: E:\bishe\1\WebsocketRequestBuilderDefault.java
#Comment:
    /**
     * The maximum number of allowed redirections.
     */

#Code:
    protected int getMaxRedirectionNbr() {
        // @see https://tools.ietf.org/html/rfc2068#section-10.3
        return 5;
    }

#end
#end
#No. 183954
#File: E:\bishe\1\WebsocketRequestBuilderDefault.java
#Comment:
    /**
     * Sends a "String message" event to the app.
     */

#Code:
    protected void sendOnStringMessageClientEvent(final String message) {

        if(this.connectionIsClosed) {
            return;
        }

        Runnable runnable = new Runnable() {

            @Override
            public void run() {
                getWebsocketClientReader().onEndpointMessage(message);
            }
        };
        sendClientEventInNewThread(runnable);
    }

#end
#end
#No. 183955
#File: E:\bishe\1\WebsocketRequestBuilderDefault.java
#Comment:
    /**
     * Sends a "Bytes message" event to the app.
     */

#Code:
    protected void sendOnBytesMessageClientEvent(final byte[] message) {

        if(this.connectionIsClosed) {
            return;
        }

        Runnable runnable = new Runnable() {

            @Override
            public void run() {
                getWebsocketClientReader().onEndpointMessage(message);
            }
        };
        sendClientEventInNewThread(runnable);
    }

#end
#end
#No. 183956
#File: E:\bishe\1\WebsocketRequestBuilderDefault.java
#Comment:
    /**
     * Sends a "Connection closed message" event to the app.
     */

#Code:
    protected void sendOnConnectionClosedMessageClientEvent(final int code,
                                                            final String reason) {

        Runnable runnable = new Runnable() {

            @Override
            public void run() {
                getWebsocketClientReader().onConnectionClosed(code, reason);
            }
        };
        sendClientEventInNewThread(runnable);
    }

#end
#end
#No. 183957
#File: E:\bishe\1\WebsocketRequestBuilderDefault.java
#Comment:
    /**
     * Sends an event to the client in a separated thread.
     */

#Code:
    protected void sendClientEventInNewThread(final Runnable runnable) {
        try {

            Callable<Void> callable = new Callable<Void>() {

                @Override
                public Void call() throws Exception {
                    runnable.run();
                    return null;
                }
            };

            Set<Callable<Void>> callables = new HashSet<>();
            callables.add(callable);

            getThreadExecutorForClientEvents().invokeAll(callables,
                                                         getThreadExecutorForClientEventsTimeoutAmount(),
                                                         getThreadExecutorForClientEventsTimeoutTimeUnit());
        } catch(InterruptedException ex) {
            this.logger.error("A Thread used for sending a Websocket event to the client took too long " +
                              "(max " + getThreadExecutorForClientEventsTimeoutAmount() + " " +
                              getThreadExecutorForClientEventsTimeoutTimeUnit().toString() + "): " + ex.getMessage());
        } catch(Exception ex) {
            this.logger.error("A Thread used for sending a Websocket event to the application thrown an exception: " +
                              "" + ex.getMessage());
        }
    }

#end
#end
#No. 183958
#File: E:\bishe\1\WebsocketRequestBuilderDefault.java
#Comment:
    /**
     * The timeout amount before cancelling a task when
     * sending events to the application. 
     */

#Code:
    protected int getThreadExecutorForClientEventsTimeoutAmount() {
        return getSpincastHttpClientWithWebsocketConfig().getWebsocketThreadExecutorForClientEventsTimeoutAmount();
    }

#end
#end
#No. 183959
#File: E:\bishe\1\WebsocketRequestBuilderDefault.java
#Comment:
    /**
     * The timeout asdasd before cancelling a task when
     * sending events to the application. 
     */

#Code:
    protected TimeUnit getThreadExecutorForClientEventsTimeoutTimeUnit() {
        return getSpincastHttpClientWithWebsocketConfig().getWebsocketThreadExecutorForClientEventsTimeoutTimeUnit();
    }

#end
#end
#No. 183960
#File: E:\bishe\1\WebsocketRequestBuilderDefault.java
#Comment:
    /**
     * The ExecutorService to use to
     * send events to the client.
     */

#Code:
    protected ExecutorService getThreadExecutorForClientEvents() {

        if(this.threadExecutorForClientEvents == null) {
            ThreadFactory threadFactory = getThreadExecutorForClientEventsThreadThreadFactory();
            if(threadFactory != null) {
                this.threadExecutorForClientEvents =
                        Executors.newFixedThreadPool(getThreadExecutorForClientEventsThreadNumber(), threadFactory);
            } else {
                this.threadExecutorForClientEvents = Executors.newFixedThreadPool(getThreadExecutorForClientEventsThreadNumber());
            }
        }

        return this.threadExecutorForClientEvents;
    }

#end
#end
#No. 183961
#File: E:\bishe\1\WebsocketRequestBuilderDefault.java
#Comment:
    /**
     * The maximum number of concurrent threads used when
     * sending events to the application. 
     */

#Code:
    protected int getThreadExecutorForClientEventsThreadNumber() {
        return getSpincastHttpClientWithWebsocketConfig().getWebsocketThreadExecutorForClientEventsThreadNumber();
    }

#end
#end
#No. 183962
#File: E:\bishe\1\WebsocketRequestBuilderDefault.java
#Comment:
    /**
     * The ThreadFactory to use for the Executor that
     * sends events to the client. 
     * 
     * @return the ThreadFactory to use or <code>null</code> 
     * to use the default one.
     */

#Code:
    protected ThreadFactory getThreadExecutorForClientEventsThreadThreadFactory() {
        return getSpincastHttpClientWithWebsocketConfig().getWebsocketThreadExecutorForClientEventsThreadFactory();
    }

#end
#end
#No. 183963
#File: E:\bishe\1\WebSocketResponseHandler.java
#Comment:
    /**
     * Translates the specified byte array into Base64 string.
     * <p>
     * Android has android.util.Base64, sun has sun.misc.Base64Encoder, Java 8 hast java.util.Base64,
     * I have this from stackoverflow: http://stackoverflow.com/a/4265472
     * </p>
     *
     * @param buf the byte array (not null)
     * @return the translated Base64 string (not null)
     */

#Code:
    private static String encodeBase64(byte[] buf) {
        int size = buf.length;
        char[] ar = new char[((size + 2) / 3) * 4];
        int a = 0;
        int i = 0;
        while (i < size) {
            byte b0 = buf[i++];
            byte b1 = (i < size) ? buf[i++] : 0;
            byte b2 = (i < size) ? buf[i++] : 0;

            int mask = 0x3F;
            ar[a++] = ALPHABET[(b0 >> 2) & mask];
            ar[a++] = ALPHABET[((b0 << 4) | ((b1 & 0xFF) >> 4)) & mask];
            ar[a++] = ALPHABET[((b1 << 2) | ((b2 & 0xFF) >> 6)) & mask];
            ar[a++] = ALPHABET[b2 & mask];
        }
        switch (size % 3) {
            case 1:
                ar[--a] = '=';
            case 2:
                ar[--a] = '=';
        }
        return new String(ar);
    }




#end
#end
#No. 183967
#File: E:\bishe\1\WebSocketServlet.java
#Comment:
    /**
     * get the posted picture and send to every websocket session.
     */

#Code:
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException,
            IOException {

        Part part = request.getPart("picture");
        InputStream in = part.getInputStream();
        int b = in.read();
        while (b > -1) {
            
        }
    }

#end
#end
#No. 183971
#File: E:\bishe\1\WebsocketThread.java
#Comment:
	/**
	 * startWS - public method to initiate the websocket
	 * @return websocket creation status
	 */

#Code:
	public boolean startWS(){
		boolean status = false;
		
		//Establish the websocket
		try {
			System.out.println("WebsocketThread.startWS(): creating WebsocketClientEndpoint with URI: <" + 
																									URIstring + ">....");
			//save the state of web socket before initiating
			//open is an async call, notification may come before setting state
			currWSstateLock.lock();
	        currWSstate = WSstate.WS_INITIATED;
	        currWSstateLock.unlock();
	        
	        //initiate WS
			clientEndPoint = new WebsocketClientEndpoint(new URI(URIstring), this);
			status = true;
			
			//set the running status
			runStatus = true;
		} catch (URISyntaxException e) {
			System.out.println("WebsocketThread.startWS(): ERROR: URISyntaxException on WebsocketClientEndpoint");
			e.printStackTrace();
		}
		return status;
	}

#end
#end
#No. 183972
#File: E:\bishe\1\WebsocketThread.java
#Comment:
	/**
	 * stopWS - method to stop the websocket thread
	 */

#Code:
	public void stopWS(){
		System.out.println("WebsocketThread.stopWS(): Sending UnSuscribe message to Streaming Quote WS server");
		sendUnSubscribeMessage();
		
		System.out.println("WebsocketThread.stopWS(): Terminate Force closing previous WS session");
		clientEndPoint.forceClose(true);
		clientEndPoint = null;
		
		currWSstateLock.lock();
		currWSstate = null;
		currWSstateLock.unlock();
		
		System.out.println("WebsocketThread.stopWS(): method called to stop Websocket data parser thread...");
		//Stop quote parser thread first
		quoteParserThread.stopThread();
		
		//flag this thread to stop
		runStatus = false;
	}

#end
#end
#No. 183973
#File: E:\bishe\1\WebsocketThread.java
#Comment:
	/**
	 * addMessageHandler - private method to add message handler
	 */

#Code:
	private void addMessageHandler() {
		//add listener
		clientEndPoint.addMessageHandler(new WebsocketClientEndpoint.MessageHandler() {
			public void handleMessage(ByteBuffer buffer) {
				//save the state of web socket
				currWSstateLock.lock();
		        currWSstate = WSstate.WS_MSG_RECEIVED;
		        currWSstateLock.unlock();
		        
				//send the buffer to Q
				try {
					quoteBufferQ.put(buffer);
				} catch (InterruptedException e) {
					System.out.println("WebsocketThread.addMessageHandler().new MessageHandler(): " +
											"ERROR: InterruptedException on putting to quoteBufferQ");
					e.printStackTrace();
				}
			}
		});
	}

#end
#end
#No. 183974
#File: E:\bishe\1\WebsocketThread.java
#Comment:
	/**
	 * sendSubscribeMessage - private method to send subscribe message for the instruments
	 */

#Code:
	private void sendSubscribeMessage(){
		//save the state of web socket before subscribing, due to async call
        currWSstateLock.lock();
        currWSstate = WSstate.WS_SUBSCRIBED;
        currWSstateLock.unlock();
        
		String instrumentString = getInstrumentString(instrumentList);
		//send message to websocket e.g. INFY (408065) and TATAMOTORS (884737)
        String msg = "{\"a\": \"subscribe\", \"v\": [" + instrumentString + "]}";
        System.out.println("WebsocketThread.sendSubscribeMessage(): WS Subscribe msg: " + msg);
        clientEndPoint.sendMessage(msg);
	}

#end
#end
#No. 183975
#File: E:\bishe\1\WebsocketThread.java
#Comment:
	/**
	 * sendModeMessage - private method to send mode message for the instruments
	 */

#Code:
	private void sendModeMessage(){
		//save the state of web socket before switching mode, due to async call
        currWSstateLock.lock();
        currWSstate = WSstate.WS_MODE_SWITCHED;
        currWSstateLock.unlock();
        
		String instrumentString = getInstrumentString(instrumentList);
		//send message to websocket e.g. INFY (408065) and TATAMOTORS (884737)
        String msg = "{\"a\": \"mode\", \"v\": [\"" + ZStreamingConfig.getStreamingQuoteMode() + "\", [" + instrumentString + "]]}";
        System.out.println("WebsocketThread.sendModeMessage(): WS mode msg: " + msg);
        clientEndPoint.sendMessage(msg);
        
        //Dirty Hack: At Market Open, WS does not respond with data after Open and Subscribe
        fireDataMissTimerOnWSsubscribe();
	}

#end
#end
#No. 183976
#File: E:\bishe\1\WebsocketThread.java
#Comment:
	/**
	 * sendUnSubscribeMessage - private method to send unsubscribe message for the instruments
	 */

#Code:
	private void sendUnSubscribeMessage(){
		//save the state of web socket before unsubscribing, due to async call
        currWSstateLock.lock();
        currWSstate = WSstate.WS_UNSUBSCRIBED;
        currWSstateLock.unlock();
        
		String instrumentString = getInstrumentString(instrumentList);
        String msg = "{\"a\": \"unsubscribe\", \"v\": [" + instrumentString + "]}";
        System.out.println("WebsocketThread.sendUnSubscribeMessage(): WS UnSubscribe msg: " + msg);
        clientEndPoint.sendMessage(msg);
	}

#end
#end
#No. 183977
#File: E:\bishe\1\WebsocketThread.java
#Comment:
	/**
	 * getInstrumentString - private method to create instrument string from instrument list
	 * @param instrumentList
	 * @return instrumentString
	 */

#Code:
	private String getInstrumentString(List<String> instrumentList){
		StringBuilder stringBuilder = new StringBuilder();
		for(int i = 0; i < instrumentList.size(); i++){
			stringBuilder.append(instrumentList.get(i));
			if(i < (instrumentList.size() - 1)){
				stringBuilder.append(",");
			}
		}
		
		String instrumentString = stringBuilder.toString();
		System.out.println("WebsocketThread.getInstrumentString(): instrumentString: [" + instrumentString + "]");
		return instrumentString;
	}

#end
#end
#No. 183978
#File: E:\bishe\1\WebsocketThread.java
#Comment:
	/**
	 * subscribeWSwithMsgHandler - private method to subscribe with Msg Handler
	 */

#Code:
	private void subscribeWSwithMsgHandler(){
		try {
			Thread.sleep(ZStreamingConfig.getStreamingQuoteSubscribeDelayAfterInitiate());
		} catch (InterruptedException e) {
			System.out.println("WebsocketThread.subscribeWSwithMsgHandler(): ERROR: InterruptedException on sleep before subscribe !!!");
		}
		
		if(currWSstate == WSstate.WS_OPENED){
			//add message handler
			addMessageHandler();
			
			//send websocket subscribe message		
			sendSubscribeMessage();
			
			//send websocket mode message
			sendModeMessage();
		} else{
			//WebSocket Did not get Opened even on delay after initiation
			if(wsSessionRetry < ZStreamingConfig.getStreamingQuoteMaxInitiateRetryCount()){
				//Reinitiate WS session
				System.out.println("WebsocketThread.subscribeWSwithMsgHandler(): WARNING: WS Open FAILED On Initiation, Retrying !!!");
				wsSessionRetry++;
				reInitiateOnWSOpenFailure();
			} else{
				//Max limit reached, No initiation again
				System.out.println("WebsocketThread.subscribeWSwithMsgHandler(): ERROR: WS reinitiation max limit reached, no retry !!!");
			}
		}
	}

#end
#end
#No. 183979
#File: E:\bishe\1\WebsocketThread.java
#Comment:
	/**
	 * reInitiateOnWSOpenFailure - private method to reinitiate websocket session on Open Failure
	 */

#Code:
	private void reInitiateOnWSOpenFailure(){
		if(clientEndPoint != null){
			//force close the session without terminating
			System.out.println("WebsocketThread.reInitiateOnWSOpenFailure(): Force closing previous WS session");
			clientEndPoint.forceClose(false);
		} else{
			System.out.println("WebsocketThread.reInitiateOnWSOpenFailure(): ERROR: clientEndPoint is null");
		}
	}

#end
#end
#No. 183980
#File: E:\bishe\1\WebsocketThread.java
#Comment:
	/**
	 * fireDataMissTimerOnWSsubscribe - private method to fire data miss timer on subscribe
	 */

#Code:
	private void fireDataMissTimerOnWSsubscribe(){
        //start Timer for Web Socket Data miss Check after subscribe
        if(dataTimer != null){
        	dataTimer.cancel();
		}
        dataTimer = new Timer("WS Data Miss Timer");
        dataTimer.schedule(new TimerTask() {			
			@Override
			public void run() {
				if(currWSstate == WSstate.WS_MODE_SWITCHED){
					System.out.println("WebsocketThread.fireDataMissTimerOnWSsubscribe().new TimerTask().run(): ERROR: " +
							"Streaming Quote WS Data Miss Timer Fired after subscribe, notifying session notifier !!!");
					//Notify Data Missed after Subscribe
					notifyWsDataMissedAfterSubscribe();
				} else{
					//Data started, let the timer expire
					System.out.println("WebsocketThread.fireDataMissTimerOnWSsubscribe()new TimerTask().run(): " + 
														"WS data getting pushed in, curr state[" + currWSstate + "]");
				}
			}
		}, dataTimeDelay);
	}

#end
#end
#No. 183981
#File: E:\bishe\1\WebsocketVersions.java
#Comment:
/**
 * Mapping between Websocket Draft/Specification version and value of <code>Sec-WebSocket-Version</code> header
 * that should be sent by the client on opening handshake to be successfully handled by the server.
 * <p/>
 * Created on: 2011-09-25 15:30:12 <br/>
 *
 * @author Wojciech Niemiec
 */

#Code:
public enum WebsocketVersions {

  HIXIE_76("0"),
  HYBI_10("8"),
  HYBI_13("13"),
  RFC_6455("13");

  private String versionCode;

  WebsocketVersions(String versionCode) {
    this.versionCode = versionCode;
  }

  public String getVersionCode() {
    return versionCode;
  }
}
#end
#end
#No. 183982
#File: E:\bishe\1\WebSocketWebResource.java
#Comment:
    /**
     * Gets a caller id (IP + role)
     *
     * @return the web service caller identification
     */

#Code:
    public String clientAppId() {
        if (clientId != null && service().getConfig().isAuthenticationEnabled()) {
            try {
                clientId = service().getAuthenticationService().authenticateHttpRequest(httpRequest);
            } catch (AuthenticationException e) {
                throw new RestException(Status.UNAUTHORIZED, "Failed to get clientId from request");
            }
        } else {
            throw new RestException(Status.UNAUTHORIZED, "Failed to get auth data from the request");
        }
        return clientId;
    }

#end
#end
#No. 183983
#File: E:\bishe\1\WebSocketWebResource.java
#Comment:
    /**
     * Checks if user has super-user access or user is authorized to produce/consume on a given topic
     * 
     * @param topic
     * @return
     */

#Code:
    protected boolean validateUserAccess(DestinationName topic) {
        try {
            validateSuperUserAccess();
            return true;
        } catch (Exception e) {
            try {
                return isAuthorized(topic);
            } catch (Exception ne) {
                throw new RestException(ne);
            }
        }
    }

#end
#end
#No. 183984
#File: E:\bishe\1\WebSocketWebResource.java
#Comment:
    /**
     * Checks if user is authorized to produce/consume on a given topic
     * 
     * @param topic
     * @return
     * @throws Exception
     */

#Code:
    protected boolean isAuthorized(DestinationName topic) throws Exception {
        if (service().isAuthorizationEnabled()) {
            String authRole = clientAppId();
            return service().getAuthorizationManager().canLookup(topic, authRole);
        }
        return true;
    }

#end
#end
#No. 183985
#File: E:\bishe\1\WebsockifyProxyHandler.java
#Comment:
    /**
     * When file timestamp is the same as what the browser is sending up, send a "304 Not Modified"
     * 
     * @param ctx
     *            Context
     */

#Code:
    private void sendNotModified(ChannelHandlerContext ctx) {
        HttpResponse response = new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.NOT_MODIFIED);
        setDateHeader(response);

        // Close the connection as soon as the error message is sent.
        ctx.getChannel().write(response).addListener(ChannelFutureListener.CLOSE);
    }

#end
#end
#No. 183986
#File: E:\bishe\1\WebsockifyProxyHandler.java
#Comment:
    /**
     * Sets the Date header for the HTTP response
     * 
     * @param response
     *            HTTP response
     */

#Code:
    private void setDateHeader(HttpResponse response) {
        SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
        dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));

        Calendar time = new GregorianCalendar();
        response.setHeader(HttpHeaders.Names.DATE, dateFormatter.format(time.getTime()));
    }

#end
#end
#No. 183987
#File: E:\bishe\1\WebsockifyProxyHandler.java
#Comment:
    /**
     * Sets the Date and Cache headers for the HTTP Response
     * 
     * @param response
     *            HTTP response
     * @param fileToCache
     *            file to extract content type
     */

#Code:
    private void setDateAndCacheHeaders(HttpResponse response, File fileToCache) {
        SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
        dateFormatter.setTimeZone(TimeZone.getTimeZone(HTTP_DATE_GMT_TIMEZONE));

        // Date header
        Calendar time = new GregorianCalendar();
        response.setHeader(HttpHeaders.Names.DATE, dateFormatter.format(time.getTime()));

        // Add cache headers
        time.add(Calendar.SECOND, HTTP_CACHE_SECONDS);
        response.setHeader(HttpHeaders.Names.EXPIRES, dateFormatter.format(time.getTime()));
        response.setHeader(HttpHeaders.Names.CACHE_CONTROL, "private, max-age=" + HTTP_CACHE_SECONDS);
        response.setHeader(HttpHeaders.Names.LAST_MODIFIED, dateFormatter.format(new Date(fileToCache.lastModified())));
    }

#end
#end
#No. 183988
#File: E:\bishe\1\WebsockifyProxyHandler.java
#Comment:
    /**
     * Sets the content type header for the HTTP Response
     * 
     * @param response
     *            HTTP response
     * @param file
     *            file to extract content type
     */

#Code:
    private void setContentTypeHeader(HttpResponse response, File file) {
        MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();
        response.setHeader(HttpHeaders.Names.CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));
    }

#end
#end
#No. 183989
#File: E:\bishe\1\WebsockifyProxyHandler.java
#Comment:
    /**
     * Closes the specified channel after all queued write requests are flushed.
     */

#Code:
    static void closeOnFlush(Channel ch) {
        if (ch.isConnected()) {
            ch.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
        }
    }

#end
#end
#No. 183990
#File: E:\bishe\1\WebsockifyServer.java
#Comment:
	/**
	 * Validates that a keystore with the given parameters exists and can be used for an SSL context.
	 * @param keystore - path to the keystore file
	 * @param password - password to the keystore file
	 * @param keyPassword - password to the private key in the keystore file
	 * @return null if valid, otherwise a string describing the error.
	 */

#Code:
	public void validateKeystore ( String keystore, String password, String keyPassword )
		throws KeyManagementException, UnrecoverableKeyException, IOException, NoSuchAlgorithmException, CertificateException, KeyStoreException
	{
		WebsockifySslContext.validateKeystore(keystore, password, keyPassword);
	}

#end
#end
#No. 183991
#File: E:\bishe\1\WebsockifySslContext.java
#Comment:
    /**
     * Returns the singleton instance for this class
     */

#Code:
    public static WebsockifySslContext getInstance(String keystore, String password, String keyPassword) {
    	WebsockifySslContext context = SingletonHolder.INSTANCE_MAP.get(keystore);
    	if ( context == null )
    	{
    		context = new WebsockifySslContext ( keystore, password, keyPassword );
    		SingletonHolder.INSTANCE_MAP.put(keystore, context);
    	}
    	return context;
    }


#end
#end
#No. 183994
#File: E:\bishe\1\WebsockifySslContext.java
#Comment:
    /**
     * Returns the server context with server side key store
     */

#Code:
    public SSLContext getServerContext() {
        return _serverContext;
    }

#end
#end
#No. 183995
#File: E:\bishe\1\WebsockifySslContext.java
#Comment:
	/**
	 * Validates that a keystore with the given parameters exists and can be used for an SSL context.
	 * @param keystore - path to the keystore file
	 * @param password - password to the keystore file
	 * @param keyPassword - password to the private key in the keystore file
	 * @return null if valid, otherwise a string describing the error.
	 */

#Code:
	public static void validateKeystore ( String keystore, String password, String keyPassword )
		throws KeyManagementException, UnrecoverableKeyException, IOException, NoSuchAlgorithmException, CertificateException, KeyStoreException
	{
        
        getSSLContext(keystore, password, keyPassword);
	}


#end
#end
#No. 183997
#File: E:\bishe\1\WebSphereDeploymentService.java
#Comment:
    /*
    This method tries to read ibm-web-ext.xml and extract the value of context-root.
    If any exception is thrown, it will fall back to the WAR name.
     */

#Code:
    private String getContextRoot(Artifact artifact) {
        try {
        	if(artifact.getContext() != null) {
        		return artifact.getContext();
        	}
            // open WAR and find ibm-web-ext.xml
            ZipFile zipFile = new ZipFile(artifact.getSourcePath());
            ZipEntry webExt = zipFile.getEntry("WEB-INF/ibm-web-ext.xml");
            if(webExt != null) { //not an IBM based WAR
	            InputStream webExtContent = zipFile.getInputStream(webExt);
	
	            // parse ibm-web-ext.xml
	            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
	            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
	            Document doc = dBuilder.parse(webExtContent);
	
	            // find uri attribute in context-root element
	            Element contextRoot = (Element) doc.getElementsByTagName("context-root").item(0);
	            String uri = contextRoot.getAttribute("uri");
	            uri = uri.startsWith("/") ? uri : "/" + uri;
	            return uri;
            }
            return getContextRootFromWarName(artifact);            		
        } catch (Exception e) {            
        	e.printStackTrace();
            return getContextRootFromWarName(artifact);
        }
    }

#end
#end
#No. 183998
#File: E:\bishe\1\WebSphereDeploymentService.java
#Comment:
    /*
     * Checks the listener and figures out the aggregate distribution status of all nodes
     */

#Code:
    private String checkDistributionStatus(DeploymentNotificationListener listener) throws MalformedObjectNameException {
		String distributionState = AppNotification.DISTRIBUTION_UNKNOWN;
		if (listener != null) {
			String compositeServers = listener.getNotificationProps().getProperty(AppNotification.DISTRIBUTION_STATUS_COMPOSITE);
			if (compositeServers != null) {
				if(verbose) {
					buildListener.getLogger().println("Server Composite: "+ compositeServers);
				}
				String[] servers = compositeServers.split("\\+");
				int countTrue = 0, countFalse = 0, countUnknown = 0;
				for (String server : servers) {
					ObjectName serverObject = new ObjectName(server);
					distributionState = serverObject.getKeyProperty("distribution");
					if(verbose) {
						buildListener.getLogger().println("Distributed to "+server+": "+distributionState);
					}
					if (distributionState.equals("true"))
						countTrue++;
					if (distributionState.equals("false"))
						countFalse++;
					if (distributionState.equals("unknown"))
						countUnknown++;
				}
				if (countUnknown > 0) {
					distributionState = AppNotification.DISTRIBUTION_UNKNOWN;
				} else if (countFalse > 0) {
					distributionState = AppNotification.DISTRIBUTION_NOT_DONE;
				} else if (countTrue > 0) {
					distributionState = AppNotification.DISTRIBUTION_DONE;
				} else {
					throw new DeploymentServiceException("Reported distribution status is invalid.");
				}
			}
		}
		return distributionState;
    }

#end
#end
#No. 183999
#File: E:\bishe\1\WebSphereEmbeddedContainerConfiguration.java
#Comment:
/**
 * WebSphereEmbeddedContainerConfiguration
 *
 * @author <a href="mailto:gerhard.poul@gmail.com">Gerhard Poul</a>
 * @version $Revision: $
 */

#Code:
public class WebSphereEmbeddedContainerConfiguration implements
      ContainerConfiguration {
   
   private String embeddedProperties;

   @Override
   public void validate() throws ConfigurationException {
      if (embeddedProperties != null) {
         if (!new File(embeddedProperties).canRead()) {
            throw new ConfigurationException("Cannot access the embeddedProperties file " + embeddedProperties);
         }
      }
   }

   public String getEmbeddedProperties() {
      return embeddedProperties;
   }

   public void setEmbeddedProperties(String embeddedProperties) {
      this.embeddedProperties = embeddedProperties;
   }

}

#end
#end
#No. 184001
#File: E:\bishe\1\WebTelemetryInitializerBase.java
#Comment:
    /**
     * Initializes properties of the given telemetry.
     * @param telemetry The {@link com.microsoft.applicationinsights.telemetry.Telemetry} to initialize.
     */

#Code:
    @Override
    public void initialize(Telemetry telemetry) {

        // Some threads may not have TLS initialized, such as performance counters mechanism threads.
        if (ThreadContext.getRequestTelemetryContext() == null) {
            return;
        }

        onInitializeTelemetry(telemetry);
    }

#end
#end
#No. 184003
#File: E:\bishe\1\WebTelemetryTests.java
#Comment:
    /**
     * Sends GET requests to server and expects that will telemetry from app insights and it will include the correct information about the request
     * @throws Exception
     */

#Code:
    @Test
    public void testHttpRequestCommonProperties() throws Exception {
        List<TelemetryItem> expectedTelemetriesForRunId = getExpectedTelemetriesForRunId(testRequestCommonPropertiesRunId);
        List<TelemetryItem> realTelemetries = applicationTelemetryManager.getApplicationTelemetries(testRequestCommonPropertiesRunId, 1);

        Assert.assertEquals(1, realTelemetries.size());
        Assert.assertEquals(expectedTelemetriesForRunId.get(0), realTelemetries.get(0));
    }

#end
#end
#No. 184007
#File: E:\bishe\1\WebUntisUrlParser.java
#Comment:
	/**
	 * Liefert die URL oder einen Leerstring, wenn die URL nicht geparst werden konnte.
	 * @param url URL, die geparst werden soll
	 * @return Die geparste URL oder einen Leerstring, wenn sie nicht geparst werden konnte
	 */

#Code:
	public String parseUrl(String url) {
		if(url.length() <= 0) {
			return "";
		}
		String applicableUrl = url.replaceAll("(?i)/WebUntis(/*)(jsonrpc.do|index.do)?$", "");
		Pattern p = Pattern.compile("^([a-zA-Z]+://)?(.*)$");
		Matcher m = p.matcher(applicableUrl);
		if(m.matches()) {
			applicableUrl = m.group(2);
			
			while(applicableUrl.endsWith("/")) {
				applicableUrl = applicableUrl.substring(0, applicableUrl.length()-1);
			}
			
			return applicableUrl;
		}
		
		return "";
	}

#end
#end
#No. 184008
#File: E:\bishe\1\WebURL.java
#Comment:
    /**
     * @return unique document id assigned to this Url.
     */

#Code:
    public int getDocid() {
        return docid;
    }

#end
#end
#No. 184009
#File: E:\bishe\1\WebURL.java
#Comment:
    /**
     * @return Url string
     */

#Code:
    public String getURL() {
        return url;
    }

#end
#end
#No. 184010
#File: E:\bishe\1\WebURL.java
#Comment:
    /**
     * @return
     *      unique document id of the parent page. The parent page is the
     *      page in which the Url of this page is first observed.
     */

#Code:
    public int getParentDocid() {
        return parentDocid;
    }

#end
#end
#No. 184011
#File: E:\bishe\1\WebURL.java
#Comment:
    /**
     * @return
     *      url of the parent page. The parent page is the page in which
     *      the Url of this page is first observed.
     */

#Code:
    public String getParentUrl() {
        return parentUrl;
    }

#end
#end
#No. 184012
#File: E:\bishe\1\WebURL.java
#Comment:
    /**
     * @return
     *      crawl depth at which this Url is first observed. Seed Urls
     *      are at depth 0. Urls that are extracted from seed Urls are at depth 1, etc.
     */

#Code:
    public short getDepth() {
        return depth;
    }

#end
#end
#No. 184013
#File: E:\bishe\1\WebURL.java
#Comment:
    /**
     * @return
     *      domain of this Url. For 'http://www.example.com/sample.htm', domain will be 'example
     *      .com'
     */

#Code:
    public String getDomain() {
        return domain;
    }

#end
#end
#No. 184014
#File: E:\bishe\1\WebURL.java
#Comment:
    /**
     * @return
     *      path of this Url. For 'http://www.example.com/sample.htm', domain will be 'sample.htm'
     */

#Code:
    public String getPath() {
        return path;
    }

#end
#end
#No. 184015
#File: E:\bishe\1\WebURL.java
#Comment:
    /**
     * @return
     *      anchor string. For example, in <a href="example.com">A sample anchor</a>
     *      the anchor string is 'A sample anchor'
     */

#Code:
    public String getAnchor() {
        return anchor;
    }

#end
#end
#No. 184016
#File: E:\bishe\1\WebURL.java
#Comment:
    /**
     * @return priority for crawling this URL. A lower number results in higher priority.
     */

#Code:
    public byte getPriority() {
        return priority;
    }

#end
#end
#No. 184017
#File: E:\bishe\1\WebURL.java
#Comment:
    /**
     * @return tag in which this URL is found
     * */

#Code:
    public String getTag() {
        return tag;
    }

#end
#end
#No. 184018
#File: E:\bishe\1\WebUserAgentTelemetryInitializer.java
#Comment:
    /**
     * Initializes the properties of the given telemetry.
     *
     * @param telemetry The {@link com.microsoft.applicationinsights.telemetry.Telemetry} to initialize.
     */

#Code:
    @Override
    protected void onInitializeTelemetry(Telemetry telemetry) {
        RequestTelemetry requestTelemetry = ThreadContext.getRequestTelemetryContext().getHttpRequestTelemetry();

        String userAgent = requestTelemetry.getContext().getUser().getUserAgent();
        telemetry.getContext().getUser().setUserAgent(userAgent);
    }

#end
#end
#No. 184019
#File: E:\bishe\1\WebUserTelemetryInitializer.java
#Comment:
    /**
     * Initializes the properties of the given telemetry.
     *
     * @param telemetry The {@link com.microsoft.applicationinsights.telemetry.Telemetry} to initialize.
     */

#Code:
    @Override
    protected void onInitializeTelemetry(Telemetry telemetry) {
        UserContext userContext = telemetry.getContext().getUser();

        if (!CommonUtils.isNullOrEmpty(userContext.getId())) {
            return;
        }

        RequestTelemetry requestTelemetry = ThreadContext.getRequestTelemetryContext().getHttpRequestTelemetry();
        UserContext requestUserContext = requestTelemetry.getContext().getUser();
        if (requestUserContext == null) {
            return;
        }

        userContext.setId(requestUserContext.getId());

        Date requestUserAcquisitionDate = requestUserContext.getAcquisitionDate();
        userContext.setAcquisitionDate(requestUserAcquisitionDate);
    }

#end
#end
#No. 184020
#File: E:\bishe\1\WebUserTrackingTelemetryModule.java
#Comment:
    /**
     * Initializes the telemetry module.
     *
     * @param configuration The configuration to used to initialize the module.
     */

#Code:
    @Override
    public void initialize(TelemetryConfiguration configuration) {
    }

#end
#end
#No. 184021
#File: E:\bishe\1\WebUserTrackingTelemetryModule.java
#Comment:
    /**
     * Begin request processing.
     *
     * @param req The request to process
     * @param res The response to modify
     */

#Code:
    @Override
    public void onBeginRequest(ServletRequest req, ServletResponse res) {
        HttpServletRequest request = (HttpServletRequest)req;
        RequestTelemetryContext context = ThreadContext.getRequestTelemetryContext();

        UserCookie userCookie =
                com.microsoft.applicationinsights.web.internal.cookies.Cookie.getCookie(
                        UserCookie.class, request, UserCookie.COOKIE_NAME);

        if (userCookie == null) {
            return;
        }

        String userId = userCookie.getUserId();
        Date acquisitionDate = userCookie.getAcquisitionDate();

        context.setUserCookie(userCookie);

        UserContext userContext = context.getHttpRequestTelemetry().getContext().getUser();
        userContext.setId(userId);
        userContext.setAcquisitionDate(acquisitionDate);
    }







#end
#end
#No. 184029
#File: E:\bishe\1\WebViewDemoActivity.java
#Comment:
	/**
	 * Checks networking status.
	 */

#Code:
	private boolean checkConnectivity()
	{
		boolean enabled = true;

		ConnectivityManager connectivityManager = (ConnectivityManager) this.getSystemService(Context.CONNECTIVITY_SERVICE);
		NetworkInfo info = connectivityManager.getActiveNetworkInfo();
		
		if ((info == null || !info.isConnected() || !info.isAvailable()))
		{
			enabled = false;
			Builder builder = new Builder(this);
			builder.setIcon(android.R.drawable.ic_dialog_alert);
			builder.setMessage(getString(R.string.noconnection));
			builder.setCancelable(false);
			builder.setNeutralButton(R.string.ok, null);
			builder.setTitle(getString(R.string.error));
			builder.create().show();		
		}
		return enabled;			
	}


#end
#end
#No. 184046
#File: E:\bishe\1\WebViewPlugin.java
#Comment:
  /**
  * Sets the context of the Command. This can then be used to do things like
  * get file paths associated with the Activity.
  *
  * @param cordova
  *            The context of the main Activity.
  * @param webView
  *            The CordovaWebView Cordova is running in.
  */

#Code:
  public void initialize(CordovaInterface cordova, CordovaWebView webView) {
    super.initialize(cordova, webView);
  }

#end
#end
#No. 184047
#File: E:\bishe\1\WebViews.java
#Comment:
	/**
	 * Creates a handle with which the specified listener can be {@link WebViewHyperlinkListenerHandle#attach()
	 * attached} to the specified web view.
	 * <p>
	 * Once attached, the listener will be called on any event on an hyperlink (i.e. any element with tag name "a")
	 * which can be represented as a {@link HyperlinkEvent} with the specified event type. See
	 * {@link DomEventType#toHyperlinkEventType()} for the conversion of event types.
	 *
	 * @param webView
	 *            the {@link WebView} to which the listener will be added
	 * @param listener
	 *            the {@link WebViewHyperlinkListener} to add to the web view
	 * @param eventType
	 *            the {@link EventType} of all events passed to the listener
	 * @return a handle on the created listener which allows to attach and detach it; initially detached
	 * @see #addHyperlinkListener(WebView, WebViewHyperlinkListener, HyperlinkEvent.EventType)
	 */

#Code:
	public static WebViewHyperlinkListenerHandle createHyperlinkListenerHandle(
			WebView webView, WebViewHyperlinkListener listener, EventType eventType) {

		Objects.requireNonNull(eventType, "The argument 'eventType' must not be null.");
		return addHyperlinkListenerDetached(webView, listener, Optional.of(eventType));
	}

#end
#end
#No. 184048
#File: E:\bishe\1\WebViews.java
#Comment:
	/**
	 * {@link #createHyperlinkListenerHandle(WebView, WebViewHyperlinkListener) Creates} a listener handle and
	 * immediately {@link WebViewHyperlinkListenerHandle#attach() attaches} it.
	 *
	 * @param webView
	 *            the {@link WebView} to which the listener will be added
	 * @param listener
	 *            the {@link WebViewHyperlinkListener} to add to the web view
	 * @return a handle on the created listener which allows to attach and detach it; initially attached
	 * @see #createHyperlinkListenerHandle(WebView, WebViewHyperlinkListener)
	 */

#Code:
	public static WebViewHyperlinkListenerHandle addHyperlinkListener(
			WebView webView, WebViewHyperlinkListener listener) {

		WebViewHyperlinkListenerHandle listenerHandle = addHyperlinkListenerDetached(webView, listener,
				Optional.empty());
		listenerHandle.attach();
		return listenerHandle;
	}

#end
#end
#No. 184049
#File: E:\bishe\1\WebViews.java
#Comment:
	/**
	 * {@link #createHyperlinkListenerHandle(WebView, WebViewHyperlinkListener, HyperlinkEvent.EventType) Creates} a
	 * listener handle and immediately {@link WebViewHyperlinkListenerHandle#attach() attaches} it.
	 *
	 * @param webView
	 *            the {@link WebView} to which the listener will be added
	 * @param listener
	 *            the {@link WebViewHyperlinkListener} to add to the web view
	 * @param eventType
	 *            the {@link EventType} of all events passed to the listener
	 * @return a handle on the created listener which allows to attach and detach it; initially attached
	 * @see #createHyperlinkListenerHandle(WebView, WebViewHyperlinkListener, HyperlinkEvent.EventType)
	 */

#Code:
	public static WebViewHyperlinkListenerHandle addHyperlinkListener(
			WebView webView, WebViewHyperlinkListener listener, EventType eventType) {

		Objects.requireNonNull(eventType, "The argument 'eventType' must not be null.");
		WebViewHyperlinkListenerHandle listenerHandle = addHyperlinkListenerDetached(webView, listener,
				Optional.of(eventType));
		listenerHandle.attach();
		return listenerHandle;
	}

#end
#end
#No. 184050
#File: E:\bishe\1\WebViews.java
#Comment:
	/**
	 * Adds the specified listener to the specified WebView.
	 * <p>
	 * If necessary this method switches to the FX application thread.
	 *
	 * @param webView
	 *            the {@link WebView} to which the listener will be added
	 * @param listener
	 *            the {@link WebViewHyperlinkListener} to add to the web view
	 * @param eventTypeFilter
	 *            the {@link EventType} of all events passed to the listener; {@link Optional#empty()} means all events
	 *            are passed
	 * @return a handle on the created listener which allows to attach and detach it
	 */

#Code:
	private static WebViewHyperlinkListenerHandle addHyperlinkListenerDetached(
			WebView webView, WebViewHyperlinkListener listener, Optional<EventType> eventTypeFilter) {

		Objects.requireNonNull(webView, "The argument 'webView' must not be null.");
		Objects.requireNonNull(listener, "The argument 'listener' must not be null.");
		Objects.requireNonNull(eventTypeFilter, "The argument 'eventTypeFilter' must not be null.");

		return new DefaultWebViewHyperlinkListenerHandle(
				webView, listener, eventTypeFilter, new DomEventConverter());
	}

#end
#end
#No. 184051
#File: E:\bishe\1\WebViews.java
#Comment:
	/**
	 * Indicates whether the specified DOM event can be converted to a {@link HyperlinkEvent}.
	 *
	 * @param domEvent
	 *            the DOM-{@link Event}
	 * @return true if the event's {@link Event#getType() type} has an equivalent {@link EventType EventType}
	 */

#Code:
	public static boolean canConvertToHyperlinkEvent(Event domEvent) {
		return StaticDomEventConverter.canConvertToHyperlinkEvent(domEvent);
	}

#end
#end
#No. 184052
#File: E:\bishe\1\WebViews.java
#Comment:
	/**
	 * Converts the specified DOM event to a hyperlink event.
	 *
	 * @param domEvent
	 *            the DOM-{@link Event} from which the {@link HyperlinkEvent} will be created
	 * @param source
	 *            the source of the {@code domEvent}
	 * @return a {@link HyperlinkEvent}
	 * @throws IllegalArgumentException
	 *             if the specified event can not be converted to a hyperlink event; this is the case if
	 *             {@link #canConvertToHyperlinkEvent(Event)} returns false
	 */

#Code:
	public static HyperlinkEvent convertToHyperlinkEvent(Event domEvent, Object source)
			throws IllegalArgumentException {

		return StaticDomEventConverter.convertToHyperlinkEvent(domEvent, source);
	}

#end
#end
#No. 184053
#File: E:\bishe\1\WebViews.java
#Comment:
	/**
	 * Returns a string representation of the specified event.
	 *
	 * @param event
	 *            the {@link HyperlinkEvent} which will be converted to a string
	 * @return a string representation of the event
	 */

#Code:
	public static String hyperlinkEventToString(HyperlinkEvent event) {
		Objects.requireNonNull(event, "The parameter 'event' must not be null.");

		return "HyperlinkEvent ["
				+ "type: "
				+ event.getEventType()
				+ "; "
				+ "URL (description): "
				+ event.getURL()
				+ " ("
				+ event.getDescription()
				+ "); "
				+ "source: "
				+ event.getSource()
				+ "; "
				+ "source element: "
				+ event.getSourceElement()
				+ "]";
	}

#end
#end
#No. 184054
#File: E:\bishe\1\WebViews.java
#Comment:
	/**
	 * Returns a string representation of the specified event.
	 *
	 * @param event
	 *            the DOM-{@link Event} which will be converted to a string
	 * @return a string representation of the event
	 */

#Code:
	public static String domEventToString(Event event) {
		Objects.requireNonNull(event, "The parameter 'event' must not be null.");

		return "DOM-Event ["
				+ "target: "
				+ event.getTarget()
				+ "; "
				+ "type: "
				+ event.getType()
				+ "; "
				+ "time stamp: "
				+ event.getTimeStamp()
				+ "; "
				+ "bubbles: "
				+ event.getBubbles()
				+ "; "
				+ "cancelable: "
				+ event.getCancelable()
				+ "]";
	}

#end
#end
#No. 184055
#File: E:\bishe\1\WebViewSoundCloudAuthenticator.java
#Comment:
    /**
     * Creates a new SoundCloudAuthenticator.
     *
     * @param clientId    Client ID of the application requesting authorization.
     * @param redirectUri Redirect URI of the application requesting authorization
     */

#Code:
    public WebViewSoundCloudAuthenticator(String clientId, String redirectUri, Activity context, int requestCode) {
        super(clientId, redirectUri);

        this.context = context;
        this.requestCode = requestCode;
    }


#end
#end
#No. 184057
#File: E:\bishe\1\WebxmlTopicReader.java
#Comment:
  /**
   * Read topics of TREC Web Tracks from 2009 to 2014 including:
   * topics.web.1-50.txt
   * topics.web.51-100.txt
   * topics.web.101-150.txt
   * topics.web.151-200.txt
   * topics.web.201-250.txt
   * topics.web.251-300.txt
   * @return SortedMap where keys are query/topic IDs and values are title portions of the topics
   * @throws IOException
   */

#Code:
  @Override
  public SortedMap<Integer, String> read() throws IOException {
    SortedMap<Integer, String> map = new TreeMap<>();
    List<String> lines = Files.readAllLines(topicFile, StandardCharsets.UTF_8);

    String number = "";
    String query = "";

    for (String line : lines) {
      line = line.trim();
      if (line.startsWith("<topic"))
        number = extract(line, "number");
      if (line.startsWith("<query>") && line.endsWith("</query>"))
        query = line.substring(7, line.length() - 8).trim();
      if (line.startsWith("</topic>"))
        map.put(Integer.parseInt(number), query);
    }

    lines.clear();
    return map;
  }

#end
#end
#No. 184145
#File: E:\bishe\1\WeekListView.java
#Comment:
    /**
     * Enable snapping behaviour for this recyclerView
     *
     * @param enabled enable or disable the snapping behaviour
     */

#Code:
    public void setSnapEnabled(boolean enabled) {
        if (enabled) {
            addOnScrollListener(mScrollListener);
        } else {
            removeOnScrollListener(mScrollListener);
        }
    }

#end
#end
#No. 184146
#File: E:\bishe\1\WeeklyTrendsList.java
#Comment:
/**
 * Holder of a list of weekly trends.
 *
 * @author Craig Walls
 * @author Antoine Sabot-Durand
 */

#Code:
@JsonIgnoreProperties(ignoreUnknown = true)
class WeeklyTrendsList extends AbstractTrendsList {

    @JsonCreator
    public WeeklyTrendsList(@JsonProperty("trends") Map<String, List<Trend>> trends) {
        super(trends, new SimpleDateFormat("yyyy-MM-dd"));
    }

#end
#end
#No. 184147
#File: E:\bishe\1\WeekPagerAdapter.java
#Comment:
        /*
         * Necessary because of how Calendar handles getting the first day of week internally.
         */

#Code:
        private CalendarDay getFirstDayOfWeek(@NonNull CalendarDay min, int wantedFirstDayOfWeek) {
            Calendar calendar = Calendar.getInstance();
            min.copyTo(calendar);
            while (calendar.get(Calendar.DAY_OF_WEEK) != wantedFirstDayOfWeek) {
                calendar.add(Calendar.DAY_OF_WEEK, -1);
            }


#end
#end
#No. 184149
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get event loader in the week view. Event loaders define the  interval after which the events
     * are loaded in week view. For a MonthLoader events are loaded for every month. You can define
     * your custom event loader by extending WeekViewLoader.
     * @return The event loader.
     */

#Code:
    public WeekViewLoader getWeekViewLoader(){
        return mWeekViewLoader;
    }

#end
#end
#No. 184150
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set event loader in the week view. For example, a MonthLoader. Event loaders define the
     * interval after which the events are loaded in week view. For a MonthLoader events are loaded
     * for every month. You can define your custom event loader by extending WeekViewLoader.
     * @param loader The event loader.
     */

#Code:
    public void setWeekViewLoader(WeekViewLoader loader){
        this.mWeekViewLoader = loader;
    }

#end
#end
#No. 184151
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get the interpreter which provides the text to show in the header column and the header row.
     * @return The date, time interpreter.
     */

#Code:
    public DateTimeInterpreter getDateTimeInterpreter() {
        if (mDateTimeInterpreter == null) {
            mDateTimeInterpreter = new DateTimeInterpreter() {
                @Override
                public String interpretDate(Calendar date) {
                    try {
                        SimpleDateFormat sdf = mDayNameLength == LENGTH_SHORT ? new SimpleDateFormat("EEEEE M/dd", Locale.getDefault()) : new SimpleDateFormat("EEE M/dd", Locale.getDefault());
                        return sdf.format(date.getTime()).toUpperCase();
                    } catch (Exception e) {
                        e.printStackTrace();
                        return "";
                    }
                }

                @Override
                public String interpretTime(int hour) {
                    Calendar calendar = Calendar.getInstance();
                    calendar.set(Calendar.HOUR_OF_DAY, hour);
                    calendar.set(Calendar.MINUTE, 0);

                    try {
                        SimpleDateFormat sdf = DateFormat.is24HourFormat(getContext()) ? new SimpleDateFormat("HH:mm", Locale.getDefault()) : new SimpleDateFormat("hh a", Locale.getDefault());
                        return sdf.format(calendar.getTime());
                    } catch (Exception e) {
                        e.printStackTrace();
                        return "";
                    }
                }
            };
        }
        return mDateTimeInterpreter;
    }

#end
#end
#No. 184152
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set the interpreter which provides the text to show in the header column and the header row.
     * @param dateTimeInterpreter The date, time interpreter.
     */

#Code:
    public void setDateTimeInterpreter(DateTimeInterpreter dateTimeInterpreter){
        this.mDateTimeInterpreter = dateTimeInterpreter;

        // Refresh time column width.
        initTextTimeWidth();
    }

#end
#end
#No. 184153
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get the number of visible days in a week.
     * @return The number of visible days in a week.
     */

#Code:
    public int getNumberOfVisibleDays() {
        return mNumberOfVisibleDays;
    }

#end
#end
#No. 184154
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set the number of visible days in a week.
     * @param numberOfVisibleDays The number of visible days in a week.
     */

#Code:
    public void setNumberOfVisibleDays(int numberOfVisibleDays) {
        this.mNumberOfVisibleDays = numberOfVisibleDays;
        mCurrentOrigin.x = 0;
        mCurrentOrigin.y = 0;
        invalidate();
    }

#end
#end
#No. 184155
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set the first day of the week. First day of the week is used only when the week view is first
     * drawn. It does not of any effect after user starts scrolling horizontally.
     * <p>
     *     <b>Note:</b> This method will only work if the week view is set to display more than 6 days at
     *     once.
     * </p>
     * @param firstDayOfWeek The supported values are {@link java.util.Calendar#SUNDAY},
     * {@link java.util.Calendar#MONDAY}, {@link java.util.Calendar#TUESDAY},
     * {@link java.util.Calendar#WEDNESDAY}, {@link java.util.Calendar#THURSDAY},
     * {@link java.util.Calendar#FRIDAY}.
     */

#Code:
    public void setFirstDayOfWeek(int firstDayOfWeek) {
        mFirstDayOfWeek = firstDayOfWeek;
        invalidate();
    }


#end
#end
#No. 184157
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set the length of the day name displayed in the header row. Example of short day names is
     * 'M' for 'Monday' and example of long day names is 'Mon' for 'Monday'.
     * <p>
     *     <b>Note:</b> Use {@link #setDateTimeInterpreter(DateTimeInterpreter)} instead.
     * </p>
     * @param length Supported values are {@link com.alamkanak.weekview.WeekView#LENGTH_SHORT} and
     * {@link com.alamkanak.weekview.WeekView#LENGTH_LONG}.
     */

#Code:
    @Deprecated
    public void setDayNameLength(int length) {
        if (length != LENGTH_LONG && length != LENGTH_SHORT) {
            throw new IllegalArgumentException("length parameter must be either LENGTH_LONG or LENGTH_SHORT");
        }
        this.mDayNameLength = length;
    }

#end
#end
#No. 184158
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set the gap between overlapping events.
     * @param overlappingEventGap The gap between overlapping events.
     */

#Code:
    public void setOverlappingEventGap(int overlappingEventGap) {
        this.mOverlappingEventGap = overlappingEventGap;
        invalidate();
    }

#end
#end
#No. 184159
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set corner radius for event rect.
     *
     * @param eventCornerRadius the radius in px.
     */

#Code:
    public void setEventCornerRadius(int eventCornerRadius) {
        mEventCornerRadius = eventCornerRadius;
    }

#end
#end
#No. 184160
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set the top and bottom margin of the event. The event will release this margin from the top
     * and bottom edge. This margin is useful for differentiation consecutive events.
     * @param eventMarginVertical The top and bottom margin.
     */

#Code:
    public void setEventMarginVertical(int eventMarginVertical) {
        this.mEventMarginVertical = eventMarginVertical;
        invalidate();
    }

#end
#end
#No. 184161
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Returns the first visible day in the week view.
     * @return The first visible day in the week view.
     */

#Code:
    public Calendar getFirstVisibleDay() {
        return mFirstVisibleDay;
    }

#end
#end
#No. 184162
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Returns the last visible day in the week view.
     * @return The last visible day in the week view.
     */

#Code:
    public Calendar getLastVisibleDay() {
        return mLastVisibleDay;
    }

#end
#end
#No. 184163
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get the scrolling speed factor in horizontal direction.
     * @return The speed factor in horizontal direction.
     */

#Code:
    public float getXScrollingSpeed() {
        return mXScrollingSpeed;
    }

#end
#end
#No. 184164
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Sets the speed for horizontal scrolling.
     * @param xScrollingSpeed The new horizontal scrolling speed.
     */

#Code:
    public void setXScrollingSpeed(float xScrollingSpeed) {
        this.mXScrollingSpeed = xScrollingSpeed;
    }

#end
#end
#No. 184165
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Whether weekends should have a background color different from the normal day background
     * color. The weekend background colors are defined by the attributes
     * `futureWeekendBackgroundColor` and `pastWeekendBackgroundColor`.
     * @return True if weekends should have different background colors.
     */

#Code:
    public boolean isShowDistinctWeekendColor() {
        return mShowDistinctWeekendColor;
    }

#end
#end
#No. 184166
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set whether weekends should have a background color different from the normal day background
     * color. The weekend background colors are defined by the attributes
     * `futureWeekendBackgroundColor` and `pastWeekendBackgroundColor`.
     * @param showDistinctWeekendColor True if weekends should have different background colors.
     */

#Code:
    public void setShowDistinctWeekendColor(boolean showDistinctWeekendColor) {
        this.mShowDistinctWeekendColor = showDistinctWeekendColor;
        invalidate();
    }

#end
#end
#No. 184167
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Whether past and future days should have two different background colors. The past and
     * future day colors are defined by the attributes `futureBackgroundColor` and
     * `pastBackgroundColor`.
     * @return True if past and future days should have two different background colors.
     */

#Code:
    public boolean isShowDistinctPastFutureColor() {
        return mShowDistinctPastFutureColor;
    }

#end
#end
#No. 184168
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set whether weekends should have a background color different from the normal day background
     * color. The past and future day colors are defined by the attributes `futureBackgroundColor`
     * and `pastBackgroundColor`.
     * @param showDistinctPastFutureColor True if past and future should have two different
     *                                    background colors.
     */

#Code:
    public void setShowDistinctPastFutureColor(boolean showDistinctPastFutureColor) {
        this.mShowDistinctPastFutureColor = showDistinctPastFutureColor;
        invalidate();
    }

#end
#end
#No. 184169
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get whether "now" line should be displayed. "Now" line is defined by the attributes
     * `nowLineColor` and `nowLineThickness`.
     * @return True if "now" line should be displayed.
     */

#Code:
    public boolean isShowNowLine() {
        return mShowNowLine;
    }

#end
#end
#No. 184170
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set whether "now" line should be displayed. "Now" line is defined by the attributes
     * `nowLineColor` and `nowLineThickness`.
     * @param showNowLine True if "now" line should be displayed.
     */

#Code:
    public void setShowNowLine(boolean showNowLine) {
        this.mShowNowLine = showNowLine;
        invalidate();
    }

#end
#end
#No. 184171
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get the "now" line color.
     * @return The color of the "now" line.
     */

#Code:
    public int getNowLineColor() {
        return mNowLineColor;
    }

#end
#end
#No. 184172
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set the "now" line color.
     * @param nowLineColor The color of the "now" line.
     */

#Code:
    public void setNowLineColor(int nowLineColor) {
        this.mNowLineColor = nowLineColor;
        invalidate();
    }

#end
#end
#No. 184173
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get the "now" line thickness.
     * @return The thickness of the "now" line.
     */

#Code:
    public int getNowLineThickness() {
        return mNowLineThickness;
    }

#end
#end
#No. 184174
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set the "now" line thickness.
     * @param nowLineThickness The thickness of the "now" line.
     */

#Code:
    public void setNowLineThickness(int nowLineThickness) {
        this.mNowLineThickness = nowLineThickness;
        invalidate();
    }

#end
#end
#No. 184175
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get whether the week view should fling horizontally.
     * @return True if the week view has horizontal fling enabled.
     */

#Code:
    public boolean isHorizontalFlingEnabled() {
        return mHorizontalFlingEnabled;
    }

#end
#end
#No. 184176
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set whether the week view should fling horizontally.
     * @return True if it should have horizontal fling enabled.
     */

#Code:
    public void setHorizontalFlingEnabled(boolean enabled) {
        mHorizontalFlingEnabled = enabled;
    }

#end
#end
#No. 184177
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get whether the week view should fling vertically.
     * @return True if the week view has vertical fling enabled.
     */

#Code:
    public boolean isVerticalFlingEnabled() {
        return mVerticalFlingEnabled;
    }

#end
#end
#No. 184178
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set whether the week view should fling vertically.
     * @return True if it should have vertical fling enabled.
     */

#Code:
    public void setVerticalFlingEnabled(boolean enabled) {
        mVerticalFlingEnabled = enabled;
    }

#end
#end
#No. 184179
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get the height of AllDay-events.
     * @return Height of AllDay-events.
     */

#Code:
    public int getAllDayEventHeight() {
        return mAllDayEventHeight;
    }

#end
#end
#No. 184180
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set the height of AllDay-events.
     */

#Code:
    public void setAllDayEventHeight(int height) {
        mAllDayEventHeight = height;
    }

#end
#end
#No. 184181
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get scroll duration
     * @return scroll duration
     */

#Code:
    public int getScrollDuration() {
        return mScrollDuration;
    }

#end
#end
#No. 184182
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Set the scroll duration
     */

#Code:
    public void setScrollDuration(int scrollDuration) {
        mScrollDuration = scrollDuration;
    }

#end
#end
#No. 184183
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Check if scrolling should be stopped.
     * @return true if scrolling should be stopped before reaching the end of animation.
     */

#Code:
    private boolean forceFinishScroll() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
            // current velocity only available since api 14
            return mScroller.getCurrVelocity() <= mMinimumFlingVelocity;
        } else {
            return false;
        }
    }

#end
#end
#No. 184184
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Show today on the week view.
     */

#Code:
    public void goToToday() {
        Calendar today = Calendar.getInstance();
        goToDate(today);
    }

#end
#end
#No. 184185
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Show a specific day on the week view.
     * @param date The date to show.
     */

#Code:
    public void goToDate(Calendar date) {
        mScroller.forceFinished(true);
        mCurrentScrollDirection = mCurrentFlingDirection = Direction.NONE;

        date.set(Calendar.HOUR_OF_DAY, 0);
        date.set(Calendar.MINUTE, 0);
        date.set(Calendar.SECOND, 0);
        date.set(Calendar.MILLISECOND, 0);

        if(mAreDimensionsInvalid) {
            mScrollToDay = date;
            return;
        }

        mRefreshEvents = true;

        Calendar today = Calendar.getInstance();
        today.set(Calendar.HOUR_OF_DAY, 0);
        today.set(Calendar.MINUTE, 0);
        today.set(Calendar.SECOND, 0);
        today.set(Calendar.MILLISECOND, 0);

        long day = 1000L * 60L * 60L * 24L;
        long dateInMillis = date.getTimeInMillis() + date.getTimeZone().getOffset(date.getTimeInMillis());
        long todayInMillis = today.getTimeInMillis() + today.getTimeZone().getOffset(today.getTimeInMillis());
        long dateDifference = (dateInMillis/day) - (todayInMillis/day);
        mCurrentOrigin.x = - dateDifference * (mWidthPerDay + mColumnGap);
        invalidate();
    }

#end
#end
#No. 184186
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Refreshes the view and loads the events again.
     */

#Code:
    public void notifyDatasetChanged(){
        mRefreshEvents = true;
        invalidate();
    }

#end
#end
#No. 184187
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Vertically scroll to a specific hour in the week view.
     * @param hour The hour to scroll to in 24-hour format. Supported values are 0-24.
     */

#Code:
    public void goToHour(double hour){
        if (mAreDimensionsInvalid) {
            mScrollToHour = hour;
            return;
        }

        int verticalOffset = 0;
        if (hour > 24)
            verticalOffset = mHourHeight * 24;
        else if (hour > 0)
            verticalOffset = (int) (mHourHeight * hour);

        if (verticalOffset > mHourHeight * 24 - getHeight() + mHeaderHeight + mHeaderRowPadding * 2 + mHeaderMarginBottom)
            verticalOffset = (int)(mHourHeight * 24 - getHeight() + mHeaderHeight + mHeaderRowPadding * 2 + mHeaderMarginBottom);

        mCurrentOrigin.y = -verticalOffset;
        invalidate();
    }

#end
#end
#No. 184188
#File: E:\bishe\1\WeekView.java
#Comment:
    /**
     * Get the first hour that is visible on the screen.
     * @return The first hour that is visible.
     */

#Code:
    public double getFirstVisibleHour(){
        return -mCurrentOrigin.y / mHourHeight;
    }



#end
#end
#No. 184191
#File: E:\bishe\1\WeekViewUtil.java
#Comment:
    /**
     * Checks if two times are on the same day.
     * @param dayOne The first day.
     * @param dayTwo The second day.
     * @return Whether the times are on the same day.
     */

#Code:
    public static boolean isSameDay(Calendar dayOne, Calendar dayTwo) {
        return dayOne.get(Calendar.YEAR) == dayTwo.get(Calendar.YEAR) && dayOne.get(Calendar.DAY_OF_YEAR) == dayTwo.get(Calendar.DAY_OF_YEAR);
    }

#end
#end
#No. 184192
#File: E:\bishe\1\WeekViewUtil.java
#Comment:
    /**
     * Returns a calendar instance at the start of this day
     * @return the calendar instance
     */

#Code:
    public static Calendar today(){
        Calendar today = Calendar.getInstance();
        today.set(Calendar.HOUR_OF_DAY, 0);
        today.set(Calendar.MINUTE, 0);
        today.set(Calendar.SECOND, 0);
        today.set(Calendar.MILLISECOND, 0);
        return today;
    }


#end
#end
#No. 184195
#File: E:\bishe\1\WeexPerTestCaseListPerfWithAppendTree.java
#Comment:
    /**
     * get tc list by text
     * @param byText
     * @return
     * @throws InterruptedException
     */

#Code:
    public ArrayList<View> getTestCaseListViewByText(String byText) throws InterruptedException {
        Log.e("TestScript_Guide", "byText ==" + byText);

        if(TextUtils.isEmpty(byText)){
            return null;
        }
        ArrayList<View> outViews = new ArrayList<View>();

        mViewGroup.findViewsWithText(outViews, byText, View.FIND_VIEWS_WITH_TEXT);
        sleep(2000);

        for (View view :  outViews){
            String viewText = ((TextView)view).getText().toString();
            Log.e(TAG, "viewText ==" + viewText);


        }
        return outViews;
    }

#end
#end
#No. 184199
#File: E:\bishe\1\WeexUiTestCaseTCAHrefEvent.java
#Comment:
    /**
     * get tc list by text
     * @param byText
     * @return
     * @throws InterruptedException
     */

#Code:
    public ArrayList<View> getTestCaseListViewByText(String byText) throws InterruptedException {
        Log.e("TestScript_Guide", "byText ==" + byText);

        if(TextUtils.isEmpty(byText)){
            return null;
        }
        ArrayList<View> outViews = new ArrayList<View>();

        mViewGroup.findViewsWithText(outViews, byText, View.FIND_VIEWS_WITH_TEXT);

        for (View view :  outViews){
            String viewText = ((WXTextView)view).getText().toString();
            Log.e(TAG, "viewText ==" + viewText);


        }
        return outViews;
    }

#end
#end
#No. 184200
#File: E:\bishe\1\WeexUiTestCaseTCAHrefEvent.java
#Comment:
    /**
     * findMyCaseByText
     */

#Code:
    public View findMyCaseByText(String caseText){
        if (mCaseListIndexView.size() == 0) return null;

        WXTextView view = null;
        for(int i=0; i<mCaseListIndexView.size();i++){

            view = (WXTextView)mCaseListIndexView.get(i);

            if (view.getText().toString().toLowerCase().contains(caseText.toLowerCase())){
                return view;
            }

        }
        return view;
    }

#end
#end
#No. 184201
#File: E:\bishe\1\WeexUiTestCaseTCAHrefEvent.java
#Comment:
    /**
     * sleep
     */

#Code:
    public void sleep(long time){
        try {
            Thread.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

#end
#end
#No. 184202
#File: E:\bishe\1\WeexUiTestCaseTCAHrefEvent.java
#Comment:
    /**
     * snapshot
     */

#Code:
    public void screenShot(String shotName) {
        try {
            ScreenShot.shoot(WXPageActivity.wxPageActivityInstance, shotName);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

#end
#end
#No. 184203
#File: E:\bishe\1\WeexUiTestCaseTCAHrefStyle.java
#Comment:
    /**
     * get tc list by text
     * @param byText
     * @return
     * @throws InterruptedException
     */

#Code:
    public ArrayList<View> getTestCaseListViewByText(String byText) throws InterruptedException {
        Log.e("TestScript_Guide", "byText ==" + byText);

        if(TextUtils.isEmpty(byText)){
            return null;
        }
        ArrayList<View> outViews = new ArrayList<View>();

        mViewGroup.findViewsWithText(outViews, byText, View.FIND_VIEWS_WITH_TEXT);

        for (View view :  outViews){
            String viewText = ((WXTextView)view).getText().toString();
            Log.e(TAG, "viewText ==" + viewText);


        }
        return outViews;
    }

#end
#end
#No. 184204
#File: E:\bishe\1\WeexUiTestCaseTCAHrefStyle.java
#Comment:
    /**
     * findMyCaseByText
     */

#Code:
    public View findMyCaseByText(String caseText){
        if (mCaseListIndexView.size() == 0) return null;

        WXTextView view = null;
        for(int i=0; i<mCaseListIndexView.size();i++){

            view = (WXTextView)mCaseListIndexView.get(i);

            if (view.getText().toString().toLowerCase().contains(caseText.toLowerCase())){
                return view;
            }

        }
        return view;
    }

#end
#end
#No. 184205
#File: E:\bishe\1\WeexUiTestCaseTCAHrefStyle.java
#Comment:
    /**
     * sleep
     */

#Code:
    public void sleep(long time){
        try {
            Thread.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

#end
#end
#No. 184206
#File: E:\bishe\1\WeexUiTestCaseTCAHrefStyle.java
#Comment:
    /**
     * snapshot
     */

#Code:
    public void screenShot(String shotName) {
        try {
            ScreenShot.shoot(WXPageActivity.wxPageActivityInstance, shotName);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

#end
#end
#No. 184207
#File: E:\bishe\1\WeexUiTestCaseTCAHrefUpdate.java
#Comment:
    /**
     * get tc list by text
     * @param byText
     * @return
     * @throws InterruptedException
     */

#Code:
    public ArrayList<View> getTestCaseListViewByText(String byText) throws InterruptedException {
        Log.e("TestScript_Guide", "byText ==" + byText);

        if(TextUtils.isEmpty(byText)){
            return null;
        }
        ArrayList<View> outViews = new ArrayList<View>();

        mViewGroup.findViewsWithText(outViews, byText, View.FIND_VIEWS_WITH_TEXT);

        for (View view :  outViews){
            String viewText = ((WXTextView)view).getText().toString();
            Log.e(TAG, "viewText ==" + viewText);


        }
        return outViews;
    }

#end
#end
#No. 184208
#File: E:\bishe\1\WeexUiTestCaseTCAHrefUpdate.java
#Comment:
    /**
     * findMyCaseByText
     */

#Code:
    public View findMyCaseByText(String caseText){
        if (mCaseListIndexView.size() == 0) return null;

        WXTextView view = null;
        for(int i=0; i<mCaseListIndexView.size();i++){

            view = (WXTextView)mCaseListIndexView.get(i);

            if (view.getText().toString().toLowerCase().contains(caseText.toLowerCase())){
                return view;
            }

        }
        return view;
    }

#end
#end
#No. 184295
#File: E:\bishe\1\Weibo.java
#Comment:
    /**
     * Executes the request and returns PluginResult.
     *
     * @param action
     *            The action to execute.
     * @param args
     *            JSONArry of arguments for the plugin.
     * @param callbackContext
     *            The callback id used when calling back into JavaScript.
     * @return True if the action was valid, false if not.
     */

#Code:
    @Override
    public boolean execute(String action, JSONArray args,
            CallbackContext callbackContext) throws JSONException {
        mCallbackContext = callbackContext;
        if (action.equals(TAG_WEIBO_LOGIN)) {
            try {
                weiboLogin(args.getString(0), args.getString(1));
            } catch (JSONException e) {
                mCallbackContext.error(e.getMessage());
                return false;
            }
        } else {
            return false;
        }
        return true;
    }


#end
#end
#No. 184311
#File: E:\bishe\1\Weibull.java
#Comment:
/*
  weibull(x) = exp(a*(x)^k + b)
  default max x is Double.MAX_VALUE
 */

#Code:
@Slf4j @Builder public class Weibull {
  final private double k, a, b, maxX;

  public WeibullBuilder defaultBuilder() {
    return Weibull.builder().maxX(Double.MAX_VALUE);
  }

#end
#end
#No. 184312
#File: E:\bishe\1\Weibull.java
#Comment:
  /*
     weibull(x) = exp(a*(x)^k + b)
     given value of weibull(x), return x
   */

#Code:
  public double getXWithOutput(double output) {
    // Below are the logic to compute the x:
    //    val t = (Math.log(p) - b) / a
    //    if (t > 0) ratio = math.min(math.pow(t, 1.0 / k), 2)
    //    else x = 0.0
    if (Math.abs(a) < 1e-10) {
      if (b > Math.log(output)) {
        return maxX;
      } else {
        return 0.0;
      }
    }

    // a is not too small.
    double t = (Math.log(output) - b) / a;
    log.debug("k = {}, a = {}, b = {}, t = {}", k, a, b, t);
    if (t > 0) {
      return Math.min(Math.pow(t, 1.0/k), maxX);
    } else {
      return 0.0;
    }
  }


#end
#end
#No. 184315
#File: E:\bishe\1\WeightedComparator.java
#Comment:
/**
 * Compares {@link Weighted} objects.
 * 
 * @author <a href="mailto:lincolnbaxter@gmail.com">Lincoln Baxter, III</a>
 * 
 */

#Code:
public enum WeightedComparator implements Comparator<Weighted>
{
   INSTANCE;

   @Override
   public int compare(final Weighted left, final Weighted right)
   {
      if ((left == null) || (right == null))
      {
         return 0;
      }
      int thisVal = left.priority();
      int anotherVal = right.priority();
      return (thisVal < anotherVal ? -1 : (thisVal == anotherVal ? 0 : 1));
   }

}

#end
#end
#No. 184318
#File: E:\bishe\1\WeightedMediaType.java
#Comment:
   /**
    * Non-equal properties should not be compatible
    */

#Code:
   @Override
   public boolean isCompatible(MediaType other)
   {
      boolean result;
      if (other == null)
         result = false;
      if (getType().equals(MEDIA_TYPE_WILDCARD) || other.getType().equals(MEDIA_TYPE_WILDCARD))
         result = true;
      else if (getType().equalsIgnoreCase(other.getType()) && (getSubtype().equals(MEDIA_TYPE_WILDCARD) || other.getSubtype().equals(MEDIA_TYPE_WILDCARD)))
         result = true;
      else
      {
         if (getType().equalsIgnoreCase(other.getType())
                 && this.getSubtype().equalsIgnoreCase(other.getSubtype()))
         {
            if (getParameters() == null || getParameters().size() == 0)
            {
               result = true;
            }
            else
            {
               result = this.equals(other);
            }
         }
         else
         {
            result = false;
         }
      }
      return result;
   }

#end
#end
#No. 184319
#File: E:\bishe\1\WeightedMultigraph.java
#Comment:
/**
 * A weighted multigraph. A weighted multigraph is a non-simple undirected graph
 * in which no loops are permitted, but multiple edges between any two vertices
 * are. The edges of a weighted multigraph have weights. If you're unsure about
 * multigraphs, see: <a href="http://mathworld.wolfram.com/Multigraph.html">
 * http://mathworld.wolfram.com/Multigraph.html</a>.
 */

#Code:
public class WeightedMultigraph<V, E>
    extends Multigraph<V, E>
    implements WeightedGraph<V, E>
{
    

    private static final long serialVersionUID = 3544671793370640696L;

    

    /**
     * Creates a new weighted multigraph with the specified edge factory.
     *
     * @param ef the edge factory of the new graph.
     */
    public WeightedMultigraph(EdgeFactory<V, E> ef)
    {
        super(ef);
    }

    /**
     * Creates a new weighted multigraph.
     *
     * @param edgeClass class on which to base factory for edges
     */
    public WeightedMultigraph(Class<? extends E> edgeClass)
    {
        this(new ClassBasedEdgeFactory<V, E>(edgeClass));
    }
}

#end
#end
#No. 184320
#File: E:\bishe\1\WeightedPredictionComputationStrategy.java
#Comment:
    /**
     * Creates a mapping of item IDs for which the user has rated to the ratings of the user
     *
     * @param userId The user to create the mapping for.
     * @return The mapping itemId -> RatingVO.
     */

#Code:
    private Map<Integer, RatingVO<Integer, Integer>> getRatingsOfUserMap(final Integer userId) {
        final List<RatingVO<Integer, Integer>> ratingsOfUser = actionDao
                .getLatestRatingsForTenant(sample.getTenantId(), sample.getItemTo().getType(), null, userId, null);
        final Map<Integer, RatingVO<Integer, Integer>> ratingsOfUserMap = new HashMap<Integer, RatingVO<Integer, Integer>>();

        for (final RatingVO<Integer, Integer> rating : ratingsOfUser) {
            if (ratingsOfUserMap.containsKey(rating.getItem().getItem())) {
                if (logger.isWarnEnabled()) logger.warn("The user should have only voted once for the same item.");

                continue;
            }

            ratingsOfUserMap.put(rating.getItem().getItem(), rating);
        }
        return ratingsOfUserMap;
    }

#end
#end
#No. 184321
#File: E:\bishe\1\WeightedPseudograph.java
#Comment:
/**
 * A weighted pseudograph. A weighted pseudograph is a non-simple undirected
 * graph in which both graph loops and multiple edges are permitted. The edges
 * of a weighted pseudograph have weights. If you're unsure about pseudographs,
 * see: <a href="http://mathworld.wolfram.com/Pseudograph.html">
 * http://mathworld.wolfram.com/Pseudograph.html</a>.
 */

#Code:
public class WeightedPseudograph<V, E>
    extends Pseudograph<V, E>
    implements WeightedGraph<V, E>
{
    

    private static final long serialVersionUID = 3257290244524356152L;

    

    /**
     * Creates a new weighted pseudograph with the specified edge factory.
     *
     * @param ef the edge factory of the new graph.
     */
    public WeightedPseudograph(EdgeFactory<V, E> ef)
    {
        super(ef);
    }

    /**
     * Creates a new weighted pseudograph.
     *
     * @param edgeClass class on which to base factory for edges
     */
    public WeightedPseudograph(Class<? extends E> edgeClass)
    {
        this(new ClassBasedEdgeFactory<V, E>(edgeClass));
    }
}



#end
#end
#No. 184324
#File: E:\bishe\1\WeightedReservoirSamplerTest.java
#Comment:
    /**
     * Tests the weighted reservoir sampling
     * @throws Exception
     */

#Code:
    @Test
    public void testRandomChoice() throws Exception {
        WeightedReservoirSampler sampler = new WeightedReservoirSampler();
        List<Integer> weights = new ArrayList<>(Arrays.asList(5,10,15,20));
        List<Integer> omit    = new ArrayList<>(Arrays.asList(0,2));

//        for (int i = 0; i < 100; ++i)
//            System.out.println("random choice: " + sampler.randomIndexChoice(weights, 2));

    }


#end
#end
#No. 184326
#File: E:\bishe\1\WeightInfoOperationType.java
#Comment:
/**
 * @author yael nahon
 * @since 12.1
 */

#Code:
public enum WeightInfoOperationType {
    WRITE, UPDATE, TAKE, CHANGE, NOTIFY, PREPARE;
}

#end
#end
#No. 184327
#File: E:\bishe\1\Weightings.java
#Comment:
    /**
     * @return Strategy that provides a uniform weight to each client
     */

#Code:
    public static <C> WeightingStrategy<C> uniform() {
        return new EqualWeightStrategy<C>();
    }

#end
#end
#No. 184328
#File: E:\bishe\1\Weightings.java
#Comment:
    /**
     * @param func
     * @return Strategy that uses the output of the function as the weight
     */

#Code:
    public static <C> WeightingStrategy<C> identity(Func1<C, Integer> func) {
        return new LinearWeightingStrategy<C>(func);
    }

#end
#end
#No. 184329
#File: E:\bishe\1\Weightings.java
#Comment:
    /**
     * @param func
     * @return Strategy that sets the weight to the difference between the max
     *  value of all clients and the client value.
     */

#Code:
    public static <C> WeightingStrategy<C> inverseMax(Func1<C, Integer> func) {
        return new InverseMaxWeightingStrategy<C>(func);
    }


#end
#end
#No. 184331
#File: E:\bishe\1\WeightLogs.java
#Comment:
    /**
     * @return The weight
     */

#Code:
    public List<Weight> getWeight() {
        return weight;
    }

#end
#end
#No. 184332
#File: E:\bishe\1\WeightLogs.java
#Comment:
    /**
     * @param weight The weight
     */

#Code:
    public void setWeight(List<Weight> weight) {
        this.weight = weight;
    }


#end
#end
#No. 184336
#File: E:\bishe\1\WeightsHistory.java
#Comment:
    /**
     * This method creates a dataset object to be able to insert data in google fit
     * @param dataType DataType Fitness Data Type object
     * @param dataSourceType int Data Source Id. For example, DataSource.TYPE_RAW
     * @param value Object Values for the fitness data. They must be int or float
     * @param startTime long Time when the fitness activity started
     * @param endTime long Time when the fitness activity finished
     * @param timeUnit TimeUnit Time unit in which period is expressed
     * @return
     */

#Code:
    private DataSet createDataForRequest(DataType dataType, int dataSourceType, Double value,
                                         long startTime, long endTime, TimeUnit timeUnit) {
        DataSource dataSource = new DataSource.Builder()
                .setAppPackageName(GoogleFitPackage.PACKAGE_NAME)
                .setDataType(dataType)
                .setType(dataSourceType)
                .build();

        DataSet dataSet = DataSet.create(dataSource);
        DataPoint dataPoint = dataSet.createDataPoint().setTimeInterval(startTime, endTime, timeUnit);

        float f1 = Float.valueOf(value.toString());
        dataPoint = dataPoint.setFloatValues(f1);

        dataSet.add(dataPoint);

        return dataSet;
    }


#end
#end
#No. 184338
#File: E:\bishe\1\WeixinAccessGrant.java
#Comment:
	/**
	 * @return the openId
	 */

#Code:
	public String getOpenId() {
		return openId;
	}

#end
#end
#No. 184339
#File: E:\bishe\1\WeixinAccessGrant.java
#Comment:
	/**
	 * @param openId the openId to set
	 */

#Code:
	public void setOpenId(String openId) {
		this.openId = openId;
	}

#end
#end
#No. 184351
#File: E:\bishe\1\WeixinAutoConfiguration.java
#Comment:
		/**
		 * @param repository
		 * @return
		 */

#Code:
		@Bean
		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES)
		public Weixin weixin(ConnectionRepository repository) {
			Connection<Weixin> connection = repository.findPrimaryConnection(Weixin.class);
			return connection != null ? connection.getApi() : null;
		}

#end
#end
#No. 184352
#File: E:\bishe\1\WeixinAutoConfiguration.java
#Comment:
		/**
		 * @return
		 */

#Code:
		@Bean(name = { "connect/weixinConnect", "connect/weixinConnected" })
		@ConditionalOnProperty(prefix = "spring.social", name = "auto-connection-views")
		public GenericConnectionStatusView weixinConnectView() {
			return new GenericConnectionStatusView(getProviderId(), "Weixin");
		}

#end
#end
#No. 184353
#File: E:\bishe\1\WeixinAutoConfiguration.java
#Comment:
		/**
		 * @return
		 */

#Code:
		@Bean(name = { "connect/status"})
		@ConditionalOnProperty(prefix = "spring.social", name = "auto-connection-views")
		public JsonConnectView jsonConnectView() {
			return new JsonConnectView();
		}

#end
#end
#No. 184354
#File: E:\bishe\1\WeixinAutoConfiguration.java
#Comment:
		/**
		 * @return
		 */

#Code:
		protected String getProviderId() {
			String providerId = properties.getProviderId();
			if (StringUtils.isBlank(providerId)) {
				providerId = "weixin";
			}
			return providerId;
		}

#end
#end
#No. 184355
#File: E:\bishe\1\WeixinConnectionFactory.java
#Comment:
	/**
	 * @param appId
	 * @param appSecret
	 */

#Code:
	public WeixinConnectionFactory(String providerId, String appId, String appSecret) {
		super(providerId, new WeixinServiceProvider(appId, appSecret), new WeixinAdapter());
	}


#end
#end
#No. 184378
#File: E:\bishe\1\WelcomeFile.java
#Comment:
    /**
     * Gets the value of the id property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

#Code:
    public String getId() {
        return id;
    }

#end
#end
#No. 184379
#File: E:\bishe\1\WelcomeFile.java
#Comment:
    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

#Code:
    public void setId(String value) {
        try {
            support.fireVetoableChange("Id",id, value);
        } catch (PropertyVetoException _x) {
            return;
        }
        this.id = value;
    }

#end
#end
#No. 184380
#File: E:\bishe\1\WelcomeFile.java
#Comment:
    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */

#Code:
    public String getvalue() {
        return value;
    }

#end
#end
#No. 184381
#File: E:\bishe\1\WelcomeFile.java
#Comment:
    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */

#Code:
    public void setvalue(String value) {
        try {
            support.fireVetoableChange("value",value, value);
        } catch (PropertyVetoException _x) {
            return;
        }
        this.value = value;
    }


#end
#end
#No. 184394
#File: E:\bishe\1\WellKnownTypeUtils.java
#Comment:
  /**
   * @return the typeUrl corresponding to the type. Example: for string, the typeUrl is
   *     type.googleapis.com/google.protobuf.StringValue
   */

#Code:
  public static TypeInfo getTypeInfo(WellKnownType type) {
    return TypeInfo.create(type.getTypeUrl(), Kind.TYPE_MESSAGE, Cardinality.CARDINALITY_OPTIONAL);
  }

#end
#end
#No. 184395
#File: E:\bishe\1\WellKnownTypeUtils.java
#Comment:
  /**
   * @return a Kind corresponding to the JSON number type and the given format. TODO (guptasu): For
   *     all below types, ensure defaults are right. TODO (guptasu): For all below types, add errors
   *     for unknown types.
   */

#Code:
  private static Kind getNumberKind(String format) {
    if (Strings.isNullOrEmpty(format)) {
      return Kind.TYPE_DOUBLE;
    }
    switch (format) {
      case "float":
        return Kind.TYPE_FLOAT;
      case "double":
        return Kind.TYPE_DOUBLE;
      default:
        return Kind.TYPE_DOUBLE;
    }
  }

#end
#end
#No. 184396
#File: E:\bishe\1\WePayError.java
#Comment:
/**
 * Known error codes.  Because wepay might add additional codes, this is not guaranteed to be an exhaustive list.
 */

#Code:
public enum WePayError {
	invalid_request,
	access_denied,
	invalid_scope,
	invalid_client,
	processing_error;
}

#end
#end
#No. 184405
#File: E:\bishe\1\WFMKeyIterator.java
#Comment:
	/**
	 * @throws UnsupportedOperationException
	 */

#Code:
	@Override
	public void remove() {
		throw new UnsupportedOperationException();
	}



#end
#end
#No. 184409
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #type
	 */

#Code:
	public IDCType getType() {
		return XfsConstants.valueOf(type, IDCType.class);
	}

#end
#end
#No. 184410
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #type
	 */

#Code:
	public void setType(final IDCType type) {
		this.type.set(type);
	}

#end
#end
#No. 184411
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #compound
	 */

#Code:
	public boolean isCompound() {
		return compound.booleanValue();
	}

#end
#end
#No. 184412
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #compound
	 */

#Code:
	public void setCompound(final boolean compound) {
		this.compound.set(compound);
	}

#end
#end
#No. 184413
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #readTracks
	 */

#Code:
	public Set<IDCTrack> getReadTracks() {
		return XfsConstants.of(readTracks, IDCTrack.class);
	}

#end
#end
#No. 184414
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #readTracks
	 */

#Code:
	public void setReadTracks(final Set<IDCTrack> readTracks) {
		this.readTracks.set((int) Bitmask.of(readTracks));
	}

#end
#end
#No. 184415
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #writeTracks
	 */

#Code:
	public Set<IDCTrack> getWriteTracks() {
		return XfsConstants.of(writeTracks, IDCTrack.class);
	}

#end
#end
#No. 184416
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #writeTracks
	 */

#Code:
	public void setWriteTracks(final Set<IDCTrack> writeTracks) {
		this.writeTracks.set((int) Bitmask.of(writeTracks));
	}

#end
#end
#No. 184417
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #chipProtocols
	 */

#Code:
	public Set<IDCChipProtocol> getChipProtocols() {
		return XfsConstants.of(chipProtocols, IDCChipProtocol.class);
	}

#end
#end
#No. 184418
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #chipProtocols
	 */

#Code:
	public void setChipProtocols(final Set<IDCChipProtocol> chipProtocols) {
		this.chipProtocols.set((int) Bitmask.of(chipProtocols));
	}

#end
#end
#No. 184419
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #cards
	 */

#Code:
	public int getCards() {
		return cards.intValue();
	}

#end
#end
#No. 184420
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #cards
	 */

#Code:
	public void setCards(final int cards) {
		this.cards.set(cards);
	}

#end
#end
#No. 184421
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #secType
	 */

#Code:
	public IDCSecType getSecType() {
		return XfsConstants.valueOf(secType, IDCSecType.class);
	}

#end
#end
#No. 184422
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #secType
	 */

#Code:
	public void setSecType(final IDCSecType secType) {
		this.secType.set((int) secType.getValue());
	}

#end
#end
#No. 184423
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #powerOnOption
	 */

#Code:
	public IDCPowerOption getPowerOnOption() {
		return XfsConstants.valueOf(powerOnOption, IDCPowerOption.class);
	}

#end
#end
#No. 184424
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #powerOnOption
	 */

#Code:
	public void setPowerOnOption(final IDCPowerOption powerOnOption) {
		this.powerOnOption.set((int) powerOnOption.getValue());
	}

#end
#end
#No. 184425
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #powerOffOption
	 */

#Code:
	public IDCPowerOption getPowerOffOption() {
		return XfsConstants.valueOf(powerOffOption, IDCPowerOption.class);
	}

#end
#end
#No. 184426
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #powerOffOption
	 */

#Code:
	public void setPowerOffOption(final IDCPowerOption powerOffOption) {
		this.powerOffOption.set((int) powerOffOption.getValue());
	}

#end
#end
#No. 184427
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #fluxSensorProgrammable
	 */

#Code:
	public boolean isFluxSensorProgrammable() {
		return fluxSensorProgrammable.booleanValue();
	}

#end
#end
#No. 184428
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #fluxSensorProgrammable
	 */

#Code:
	public void setFluxSensorProgrammable(final boolean fluxSensorProgrammable) {
		this.fluxSensorProgrammable.set(fluxSensorProgrammable);
	}

#end
#end
#No. 184429
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #readWriteAccessFollowingEject
	 */

#Code:
	public boolean isReadWriteAccessFollowingEject() {
		return readWriteAccessFollowingEject.booleanValue();
	}

#end
#end
#No. 184430
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #readWriteAccessFollowingEject
	 */

#Code:
	public void setReadWriteAccessFollowingEject(final boolean readWriteAccessFollowingEject) {
		this.readWriteAccessFollowingEject.set(readWriteAccessFollowingEject);
	}

#end
#end
#No. 184431
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #writeMode
	 */

#Code:
	public Set<IDCWriteMethod> getWriteMode() {
		return XfsConstants.of(writeMode, IDCWriteMethod.class);
	}

#end
#end
#No. 184432
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #writeMode
	 */

#Code:
	public void setWriteMode(final Set<IDCWriteMethod> writeMode) {
		this.writeMode.set((int) Bitmask.of(writeMode));
	}

#end
#end
#No. 184433
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #chipPower
	 */

#Code:
	public Set<IDCChipPower> getChipPower() {
		return XfsConstants.of(chipPower, IDCChipPower.class);
	}

#end
#end
#No. 184434
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #chipPower
	 */

#Code:
	public void setChipPower(final Set<IDCChipPower> chipPower) {
		this.chipPower.set((int) Bitmask.of(chipPower));
	}

#end
#end
#No. 184435
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #extra
	 */

#Code:
	public Map<String, String> getExtra() {
		return KeyValueMap.from(extra);
	}

#end
#end
#No. 184436
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #extra
	 */

#Code:
	public void setExtra(final Map<String, String> extra) {
		this.extra.pointTo(KeyValueMap.toZZString(extra));
	}

#end
#end
#No. 184437
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #dipMode
	 */

#Code:
	public IDCDIPMode getDIPMode() {
		return XfsConstants.valueOf(dipMode, IDCDIPMode.class);
	}

#end
#end
#No. 184438
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #dipMode
	 */

#Code:
	public void setDIPMode(final IDCDIPMode dipMode) {
		this.dipMode.set((int) dipMode.getValue());
	}

#end
#end
#No. 184439
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #memoryChipProtocols
	 */

#Code:
	public Set<IDCMemoryChipProtocol> getMemoryChipProtocols() {
		// FIXME:
		return null;
	}

#end
#end
#No. 184440
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #memoryChipProtocols
	 */

#Code:
	public void setMemoryChipProtocols(final Set<IDCMemoryChipProtocol> memoryChipProtocols) {
		// FIXME: this.memoryChipProtocols = memoryChipProtocols;
	}

#end
#end
#No. 184441
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #ejectPosition
	 */

#Code:
	public Set<IDCEjectPosition> getEjectPosition() {
		return XfsConstants.of(ejectPosition, IDCEjectPosition.class);
	}

#end
#end
#No. 184442
#File: E:\bishe\1\WFSIDCCAPS.java
#Comment:
	/**
	 * @see #ejectPosition
	 */

#Code:
	public void setEjectPosition(final Set<IDCEjectPosition> ejectPosition) {
		this.ejectPosition.set((int) Bitmask.of(ejectPosition));
	}


#end
#end
#No. 184445
#File: E:\bishe\1\WFSIDCCARDDATA.java
#Comment:
	/**
	 * @param pCardData
	 *            pointer to card data structure
	 */

#Code:
	public WFSIDCCARDDATA(final XfsVersion xfsVersion, final Pointer pCardData) {
		this(xfsVersion);
		assignBuffer(pCardData);
	}


#end
#end
#No. 184449
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #device
	 */

#Code:
	public IDCDeviceState getDevice() {
		return XfsConstants.valueOf(device, IDCDeviceState.class);
	}

#end
#end
#No. 184450
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #media
	 */

#Code:
	public IDCMedia getMedia() {
		return XfsConstants.valueOf(media, IDCMedia.class);
	}

#end
#end
#No. 184451
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #retainBin
	 */

#Code:
	public IDCRetainBin getRetainBin() {
		return XfsConstants.valueOf(retainBin, IDCRetainBin.class);
	}

#end
#end
#No. 184452
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #security
	 */

#Code:
	public IDCSecurity getSecurity() {
		return XfsConstants.valueOf(security, IDCSecurity.class);
	}

#end
#end
#No. 184453
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #cards
	 */

#Code:
	public int getCards() {
		return cards.intValue();
	}

#end
#end
#No. 184454
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #chipPower
	 */

#Code:
	public IDCChipState getChipPower() {
		return XfsConstants.valueOf(chipPower, IDCChipState.class);
	}

#end
#end
#No. 184455
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #chipPower
	 */

#Code:
	public void setChipPower(final IDCChipState chipPower) {
		this.chipPower.set(chipPower);
	}

#end
#end
#No. 184456
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #extra
	 */

#Code:
	public Map<String, String> getExtra() {
		return KeyValueMap.from(extra);
	}

#end
#end
#No. 184457
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #chipModule
	 */

#Code:
	public IDCChipModule getChipModule() {
		return chipModule.get();
	}

#end
#end
#No. 184458
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #chipModule
	 */

#Code:
	public void setChipModule(final IDCChipModule chipModule) {
		this.chipModule.set(chipModule);
	}

#end
#end
#No. 184459
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #magReadModule
	 */

#Code:
	public IDCMagModule getMagReadModule() {
		return magReadModule.get();
	}

#end
#end
#No. 184460
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #magReadModule
	 */

#Code:
	public void setMagReadModule(final IDCMagModule magReadModule) {
		this.magReadModule.set(magReadModule);
	}

#end
#end
#No. 184461
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #magWriteModule
	 */

#Code:
	public IDCMagModule getMagWriteModule() {
		return magWriteModule.get();
	}

#end
#end
#No. 184462
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #magWriteModule
	 */

#Code:
	public void setMagWriteModule(final IDCMagModule magWriteModule) {
		this.magWriteModule.set(magWriteModule);
	}

#end
#end
#No. 184463
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #frontImageModule
	 */

#Code:
	public IDCImageModule getFrontImageModule() {
		return frontImageModule.get();
	}

#end
#end
#No. 184464
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #frontImageModule
	 */

#Code:
	public void setFrontImageModule(final IDCImageModule frontImageModule) {
		this.frontImageModule.set(frontImageModule);
	}

#end
#end
#No. 184465
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #backImageModule
	 */

#Code:
	public IDCImageModule getBackImageModule() {
		return backImageModule.get();
	}

#end
#end
#No. 184466
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #backImageModule
	 */

#Code:
	public void setBackImageModule(final IDCImageModule backImageModule) {
		this.backImageModule.set(backImageModule);
	}

#end
#end
#No. 184467
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #devicePosition
	 */

#Code:
	public IDCDevicePosition getDevicePosition() {
		return devicePosition.get();
	}

#end
#end
#No. 184468
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #devicePosition
	 */

#Code:
	public void setDevicePosition(final IDCDevicePosition devicePosition) {
		this.devicePosition.set(devicePosition);
	}

#end
#end
#No. 184469
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #powerSaveRecoveryTime
	 */

#Code:
	public int getPowerSaveRecoveryTime() {
		return powerSaveRecoveryTime.intValue();
	}

#end
#end
#No. 184470
#File: E:\bishe\1\WfsIDCStatus.java
#Comment:
	/**
	 * @see #powerSaveRecoveryTime
	 */

#Code:
	public void setPowerSaveRecoveryTime(final int powerSaveRecoveryTime) {
		this.powerSaveRecoveryTime.set(powerSaveRecoveryTime);
	}

#end
#end
#No. 184473
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #clazz}
	 */

#Code:
	public Set<PINType> getType() {
		return XfsConstants.of(clazz, PINType.class);
	}

#end
#end
#No. 184474
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #compound}
	 */

#Code:
	public boolean isCompound() {
		return compound.booleanValue();
	}

#end
#end
#No. 184475
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #keyNum}
	 */

#Code:
	public int getKeyNum() {
		return keyNum.intValue();
	}

#end
#end
#No. 184476
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #algorithms}
	 */

#Code:
	public Set<PINAlgorithm> getAlgorithms() {
		return XfsConstants.of(algorithms, PINAlgorithm.class);
	}

#end
#end
#No. 184477
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #pinFormats}
	 */

#Code:
	public Set<PINFormat> getPINFormats() {
		return XfsConstants.of(pinFormats, PINFormat.class);
	}

#end
#end
#No. 184478
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #derivationAlgorithms}
	 */

#Code:
	public Set<PINDerivationAlgorithm> getDerivationAlgorithms() {
		return XfsConstants.of(derivationAlgorithms, PINDerivationAlgorithm.class);
	}

#end
#end
#No. 184479
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #presentationAlgorithms}
	 */

#Code:
	public Set<PINPresentationAlgorithm> getPresentationAlgorithms() {
		return XfsConstants.of(presentationAlgorithms, PINPresentationAlgorithm.class);
	}

#end
#end
#No. 184480
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #display}
	 */

#Code:
	public PINDisplay getDisplay() {
		return XfsConstants.valueOf(display, PINDisplay.class);
	}

#end
#end
#No. 184481
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #idConnect}
	 */

#Code:
	public boolean isIDConnect() {
		return idConnect.booleanValue();
	}

#end
#end
#No. 184482
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #idKey}
	 */

#Code:
	public Set<PINIDKey> getIDKey() {
		return XfsConstants.of(idKey, PINIDKey.class);
	}

#end
#end
#No. 184483
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #validationAlgorithms}
	 */

#Code:
	public Set<PINValidationAlgorithm> getValidationAlgorithms() {
		return XfsConstants.of(validationAlgorithms, PINValidationAlgorithm.class);
	}

#end
#end
#No. 184484
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #keyCheckModes}
	 */

#Code:
	public Set<PINKeyCheckMode> getKeyCheckModes() {
		return XfsConstants.of(keyCheckModes, PINKeyCheckMode.class);
	}

#end
#end
#No. 184485
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #keyCheckModes}
	 */

#Code:
	public void setKeyCheckModes(final Set<PINKeyCheckMode> keyCheckModes) {
		this.keyCheckModes.set((int) Bitmask.of(keyCheckModes));
	}

#end
#end
#No. 184486
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #extra}
	 */

#Code:
	public Map<String, String> getExtra() {
		return KeyValueMap.from(extra);
	}

#end
#end
#No. 184487
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #guidLights}
	 */

#Code:
	public DWORDArray getGuidLights() {
		return guidLights;
	}

#end
#end
#No. 184488
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #pinCanPersistAfterUse}
	 */

#Code:
	public boolean isPINCanPersistAfterUse() {
		return pinCanPersistAfterUse.booleanValue();
	}

#end
#end
#No. 184489
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #pinCanPersistAfterUse}
	 */

#Code:
	public void setPINCanPersistAfterUse(final boolean pinCanPersistAfterUse) {
		this.pinCanPersistAfterUse.set(pinCanPersistAfterUse);
	}

#end
#end
#No. 184490
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #autoBeep}
	 */

#Code:
	public Set<PINAutoBeep> getAutoBeep() {
		return XfsConstants.of(autoBeep, PINAutoBeep.class);
	}

#end
#end
#No. 184491
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #autoBeep}
	 */

#Code:
	public void setAutoBeep(final Set<PINAutoBeep> autoBeep) {
		this.autoBeep.set((int) Bitmask.of(autoBeep));
	}

#end
#end
#No. 184492
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #hsmVendor}
	 */

#Code:
	public String getHSMVendor() {
		return hsmVendor.toString();
	}

#end
#end
#No. 184493
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #hsmVendor}
	 */

#Code:
	public void setHSMVendor(final String hsmVendor) {
		this.hsmVendor.pointTo(new ZSTR(hsmVendor));
	}

#end
#end
#No. 184494
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #hsmJournaling}
	 */

#Code:
	public boolean isHSMJournaling() {
		return hsmJournaling.booleanValue();
	}

#end
#end
#No. 184495
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #hsmJournaling}
	 */

#Code:
	public void setHSMJournaling(final boolean hsmJournaling) {
		this.hsmJournaling.set(hsmJournaling);
	}

#end
#end
#No. 184496
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #rsaAuthenticationSchemes}
	 */

#Code:
	public Set<PINRSAAuthenticationScheme> getRSAAuthenticationSchemes() {
		return XfsConstants.of(rsaAuthenticationSchemes, PINRSAAuthenticationScheme.class);
	}

#end
#end
#No. 184497
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #rsaAuthenticationSchemes}
	 */

#Code:
	public void setRSAAuthenticationSchemes(final Set<PINRSAAuthenticationScheme> rsaAuthenticationSchemes) {
		this.rsaAuthenticationSchemes.set((int) Bitmask.of(rsaAuthenticationSchemes));
	}

#end
#end
#No. 184498
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #rsaSignatureAlgorithms}
	 */

#Code:
	public Set<PINRSASignatureAlgorithm> getRSASignatureAlgorithms() {
		return XfsConstants.of(rsaSignatureAlgorithms, PINRSASignatureAlgorithm.class);
	}

#end
#end
#No. 184499
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #rsaSignatureAlgorithms}
	 */

#Code:
	public void setRSASignatureAlgorithms(final Set<PINRSASignatureAlgorithm> rsaSignatureAlgorithms) {
		this.rsaSignatureAlgorithms.set((int) Bitmask.of(rsaSignatureAlgorithms));
	}

#end
#end
#No. 184500
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #rsaCryptAlgorithms}
	 */

#Code:
	public Set<PINRSACryptAlgorithm> getRSACryptAlgorithms() {
		return XfsConstants.of(rsaCryptAlgorithms, PINRSACryptAlgorithm.class);
	}

#end
#end
#No. 184501
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #rsaCryptAlgorithms}
	 */

#Code:
	public void setRSACryptAlgorithms(final Set<PINRSACryptAlgorithm> rsaCryptAlgorithms) {
		this.rsaCryptAlgorithms.set((int) Bitmask.of(rsaCryptAlgorithms));
	}

#end
#end
#No. 184502
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #rsaKeyCheckModes}
	 */

#Code:
	public Set<PINRSAKeyCheckMode> getRSAKeyCheckModes() {
		return XfsConstants.of(rsaKeyCheckModes, PINRSAKeyCheckMode.class);
	}

#end
#end
#No. 184503
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #rsaKeyCheckModes}
	 */

#Code:
	public void setRSAKeyCheckModes(final Set<PINRSAKeyCheckMode> rsaKeyCheckModes) {
		this.rsaKeyCheckModes.set((int) Bitmask.of(rsaKeyCheckModes));
	}

#end
#end
#No. 184504
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #signatureSchemes}
	 */

#Code:
	public Set<PINSignatureSchemes> getSignatureSchemes() {
		return XfsConstants.of(signatureSchemes, PINSignatureSchemes.class);
	}

#end
#end
#No. 184505
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #signatureSchemes}
	 */

#Code:
	public void setSignatureSchemes(final Set<PINSignatureSchemes> signatureSchemes) {
		this.signatureSchemes.set((int) Bitmask.of(signatureSchemes));
	}

#end
#end
#No. 184506
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #emvImportSchemes}
	 */

#Code:
	public Pointer getEMVImportSchemes() {
		return emvImportSchemes;
	}

#end
#end
#No. 184507
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #emvImportSchemes}
	 */

#Code:
	public void setEMVImportSchemes(final Set<PINEMVImportScheme> emvImportSchemes) {
		// FIXME
	}

#end
#end
#No. 184508
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #emvHashAlgorithms}
	 */

#Code:
	public Set<PINEMVHashAlgorithm> getEMVHashAlgorithms() {
		return XfsConstants.of(emvHashAlgorithms, PINEMVHashAlgorithm.class);
	}

#end
#end
#No. 184509
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #emvHashAlgorithms}
	 */

#Code:
	public void setEMVHashAlgorithms(final Set<PINEMVHashAlgorithm> emvHashAlgorithms) {
		this.emvHashAlgorithms.set((int) Bitmask.of(emvHashAlgorithms));
	}

#end
#end
#No. 184510
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #keyImportThroughParts}
	 */

#Code:
	public boolean isKeyImportThroughParts() {
		return keyImportThroughParts.booleanValue();
	}

#end
#end
#No. 184511
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #keyImportThroughParts}
	 */

#Code:
	public void setKeyImportThroughParts(boolean keyImportThroughParts) {
		this.keyImportThroughParts.set(keyImportThroughParts);
	}

#end
#end
#No. 184512
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #encIOProtocols}
	 */

#Code:
	public Set<PINENCIOProtocols> getEncIOProtocols() {
		return XfsConstants.of(encIOProtocols, PINENCIOProtocols.class);
	}

#end
#end
#No. 184513
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #encIOProtocols}
	 */

#Code:
	public void setEncIOProtocols(final Set<PINENCIOProtocols> encIOProtocols) {
		this.encIOProtocols.set((int) Bitmask.of(encIOProtocols));
	}

#end
#end
#No. 184514
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #typeCombined}
	 */

#Code:
	public boolean isTypeCombined() {
		return typeCombined.booleanValue();
	}

#end
#end
#No. 184515
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #typeCombined}
	 */

#Code:
	public void setTypeCombined(final boolean typeCombined) {
		this.typeCombined.set(typeCombined);
	}

#end
#end
#No. 184516
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #setPinblockDataRequired}
	 */

#Code:
	public boolean isSetPinblockDataRequired() {
		return setPinblockDataRequired.booleanValue();
	}

#end
#end
#No. 184517
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #setPinblockDataRequired}
	 */

#Code:
	public void setSetPinblockDataRequired(boolean setPinblockDataRequired) {
		this.setPinblockDataRequired.set(setPinblockDataRequired);
	}

#end
#end
#No. 184518
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #keyBlockImportFormats}
	 */

#Code:
	public Set<PINKeyBlockImportFormat> getKeyBlockImportFormats() {
		return XfsConstants.of(keyBlockImportFormats, PINKeyBlockImportFormat.class);
	}

#end
#end
#No. 184519
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #keyBlockImportFormats}
	 */

#Code:
	public void setKeyBlockImportFormats(final Set<PINKeyBlockImportFormat> keyBlockImportFormats) {
		this.keyBlockImportFormats.set((int) Bitmask.of(keyBlockImportFormats));
	}

#end
#end
#No. 184520
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #powerSaveControl}
	 */

#Code:
	public boolean isPowerSaveControl() {
		return powerSaveControl.booleanValue();
	}

#end
#end
#No. 184521
#File: E:\bishe\1\WFSPINCAPS.java
#Comment:
	/**
	 * {@link #powerSaveControl}
	 */

#Code:
	public void setPowerSaveControl(final boolean powerSaveControl) {
		this.powerSaveControl.set(powerSaveControl);
	}

#end
#end
#No. 184525
#File: E:\bishe\1\WFSPINFDK.java
#Comment:
	/**
	 * @see #xPosition
	 */

#Code:
	public int getXPosition() {
		return xPosition.intValue();
	}

#end
#end
#No. 184526
#File: E:\bishe\1\WFSPINFDK.java
#Comment:
	/**
	 * @see #xPosition
	 */

#Code:
	public void setXPosition(final int xPosition) {
		this.xPosition.set(xPosition);
	}

#end
#end
#No. 184527
#File: E:\bishe\1\WFSPINFDK.java
#Comment:
	/**
	 * @see #yPosition
	 */

#Code:
	public int getYPosition() {
		return yPosition.intValue();
	}

#end
#end
#No. 184528
#File: E:\bishe\1\WFSPINFDK.java
#Comment:
	/**
	 * @see #yPosition
	 */

#Code:
	public void setYPosition(final int yPosition) {
		this.yPosition.set(yPosition);
	}


#end
#end
#No. 184530
#File: E:\bishe\1\WFSPINFUNCKEYDETAIL.java
#Comment:
	/**
	 * @param p
	 *            Pointer to WFSPINFUNCKEYDETAIL
	 */

#Code:
	public WFSPINFUNCKEYDETAIL(final Pointer p) {
		this();
		assignBuffer(p);
	}


#end
#end
#No. 184535
#File: E:\bishe\1\WFSPINKEYDETAIL.java
#Comment:
	/**
	 * @param pKeyDetail
	 *            pointer to key detail structure.
	 */

#Code:
	public WFSPINKEYDETAIL(final XfsVersion xfsVersion, final Pointer pKeyDetail) {
		this(xfsVersion);
		assignBuffer(pKeyDetail);
	}

#end
#end
#No. 184536
#File: E:\bishe\1\WFSPINKEYDETAIL.java
#Comment:
	/**
	 * {@link #keyName}
	 */

#Code:
	public String getKeyName() {
		return keyName.toString();
	}

#end
#end
#No. 184537
#File: E:\bishe\1\WFSPINKEYDETAIL.java
#Comment:
	/**
	 * {@link #use}
	 */

#Code:
	public Set<PINUse> getUse() {
		return XfsConstants.of(use, PINUse.class);
	}

#end
#end
#No. 184538
#File: E:\bishe\1\WFSPINKEYDETAIL.java
#Comment:
	/**
	 * {@link #loaded}
	 */

#Code:
	public boolean isLoaded() {
		return loaded.booleanValue();
	}

#end
#end
#No. 184539
#File: E:\bishe\1\WFSPINKEYDETAIL.java
#Comment:
	/**
	 * {@link #xKeyBlockHeader}
	 */

#Code:
	public WfsXData getXKeyBlockHeader() {
		if (Pointer.NULL.equals(xKeyBlockHeader)) {
			return null;
		}
		return new WfsXData(xKeyBlockHeader);
	}

#end
#end
#No. 184540
#File: E:\bishe\1\WFSPINKEYDETAIL.java
#Comment:
	/**
	 * {@link #xKeyBlockHeader}
	 */

#Code:
	public void setXKeyBlockHeader(final WfsXData xData) {
		this.xKeyBlockHeader.pointTo(xData);
	}

#end
#end
#No. 184541
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the logical service class, value is:
	 * {@link XfsServiceClass#PTR}
	 */

#Code:
	public XfsServiceClass getServiceClass() {
		return XfsConstants.valueOf(clazz, XfsServiceClass.class);
	}

#end
#end
#No. 184542
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the type(s) of the physical device driven by the logical
	 * service, as a combination of the following flags: {@link PTRType}
	 */

#Code:
	public Set<PTRType> getType() {
		return XfsConstants.of(type, PTRType.class);
	}

#end
#end
#No. 184543
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the logical device is part of a compound physical
	 * device.
	 */

#Code:
	public boolean isCompound() {
		return compound.booleanValue();
	}

#end
#end
#No. 184544
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies at which resolution(s) the physical device can print. Used by
	 * the application to select the level of print quality desired (e.g. as in
	 * Word for Windows); does not imply any absolute level of resolution, only
	 * relative. Specified as a combination of the following flags:
	 * {@link PTRResolution}
	 */

#Code:
	public Set<PTRResolution> getResolution() {
		return XfsConstants.of(resolution, PTRResolution.class);
	}

#end
#end
#No. 184545
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the device can read data from media, as a combination
	 * of the following flags (zero if none of the choices is supported):
	 * {@link PTRReadForm}
	 */

#Code:
	public Set<PTRReadForm> getReadForm() {
		return XfsConstants.of(readForm, PTRReadForm.class);
	}

#end
#end
#No. 184546
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the device can write data to the media, as a
	 * combination of the following flags (zero if none of the choices is
	 * supported): {@link PTRWriteForm}
	 */

#Code:
	public Set<PTRWriteForm> getWriteForm() {
		return XfsConstants.of(writeForm, PTRWriteForm.class);
	}

#end
#end
#No. 184547
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the device is able to measure the inserted media, as a
	 * combination of the following flags (zero if none of the choices is
	 * supported): {@link PTRExtents}
	 */

#Code:
	public Set<PTRExtents> getExtents() {
		return XfsConstants.of(extents, PTRExtents.class);
	}

#end
#end
#No. 184548
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the manner in which media can be controlled, as a combination
	 * of the following flags (zero if none of the choices is supported):
	 * {@link PTRMediaControl}
	 */

#Code:
	public Set<PTRMediaControl> getControl() {
		return XfsConstants.of(control, PTRMediaControl.class);
	}

#end
#end
#No. 184549
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the maximum number of media items that the stacker can hold
	 * (zero if not available).
	 */

#Code:
	public int getMaxMediaOnStacker() {
		return maxMediaOnStacker.intValue();
	}

#end
#end
#No. 184550
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the device is able to accept media while no execute
	 * command is running that is waiting explicitly for media to be inserted.
	 */

#Code:
	public boolean isAcceptMedia() {
		return acceptMedia.booleanValue();
	}

#end
#end
#No. 184551
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the device is able to support multiple page print jobs.
	 *
	 * @since 3.00
	 */

#Code:
	public boolean isMultiPage() {
		return multiPage.booleanValue();
	}

#end
#end
#No. 184552
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the Paper sources available for this printer as a combination
	 * of the following flags: {@link PTRPaperSource}
	 *
	 * @since 3.00
	 */

#Code:
	public Set<PTRPaperSource> getPaperSources() {
		return XfsConstants.of(paperSources, PTRPaperSource.class);
	}

#end
#end
#No. 184553
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the device is able to detect when the media is taken
	 * from the exit slot. If FALSE, the WFS_SRVE_PTR_MEDIATAKEN event is not
	 * fired. Its value is either TRUE or FALSE.
	 *
	 * @since 3.00
	 */

#Code:
	public boolean isMediaTaken() {
		return mediaTaken.booleanValue();
	}

#end
#end
#No. 184554
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the number of retract bins (zero if not supported).
	 */

#Code:
	private int getRetractBins() {
		return retractBins.intValue();
	}

#end
#end
#No. 184555
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * A list of the maximum number of media items that each retract bin can
	 * hold (one count for each supported bin).
	 */

#Code:
	public List<Integer> getMaxRetracts() {
		final List<Integer> numbers = new ArrayList<Integer>();
		if (maxRetract != null) {
			if (maxRetract.intValue() > 0) {
				numbers.add(Integer.valueOf(maxRetract.intValue()));
			}
		} else if (getRetractBins() > 0) {
			final UShortArray array = new UShortArray(maxRetracts, getRetractBins());
			for (int i = 0; i < array.length; i++) {
				final int num = array.get(i).intValue();
				numbers.add(Integer.valueOf(num));
			}
		}
		return numbers;
	}

#end
#end
#No. 184556
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the image format supported by this device, as a combination of
	 * following flags (empty if not supported): {@link PTRImageType}
	 *
	 * @since 3.00
	 */

#Code:
	public Set<PTRImageType> getImageType() {
		return XfsConstants.of(imageType, PTRImageType.class);
	}

#end
#end
#No. 184557
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the front image color formats supported by this device, as a
	 * combination of following flags (empty if not supported):
	 *
	 * @since 3.00
	 */

#Code:
	public Set<PTRImageColor> getFrontImageColorFormat() {
		return XfsConstants.of(frontImageColorFormat, PTRImageColor.class);
	}

#end
#end
#No. 184558
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the back image color formats supported by this device, as a
	 * combination of following flags (empty if not supported):
	 * {@link PTRImageColor}
	 *
	 * @since 3.00
	 */

#Code:
	public Set<PTRImageColor> getBackImageColorFormat() {
		return XfsConstants.of(backImageColorFormat, PTRImageColor.class);
	}

#end
#end
#No. 184559
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the code line (MICR data) formats supported by this device, as
	 * a combination of following flags (empty if not supported):
	 * {@link PTRCodelineFormat}
	 *
	 * @since 3.00
	 */

#Code:
	public Set<PTRCodelineFormat> getCodelineFormat() {
		return XfsConstants.of(codelineFormat, PTRCodelineFormat.class);
	}

#end
#end
#No. 184560
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the source for the read image command supported by this device,
	 * as a combination of the following flags (empty if not supported):
	 * {@link PTRImageSource}
	 *
	 * @since 3.00
	 */

#Code:
	public Set<PTRImageSource> getImageSource() {
		return XfsConstants.of(imageSource, PTRImageSource.class);
	}


#end
#end
#No. 184562
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the device is able to dispense paper.
	 *
	 * @since 3.00
	 */

#Code:
	public boolean isDispensePaper() {
		return dispensePaper.booleanValue();
	}

#end
#end
#No. 184563
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * A list of vendor-specific, or any other extended, information.
	 */

#Code:
	public Map<String, String> getExtra() {
		return KeyValueMap.from(extra);
	}

#end
#end
#No. 184564
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies which guidance lights are available.
	 *
	 * @since 3.10
	 */

#Code:
	public DWORD getGuidLights() {
		return guidLights;
	}

#end
#end
#No. 184565
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the name of the default logical Windows printer that is
	 * associated with this Service Provider. Applications should use this
	 * printer name to generate native printer files (i.e. .PRN) to be printed
	 * through the WFS_CMD_PTR_PRINT_RAW_FILE command. This value will be
	 * <code>null</code> if the Service Provider does not support the
	 * WFS_CMD_PTR_PRINT_RAW_FILE command.
	 *
	 * @since 3.10
	 */

#Code:
	public String getWindowsPrinter() {
		final String s = windowsPrinter.toString();
		if (s.isEmpty()) {
			return null;
		}
		return s;
	}

#end
#end
#No. 184566
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the device is able to detect when the media is
	 * presented to the user for removal. If TRUE, the
	 * WFS_EXEE_PTR_MEDIAPRESENTED event is fired. If FALSE, the
	 * WFS_EXEE_PTR_MEDIAPRESENTED event is not fired.
	 *
	 * @since 3.10
	 */

#Code:
	public boolean isMediaPresented() {
		return mediaPresented.booleanValue();
	}

#end
#end
#No. 184567
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the number of seconds before the device will automatically
	 * retract the presented media. If the command that generated the media is
	 * still active when the media is automatically retracted, the command will
	 * complete with a WFS_ERR_PTR_MEDIARETRACTED error. If the device does not
	 * retract media automatically this value will be zero.
	 *
	 * @since 3.10
	 */

#Code:
	public int getAutoRetractPeriod() {
		return autoRetractPeriod.intValue();
	}

#end
#end
#No. 184568
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the device is able to retract the previously ejected
	 * media to the transport.
	 *
	 * @since 3.10
	 */

#Code:
	public boolean isRetractToTransport() {
		return retractToTransport.booleanValue();
	}

#end
#end
#No. 184569
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether power saving control is available.
	 *
	 * @since 3.10
	 */

#Code:
	public boolean isPowerSaveControl() {
		return powerSaveControl.booleanValue();
	}

#end
#end
#No. 184570
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies the form write modes supported by this device, as a combination
	 * of the following flags: {@link PTRCoercivityType}
	 *
	 * @since 3.20
	 */

#Code:
	public Set<PTRCoercivityType> getCoercivityType() {
		return XfsConstants.of(coercivityType, PTRCoercivityType.class);
	}

#end
#end
#No. 184571
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies how the passbook can be controlled with the
	 * WFS_CMD_PTR_CONTROL_PASSBOOK command, as a combination of the following
	 * flags: {@link PTRPassbookControl}
	 *
	 * @since 3.20
	 */

#Code:
	public Set<PTRPassbookControl> getControlPassbook() {
		return XfsConstants.of(controlPassbook, PTRPassbookControl.class);
	}

#end
#end
#No. 184572
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies on which sides of the media this device can print as one of the
	 * following values:
	 *
	 * @since 3.20
	 */

#Code:
	public PTRPrintSides getPrintSides() {
		return XfsConstants.valueOf(printSides, PTRPrintSides.class);
	}

#end
#end
#No. 184573
#File: E:\bishe\1\WFSPTRCAPS.java
#Comment:
	/**
	 * Specifies whether the anti-fraud module is available.
	 *
	 * @since 3.20
	 */

#Code:
	public boolean isAntiFraudModule() {
		return antiFraudModule.booleanValue();
	}

#end
#end
#No. 184574
#File: E:\bishe\1\WFSPTRRETRACTBINS.java
#Comment:
	/**
	 * Specifies the state of the printer retract bin as one of the following
	 * values: {@link PTRRetractBin}
	 */

#Code:
	public PTRRetractBin getRetractBin() {
		return XfsConstants.valueOf(retractBin, PTRRetractBin.class);
	}

#end
#end
#No. 184575
#File: E:\bishe\1\WFSPTRRETRACTBINS.java
#Comment:
	/**
	 * The number of media retracted to this bin. This value is persistent; it
	 * may be reset to zero by the WFS_CMD_PTR_RESET_COUNT command.
	 */

#Code:
	public int getRetractCount() {
		return retractCount.intValue();
	}

#end
#end
#No. 184576
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * Specifies the state of the print device as one of the following flags: {@link PTRDeviceState}
	 *
	 * @since 2.00
	 */

#Code:
	public PTRDeviceState getDevice() {
		return XfsConstants.valueOf(device, PTRDeviceState.class);
	}

#end
#end
#No. 184577
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * Specifies the state of the print media (i.e. receipt, statement,
	 * passbook, etc.) as one of the following values. This field does not apply
	 * to journal printers: {@link PTRMedia}
	 *
	 * @since 2.00
	 */

#Code:
	public PTRMedia getMedia() {
		return XfsConstants.valueOf(media, PTRMedia.class);
	}

#end
#end
#No. 184578
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * Specifies the state of the paper supplies. A number of paper supplies are
	 * defined below. Vendor specific paper supplies are defined starting from
	 * the end of the array. The maximum paper index is WFS_PTR_SUPPLYMAX.
	 */

#Code:
	public PTRPaper[] getPaper() {
		final PTRPaper[] paperSupplies = new PTRPaper[WFS_PTR_SUPPLYSIZE];
		for (int i = 0; i < paperSupplies.length; i++) {
			if (i < paper.length) {
				paperSupplies[i] = XfsConstants.valueOf(paper.get(i), PTRPaper.class);
			} else {
				paperSupplies[i] = PTRPaper.NOTSUPP;
			}
		}
		return paperSupplies;
	}

#end
#end
#No. 184579
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * Specifies the state of the toner or ink supply or the state of the ribbon
	 * as one of the following values: {@link PTRToner}
	 *
	 * @since 2.0
	 */

#Code:
	public PTRToner getToner() {
		return XfsConstants.valueOf(toner, PTRToner.class);
	}

#end
#end
#No. 184580
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * Specifies the status of the stamping ink in the printer as one of the
	 * following values: {@link PTRInk}
	 *
	 * @since 2.0
	 */

#Code:
	public PTRInk getInk() {
		return XfsConstants.valueOf(ink, PTRInk.class);
	}

#end
#end
#No. 184581
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * Specifies the status of the printer imaging lamp as one of the following
	 * values: {@link PTRLamp}
	 *
	 * @since 2.0
	 */

#Code:
	public PTRLamp getLamp() {
		return XfsConstants.valueOf(lamp, PTRLamp.class);
	}

#end
#end
#No. 184582
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 *
	 * @return
	 */

#Code:
	public List<WFSPTRRETRACTBINS> getRetractBins() {
		final List<WFSPTRRETRACTBINS> result = new ArrayList<WFSPTRRETRACTBINS>();
		if (retractBin != null) {
			if (!PTRRetractBin.NOTSUPP.equals(retractBin.getRetractBin())) {
				result.add(retractBin);
			}
		} else if (retractBins != null) {
			final ZList list = new ZList(retractBins);
			for (final Pointer p : list) {
				final WFSPTRRETRACTBINS bin = new WFSPTRRETRACTBINS(p);
				result.add(new WFSPTRRETRACTBINS(bin));
			}
		}
		return result;
	}

#end
#end
#No. 184583
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * The number of media on stacker; applicable only to printers with stacking
	 * capability.
	 *
	 * @since 2.0
	 */

#Code:
	public int getMediaOnStacker() {
		return mediaOnStacker.intValue();
	}

#end
#end
#No. 184584
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * Pointer to a list of vendor-specific, or any other extended, information.
	 *
	 * @since 2.0
	 */

#Code:
	public Map<String, String> getExtra() {
		return KeyValueMap.from(extra);
	}

#end
#end
#No. 184585
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * @since 3.10
	 */

#Code:
	public DWORDArray getGuidLights() {
		return guidLights;
	}

#end
#end
#No. 184586
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * Specifies the device position. The device position value is independent
	 * of the fwDevice value, e.g. when the device position is reported as
	 * WFS_PTR_DEVICENOTINPOSITION, fwDevice can have any of the values defined
	 * above (including WFS_PTR_DEVONLINE or WFS_PTR_DEVOFFLINE). If the device
	 * is not in its normal operating position (i.e. WFS_PTR_DEVICEINPOSITION)
	 * then media may not be presented through the normal customer interface.
	 * This value is one of the following values: {@link PTRDevicePosition}
	 *
	 * @since 3.10
	 */

#Code:
	public PTRDevicePosition getDevicePosition() {
		return XfsConstants.valueOf(devicePosition, PTRDevicePosition.class);
	}

#end
#end
#No. 184587
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * Specifies the actual number of seconds required by the device to resume
	 * its normal operational state from the current power saving mode. This
	 * value is zero if either the power saving mode has not been activated or
	 * no power save control is supported.
	 *
	 * @since 3.10
	 */

#Code:
	public int getPowerSaveRecoveryTime() {
		return powerSaveRecoveryTime.intValue();
	}

#end
#end
#No. 184588
#File: E:\bishe\1\WFSPTRSTATUS.java
#Comment:
	/**
	 * Specifies the type of paper loaded in the device. A number of paper types
	 * are defined below. Vendor specific paper types are defined starting from
	 * the end of the array. The maximum paper index is WFS_PTR_SUPPLYMAX.
	 *
	 * @since 3.20
	 */

#Code:
	public PTRPaperType[] getPaperType() {
		final PTRPaper[] supplies = getPaper();
		final PTRPaperType[] paperTypes = new PTRPaperType[WFS_PTR_SUPPLYSIZE];
		for (int i = 0; i < paperTypes.length; i++) {
			PTRPaperType paperType = PTRPaperType.TYPEUNKNOWN;
			if (i < paper.length && !PTRPaper.NOTSUPP.equals(supplies[i])) {
				paperType = XfsConstants.valueOf(paper.get(i), PTRPaperType.class);
			}
			paperTypes[i] = paperType;
		}
		return paperTypes;
	}


#end
#end
#No. 184592
#File: E:\bishe\1\WfsXData.java
#Comment:
	/**
	 * {@link #length}
	 */

#Code:
	private int getLength() {
		return length.intValue();
	}

#end
#end
#No. 184593
#File: E:\bishe\1\WfsXData.java
#Comment:
	/**
	 * {@link #length}
	 */

#Code:
	private void setLength(final int length) {
		this.length.set(length);
	}

#end
#end
#No. 184594
#File: E:\bishe\1\WfsXData.java
#Comment:
	/**
	 * {@link #data}
	 */

#Code:
	public byte[] getData() {
		byte[] result = null;
		if (!Pointer.NULL.equals(data)) {
			result = data.buffer(getLength()).get();
		}
		return result;
	}

#end
#end
#No. 184595
#File: E:\bishe\1\WfsXData.java
#Comment:
	/**
	 * {@link #data}
	 */

#Code:
	public void setData(final byte[] data) {
		setLength(data.length);
		ByteArray array = new ByteArray(data);
		this.data.pointTo(array);
	}

#end
#end
#No. 184596
#File: E:\bishe\1\WFWebClient.java
#Comment:
	/**
	 * @param isServiceWindowVisible the isServiceWindowVisible to set
	 */

#Code:
	public void setServiceWindowVisible(boolean isServiceWindowVisible) {
		this.isServiceWindowVisible = isServiceWindowVisible;
	} 



#end
#end
#No. 184601
#File: E:\bishe\1\WhatsappExtension.java
#Comment:
	/**
	 * Clear DashClock
	 */

#Code:
	private void clearUpdateExtensionData() {
		publishUpdate(null);
	}


#end
#end
#No. 184636
#File: E:\bishe\1\WhereBetweenPiece.java
#Comment:
/**
 * x BETWEEN y
 * @author serge fantino
 *
 */

#Code:
public class WhereBetweenPiece 
extends AbstractWherePiece
{
	
	private IPiece left;
	private IPiece right;
	
	public WhereBetweenPiece(IPiece left, IPiece right) {
		super();
		this.left = left;
		this.right = right;
	}

	@Override
	public String render(SQLSkin skin) throws RenderingException {
		String render = "";
		if (hasComment()) render += renderComment(skin);
		render += left.render(skin)+" BETWEEN "+right.render(skin);
		return render;
	}

}




#end
#end
#No. 184642
#File: E:\bishe\1\WhereORPiece.java
#Comment:
/**
 * A convenient way to display (x OR y OR z...)
 * @author serge fantino
 *
 */

#Code:
public class WhereORPiece 
extends AbstractWherePiece
{
	
	private IPiece[] pieces;
	private boolean not = false;
	
	public WhereORPiece(IPiece[] pieces) {
		this.pieces = pieces;
	}
	
	public WhereORPiece(IPiece[] pieces, boolean not) {
		this.pieces = pieces;
		this.not = not;
	}

	@Override
	public String render(SQLSkin skin) throws RenderingException {
		String render = "";
		if (hasComment()) render += renderComment(skin);
		if (not){
			render+=skin.getToken(SQLTokenConstant.NOT);
		}
		if (pieces.length>1 || not) render += "(";
		//
		for (int i=0;i<pieces.length;i++) {
			if (i>0) render +=" " + skin.getToken(SQLTokenConstant.OR) +" ";
			render += pieces[i].render(skin);
		}
		//
		if (pieces.length>1 || not) render += ")";
		//
		return render;
	}

}


#end
#end
#No. 184644
#File: E:\bishe\1\WhichImplicitThis6.java
#Comment:
/**
 * @test
 * @bug 4717633
 * @summary compiler fails to allow access to enclosing instance in super()
 *
 * @compile WhichImplicitThis6.java
 */

#Code:

class WhichImplicitThis6 {
    private int i;
    WhichImplicitThis6(int i) {}
    class Sub extends WhichImplicitThis6 {
	Sub() {
	    super(i); // i is not inherited, so it is the enclosing i
	}
    }
}


#end
#end
#No. 184649
#File: E:\bishe\1\Whirlpool0.java
#Comment:
	/**
	 * Create the object.
	 */

#Code:
	public Whirlpool0()
	{
		super(T0, T1, T2, T3, T4, T5, T6, T7, RC);
	}

#end
#end
#No. 184650
#File: E:\bishe\1\Whirlpool1.java
#Comment:
	/**
	 * Create the object.
	 */

#Code:
	public Whirlpool1()
	{
		super(T0, T1, T2, T3, T4, T5, T6, T7, RC);
	}

#end
#end
#No. 184651
#File: E:\bishe\1\WhirlpoolCore.java
#Comment:
	/**
	 * Create the object.
	 */

#Code:
	WhirlpoolCore(long[] T0, long[] T1, long[] T2, long[] T3,
		long[] T4, long[] T5, long[] T6, long[] T7, long[] RC)
	{
		super(false, 32);
		this.T0 = T0;
		this.T1 = T1;
		this.T2 = T2;
		this.T3 = T3;
		this.T4 = T4;
		this.T5 = T5;
		this.T6 = T6;
		this.T7 = T7;
		this.RC = RC;
	}

#end
#end
#No. 184652
#File: E:\bishe\1\WhirlpoolCore.java
#Comment:
	/**
	 * Decode a 64-bit little-endian integer.
	 *
	 * @param buf   the source buffer
	 * @param off   the source offset
	 * @return  the decoded integer
	 */

#Code:
	private static final long decodeLELong(byte[] buf, int off)
	{
		return (buf[off + 0] & 0xFF)
			| ((long)(buf[off + 1] & 0xFF) << 8)
			| ((long)(buf[off + 2] & 0xFF) << 16)
			| ((long)(buf[off + 3] & 0xFF) << 24)
			| ((long)(buf[off + 4] & 0xFF) << 32)
			| ((long)(buf[off + 5] & 0xFF) << 40)
			| ((long)(buf[off + 6] & 0xFF) << 48)
			| ((long)(buf[off + 7] & 0xFF) << 56);
	}

#end
#end
#No. 184653
#File: E:\bishe\1\WhirlpoolCore.java
#Comment:
	/**
	 * Encode a 64-bit integer with little-endian convention.
	 *
	 * @param val   the integer to encode
	 * @param dst   the destination buffer
	 * @param off   the destination offset
	 */

#Code:
	private static final void encodeLELong(long val, byte[] dst, int off)
	{
		dst[off + 0] = (byte)val;
		dst[off + 1] = (byte)((int)val >>> 8);
		dst[off + 2] = (byte)((int)val >>> 16);
		dst[off + 3] = (byte)((int)val >>> 24);
		dst[off + 4] = (byte)(val >>> 32);
		dst[off + 5] = (byte)(val >>> 40);
		dst[off + 6] = (byte)(val >>> 48);
		dst[off + 7] = (byte)(val >>> 56);
	}

#end
#end
#No. 184654
#File: E:\bishe\1\WhiteBalanceMode.java
#Comment:
/**
 * <p>Java class for WhiteBalanceMode.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="WhiteBalanceMode"&gt;
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string"&gt;
 *     &lt;enumeration value="AUTO"/&gt;
 *     &lt;enumeration value="MANUAL"/&gt;
 *   &lt;/restriction&gt;
 * &lt;/simpleType&gt;
 * </pre>
 * 
 */

#Code:
@XmlType(name = "WhiteBalanceMode")
@XmlEnum
public enum WhiteBalanceMode {

    AUTO,
    MANUAL;

    public String value() {
        return name();
    }

    public static WhiteBalanceMode fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 184655
#File: E:\bishe\1\Whitelist.java
#Comment:
    /**
     Add allowed URL protocols for an element's URL attribute. This restricts the possible values of the attribute to
     URLs with the defined protocol.
     <p/>
     E.g.: <code>addProtocols("a", "href", "ftp", "http", "https")</code>

     @param tag       Tag the URL protocol is for
     @param key       Attribute key
     @param protocols List of valid protocols
     @return this, for chaining
     */

#Code:
    public Whitelist addProtocols(String tag, String key, String... protocols) {
        Validate.notEmpty(tag);
        Validate.notEmpty(key);
        Validate.notNull(protocols);

        TagName tagName = TagName.valueOf(tag);
        AttributeKey attrKey = AttributeKey.valueOf(key);
        Map<AttributeKey, Set<Protocol>> attrMap;
        Set<Protocol> protSet;

        if (this.protocols.containsKey(tagName)) {
            attrMap = this.protocols.get(tagName);
        } else {
            attrMap = new HashMap<AttributeKey, Set<Protocol>>();
            this.protocols.put(tagName, attrMap);
        }
        if (attrMap.containsKey(attrKey)) {
            protSet = attrMap.get(attrKey);
        } else {
            protSet = new HashSet<Protocol>();
            attrMap.put(attrKey, protSet);
        }
        for (String protocol : protocols) {
            Validate.notEmpty(protocol);
            Protocol prot = Protocol.valueOf(protocol);
            protSet.add(prot);
        }
        return this;
    }

#end
#end
#No. 184656
#File: E:\bishe\1\Whitelist.java
#Comment:
    /**
     * Test if the supplied tag is allowed by this whitelist
     * @param tag test tag
     * @return true if allowed
     */

#Code:
    protected boolean isSafeTag(String tag) {
        return tagNames.contains(TagName.valueOf(tag));
    }

#end
#end
#No. 184657
#File: E:\bishe\1\Whitelist.java
#Comment:
    /**
     * Test if the supplied attribute is allowed by this whitelist for this tag
     * @param tagName tag to consider allowing the attribute in
     * @param el element under test, to confirm protocol
     * @param attr attribute under test
     * @return true if allowed
     */

#Code:
    protected boolean isSafeAttribute(String tagName, Element el, Attribute attr) {
        TagName tag = TagName.valueOf(tagName);
        AttributeKey key = AttributeKey.valueOf(attr.getKey());

        if (attributes.containsKey(tag)) {
            if (attributes.get(tag).contains(key)) {
                if (protocols.containsKey(tag)) {
                    Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);
                    // ok if not defined protocol; otherwise test
                    return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));
                } else { // attribute found, no protocols defined, so OK
                    return true;
                }
            }
        }
        // no attributes defined for tag, try :all tag
        return !tagName.equals(":all") && isSafeAttribute(":all", el, attr);
    }

#end
#end
#No. 184658
#File: E:\bishe\1\WhiteListMatcher.java
#Comment:
    /**
     * Performs a wildcard matching for the text and pattern
     * provided.
     *
     * @param text the text to be tested for matches.
     *
     * @param pattern the pattern to be matched for.
     * This can contain the wildcard character '*' (asterisk).
     *
     * @return <tt>true</tt> if a match is found, <tt>false</tt>
     * otherwise.
     *
     * @url http://www.adarshr.com/simple-implementation-of-wildcard-text-matching-using-java
     */

#Code:
    public static boolean wildCardMatch(String text, String pattern) {
        // Create the cards by splitting using a RegEx. If more speed
        // is desired, a simpler character based splitting can be done.
        String [] cards = pattern.split("\\*");

        // Iterate over the cards.
        for (String card : cards) {
            int idx = text.indexOf(card);

            // Card not detected in the text.
            if(idx == -1) {
                return false;
            }

            // Move ahead, towards the right of the text.
            text = text.substring(idx + card.length());
        }

        return true;
    }

#end
#end
#No. 184659
#File: E:\bishe\1\WhiteListMatcher.java
#Comment:
    /**
     * Checks if the url parameter has a valid host
     * among a list of hosts.
     *
     * @param url
     * @param hostsWhitelist
     * @return
     */

#Code:
    public static boolean isValidHost(String url, String[] hostsWhitelist){
        if (!TextUtils.isEmpty(url)) {
            final String host = Uri.parse(url).getHost();
            if( host == null ) {
                return false;
            }
            for (String whitelistedHost: hostsWhitelist){
                if(wildCardMatch(host, whitelistedHost)) {
                    return true;
                }
            }
        }
        return false;
    }

#end
#end
#No. 184660
#File: E:\bishe\1\WhiteListMatcher.java
#Comment:
    /**
     * Checks if the URL can be parsed.
     *
     * @param padUrl
     * @return
     */

#Code:
    public static boolean checkValidUrl(String padUrl) {
        // Check if it is a valid url
        try {
            new URL(padUrl);
        } catch (MalformedURLException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }


#end
#end
#No. 184662
#File: E:\bishe\1\WhitelistRulesEvaluator.java
#Comment:
    /**
     * true if rule matches a violation and should be whitelisted.
     *
     * @return true if rule matches a violation
     */

#Code:
    @Override
    public Boolean apply(final RuleEntity ruleEntity, final ViolationEntity violationEntity) {
        final List<Predicate<ViolationEntity>> predicates = newArrayList();


        trimOptional(ruleEntity.getAccountId())
                .map(WhitelistRulesEvaluator::accountIsEqual)
                .ifPresent(predicates::add);

        trimOptional(ruleEntity.getRegion())
                .map(WhitelistRulesEvaluator::regionIsEqual)
                .ifPresent(predicates::add);

        trimOptional(ruleEntity.getViolationTypeEntityId())
                .map(WhitelistRulesEvaluator::violationTypeIdIsEqual)
                .ifPresent(predicates::add);

        trimOptional(ruleEntity.getImageName())
                .map(WhitelistRulesEvaluator::imageNameMatches)
                .ifPresent(predicates::add);

        trimOptional(ruleEntity.getImageOwner())
                .map(WhitelistRulesEvaluator::imageOwnerIsEqual)
                .ifPresent(predicates::add);

        trimOptional(ruleEntity.getApplicationId())
                .map(WhitelistRulesEvaluator::applicationIdIsEqual)
                .ifPresent(predicates::add);

        trimOptional(ruleEntity.getApplicationVersion())
                .map(WhitelistRulesEvaluator::applicationVersionIsEqual)
                .ifPresent(predicates::add);

        final Optional<Predicate<ViolationEntity>> whiteListTest = predicates.stream().reduce(Predicate::and);

        return whiteListTest.isPresent() && whiteListTest.get().test(violationEntity);
    }

#end
#end
#No. 184663
#File: E:\bishe\1\WhitelistUserService.java
#Comment:
/**
 * Service based on an explicit list if addresses and mappings provided in the
 * config.
 */

#Code:
@Singleton
class WhitelistUserService extends AbstractService implements UserService {

  private final Set<String> emails;
  private final Map<String, String> mappings;

  @Inject
  WhitelistUserService(Context context) {
    Config config = context.config().getConfig("whitelist");
    emails = Collections.unmodifiableSet(new TreeSet<>(config.getStringList("emails")));
    mappings = new HashMap<>();
    for (Config c : config.getConfigList("mappings")) {
      mappings.put(c.getString("email"), c.getString("replacement"));
    }
  }

  @Override protected void startImpl() throws Exception {
  }


#end
#end
#No. 184666
#File: E:\bishe\1\WhoisListener.java
#Comment:
    /**
     *
     * @param plugin the PurpleIRC plugin
     * @param ircBot
     */

#Code:
    public WhoisListener(PurpleIRC plugin, PurpleBot ircBot) {
        this.plugin = plugin;
        this.ircBot = ircBot;
    }

#end
#end
#No. 184667
#File: E:\bishe\1\WhoisListener.java
#Comment:
    /**
     *
     * @param event
     */

#Code:
    @Override
    public void onWhois(WhoisEvent event) {
        if (ircBot.whoisSenders.isEmpty()) {
            return;
        }
        CommandSender sender = ircBot.whoisSenders.remove(0);

        sender.sendMessage(ChatColor.LIGHT_PURPLE + "----[ " + ChatColor.WHITE + "Whois" + ChatColor.LIGHT_PURPLE + " ]----");
        sender.sendMessage(ChatColor.LIGHT_PURPLE + "Nick: " + ChatColor.WHITE + event.getNick());
        sender.sendMessage(ChatColor.LIGHT_PURPLE + "Username: " + ChatColor.WHITE + event.getLogin() + "@" + event.getHostname());
        sender.sendMessage(ChatColor.LIGHT_PURPLE + "Real name: " + ChatColor.WHITE + event.getRealname());
        sender.sendMessage(ChatColor.LIGHT_PURPLE + "Server: " + ChatColor.WHITE + event.getServer());
        User user = null;
        for (Channel channel : ircBot.getBot().getUserBot().getChannels()) {
            for (User u : channel.getUsers()) {
                if (u.getNick().equalsIgnoreCase(event.getNick())) {
                    user = u;
                    break;
                }
            }
        }
        if (user != null) {
            if (user.isAway()) {
                sender.sendMessage(ChatColor.LIGHT_PURPLE + "Away: " + ChatColor.WHITE + user.getAwayMessage());
            }
        }
        if (!event.getChannels().isEmpty()) {
            StringBuilder sb = new StringBuilder();
            for (Object channel : (List<String>) event.getChannels()) {
                sb.append(" ");
                sb.append(channel);
            }
            sender.sendMessage(ChatColor.LIGHT_PURPLE + "Currently on:" + ChatColor.WHITE + sb.toString());
        }
        sender.sendMessage(ChatColor.LIGHT_PURPLE + "Idle: " + ChatColor.WHITE + secondsToTime(event.getIdleSeconds()));
        sender.sendMessage(ChatColor.LIGHT_PURPLE + "Online since: " + ChatColor.WHITE + secondsToDate(event.getSignOnTime()));
        sender.sendMessage(ChatColor.LIGHT_PURPLE + "----[ " + ChatColor.WHITE + "End Whois" + ChatColor.LIGHT_PURPLE + " ]----");
    }

#end
#end
#No. 184668
#File: E:\bishe\1\WhoisParseException.java
#Comment:
	/**
	 * @param message
	 * @param cause
	 */

#Code:
	public WhoisParseException(String message, Throwable cause) {
		super(message, cause);
	}

#end
#end
#No. 184669
#File: E:\bishe\1\WholeColumnFamilyIterator.java
#Comment:
    /**
     * @param currentRow All keys have this in their row portion (do not modify!).
     * @param keys       One key for each key in the row, ordered as they are given by the source iterator (do not modify!).
     * @param values     One value for each key in keys, ordered to correspond to the ordering in keys (do not modify!).
     * @return true if we want to keep the row, false if we want to skip it
     */

#Code:
    protected boolean filter(Text currentRow, Collection<Map.Entry<Key,Value>> keysValues) {
        return true;
    }

#end
#end
#No. 184670
#File: E:\bishe\1\WhtsExtension.java
#Comment:
	/**
	 * 
	 * @param object
	 */

#Code:
	private void readData() {

		if (mManager == null)
			return;
		
		dashIcon=R.drawable.ic_extension_whts;

		int mCount = mManager.getmCount();
		LOGD(TAG,"count="+mCount);

		if (mCount > 0) {
			dashVisible = true;

			dashStatus = "" + mCount;
			
			Resources res = getResources();
			String book = res.getQuantityString(R.plurals.notifications,
					mCount, mCount);
			dashTitle = book;
		
			ArrayList<MessageWht> msgs = mManager.getmMsgs();
			if (msgs != null) {
				StringBuilder sb = new StringBuilder();
				String and = "";
				
				for (MessageWht msg:msgs) {
						sb.append(and);
						sb.append(msg.getText());
						and="\n";
				}
				
				dashSubtitle=sb.toString();
			}

		} else {
			dashVisible = false;
		}

	}

#end
#end
#No. 184671
#File: E:\bishe\1\WhtsNotificationListener.java
#Comment:
	/**
	 * Add a single notification
	 * 
	 * @param sbn     statusbarnotification
	 * @param update  true to update the dashclock
	 */

#Code:
	public void addNotification(StatusBarNotification sbn,boolean updateDash)  {
		
		if (sbn==null) return;
		
		if (sbn!=null && sbn.getPackageName().equalsIgnoreCase("com.whatsapp")){
			MessageManager mManager=MessageManager.getInstance(this);
			if (mManager!=null){
				mManager.addNotification(sbn.getNotification(),sbn.getPostTime(),updateDash);
			}
		}
		
	}

#end
#end
#No. 184672
#File: E:\bishe\1\WhylineProgressBar.java
#Comment:
	/**
	 * Automatically prefixes with <html>
	 */

#Code:
	public void setNote(String note) {
		
		this.setText("<html>" + note);
		
	}






#end
#end
#No. 184677
#File: E:\bishe\1\WicketModule.java
#Comment:
   /**
    * Call in the <code>init()</code> method of the
    * application to setup this module to work with
    * the given application.
    */

#Code:
   public void init(Application application) {
      registerInfrastructure(application);
      registerPages();
   }

#end
#end
#No. 184678
#File: E:\bishe\1\WicketModule.java
#Comment:
   /**
    * Add a bookmarkable page to the page factory. In wicket there are two
    * types of pages, one that is bookmarkable, that is, it can be instantiated
    * automatically by wicket, and the other is self-instantiated. The latter
    * can be covered by providing <i>Suppliers</i> for each page. Bookmarkable
    * pages need to be however registered with this method. Each bookmarkable
    * page optionally can choose to support <i>PageParameters</i>.
    * @param pageClass The class of the page. This will be used as key by Wicket
    * to produce a new instance of a Page.
    * @param factory The factory function to create a new instance of the given
    * page. Page parameters will always be non-null, but the factory can choose
    * to ignore page parameters.
    */

#Code:
   protected <P extends IRequestablePage> void addPage(
         Class<P> pageClass, Function<PageParameters, P> factory) {
      pageFactories.put(pageClass, factory);
   }

#end
#end
#No. 184679
#File: E:\bishe\1\Wicketopia.java
#Comment:
    /**
     * Installs Wicketopia into the currently-running web application using all default settings.
     */

#Code:
    public static void install() {
        new Wicketopia().install(WebApplication.get());
    }

#end
#end
#No. 184680
#File: E:\bishe\1\Wicketopia.java
#Comment:
    /**
     * Retrieves a plugin by type
     *
     * @param pluginType the plugin type
     * @param <P>        the plugin type
     * @return the plugin
     */

#Code:
    public <P extends WicketopiaPlugin> P getPlugin(Class<P> pluginType) {
        for (WicketopiaPlugin plugin : plugins) {
            if (pluginType.isInstance(plugin)) {
                return pluginType.cast(plugin);
            }
        }
        throw new WicketRuntimeException("No plugin of type " + pluginType.getName() + " is installed.");
    }

#end
#end
#No. 184681
#File: E:\bishe\1\WicketOrientDbAuthorizationStrategy.java
#Comment:
/**
 * {@link CompoundAuthorizationStrategy} for OrientDB specific applications. It uses:
 * <ul>
 * <li>{@link AnnotationsRoleAuthorizationStrategy}</li>
 * <li>{@link OrientResourceAuthorizationStrategy}</li>
 * </ul>
 */

#Code:
public class WicketOrientDbAuthorizationStrategy extends
		CompoundAuthorizationStrategy {
	
	public WicketOrientDbAuthorizationStrategy(final IRoleCheckingStrategy roleCheckingStrategy)
	{
		add(new AnnotationsRoleAuthorizationStrategy(roleCheckingStrategy));
		add(new OrientResourceAuthorizationStrategy());
	}
}

#end
#end
#No. 184682
#File: E:\bishe\1\WideDynamicMode.java
#Comment:
/**
 * <p>Java class for WideDynamicMode.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="WideDynamicMode"&gt;
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string"&gt;
 *     &lt;enumeration value="OFF"/&gt;
 *     &lt;enumeration value="ON"/&gt;
 *   &lt;/restriction&gt;
 * &lt;/simpleType&gt;
 * </pre>
 * 
 */

#Code:
@XmlType(name = "WideDynamicMode")
@XmlEnum
public enum WideDynamicMode {

    OFF,
    ON;

    public String value() {
        return name();
    }

    public static WideDynamicMode fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 184683
#File: E:\bishe\1\WideRouter.java
#Comment:
    /**
     */

#Code:
    void stopSelf() {
        mIsStopping = true;
        new Thread(new Runnable() {
            @Override
            public void run() {
                List<String> locals = new ArrayList<>();
                locals.addAll(mLocalRouterAIDLMap.keySet());
                for (String domain : locals) {
                    ILocalRouterAIDL aidl = mLocalRouterAIDLMap.get(domain);
                    if (null != aidl) {
                        try {
                            aidl.stopWideRouter();
                        } catch (RemoteException e) {
                            e.printStackTrace();
                        }
                        mApplication.unbindService(mLocalRouterConnectionMap.get(domain));
                        mLocalRouterAIDLMap.remove(domain);
                        mLocalRouterConnectionMap.remove(domain);
                    }
                }
                try {
                    Thread.sleep(1000);
                    mApplication.stopService(new Intent(mApplication, WideRouterConnectService.class));
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.exit(0);
            }
        }).start();
    }

#end
#end
#No. 184685
#File: E:\bishe\1\WidgetBean.java
#Comment:
    /**
     * We create the {@link JpaWidgetDao}
     */

#Code:
    @PostConstruct
    @SuppressWarnings("unused")
    private void initialize() {
        widgetDao = new JpaWidgetDao(em);
    }

#end
#end
#No. 184686
#File: E:\bishe\1\WidgetBean.java
#Comment:
    /**
     * @return list of all widgets
     */

#Code:
    public final List<Widget> listAll() {
        return widgetDao.listAll();
    }

#end
#end
#No. 184687
#File: E:\bishe\1\WidgetBean.java
#Comment:
    /**
     * @param id
     *        the Widget id
     * @return the found Widget
     */

#Code:
    public final Widget findById(final int id) {
        return widgetDao.findById(id);
    }

#end
#end
#No. 184689
#File: E:\bishe\1\WidgetButtonNextPage.java
#Comment:
	/**
	 * Draws this button to the screen.
	 */

#Code:
	@Override
	public void drawButton(Minecraft par1Minecraft, int par2, int par3)
	{
		if (this.visible)
		{
			boolean flag = par2 >= this.xPosition && par3 >= this.yPosition && par2 < this.xPosition + this.width && par3 < this.yPosition + this.height;
			GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
			par1Minecraft.getTextureManager().bindTexture(bookGui);
			int k = 0;
			int l = 192;

			if (flag)
			{
				k += 23;
			}

			if (!this.nextPage)
			{
				l += 13;
			}

			this.drawTexturedModalRect(this.xPosition, this.yPosition, k, l, 23, 13);
		}
	}


#end
#end
#No. 184691
#File: E:\bishe\1\WidgetButtonSortDirection.java
#Comment:
	/**
	 * Draws this button to the screen.
	 */

#Code:
	@Override
	public void drawButton(Minecraft mc, int mouseX, int mouseY)
	{
		if (this.visible)
		{
			boolean isHovered = mouseX >= this.xPosition && mouseY >= this.yPosition && mouseX < this.xPosition + this.width && mouseY < this.yPosition + this.height;
			GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
			mc.getTextureManager().bindTexture(modIcons);
			int x = 0;
			int y = 0;

			if (isHovered)
			{
				x += this.width;
			}

			if (!sortDesc)
			{
				x += this.width * 2;
			}

			this.drawTexturedModalRect(this.xPosition, this.yPosition, x, y, width, height);
		}
	}

#end
#end
#No. 184694
#File: E:\bishe\1\WidgetConfigure.java
#Comment:
    /**
     * Click listener to handle create button click
     */

#Code:
    View.OnClickListener mOnCreateClickListener = new View.OnClickListener() {
        public void onClick(View v) {
            final Context context = WidgetConfigure.this;
            AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);

            // Update widget view
            int napDuration = getNapDuration();
            NapplyWidget.setNapDuration(context, mAppWidgetId, napDuration);
            NapplyWidget.updateAppWidget(context, appWidgetManager, mAppWidgetId);

            // Make sure we pass back the original appWidgetId
            Intent resultValue = new Intent();
            resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
            setResult(RESULT_OK, resultValue);
            finish();
        }
    };

#end
#end
#No. 184695
#File: E:\bishe\1\WidgetConfigure.java
#Comment:
    /**
     * Click listener to handle cancel button click
     */

#Code:
    View.OnClickListener mOnCancelClickListener = new View.OnClickListener() {
        public void onClick(View v) {
            finish();
        }
    };

#end
#end
#No. 184696
#File: E:\bishe\1\WidgetConfigure.java
#Comment:
    /**
     * Configure nap duration pickers with correct ranges and default values
     */

#Code:
    private void configurePickers() {
        mHourPicker = (NumberPicker) findViewById(R.id.nap_hour);
        mHourPicker.setRange(0, 23);
        mHourPicker.setCurrent(DEFAULT_NAP_HOURS);

        mMinutePicker = (NumberPicker) findViewById(R.id.nap_minute);
        mMinutePicker.setRange(0, 59);
        mMinutePicker.setCurrent(DEFAULT_NAP_MINUTES);
    }

#end
#end
#No. 184697
#File: E:\bishe\1\WidgetConfigure.java
#Comment:
    /**
     * Computes the total nap duration
     * @return the nap duration, in minutes
     */

#Code:
    public int getNapDuration()
    {
        return mHourPicker.getCurrent() * 60 + mMinutePicker.getCurrent();
    }


#end
#end
#No. 184700
#File: E:\bishe\1\WidgetCursorAdapter.java
#Comment:
        /**
         * 
         * @param t
         *            view type
         * @param l
         *            layout id
         * @param i
         *            index
         * @param r
         *            default resource
         * @param u
         *            clickable
         */

#Code:
        ItemMapping(int t, int l, int i, int r, boolean u) {
            type = t;
            layoutId = l;
            defaultResource = r;
            index = i;
            clickable = u;
        }

#end
#end
#No. 184701
#File: E:\bishe\1\WidgetCursorAdapter.java
#Comment:
    /**
     * 
     * @param context
     *            remote context
     * @param c
     *            cursor for reading data
     * @param intent
     *            broadcast intent initiated the replacement, don't save it
     * @param appWidgetId
     * @param listViewId
     */

#Code:
    public WidgetCursorAdapter(Activity a, Context context, Cursor c, Intent intent,
            ComponentName provider, int appWidgetId, int listViewId)
            throws IllegalArgumentException {
        super(context, c);

        mAppWidgetId = appWidgetId;
        mListViewId = listViewId;
        mAppWidgetProvider = provider;
        mInflater = LayoutInflater.from(context);
        
        // verify is contentProvider requery is allowed
        mAllowRequery = intent.getBooleanExtra(
                LauncherIntent.Extra.Scroll.EXTRA_DATA_PROVIDER_ALLOW_REQUERY, false);

        // Get the layout if for items
        mItemLayoutId = intent.getIntExtra(LauncherIntent.Extra.Scroll.EXTRA_ITEM_LAYOUT_ID, -1);
        if (mItemLayoutId <= 0)
            throw (new IllegalArgumentException("The passed layout id is illegal"));

        mItemChildrenClickable = intent.getBooleanExtra(
                LauncherIntent.Extra.Scroll.EXTRA_ITEM_CHILDREN_CLICKABLE, false);

        mItemActionUriIndex = intent.getIntExtra(
                LauncherIntent.Extra.Scroll.EXTRA_ITEM_ACTION_VIEW_URI_INDEX, -1);

        // Generate
        generateItemMapping(intent);

    }

#end
#end
#No. 184702
#File: E:\bishe\1\WidgetCursorAdapter.java
#Comment:
    /**
     * Collect arrays and put them together
     * 
     * @param t
     * @param ids
     * @param c
     * @param u
     *            uri indices; could be zero, IMPOSSIBLE_INDEX will be used
     */

#Code:
    private void generateItemMapping(Intent intent) {

        // Read the mapping data
        int[] viewTypes = intent
                .getIntArrayExtra(LauncherIntent.Extra.Scroll.Mapping.EXTRA_VIEW_TYPES);
        int[] viewIds = intent.getIntArrayExtra(LauncherIntent.Extra.Scroll.Mapping.EXTRA_VIEW_IDS);
        int[] cursorIndices = intent
                .getIntArrayExtra(LauncherIntent.Extra.Scroll.Mapping.EXTRA_CURSOR_INDICES);
        int[] defaultResources = intent
                .getIntArrayExtra(LauncherIntent.Extra.Scroll.Mapping.EXTRA_DEFAULT_RESOURCES);
        boolean[] viewClickable = intent
                .getBooleanArrayExtra(LauncherIntent.Extra.Scroll.Mapping.EXTRA_VIEW_CLICKABLE);

        // Check
        if (viewTypes == null || viewIds == null || cursorIndices == null)
            throw (new IllegalArgumentException("A mapping component is missing"));

        if (viewTypes.length == viewIds.length && viewTypes.length == cursorIndices.length) {
        } else
            throw (new IllegalArgumentException("Mapping inconsistent"));

        // Init mapping array
        final int size = viewTypes.length;
        mItemMappings = new ItemMapping[size];
        for (int i = size - 1; i >= 0; i--)
            mItemMappings[i] = new ItemMapping(viewTypes[i], viewIds[i], cursorIndices[i]);

        // Put extra data in if they are available
        if (viewClickable != null && viewClickable.length == size)
            for (int i = size - 1; i >= 0; i--)
                mItemMappings[i].clickable = viewClickable[i];

        if (defaultResources != null && defaultResources.length == size)
            for (int i = size - 1; i >= 0; i--)
                mItemMappings[i].defaultResource = defaultResources[i];

    }

#end
#end
#No. 184703
#File: E:\bishe\1\WidgetDirectiveBuilder.java
#Comment:
    /**
     * Build directive corresponding to the widget descriptive json file which has changed.
     * Resulting js file is created in the same directory than the json file overriding previous build.
     *
     * @param jsonPath is the path to the widget file to build.
     * @throws IOException
     */

#Code:
    @Override
    public void build(Path jsonPath) throws IOException {
        Widget widget = widgetLoader.get(jsonPath);
        write(
                get(valueOf(jsonPath).replace(".json", ".js")),
                htmlBuilder
                        .with("escapedTemplate", htmlSanitizer.escapeSingleQuotesAndNewLines(widget.getTemplate()))
                        .build(widget).getBytes(StandardCharsets.UTF_8));
    }

#end
#end
#No. 184704
#File: E:\bishe\1\WidgetDirectiveBuilderTest.java
#Comment:
    /**
     * Read directive content found at widgetId/widgetId.js
     *
     * @param widgetId id of the widget
     * @return the directive as a string
     * @throws IOException
     */

#Code:
    private String readDirective(String widgetId) throws IOException {
        return new String(readAllBytes(resolve(widgetId + "/" + widgetId + ".js")));
    }

#end
#end
#No. 184705
#File: E:\bishe\1\WidgetDirectiveBuilderTest.java
#Comment:
    /**
     * Generate directive
     *
     * @param widget from which the directive is generated
     * @return the directive as a string
     * @throws IOException
     */

#Code:
    private String generateDirective(Widget widget) throws IOException {
        return htmlBuilder.with("escapedTemplate", widget.getTemplate()).build(widget);
    }

#end
#end
#No. 184706
#File: E:\bishe\1\WidgetDirectiveBuilderTest.java
#Comment:
    /**
     * Write contents into widgetId/widgetId.js file.
     *
     * @param widgetId id of the widget
     * @param contents contents of the file
     * @throws IOException
     */

#Code:
    private void writeDirective(String widgetId, byte[] contents) throws IOException {
        write(resolve(widgetId + "/" + widgetId + ".js"), contents);
    }

#end
#end
#No. 184707
#File: E:\bishe\1\WidgetDirectiveBuilderTest.java
#Comment:
    /**
     * Resolve path from widgetRepositoryDirectory
     *
     * @param path to resolve
     * @return resolved path
     */

#Code:
    private Path resolve(String path) {
        return widgetRepositoryDirectory.getRoot().toPath().resolve(path);
    }


#end
#end
#No. 184709
#File: E:\bishe\1\WidgetFrequencyDomainType.java
#Comment:
	/**
	 * @return    "Live View" or "Waveform View" or "Waterfall View"
	 */

#Code:
	public String getType() {
		
		return typeCombobox.getSelectedItem().toString();
		
	}

#end
#end
#No. 184710
#File: E:\bishe\1\WidgetFrequencyDomainType.java
#Comment:
	/**
	 * @return    The sample count.
	 */

#Code:
	public int getSampleCount() {
		
		return Integer.parseInt(sampleCountTextfield.getText());
		
	}

#end
#end
#No. 184711
#File: E:\bishe\1\WidgetFrequencyDomainType.java
#Comment:
	/**
	 * @return    The total sample count.
	 */

#Code:
	public int getTotalSampleCount() {
		
		return Integer.parseInt(totalSampleCountTextfield.getText());
		
	}

#end
#end
#No. 184712
#File: E:\bishe\1\WidgetFrequencyDomainType.java
#Comment:
	/**
	 * @return    The row count for Waveform View.
	 */

#Code:
	public int getRowCount() {
		
		return Integer.parseInt(rowCountTextfield.getText());
		
	}

#end
#end
#No. 184713
#File: E:\bishe\1\WidgetHistogramXaxisType.java
#Comment:
	/**
	 * Ensures that minimum < maximum.
	 */

#Code:
	private void sanityCheckMinMax() {
		
		try {
			
			// clip to limits
			maxTextfield.setText(maxTextfield.getText().trim());
			minTextfield.setText(minTextfield.getText().trim());
			float max = Float.parseFloat(maxTextfield.getText());
			float min = Float.parseFloat(minTextfield.getText());
			if(max > upperLimit) max = upperLimit;
			if(max < lowerLimit) max = lowerLimit;
			if(min > upperLimit) min = upperLimit;
			if(min < lowerLimit) min = lowerLimit;
			
			// ensure min < max
			if(min == max) {
				if(max == upperLimit)
					min = Math.nextDown(min);
				else
					max = Math.nextUp(max);
			} else if(min > max) {
				float temp = max;
				max = min;
				min = temp;
			}
			
			// update textfields
			maxTextfield.setText(Float.toString(max));
			minTextfield.setText(Float.toString(min));
			
		} catch(Exception e) {
			
			// one of the textfields doesn't contain a valid number, so reset both to defaults
			maxTextfield.setText(Float.toString(defaultMaximum));
			minTextfield.setText(Float.toString(defaultMinimum));
			
		}
		
	}

#end
#end
#No. 184714
#File: E:\bishe\1\WidgetHistogramXaxisType.java
#Comment:
	/**
	 * Checks if the axis mode is "normal" or "locked center"
	 * 
	 * @return    True if the axis mode is "locked center"
	 */

#Code:
	public boolean isAxisCentered() {
		
		return axisTypeCombobox.getSelectedItem().toString().equals("Locked Center");
		
	}

#end
#end
#No. 184715
#File: E:\bishe\1\WidgetHistogramXaxisType.java
#Comment:
	/**
	 * Gets the axis center value. This should only be called if isAxisCentered() returns true.
	 * 
	 * @return    The center value for this axis.
	 */

#Code:
	public float getCenterValue() {
		
		return Float.parseFloat(centerTextfield.getText());
		
	}

#end
#end
#No. 184716
#File: E:\bishe\1\WidgetHistogramXaxisType.java
#Comment:
	/**
	 * Checks if the axis maximum should be automatic. This should only be called if isAxisCentered() returns false.
	 * 
	 * @return    True if the maximum should be automatic.
	 */

#Code:
	public boolean isMaximumAutomatic() {
		
		return maxCheckbox.isSelected();
		
	}

#end
#end
#No. 184717
#File: E:\bishe\1\WidgetHistogramXaxisType.java
#Comment:
	/**
	 * Checks if the axis minimum should be automatic. This should only be called if isAxisCentered() returns false.
	 * 
	 * @return    True if the minimum should be automatic.
	 */

#Code:
	public boolean isMinimumAutomatic() {
		
		return minCheckbox.isSelected();
		
	}

#end
#end
#No. 184718
#File: E:\bishe\1\WidgetHistogramXaxisType.java
#Comment:
	/**
	 * Gets the axis maximum value. This should only be called if isAxisCentered() returns false and isMaximumAutomatic() returns false.
	 * 
	 * @return    The maximum value for this axis.
	 */

#Code:
	public float getMaximumValue() {
		
		return Float.parseFloat(maxTextfield.getText());
		
	}

#end
#end
#No. 184719
#File: E:\bishe\1\WidgetHistogramXaxisType.java
#Comment:
	/**
	 * Gets the axis minimum value. This should only be called if isAxisCentered() returns false and isMinimumAutomatic() returns false.
	 * 
	 * @return    The minimum value for this axis.
	 */

#Code:
	public float getMinimumValue() {
		
		return Float.parseFloat(minTextfield.getText());
		
	}

#end
#end
#No. 184720
#File: E:\bishe\1\WidgetHistogramYaxisType.java
#Comment:
	/**
	 * @return    True if relative frequency should be shown.
	 */

#Code:
	public boolean isRelativeFrequencyShown() {
		
		return axisTypeCombobox.getSelectedItem().toString().equals("Relative Frequency") || axisTypeCombobox.getSelectedItem().toString().equals("Both");
		
	}

#end
#end
#No. 184721
#File: E:\bishe\1\WidgetHistogramYaxisType.java
#Comment:
	/**
	 * @return    True if frequency should be shown.
	 */

#Code:
	public boolean isFrequencyShown() {
		
		return axisTypeCombobox.getSelectedItem().toString().equals("Frequency") || axisTypeCombobox.getSelectedItem().toString().equals("Both");
		
	}

#end
#end
#No. 184722
#File: E:\bishe\1\WidgetHistogramYaxisType.java
#Comment:
	/**
	 * @return    True if the maximum should be automatic.
	 */

#Code:
	public boolean isMaximumAutomatic() {
		
		return maxCheckbox.isSelected();
		
	}

#end
#end
#No. 184723
#File: E:\bishe\1\WidgetHistogramYaxisType.java
#Comment:
	/**
	 * @return    True if the minimum should be zero.
	 */

#Code:
	public boolean isMinimumZero() {
		
		return minCheckbox.isSelected();
		
	}

#end
#end
#No. 184724
#File: E:\bishe\1\WidgetHistogramYaxisType.java
#Comment:
	 /** 
	 * @return    The maximum value for this axis.
	 */

#Code:
	public float getMaximumValue() {
		
		return Float.parseFloat(maxTextfield.getText());
		
	}

#end
#end
#No. 184725
#File: E:\bishe\1\WidgetHistogramYaxisType.java
#Comment:
	 /** 
	 * @return    The minimum value for this axis.
	 */

#Code:
	public float getMinimumValue() {
		
		return Float.parseFloat(minTextfield.getText());
		
	}

#end
#end
#No. 184726
#File: E:\bishe\1\WidgetListAdapter.java
#Comment:
		/**
		 *
		 * @param t
		 *            view type
		 * @param l
		 *            layout id
		 * @param i
		 *            index
		 * @param r
		 *            default resource
		 * @param u
		 *            clickable
		 */

#Code:
		ItemMapping(int t, int l, int i, int r, boolean u) {
			type = t;
			layoutId = l;
			defaultResource = r;
			index = i;
			clickable = u;
		}

#end
#end
#No. 184727
#File: E:\bishe\1\WidgetListAdapter.java
#Comment:
	/**
	 *
	 * @param context
	 *            remote context
	 * @param c
	 *            cursor for reading data
	 * @param intent
	 *            broadcast intent initiated the replacement, don't save it
	 * @param appWidgetId
	 * @param listViewId
	 */

#Code:
    public WidgetListAdapter(Context context, Intent intent, ComponentName provider,
            int appWidgetId, int listViewId) throws IllegalArgumentException {
 		super();

		mAppWidgetId = appWidgetId;
		mListViewId = listViewId;
		mContentResolver = context.getContentResolver();
		mIntent = intent;
		mAppWidgetProvider = provider;
		mInflater = LayoutInflater.from(context);

		// verify is contentProvider requery is allowed
        mAllowRequery = intent.getBooleanExtra(
                LauncherIntent.Extra.Scroll.EXTRA_DATA_PROVIDER_ALLOW_REQUERY, false);

        // Get the layout if for items
        mItemLayoutId = intent.getIntExtra(LauncherIntent.Extra.Scroll.EXTRA_ITEM_LAYOUT_ID, -1);
        if (mItemLayoutId <= 0)
            throw (new IllegalArgumentException("The passed layout id is illegal"));

        mItemChildrenClickable = intent.getBooleanExtra(
                LauncherIntent.Extra.Scroll.EXTRA_ITEM_CHILDREN_CLICKABLE, false);

        mItemActionUriIndex = intent.getIntExtra(
                LauncherIntent.Extra.Scroll.EXTRA_ITEM_ACTION_VIEW_URI_INDEX, -1);

		// Generate item mapping
		generateItemMapping(intent);

        mAsyncQuery=new MyQueryHandler(mContentResolver);
		// Generate data cache from content provider
		mHandler.post(mGenerateDataCacheRunnable);
	}

#end
#end
#No. 184728
#File: E:\bishe\1\WidgetListAdapter.java
#Comment:
	/**
	 * Collect arrays and put them together
	 *
	 * @param t
	 * @param ids
	 * @param c
	 * @param u
	 *            uri indices; could be zero, IMPOSSIBLE_INDEX will be used
	 */

#Code:
	private void generateItemMapping(Intent intent) {

		// Read the mapping data
        int[] viewTypes = intent
                .getIntArrayExtra(LauncherIntent.Extra.Scroll.Mapping.EXTRA_VIEW_TYPES);
        int[] viewIds = intent.getIntArrayExtra(LauncherIntent.Extra.Scroll.Mapping.EXTRA_VIEW_IDS);
        int[] cursorIndices = intent
                .getIntArrayExtra(LauncherIntent.Extra.Scroll.Mapping.EXTRA_CURSOR_INDICES);
        int[] defaultResources = intent
                .getIntArrayExtra(LauncherIntent.Extra.Scroll.Mapping.EXTRA_DEFAULT_RESOURCES);
        boolean[] viewClickable = intent
                .getBooleanArrayExtra(LauncherIntent.Extra.Scroll.Mapping.EXTRA_VIEW_CLICKABLE);

		// Check
		if (viewTypes == null || viewIds == null || cursorIndices == null)
			throw (new IllegalArgumentException("A mapping component is missing"));

		if (viewTypes.length == viewIds.length && viewTypes.length == cursorIndices.length) {
		} else
			throw (new IllegalArgumentException("Mapping inconsistent"));

		// Init mapping array
		final int size = viewTypes.length;
		mItemMappings = new ItemMapping[size];
		for (int i = size - 1; i >= 0; i--)
			mItemMappings[i] = new ItemMapping(viewTypes[i], viewIds[i], cursorIndices[i]);

		// Put extra data in if they are available
		if (viewClickable != null && viewClickable.length == size)
			for (int i = size - 1; i >= 0; i--)
				mItemMappings[i].clickable = viewClickable[i];

		if (defaultResources != null && defaultResources.length == size)
			for (int i = size - 1; i >= 0; i--)
				mItemMappings[i].defaultResource = defaultResources[i];

	}

#end
#end
#No. 184729
#File: E:\bishe\1\WidgetMarketplaceController.java
#Comment:
	/**
	 * Views the marketplace tab of the Add New Widget page
	 * @param model
	 * @param referringPageId
	 * @return the view name of the marketplace tab
	 */

#Code:
	@RequestMapping(method = RequestMethod.GET)
	public String viewSearchResult(Model model,
			@RequestParam String referringPageId,
            @RequestParam(required = false, defaultValue = "0") int offset) {

		final String view = ViewNames.ADD_WIDGET_MARKETPLACE;

		User user = userService.getAuthenticatedUser();
		widgetStoreModelHelper(model, referringPageId, user, view);

		try {
			model.addAttribute(ModelKeys.WIDGETS, marketplaceService
					.getWidgetsByFreeTextSearch("", offset, getPageSize()));
			model.addAttribute(ModelKeys.CATEGORIES, marketplaceService.getCategories());
		} catch (Exception e) {
			model.addAttribute(ModelKeys.ERROR_MESSAGE, "Marketplace not available");
		}

#end
#end
#No. 184730
#File: E:\bishe\1\WidgetMarketplaceController.java
#Comment:
	/**
	 * Views the marketplace tab with search results 
	 * @param model
	 * @param referringPageId
	 * @param searchTerm
	 * @param offset
	 * @return
	 */

#Code:
	@RequestMapping(value = { "marketplace/search" }, method = RequestMethod.GET)
	public String viewSearchResult(Model model,
			@RequestParam String referringPageId,
			@RequestParam String searchTerm,
			@RequestParam(required = false, defaultValue = "0") int offset) {

		final String view = ViewNames.ADD_WIDGET_MARKETPLACE;

		User user = userService.getAuthenticatedUser();
		widgetStoreModelHelper(model, referringPageId, user, view);

		try {
			model.addAttribute(ModelKeys.WIDGETS, marketplaceService
					.getWidgetsByFreeTextSearch(searchTerm, offset, getPageSize()));
			model.addAttribute(ModelKeys.CATEGORIES, marketplaceService.getCategories());
		} catch (Exception e) {
			model.addAttribute(ModelKeys.ERROR_MESSAGE, "Marketplace not available");
		}

#end
#end
#No. 184731
#File: E:\bishe\1\WidgetMarketplaceController.java
#Comment:
	/**
	 * Views the marketplace tab with category results 
	 * @param model
	 * @param referringPageId
	 * @param category
	 * @param offset
	 * @return
	 */

#Code:
	@RequestMapping(value = { "category/{category}" }, method = RequestMethod.GET)
	public String viewCategory(Model model,
			@RequestParam String referringPageId,
			@PathVariable String category,
			@RequestParam(required = false, defaultValue = "0") int offset) {

		final String view = ViewNames.ADD_WIDGET_MARKETPLACE;

		User user = userService.getAuthenticatedUser();
		widgetStoreModelHelper(model, referringPageId, user, view);

        try {
            if(category.equals("0")){
                model.addAttribute(ModelKeys.WIDGETS, marketplaceService
                    .getWidgetsByFreeTextSearch("", offset, getPageSize()));
                model.addAttribute(ModelKeys.CATEGORIES, marketplaceService.getCategories());
            }else{
                model.addAttribute(ModelKeys.WIDGETS, marketplaceService.getWidgetsByCategory(category, offset, getPageSize()));
                model.addAttribute(ModelKeys.CATEGORIES, marketplaceService.getCategories());
                model.addAttribute(ModelKeys.SELECTED_CATEGORY, category);
            }
		} catch (Exception e) {
			model.addAttribute(ModelKeys.ERROR_MESSAGE, "Marketplace not available");
		}

#end
#end
#No. 184732
#File: E:\bishe\1\WidgetMarketplaceController.java
#Comment:
	/**
	 * View the marketplace tab showing a single widget detail
	 * @return the view
	 */

#Code:
	@RequestMapping(value = {"widget/{widget}"}, method=RequestMethod.GET)
	public String viewWidgetDetail(Model model,
			@RequestParam String referringPageId,
			@RequestParam String externalId,
			@PathVariable String widget){
		
		final String view = ViewNames.WIDGET_MARKETPLACE;
		User user = userService.getAuthenticatedUser();
		widgetStoreModelHelper(model, referringPageId, user, view);
		try {
			model.addAttribute(ModelKeys.WIDGET, marketplaceService.getWidget(externalId));
		} catch (Exception e) {
			model.addAttribute(ModelKeys.ERROR_MESSAGE, "Marketplace not available");
		}

#end
#end
#No. 184733
#File: E:\bishe\1\WidgetMarketplaceController.java
#Comment:
	/*
	 * Add common model attributes to the model
	 * 
	 * @param model
	 *            Model to add to
	 * @param referringPageId
	 *            Page to refer back to
	 * @param user
	 *            Current authenticated User
	 */

#Code:
	private void widgetStoreModelHelper(Model model, String referringPageId,
			User user, String view) {
		model.addAttribute(ModelKeys.REFERRING_PAGE_ID, referringPageId);
		ControllerUtils.addNavItemsToModel(view, model, referringPageId, user);
	}

#end
#end
#No. 184734
#File: E:\bishe\1\WidgetMarketplaceWidgetResult.java
#Comment:
    /**
     * @return the widgets
     */

#Code:
    public MarketplaceWidgetDetailResult getWidgetProfile() {
        return widgetProfile;
    }

#end
#end
#No. 184735
#File: E:\bishe\1\WidgetMatcherFactory.java
#Comment:
  /**
   * Matches a workbench part (view/editor) with the specfied name.
   * 
   * @param text the label of the part.
   * @return a matcher.
   * @since 2.0
   */

#Code:
  public static <T extends org.eclipse.ui.IWorkbenchPartReference> org.hamcrest.Matcher<T> withPartName(java.lang.String text) {
    return org.eclipse.swtbot.eclipse.finder.matchers.WithPartName.withPartName(text);
  }

#end
#end
#No. 184736
#File: E:\bishe\1\WidgetMatcherFactory.java
#Comment:
  /**
   * Matches a workbench part (view/editor) with the specified name.
   * 
   * @param nameMatcher the part name matcher.
   * @return a matcher.
   * @since 2.0
   */

#Code:
  public static <T extends org.eclipse.ui.IWorkbenchPartReference> org.hamcrest.Matcher<T> withPartName(org.hamcrest.Matcher<java.lang.String> nameMatcher) {
    return org.eclipse.swtbot.eclipse.finder.matchers.WithPartName.withPartName(nameMatcher);
  }

#end
#end
#No. 184737
#File: E:\bishe\1\WidgetMatcherFactory.java
#Comment:
  /**
   * Matches a workbench part (view/editor) with the specified id.
   * 
   * @param id the id of the part.
   * @return a matcher.
   * @since 2.0
   */

#Code:
  public static <T extends org.eclipse.ui.IWorkbenchPartReference> org.hamcrest.Matcher<T> withPartId(java.lang.String id) {
    return org.eclipse.swtbot.eclipse.finder.matchers.WithPartId.withPartId(id);
  }

#end
#end
#No. 184738
#File: E:\bishe\1\WidgetMatcherFactory.java
#Comment:
  /**
   * Matches a workbench part (view/editor) with the specified id.
   * 
   * @param idMatcher the part id matcher.
   * @return a matcher.
   * @since 2.0
   */

#Code:
  public static <T extends org.eclipse.ui.IWorkbenchPartReference> org.hamcrest.Matcher<T> withPartId(org.hamcrest.Matcher<java.lang.String> idMatcher) {
    return org.eclipse.swtbot.eclipse.finder.matchers.WithPartId.withPartId(idMatcher);
  }

#end
#end
#No. 184739
#File: E:\bishe\1\WidgetMatcherFactory.java
#Comment:
  /**
   * Matches a perspective with the specified id.
   * 
   * @param id the id of the perspective.
   * @return a matcher.
   * @since 2.0
   */

#Code:
  public static org.hamcrest.Matcher withPerspectiveId(java.lang.String id) {
    return org.eclipse.swtbot.eclipse.finder.matchers.WithPerspectiveId.withPerspectiveId(id);
  }

#end
#end
#No. 184740
#File: E:\bishe\1\WidgetMatcherFactory.java
#Comment:
  /**
   * Matches a perspective with the specified id.
   * 
   * @param idMatcher the matcher that matches the id of the perspective.
   * @return a matcher.
   * @since 2.0
   */

#Code:
  public static org.hamcrest.Matcher withPerspectiveId(org.hamcrest.Matcher<java.lang.String> idMatcher) {
    return org.eclipse.swtbot.eclipse.finder.matchers.WithPerspectiveId.withPerspectiveId(idMatcher);
  }

#end
#end
#No. 184741
#File: E:\bishe\1\WidgetMatcherFactory.java
#Comment:
  /**
   * Matches a perspective with the specified label.
   * 
   * @param label the label of the perspective.
   * @return a matcher.
   * @since 2.0
   */

#Code:
  public static org.hamcrest.Matcher withPerspectiveLabel(java.lang.String label) {
    return org.eclipse.swtbot.eclipse.finder.matchers.WithPerspectiveLabel.withPerspectiveLabel(label);
  }

#end
#end
#No. 184742
#File: E:\bishe\1\WidgetMatcherFactory.java
#Comment:
  /**
   * Matches a perspective with the specified label.
   * 
   * @param labelMatcher the matcher that matches the perspective label.
   * @return a matcher.
   * @since 2.0
   */

#Code:
  public static org.hamcrest.Matcher withPerspectiveLabel(org.hamcrest.Matcher<java.lang.String> labelMatcher) {
    return org.eclipse.swtbot.eclipse.finder.matchers.WithPerspectiveLabel.withPerspectiveLabel(labelMatcher);
  }


#end
#end
#No. 184744
#File: E:\bishe\1\WidgetPreferenceActivity.java
#Comment:
    /**
     * Send an intent to update the widget.
     */

#Code:
    private void updateWidget(boolean online) {
        Intent updateIntent = new Intent(android.appwidget.AppWidgetManager.ACTION_APPWIDGET_UPDATE,
                Uri.EMPTY, this, Widget.class);
        updateIntent.putExtra(Widget.LOAD_DATA_KEY, online);
        sendBroadcast(updateIntent);
    }

#end
#end
#No. 184745
#File: E:\bishe\1\WidgetProviderService.java
#Comment:
    /**
     * Gets the object that represents the metadata about the widget for 
     * the viewer in the current context
     * @param viewer the current logged in user
     * @param context the context identifier for where the widget is displayed (e.g. regionwidget id)
     * @param widget the default widget
     * @return valid widget
     */

#Code:
    Widget getWidget(User viewer, String context, Widget widget);
}
#end
#end
#No. 184747
#File: E:\bishe\1\WidgetRemoteViewsListAdapter.java
#Comment:
    /**
     *
     * @param context
     *            remote context
     * @param c
     *            cursor for reading data
     * @param intent
     *            broadcast intent initiated the replacement, don't save it
     * @param appWidgetId
     * @param listViewId
     */

#Code:
    public WidgetRemoteViewsListAdapter(Context context, Intent intent, ComponentName provider,
            int appWidgetId, int listViewId) throws IllegalArgumentException {
        super();

        mContext = context;
        mAppWidgetProvider = provider;
        mIntent = intent;

        mRemoteViews = (BoundRemoteViews)intent.getParcelableExtra(LauncherIntent.Extra.Scroll.EXTRA_ITEM_LAYOUT_REMOTEVIEWS);
        mAsyncQuery=new MyQueryHandler(mContext.getContentResolver());
        mHandler.post(mQueryDataRunnable);
    }

#end
#end
#No. 184748
#File: E:\bishe\1\WidgetRemoteViewsListAdapter.java
#Comment:
    /**
     * AsyncQueryHandler helper class to do async queries
     * instead of blocking the UI thread
     * (yeah, don't know why but the runnable was not avoiding
     * the UI lock
     * @author adw
     *
     */

#Code:
    private class MyQueryHandler extends AsyncQueryHandler
    {
        public MyQueryHandler(ContentResolver cr) {
            super(cr);
        }

        @Override
		protected void onQueryComplete(int token, Object cookie,
                Cursor cursor) {
            super.onQueryComplete(token, cookie, cursor);
            android.util.Log.d("LAUNCHER","API v2 QUERY COMPLETE");
            mRemoteViews.setBindingCursor(cursor, mContext);
            cursor.close();
            notifyDataSetInvalidated();
        }
    }

#end
#end
#No. 184749
#File: E:\bishe\1\WidgetResolverTest.java
#Comment:
	/**
	 * For each widget found in active window check that for each 
	 * child widget returned by WidgetResolver.getInstance().getChildren(widget) 
	 * the parent returned by WidgetResolver.getInstance().getParent(childWidget) 
	 * is equal to the widget with the exception of CTabItem when the parent 
	 * returned for its control is CTabFolder which is the parent to both of them.
	 */

#Code:
	@Test
	public void parentMatchesChildrenTest() {
		Shell shell = new DefaultShell().getSWTWidget();
		List<Widget> all = WidgetLookup.getInstance().activeWidgets(shell, new BaseMatcher<Widget>() {
			@Override
			public boolean matches(Object obj) {
				return true;
			}

			@Override
			public void describeTo(Description desc) {				
			}
			
		});
		log.info("Testing " + all.size() + " widgets for matching children to parent.");

		Assert.assertFalse("Shell is empty, test cannot be done.", all.isEmpty());

		for (Widget c: all) {
			List<Widget> children = getChildrenSync(c);
			Widget p = getParentSync(c);
			for (Widget w: children) {
				Widget parent = getParentSync(w);
						
				Assert.assertNotNull("Widget " + syncToString(w) + " was returned as a child of control " + syncToString(c) + " but WidgetResolver.getInstance().getParent() returned null.", parent);
				if(c instanceof CTabItem) {
					//Now implementation should return its 'natural' parent CTabFolder.
					Assert.assertEquals("For child " + syncToString(w) + " of CTabItem was return wrong parent.", p, parent);
				} else {
					Assert.assertEquals("For child " + syncToString(w) + " was returned wrong parent " + syncToString(parent), c, parent);
				}
				log.info("Child widget " + syncToString(w) + " matches to its parent widget " + syncToString(c));
			}
		} 
	}

#end
#end
#No. 184750
#File: E:\bishe\1\WidgetScreen.java
#Comment:
  /**
   * Updates the widget screen buffer using the widgetBuffer sent by a widget.
   * 
   * @param widgetBuffer the buffer sent by a widget
   * @param sessionId the sessionId of the sender; used to determine which part of the screen to
   *        update
   * @return the updated widget screen buffer
   */

#Code:
  public byte[] updateScreenBuffer(byte[] widgetBuffer, int sessionId) {
    for (int i = 0; i < widgets.length; i++) {
      if ((widgets[i] != null) && (sessionId == sessionIds[i])) {
        System.arraycopy(widgetBuffer, 0, screenBuffer, i * BUFFER_LENGTH, BUFFER_LENGTH);
        break;
      }
    }
    
    return screenBuffer;
  }


#end
#end
#No. 184752
#File: E:\bishe\1\WidgetSpace.java
#Comment:
    /**
     * Look for a widget in all screens
     *
     * @param appWidgetId
     * @return
     */

#Code:
    final AppWidgetHostView findWidget(int appWidgetId) {
        AppWidgetHostView wv;
        for (int i = getChildCount() - 1; i >= 0; i--) {
            wv = findWidget(i, appWidgetId);
            if (wv != null)
                return wv;
        }
        return null;
    }

#end
#end
#No. 184753
#File: E:\bishe\1\WidgetSpace.java
#Comment:
    /**
     * Find widget in a given screen
     *
     * @param screen
     * @param appWidgetId
     * @return
     */

#Code:
    final AppWidgetHostView findWidget(int screen, int appWidgetId) {
        if (appWidgetId < 0)
            return null;

        View child = getChildAt(screen);
        if (child == null)
            return null;

        if (child instanceof AppWidgetHostView) {
            AppWidgetHostView widgetView = (AppWidgetHostView) child;
            if (widgetView.getAppWidgetId() == appWidgetId)
                return widgetView;
        } else if (child instanceof ViewGroup) {
            ViewGroup cells = (ViewGroup) getChildAt(screen);
            for (int i = cells.getChildCount() - 1; i >= 0; i--) {
                View widgetView = cells.getChildAt(i);
                if (widgetView instanceof AppWidgetHostView) {
                    if (((AppWidgetHostView) widgetView).getAppWidgetId() == appWidgetId)
                        return (AppWidgetHostView) widgetView;
                }
            }
        }

        return null;
    }

#end
#end
#No. 184754
#File: E:\bishe\1\WidgetSpace.java
#Comment:
        /**
         *
         * @param widgetView
         * @param dummyViewId
         * @return whether the dummy view is replaced by listview
         */

#Code:
        ListView postListView(AppWidgetHostView widgetView, int dummyViewId) {
            ListView lv = new ListView(getContext());
            lv.setCacheColorHint(0);

            if (replaceView(widgetView, dummyViewId, lv))
                return lv;
            else
                return null;
        }

#end
#end
#No. 184755
#File: E:\bishe\1\WidgetSpace.java
#Comment:
        /**
         *
         * @param vg
         * @param id
         * @param replacement
         * @return
         */

#Code:
        boolean replaceView(ViewGroup vg, int id, View replacement) {
            View child;
            boolean result = false;
            for (int i = vg.getChildCount() - 1; i >= 0; i--) {
                child = vg.getChildAt(i);
                if (child.getId() == id) {
                    // Remove the dummy
                    vg.removeView(child);
                    // Set the replacement id to be the old one
                    replacement.setId(id);
                    // Put the replacement in
                    vg.addView(replacement, i, child.getLayoutParams());
                    return true;
                } else if (child instanceof ViewGroup)
                    result |= replaceView((ViewGroup) child, id, replacement);
            }
            return result;
        }

#end
#end
#No. 184756
#File: E:\bishe\1\WidgetSpace.java
#Comment:
    /**
     * Register receivers given by this workspace
     */

#Code:
    public void registerProvider() {
        final Context context = getContext();

        IntentFilter filter = new IntentFilter();
        filter.addAction(LauncherIntent.Action.ACTION_START_FRAME_ANIMATION);
        filter.addAction(LauncherIntent.Action.ACTION_STOP_FRAME_ANIMATION);
        filter.addAction(LauncherIntent.Action.ACTION_START_TWEEN_ANIMATION);
        context.registerReceiver(mAnimationProvider, filter);

        IntentFilter scrollFilter = new IntentFilter();
        scrollFilter.addAction(LauncherIntent.Action.ACTION_SCROLL_WIDGET_START);
        scrollFilter.addAction(LauncherIntent.Action.ACTION_SCROLL_WIDGET_CLOSE);
        scrollFilter.addAction(LauncherIntent.Action.ACTION_SCROLL_WIDGET_CLEAR_IMAGE_CACHE);
        scrollFilter.addAction(LauncherIntent.Action.ACTION_SCROLL_WIDGET_SELECT_ITEM);
        context.registerReceiver(mScrollViewProvider, scrollFilter);
    }

#end
#end
#No. 184757
#File: E:\bishe\1\WidgetSpace.java
#Comment:
    /**
     * Unregister receivers given by this workspace
     */

#Code:
    public void unregisterProvider() {
        final Context context = getContext();
        unregisterReceiver(context, mAnimationProvider);
        unregisterReceiver(context, mScrollViewProvider);
    }




#end
#end
#No. 184762
#File: E:\bishe\1\WidgetStoreController.java
#Comment:
    /**
     * Validates the form input, if valid, tries to store the Widget data
     *
     * @param widget
     *            {@link org.apache.rave.model.Widget} as submitted by the user
     * @param results
     *            {@link BindingResult}
     * @param model
     *            {@link Model}
     * @param referringPageId
     *            the source {@link org.apache.rave.model.Page } ID
     * @return if successful the view name of the widget, otherwise the form
     */

#Code:
    @RequestMapping(method = RequestMethod.POST, value = "widget/add")
    public String viewAddWidgetResult(@ModelAttribute WidgetImpl widget, BindingResult results, Model model,
            @RequestParam String referringPageId) {
        User user = userService.getAuthenticatedUser();
        widgetValidator.validate(widget, results);
        if (results.hasErrors()) {
        	final String view = ViewNames.ADD_WIDGET_FORM;
            model.addAttribute(ModelKeys.WIDGET, widget);
            model.addAttribute(ModelKeys.REFERRING_PAGE_ID, referringPageId);
            ControllerUtils.addNavItemsToModel(view, model, referringPageId, user);
            return view;
        }

#end
#end
#No. 184763
#File: E:\bishe\1\WidgetStoreController.java
#Comment:
    /**
     * Validates the form input, if valid, tries to store the Widget data
     *
     * @param widget
     *            {@link org.apache.rave.model.Widget} as submitted by the user
     * @param results
     *            {@link BindingResult}
     * @param model
     *            {@link Model}
     * @param referringPageId
     *            the source {@link org.apache.rave.model.Page } ID
     * @return if successful the view name of the widget, otherwise the form
     */

#Code:
    @RequestMapping(method = RequestMethod.POST, value = "widget/add/w3c")
    public String viewAddWidgetResultW3c(@ModelAttribute WidgetImpl widget, BindingResult results, Model model,
            @RequestParam String referringPageId) {
        User user = userService.getAuthenticatedUser();
        widgetValidator.validate(widget, results);
        if (results.hasErrors()) {
        	final String view = ViewNames.ADD_WIDGET_W3C;
            model.addAttribute(ModelKeys.WIDGET, widget);
            model.addAttribute(ModelKeys.REFERRING_PAGE_ID, referringPageId);
            ControllerUtils.addNavItemsToModel(view, model, referringPageId, user);
            return view;
        }

#end
#end
#No. 184764
#File: E:\bishe\1\WidgetStoreController.java
#Comment:
    /**
     * Finalize adding a new widget created from validated form data, and redirect to its store detail page
     * @param widget
     *            {@link org.apache.rave.model.Widget} as created from form input
     * @param user
     *            the user submitting the new widget
     * @param referringPageId
     *            the source page ID
     * @return a redirection string for the store detail page.
     */

#Code:
    private String finalizeNewWidget(WidgetImpl widget, User user, String referringPageId){
        /*
         * By default, a new widget has a status of "PREVIEW", however this can be overridden in portal preferences,
         * skipping the need for an admin to approve a new widget.
         */
        PortalPreference status = preferenceService.getPreference(PortalPreferenceKeys.INITIAL_WIDGET_STATUS);
        if (status != null && status.getValue().equals("PUBLISHED")){
			widget.setWidgetStatus(WidgetStatus.PUBLISHED);
		} else {
	        widget.setWidgetStatus(WidgetStatus.PREVIEW);
		}
        
        widget.setOwnerId(user.getId());

        final Widget storedWidget = widgetService.registerNewWidget(widget);
        return "redirect:/app/store/widget/" + storedWidget.getId() + "?referringPageId=" + referringPageId;
    }

#end
#end
#No. 184765
#File: E:\bishe\1\WidgetStoreController.java
#Comment:
    /**
     * Add common model attributes to the model
     *
     * @param model
     *            Model to add to
     * @param referringPageId
     *            Page to refer back to
     * @param user
     *            Current authenticated User
     */

#Code:
    private void widgetStoreModelHelper(Model model, String referringPageId, User user, String view) {
        model.addAttribute(ModelKeys.REFERRING_PAGE_ID, referringPageId);
        model.addAttribute(ModelKeys.WIDGETS_STATISTICS, widgetService.getAllWidgetStatistics(user.getId()));
        model.addAttribute(ModelKeys.TAGS, tagService.getAllTagsList());
        model.addAttribute(ModelKeys.CATEGORIES, categoryService.getAllList());
        ControllerUtils.addNavItemsToModel(view, model, referringPageId, user);
    }


#end
#end
#No. 184767
#File: E:\bishe\1\WidgetTextfieldInteger.java
#Comment:
	/**
	 * @return    The specified value.
	 */

#Code:
	public int getValue() {
		
		return Integer.parseInt(textfield.getText());
		
	}

#end
#end
#No. 184768
#File: E:\bishe\1\WidgetTextfieldsOptionalMinMax.java
#Comment:
	/**
	 * @return    True if the maximum should be automatic.
	 */

#Code:
	public boolean isMaximumAutomatic() {
		
		return maxCheckbox.isSelected();
		
	}

#end
#end
#No. 184769
#File: E:\bishe\1\WidgetTextfieldsOptionalMinMax.java
#Comment:
	/**
	 * @return    True if the minimum should be automatic.
	 */

#Code:
	public boolean isMinimumAutomatic() {
		
		return minCheckbox.isSelected();
		
	}

#end
#end
#No. 184770
#File: E:\bishe\1\WidgetTextfieldsOptionalMinMax.java
#Comment:
	 /** 
	 * @return    The maximum value.
	 */

#Code:
	public float getMaximumValue() {
		
		return Float.parseFloat(maxTextfield.getText());
		
	}

#end
#end
#No. 184771
#File: E:\bishe\1\WidgetTextfieldsOptionalMinMax.java
#Comment:
	 /** 
	 * @return    The minimum value.
	 */

#Code:
	public float getMinimumValue() {
		
		return Float.parseFloat(minTextfield.getText());
		
	}

#end
#end
#No. 184772
#File: E:\bishe\1\WidgetUpdater.java
#Comment:
	/**
	 * update only the app widgets associated with the given id
	 * @param context
	 * @param dbHelper
	 * @param appWidgetId
	 */

#Code:
	public static void updateWidget(Context context, AppHistoryDbHelper dbHelper, int appWidgetId) {
		
		log.d("updating widget for appWidgetId: " + appWidgetId);
		
		AppWidgetManager manager = AppWidgetManager.getInstance(context);
		RemoteViews updateViews = buildUpdate(context, dbHelper, appWidgetId);
		if (updateViews != null) {
			manager.updateAppWidget(appWidgetId, updateViews);
		}
	}

#end
#end
#No. 184773
#File: E:\bishe\1\WidgetUpdater.java
#Comment:
	/**
	 * Update all app tracker app widgets
	 * @param context
	 * @param dbHelper
	 */

#Code:
	public static void updateWidget(Context context, AppHistoryDbHelper dbHelper) {
		
		ComponentName widget = new ComponentName(context, AppTrackerWidgetProvider.class);
		AppWidgetManager manager = AppWidgetManager.getInstance(context);
		int[] appWidgetIds = manager.getAppWidgetIds(widget);
		log.d("updating widget for all app widget ids: %s", appWidgetIds);
		for (int appWidgetId : appWidgetIds) {
			
			// perform this check because there is a bug in Android where, if you
			// exit from the configuration screen, Android will never forget that
			// appWidgetId and it will remain as a "stale" appWidgetId
			boolean exists = PreferenceHelper.checkIfAppExists(context, appWidgetId);
			
			if (!exists) {
				log.d("skipping stale appWidgetId %d", appWidgetId);
				continue;
			}
			
			RemoteViews updateViews = buildUpdate(context, dbHelper, appWidgetId);
			if (updateViews == null) { // nothing to see yet
				continue;
			}
			manager.updateAppWidget(appWidgetId, updateViews);
		}
	}

#end
#end
#No. 184774
#File: E:\bishe\1\WidgetUtil.java
#Comment:
    /**
     * Parse custom view attr valueIndexes (flags).<br>
     * E.g. you want your custom view with attr to work like that: <br>
     * <code>
     * <com.dating.sdk.ui.widget.UserActionsSection
     * android:layout_width="fill_parent"
     * android:layout_height="wrap_content"
     * <b>app:action="chat|mail|wink|icebreaker" /></b></code> <br>
     * E.g. You've got custom stylable with attr which works like
     * list of available flags. <br>
     * <code><declare-styleable title="UserActions">
     * <attr title="action">
     * <flag title="chat" value="1" />
     * <flag title="mail" value="2" />
     * <flag title="wink" value="4" />
     * <flag title="icebreaker" value="8" />
     * </attr>
     * </declare-styleable></code> <br>
     * <b>Caveat: flag valueIndexes should be power of 2 (2,4,8,16 etc)</b>
     * @param a
     *            attrs of view to search for attrName
     * @param attrName
     *            custom attr with flag valueIndexes
     * @param values
     *            enum's valueIndexes. enum should implement {@code AttrValue}
     * @return list of available (declared in xml) view's valueIndexes
     */

#Code:
    public static <U extends AttrValue> Collection<U> readAttrValues(TypedArray a, int attrName, U[] values) {
        Set<U> availableValues = new HashSet<U>();
        int valuesSumIndex = a.getInteger(attrName, 0);
        if (valuesSumIndex != 0) {
            for (U action : values) {
                int actionIndex = action.getAttrIndex();
                if ((valuesSumIndex & actionIndex) == actionIndex)
                    availableValues.add(action);
            }
        }
        return availableValues;
    }

#end
#end
#No. 184775
#File: E:\bishe\1\WidgetUtils.java
#Comment:
	/**
	 *
	 * @param control which index should be found
	 * @return index of control
	 */

#Code:
	public static int getIndex(Control control) {
		// This is the reverse method of
		//    Matcher matcher = allOf(widgetOfType(Button.class), withStyle(SWT.PUSH, "SWT.PUSH"));
		//    return new SWTBotButton((Button) widget(matcher, index), matcher);
		// TODO? Evaluate reusing matchers here too

		int index = 0;
		Composite parent = null;
		do {
			parent = control.getParent();
			for (Control c : parent.getChildren()) {
				if(c.equals(control)){
					return index;
				} else if (c.getClass().equals(control.getClass())){
					index++;
				}
			}
		} while(!(parent instanceof Shell));

		throw new RuntimeException("Could not determine index for widget " + control);
	}

#end
#end
#No. 184776
#File: E:\bishe\1\WidgetUtils.java
#Comment:
	/**
	 *
	 * @param control which group should be found
	 * @return group text or null if group was not found
	 */

#Code:
	public static String getGroup(Control control){
		Composite parent = control.getParent();
		while(parent != null){
			if(parent instanceof Group){
				return ((Group)parent).getText();
			}
			parent = parent.getParent();
		}

		return null;
	}

#end
#end
#No. 184777
#File: E:\bishe\1\WidgetUtils.java
#Comment:
	/**
	 *
	 * @param widget which parent shell should be found
	 * @return shell which contains widget or null
	 */

#Code:
	public static Shell getShell(Control widget) {
		while (widget != null) {
			if (widget instanceof Shell) {
				return ((Shell)widget);
			} else {
				widget = ((Control)widget).getParent();
			}
		}
		return null;
	}

#end
#end
#No. 184778
#File: E:\bishe\1\WidgetUtils.java
#Comment:
	/**
	 *
	 * @param widget widget which label should be found
	 * @return label text or null if no label was found
	 */

#Code:
	public static String getLabel(Control widget) {
		Control[] controls = widget.getParent().getChildren();
		for (int i = 0; i < controls.length; i++) {
			if (controls[i] instanceof Label && controls[i + 1].equals(widget)) {
				return ((Label) controls[i]).getText();
			}
		}
		return null;
	}

#end
#end
#No. 184779
#File: E:\bishe\1\WidgetUtils.java
#Comment:
	/**
	 * Clean text
	 * @param text text to clean
	 * @return cleaned text
	 */

#Code:
	public static String cleanText(String text) {
		if(text	!= null){
			return text.replaceAll("&", "").split("\t")[0];
		}
		return null;
	}

#end
#end
#No. 184780
#File: E:\bishe\1\WidgetValidator.java
#Comment:
    /**
     * Checks if the required fields contain a value
     *
     * @param errors {@link Errors}
     */

#Code:
    private void validateRequiredFields(Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "title", "widget.title.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, FIELD_URL, "widget.url.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "type", "widget.type.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "description", "widget.description.required");

    }

#end
#end
#No. 184781
#File: E:\bishe\1\WidgetValidator.java
#Comment:
    /**
     * Validates fields that may contain a URL
     *
     * @param widget {@link org.apache.rave.model.Widget} to validate
     * @param errors {@link org.springframework.validation.Errors}
     */

#Code:
    private void validateUrlFields(Widget widget, Errors errors) {
        String url = widget.getUrl();
        if (StringUtils.isNotBlank(url) && !urlValidator.isValid(url)) {
            errors.rejectValue(FIELD_URL, "widget.url.malformed");
        }

        String screenshotUrl = widget.getScreenshotUrl();
        if (StringUtils.isNotBlank(screenshotUrl) && !urlValidator.isValid(screenshotUrl)) {
            errors.rejectValue("screenshotUrl", "widget.screenshotUrl.malformed");
        }

        String thumbnailUrl = widget.getThumbnailUrl();
        if (StringUtils.isNotBlank(thumbnailUrl) && !urlValidator.isValid(thumbnailUrl)) {
            errors.rejectValue("thumbnailUrl", "widget.thumbnailUrl.malformed");
        }

        String titleUrl = widget.getTitleUrl();
        if (StringUtils.isNotBlank(titleUrl) && !urlValidator.isValid(titleUrl)) {
            errors.rejectValue("titleUrl", "widget.titleUrl.malformed");
        }
    }



#end
#end
#No. 184784
#File: E:\bishe\1\Wiff.java
#Comment:
  /**
   * Initializes objects according to the application config and starts capture
   * and consumer threads.
   * 
   * @param args
   *          arguments from the command line
   */

#Code:
  public static void main(String[] args) {
    // Configure log4j
    PropertyConfigurator.configure("config/log4j.properties");
    LOGGER = Logger.getLogger(Wiff.class);

    // load cli options in order to get the config file location
    processCLIOptions(args);
    if (cliOptions.containsKey("config-file")) {
      configFile = cliOptions.get("config-file");
    }

    // load properties from file
    properties = WiffProperties.createFromFile(configFile);

    // overwrite properties passed in from the command line
    properties.setProperities(cliOptions);
    LOGGER.debug("Properties:" + properties);

    if (properties.contains("log_level")) {
      log_level = Level.toLevel(properties.getString("log_level"));
    }
    Logger.getRootLogger().setLevel(log_level);

    attachShutDownHook();

    initializeCapture();
  }

#end
#end
#No. 184785
#File: E:\bishe\1\Wiff.java
#Comment:
  /**
   * Populates cliOptions HashMap with the options given to this program from
   * the command line
   * 
   * @param options
   *          the program arguments
   */

#Code:
  private static void processCLIOptions(String[] options) {
    for (String option : options) {
      String[] tuple = option.split("\\s*=\\s*");

      // remove any dash chars from the key
      tuple[0] = tuple[0].replaceAll("^[\\s-]+", "");

      cliOptions.put(tuple[0], tuple[1]);
    }
  }

#end
#end
#No. 184786
#File: E:\bishe\1\Wiff.java
#Comment:
  /**
   * Creates a processor according to the config file
   * 
   * @param processorName
   *          the name of the processor to create
   * @param queue
   *          the queue into which this processor will place its data
   * @return a processor object
   */

#Code:
  private static WiffProcessor createProcessor(String processorName,
      WiffQueue queue) {
    LOGGER.info("Creating instance of processor " + processorName + "...");

    String prefix = "wiff.processor." + processorName + ".";
    String processorType = properties.getString(prefix + "type", "");

    // Common properties
    String host = properties.getString(prefix + "host");
    int port = properties.getInt(prefix + "port");

    WiffProcessor processor = null;
    switch (Processors.valueOf(processorType)) {
      case RabbitMQProcessor:
        String user = properties.getString(prefix + "user", "guest");
        String pass = properties.getString(prefix + "pass", "guest");
        String queueName = properties.getString(prefix + "queue");

        processor = new RabbitMQProcessor(host, port, user, pass, queueName,
            queue);
        break;
      default:
        break;
    }
    return processor;
  }

#end
#end
#No. 184787
#File: E:\bishe\1\Wiff.java
#Comment:
  /**
   * Instantiates a set of services as defined in the configuration
   * 
   * @param serviceNames
   *          the set of names of services to create
   */

#Code:
  private static void createServices(String[] serviceNames) {
    services = new WiffService[serviceNames.length];

    int index = 0;
    for (String serviceName : serviceNames) {
      String serivcePrefix = "wiff.service." + serviceName + ".";

      // Create reporter
      WiffReporter reporter = null;
      if (properties.contains(serivcePrefix + "reporter")) {
        try {
          reporter = createReporter(properties.getString(serivcePrefix
              + "reporter"));
        } catch (IOException e) {
          LOGGER.error("", e);
        }
      }

      // Initialize services
      String serviceType = properties.getString(serivcePrefix + "type");
      switch (Services.valueOf(serviceType)) {
        case WiffStitch:
          int cacheTime = properties.getInt(serivcePrefix + "cachetime", 1);
          services[index] = new WiffStitch(cacheTime, reporter);
          break;
        case ParseBytes:
          services[index] = new ParseBytes(reporter);
          break;
        case WiffRoundtrip:
          services[index] = new WiffRoundtrip(reporter);
        default:
          break;
      }
      index++;

      LOGGER.info("Service " + serviceName + " has been started.");
    }
  }

#end
#end
#No. 184788
#File: E:\bishe\1\Wiff.java
#Comment:
  /**
   * Instantiates a reporter as defined in the configuration
   * 
   * @param reporterName
   *          the name of the reporter to create
   */

#Code:
  private static WiffReporter createReporter(String reporterName)
      throws IOException {
    LOGGER.info("Creating instance of reporter " + reporterName + "...");

    String reporterPrefix = "wiff.reporter." + reporterName + ".";

    // Common properties
    String host = properties.getString(reporterPrefix + "host");
    int port = properties.getInt(reporterPrefix + "port");
    String reporterType = properties.getString(reporterPrefix + "type");
    int reportInterval = properties.getInt(reporterPrefix + "report_interval",
        0);

    // Create parser
    Parser parser = null;
    if (properties.contains(reporterPrefix + "parser")) {
      parser = createParser(properties.getString(reporterPrefix + "parser"));
    }

    WiffReporter reporter = null;
    switch (Reporters.valueOf(reporterType)) {
      case RabbitMQClient:
        String queueName = properties.getString(reporterPrefix + "queue");
        String exchangeName = properties.getString(reporterPrefix + "exchange");
        String user = properties.getString(reporterPrefix + "user", "guest");
        String pass = properties.getString(reporterPrefix + "pass", "guest");

        reporter = new RabbitMQClient(host, port, user, pass, exchangeName,
            queueName, reportInterval, null, parser);
        break;
      case ElasticsearchClient:
        reporter = new ElasticsearchClient(host, port, reportInterval, parser);
        break;
      default:
        break;
    }
    return reporter;
  }

#end
#end
#No. 184789
#File: E:\bishe\1\Wiff.java
#Comment:
  /**
   * Instantiates a parser as defined in the configuration
   * 
   * @param parserName
   *          the name of the parser to create
   */

#Code:
  private static Parser createParser(String parserName) {
    LOGGER.info("Creating instance of parser " + parserName + "...");

    String parserPrefix = "wiff.parser." + parserName + ".";
    String parserType = properties.getString(parserPrefix + "type", "");

    String indexName = properties
        .getString(parserPrefix + "index_name", "wiff");
    Parser parser = null;
    switch (Parsers.valueOf(parserType)) {
      case HTTPParser:
        boolean includeBody = properties.getBoolean(parserPrefix
            + "include_body", true);

        String dataSource = properties.getString(parserPrefix + "data_source");
        String inputSource = properties
            .getString(parserPrefix + "input_source");

        parser = new HTTPParser(indexName, includeBody, dataSource, inputSource);
        break;
      case PrependSize:
        parser = new PrependSize();
        break;
      case ESBulkIndex:
        parser = new ESBulkIndex(indexName);
        break;
      default:
        break;
    }
    return parser;
  }

#end
#end
#No. 184790
#File: E:\bishe\1\Wiff.java
#Comment:
  /**
   * Returns an array of the services that Wiff is running
   * 
   * @return an iterator over services
   */

#Code:
  public static WiffService<?, ?>[] getServices() {
    return services;
  }

#end
#end
#No. 184791
#File: E:\bishe\1\WiffCapture.java
#Comment:
  /**
   * Creates a capture object that pulls packets from the first capture device
   * it locates and pushes them onto the queue
   * 
   * @param queue
   *          the queue onto which this object places captured packets
   */

#Code:
  public WiffCapture(final WiffQueue<WiffByteBuffer> queue, ByteBufferPool pool) {
    this("0", queue, pool, "");
  }


#end
#end
#No. 184793
#File: E:\bishe\1\WiffCapture.java
#Comment:
  /**
   * Stop capturing packets
   */

#Code:
  public void stop() {
    running = false;
    if (offline || streamMode) {
      pcap.breakloop();
    }
  }

#end
#end
#No. 184794
#File: E:\bishe\1\WiffCapture.java
#Comment:
  /**
   * Loads all available capture devices
   */

#Code:
  private void getCaptureDevices() {
    int r = Pcap.findAllDevs(captureDevices, errbuf);
    if (r == Pcap.ERROR || captureDevices.isEmpty()) {
      LOGGER.error("Can't read list of devices, error is %s" + errbuf);
      System.exit(1);
    }
  }

#end
#end
#No. 184795
#File: E:\bishe\1\WiffCapture.java
#Comment:
  /**
   * Display available capture devices to the user
   */

#Code:
  private void displayCaptureDevices() {
    LOGGER.info("Network devices found:");

    int i = 0;
    String description;
    for (PcapIf device : captureDevices) {
      description = (i++) + ": " + device.getName() + " ";
      description += (device.getDescription() != null) ? device
          .getDescription() : "No description available";
      LOGGER.info(description);
    }
  }


#end
#end
#No. 184797
#File: E:\bishe\1\WiffCapture.java
#Comment:
  /**
   * @return the number of dropped packets
   */

#Code:
  public long getDroppedPackets() {
    PcapStat stats = new PcapStat();
    pcap.stats(stats);
    return stats.getDrop();
  }

#end
#end
#No. 184798
#File: E:\bishe\1\WiffConnection.java
#Comment:
  /**
   * @param sourceIp
   *          a connection's source IP address
   * @param sourcePort
   *          a connection's source port
   * @param destinationIp
   *          a connection's destination IP address
   * @param destinationPort
   *          a connection's destination port
   */

#Code:
  public WiffConnection(String sourceIp, int sourcePort, String destinationIp,
      int destinationPort) {
    this.sourceIp = sourceIp;
    this.sourcePort = sourcePort;
    this.destinationIp = destinationIp;
    this.destinationPort = destinationPort;
  }

#end
#end
#No. 184799
#File: E:\bishe\1\WiffConnection.java
#Comment:
  /**
   * @param packet
   *          a packet object describing this TCP packet
   * @throws Exception
   */

#Code:
  public WiffConnection(WiffPacket packet) throws Exception {
    sourceIp = packet.getSourceIP();
    sourcePort = packet.getSourcePort();
    destinationIp = packet.getDestinationIP();
    destinationPort = packet.getDestinationPort();
  }

#end
#end
#No. 184800
#File: E:\bishe\1\WiffConnection.java
#Comment:
  /**
   * @return the connection's source IP address
   */

#Code:
  public String getSourceIp() {
    return sourceIp;
  }

#end
#end
#No. 184801
#File: E:\bishe\1\WiffConnection.java
#Comment:
  /**
   * @return the connection's source port
   */

#Code:
  public int getSourcePort() {
    return sourcePort;
  }

#end
#end
#No. 184802
#File: E:\bishe\1\WiffConnection.java
#Comment:
  /**
   * @return the connection's destination IP address
   */

#Code:
  public String getDestinationIp() {
    return destinationIp;
  }

#end
#end
#No. 184803
#File: E:\bishe\1\WiffConnection.java
#Comment:
  /**
   * @return the connection's destination port
   */

#Code:
  public int getDestinationPort() {
    return destinationPort;
  }

#end
#end
#No. 184804
#File: E:\bishe\1\WiffConsumer.java
#Comment:
  /**
   * Indicates if the run method is executing
   * 
   * @return whether or not the run method is executing
   */

#Code:
  public boolean isRunning() {
    return running;
  }

#end
#end
#No. 184805
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the number of bytes the packet contains
   */

#Code:
  public int getPacketByteLength() {
    return size;
  }

#end
#end
#No. 184806
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the source IP address
   */

#Code:
  public String getSourceIP() {
    return FormatUtils.ip(source());
  }

#end
#end
#No. 184807
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the destination IP address
   */

#Code:
  public String getDestinationIP() {
    return FormatUtils.ip(destination());
  }

#end
#end
#No. 184808
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the source ip
   */

#Code:
  public int getSourceIPAsInt() {
    return getUInt(source());
  }

#end
#end
#No. 184809
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the destination ip
   */

#Code:
  public int getDestinationIPAsInt() {
    return getUInt(destination());
  }

#end
#end
#No. 184810
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return true if a TCP header is present
   */

#Code:
  public boolean hasTcpHeader() {
    int offset = getEthHeaderLength() + 9;

    byte[] bytes = new byte[1];
    buffer.clear().position(offset).limit(offset + 1);
    buffer.get(bytes);

    return (bytes[0] & 0xFF) == 0x06;
  }

#end
#end
#No. 184811
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the number of bytes in the TCP header
   */

#Code:
  public int getTcpHeaderLength() {
    int length = 0;
    if (hasTcpHeader()) {
      int offset = getEthHeaderLength() + getIpHeaderLength() + 12;

      byte[] bytes = new byte[1];
      buffer.clear().position(offset).limit(offset + 1);
      buffer.get(bytes);

      length = (((bytes[0] & 0xff) >> 4) & 0x0000000f) * 4;
    }
    return length;
  }

#end
#end
#No. 184812
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the source port
   */

#Code:
  public int getSourcePort() {
    int offset = getEthHeaderLength() + getIpHeaderLength();

    byte[] bytes = new byte[2];
    buffer.clear().position(offset).limit(offset + 2);
    buffer.get(bytes);

    return getUShortAsUInt(bytes);
  }

#end
#end
#No. 184813
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the destination port
   */

#Code:
  public int getDestinationPort() {
    int offset = getEthHeaderLength() + getIpHeaderLength() + 2;

    byte[] bytes = new byte[2];
    buffer.clear().position(offset).limit(offset + 2);
    buffer.get(bytes);

    return getUShortAsUInt(bytes);
  }

#end
#end
#No. 184814
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the packet's sequence number
   */

#Code:
  public long getSequenceNumber() {
    int offset = getEthHeaderLength() + getIpHeaderLength() + 4;

    byte[] bytes = new byte[4];
    buffer.clear().position(offset).limit(offset + 4);
    buffer.get(bytes);

    return getULong(bytes);
  }

#end
#end
#No. 184815
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the number of bytes in the packet's payload
   */

#Code:
  public int getTcpPayloadLength() {
    // payload = total size - tcp header - ip header
    return getPacketByteLength() - getTcpHeaderLength() - getIpHeaderLength()
        - getEthHeaderLength();
  }

#end
#end
#No. 184816
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return the packet's payload
   */

#Code:
  public byte[] getTcpPayload() {
    byte[] payload = null;
    if (hasTcpHeader()) {
      int firstByte = getTcpPayloadOffset();
      int length = getTcpPayloadLength();

      payload = new byte[length];
      buffer.clear().position(firstByte).limit(firstByte + length);
      buffer.get(payload);
    }
    return payload;
  }

#end
#end
#No. 184817
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return true if the packet's SYN flag is raised
   */

#Code:
  public boolean isSyn() {
    int offset = getEthHeaderLength() + getIpHeaderLength() + 13;

    byte[] bytes = new byte[1];
    buffer.clear().position(offset).limit(offset + 1);
    buffer.get(bytes);

    return (bytes[0] & 0x02) == 0x02;
  }

#end
#end
#No. 184818
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return true if the packet's FIN flag is raised
   */

#Code:
  public boolean isFin() {
    int offset = getEthHeaderLength() + getIpHeaderLength() + 13;

    byte[] bytes = new byte[1];
    buffer.clear().position(offset).limit(offset + 1);
    buffer.get(bytes);

    return (bytes[0] & 0x01) == 0x01;
  }

#end
#end
#No. 184819
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return true if the packet's ACK flag is raised
   */

#Code:
  public boolean isAck() {
    int offset = getEthHeaderLength() + getIpHeaderLength() + 13;

    byte[] bytes = new byte[1];
    buffer.clear().position(offset).limit(offset + 1);
    buffer.get(bytes);

    return (bytes[0] & 0x10) == 0x10;
  }

#end
#end
#No. 184820
#File: E:\bishe\1\WiffPacket.java
#Comment:
  /**
   * @return true if the packet's PSH flag is raised
   */

#Code:
  public boolean isPSH() {
    int offset = getEthHeaderLength() + getIpHeaderLength() + 13;

    byte[] bytes = new byte[1];
    buffer.clear().position(offset).limit(offset + 1);
    buffer.get(bytes);

    return (bytes[0] & 0x08) == 0x08;
  }

#end
#end
#No. 184821
#File: E:\bishe\1\WiffProcessor.java
#Comment:
  /**
   * Creates a processor that inserts its data into the given queue
   * 
   * @param queue
   */

#Code:
  public WiffProcessor(WiffQueue<byte[]> queue) {
    this.queue = queue;
  }

#end
#end
#No. 184822
#File: E:\bishe\1\WiffProcessor.java
#Comment:
  /**
   * Safely stops this processor's execution
   * 
   */

#Code:
  public abstract void stop();
}
}

#end
#end
#No. 184823
#File: E:\bishe\1\WiffProperties.java
#Comment:
  /**
   * Creates a WiffProperties object using key and value pairs from an input
   * stream
   * 
   * @param reader
   *          the input stream
   * @return a WiffProperties object containing the data from the input stream
   */

#Code:
  public static WiffProperties createFromStream(BufferedReader reader) {
    WiffProperties props = new WiffProperties();
    try {
      props.properties.load(reader);
    } catch (IOException e) {
      e.printStackTrace();
    }
    return props;
  }

#end
#end
#No. 184824
#File: E:\bishe\1\WiffProperties.java
#Comment:
  /**
   * Creates a WiffProperties object using key and value pairs from an file
   * 
   * @param filePath
   *          a path to a file of key=value assignments
   * @return a WiffProperties object containing the data from the file
   */

#Code:
  public static WiffProperties createFromFile(String filePath) {
    try {
      File config = new File(filePath);
      BufferedReader reader = new BufferedReader(new FileReader(
          config.getAbsoluteFile()));

      return WiffProperties.createFromStream(reader);
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    }
    return null;
  }

#end
#end
#No. 184825
#File: E:\bishe\1\WiffProperties.java
#Comment:
  /**
   * Sets the given key equal to the given value
   * 
   * @param key
   * @param value
   */

#Code:
  public void setProperty(String key, String value) {
    properties.setProperty(key.trim(), value.trim());
  }

#end
#end
#No. 184826
#File: E:\bishe\1\WiffProperties.java
#Comment:
  /**
   * Retrieves the value of the given key as a string
   * 
   * @param key
   *          the property to retrieve
   * @return a string containing the key's value
   */

#Code:
  public String getString(String key) {
    String result = properties.getProperty(key.trim());
    if (result != null) {
      result = result.trim();
    }
    return result;
  }

#end
#end
#No. 184827
#File: E:\bishe\1\WiffProperties.java
#Comment:
  /**
   * Retrieves the value of the given key as an int
   * 
   * @param key
   *          the property to retrieve
   * @return the key's value as an int
   */

#Code:
  public int getInt(String key) {
    return getInt(key, 0);
  }

#end
#end
#No. 184828
#File: E:\bishe\1\WiffProperties.java
#Comment:
  /**
   * Retrieves the value of the given key as a float
   * 
   * @param key
   *          the property to retrieve
   * @return the key's value as a float
   */

#Code:
  public float getFloat(String key) {
    return Float.parseFloat(getString(key));
  }

#end
#end
#No. 184829
#File: E:\bishe\1\WiffProperties.java
#Comment:
  /**
   * Retrieves the value of the given key as a boolean
   * 
   * @param key
   *          the property to retrieve
   * @return the key's value as a boolean
   */

#Code:
  public boolean getBoolean(String key) {
    return Boolean.parseBoolean(getString(key));
  }

#end
#end
#No. 184830
#File: E:\bishe\1\WiffProperties.java
#Comment:
  /**
   * Bulk loads the properties object from a map of key, value pairs
   * 
   * @param map
   *          a map of keys and values
   */

#Code:
  public void setProperities(Map<String, String> map) {
    for (String key : map.keySet()) {
      setProperty(key, map.get(key));
    }
  }

#end
#end
#No. 184831
#File: E:\bishe\1\WiffProperties.java
#Comment:
  /**
   * Determines if the given property has a value
   * 
   * @param key
   *          the name of the property
   * @return true if the property has been set. Otherwise, false.
   */

#Code:
  public boolean contains(String key) {
    return properties.containsKey(key);
  }

#end
#end
#No. 184832
#File: E:\bishe\1\WiffReporter.java
#Comment:
  /**
   * Creates an instance of a reporter
   * 
   * @param killSignal
   *          the object that, if sent to this report, will cause it to shutdown
   */

#Code:
  public WiffReporter(T killSignal) {
    this.killSignal = killSignal;
    messages = new LinkedBlockingQueue<T>();
  }

#end
#end
#No. 184833
#File: E:\bishe\1\WiffReporter.java
#Comment:
  /**
   * Creates an instance of a reporter
   * 
   * @param killSignal
   *          the object that, if sent to this report, will cause it to shutdown
   * @param parser
   *          a Parser object that, if present, will be used by this reporter to
   *          transform the data it receives
   */

#Code:
  public WiffReporter(T killSignal, Parser<T, ?> parser) {
    this(killSignal);
    this.parser = parser;
  }

#end
#end
#No. 184834
#File: E:\bishe\1\WiffReporter.java
#Comment:
  /**
   * @param value
   * @throws InterruptedException
   */

#Code:
  public void sendData(T value) throws InterruptedException {
    messages.put(value);
  }

#end
#end
#No. 184835
#File: E:\bishe\1\WiffReporter.java
#Comment:
  /**
   * @return
   * @throws InterruptedException
   */

#Code:
  protected T receiveData() throws InterruptedException {
    return messages.take();
  }

#end
#end
#No. 184836
#File: E:\bishe\1\WiffReporter.java
#Comment:
  /**
   * @return
   */

#Code:
  public T getKillPill() {
    return killSignal;
  }

#end
#end
#No. 184837
#File: E:\bishe\1\WiffReporter.java
#Comment:
  /**
   * Releases resources used by this reporter
   */

#Code:
  public void cleanup() {
    messages.clear();
  }

#end
#end
#No. 184838
#File: E:\bishe\1\WiffReporter.java
#Comment:
  /**
   * Stops the execution of the run method and releases resources.
   */

#Code:
  public void stop() {
    running = false;
  }

#end
#end
#No. 184839
#File: E:\bishe\1\WiffReporter.java
#Comment:
  /**
   * Determines if this reporter is still active.
   * 
   * @return true, if this reporter is still active.
   */

#Code:
  public boolean isRunning() {
    return running;
  }

#end
#end
#No. 184840
#File: E:\bishe\1\WiffService.java
#Comment:
  /**
   * @param reporter
   *          a reporter to which this service will send data
   */

#Code:
  public WiffService(WiffReporter<S> reporter) {
    this.reporter = reporter;
  }

#end
#end
#No. 184841
#File: E:\bishe\1\WiffService.java
#Comment:
  /**
   * Starts the reporter on its own thread
   */

#Code:
  public void startReporter() {
    if (reporter != null) {
      reporterThread = new Thread(reporter);
      reporterThread.start();
    }
  }

#end
#end
#No. 184842
#File: E:\bishe\1\WiffService.java
#Comment:
  /**
   * Safely stops this service
   */

#Code:
  public void stop() {
    stopReporter();
  }

#end
#end
#No. 184843
#File: E:\bishe\1\WiffService.java
#Comment:
  /**
   * Stops the reporter thread
   */

#Code:
  public void stopReporter() {
    if (reporter != null) {
      LOGGER.info("Calling shut down on reporter " + reporter.getClass());
      try {
        reporter.stop();

        /*
         * Send kill message to reporter. This is for the case in which the
         * reporter's message queue is empty and it is waiting and therefore
         * does not stop execution.
         */
        reporter.sendData(reporter.getKillPill());

        // Wait for reporter to die
        reporterThread.join();
      } catch (InterruptedException e) {
        LOGGER.error("", e);
      }
    }
  }

#end
#end
#No. 184844
#File: E:\bishe\1\wifiAddresses.java
#Comment:
	/**
  	 * Method to Get Gateway Ip Address
  	 * 
  	 * @return Gateway Ip Address as String 
  	 */

#Code:
    public String getGatewayIPAddress(){
	 if(mWifiManager!=null){
		 final DhcpInfo dhcp = mWifiManager.getDhcpInfo();
		 return ipIntToString(dhcp.gateway);
	    }
	   return null;
    }

#end
#end
#No. 184845
#File: E:\bishe\1\wifiAddresses.java
#Comment:
    /**
     *  Method to Get Device Ip Address 
     * 
     * @return  Device Ip Address as String
     */

#Code:
    public String getDeviceIPAddress(){
	 if(mWifiInfo!=null){
		 int ip = mWifiInfo.getIpAddress();
		 return ipIntToString(ip);
	 }
     	return null;
    } 

#end
#end
#No. 184846
#File: E:\bishe\1\wifiAddresses.java
#Comment:
    /**
     * Method for Conversion Ip Address From Int to String
     * 
     * @param ipInt Ip as Int
     * @return Ip as String
     */

#Code:
    public static String ipIntToString(int ipInt) {
        String ip = "";
        for (int i = 0; i < 4; i++) {
            ip = ip + ((ipInt >> i * 8) & 0xFF) + ".";
        }
        return ip.substring(0, ip.length() - 1);
    }

#end
#end
#No. 184847
#File: E:\bishe\1\wifiAddresses.java
#Comment:
    /**
  	 * Method to Get Device MAC Address
  	 * 
   	 * @return MAC Address as String
  	 */

#Code:
    public String getDeviceMacAddress(){
	 if(mWifiInfo!=null){
		 return  mWifiInfo.getMacAddress();
	 }
	return null;
}

#end
#end
#No. 184848
#File: E:\bishe\1\wifiAddresses.java
#Comment:
    /**
  	 * Method to Get MAC Address of GatWay(BSSID)
  	 * 
  	 * @return String contain MAC Address of GatWay
  	 */

#Code:
    public String getGatWayMacAddress(){
		 if(mWifiManager!=null){
			 return mWifiInfo.getBSSID();
		 }
		return null;
	}

#end
#end
#No. 184849
#File: E:\bishe\1\wifiAddresses.java
#Comment:
    /**
 	 * Method to Ping  IP Address
 	 * 
 	 * @param addr IP address you want to ping it 
 	 * @return true if the IP address is reachable
 	 */

#Code:
 	public boolean pingCmd(String addr){
 		try {
			String ping = "ping  -c 1 -W 1 " + addr;
    		Runtime run = Runtime.getRuntime();
			Process pro = run.exec(ping);
			 try {
				pro.waitFor();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
	     	int exit = pro.exitValue();
	        if (exit == 0) { 
	        	 return true;
	         } else {
	        	 //ip address is not reachable
	           return false;
	         }
		}
			catch (IOException e) {
			}
		return false;
	}  	

#end
#end
#No. 184850
#File: E:\bishe\1\wifiAddresses.java
#Comment:
 	/**
 	 * Method to Get Result of pinging  IP Address
 	 * 
 	 * @param addr  IP address you want to ping it 
 	 * @return Result of Pinging as String
 	 */

#Code:
    public String getPingResulta(String addr){
		try {
			String ping = "ping -c 1 -W 1 " + addr;
			String pingResult = "";
			Runtime run = Runtime.getRuntime();
			Process pro = run.exec(ping);
			
			BufferedReader buf = new BufferedReader(new	InputStreamReader(pro.getInputStream()));
			
			String inputLine;
			while ((inputLine = buf.readLine()) != null) {
						pingResult += inputLine;
			}
			      buf.close();
			return pingResult;
		}
			catch (IOException e) {
			}
		
	return "";
	}

#end
#end
#No. 184851
#File: E:\bishe\1\wifiAddresses.java
#Comment:
   /**
     * Method to Get MAC Address From  ARP File
     * 
     * @param ip  address you want to Get it MAC Address
     * @return MAC Address as String
     */

#Code:
    public String getArpMacAddress(String addr){
			String macAddr = "00:00:00:00:00:00";
	        try {
	            if (addr != null) {
	                String ptrn = String.format(REG_E, addr.replace(".", "\\."));
	                Pattern pat = Pattern.compile(ptrn);
	                            
	                BufferedReader buf = new BufferedReader(new FileReader("/proc/net/arp"), BUFFER);
	                String line;
	                Matcher mat;
	                while ((line = buf.readLine()) != null) {
	                    mat = pat.matcher(line);
	                    if (mat.matches()) {
	                    	macAddr = mat.group(1);
	                        break;
	                    }
	                }
	                buf.close();
	            } else {
	            }
	        } catch (IOException e) {
	             return macAddr;
	        }
	        return macAddr;
	           
		}

#end
#end
#No. 184852
#File: E:\bishe\1\wifiAddresses.java
#Comment:
    /**
  	 * Method to Clear ARP table not tested
  	 * 
  	 * @return true if ARP table cleared or false if not
  	 */

#Code:
    public boolean clearArpTable(){
    	 return runAsRoot("ip -s -s neigh flush all");
	   
    }

#end
#end
#No. 184853
#File: E:\bishe\1\wifiAddresses.java
#Comment:
   	/**
	 * Run command as root.
	 * 
	 * @param command
	 * @return true, if command was successfully executed
	 */

#Code:
	private static boolean runAsRoot(final String command) {
		try {
								
			Process pro = Runtime.getRuntime().exec("su");
			DataOutputStream outStr = new DataOutputStream(pro.getOutputStream());
			
			 outStr.writeBytes(command);
			 outStr.writeBytes("\nexit\n");
			 outStr.flush();
			 
			int retval = pro.waitFor();
			
			return (retval == 0);
			
		    } catch (Exception e) {
		    	
			return false;
			
		    }
	}

#end
#end
#No. 184854
#File: E:\bishe\1\wifiAddresses.java
#Comment:
    /**
  	 * Method to Check if  IP Live Using ARP
  	 * 
  	 * @addr ip address you want to check it
  	 * @return true if the ip address is reachable
  	 */

#Code:
   public boolean arpIsALive(String addr){
		 
	       if(!"00:00:00:00:00:00".equals( getArpMacAddress(addr))){
	         return true;
	        }else{return false;}
			
		}

#end
#end
#No. 184855
#File: E:\bishe\1\wifiAddresses.java
#Comment:
    /**
  	 * Method to Check if IP Live Using DNS
  	 * 
  	 * @addr ip address you want to check it
  	 * @return true if the ip address is reachable
  	 */

#Code:
   
   public void dnsLive(final String addr,final Runnable task){
	   mTask.runAsynTask(new Runnable() {
    	    public void run() {
    	    	isDnsLive=dnsIsALive(addr);
    	    	task.run();
    	    	
    	    }	
     	    	
     	} );
   }

#end
#end
#No. 184856
#File: E:\bishe\1\wifiAddresses.java
#Comment:
    /**
     * Method to Check if IP Live Using Socket And PORT
     * 
     * @addr ip address you want to check it
  	 * @return true if the ip address is reachable
     */

#Code:
   public void portLive(final String addr,final Runnable task){
	   mTask.runAsynTask(new Runnable() {
    	    public void run() {
    	    	isDnsLive=portIsALive(addr);
    	    	task.run();
    	    	
    	    }	
     	    	
     	} );
   }

#end
#end
#No. 184857
#File: E:\bishe\1\wifiAddresses.java
#Comment:
   /**
     * Gets a list of all clients Ip Addresses connected to the Hotspot from ARP file
     * @param onlyReachables  false if the list should contain unreachable clients or true otherwise
     * @return ArrayList of all clients Ip Addresses 
     */

#Code:
    public ArrayList<String> getArpLiveIps(boolean onlyReachables) {
                BufferedReader bufRead = null;
                ArrayList<String> result = null;
               
                try {
                        result = new ArrayList<String>();
                        bufRead = new BufferedReader(new FileReader("/proc/net/arp"));
                        String fileLine;
                        while ((fileLine = bufRead.readLine()) != null) {
                        	
                        	 
                                String[] splitted = fileLine.split(" +");
                                
                                  if ((splitted != null) && (splitted.length >= 4)) {
                                	  
                                        String mac = splitted[3];
                                         if (mac.matches("..:..:..:..:..:..")) {
                                              boolean isReachable = pingCmd(splitted[0]);
                                             if (!onlyReachables || isReachable) {
                                                        result.add(splitted[0]);
                                                }
                                        }
                                }
                        }
                } catch (Exception e) {
                       
                } finally {
                        try {
                        	bufRead.close();
                        } catch (IOException e) {
                               
                        }
                }

                return result;
        }

#end
#end
#No. 184858
#File: E:\bishe\1\wifiAddresses.java
#Comment:
     /**
      * Method to Change  static IP address, netmask, gateway 
      * <uses-permission android:name="android.permission.WRITE_SETTINGS"></uses-permission>
      */

#Code:
    public void setStaticIpInfo(String ip,String netMask,String gateWay,String dns1,String dns2){
        	final ContentResolver cr = mContext.getContentResolver();
        	Settings.System.putInt(cr, Settings.System.WIFI_USE_STATIC_IP, 1);
        	Settings.System.putString(cr, Settings.System.WIFI_STATIC_IP, ip);
        	Settings.System.putString(cr, Settings.System.WIFI_STATIC_GATEWAY, gateWay);
        	Settings.System.putString(cr, Settings.System.WIFI_STATIC_NETMASK, netMask);
        	Settings.System.putString(cr, Settings.System.WIFI_STATIC_DNS1, dns1);
        	Settings.System.putString(cr, Settings.System.WIFI_STATIC_DNS2, dns2);
        }

#end
#end
#No. 184859
#File: E:\bishe\1\wifiAddresses.java
#Comment:
        /**
         * Method to Manually Change  static IP address, netmask, gateway 
         * 
         */

#Code:
    public void startStaticIpIntent(){
        	   mContext.startActivity(new Intent(WifiManager.ACTION_PICK_WIFI_NETWORK));
          }


#end
#end
#No. 184865
#File: E:\bishe\1\WifiConfigManager.java
#Comment:
  /**
   * Update the network: either create a new network or modify an existing network
   * @param config the new network configuration
   */

#Code:
  private static void updateNetwork(WifiManager wifiManager, WifiConfiguration config) {
    Integer foundNetworkID = findNetworkInExistingConfig(wifiManager, config.SSID);
    if (foundNetworkID != null) {
      Log.i(TAG, "Removing old configuration for network " + config.SSID);
      wifiManager.removeNetwork(foundNetworkID);
      wifiManager.saveConfiguration();
    }
    int networkId = wifiManager.addNetwork(config);
    if (networkId >= 0) {
      // Try to disable the current network and start a new one.
      if (wifiManager.enableNetwork(networkId, true)) {
        Log.i(TAG, "Associating to network " + config.SSID);
        wifiManager.saveConfiguration();
      } else {
        Log.w(TAG, "Failed to enable network " + config.SSID);
      }
    } else {
      Log.w(TAG, "Unable to add network " + config.SSID);
    }
  }

#end
#end
#No. 184866
#File: E:\bishe\1\WifiConfigManager.java
#Comment:
  /**
   * Encloses the incoming string inside double quotes, if it isn't already quoted.
   * @param s the input string
   * @return a quoted string, of the form "input".  If the input string is null, it returns null
   * as well.
   */

#Code:
  private static String convertToQuotedString(String s) {
    if (s == null || s.isEmpty()) {
      return null;
    }
    // If already quoted, return as-is
    if (s.charAt(0) == '"' && s.charAt(s.length() - 1) == '"') {
      return s;
    }
    return '\"' + s + '\"';
  }

#end
#end
#No. 184867
#File: E:\bishe\1\WifiConfigManager.java
#Comment:
  /**
   * @param value input to check
   * @param allowedLengths allowed lengths, if any
   * @return true if value is a non-null, non-empty string of hex digits, and if allowed lengths are given, has
   *  an allowed length
   */

#Code:
  private static boolean isHexOfLength(CharSequence value, int... allowedLengths) {
    if (value == null || !HEX_DIGITS.matcher(value).matches()) {
      return false;
    }
    if (allowedLengths.length == 0) {
      return true;
    }
    for (int length : allowedLengths) {
      if (value.length() == length) {
        return true;
      }
    }
    return false;
  }


#end
#end
#No. 184871
#File: E:\bishe\1\WifiControl.java
#Comment:
	/**
	 * Returns whether wifi is on or not
	 * @param ctx a Context
	 * @return true if wifi is on
	 */

#Code:
	public static final boolean isWifiOn(Context ctx)
	{
		WifiManager wifiManager = (WifiManager) ctx.getSystemService(Context.WIFI_SERVICE);
		
		return wifiManager.isWifiEnabled();
	}

#end
#end
#No. 184872
#File: E:\bishe\1\WifiControl.java
#Comment:
	/**
	 * Turns Wifi on or off
	 * @param ctx a Context
	 * @param state on=true or off=false
	 */

#Code:
	public static final void setWifi(Context ctx, boolean state)
	{
		WifiManager wifiManager = (WifiManager) ctx.getSystemService(Context.WIFI_SERVICE);
		
		if ( (state && !isWifiOn(ctx)) || (!state && isWifiOn(ctx)) )
		{
			if (state)
			{
				Log.d(TAG, "Turning Wifi on");
			}
			else
			{
				Log.d(TAG, "Turning Wifi off");
			}
			
			wifiManager.setWifiEnabled(state);
			
		}
	}

#end
#end
#No. 184873
#File: E:\bishe\1\WifiControl.java
#Comment:
	/**
	 * Returns true if a Wifi connection is established 
	 * @param ctx a Context
	 * @return true if a Wifi connection is established
	 */

#Code:
	public static final boolean isWifiConnected(Context ctx)
	{
		ConnectivityManager connMgr = (ConnectivityManager) ctx.getSystemService(Context.CONNECTIVITY_SERVICE);
		NetworkInfo networkInfo = connMgr.getActiveNetworkInfo();
		
		if (networkInfo != null && networkInfo.isConnected())
		{
			Log.d(TAG, "A connection was detected, testing if an IP was assigned");
			WifiManager wifi;
			wifi = (WifiManager) ctx.getSystemService(Context.WIFI_SERVICE);
			WifiInfo wifiInfo = wifi.getConnectionInfo();
			int ipAddress = wifiInfo.getIpAddress();
			
			if (ipAddress == 0)
			{
				Log.d(TAG, "No IP address assigned: " + ipAddress + ". Wifi is not connected");
				Log.d(TAG, "Wifilock status: " + WifiManagerProxy.hasWifiLock(ctx));
				Log.d(TAG, "SSID:" + wifiInfo.getSSID());
				Log.d(TAG, "Supplicant state:" + wifiInfo.getSupplicantState());
				
				return false;
			}
			else
			{
				Log.d(TAG, "IP address assigned: " + ipAddress + ". Wifi is connected");
				Log.d(TAG, "Wifilock status: " + WifiManagerProxy.hasWifiLock(ctx));
				Log.d(TAG, "SSID:" + wifiInfo.getSSID());
				Log.d(TAG, "Supplicant state:" + wifiInfo.getSupplicantState());
				return true;
			}
		}
		else
		{
			Log.d(TAG, "No active connection detected");
			return false;
		}
	}

#end
#end
#No. 184875
#File: E:\bishe\1\WifiControl.java
#Comment:
	/**
	 * Returns true if a Wifi connection is established but google DNS could not be reached 
	 * @param ctx a Context
	 * @return true if a Wifi connection is established but caged
	 */

#Code:
	public static boolean isWifiCaged()
	{
		Log.i(TAG, "Check for cage returned " + m_WifiCaged + ". Thread status was " +m_WifiCageTransactional);
		return m_WifiCaged;
	}

#end
#end
#No. 184876
#File: E:\bishe\1\WifiControl.java
#Comment:
	/**
	 * Return true if the connected access point is in the given whitelist
	 * @param ctx a Context
	 * @param whiteList the white list as separated string
	 * @return true if the currently connected AP is whitelisted
	 */

#Code:
	public static final boolean isWhitelistedWifiConnected(Context ctx, String whiteList)
	{
		WifiManager wifiManager = (WifiManager) ctx.getSystemService(Context.WIFI_SERVICE);
		String ssid = StringUtils.stripLeadingAndTrailingQuotes(wifiManager.getConnectionInfo().getSSID());
		Log.i(TAG, "Whitelist check: ssid: '" + ssid + "', whitelist: '" + whiteList + "', result: " + (whiteList.indexOf(ssid) != -1));
		List<String> whitelistedList = Arrays.asList(whiteList.split(","));
		return ( (whitelistedList.contains(ssid)) && (!ssid.equals("")) );
//		return ((whiteList.indexOf(ssid) != -1) && (!ssid.equals("")));
	}

#end
#end
#No. 184877
#File: E:\bishe\1\WifiControl.java
#Comment:
	/**
	 * Return the ssid currently connected to
	 * @param ctx a Context
	 * @return the ssid of the connected AP
	 */

#Code:
	public static final String connectedSsid(Context ctx)
	{
		WifiManager wifiManager = (WifiManager) ctx.getSystemService(Context.WIFI_SERVICE);
		String ssid = StringUtils.stripLeadingAndTrailingQuotes(wifiManager.getConnectionInfo().getSSID());
		return ssid;
	}

#end
#end
#No. 184878
#File: E:\bishe\1\WifiControl.java
#Comment:
	/** 
	 * Returns the list of access points that were added to the Wifi configuration
	 * @param ctx a Context
	 * @return the list as List<String>
	 */

#Code:
	public static final List<String> getConfiguredAccessPoints(Context ctx)
	{
		WifiManager wifiManager = (WifiManager) ctx.getSystemService(Context.WIFI_SERVICE);

		ArrayList<String> myList = new ArrayList<String>();
		
		List<WifiConfiguration> myConfiguredAccessPoints = wifiManager.getConfiguredNetworks();
		if (myConfiguredAccessPoints != null)
		{
			for (int i = 0; i < myConfiguredAccessPoints.size(); i++)
			{
				myList.add(myConfiguredAccessPoints.get(i).SSID);
			}
		}
		return myList;
	}

#end
#end
#No. 184879
#File: E:\bishe\1\WifiControl.java
#Comment:
	/**
	 * Returns the list of access points in range, disregarded if they can be connected or not
	 * @param ctx a Context
	 * @return the list as List<String>
	 */

#Code:
	public static final List<String> getAvailableAccessPoints(Context ctx)
	{
		WifiManager wifiManager = (WifiManager) ctx.getSystemService(Context.WIFI_SERVICE);

		ArrayList<String> myList = new ArrayList<String>();
		
		List<ScanResult> myConfiguredAccessPoints = wifiManager.getScanResults();
		if (myConfiguredAccessPoints != null)
		{
			for (int i = 0; i < myConfiguredAccessPoints.size(); i++)
			{
				myList.add(myConfiguredAccessPoints.get(i).SSID);
			}
		}
		return myList;
	}

#end
#end
#No. 184880
#File: E:\bishe\1\WifiControl.java
#Comment:
	/**
	 * Returns the speed of the current Wifi connection
	 * @param ctx a Context
	 * @return the speed in Mbps
	 */

#Code:
	public static final int getConnectionSpeed(Context ctx)
	{
		WifiManager wifiManager = (WifiManager) ctx.getSystemService(Context.WIFI_SERVICE);
		WifiInfo info = wifiManager.getConnectionInfo();
		int speed = info.getLinkSpeed();
		Log.d(TAG, "Connection speed: " + speed);
		
		return speed;
	}

#end
#end
#No. 184881
#File: E:\bishe\1\WifiControl.java
#Comment:
	/**
	* Gets the state of Airplane Mode.
	* 
	* @param context
	* @return true if enabled.
	*/

#Code:
	public static boolean isAirplaneModeOn(Context context)
	{

	   return Settings.System.getInt(context.getContentResolver(),
	           Settings.System.AIRPLANE_MODE_ON, 0) != 0;

	}

#end
#end
#No. 184882
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Registers the Wi-Fi manager, registers the app with the Wi-Fi P2P framework, registers the
     * P2P BroadcastReceiver, and registers a local BroadcastManager
     */

#Code:
    @Override
    public void onCreate() {
        super.onCreate();
        Log.i(TAG, "Creating WifiDirectHandler");

        // Registers the Wi-Fi Manager and the Wi-Fi BroadcastReceiver
        wifiManager = (WifiManager) getSystemService(WIFI_SERVICE);
        registerWifiReceiver();

        // Scans for available Wi-Fi networks
        wifiManager.startScan();

        if (wifiManager.isWifiEnabled()) {
            Log.i(TAG, "Wi-Fi enabled on load");
        } else {
            Log.i(TAG, "Wi-Fi disabled on load");
        }

        // Registers a local BroadcastManager that is used to broadcast Intents to Activities
        localBroadcastManager = LocalBroadcastManager.getInstance(this);
        Log.i(TAG, "WifiDirectHandler created");
    }

#end
#end
#No. 184883
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Registers the application with the Wi-Fi P2P framework
     * Initializes the P2P manager and gets a P2P communication channel
     */

#Code:
    public void registerP2p() {
        // Manages Wi-Fi P2P connectivity
        wifiP2pManager = (WifiP2pManager) getSystemService(WIFI_P2P_SERVICE);

        // initialize() registers the app with the Wi-Fi P2P framework
        // Channel is used to communicate with the Wi-Fi P2P framework
        // Main Looper is the Looper for the main thread of the current process
        channel = wifiP2pManager.initialize(this, getMainLooper(), null);
        Log.i(TAG, "Registered with Wi-Fi P2P framework");
    }

#end
#end
#No. 184884
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Unregisters the application with the Wi-Fi P2P framework
     */

#Code:
    public void unregisterP2p() {
        if (wifiP2pManager != null) {
            wifiP2pManager = null;
            channel = null;
            thisDevice = null;
            localBroadcastManager.sendBroadcast(new Intent(Action.DEVICE_CHANGED));
            Log.i(TAG, "Unregistered with Wi-Fi P2P framework");
        }
    }

#end
#end
#No. 184885
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Registers a WifiDirectBroadcastReceiver with an IntentFilter listening for P2P Actions
     */

#Code:
    public void registerP2pReceiver() {
        p2pBroadcastReceiver = new WifiDirectBroadcastReceiver();
        IntentFilter intentFilter = new IntentFilter();

        // Indicates a change in the list of available peers
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
        // Indicates a change in the Wi-Fi P2P status
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
        // Indicates the state of Wi-Fi P2P connectivity has changed
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
        // Indicates this device's details have changed.
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);

        registerReceiver(p2pBroadcastReceiver, intentFilter);
        Log.i(TAG, "P2P BroadcastReceiver registered");
    }

#end
#end
#No. 184886
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Unregisters the WifiDirectBroadcastReceiver and IntentFilter
     */

#Code:
    public void unregisterP2pReceiver() {
        if (p2pBroadcastReceiver != null) {
            unregisterReceiver(p2pBroadcastReceiver);
            p2pBroadcastReceiver = null;
            Log.i(TAG, "P2P BroadcastReceiver unregistered");
        }
    }

#end
#end
#No. 184887
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * The requested connection info is available
     * @param wifiP2pInfo Wi-Fi P2P connection info
     */

#Code:
    @Override
    public void onConnectionInfoAvailable(WifiP2pInfo wifiP2pInfo) {
        Log.i(TAG, "Connection info available");

        Log.i(TAG, "WifiP2pInfo: ");
        Log.i(TAG, p2pInfoToString(wifiP2pInfo));
        this.groupFormed = wifiP2pInfo.groupFormed;
        this.isGroupOwner = wifiP2pInfo.isGroupOwner;

        if (wifiP2pInfo.groupFormed) {
            if(stopDiscoveryAfterGroupFormed){
                stopServiceDiscovery();
            }

//            Thread handler;
            if (wifiP2pInfo.isGroupOwner && socketHandler == null) {
                Log.i(TAG, "Connected as group owner");
                try {
                    socketHandler = new OwnerSocketHandler(this.getHandler());
                    socketHandler.start();
                } catch (IOException e) {
                    Log.e(TAG, "Failed to create a server thread - " + e.getMessage());
                    return;
                }
            } else {
                Log.i(TAG, "Connected as peer");
                socketHandler = new ClientSocketHandler(this.getHandler(), wifiP2pInfo.groupOwnerAddress);
                socketHandler.start();
            }

//            localBroadcastManager.sendBroadcast(new Intent(Action.SERVICE_CONNECTED));
        } else {
            Log.w(TAG, "Group not formed");
        }
        localBroadcastManager.sendBroadcast(new Intent(Action.DEVICE_CHANGED));
    }

#end
#end
#No. 184888
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Removes persistent/remembered groups
     *
     * Source: https://android.googlesource.com/platform/cts/+/jb-mr1-dev%5E1%5E2..jb-mr1-dev%5E1/
     * Author: Nick  Kralevich <nnk@google.com>
     *
     * WifiP2pManager.java has a method deletePersistentGroup(), but it is not accessible in the
     * SDK. According to Vinit Deshpande <vinitd@google.com>, it is a common Android paradigm to
     * expose certain APIs in the SDK and hide others. This allows Android to maintain stability and
     * security. As a workaround, this removePersistentGroups() method uses Java reflection to call
     * the hidden method. We can list all the methods in WifiP2pManager and invoke "deletePersistentGroup"
     * if it exists. This is used to remove all possible persistent/remembered groups. 
     */

#Code:
    private void removePersistentGroups() {
        try {
            Method[] methods = WifiP2pManager.class.getMethods();
            for (int i = 0; i < methods.length; i++) {
                if (methods[i].getName().equals("deletePersistentGroup")) {
                    // Remove any persistent group
                    for (int netid = 0; netid < 32; netid++) {
                        methods[i].invoke(wifiP2pManager, channel, netid, null);
                    }
                }
            }
            Log.i(TAG, "Persistent groups removed");
        } catch(Exception e) {
            Log.e(TAG, "Failure removing persistent groups: " + e.getMessage());
            e.printStackTrace();
        }
    }

#end
#end
#No. 184889
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Removes the current WifiP2pGroup in the WifiP2pChannel.
     */

#Code:
    public void removeGroup() {
        if (wifiP2pGroup != null) {
            wifiP2pManager.removeGroup(channel, new WifiP2pManager.ActionListener() {
                @Override
                public void onSuccess() {
                    wifiP2pGroup = null;
                    groupFormed = false;
                    isGroupOwner = false;
                    Log.i(TAG, "Group removed");
                }

                @Override
                public void onFailure(int reason) {
                    Log.e(TAG, "Failure removing group: " + FailureReason.fromInteger(reason).toString());
                }
            });
        }
    }

#end
#end
#No. 184890
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /*
     * Registers listeners for DNS-SD services. These are callbacks invoked
     * by the system when a service is actually discovered.
     */

#Code:
    private void registerServiceDiscoveryListeners() {
        // DnsSdTxtRecordListener
        // Interface for callback invocation when Bonjour TXT record is available for a service
        // Used to listen for incoming records and get peer device information
        WifiP2pManager.DnsSdTxtRecordListener txtRecordListener = new WifiP2pManager.DnsSdTxtRecordListener() {
            @Override
            public void onDnsSdTxtRecordAvailable(String fullDomainName, Map<String, String> txtRecordMap, WifiP2pDevice srcDevice) {
                // Records of peer are available
                Log.i(TAG, "Peer DNS-SD TXT Record available");

                Intent intent = new Intent(Action.DNS_SD_TXT_RECORD_AVAILABLE);
                intent.putExtra(TXT_MAP_KEY, srcDevice.deviceAddress);
                localBroadcastManager.sendBroadcast(intent);
                dnsSdTxtRecordMap.put(srcDevice.deviceAddress, new DnsSdTxtRecord(fullDomainName, txtRecordMap, srcDevice));
            }
        };

        // DnsSdServiceResponseListener
        // Interface for callback invocation when Bonjour service discovery response is received
        // Used to get service information
        WifiP2pManager.DnsSdServiceResponseListener serviceResponseListener = new WifiP2pManager.DnsSdServiceResponseListener() {
            @Override
            public void onDnsSdServiceAvailable(String instanceName, String registrationType, WifiP2pDevice srcDevice) {
                // Not sure if we want to track the map here or just send the service in the request to let the caller do
                // what it wants with it

                Log.i(TAG, "DNS-SD service available");
                Log.i(TAG, "Local service found: " + instanceName);
                Log.i("TAG", "Source device: ");
                Log.i(TAG, p2pDeviceToString(srcDevice));
                dnsSdServiceMap.put(srcDevice.deviceAddress, new DnsSdService(instanceName, registrationType, srcDevice));
                Intent intent = new Intent(Action.DNS_SD_SERVICE_AVAILABLE);
                intent.putExtra(SERVICE_MAP_KEY, srcDevice.deviceAddress);
                localBroadcastManager.sendBroadcast(intent);
            }
        };

        wifiP2pManager.setDnsSdResponseListeners(channel, serviceResponseListener, txtRecordListener);
        Log.i(TAG, "Service discovery listeners registered");
    }

#end
#end
#No. 184891
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * By default after a group is formed service discovery will be stopped automatically. If you
     * wish to continue discovery after forming a group set this to false
     *
     * @param stopDiscoveryAfterGroupFormed true to stop discovery automatically after a group is formed; false otherwise
     */

#Code:
    public void setStopDiscoveryAfterGroupFormed(boolean stopDiscoveryAfterGroupFormed){
        this.stopDiscoveryAfterGroupFormed=stopDiscoveryAfterGroupFormed;
    }



#end
#end
#No. 184893
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Initiates a service discovery. This has a 2 minute timeout. To continuously
     * discover services use continuouslyDiscoverServices
     */

#Code:
    public void discoverServices(){
        // Initiates service discovery. Starts to scan for services we want to connect to
        wifiP2pManager.discoverServices(channel, new WifiP2pManager.ActionListener() {
            @Override
            public void onSuccess() {
                Log.i(TAG, "Service discovery initiated");
            }

            @Override
            public void onFailure(int reason) {
                Log.e(TAG, "Failure initiating service discovery: " + FailureReason.fromInteger(reason).toString());
            }
        });
    }

#end
#end
#No. 184894
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Calls initial services discovery call and submits the first
     * Discover task. This will continue until stopDiscoveringServices is called
     */

#Code:
    public void continuouslyDiscoverServices(){
        Log.i(TAG, "Continuously Discover services called");

        if (serviceDiscoveryRegistered == false) {
            Log.i(TAG, "Setting up service discovery");
            registerServiceDiscoveryListeners();
            serviceDiscoveryRegistered = true;
        }

        // TODO Change this to give some sort of status
        if (isDiscovering){
            Log.w(TAG, "Services are still discovering, do not need to make this call");
        } else {
            addServiceDiscoveryRequest();
            isDiscovering = true;
            // List to track discovery tasks in progress
            serviceDiscoveryTasks = new ArrayList<>();
            // Make discover call and first discover task submission
            discoverServices();
            submitServiceDiscoveryTask();
        }
    }

#end
#end
#No. 184895
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Submits a new task to initiate service discovery after the discovery
     * timeout period has expired
     */

#Code:
    private void submitServiceDiscoveryTask(){
        Log.i(TAG, "Submitting service discovery task");
        // Discover times out after 2 minutes so we set the timer to that
        int timeToWait = SERVICE_DISCOVERY_TIMEOUT;
        ServiceDiscoveryTask serviceDiscoveryTask = new ServiceDiscoveryTask();
        Timer timer = new Timer();
        // Submit the service discovery task and add it to the list
        timer.schedule(serviceDiscoveryTask, timeToWait);
        serviceDiscoveryTasks.add(serviceDiscoveryTask);
    }

#end
#end
#No. 184896
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Uses wifiManager to determine if Wi-Fi is enabled
     * @return Whether Wi-Fi is enabled or not
     */

#Code:
    public boolean isWifiEnabled() {
        return wifiManager.isWifiEnabled();
    }

#end
#end
#No. 184897
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Removes a registered local service.
     */

#Code:
    public void removeService() {
        if(wifiP2pServiceInfo != null) {
            Log.i(TAG, "Removing local service");
            wifiP2pManager.removeLocalService(channel, wifiP2pServiceInfo, new WifiP2pManager.ActionListener() {
                @Override
                public void onSuccess() {
                    wifiP2pServiceInfo = null;
                    Intent intent = new Intent(Action.SERVICE_REMOVED);
                    localBroadcastManager.sendBroadcast(intent);
                    Log.i(TAG, "Local service removed");
                }

                @Override
                public void onFailure(int reason) {
                    Log.e(TAG, "Failure removing local service: " + FailureReason.fromInteger(reason).toString());
                }
            });
            wifiP2pServiceInfo = null;
        } else {
            Log.w(TAG, "No local service to remove");
        }
    }

#end
#end
#No. 184898
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Initiates a connection to a service
     * @param service The service to connect to
     */

#Code:
    public void initiateConnectToService(DnsSdService service) {
        // Device info of peer to connect to
        WifiP2pConfig wifiP2pConfig = new WifiP2pConfig();
        wifiP2pConfig.deviceAddress = service.getSrcDevice().deviceAddress;
        wifiP2pConfig.wps.setup = WpsInfo.PBC;

        // Starts a peer-to-peer connection with a device with the specified configuration
        wifiP2pManager.connect(channel, wifiP2pConfig, new WifiP2pManager.ActionListener() {
            // The ActionListener only notifies that initiation of connection has succeeded or failed

            @Override
            public void onSuccess() {
                Log.i(TAG, "Initiating connection to service");
            }

            @Override
            public void onFailure(int reason) {
                Log.e(TAG, "Failure initiating connection to service: " + FailureReason.fromInteger(reason).toString());
            }
        });
    }

#end
#end
#No. 184899
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Creates a service that can be connected to without prompting. This is possible by creating an
     * access point and broadcasting the password for peers to use. Peers connect via normal wifi, not
     * wifi direct, but the effect is the same.
     */

#Code:
    public void startAddingNoPromptService(ServiceData serviceData) {
        if (wifiP2pServiceInfo != null) {
            removeService();
        }
        isCreatingNoPrompt = true;
        noPromptServiceData = serviceData;

        wifiP2pManager.createGroup(channel, new WifiP2pManager.ActionListener() {
            @Override
            public void onSuccess() {
                Log.i(TAG, "Group created successfully");
                //Note that you will have to wait for WIFI_P2P_CONNECTION_CHANGED_INTENT for group info
            }

            @Override
            public void onFailure(int reason) {
                Log.i(TAG, "Group creation failed: " + FailureReason.fromInteger(reason));

            }
        });
    }

#end
#end
#No. 184900
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Connects to a no prompt service
     * @param service The service to connect to
     */

#Code:
    public void connectToNoPromptService(DnsSdService service) {
        removeService();
        WifiConfiguration configuration = new WifiConfiguration();
        DnsSdTxtRecord txtRecord = dnsSdTxtRecordMap.get(service.getSrcDevice().deviceAddress);
        if(txtRecord == null) {
            Log.e(TAG, "No dnsSdTxtRecord found for the no prompt service");
            return;
        }
        // Quotes around these are required
        configuration.SSID = "\"" + txtRecord.getRecord().get(Keys.NO_PROMPT_NETWORK_NAME) + "\"";
        configuration.preSharedKey = "\"" + txtRecord.getRecord().get(Keys.NO_PROMPT_NETWORK_PASS) + "\"";
        int netId = wifiManager.addNetwork(configuration);

        //disconnect form current network and connect to this one
        wifiManager.disconnect();
        wifiManager.enableNetwork(netId, true);
        wifiManager.reconnect();
        Log.i(TAG, "Connected to no prompt network");
    }

#end
#end
#No. 184901
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * The list of discovered peers has changed
     * Available extras: EXTRA_P2P_DEVICE_LIST
     * @param intent
     */

#Code:
    private void handlePeersChanged(Intent intent) {
        Log.i(TAG, "List of discovered peers changed");
        if (wifiP2pManager != null) {
            // Request the updated list of discovered peers from wifiP2PManager
            wifiP2pManager.requestPeers(channel, new WifiP2pManager.PeerListListener() {
                @Override
                public void onPeersAvailable(WifiP2pDeviceList peers) {
                    WifiDirectHandler.this.peers = peers;
                    Intent intent = new Intent(Action.PEERS_CHANGED);
                    intent.putExtra(PEERS, peers);
                    localBroadcastManager.sendBroadcast(intent);
                }
            });
        }
    }

#end
#end
#No. 184902
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * The state of Wi-Fi P2P connectivity has changed
     * Here is where you can request group info
     * Available extras: EXTRA_WIFI_P2P_INFO, EXTRA_NETWORK_INFO, EXTRA_WIFI_P2P_GROUP
     * @param intent
     */

#Code:
    private void handleConnectionChanged(Intent intent) {
        Log.i(TAG, "Wi-Fi P2P Connection Changed");

        if(wifiP2pManager == null) {
            return;
        }

        // Extra information from EXTRA_NETWORK_INFO
        NetworkInfo networkInfo = intent.getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO);
        if(networkInfo.isConnected()) {
            Log.i(TAG, "Connected to P2P network. Requesting connection info");
            wifiP2pManager.requestConnectionInfo(channel, WifiDirectHandler.this);
        } else {
            Intent disconnected = new Intent(Action.COMMUNICATION_DISCONNECTED);
            localBroadcastManager.sendBroadcast(disconnected);
        }

        // Requests peer-to-peer group information
        wifiP2pManager.requestGroupInfo(channel, new WifiP2pManager.GroupInfoListener() {
            @Override
            public void onGroupInfoAvailable(WifiP2pGroup wifiP2pGroup) {
                if (wifiP2pGroup != null) {
                    Log.i(TAG, "Group info available");
                    Log.i(TAG, "WifiP2pGroup:");
                    Log.i(TAG, p2pGroupToString(wifiP2pGroup));
                    WifiDirectHandler.this.wifiP2pGroup = wifiP2pGroup;
                }
            }
        });

    }

#end
#end
#No. 184903
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Indicates whether Wi-Fi P2P is enabled
     * Determine if Wi-Fi P2P mode is enabled or not, alert the Activity
     * Available extras: EXTRA_WIFI_STATE
     * Sticky Intent
     * @param intent
     */

#Code:
    private void handleP2pStateChanged(Intent intent) {
        Log.i(TAG, "Wi-Fi P2P State Changed:");
        int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1);
        if (state == WifiP2pManager.WIFI_P2P_STATE_ENABLED) {
            // Wi-Fi Direct is enabled
            isWifiP2pEnabled = true;
            Log.i(TAG, "- Wi-Fi Direct is enabled");
        } else {
            // Wi-Fi Direct is not enabled
            isWifiP2pEnabled = false;
            Log.i(TAG, "- Wi-Fi Direct is not enabled");
        }
    }

#end
#end
#No. 184904
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Indicates this device's configuration details have changed
     * Sticky Intent
     * @param intent
     */

#Code:
    private void handleThisDeviceChanged(Intent intent) {
        Log.i(TAG, "This device changed");

        // Extra information from EXTRA_WIFI_P2P_DEVICE
        thisDevice = intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_DEVICE);

        // Logs extra information from EXTRA_WIFI_P2P_DEVICE
        Log.i(TAG, p2pDeviceToString(thisDevice));

        localBroadcastManager.sendBroadcast(new Intent(Action.DEVICE_CHANGED));
    }

#end
#end
#No. 184905
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Toggle wifi
     * @param wifiEnabled whether or not wifi should be enabled
     */

#Code:
    public void setWifiEnabled(boolean wifiEnabled) {
        wifiManager.setWifiEnabled(wifiEnabled);
    }

#end
#end
#No. 184906
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Takes a WifiP2pDevice and returns a String of readable device information
     * @param wifiP2pDevice
     * @return
     */

#Code:
    public String p2pDeviceToString(WifiP2pDevice wifiP2pDevice) {
        if (wifiP2pDevice != null) {
            String strDevice = "Device name: " + wifiP2pDevice.deviceName;
            strDevice += "\nDevice address: " + wifiP2pDevice.deviceAddress;
            if (wifiP2pDevice.equals(thisDevice)) {
                strDevice += "\nIs group owner: " + isGroupOwner();
            } else {
                strDevice += "\nIs group owner: false";
            }
            strDevice += "\nStatus: " + deviceStatusToString(wifiP2pDevice.status) + "\n";
            return strDevice;
        } else {
            Log.e(TAG, "WifiP2pDevice is null");
            return "";
        }
    }

#end
#end
#No. 184907
#File: E:\bishe\1\WifiDirectHandler.java
#Comment:
    /**
     * Translates a device status code to a readable String status
     * @param status
     * @return A readable String device status
     */

#Code:
    public String deviceStatusToString(int status) {
        if (status == WifiP2pDevice.AVAILABLE) {
            return "Available";
        } else if (status == WifiP2pDevice.INVITED) {
            return "Invited";
        } else if (status == WifiP2pDevice.CONNECTED) {
            return "Connected";
        } else if (status == WifiP2pDevice.FAILED) {
            return "Failed";
        } else if (status == WifiP2pDevice.UNAVAILABLE) {
            return "Unavailable";
        } else {
            return "Unknown";
        }
    }

#end
#end
#No. 184908
#File: E:\bishe\1\WifiHelper.java
#Comment:
    /**
     * @return a map of printable SSIDs to a base64 encoded representation of the SSID
     */

#Code:
    public Map<String, String> getPrintableNetworks() {
        List<WifiConfiguration> storedNetworks = getStoredNetworks();

        Map<String, String> printableNetworks = new HashMap<String, String>();
        for (WifiConfiguration wifiConfiguration : storedNetworks) {
            String ssid = stripQuotes(wifiConfiguration.SSID);
            if (!TextUtils.isEmpty(ssid)) {
                printableNetworks.put(ssid, base64Encode(ssid));
            }
        }

        return printableNetworks;
    }

#end
#end
#No. 184909
#File: E:\bishe\1\WifiHelper.java
#Comment:
    /**
     * @return a list of {@link android.net.wifi.WifiConfiguration}s or null if Wifi is disabled
     * or there was a failure getting networks
     */

#Code:
    public List<WifiConfiguration> getStoredNetworks() {
        return ((WifiManager) mContext.getSystemService(Context.WIFI_SERVICE)).getConfiguredNetworks();
    }

#end
#end
#No. 184910
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
   /**
     * Check if The Device Is Connected to Hotspot using wifi
     * 
     * @return true if device connect to Hotspot 
     */

#Code:
    public boolean  isConnectedToAP(){
		ConnectivityManager connectivity = (ConnectivityManager)mContext
		        .getSystemService(Context.CONNECTIVITY_SERVICE);
		if (connectivity != null) {
		    NetworkInfo info = connectivity.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
		    if (info != null) {
		        if (info.isConnected()) {
			            return true;
		        }
		    }
		}
		return false;
	}

#end
#end
#No. 184911
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
     * Method to Get hotspot Max Level of all Hotspots Around you
     * 
     * @return a highest level hotspot 
     */

#Code:
    public ScanResult getHotspotMaxLevel(){
    	List<ScanResult> hotspotList=mWifiManager.getScanResults();
    	  if (hotspotList != null) {
	            final int size = hotspotList.size();
		            if (size == 0){ 
	            	return null;
	                } else {
	                ScanResult maxLevel = hotspotList.get(0);
	                for (ScanResult result : hotspotList) {
	                      if (WifiManager.compareSignalLevel(maxLevel.level,
	                            result.level) < 0) {
	                        maxLevel = result;
	                    }
	                }
	                return maxLevel;
	            }
	        }else{
	        	return null;
	        }
	    }

#end
#end
#No. 184912
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
     * Method to Get hotspot Max Level of all Hotspots in hotspotList list 
     * 
     * @param  hotspotList list of Hotspots 
     * @return a highest level hotspot 
     */

#Code:
    public ScanResult getHotspotMaxLevel(List<ScanResult> hotspotList){
    	
    	  if (hotspotList != null) {
	            final int size = hotspotList.size();
		            if (size == 0){ 
	            	return null;
	            } else {
	                ScanResult maxSignal = hotspotList.get(0);
	              
	                for (ScanResult result : hotspotList) {
	                      if (WifiManager.compareSignalLevel(maxSignal.level,
	                            result.level) < 0) {
	                        maxSignal = result;
	                    }
	                }
	                return maxSignal;
	            }
	        }else{
	        	return null;
	        }
	        
	    }

#end
#end
#No. 184913
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
     * sort All  Hotspots Around you By Level
     * 
     * @return sorted hotspots List
     */

#Code:
    public List<ScanResult> sortHotspotsByLevel(){
    	List<ScanResult> hotspotList=mWifiManager.getScanResults();
    	List<ScanResult> sorthotspotsList=new ArrayList<ScanResult>();
    	ScanResult result;
  	    while(!hotspotList.isEmpty()){
  	        result=getHotspotMaxLevel(hotspotList); 
  	        sorthotspotsList.add(result);
  	        hotspotList.remove(result);  
  	    }
  	              
	    return sorthotspotsList;
    }

#end
#end
#No. 184914
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
     * sort Hotspots in hotspotList By Level
     * 
     * @return sorted hotspots List
     */

#Code:
    public List<ScanResult> sortHotspotsByLevel(List<ScanResult> hotspotList){
    	List<ScanResult> hotspotList2=hotspotList;
    	List<ScanResult> sorthotspotsList=new ArrayList<ScanResult>();
    	ScanResult result;
  	    while(!hotspotList2.isEmpty()){
  	         result=getHotspotMaxLevel(hotspotList2); 
  	         sorthotspotsList.add(result);
  	         hotspotList2.remove(result);  
  	    }
 	    return sorthotspotsList;
	   }

#end
#end
#No. 184915
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
     * Method to Get  List of  WIFI Networks (hotspots) Around you
     * 
     * @return List  of networks (hotspots)
     */

#Code:
    public List<ScanResult> getHotspotsList(){
    	
    	if(mWifiManager.isWifiEnabled()) {
    	 	
    	 	if(mWifiManager.startScan()){
    	 		return mWifiManager.getScanResults();	
    	 	}
    		
		}
	return null;
    }

#end
#end
#No. 184916
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
   /**
     * Method to Get and showing  List of  WIFI Networks (hotspots) Around you
     * 
     * @param List a listview for showing list of networks (hotspots)
     */

#Code:
	public void showHotspotsList(ListView List){
		if(mWifiManager.isWifiEnabled()) {
			mReceiver = new WifiReceiver();
			scanNetworks();
			mNetworksList = mNetworksList==null ? List : mNetworksList;
			if(mResults!=null){
			mAdapter = new ScanResultsAdapter(mContext,mResults);
			mNetworksList.setAdapter(mAdapter);
			}
		} 
		else Toast.makeText(mContext,"wifi is not enabled", Toast.LENGTH_LONG).show();
	}

#end
#end
#No. 184918
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
 	/**
     * Method to turn ON/OFF a  Access Point  
     * 
     * @param enable Put true if you want to start  Access Point  
     * @return true if AP is started
     */

#Code:
    public boolean startHotSpot(boolean enable) {
    	mWifiManager.setWifiEnabled(false);
        Method[] mMethods = mWifiManager.getClass().getDeclaredMethods();
        for (Method mMethod : mMethods) {
            if (mMethod.getName().equals("setWifiApEnabled")) {
                try {
                    mMethod.invoke(mWifiManager, null, enable);
                    return true;
                } catch (Exception ex) {
                }
                break;
            }
        }
        return false;
    }

#end
#end
#No. 184919
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
     * Method to Change SSID and Password of Device Access Point and Start HotSpot 
     * 
     * @param SSID a new SSID of your Access Point
     * @param passWord a new password you want for your Access Point
     */

#Code:
    public boolean setAndStartHotSpot(boolean enable, String SSID)
    {
    	//For simple implementation I am creating the open hotspot.
    	Method[] mMethods = mWifiManager.getClass().getDeclaredMethods();
    	for(Method mMethod: mMethods){
    		{
    			if(mMethod.getName().equals("setWifiApEnabled")) {
    				WifiConfiguration netConfig = new WifiConfiguration();
    				netConfig.SSID = SSID;
    				netConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
    				try{
    				mMethod.invoke(mWifiManager, netConfig,true);
    				}catch(Exception e)
    				{
    					return false;
    				}
    				startHotSpot(enable);
    			}
    		}
    	}
    	return enable;
    }

#end
#end
#No. 184920
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
 	 /**
     * @return true if Wifi Access Point Enabled
     */

#Code:
    public boolean isWifiApEnabled() {
        try {
            Method method = mWifiManager.getClass().getMethod("isWifiApEnabled");
            return (Boolean)method.invoke(mWifiManager);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return false;
    }

#end
#end
#No. 184921
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
   /**
     * shred all  Configured wifi Networks
     */

#Code:
    public boolean shredAllWifi(){
    	Context context =  mContext;
    	 mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
    	
    	if( mWifiInfo != null ){
    	    for(WifiConfiguration conn:  mWifiManager.getConfiguredNetworks()){
    	    	 mWifiManager.removeNetwork(conn.networkId);
    	    }
    	    
    	    mWifiManager.saveConfiguration(); 
    	    return true;
    	}
    	return false;
	}

#end
#end
#No. 184922
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
     * This gets a list of the wifi profiles from the system and returns them.
     * @return List<WifiConfigurationg> : a list of all the profile names.
     */

#Code:
    public ArrayList<WifiConfiguration> getProfiles(){
    	ArrayList<WifiConfiguration> profileList =new ArrayList<WifiConfiguration>();
      	if( mWifiInfo != null ){ 
    	    for(WifiConfiguration conn: mWifiManager.getConfiguredNetworks()){
    	    	profileList.add(conn);
    	    	  }
    	}
    	return profileList;
    }

#end
#end
#No. 184923
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
     *shred  Configured wifi Network By SSID
     * @param ssid of wifi Network
     */

#Code:
    public void removeWifiNetwork(String ssid) {
        List<WifiConfiguration> configs = mWifiManager.getConfiguredNetworks();
        if (configs != null) {
            for (WifiConfiguration config : configs) {
                if (config.SSID.contains(ssid)) {
                    mWifiManager.disableNetwork(config.networkId);
                    mWifiManager.removeNetwork(config.networkId);
                }
            }
        }
        mWifiManager.saveConfiguration();
    }

#end
#end
#No. 184924
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
     * get Connection Info
     * @return WifiInfo
     */

#Code:
    public WifiInfo getConnectionInfo() {
        return mWifiManager.getConnectionInfo();
    }

#end
#end
#No. 184926
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
   	/**
	 * Run command as root.
	 * 
	 * @param command
	 * @return true, if command was successfully executed
	 */

#Code:
	private static boolean runAsRoot(final String command) {
		try {
								
			Process pro = Runtime.getRuntime().exec("su");
			DataOutputStream outStr = new DataOutputStream(pro.getOutputStream());
			
			 outStr.writeBytes(command);
			 outStr.writeBytes("\nexit\n");
			 outStr.flush();
			 
			int retval = pro.waitFor();
			
			return (retval == 0);
			
		    } catch (Exception e) {
		    	
			return false;
			
		    }
	}

#end
#end
#No. 184927
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
	 /**
  	 * Method to Get Ap Capabilities
  	 * 
  	 * @param SSID Name of HotSpot
  	 * @return String contain Ap Capabilities
  	 */

#Code:
    public String getApCapabilities(String mSSID){
    	scanNetworks();
	      for (ScanResult r : mResults) {
         if(r.SSID.equals(mSSID)){
    	     return r.capabilities;
    	     }
    	   }
    	 
    	return null;
 } 

#end
#end
#No. 184928
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
  	 * Method to Get Ap frequency
  	 * 
  	 * @param SSID Name of HotSpot
  	 * @return int contain Link Speed
  	 */

#Code:
    public int getApfrequency(String mSSID){
    	scanNetworks();
 	      for (ScanResult r : mResults) {
           if(r.SSID.equals(mSSID)){
      	     return r.frequency;
      	     }
      	   }
      	 
	    	return 0;
 } 

#end
#end
#No. 184929
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
  	 * Method to Get Ap Signal Level
  	 * 
  	 * @param SSID Name of HotSpot
  	 * @return int contain Link Speed
  	 */

#Code:
    public int getApSignalLevel(String mSSID){
       scanNetworks();
	      for (ScanResult r : mResults) {
         if(r.SSID.equals(mSSID)){
    	     return r.level;
    	     }
    	   }
    	 
    	return 0;
 } 

#end
#end
#No. 184930
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
    /**
     * Method to Get Security Mode By Network SSID
     * 
     * @param SSID Name of HotSpot
     * @return OPEN PSK EAP OR WEP
     */

#Code:
   public  String getSecurityModeBySSID(String SSID){
	   
	   List<ScanResult> scanResultList=mWifiManager.getScanResults();
       
       if(mWifiManager.isWifiEnabled()){
       		
       for (ScanResult result : scanResultList) {
       	
           if (result.SSID.equals(SSID)) {
        	   return getSecurityMode(result);
        	  
           }
       }
       
       }
	  return null; 
   } 

#end
#end
#No. 184931
#File: E:\bishe\1\wifiHotSpots.java
#Comment:
   /**
    * Method to Get Network Security Mode
    * 
    * @param scanResult 
    * @return OPEN PSK EAP OR WEP
    */

#Code:
   public String getSecurityMode(ScanResult scanResult) {
       final String cap = scanResult.capabilities;
       final String[] modes = {"WPA", "EAP","WEP" };
        for (int i = modes.length - 1; i >= 0; i--) {
           if (cap.contains(modes[i])) {
               return modes[i];
           }
       }
      return "OPEN";
   }

#end
#end
#No. 184935
#File: E:\bishe\1\WifiManagerWrap.java
#Comment:
	/**
	 * start WiFi connect
	 */

#Code:
	public boolean startWifi() {
		try {
			Method method = mWifiManager.getClass().getMethod("startWifi");
			return (Boolean)method.invoke(mWifiManager);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return false;

	}

#end
#end
#No. 184936
#File: E:\bishe\1\WifiManagerWrap.java
#Comment:
	/**
	 * stop WiFi connect
	 */

#Code:
	public boolean stopWifi() {
		try {
			Method method = mWifiManager.getClass().getMethod("stopWifi");
			return (Boolean)method.invoke(mWifiManager);
		} catch (Exception e) {
			e.printStackTrace();
		}

		return false;
	}

#end
#end
#No. 184937
#File: E:\bishe\1\WifiManagerWrap.java
#Comment:
	/**
	 * clear the special net Info
	 */

#Code:
	public void removeNetwork(String ssid) {
		List<WifiConfiguration> configs = mWifiManager.getConfiguredNetworks();
		if (configs != null) {
			for (WifiConfiguration config : configs) {
				loadWifiConfigurationFromProfile(config);
				if ( (config.SSID != null ) && config.SSID.contains(ssid) ) {
					mWifiManager.disableNetwork(config.networkId);
					mWifiManager.removeNetwork(config.networkId);
				}
			}
		}
		mWifiManager.saveConfiguration();

	}




#end
#end
#No. 184961
#File: E:\bishe\1\WifiP2pBroadcastObservableManagerFactory.java
#Comment:
/**
 * Created by Stefan Mitev on 01/07/2015.
 *
 * This concrete implementation of {@link BroadcastObservableManager.Factory} takes care of
 * instantiation of new {@link WifiP2PBroadcastObservableManager}s.
 */

#Code:
public class WifiP2pBroadcastObservableManagerFactory
        implements BroadcastObservableManager.Factory {
    private final Context mContext;

    public WifiP2pBroadcastObservableManagerFactory(final Context context) {
        mContext = context;
    }

    @Override
    public WifiP2PBroadcastObservableManager create() {
        return new WifiP2PBroadcastObservableManager(mContext);
    }
}

#end
#end
#No. 184962
#File: E:\bishe\1\WiFiPayload.java
#Comment:
/**
 * An MDM payload for Wi-Fi.
 *
 * @author Sylvain Pedneault
 */

#Code:
class WiFiPayload extends MobileConfigPayload {
  public WiFiPayload(final int payloadVersion, final String payloadOrganization, final String payloadIdentifier, final String payloadDisplayName, final String ssidStr, final boolean hiddenNetwork, final String encryptionType) throws JSONException {
    super(payloadVersion, "com.apple.wifi.managed", payloadOrganization, payloadIdentifier, payloadDisplayName);
    final JSONObject payload = getPayload();
    payload.put("SSID_STR", ssidStr);
    payload.put("HIDDEN_NETWORK", hiddenNetwork);
    payload.put("EncryptionType", encryptionType);
  }

  public void setPassword(final String value) throws JSONException {
    getPayload().put("Password", value);
  }

  public JSONObject addEAPClientConfiguration() throws JSONException {
    final JSONObject object = new JSONObject();
    getPayload().put("EAPClientConfiguration", object);
    return object;
  }
}



#end
#end
#No. 184965
#File: E:\bishe\1\WiFiServicesAdapter.java
#Comment:
    /**
     * Private method used by this adapter to obtain the status, from the status code.
     * @param statusCode int that represents the status code.
     * @return A String that represent the status associated to the statusCode.
     */

#Code:
    private static String getDeviceStatus(int statusCode) {
        switch (statusCode) {
            case WifiP2pDevice.CONNECTED:
                return "Connected";
            case WifiP2pDevice.INVITED:
                return "Invited";
            case WifiP2pDevice.FAILED:
                return "Failed";
            case WifiP2pDevice.AVAILABLE:
                return "Available";
            case WifiP2pDevice.UNAVAILABLE:
                return "Unavailable";
            default:
                return "Unknown";

        }
    }

#end
#end
#No. 184966
#File: E:\bishe\1\WifiStatus.java
#Comment:
	   /**
		 * Method to Check if the Device Support  Wifi or not 
		 * 
		 * @return true if Wifi supported or false if Wifi not supported
		 */

#Code:
	  public boolean isSupportWifi() {
		    PackageManager pm = mContext.getPackageManager();
		    if (pm.hasSystemFeature(PackageManager.FEATURE_WIFI)) {
		        return true;
		    } else {
		        return false;
		    }
		}

#end
#end
#No. 184967
#File: E:\bishe\1\WifiStatus.java
#Comment:
	  /**
		 * Method to Check if Wifi Direct is  Supported  or not in this android version
		 * 
		 * @return true if Wifi Direct is supported or false if Wifi Direct not supported
		 */

#Code:
	  public boolean isSupportWifiDirect() {
		  PackageManager pm = mContext.getPackageManager();
		    if (pm.hasSystemFeature(PackageManager.FEATURE_WIFI_DIRECT)) {
		        return true;
		    } else {
		        return false;
		    }
		}

#end
#end
#No. 184968
#File: E:\bishe\1\WifiStatus.java
#Comment:
		/**
		 * Method to Check if wifi is enabled
		 * 
		 * @return true if wifi enabled or false if wifi Disabled 
		 */

#Code:
	  public boolean istWifiEnabled() {
			if (!mWifiManager.isWifiEnabled() ) {
				  return false;
			 }else{
			      return true;  	   
			  }
	  }

#end
#end
#No. 184969
#File: E:\bishe\1\WifiStatus.java
#Comment:
	  /**
	     * Check if The Device Is Connected to Hotspot using wifi
	     * 
	     * @return true if device connect to Hotspot or return false if not
	     */

#Code:
      public boolean  isConnectedToAP(){
			ConnectivityManager connectivity = (ConnectivityManager)mContext
			        .getSystemService(Context.CONNECTIVITY_SERVICE);
			if (connectivity != null) {
			    NetworkInfo info = connectivity.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
			    if (info != null) {
			        if (info.isConnected()) {
				            return true;
			        }
			    }
			}
			return false;
		}

#end
#end
#No. 184970
#File: E:\bishe\1\WifiStatus.java
#Comment:
	   /**
		 * Method to Turn wifi ON without Progress dialog
		 */

#Code:
	  public boolean setWifiEnabled(){
			   if(!istWifiEnabled()){
				   mWifiManager.setWifiEnabled(true);
				   return true;
		        }else{
			       return false;
			     	  }
		        }

#end
#end
#No. 184971
#File: E:\bishe\1\WifiStatus.java
#Comment:
		/**
		 * check if wifi disable and Show Progress dialog  to turn on wifi
		 */

#Code:
	  public void wifiEnableDialog()
	    	{
	    		if(!mWifiManager.isWifiEnabled())
	    		{
	   			final ProgressDialog progDialog = new ProgressDialog(mContext);
	   			progDialog.setMessage("Turning Wifi ON");
	   			progDialog.setTitle("WiFi");
	    			AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
	    			builder.setMessage("Do you want to turn ON Wifi ")
	    					.setCancelable(false)
	    					.setPositiveButton("Yes", new DialogInterface.OnClickListener() {
	    						
	    						public void onClick(DialogInterface dialog, int which) {
	    							mWifiManager.setWifiEnabled(true);
	    							progDialog.show();
	    							new Thread() {
	    								public void run() {
	    									try{
	    										while (!mWifiManager.isWifiEnabled()) {
	    											   
	    											sleep(100);} 
	    										progDialog.dismiss();
	    									} catch (Exception e) {} 
	    									
	    								}
	    							}.start();
	    						}
	    					})
	    					.setNegativeButton("No", new DialogInterface.OnClickListener() {
	    						public void onClick(DialogInterface dialog, int which) {
	    						}
	    					});
	    			AlertDialog dialog = builder.create();
	    			dialog.show();
	    		}
	    	}

#end
#end
#No. 184972
#File: E:\bishe\1\WifiStatus.java
#Comment:
	    /**
	     * Method to Turn wifi OFF  without Progress dialog
		 */

#Code:
	  public boolean setWifiDisabled(){
			   	   if(istWifiEnabled()){
			   		mWifiManager.setWifiEnabled(false);
			   	    	return true;
			       }else{
			    	   return false;
			       }
			     } 

#end
#end
#No. 184973
#File: E:\bishe\1\WifiStatus.java
#Comment:
	    /**
	     * check if wifi Enabled  and Show Progress dialog  to turn OFF wifi 
	     */

#Code:
	  public void wifiDisableDialog()
	    	{
	    		if(mWifiManager.isWifiEnabled())
	    		{
	   			final ProgressDialog progDialog = new ProgressDialog(mContext);
	   			progDialog.setMessage("Turning Wifi OFF");
	   			progDialog.setTitle("WiFi");
	    			AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
	    			builder.setMessage("Do you want to turn OFF Wifi ")
	    					.setCancelable(false)
	    					.setPositiveButton("Yes", new DialogInterface.OnClickListener() {
	    						
	    						public void onClick(DialogInterface dialog, int which) {
	    							mWifiManager.setWifiEnabled(false);
	    							progDialog.show();
	    							new Thread() {
	    								public void run() {
	    									try{
	    										
	    										while (mWifiManager.isWifiEnabled()) {
	    											   
	    											sleep(100);} 
	    										progDialog.dismiss();
	    									} catch (Exception e) {} 
	    									
	    								}
	    							}.start();
	    						}
	    					})
	    					.setNegativeButton("No", new DialogInterface.OnClickListener() {
	    						public void onClick(DialogInterface dialog, int which) {
	    						}
	    					});
	    			AlertDialog dialog = builder.create();
	    			dialog.show();
	    		}
	    	}

#end
#end
#No. 184974
#File: E:\bishe\1\WifiStatus.java
#Comment:
	   /**
	  	 * Method to Toggle wifi ON/OFF
	  	 * 
	  	 * @return true if wifi ON and false if wifi OFF
	  	 */

#Code:
 	  public boolean wifiToggle(){
		   
	   	   if(!istWifiEnabled()){
	   	             	mWifiManager.setWifiEnabled(true);
	   		            return true;
	     	        }else{
	     		        mWifiManager.setWifiEnabled(false);
	     		        return false;
	    	               }
	      }

#end
#end
#No. 184975
#File: E:\bishe\1\WifiStatus.java
#Comment:
	    /**
	  	 * Method to Run wifi Settings Activity Using Intent
	  	 */

#Code:
	   public void runWifiSettings(){
		 mContext.startActivity(new Intent(WifiManager.ACTION_PICK_WIFI_NETWORK));
	       }

#end
#end
#No. 184976
#File: E:\bishe\1\WifiStatus.java
#Comment:
	    /**
	     * Check if The Device Is Connected to Internet
	     * 
	     * @return true if device connect to Internet or return false if not
	     */

#Code:
        public boolean  isConnectedToInternet(){
			ConnectivityManager connectivity = (ConnectivityManager)mContext
			        .getSystemService(Context.CONNECTIVITY_SERVICE);
			if (connectivity != null) {
			    NetworkInfo info = connectivity.getActiveNetworkInfo();
			    if (info != null) {
			        if (info.isConnected()) {
				            return pingCmd("www.google.com") ;
			       }
			    }
			}
			return false;
		}

#end
#end
#No. 184977
#File: E:\bishe\1\WifiStatus.java
#Comment:
        /**
     	 * Method to Ping  IP Address
     	 * 
     	 * @param addr IP address you want to ping it 
     	 * @return true if the IP address is reachable
     	 */

#Code:
     	public boolean pingCmd(String addr){
     		try {
    			String ping = "ping  -c 1 -W 3 " + addr;
        		Runtime run = Runtime.getRuntime();
    			Process pro = run.exec(ping);
    			 try {
    				pro.waitFor();
    			} catch (InterruptedException e) {
    				e.printStackTrace();
    			}
    	     	int exit = pro.exitValue();
    	        if (exit == 0) { 
    	        	 return true;
    	         } else {
    	        	 //ip address is not reachable
    	           return false;
    	         }
    		}
    			catch (IOException e) {
    			}
    		return false;
    	}  	

#end
#end
#No. 184978
#File: E:\bishe\1\WifiStatus.java
#Comment:
         /**
         * set Mobile Data Enabled with SIM
         *
         * @param enabled true or false
         */

#Code:
         public void setMobileDataEnabled(boolean enabled) {
            try {
                ConnectivityManager connectivityManager = (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                Method method = connectivityManager.getClass().getMethod("setMobileDataEnabled", boolean.class);
                method.invoke(connectivityManager, enabled);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

#end
#end
#No. 184979
#File: E:\bishe\1\WifiStatus.java
#Comment:
        /**
         * check if  Mobile Data With SIM Enabled
         */

#Code:
        public boolean isMobileDataEnabled() {
            try {
                ConnectivityManager connectivityManager = (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                Method method = connectivityManager.getClass().getMethod("getMobileDataEnabled");
                return (Boolean)method.invoke(connectivityManager);
            } catch (Exception e) {
                e.printStackTrace();
            }

            return false;
        }

#end
#end
#No. 184980
#File: E:\bishe\1\WifiStatus.java
#Comment:
        /**
	  	 * Method to Get SSID
	  	 * 
	  	 * @return String contain SSID
	  	 */

#Code:
        public String getSSID(){
		 if(mWifiManager!=null){
			 return mWifiInfo.getSSID();
			 
		 }
		return null;
	 }

#end
#end
#No. 184981
#File: E:\bishe\1\WifiStatus.java
#Comment:
        /**
	  	 * Method to Get BSSID
	  	 * 
	  	 * @return String contain BSSID
	  	 */

#Code:
        public String getBSSID(){
   		 if(mWifiManager!=null){
   			 return mWifiInfo.getBSSID();
   		 }
   		return null;
   	}

#end
#end
#No. 184982
#File: E:\bishe\1\WifiStatus.java
#Comment:
        /**
	  	 * Method to Get Rssi
	  	 * 
	  	 * @return int contain RSSI
	  	 */

#Code:
        public int getRSSI(){
		 if(mWifiManager!=null){
			 return mWifiInfo.getRssi();
		 }
		return 0;
	 } 

#end
#end
#No. 184983
#File: E:\bishe\1\WifiStatus.java
#Comment:
        /**
	  	 * Method to Get Signal Strength
	  	 * 
	  	 * @return String contain Signal Strength
	  	 */

#Code:
        public String getLinkSpeedUnits(){
		 if(mWifiManager!=null){
			 return WifiInfo.LINK_SPEED_UNITS;
		 }
		return null;
	 } 

#end
#end
#No. 184984
#File: E:\bishe\1\WifiStatus.java
#Comment:
        /**
	  	 * Method to Get Link Speed
	  	 * 
	  	 * @return int contain Link Speed
	  	 */

#Code:
        public int getLinkSpeed(){
		 if(mWifiManager!=null){
			 return mWifiInfo.getLinkSpeed();
		 }
		return 0;
	 } 

#end
#end
#No. 184985
#File: E:\bishe\1\WifiStatus.java
#Comment:
        /**
	  	 * Method to Get Signal Strength
	  	 * 
	  	 * @return int contain Signal Strength
	  	 */

#Code:
        public int getSignalStrength(){
		 if(mWifiManager!=null){
			 return WifiManager.calculateSignalLevel(mWifiInfo.getRssi(), 100);
		 }
		return 0;
	 } 

#end
#end
#No. 184986
#File: E:\bishe\1\WifiStatus.java
#Comment:
       /**
        * Method to Get type of connection used by mobile now
        * 
        * @return String contain TYPE_WIFI,TYPE_MOBILE,TYPE_NOT_CONNECTED
        */

#Code:
        public  String getConnectivityStatus() {
    		ConnectivityManager cm = (ConnectivityManager) mContext
    				.getSystemService(Context.CONNECTIVITY_SERVICE);

    		NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
    		if (null != activeNetwork) {
    			if(activeNetwork.getType() == ConnectivityManager.TYPE_WIFI)
    				return "TYPE_WIFI";
    			
    			if(activeNetwork.getType() == ConnectivityManager.TYPE_MOBILE)
    				return "TYPE_MOBILE";
    		} 
    		return "TYPE_NOT_CONNECTED";
    	}

#end
#end
#No. 184987
#File: E:\bishe\1\WifiStatus.java
#Comment:
        /**
         * Method to Get type of connection used by mobile now
         * 
         * 
         */

#Code:
         public  boolean isDataByWifi() {
     		ConnectivityManager cm = (ConnectivityManager) mContext
     				.getSystemService(Context.CONNECTIVITY_SERVICE);

     		NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
     		if (null != activeNetwork) {
     			if(activeNetwork.getType() == ConnectivityManager.TYPE_WIFI)
     				return true;
      		} 
     		return false;
     	}

#end
#end
#No. 184988
#File: E:\bishe\1\WifiStatus.java
#Comment:
    	/**
    	 * Method to Get wifi Connection Status  
    	 * 
    	 * @return String contain DISABLING,DISABLED,ENABLING,ENABLED,UNKNOWN
    	 */

#Code:
    	public  String getWifiStatus() {
    		String status = null;
    		switch(mWifiManager.getWifiState()) {
    	         case WifiManager.WIFI_STATE_DISABLING:
             		      status ="DISABLING";
	         		      break;
		         case WifiManager.WIFI_STATE_DISABLED:
			              status ="DISABLED";
			              break;
		         case WifiManager.WIFI_STATE_ENABLING:
			              status ="ENABLING";
			              break;
		         case WifiManager.WIFI_STATE_ENABLED:
			              status ="ENABLED";
			              break;
		         case WifiManager.WIFI_STATE_UNKNOWN:
			              status ="UNKNOWN";
			              break;
    	      	}
     		return status;
    	}   

#end
#end
#No. 184989
#File: E:\bishe\1\WifiStatus.java
#Comment:
/**
 * Method to check if wifi on or off or device support wifi or support wifi direct or device conect to ap or internet 
 * and turn on or off wifi
 *  @param stat String : ISON,ON,OFF, TOGGLE,SUPPORT_WIFI, 
 *	    SUPPORT_WIFI_DIRECT,CONECT_AP,CONECT_INTERNET; 
 * @return TRUE OR FALSE
 */

#Code:
   public boolean checkWifi(int state){
	   switch (state){
	   case SUPPORT_WIFI:
		   return isSupportWifi();
	   case SUPPORT_WIFI_DIRECT:
		   return isSupportWifiDirect();
	   case IS_WIFI_ON:
		   return istWifiEnabled();
	   case WIFI_ON:
		   return setWifiEnabled();
	   case WIFI_OFF:
		   return setWifiDisabled();
	   case WIFI_TOGGLE:
		   return wifiToggle();
	   case CONECT_HOTSPOT:
		   return isConnectedToAP();
	   case CONECT_INTERNET:
		   return isConnectedToInternet();
	   case DATA_BY_WIFI:
		   return isDataByWifi();	   
	   default:
		   return false;
	   
	   }
	   
	}   

#end
#end
#No. 184990
#File: E:\bishe\1\WiFiSyncStatus.java
#Comment:
/**
 * List of possible status of sync.
 * 
 * A OK status is a null.
 * 
 * @author Raffaele Ragni <raffaele.ragni@gmail.com>
 */

#Code:
public enum WiFiSyncStatus
{
    UPDATED,
    TO_UPDATE_UPLOAD,
    TO_UPDATE_DOWNLOAD
}

#end
#end
#No. 184991
#File: E:\bishe\1\WifiTransport.java
#Comment:
    /**
     * Queue data for transmission to identifier
     */

#Code:
    private void queueOutgoingData(byte[] data, String identifier) {
        synchronized (outBuffers) {
            if (!outBuffers.containsKey(identifier)) {
                outBuffers.put(identifier, new ArrayDeque<byte[]>());
            }

            int mtu = getMtuForIdentifier(identifier);

            int readIdx = 0;
            while (readIdx < data.length) {

                if (data.length - readIdx > mtu) {
                    ByteArrayOutputStream bos = new ByteArrayOutputStream(mtu);
                    bos.write(data, readIdx, mtu);
                    outBuffers.get(identifier).add(bos.toByteArray());
                    readIdx += mtu;
                } else {
                    outBuffers.get(identifier).add(data);
                    break;
                }
            }

            if (VERBOSE) Timber.d("Queued %d outgoing bytes for %s", data.length, identifier);
            outBuffers.notify();
        }
    }

#end
#end
#No. 184993
#File: E:\bishe\1\WiFiUtils.java
#Comment:
    /**
     * Helper method to decide whether to bypass conference WiFi setup.  Return true if
     * WiFi AP is already configured (WiFi adapter enabled) or WiFi configuration is complete
     * as per shared preference.
     */

#Code:
    public static boolean shouldBypassWiFiSetup(final Context context) {
        final WifiManager wifiManager =
                (WifiManager) context.getSystemService(Context.WIFI_SERVICE);

        // Is WiFi on?
        if (wifiManager.isWifiEnabled()) {
            // Check for existing APs.
            final List<WifiConfiguration> configs = wifiManager.getConfiguredNetworks();
            final String conferenceSSID = String.format("\"%s\"", Config.WIFI_SSID);
            for(WifiConfiguration config : configs) {
                if (conferenceSSID.equalsIgnoreCase(config.SSID)) return true;
            }
        }

        return WIFI_CONFIG_DONE.equals(getWiFiConfigStatus(context));
    }

#end
#end
#No. 184994
#File: E:\bishe\1\WiFiUtils.java
#Comment:
    /**
     * Returns whether we should or should not offer to set up wifi. If asCard == true
     * this will decide whether or not to offer wifi setup actively (as a card, for instance).
     * If asCard == false, this will return whether or not to offer wifi setup passively
     * (in the overflow menu, for instance).
     */

#Code:
    public static boolean shouldOfferToSetupWifi(final Context context, boolean actively) {
        long now = UIUtils.getCurrentTime(context);
        if (now < Config.WIFI_SETUP_OFFER_START) {
            // too early to offer
            return false;
        }
        if (now > Config.CONFERENCE_END_MILLIS) {
            // too late
            return false;
        }
        if (!WiFiUtils.isWiFiEnabled(context)) {
            // no wifi, no offer
            return false;
        }
        if (!PrefUtils.isAttendeeAtVenue(context)) {
            // wifi setup not relevant
            return false;
        }
        if (WiFiUtils.isWiFiApConfigured(context)) {
            // already set up
            return false;
        }
        if (actively && PrefUtils.hasDeclinedWifiSetup(context)) {
            // user said no
            return false;
        }
        return true;
    }



#end
#end
#No. 184997
#File: E:\bishe\1\WikiDatabasePreparation.java
#Comment:
	/**
	 * Gets distance in meters
	 */

#Code:
	public static double getDistance(double lat1, double lon1, double lat2, double lon2){
		double R = 6372.8; // for haversine use R = 6372.8 km instead of 6371 km
		double dLat = toRadians(lat2-lat1);
		double dLon = toRadians(lon2-lon1); 
		double a = Math.sin(dLat/2) * Math.sin(dLat/2) +
		        Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) * 
		        Math.sin(dLon/2) * Math.sin(dLon/2); 
		//double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
		//return R * c * 1000;
		// simplyfy haversine:
		return (2 * R * 1000 * Math.asin(Math.sqrt(a)));
	}

#end
#end
#No. 185002
#File: E:\bishe\1\WikiLoader.java
#Comment:
   /**
    * Visit a block and returns the list of substitutions that must be performed in the visited block. The returned list
    * can be safely modified.
    *
    * @param block the block to visit
    * @param currentSyntaxId the current syntax is
    * @return the substitution list
    */

#Code:
   private List<Substitution> visit(Block block, String currentSyntaxId)
   {
      return visit(block, 0, currentSyntaxId);
   }

#end
#end
#No. 185003
#File: E:\bishe\1\WikipediaExample.java
#Comment:
  /**
   * this will lazily continue searches, making new http calls as necessary.
   *
   * @param wikipedia used to search
   * @param query     see {@link Wikipedia#search(String)}.
   */

#Code:
  static Iterator<Page> lazySearch(final Wikipedia wikipedia, final String query) {
    final Response<Page> first = wikipedia.search(query);
    if (first.nextOffset == null) {
      return first.iterator();
    }
    return new Iterator<Page>() {
      Iterator<Page> current = first.iterator();
      Long nextOffset = first.nextOffset;

      @Override
      public boolean hasNext() {
        while (!current.hasNext() && nextOffset != null) {
          System.out.println("Wow.. even more results than " + nextOffset);
          Response<Page> nextPage = wikipedia.resumeSearch(query, nextOffset);
          current = nextPage.iterator();
          nextOffset = nextPage.nextOffset;
        }
        return current.hasNext();
      }

      @Override
      public Page next() {
        return current.next();
      }

      @Override
      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
  }


#end
#end
#No. 185005
#File: E:\bishe\1\WikipediaSectionFragment.java
#Comment:
    /**
     * Creates a new section header for use in the leftmost column of a GridViewPager
     * @param title section title to display
     * @param image_url optional background image URL
     * @return Fragment to be passed to adapter
     */

#Code:

    public static WikipediaSectionFragment newInstance(String title, String image_url) {
        Bundle bundle = new Bundle();
        bundle.putString("title", title);
        if(image_url == null) image_url = "";
        bundle.putString("image_url", image_url);
        WikipediaSectionFragment f = new WikipediaSectionFragment();
        f.setArguments(bundle);
        return f;
    }

#end
#end
#No. 185010
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * @param model
	 * @return 
	 */

#Code:
	public static boolean captchaValid(CaptchaServiceProxy captchaService, CaptchaCodeModel model) {
		if(model != null && model.reqireCaptcha){
			HttpServletRequest request = WebUtil.getRequest();
			HttpServletResponse response = WebUtil.getResponse();
			String id = request.getSession().getId();
			boolean valid =captchaService.validateReponseForId(id, model.captchaCode);
			if(!valid){
				try {
					//here does not put webcontext - it is fine as GwtSpringController only do endWith() check.
					response.sendRedirect(WikiConstants.URL_CAPTCHA_VERIFIED_ERROR );
				} catch (IOException e) {
					log.error("Redir failed:" + WikiConstants.URL_CAPTCHA_VERIFIED_ERROR,e);
				}
				return false;
			}
		}
		return true;
	}

#end
#end
#No. 185011
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public static User getUser() {
		ServletContext servletCtx = WebUtil.getServletContext();
		User user = null;
		if(servletCtx != null){
			ApplicationContext ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(servletCtx);
			UserReadingService userReadingService = (UserReadingService) ctx.getBean(UserReadingService.SERVICE_NAME);
			user = userReadingService.getUserByName(getUserName());
		}
		if(user == null){
			user = ProxyLoginUtil.getRequester();
		}
		return user;
	}

#end
#end
#No. 185012
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * Some service is called is not inside HttpRequest, such as Indexing, RSS service. They need use this method to get User information.
	 * @param userReadingService
	 * @return
	 */

#Code:
	public static User getUser(UserReadingService userReadingService) {
		
		return userReadingService.getUserByName(getUserName());
	}

#end
#end
#No. 185013
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * @param userService
	 * @return
	 */

#Code:
	public static User getAnonymous() {

		ApplicationContext ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(WebUtil.getServletContext());
		UserReadingService userReadingService = (UserReadingService) ctx.getBean(UserReadingService.SERVICE_NAME);
		return userReadingService.getUserByName(null);
	}

#end
#end
#No. 185014
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * @param userService
	 * @return
	 */

#Code:
	public static User getAnonymous(UserReadingService userReadingService) {
		return userReadingService.getUserByName(null);
	}

#end
#end
#No. 185015
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * @param touchedObject
	 */

#Code:
	public static void setTouchedInfo(UserReadingService userReadingService, TouchedInfo touchedObject) {
		User author = userReadingService.getUserByName(getUserName());
		if(author == null || author.isAnonymous())
			author = null;
		
		Date now = new Date();
		if(touchedObject.getCreatedDate() == null){
			touchedObject.setCreatedDate(now);
			touchedObject.setCreator(author);
		}
		touchedObject.setModifiedDate(now);
		touchedObject.setModifier(author);
		
		if(touchedObject instanceof SensitiveTouchedInfo){
			((SensitiveTouchedInfo)touchedObject).setTouchedDate(now);
		}
	}

#end
#end
#No. 185016
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * @param pageTitle, concat by "+" string
	 * @return, replace  "+" with space
	 */

#Code:
	public static String getPageTitle(String pageUname) {
		if(pageUname == null)
			return "";
		return pageUname.replaceAll("\\+", " ");
	}

#end
#end
#No. 185017
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * Return an unique UUID and initial it in repository. 
	 * @param spacename
	 * @param username
	 * @param password
	 * @param repositoryService
	 * @return
	 * @throws PageException
	 */

#Code:
	public static String createPageUuid(String spacename, String username, String password, RepositoryService repositoryService) throws PageException{
		//DON'T user repository created UUID for future export/import function:
		//always keep page UUID unchanged whatever import to any new database
		//UUID.randomUUID().toString(); - use smaller string to replace 32 length UUID, I test possible duplicated case
		//if it is case sensitive, it is almost impossible duplicated even 50 million. But I have to make to lowerCase 
		// 1 million no duplicate, but 50 million will have 9 duplicate -- this make need make duplciate try-catch check?
		String uuid = RandomStringUtils.randomAlphanumeric(WikiConstants.UUID_KEY_SIZE).toLowerCase();
		try {
			ITicket ticket = repositoryService.login(spacename,username, password);
			repositoryService.createIdentifier(ticket,RepositoryService.TYPE_ATTACHMENT, uuid);
		} catch (RepositoryException e) {
			log.error("Create page UUID failed request from repository :" , e);
			throw new PageException(e);
		} catch (RepositoryTiemoutExcetpion e) {
			log.error("Create page UUID failed request from repository :" , e);
			throw new PageException(e);
		}
		
		return uuid;
	}


#end
#end
#No. 185019
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * return format "/context/page#token"
	 * This URL can used in server side code to redirect to page. 
	 * @return
	 */

#Code:
	public static String getPageRelativeTokenURL(String spaceUname, String pageTitle, String anchor) {
		StringBuffer redir = new StringBuffer(WebUtil.getWebConext());
		if(!StringUtils.isBlank(spaceUname)){
			//if URL is page.do?s=spaceUname&p=pageTitle, convert this URL
			//to ajax token URL /page#/spaceUname/pageTitle#anchor
			redir.append(SharedConstants.URL_PAGE).append("#");
			try {
				//page#/xxx - xxx must do URLEncode otherwise it will broken URL even its value in anchor part
				redir.append(URLEncoder.encode(GwtUtils.getSpacePageToken(spaceUname,pageTitle),Constants.UTF8));
				if(!StringUtils.isBlank(anchor)){
					redir.append(URLEncoder.encode("#"+EscapeUtil.escapeToken(anchor),Constants.UTF8));
				}
			} catch (UnsupportedEncodingException e1) {
				log.error("URL encode error", e1);
			}
		}
		return redir.toString();
	}




#end
#end
#No. 185023
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * This page return URL according to given parameters and could produce one of below format URL:
	 *  <li>/context/page(view)/spaceUname/pageTitle/anchor  - This is normal case if all spaceUname, pageTitle and anchor don't have invalid characters</li>
	 *  <li>/context/p(v)/pageUuid/anchor  - if any invalid characters and pageUuid is not blank</li>
	 * @return
	 */

#Code:
	private static String getFullURL(String hostURL, String urlStartWith, String spaceUname, String pageTitle, String pageUuid, String anchor) {
		
		if(StringUtils.isBlank(spaceUname))
			return hostURL;
		

		try{
			if((GwtUtils.isSupportInURL(pageTitle) && GwtUtils.isSupportInURL(spaceUname))
					//if page not exist, pageUuid is null, it becomes impossible to give tinyURL format. Then always give meaning URL 
				||StringUtils.isBlank(pageUuid)){
				if(StringUtils.isBlank(pageTitle)){ 
					//home page
					return  hostURL+urlStartWith+"/" +URLEncoder.encode(spaceUname,Constants.UTF8);
				}else{
					//normal url p/spaceUname/pageTitle
					return  hostURL+urlStartWith+"/"+URLEncoder.encode(spaceUname,Constants.UTF8)
							+"/"+ URLEncoder.encode(pageTitle,Constants.UTF8) 
							+ (StringUtils.isBlank(anchor)?"":("/"+anchor));
				}
			}else{
				// tinyURL: /v/pageUuid or p/pageUuid 
				return  hostURL+(urlStartWith.equals(SharedConstants.URL_VIEW)?SharedConstants.URL_TINY_VIEW:SharedConstants.URL_TINY_PAGE)
						+"/"+ pageUuid + (StringUtils.isBlank(anchor)?"":("/"+anchor));
			}
		}catch(UnsupportedEncodingException e){
			log.error("Failed to encode URL",e);
		}
		
		return hostURL;
	}

#end
#end
#No. 185024
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * @param user
	 * @return
	 */

#Code:
	public static boolean isUsingRichEditor(User user) {
		UserSetting setting = user.getSetting();
		
		return setting.isUsingRichEditor();
	}

#end
#end
#No. 185025
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * GWT use anchor to do ajax call. such as #token.
	 * Basically, this is same with javascript location.href=token. location.href will do encoding to token. 
	 * But this encoding has some different with URL encoding. This method will encode string to location.href encoding  
	 * 
	 * Normally,Different list<br>
	 * Space: URL=+ ; Anchor=%20
	 * 
	 * But system use special entity replace to replace some keywords, include +.
	 * 
	 * @param token
	 * @return
	 */

#Code:
	public static String encodeURL(String token) {
		try {
			//replace token keyword #,@,>,+ etc to entity
			token = EscapeUtil.escapeToken(token);
			token = URLEncoder.encode(token, Constants.UTF8);
		} catch (UnsupportedEncodingException e) {
			WebUtil.log.error("Encode token failed.",e);
		}
		return token;
	}

#end
#end
#No. 185026
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * Get unique key which no newline inside.
	 * @param htmlText
	 * @return
	 */

#Code:
	public static String findUniqueKey(String htmlText) {
		return findUniqueKey(htmlText,false, false);
	}

#end
#end
#No. 185027
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * Get an unique string from given html. It means indexOf(htmlText) will always return -1. 
	 * 
	 * @param htmlText
	 * @param multipleLines -- put newline(\n) into returned key.
	 * @param newlineAtEnd -- only multipleLines is true, this flag is useful. If true, it puts newline end of key, 
	 * 						otherwise, put newline as first character of key
	 * @return
	 */

#Code:
	public static String findUniqueKey(String htmlText, boolean multipleLines, boolean newlineAtEnd) {
		//please note, if multipleLines flag is true, the unique part should be the part which does not include newline.
		//this scenario: some multipleLines key may be trimmed during markup render process. this means, so we may try to 
		//use unique part rather than whole key part as parameter in String.index(). See MarkupRenderEngineImpl.processObjects().
		String key, uniquePart;
		do  {
			key = RandomStringUtils.randomAlphanumeric(WikiConstants.UUID_KEY_SIZE);
			uniquePart = key;
			if(multipleLines){
				char[] bk = key.toCharArray();
				if(newlineAtEnd){
					//replace last character, this is requirement of NewlineFilter, which will detect \n is belong to unique key or not
					bk[bk.length-1] = '\n';
					uniquePart = new String(bk,0,bk.length-1);
				}else{
					bk[0] = '\n';
					uniquePart = new String(bk,1,bk.length-1);
				}
				key = new String(bk);
			}
		}while(htmlText != null && htmlText.indexOf(uniquePart) != -1);

		return key;
	}

#end
#end
#No. 185028
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * @param page
	 * @return
	 */

#Code:
	public static boolean isHomepage(AbstractPage page) {
		return page.equals(page.getSpace().getHomepage());
	}

#end
#end
#No. 185029
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * @return System administrator notification web page URL
	 */

#Code:
	public static String getSystemAdminTokenLink() {
		return new StringBuffer(WebUtil.getHostAppURL()).append(SharedConstants.URL_PAGE).append("#")
		.append(GwtUtils.getCPageToken(SharedConstants.CPAGE_SYSADMIN_NOTIFY)).toString();
	}

#end
#end
#No. 185030
#File: E:\bishe\1\WikiUtil.java
#Comment:
	/**
	 * @param page
	 * @return
	 */

#Code:
	public static String getAdsenseHTML(String spaceUname, Page page) {
		String root = DataRoot.getDataRoot();
		if(FileUtil.exist(root+"ad.html")){
			//This is a trick, allow user put external HTML to display AD
			try {
				File adfile = FileUtil.getFile(root+"ad.html");
				return FileUtils.readFileToString(adfile);
			} catch (IOException e) {
				log.error("Unable to read ad.html", e);
			}
		}
		String viewURL = getFullURL(WebUtil.getHostAppURL(), SharedConstants.URL_VIEW, spaceUname, page.getTitle(), page.getPageUuid(), null);
		return new StringBuffer("<iframe id=\"googlead\" name=\"googlead\" src=\"")
				.append(viewURL)
				.append("\"  width=\"100%\" height=\"92\" scrolling=\"no\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\"></iframe>").toString();
	}


#end
#end
#No. 185032
#File: E:\bishe\1\WiktionaryEdition.java
#Comment:
	/** @throws IllegalStateException if the connection has already been 
	 * 		closed. This method is to be called from each retrieval method.  */

#Code:
	protected void ensureOpen() {
		if (isClosed)
			throw new IllegalStateException("Wiktionary was already closed.");
	}

#end
#end
#No. 185033
#File: E:\bishe\1\WiktionaryEntryParser.java
#Comment:
	/** Check if the specified text is a redirect and set the redirect target of 
	 *  the given Wiktionary page. */

#Code:
	protected boolean checkForRedirect(final WiktionaryPage page, 
			final String text) {
		if (text.endsWith("]]") && text.startsWith(redirectTemplate)) {
			page.setRedirectTarget(text.substring(redirectTemplate.length(),
					text.length() - 2));
			//System.err.println("REDIRECT " + page.getTitle() + " -> " + page.getRedirectTarget());
			return true;
		} else
			return false;
	}

#end
#end
#No. 185034
#File: E:\bishe\1\WiktionarySenseFilter.java
#Comment:
/**
 * Default implementation of the {@link IWiktionarySenseFilter} interface
 * which inherits all filter options of the {@link WiktionaryEntryFilter}
 * @author Christian M. Meyer
 */

#Code:
public class WiktionarySenseFilter extends WiktionaryEntryFilter 
		implements IWiktionarySenseFilter {
	
	/** Initializes a page filter without any filter restrictions. */
	public WiktionarySenseFilter() {
		super();		
	}
			
	public boolean accept(final IWiktionarySense sense) {
		if (!accept(sense.getEntry()))
			return false;
		
		return true;
	}
	
}

#end
#end
#No. 185035
#File: E:\bishe\1\WilcoxonAnalysis.java
#Comment:
	/**
	 * Class for doing a Wilcoxon signed rank analysis
	 * Expects a semicolon (;) separated file with first row being names, and all next rows being samples
	 * Each column is expected to be a different test
	 */

#Code:
	public WilcoxonAnalysis(String filename, int samples, int tests) throws Exception
	{
		File f = new File(filename);
		@SuppressWarnings("resource")
		BufferedReader reader = new BufferedReader(new FileReader(f));

		statsResults = new StatsResult[tests];
		
		String line = reader.readLine();
		String[] names = line.split(";");
		if (tests != names.length) throw new IllegalArgumentException("tests != names.length");
		for (int i = 0; i < names.length; i++)
		{
			statsResults[i] = new StatsResult(names[i], samples);
		}
	
		line = reader.readLine();
		int i = 0;
		while (line != null)
		{
			String[] values = line.split(";");
			if (tests != values.length) throw new IllegalArgumentException("tests != values.length");
			for (int j = 0; j < values.length; j++)
			{
				statsResults[j].values[i] = Double.parseDouble(values[j]);
			}
			i++;
			line = reader.readLine();
		}
		reader.close();
		System.out.println("Data loaded!");
		
	}

#end
#end
#No. 185036
#File: E:\bishe\1\WilcoxonAnalysis.java
#Comment:
	/**
	 * @param args
	 */

#Code:
	public static void main(String[] args) throws Exception {
		WilcoxonAnalysis x = new WilcoxonAnalysis("Mario stats data2.csv", 100, 64);
		x.FindUCTWinning();
		for (int i = 0; i < 64; i++)
			x.WilcoxonSignedRankTest(Comparison.UCT, i);

		for (int i = 0; i < 64; i++)
			x.WilcoxonSignedRankTest(Comparison.Winning, i);
	}

#end
#end
#No. 185037
#File: E:\bishe\1\WildCard.java
#Comment:
/**
 * Wildcards
 *
 * @author batiaev
 * @since 19/06/15
 */

#Code:
public enum WildCard {
    ZeroMore("^"),
    OneMore("*"),
    ZeroMorePriority("#"),
    OneMorePriority("_");

    private final String sumbol;

    WildCard(String sumbol) {
        this.sumbol = sumbol;
    }

    public String get() {
        return sumbol;
    }
}
#end
#end
#No. 185038
#File: E:\bishe\1\WildcardPermission.java
#Comment:
  /**
   * URI is a a special case. For URI's, /a implies /a/b.
   * Therefore the test is "/a/b".startsWith("/a");
   */

#Code:
  @VisibleForTesting
  protected static boolean impliesURI(String policy, String request) {
    try {
      URI policyURI = new URI(new StrSubstitutor(System.getProperties()).replace(policy));
      URI requestURI = new URI(request);
      if(policyURI.getScheme() == null || policyURI.getPath() == null) {
        LOGGER.warn("Policy URI " + policy + " is not valid. Either no scheme or no path.");
        return false;
      }
      if(requestURI.getScheme() == null || requestURI.getPath() == null) {
        LOGGER.warn("Request URI " + request + " is not valid. Either no scheme or no path.");
        return false;
      }
      // schemes are equal &&
      // request path does not contain relative parts /a/../b &&
      // request path starts with policy path &&
      // authorities (nullable) are equal
      String requestPath = requestURI.getPath() + File.separator;
      String policyPath = policyURI.getPath() + File.separator;
      if(policyURI.getScheme().equals(requestURI.getScheme()) &&
          requestURI.getPath().equals(new URI(request).normalize().getPath()) &&
          requestPath.startsWith(policyPath) &&
          Strings.nullToEmpty(policyURI.getAuthority()).equals(Strings.nullToEmpty(requestURI.getAuthority()))) {
        return true;
      }
      return false;
    } catch (URISyntaxException e) {
      LOGGER.warn("Request URI " + request + " is not a URI", e);
      return false;
    }
  }

#end
#end
#No. 185039
#File: E:\bishe\1\WildcardTypeName.java
#Comment:
  /**
   * Returns a type that represents an unknown type that extends {@code bound}. For example, if
   * {@code bound} is {@code CharSequence.class}, this returns {@code ? extends CharSequence}. If
   * {@code bound} is {@code Object.class}, this returns {@code ?}, which is shorthand for {@code
   * ? extends Object}.
   */

#Code:
  public static WildcardTypeName subtypeOf(TypeName upperBound) {
    return new WildcardTypeName(Arrays.asList(upperBound), Collections.<TypeName>emptyList());
  }

#end
#end
#No. 185040
#File: E:\bishe\1\WildcardTypeName.java
#Comment:
  /**
   * Returns a type that represents an unknown supertype of {@code bound}. For example, if {@code
   * bound} is {@code String.class}, this returns {@code ? super String}.
   */

#Code:
  public static WildcardTypeName supertypeOf(TypeName lowerBound) {
    return new WildcardTypeName(Arrays.<TypeName>asList(OBJECT), Arrays.asList(lowerBound));
  }

#end
#end
#No. 185041
#File: E:\bishe\1\WildFlyTestRunner.java
#Comment:
    /**
     * Creates a BlockJUnit4ClassRunner to run {@code clazz}
     *
     * @throws org.junit.runners.model.InitializationError if the test class is malformed.
     */

#Code:
    public WildFlyTestRunner(Class<?> clazz) throws InitializationError {
        super(clazz);

    }

#end
#end
#No. 185042
#File: E:\bishe\1\WillPassivate.java
#Comment:
/**
 * Qualifies observer method parameters to select events that fire when HTTP sessions are passivated.
 * <p/>
 * The event parameter is an {@link javax.servlet.http.HttpSession}
 *
 * @author Nicklas Karlsson
 */

#Code:
@Qualifier
@Target({FIELD, PARAMETER})
@Retention(RUNTIME)
@Documented
public @interface WillPassivate {
}
}

#end
#end
#No. 185043
#File: E:\bishe\1\Win.java
#Comment:
/**
 * Indicates that the annotated code is win. For example:
 * <p/>
 * <pre>
 *   &#064;Win(Outcome.INCONCEIVABLE)
 *   public class BaconExplosion {
 * </pre>
 */

#Code:
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Visionary("Hanneli")
public @interface Win {
    Outcome value() default Outcome.EPIC;
}
#end
#end
#No. 185045
#File: E:\bishe\1\Win32Executor.java
#Comment:
	/**
	 * Execute a command like a OS native script. This a method used by the
	 * Executor class in order to provide some facilities provided by shell. For
	 * example, wild cards expansion.
	 * 
	 * @param command The command must be executed
	 * @param dirName The directory where the execution will be started.
	 * @return The result (stdout and stderr) of the command execution
	 * @throws ExecutorException If the execution could not be performed.
	 */

#Code:
	public ExecutorHandle execute( String dirName, String command ) throws ExecutorException {
		return execute( dirName, command, new LinkedHashMap() );
	}

#end
#end
#No. 185046
#File: E:\bishe\1\Win32Executor.java
#Comment:
	/**
	 * This method is responsible to convert some linux variables and separators
	 * styles to Windows' ones
	 * 
	 * @param inn String containing the text that should be processed and if
	 *        necessary converted to windows style
	 * @return The string converted for windows' format
	 */

#Code:

	public static String convert2WinStyle( String inn ) {
		StringBuffer sb = new StringBuffer( inn );
		Pattern p = Pattern.compile( "\\${1}[1-9a-zA-Z]+" );
		Matcher m = p.matcher( inn );
		int increased = 0;
		while ( m.find() ) {
			sb.replace( m.start() + increased, m.start() + increased + 1, "%" );
			sb.insert( m.end() + increased, "%" );
			increased++;
		}
		return sb.toString().replace( '/', '\\' );
		// TODO Verify if we should also do replace(':',';')
	}

#end
#end
#No. 185047
#File: E:\bishe\1\Win32Executor.java
#Comment:
	/**
	 * Adds a process into the set of the ones which results were not collected
	 * yet.
	 * 
	 * @param handle The handle for the process
	 * @param process The process to be included at the group
	 */

#Code:
	protected synchronized void includeInProcesses( ExecutorHandle handle, Process process ) {
		getHandleEntries().put( handle, new HandleEntry(handle, process, "") );
	}

#end
#end
#No. 185048
#File: E:\bishe\1\Win32Executor.java
#Comment:
	/**
	 * This method manage the handles issued for each command execution
	 * 
	 * @return A handle to be used by the client to identify its execution
	 */

#Code:
	protected synchronized ExecutorHandle getNextHandle( ) {

		/** Produce a new handle */
		IntegerExecutorHandle newHandle = new IntegerExecutorHandle( nextHandle );

		/** Increment the handle pointer */
		this.nextHandle++;

		return newHandle;
	}




#end
#end
#No. 185053
#File: E:\bishe\1\Win32PrintJob.java
#Comment:
    /**
     * updates a Paper object to reflect the current printer's selected
     * paper size and imageable area for that paper size.
     * Default implementation copies settings from the original, applies
     * applies some validity checks, changes them only if they are
     * clearly unreasonable, then sets them into the new Paper.
     * Subclasses are expected to override this method to make more
     * informed decisons.
     */

#Code:
    protected void validatePaper(Paper origPaper, Paper newPaper) {
        if (origPaper == null || newPaper == null) {
            return;
        } else {
            double wid = origPaper.getWidth();
            double hgt = origPaper.getHeight();
            double ix = origPaper.getImageableX();
            double iy = origPaper.getImageableY();
            double iw = origPaper.getImageableWidth();
            double ih = origPaper.getImageableHeight();

            /* Assume any +ve values are legal. Overall paper dimensions
             * take precedence. Make sure imageable area fits on the paper.
             */
            Paper defaultPaper = new Paper();
            wid = ((wid > 0.0) ? wid : defaultPaper.getWidth());
            hgt = ((hgt > 0.0) ? hgt : defaultPaper.getHeight());
            ix = ((ix > 0.0) ? ix : defaultPaper.getImageableX());
            iy = ((iy > 0.0) ? iy : defaultPaper.getImageableY());
            iw = ((iw > 0.0) ? iw : defaultPaper.getImageableWidth());
            ih = ((ih > 0.0) ? ih : defaultPaper.getImageableHeight());
            /* full width/height is not likely to be imageable, but since we
             * don't know the limits we have to allow it
             */
            if (iw > wid) {
                iw = wid;
            }
            if (ih > hgt) {
                ih = hgt;
            }
            if ((ix + iw) > wid) {
                ix = wid - iw;
            }
            if ((iy + ih) > hgt) {
                iy = hgt - ih;
            }
            newPaper.setSize(wid, hgt);
            newPaper.setImageableArea(ix, iy, iw, ih);
        }
    }

#end
#end
#No. 185054
#File: E:\bishe\1\Win32PrintJob.java
#Comment:
    /**
     * Checks whether a certain attribute value is valid for the current print service
     * @param attrval the attribute value 
     * @param attrset Set of printing attributes for a supposed job (both job-level attributes and document-level attributes), or null.
     * @return true if valid
     */

#Code:
    protected boolean isSupportedValue(Attribute attrval, PrintRequestAttributeSet attrset) {
    	return (attrval != null && service != null && service.isAttributeValueSupported(attrval, DocFlavor.SERVICE_FORMATTED.PAGEABLE, attrset));
    }

#end
#end
#No. 185055
#File: E:\bishe\1\Win32PrintJob.java
#Comment:
    /**
     * Converts the Java 1/72 inch to .NET 1/100 inch
     * @param javaLength the java length in 1/72 inch
     * @return the .NET length in 1/100 inch
     */

#Code:
    private static int java2netLength( int javaLength ){
    	return (int) Math.round( (double)(javaLength * 100) / 72d );
    }

#end
#end
#No. 185056
#File: E:\bishe\1\Win32PrintJob.java
#Comment:
    /**
     * Converts the Java 1/72 inch to .NET 1/100 inch
     * @param javaLength the java length in 1/72 inch
     * @return the .NET length in 1/100 inch
     */

#Code:
    private static int java2netLength( double javaLength ){
    	return (int) Math.round( (javaLength * 100) / 72d );
    }


#end
#end
#No. 185058
#File: E:\bishe\1\Win32PrintService.java
#Comment:
    /*  it turns out to be inconvenient to store the other categories
     *  separately because many attributes are in multiple categories.
     */

#Code:
    private static Class[] otherAttrCats = {
        JobName.class,
        RequestingUserName.class,
        Copies.class,
        Destination.class,
        OrientationRequested.class,
        PageRanges.class,
        Media.class,
        MediaPrintableArea.class,
        Fidelity.class,
        // We support collation on 2D printer jobs, even if the driver can't.
        SheetCollate.class,
        SunAlternateMedia.class,
        Chromaticity.class
    };

#end
#end
#No. 185059
#File: E:\bishe\1\Win32PrintService.java
#Comment:
    /**
     * Tries to find a matching {@link MediaSizeName} for a paper by it's size
     * @param paper
     * @return
     */

#Code:
    private MediaSizeName findMatchingMedia( PaperSize paper ){
    	if( paper.get_RawKind() > 0 && paper.get_RawKind() <= MEDIA_NAMES.length ){
    		// match to predefined size
    		return MEDIA_NAMES[ paper.get_RawKind() - 1 ];
    	}
    	int x = paper.get_Width() * INCH100_TO_MYM;
    	int y = paper.get_Height() * INCH100_TO_MYM;
    	if( x > y ){ // MediaSizes are always portrait!
    		int tmp = x;
    		x = y;
    		y = tmp;
    	}
    	for( MediaSizeName name : MEDIA_NAMES ){
    		MediaSize media = MediaSize.getMediaSizeForName(name);
    		if( media != null ){
    			if( Math.abs( x - media.getX(1) ) < MATCH_DIFF && Math.abs( y - media.getY(1) ) < MATCH_DIFF ){
    				return name;
    			}
    		}
    	}
    	return null;
    }

#end
#end
#No. 185060
#File: E:\bishe\1\Win32PrintService.java
#Comment:
    /**
     * Returns the Java-default {@link MediaTray} for a paper source. This is required since these default
     * trays are public constants which can be used without checking for the actually present media trays 
     * @param source the .NET paper source to get the predefined source for
     * @return the media tray or null, in case there is no mapping for the paper source
     */

#Code:
    private MediaTray getDefaultTray( PaperSource source ){
    	// convert from .NET kind to java's pre defined MediaTrays
    	switch( source.get_RawKind() ){
    		case 1 : return MediaTray.TOP;
    		case 2 : return MediaTray.BOTTOM;
    		case 3 : return MediaTray.MIDDLE;
    		case 4 : return MediaTray.MANUAL;
    		case 5 : return MediaTray.ENVELOPE;
    		case 6 : return Win32MediaTray.ENVELOPE_MANUAL;
    		case 7 : return Win32MediaTray.AUTO;
    		case 8 : return Win32MediaTray.TRACTOR;
    		case 9 : return Win32MediaTray.SMALL_FORMAT;
    		case 10 : return Win32MediaTray.LARGE_FORMAT;
    		case 11 : return MediaTray.LARGE_CAPACITY;
    		case 14 : return MediaTray.MAIN;
    		case 15 : return Win32MediaTray.FORMSOURCE;
    		// FIXME which PaperSourceKind is MediaTray.SIDE ???
    	}
    	return null;
    }

#end
#end
#No. 185061
#File: E:\bishe\1\Win32PrintService.java
#Comment:
    /**
     * Returns the .NET {@link PaperSource} for a media tray. This will be done either by mapping or
     * directly in case the tray is a {@link NetMediaTray}
     * @param tray the tray to get the paper source for, must not be null
     * @return the selected {@link PaperSource} or null, in case there is no matching {@link PaperSource}
     */

#Code:
    public PaperSource getPaperSourceForTray( MediaTray tray ){
    	if( tray instanceof NetMediaTray ){
			return ((NetMediaTray)tray).getPaperSource( this );
		}
    	// try to find the appropriate paper source for the Java-Defined tray
    	PaperSourceCollection trays = settings.get_PaperSources();
    	int count = trays.get_Count();
    	for( int i=0; i < count; i++ ){
    		PaperSource paperSource = trays.get_Item(i);
			if( getDefaultTray( paperSource ) == tray ){
    			return paperSource;
    		}
    	}
    	return null;
    }




#end
#end
#No. 185064
#File: E:\bishe\1\Win32PrintServiceLookup.java
#Comment:
    /*
     * return empty array as don't support multi docs
     */

#Code:
    public MultiDocPrintService[]
        getMultiDocPrintServices(DocFlavor[] flavors,
                                 AttributeSet attributes) {
        SecurityManager security = System.getSecurityManager();
        if (security != null) {
          security.checkPrintJobAccess();
        }
        return new MultiDocPrintService[0];
    }

#end
#end
#No. 185065
#File: E:\bishe\1\Win32Utils.java
#Comment:
    /**
     * Determines the location of the AppData/Roaming folder
     */

#Code:
    public static String determineAppDataDir()
    {
        String appDataDir = null;

        // Modified from http://stackoverflow.com/questions/5953149/detect-the-location-of-appdata-locallow-with-jna
        final PointerByReference ppszPath = new PointerByReference();

        int hResult = Shell32.INSTANCE.SHGetKnownFolderPath(
                Shell32.FOLDERID_RoamingAppData,
                Shell32.KF_FLAG_CREATE, null, ppszPath);

        if (Shell32.S_OK == hResult) {
            try {
                appDataDir = nullTerminatedToString(ppszPath);
            } finally {
                Ole32.INSTANCE.CoTaskMemFree(ppszPath.getValue());
            }
        } else {
            logger.log(Level.SEVERE, null, "Could not determine local application data directory: " + hResult);
        }

        return appDataDir;
    }

#end
#end
#No. 185066
#File: E:\bishe\1\Win32Utils.java
#Comment:
    /**
     * Convert a Win32 string into a Java string.
     *
     * @param ppszPath pointer to the string to convert.
     */

#Code:
    public static String nullTerminatedToString(PointerByReference ppszPath) {
        char delim = '\0';
        char[] chars = ppszPath.getValue().getCharArray(0, Shell32.MAX_PATH);
        int charIdx;

        for (charIdx = 0; charIdx < chars.length; charIdx++) {
            if (chars[charIdx] == delim) {
                break;
            }
        }

        return new String(chars, 0, charIdx);
    }



#end
#end
#No. 185072
#File: E:\bishe\1\WindowAutorouteDetailParameter.java
#Comment:
    /**
     * Recalculates all displayed values
     */

#Code:
    public void refresh()
    {
        interactive.AutorouteSettings settings = this.board_handling.settings.autoroute_settings;
        board.LayerStructure layer_structure = this.board_handling.get_routing_board().layer_structure;
        this.via_cost_field.setValue(settings.get_via_costs());
        this.plane_via_cost_field.setValue(settings.get_plane_via_costs());
        this.start_ripup_costs.setValue(settings.get_start_ripup_costs());
        this.start_pass_no.setValue(settings.get_pass_no());
        for (int i = 0; i < preferred_direction_trace_cost_arr.length; ++i)
        {
            this.preferred_direction_trace_cost_arr[i].setValue(settings.get_preferred_direction_trace_costs(layer_structure.get_layer_no(i)));
        }
        for (int i = 0; i < against_preferred_direction_trace_cost_arr.length; ++i)
        {
            this.against_preferred_direction_trace_cost_arr[i].setValue(settings.get_against_preferred_direction_trace_costs(layer_structure.get_layer_no(i)));
        }
    }

#end
#end
#No. 185073
#File: E:\bishe\1\WindowCache.java
#Comment:
    /**
     * Returns whether the window corresponding to the class and id exists in
     * the {@link #sWindows} cache.
     *
     * @param id  The id representing the window.
     * @param cls Class corresponding to the window.
     * @return True if the window corresponding to the class and id exists in
     * the cache, or false if it does not exist.
     */

#Code:
    public boolean isCached(int id, Class<? extends StandOutWindow> cls) {
        return getCache(id, cls) != null;
    }

#end
#end
#No. 185074
#File: E:\bishe\1\WindowCache.java
#Comment:
    /**
     * Returns the window corresponding to the id from the {@link #sWindows}
     * cache.
     *
     * @param id  The id representing the window.
     * @param cls The class of the implementation of the window.
     * @return The window corresponding to the id if it exists in the cache, or
     * null if it does not.
     */

#Code:
    public Window getCache(int id, Class<? extends StandOutWindow> cls) {
        SparseArray<Window> l2 = sWindows.get(cls);
        if (l2 == null) {
            return null;
        }

        return l2.get(id);
    }

#end
#end
#No. 185075
#File: E:\bishe\1\WindowCache.java
#Comment:
    /**
     * Add the window corresponding to the id in the {@link #sWindows} cache.
     *
     * @param id     The id representing the window.
     * @param cls    The class of the implementation of the window.
     * @param window The window to be put in the cache.
     */

#Code:
    public void putCache(int id, Class<? extends StandOutWindow> cls, Window window) {
        SparseArray<Window> l2 = sWindows.get(cls);
        if (l2 == null) {
            l2 = new SparseArray<Window>();
            sWindows.put(cls, l2);
        }

        l2.put(id, window);
    }

#end
#end
#No. 185076
#File: E:\bishe\1\WindowCache.java
#Comment:
    /**
     * Remove the window corresponding to the id from the {@link #sWindows}
     * cache.
     *
     * @param id  The id representing the window.
     * @param cls The class of the implementation of the window.
     */

#Code:
    public void removeCache(int id, Class<? extends StandOutWindow> cls) {
        SparseArray<Window> l2 = sWindows.get(cls);
        if (l2 != null) {
            l2.remove(id);
            if (l2.size() == 0) {
                sWindows.remove(cls);
            }
        }
    }

#end
#end
#No. 185077
#File: E:\bishe\1\WindowCache.java
#Comment:
    /**
     * Returns the size of the {@link #sWindows} cache.
     *
     * @param cls The class of the implementation of the window.
     * @return True if the cache corresponding to this class is empty, false if
     * it is not empty.
     */

#Code:
    public int getCacheSize(Class<? extends StandOutWindow> cls) {
        SparseArray<Window> l2 = sWindows.get(cls);
        if (l2 == null) {
            return 0;
        }

        return l2.size();
    }

#end
#end
#No. 185078
#File: E:\bishe\1\WindowCache.java
#Comment:
    /**
     * Returns the ids in the {@link #sWindows} cache.
     *
     * @param cls The class of the implementation of the window.
     * @return The ids representing the cached windows.
     */

#Code:
    public Set<Integer> getCacheIds(Class<? extends StandOutWindow> cls) {
        SparseArray<Window> l2 = sWindows.get(cls);
        if (l2 == null) {
            return new HashSet<Integer>();
        }

        Set<Integer> keys = new HashSet<Integer>();
        for (int i = 0; i < l2.size(); i++) {
            keys.add(l2.keyAt(i));
        }
        return keys;
    }

#end
#end
#No. 185079
#File: E:\bishe\1\WindowCompat.java
#Comment:
    /**
     * Flag for specifying the behavior of action modes when an Action Bar is not present.
     * If overlay is enabled, the action mode UI will be allowed to cover existing window content.
     */

#Code:
    public static final int FEATURE_ACTION_MODE_OVERLAY = 10;
}
}

#end
#end
#No. 185080
#File: E:\bishe\1\WindowDuration.java
#Comment:
	/**
	 * <p>Constructor for WindowDuration.</p>
	 *
	 * @param duration a int.
	 */

#Code:
	public WindowDuration(final int duration) {
		this.duration = duration;
	}


#end
#end
#No. 185082
#File: E:\bishe\1\WindowFeatures.java
#Comment:
/**
 * <p>Used to annotate an {@link IckleActivity} with <i>Window 
 * Feature</i> metadata using the constants declared in {@link Window}.</p>
 * 
 * @version 1.0.0
 * <br><br>
 * @author <a href="mailto:lahiru@lonepulse.com">Lahiru Sahan Jayasinghe</a>
 */

#Code:
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface WindowFeatures {

	/**
	 * <p>The array of {@code int}s containing the IDs of the 
	 * <i>window features</i> to be applied. These constants 
	 * can be found in {@link Window}.</p>
	 * 
	 * <p>Empty by default.</p>
	 * 
	 * @return the constant {@code int} IDs representing the  
	 * 		   {@link Window} features to be used.
	 * <br><br>
	 * @since 1.0.0
	 */
	int[] value() default {};
}

#end
#end
#No. 185083
#File: E:\bishe\1\WindowFunctions.java
#Comment:
	/**
	 * Creates a Blackman Window.
	 * Code from https://www.ee.columbia.edu/~ronw/code/MEAPsoft/doc/html/FFT_8java-source.html
	 * All credit goes to the original authors!
	 *
	 * @param ntabs number of samples
	 * @return window samples
	 */

#Code:
	public static float[] makeBlackmanWindow(int ntabs) {
		// Make a blackman window:
		// w(n)=0.42-0.5cos{(2*PI*n)/(N-1)}+0.08cos{(4*PI*n)/(N-1)};
		float[] window = new float[ntabs];
		for (int i = 0; i < window.length; i++)
			window[i] = 0.42f - 0.5f * (float)Math.cos(2 * Math.PI * i / (ntabs - 1))
					+ 0.08f * (float)Math.cos(4 * Math.PI * i / (ntabs - 1));
		return window;
	}

#end
#end
#No. 185084
#File: E:\bishe\1\WindowHandler.java
#Comment:
    /**
     * @return Returns the sizePreferred.
     */

#Code:
    public Dimension getSizePreferred() {
        return sizePreferred;
    }

#end
#end
#No. 185085
#File: E:\bishe\1\WindowHandler.java
#Comment:
    /**
     * @return Returns the persistLocation.
     */

#Code:
    public boolean isPersistLocation() {
        return persistLocation;
    }

#end
#end
#No. 185086
#File: E:\bishe\1\WindowHandler.java
#Comment:
    /**
     * @return Returns the persistSize.
     */

#Code:
    public boolean isPersistSize() {
        return persistSize;
    }

#end
#end
#No. 185087
#File: E:\bishe\1\WindowHandler.java
#Comment:
    /**
     * @param persistLocation The persistLocation to set.
     */

#Code:
    public void setPersistLocation(boolean persistLocation) {
        this.persistLocation = persistLocation;
    }

#end
#end
#No. 185088
#File: E:\bishe\1\WindowHandler.java
#Comment:
    /**
     * @param persistSize The persistSize to set.
     */

#Code:
    public void setPersistSize(boolean persistSize) {
        this.persistSize = persistSize;
    }

#end
#end
#No. 185089
#File: E:\bishe\1\WindowHandler.java
#Comment:
    /**
     * @param sizePreferred The sizePreferred to set.
     */

#Code:
    public void setSizePreferred(Dimension sizePreferred) {
        this.sizePreferred = sizePreferred;
        locationRestore();
    }

#end
#end
#No. 185090
#File: E:\bishe\1\WindowHandler.java
#Comment:
    /**
     * 
     * @see java.awt.event.WindowAdapter#windowClosing(java.awt.event.WindowEvent)
     */

#Code:
    public void windowClosing(WindowEvent e) {
        close();
    }



#end
#end
#No. 185092
#File: E:\bishe\1\WindowHelper.java
#Comment:
    /**
     * get current window rotation
     *
     * @param activity activity
     * @return int {@link Surface#ROTATION_0}: 0; {@link Surface#ROTATION_90}: 90;
     * {@link Surface#ROTATION_180}: 180; {@link Surface#ROTATION_270}: 270
     */

#Code:
    public static int getDisplayRotation(Activity activity) {
        switch (activity.getWindowManager().getDefaultDisplay().getRotation()) {
            case Surface.ROTATION_0:
                return 0;
            case Surface.ROTATION_90:
                return 90;
            case Surface.ROTATION_180:
                return 180;
            case Surface.ROTATION_270:
                return 270;
            default:
                return 0;
        }
    }

#end
#end
#No. 185093
#File: E:\bishe\1\WindowHelper.java
#Comment:
    /**
     * whether current window is landscape
     *
     * @param context context
     * @return boolean true if landscape, otherwise false
     */

#Code:
    public static final boolean isLandscape(Context context) {
        return context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;
    }

#end
#end
#No. 185094
#File: E:\bishe\1\WindowHelper.java
#Comment:
    /**
     * whether current window is portrait
     *
     * @param context context
     * @return boolean
     */

#Code:
    public static final boolean isPortrait(Context context) {
        return context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT;
    }

#end
#end
#No. 185095
#File: E:\bishe\1\WindowHoverMenu.java
#Comment:
    /**
     * Initializes and displays the Hover menu. To destroy and remove the Hover menu, use {@link #hide()}.
     */

#Code:
    @Override
    public void show() {
        if (!mIsShowingHoverMenu) {
            mWindowViewController.addView(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT, false, mHoverMenuView);

            // Sync our control state with the HoverMenuView state.
            if (mHoverMenuView.isExpanded()) {
                mWindowViewController.makeTouchable(mHoverMenuView);
            } else {
                collapseMenu();
            }

            mIsShowingHoverMenu = true;
        }
    }

#end
#end
#No. 185096
#File: E:\bishe\1\WindowHoverMenu.java
#Comment:
    /**
     * Exits the Hover menu system. This method is the inverse of {@link #show()}.
     */

#Code:
    @Override
    public void hide() {
        if (mIsShowingHoverMenu) {
            mIsShowingHoverMenu = false;

            // Notify our exit listeners that we're exiting.
            notifyOnExitListeners();

            // Cleanup the control structures and Views.
            mWindowViewController.removeView(mHoverMenuView);
            mHoverMenuView.release();
        }
    }

#end
#end
#No. 185097
#File: E:\bishe\1\WindowHoverMenu.java
#Comment:
    /**
     * Expands the Hover menu to show all of its tabs and a content area for the selected tab. To
     * collapse the menu down a single active tab, use {@link #collapseMenu()}.
     */

#Code:
    @Override
    public void expandMenu() {
        if (mIsInDragMode) {
            mHoverMenuView.expand();
        }
    }

#end
#end
#No. 185098
#File: E:\bishe\1\WindowHoverMenu.java
#Comment:
    /**
     * Collapses the Hover menu down to its single active tab and allows the tab to be dragged
     * around the display. This method is the inverse of {@link #expandMenu()}.
     */

#Code:
    @Override
    public void collapseMenu() {
        if (!mIsInDragMode) {
            mHoverMenuView.setHoverMenuTransitionListener(mHoverMenuTransitionListener);
            mHoverMenuView.collapse();
        }
    }

#end
#end
#No. 185099
#File: E:\bishe\1\WindowIncompletes.java
#Comment:
    /**
     * Fills the list with the board incompletes.
     */

#Code:
    protected void fill_list()
    {
        RatsNest ratsnest = board_frame.board_panel.board_handling.get_ratsnest();
        RatsNest.AirLine[] sorted_arr = ratsnest.get_airlines();
        
        java.util.Arrays.sort(sorted_arr);
        for (int i = 0; i < sorted_arr.length; ++i)
        {
            this.add_to_list(sorted_arr[i]);
        }
        this.list.setVisibleRowCount(Math.min(sorted_arr.length, DEFAULT_TABLE_SIZE));
    }

#end
#end
#No. 185100
#File: E:\bishe\1\WindowInEvent.java
#Comment:
	/**
	 * 
	 * Getter for the windowId property
	 * 
	 * @return Opaque String indicating the id of the window entered *
	 **/

#Code:
	public String getWindowId() {
		return windowId;
	}

#end
#end
#No. 185101
#File: E:\bishe\1\WindowInEvent.java
#Comment:
	/**
	 * 
	 * Setter for the windowId property
	 * 
	 * @param windowId
	 *            Opaque String indicating the id of the window entered
	 * 
	 **/

#Code:
	public void setWindowId(String windowId) {
		this.windowId = windowId;
	}

#end
#end
#No. 185102
#File: E:\bishe\1\WindowingDomain.java
#Comment:
/**
 * WindowingDomain allows to type a windowing expression like ROWS(CURRENT(),UNBOUNDED)...
 * A windowing expression may be used with analytical operators
 * 
 * @author sfantino
 *
 */

#Code:
public interface WindowingDomain
extends IDomain
{
	
	public static final WindowingDomain DOMAIN = new WindowingDomainImp();
	public static final ProxyAnalyticDomainManager MANAGER = new ProxyAnalyticDomainManager();
	
	public WindowingStaticExpression getExpression();

}




#end
#end
#No. 185105
#File: E:\bishe\1\WindowInstances.java
#Comment:
	/**
	 * Checks if given triple has predicate==rdf:type and object==instanceClass
	 *
	 * @param t a {@link lupos.datastructures.items.Triple} object.
	 * @return a boolean.
	 */

#Code:
	protected boolean isMatchingTypeTriple(Triple t) {
		return t.getPredicate().compareToNotNecessarilySPARQLSpecificationConform(this.RDF_TYPE) == 0
				&& t.getObject().compareToNotNecessarilySPARQLSpecificationConform(this.instanceClass)==0;
	}

#end
#end
#No. 185106
#File: E:\bishe\1\WindowInstances.java
#Comment:
	/**
	 * <p>haveSameSubject.</p>
	 *
	 * @param t1 a {@link lupos.datastructures.items.Triple} object.
	 * @param t2 a {@link lupos.datastructures.items.Triple} object.
	 * @return a boolean.
	 */

#Code:
	protected boolean haveSameSubject(Triple t1, Triple t2) {
		if(t1==null || t2==null){
			return false;
		}
		return 0==t1.getSubject().compareToNotNecessarilySPARQLSpecificationConform(t2.getSubject());
	}

#end
#end
#No. 185107
#File: E:\bishe\1\WindowInstances.java
#Comment:
	/**
	 * Deletes all triples which have the same subject as a given triple t.
	 *
	 * @param t a {@link lupos.datastructures.items.Triple} object.
	 */

#Code:
	protected void deleteInstance(Triple t) {
		// 1. search for triples with same subject
		List<TimestampedTriple> instanceTriples = new ArrayList<TimestampedTriple>();
		for(TimestampedTriple tmp : this.tripleBuffer) {
			if(haveSameSubject(tmp,t)){
				instanceTriples.add(tmp);
			}
		}
		// 2. delete them
		for(TimestampedTriple tmp : instanceTriples) {
			this.tripleBuffer.remove(tmp);
			super.deleteTriple(tmp);
		}
	}

#end
#end
#No. 185108
#File: E:\bishe\1\WindowInstances.java
#Comment:
	/**
	 * <p>deleteInstanceDebug.</p>
	 *
	 * @param t a {@link lupos.datastructures.items.Triple} object.
	 * @param debugstep a {@link lupos.misc.debug.DebugStep} object.
	 */

#Code:
	protected void deleteInstanceDebug(Triple t, DebugStep debugstep) {
		// 1. search for triples with same subject
		List<TimestampedTriple> instanceTriples = new ArrayList<TimestampedTriple>();
		for(TimestampedTriple tmp : this.tripleBuffer) {
			if(haveSameSubject(tmp,t)){
				instanceTriples.add(tmp);
			}
		}
		// 2. delete them
		for(TimestampedTriple tmp : instanceTriples) {
			this.tripleBuffer.remove(tmp);
			super.deleteTripleDebug(tmp, debugstep);
		}
	}

#end
#end
#No. 185109
#File: E:\bishe\1\WindowInstancesDuration.java
#Comment:
	/**
	 * <p>Constructor for WindowInstancesDuration.</p>
	 *
	 * @param duration a int.
	 * @param instanceClass a {@link lupos.datastructures.items.literal.Literal} object.
	 */

#Code:
	public WindowInstancesDuration(final int duration, Literal instanceClass) {
		super(instanceClass);
		this.duration = duration;
	}

#end
#end
#No. 185110
#File: E:\bishe\1\WindowInstancesNumber.java
#Comment:
	/**
	 * <p>Constructor for WindowInstancesNumber.</p>
	 *
	 * @param numberOfInstances a int.
	 * @param instanceClass a {@link lupos.datastructures.items.literal.Literal} object.
	 */

#Code:
	public WindowInstancesNumber(final int numberOfInstances, Literal instanceClass) {
		super(instanceClass);
		if (numberOfInstances < 1) {
			System.err.println("X must be >=1 for WINDOW TYPE SLIDINGTRIPLES X");
			System.err.println("Assuming WINDOW TYPE SLIDINGTRIPLES 1...");
			this.numberOfInstances = 1;
		} else
			this.numberOfInstances = numberOfInstances;		
	}

#end
#end
#No. 185111
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Return the list of Windows from the passed token on the given Display.
     * @param token The token with all the windows.
     * @param displayContent The display we are interested in.
     * @return List of windows from token that are on displayContent.
     */

#Code:
    WindowList getTokenWindowsOnDisplay(WindowToken token, DisplayContent displayContent) {
        final WindowList windowList = new WindowList();
        final int count = token.windows.size();
        for (int i = 0; i < count; i++) {
            final WindowState win = token.windows.get(i);
            if (win.getDisplayContent() == displayContent) {
                windowList.add(win);
            }
        }
        return windowList;
    }

#end
#end
#No. 185112
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Recursive search through a WindowList and all of its windows' children.
     * @param targetWin The window to search for.
     * @param windows The list to search.
     * @return The index of win in windows or of the window that is an ancestor of win.
     */

#Code:
    private int indexOfWinInWindowList(WindowState targetWin, WindowList windows) {
        for (int i = windows.size() - 1; i >= 0; i--) {
            final WindowState w = windows.get(i);
            if (w == targetWin) {
                return i;
            }
            if (!w.mChildWindows.isEmpty()) {
                if (indexOfWinInWindowList(targetWin, w.mChildWindows) >= 0) {
                    return i;
                }
            }
        }
        return -1;
    }

#end
#end
#No. 185114
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Check wallpaper for visiblity change and notify window if so.
     * @param wallpaper The wallpaper to test and notify.
     * @param visible Current visibility.
     */

#Code:
    void dispatchWallpaperVisibility(final WindowState wallpaper, final boolean visible) {
        if (wallpaper.mWallpaperVisible != visible) {
            wallpaper.mWallpaperVisible = visible;
            try {
                if (DEBUG_VISIBILITY || DEBUG_WALLPAPER_LIGHT) Slog.v(TAG,
                        "Updating vis of wallpaper " + wallpaper
                        + ": " + visible + " from:\n" + Debug.getCallers(4, "  "));
                wallpaper.mClient.dispatchAppVisibility(visible);
            } catch (RemoteException e) {
            }
        }
    }

#end
#end
#No. 185115
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Returns whether screen capture is disabled for all windows of a specific user.
     */

#Code:
    boolean isScreenCaptureDisabledLocked(int userId) {
        Boolean disabled = mScreenCaptureDisabled.get(userId);
        if (disabled == null) {
            return false;
        }
        return disabled;
    }

#end
#end
#No. 185116
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Set mScreenCaptureDisabled for specific user
     */

#Code:
    @Override
    public void setScreenCaptureDisabled(int userId, boolean disabled) {
        int callingUid = Binder.getCallingUid();
        if (callingUid != Process.SYSTEM_UID) {
            throw new SecurityException("Only system can call setScreenCaptureDisabled.");
        }

        synchronized(mWindowMap) {
            mScreenCaptureDisabled.put(userId, disabled);
        }
    }

#end
#end
#No. 185117
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /*
     * Determine the new desired orientation of the display, returning
     * a non-null new Configuration if it has changed from the current
     * orientation.  IF TRUE IS RETURNED SOMEONE MUST CALL
     * setNewConfiguration() TO TELL THE WINDOW MANAGER IT CAN UNFREEZE THE
     * SCREEN.  This will typically be done for you if you call
     * sendNewConfiguration().
     *
     * The orientation is computed from non-application windows first. If none of
     * the non-application windows specify orientation, the orientation is computed from
     * application tokens.
     * @see android.view.IWindowManager#updateOrientationFromAppTokens(
     * android.os.IBinder)
     */

#Code:
    boolean updateOrientationFromAppTokensLocked(boolean inTransaction) {
        long ident = Binder.clearCallingIdentity();
        try {
            int req = getOrientationFromWindowsLocked();
            if (req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
                req = getOrientationFromAppTokensLocked();
            }

            if (req != mForcedAppOrientation) {
                mForcedAppOrientation = req;
                //send a message to Policy indicating orientation change to take
                //action like disabling/enabling sensors etc.,
                mPolicy.setCurrentOrientationLw(req);
                if (updateRotationUncheckedLocked(inTransaction)) {
                    // changed
                    return true;
                }
            }

            return false;
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

#end
#end
#No. 185118
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Create a new TaskStack and place it on a DisplayContent.
     * @param stackId The unique identifier of the new stack.
     * @param displayId The unique identifier of the DisplayContent.
     */

#Code:
    public void attachStack(int stackId, int displayId) {
        final long origId = Binder.clearCallingIdentity();
        try {
            synchronized (mWindowMap) {
                final DisplayContent displayContent = mDisplayContents.get(displayId);
                if (displayContent != null) {
                    TaskStack stack = mStackIdToStack.get(stackId);
                    if (stack == null) {
                        if (DEBUG_STACK) Slog.d(TAG, "attachStack: stackId=" + stackId);
                        stack = new TaskStack(this, stackId);
                        mStackIdToStack.put(stackId, stack);
                    }
                    stack.attachDisplayContent(displayContent);
                    displayContent.attachStack(stack);
                    moveStackWindowsLocked(displayContent);
                    final WindowList windows = displayContent.getWindowList();
                    for (int winNdx = windows.size() - 1; winNdx >= 0; --winNdx) {
                        windows.get(winNdx).reportResized();
                    }
                }
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

#end
#end
#No. 185119
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * @see android.app.KeyguardManager#exitKeyguardSecurely
     */

#Code:
    @Override
    public void exitKeyguardSecurely(final IOnKeyguardExitResult callback) {
        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DISABLE_KEYGUARD)
            != PackageManager.PERMISSION_GRANTED) {
            throw new SecurityException("Requires DISABLE_KEYGUARD permission");
        }

        if (callback == null) {
            throw new IllegalArgumentException("callback == null");
        }

        mPolicy.exitKeyguardSecurely(new WindowManagerPolicy.OnKeyguardExitResult() {
            @Override
            public void onKeyguardExitResult(boolean success) {
                try {
                    callback.onKeyguardExitResult(success);
                } catch (RemoteException e) {
                    // Client has died, we don't care.
                }
            }
        });
    }

#end
#end
#No. 185120
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Freeze rotation changes.  (Enable "rotation lock".)
     * Persists across reboots.
     * @param rotation The desired rotation to freeze to, or -1 to use the
     * current rotation.
     */

#Code:
    @Override
    public void freezeRotation(int rotation) {
        if (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION,
                "freezeRotation()")) {
            throw new SecurityException("Requires SET_ORIENTATION permission");
        }
        if (rotation < -1 || rotation > Surface.ROTATION_270) {
            throw new IllegalArgumentException("Rotation argument must be -1 or a valid "
                    + "rotation constant.");
        }

        if (DEBUG_ORIENTATION) Slog.v(TAG, "freezeRotation: mRotation=" + mRotation);

        long origId = Binder.clearCallingIdentity();
        try {
            mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_LOCKED,
                    rotation == -1 ? mRotation : rotation);
        } finally {
            Binder.restoreCallingIdentity(origId);
        }

        updateRotationUnchecked(false, false);
    }

#end
#end
#No. 185121
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Thaw rotation changes.  (Disable "rotation lock".)
     * Persists across reboots.
     */

#Code:
    @Override
    public void thawRotation() {
        if (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION,
                "thawRotation()")) {
            throw new SecurityException("Requires SET_ORIENTATION permission");
        }

        if (DEBUG_ORIENTATION) Slog.v(TAG, "thawRotation: mRotation=" + mRotation);

        long origId = Binder.clearCallingIdentity();
        try {
            mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_FREE,
                    777); // rot not used
        } finally {
            Binder.restoreCallingIdentity(origId);
        }

        updateRotationUnchecked(false, false);
    }

#end
#end
#No. 185122
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Recalculate the current rotation.
     *
     * Called by the window manager policy whenever the state of the system changes
     * such that the current rotation might need to be updated, such as when the
     * device is docked or rotated into a new posture.
     */

#Code:
    @Override
    public void updateRotation(boolean alwaysSendConfiguration, boolean forceRelayout) {
        updateRotationUnchecked(alwaysSendConfiguration, forceRelayout);
    }

#end
#end
#No. 185123
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Temporarily pauses rotation changes until resumed.
     *
     * This can be used to prevent rotation changes from occurring while the user is
     * performing certain operations, such as drag and drop.
     *
     * This call nests and must be matched by an equal number of calls to
     * {@link #resumeRotationLocked}.
     */

#Code:
    void pauseRotationLocked() {
        mDeferredRotationPauseCount += 1;
    }

#end
#end
#No. 185124
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Resumes normal rotation changes after being paused.
     */

#Code:
    void resumeRotationLocked() {
        if (mDeferredRotationPauseCount > 0) {
            mDeferredRotationPauseCount -= 1;
            if (mDeferredRotationPauseCount == 0) {
                boolean changed = updateRotationUncheckedLocked(false);
                if (changed) {
                    mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
                }
            }
        }
    }

#end
#end
#No. 185125
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Apps that use the compact menu panel (as controlled by the panelMenuIsCompact
     * theme attribute) on devices that feature a physical options menu key attempt to position
     * their menu panel window along the edge of the screen nearest the physical menu key.
     * This lowers the travel distance between invoking the menu panel and selecting
     * a menu option.
     *
     * This method helps control where that menu is placed. Its current implementation makes
     * assumptions about the menu key and its relationship to the screen based on whether
     * the device's natural orientation is portrait (width < height) or landscape.
     *
     * The menu key is assumed to be located along the bottom edge of natural-portrait
     * devices and along the right edge of natural-landscape devices. If these assumptions
     * do not hold for the target device, this method should be changed to reflect that.
     *
     * @return A {@link Gravity} value for placing the options menu window
     */

#Code:
    @Override
    public int getPreferredOptionsPanelGravity() {
        synchronized (mWindowMap) {
            final int rotation = getRotation();

            // TODO(multidisplay): Assume that such devices physical keys are on the main screen.
            final DisplayContent displayContent = getDefaultDisplayContentLocked();
            if (displayContent.mInitialDisplayWidth < displayContent.mInitialDisplayHeight) {
                // On devices with a natural orientation of portrait
                switch (rotation) {
                    default:
                    case Surface.ROTATION_0:
                        return Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM;
                    case Surface.ROTATION_90:
                        return Gravity.RIGHT | Gravity.BOTTOM;
                    case Surface.ROTATION_180:
                        return Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM;
                    case Surface.ROTATION_270:
                        return Gravity.START | Gravity.BOTTOM;
                }
            }

            // On devices with a natural orientation of landscape
            switch (rotation) {
                default:
                case Surface.ROTATION_0:
                    return Gravity.RIGHT | Gravity.BOTTOM;
                case Surface.ROTATION_90:
                    return Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM;
                case Surface.ROTATION_180:
                    return Gravity.START | Gravity.BOTTOM;
                case Surface.ROTATION_270:
                    return Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM;
            }
        }
    }

#end
#end
#No. 185126
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Starts the view server on the specified port.
     *
     * @param port The port to listener to.
     *
     * @return True if the server was successfully started, false otherwise.
     *
     * @see com.android.server.wm.ViewServer
     * @see com.android.server.wm.ViewServer#VIEW_SERVER_DEFAULT_PORT
     */

#Code:
    @Override
    public boolean startViewServer(int port) {
        if (isSystemSecure()) {
            return false;
        }

        if (!checkCallingPermission(Manifest.permission.DUMP, "startViewServer")) {
            return false;
        }

        if (port < 1024) {
            return false;
        }

        if (mViewServer != null) {
            if (!mViewServer.isRunning()) {
                try {
                    return mViewServer.start();
                } catch (IOException e) {
                    Slog.w(TAG, "View server did not start");
                }
            }
            return false;
        }

        try {
            mViewServer = new ViewServer(this, port);
            return mViewServer.start();
        } catch (IOException e) {
            Slog.w(TAG, "View server did not start");
        }
        return false;
    }

#end
#end
#No. 185127
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Stops the view server if it exists.
     *
     * @return True if the server stopped, false if it wasn't started or
     *         couldn't be stopped.
     *
     * @see com.android.server.wm.ViewServer
     */

#Code:
    @Override
    public boolean stopViewServer() {
        if (isSystemSecure()) {
            return false;
        }

        if (!checkCallingPermission(Manifest.permission.DUMP, "stopViewServer")) {
            return false;
        }

        if (mViewServer != null) {
            return mViewServer.stop();
        }
        return false;
    }

#end
#end
#No. 185128
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Indicates whether the view server is running.
     *
     * @return True if the server is running, false otherwise.
     *
     * @see com.android.server.wm.ViewServer
     */

#Code:
    @Override
    public boolean isViewServerRunning() {
        if (isSystemSecure()) {
            return false;
        }

        if (!checkCallingPermission(Manifest.permission.DUMP, "isViewServerRunning")) {
            return false;
        }

        return mViewServer != null && mViewServer.isRunning();
    }

#end
#end
#No. 185129
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Returns the focused window in the following format:
     * windowHashCodeInHexadecimal windowName
     *
     * @param client The remote client to send the listing to.
     * @return False if an error occurred, true otherwise.
     */

#Code:
    boolean viewServerGetFocusedWindow(Socket client) {
        if (isSystemSecure()) {
            return false;
        }

        boolean result = true;

        WindowState focusedWindow = getFocusedWindow();

        BufferedWriter out = null;

        // Any uncaught exception will crash the system process
        try {
            OutputStream clientStream = client.getOutputStream();
            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);

            if(focusedWindow != null) {
                out.write(Integer.toHexString(System.identityHashCode(focusedWindow)));
                out.write(' ');
                out.append(focusedWindow.mAttrs.getTitle());
            }
            out.write('\n');
            out.flush();
        } catch (Exception e) {
            result = false;
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    result = false;
                }
            }
        }

        return result;
    }


#end
#end
#No. 185131
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /** If a window that has an animation specifying a colored background and the current wallpaper
     * is visible, then the color goes *below* the wallpaper so we don't cause the wallpaper to
     * suddenly disappear. */

#Code:
    int adjustAnimationBackground(WindowStateAnimator winAnimator) {
        WindowList windows = winAnimator.mWin.getWindowList();
        for (int i = windows.size() - 1; i >= 0; --i) {
            WindowState testWin = windows.get(i);
            if (testWin.mIsWallpaper && testWin.isVisibleNow()) {
                return testWin.mWinAnimator.mAnimLayer;
            }
        }
        return winAnimator.mAnimLayer;
    }
#end
#end
#No. 185132
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Saves information about the state of the window manager at
     * the time an ANR occurred before anything else in the system changes
     * in response.
     *
     * @param appWindowToken The application that ANR'd, may be null.
     * @param windowState The window that ANR'd, may be null.
     * @param reason The reason for the ANR, may be null.
     */

#Code:
    public void saveANRStateLocked(AppWindowToken appWindowToken, WindowState windowState,
            String reason) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new FastPrintWriter(sw, false, 1024);
        pw.println("  ANR time: " + DateFormat.getInstance().format(new Date()));
        if (appWindowToken != null) {
            pw.println("  Application at fault: " + appWindowToken.stringName);
        }
        if (windowState != null) {
            pw.println("  Window at fault: " + windowState.mAttrs.getTitle());
        }
        if (reason != null) {
            pw.println("  Reason: " + reason);
        }
        pw.println();
        dumpWindowsNoHeaderLocked(pw, true, null);
        pw.println();
        pw.println("Last ANR continued");
        dumpDisplayContentsLocked(pw, true);
        pw.close();
        mLastANRState = sw.toString();

        mH.removeMessages(H.RESET_ANR_MESSAGE);
        mH.sendEmptyMessageDelayed(H.RESET_ANR_MESSAGE, LAST_ANR_LIFETIME_DURATION_MSECS);
    }

#end
#end
#No. 185133
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Retrieve the DisplayContent for the specified displayId. Will create a new DisplayContent if
     * there is a Display for the displayId.
     * @param displayId The display the caller is interested in.
     * @return The DisplayContent associated with displayId or null if there is no Display for it.
     */

#Code:
    public DisplayContent getDisplayContentLocked(final int displayId) {
        DisplayContent displayContent = mDisplayContents.get(displayId);
        if (displayContent == null) {
            final Display display = mDisplayManager.getDisplay(displayId);
            if (display != null) {
                displayContent = newDisplayContentLocked(display);
            }
        }
        return displayContent;
    }

#end
#end
#No. 185134
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Return the list of WindowStates associated on the passed display.
     * @param display The screen to return windows from.
     * @return The list of WindowStates on the screen, or null if the there is no screen.
     */

#Code:
    public WindowList getWindowListLocked(final Display display) {
        return getWindowListLocked(display.getDisplayId());
    }

#end
#end
#No. 185135
#File: E:\bishe\1\WindowManagerService.java
#Comment:
    /**
     * Return the list of WindowStates associated on the passed display.
     * @param displayId The screen to return windows from.
     * @return The list of WindowStates on the screen, or null if the there is no screen.
     */

#Code:
    public WindowList getWindowListLocked(final int displayId) {
        final DisplayContent displayContent = getDisplayContentLocked(displayId);
        return displayContent != null ? displayContent.getWindowList() : null;
    }

#end
#end
#No. 185136
#File: E:\bishe\1\WindowNets.java
#Comment:
    /**
     * Fills the list with the nets in the net list.
     */

#Code:
    protected void fill_list()
    {
        Nets nets = this.board_frame.board_panel.board_handling.get_routing_board().rules.nets;
        Net[] sorted_arr = new Net[nets.max_net_no()];
        for (int i = 0; i < sorted_arr.length; ++i)
        {
            sorted_arr[i] = nets.get(i + 1);
        }
        java.util.Arrays.sort(sorted_arr);
        for (int i = 0; i < sorted_arr.length; ++i)
        {
            this.add_to_list(sorted_arr[i]);
        }
        this.list.setVisibleRowCount(Math.min(sorted_arr.length, DEFAULT_TABLE_SIZE));
    }

#end
#end
#No. 185137
#File: E:\bishe\1\WindowNetSamples.java
#Comment:
    /**
     * Opens a sample design on the website.
     */

#Code:
    protected static BoardFrame open_design(String p_archive_name, String p_design_name, java.util.Locale p_locale)
    {
        ZipInputStream zip_input_stream = open_zipped_file(p_archive_name, p_design_name);
        if (zip_input_stream == null)
        {
            return null;
        }
        DesignFile design_file = DesignFile.get_instance("sharc_routed.dsn", true);
        BoardFrame new_frame =
                new BoardFrame(design_file, BoardFrame.Option.WEBSTART, board.TestLevel.RELEASE_VERSION,
                p_locale, false);
        boolean read_ok = new_frame.read(zip_input_stream, true, null);
        if (!read_ok)
        {
            return null;
        }
        new_frame.setVisible(true);
        return new_frame;
    }

#end
#end
#No. 185138
#File: E:\bishe\1\WindowOutEvent.java
#Comment:
	/**
	 * 
	 * Getter for the windowId property
	 * 
	 * @return Opaque String indicating the id of the window entered *
	 **/

#Code:
	public String getWindowId() {
		return windowId;
	}

#end
#end
#No. 185139
#File: E:\bishe\1\WindowOutEvent.java
#Comment:
	/**
	 * 
	 * Setter for the windowId property
	 * 
	 * @param windowId
	 *            Opaque String indicating the id of the window entered
	 * 
	 **/

#Code:
	public void setWindowId(String windowId) {
		this.windowId = windowId;
	}

#end
#end
#No. 185140
#File: E:\bishe\1\WindowParam.java
#Comment:
	/**
	 * 
	 * get X coordinate of the left upper point of the window
	 * 
	 **/

#Code:
	public int getTopRightCornerX() {
		return topRightCornerX;
	}

#end
#end
#No. 185141
#File: E:\bishe\1\WindowParam.java
#Comment:
	/**
	 * 
	 * set X coordinate of the left upper point of the window
	 * 
	 **/

#Code:
	public void setTopRightCornerX(int topRightCornerX) {
		this.topRightCornerX = topRightCornerX;
	}

#end
#end
#No. 185142
#File: E:\bishe\1\WindowParam.java
#Comment:
	/**
	 * 
	 * get Y coordinate of the left upper point of the window
	 * 
	 **/

#Code:
	public int getTopRightCornerY() {
		return topRightCornerY;
	}

#end
#end
#No. 185143
#File: E:\bishe\1\WindowParam.java
#Comment:
	/**
	 * 
	 * set Y coordinate of the left upper point of the window
	 * 
	 **/

#Code:
	public void setTopRightCornerY(int topRightCornerY) {
		this.topRightCornerY = topRightCornerY;
	}

#end
#end
#No. 185144
#File: E:\bishe\1\WindowParam.java
#Comment:
	/**
	 * 
	 * get width in pixels of the window
	 * 
	 **/

#Code:
	public int getWidth() {
		return width;
	}

#end
#end
#No. 185145
#File: E:\bishe\1\WindowParam.java
#Comment:
	/**
	 * 
	 * set width in pixels of the window
	 * 
	 **/

#Code:
	public void setWidth(int width) {
		this.width = width;
	}

#end
#end
#No. 185146
#File: E:\bishe\1\WindowParam.java
#Comment:
	/**
	 * 
	 * get height in pixels of the window
	 * 
	 **/

#Code:
	public int getHeight() {
		return height;
	}

#end
#end
#No. 185147
#File: E:\bishe\1\WindowParam.java
#Comment:
	/**
	 * 
	 * set height in pixels of the window
	 * 
	 **/

#Code:
	public void setHeight(int height) {
		this.height = height;
	}

#end
#end
#No. 185148
#File: E:\bishe\1\WindowsAttachProvider.java
#Comment:
	/**
	 * Returns true if the temporary file system supports security
	 */

#Code:
	private static boolean isTempPathSecure() {
		if (!wasTempPathChecked) {
			synchronized (WindowsAttachProvider.class) {
				if (!wasTempPathChecked) {
					// get the value of TMP/TEMP, ignoring UNC, and paths that
					// aren't absolute
					String temp = tempPath();
					if ((temp != null) && (temp.length() >= 3) && (temp.charAt(1) == ':') && (temp.charAt(2) == '\\')) {
						// check if the volume supports security
						long flags = volumeFlags(temp.substring(0, 3));
						isTempPathSecure = ((flags & FS_PERSISTENT_ACLS) != 0);
					}
					wasTempPathChecked = true;
				}
			}
		}

		return isTempPathSecure;
	}

#end
#end
#No. 185149
#File: E:\bishe\1\WindowsAttachProvider.java
#Comment:
	/**
	 * Returns a list of virtual machine descriptors derived from an enumeration of the process list.
	 */

#Code:
	private List<VirtualMachineDescriptor> listJavaProcesses() {
		ArrayList<VirtualMachineDescriptor> list = new ArrayList<VirtualMachineDescriptor>();

		// Use localhost in the display name
		String host = "localhost";
		try {
			host = InetAddress.getLocalHost().getHostName();
		} catch (UnknownHostException uhe) {
			// ignore
		}

		// Enumerate all processes.
		// For those processes that have loaded a library named "jvm.dll"
		// then we attempt to attach. If we succeed then we have a 6.0+ VM.
		int processes[] = new int[1024];
		int count = enumProcesses(processes, processes.length);
		for (int i = 0; i < count; i++) {
			if (isLibraryLoadedByProcess("jvm.dll", processes[i])) {
				String pid = Integer.toString(processes[i]);
				try {
					new WindowsVirtualMachine(this, pid).detach();

					// FIXME - for now we don't have an appropriate display
					// name so we use pid@hostname
					String name = pid + "@" + host;

					list.add(new HotSpotVirtualMachineDescriptor(this, pid, name));
				} catch (AttachNotSupportedException x) {
				} catch (IOException ioe) {
				}
			}
		}

		return list;
	}

#end
#end
#No. 185150
#File: E:\bishe\1\WindowsAttachProviderImpl.java
#Comment:
    /**
     * Returns true if the temporary file system supports security
     */

#Code:
    private static boolean isTempPathSecure() {
        if (!wasTempPathChecked) {
            synchronized (WindowsAttachProviderImpl.class) {
                if (!wasTempPathChecked) {
                    // get the value of TMP/TEMP, ignoring UNC, and paths that
                    // aren't absolute
                    String temp = tempPath();
                    if ((temp != null) && (temp.length() >= 3) &&
                        (temp.charAt(1) == ':') && (temp.charAt(2) == '\\'))
                    {
                        // check if the volume supports security
                        long flags = volumeFlags(temp.substring(0, 3));
                        isTempPathSecure = ((flags & FS_PERSISTENT_ACLS) != 0);
                    }
                    wasTempPathChecked = true;
                }
            }
        }

        return isTempPathSecure;
    }

#end
#end
#No. 185151
#File: E:\bishe\1\WindowsAttachProviderImpl.java
#Comment:
    /**
     * Returns a list of virtual machine descriptors derived from an enumeration
     * of the process list.
     */

#Code:
    private List<VirtualMachineDescriptor> listJavaProcesses() {
        ArrayList<VirtualMachineDescriptor> list =
            new ArrayList<VirtualMachineDescriptor>();

        // Use localhost in the display name
        String host = "localhost";
        try {
            host = InetAddress.getLocalHost().getHostName();
        } catch (UnknownHostException uhe) {
            // ignore
        }

        // Enumerate all processes.
        // For those processes that have loaded a library named "jvm.dll"
        // then we attempt to attach. If we succeed then we have a 6.0+ VM.
        int processes[] = new int[1024];
        int count = enumProcesses(processes, processes.length);
        for (int i=0; i<count; i++) {
            if (isLibraryLoadedByProcess("jvm.dll", processes[i])) {
                String pid = Integer.toString(processes[i]);
                try {
                    new WindowsVirtualMachineImpl(this, pid).detach();

                    // FIXME - for now we don't have an appropriate display
                    // name so we use pid@hostname
                    String name = pid + "@" + host;

                    list.add(new HotSpotVirtualMachineDescriptor(this, pid, name));
                } catch (AttachNotSupportedException x) {
                } catch (IOException ioe) {
                }
            }
        }

        return list;
    }

#end
#end
#No. 185152
#File: E:\bishe\1\WindowsBooterDaemonGenerator.java
#Comment:
/**
 * Generates windows wrapperscripts.
 *
 * @author <a href="mailto:kaare.nilsen@gmail.com">Kaare Nilsen</a>
 * @plexus.component role-hint="booter-windows"
 */

#Code:
public class WindowsBooterDaemonGenerator
    extends AbstractBooterDaemonGenerator
{
    public WindowsBooterDaemonGenerator()
    {
        super( Platform.WINDOWS_NAME );
    }
}





#end
#end
#No. 185157
#File: E:\bishe\1\WindowsPerformanceCounterData.java
#Comment:
    /**
     * Sets the instance name, the method will consult the JniPCConnector for the proper instance name.
     * @param instanceName The requested instance name.
     * @return 'this'.
     * @throws Throwable The method might throw an Error if the JniPCConnector is not able to properly connect to the native code.
     */

#Code:
    public WindowsPerformanceCounterData setInstanceName(String instanceName) throws Throwable {
        String translatedInstanceName;
        try {
            translatedInstanceName = JniPCConnector.translateInstanceName(instanceName);
            this.instanceName = translatedInstanceName;
        } catch (Throwable e) {
            InternalLogger.INSTANCE.error("Failed to translate instance name '%s': '%s'", instanceName, e.getMessage());
            throw e;
        }
        return this;
    }

#end
#end
#No. 185158
#File: E:\bishe\1\WindowsProcessesServiceTest.java
#Comment:
    /**
     * Test of getProcessList method, of class JProcesses.
     */

#Code:
    @Test
    public void testGetList() {
        if (OSDetector.isWindows()) {
            List<ProcessInfo> list = srv.getList();
            assertEquals(5, list.size());
            assertTrue(list.contains(processInfo1));
            assertTrue(list.contains(processInfo2));
            assertTrue(list.contains(processInfo3));
            assertTrue(list.contains(processInfo4));
            assertTrue(list.contains(processInfo5));
        }
    }

#end
#end
#No. 185159
#File: E:\bishe\1\WindowsPropertyTab.java
#Comment:
/**
 * UI to control host Windows specific project properties and preferences for
 * cmake. This tab is responsible for storing its values.
 *
 * @author Martin Weber
 */

#Code:
public class WindowsPropertyTab extends
    AbstractOsPropertyTab<WindowsPreferences> {

  private static final EnumSet<CmakeGenerator> generators = EnumSet.of(
      CmakeGenerator.MinGWMakefiles, CmakeGenerator.MSYSMakefiles,
      CmakeGenerator.UnixMakefiles, CmakeGenerator.Ninja,
      CmakeGenerator.NMakeMakefiles, CmakeGenerator.NMakeMakefilesJOM,
      CmakeGenerator.BorlandMakefiles, CmakeGenerator.WatcomWMake);

  /*-
   * @see de.marw.cdt.cmake.core.ui.AbstractOsPropertyTab#getOsPreferences(de.marw.cdt.cmake.core.internal.CMakePreferences)
   */
  @Override
  protected WindowsPreferences getOsPreferences(CMakePreferences prefs) {
    return prefs.getWindowsPreferences();
  }

  @Override
  protected EnumSet<CmakeGenerator> getAvailableGenerators() {
    return WindowsPropertyTab.generators;
  }

}

#end
#end
#No. 185160
#File: E:\bishe\1\WindowsRealm.java
#Comment:
    /**
     * Set the admin attribute from group memberships retrieved from Windows.
     *
     * @param account
     */

#Code:
    private void setAdminAttribute(Account account) {
        if (adminGroups != null) {
            for (String adminGroup : adminGroups) {
                if (adminGroup.startsWith("@") && account.getUsername().equalsIgnoreCase(adminGroup.substring(1))) {
                    // admin user
                    account.getAuthorizations().addPermission("*");
                } else if (account.hasRole(adminGroup)) {
                    // admin role
                    account.getAuthorizations().addPermission("*");
                }
            }
        }

#end
#end
#No. 185161
#File: E:\bishe\1\WindowsRealm.java
#Comment:
    /**
     * Returns a simple username without any domain prefixes.
     *
     * @param username
     * @return a simple username
     */

#Code:
    private String getSimpleUsername(String username) {
        String simpleUsername = username;
        if (defaultDomain != null) {
            // sanitize username
            if (username.startsWith(defaultDomain + "\\")) {
                // strip default domain from domain\ username
                simpleUsername = username.substring(defaultDomain.length() + 1);
            } else if (username.endsWith("@" + defaultDomain)) {
                // strip default domain from username@domain
                simpleUsername = username.substring(0, username.lastIndexOf('@'));
            }
        }
        return simpleUsername;
    }

#end
#end
#No. 185162
#File: E:\bishe\1\WindowsScriptDaemonGenerator.java
#Comment:
/**
 * Generates unix and/or windows wrapperscripts.
 *
 * @plexus.component role-hint="windows"
 */

#Code:
public class WindowsScriptDaemonGenerator
    extends AbstactScriptDaemonGenerator
{
    public WindowsScriptDaemonGenerator()
    {
        super( Platform.WINDOWS_NAME );
    }

    public void generate( DaemonGenerationRequest generationRequest )
        throws DaemonGeneratorException
    {
        scriptGenerator.createBinScript( getPlatformName(), generationRequest.getDaemon(),
                                         generationRequest.getOutputDirectory(), generationRequest.getBinFolder() );
    }
}



#end
#end
#No. 185165
#File: E:\bishe\1\WindowTriples.java
#Comment:
	/**
	 * <p>Constructor for WindowTriples.</p>
	 *
	 * @param numberOfTriples a int.
	 */

#Code:
	public WindowTriples(final int numberOfTriples) {
		if (numberOfTriples < 1) {
			System.err
					.println("X must be >=1 for WINDOW TYPE SLIDINGTRIPLES X");
			System.err.println("Assuming WINDOW TYPE SLIDINGTRIPLES 1...");
			this.numberOfTriples = 1;
		} else
			this.numberOfTriples = numberOfTriples;
	}

#end
#end
#No. 185166
#File: E:\bishe\1\WindowVisibility.java
#Comment:
    /**
     * p_slider_no is required to identify the number of the slider in slider_arr.
     */

#Code:
    private class SliderChangeListener implements javax.swing.event.ChangeListener
    {
        public SliderChangeListener(int p_slider_no)
        {
            slider_no = p_slider_no;
        }
        public void stateChanged(javax.swing.event.ChangeEvent evt)
        {
            int new_visibility = slider_arr[slider_no].getValue();
            set_changed_value(slider_no, ((double) new_visibility) / ((double)MAX_SLIDER_VALUE));
            board_panel.repaint();
        }
        
        public int slider_no;
    }



#end
#end
#No. 185169
#File: E:\bishe\1\Winds.java
#Comment:
    /**
     * Check to see if we should show the changelog activity if there are any new changes
     * to the configuration file.
     *
     * @param ctx           the context to launch the activity with
     * @param configId      the changelog configuration xml resource id
     */

#Code:
    public static void checkChangelogActivity(Context ctx, @XmlRes int configId){

        // Parse configuration
        ChangeLog changeLog = Parser.parse(ctx, configId);
        if(changeLog != null){

            // Validate that there is a new version code
            if(validateVersion(ctx, changeLog)) {
                openChangelogActivity(ctx, configId);
            }

        }else{
            throw new NullPointerException("Unable to find a 'Winds' configuration @ " + configId);
        }

#end
#end
#No. 185170
#File: E:\bishe\1\Winds.java
#Comment:
    /**
     * Check to open the changelog activity with the default configuration file R.xml.changelog
     *
     * @param ctx       the context to launch with
     */

#Code:
    public static void checkChangelogActivity(Context ctx){
        checkChangelogActivity(ctx, R.xml.changelog);
    }

#end
#end
#No. 185171
#File: E:\bishe\1\Winds.java
#Comment:
    /**
     * Check to see if we should show the changelog activity if there are any new changes
     * to the configuration file.
     *
     * @param ctx           the context to launch the activity with
     * @param configId      the changelog configuration xml resource id
     */

#Code:
    public static void checkChangelogDialog(Activity ctx, @XmlRes int configId){

        // Parse configuration
        ChangeLog changeLog = Parser.parse(ctx, configId);
        if(changeLog != null){

            // Validate that there is a new version code
            if(validateVersion(ctx, changeLog)) {
                openChangelogDialog(ctx, configId);
            }

        }else{
            throw new NullPointerException("Unable to find a 'Winds' configuration @ " + configId);
        }

#end
#end
#No. 185172
#File: E:\bishe\1\Winds.java
#Comment:
    /**
     * Check to open the changelog activity with the default configuration file R.xml.changelog
     *
     * @param ctx       the context to launch with
     */

#Code:
    public static void checkChangelogDialog(Activity ctx){
        checkChangelogDialog(ctx, R.xml.changelog);
    }

#end
#end
#No. 185173
#File: E:\bishe\1\Winds.java
#Comment:
    /**
     * Validate the last seen stored verion code against the current changelog configuration
     * to see if there is any updates and whether or not we should show the changelog dialog when
     * called.
     *
     * @param ctx
     * @param clog
     * @return
     */

#Code:
    private static boolean validateVersion(Context ctx, ChangeLog clog){

        // Get Preferences
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
        int lastSeen = prefs.getInt(PREF_CHANGELOG_LAST_SEEN, -1);

        // Second sort versions by it's code
        int latest = Integer.MIN_VALUE;
        for(Version version: clog.versions){
            if(version.code > latest){
                latest = version.code;
            }
        }

        // Get applications current version
        if(latest > lastSeen){
            if(!BuildConfig.DEBUG) prefs.edit().putInt(PREF_CHANGELOG_LAST_SEEN, latest).apply();
            return true;
        }

        return false;
    }

#end
#end
#No. 185174
#File: E:\bishe\1\Wine$Type.java
#Comment:
/**
 * Generated by Gfx v3.0.0 (Granite Data Services).
 *
 * WARNING: DO NOT CHANGE THIS FILE. IT MAY BE OVERWRITTEN EACH TIME YOU USE
 * THE GENERATOR.
 */

#Code:

package com.wineshop.client.entities;

import org.granite.client.messaging.RemoteAlias;

@RemoteAlias("com.wineshop.entities.Wine$Type")
public enum Wine$Type {

    RED, 
    WHITE, 
    ROSE
}

#end
#end
#No. 185182
#File: E:\bishe\1\WineTastingAdapter.java
#Comment:
    /**
     * Adds a tasting object to the list.
     * @param aTasting The tasting object to add.
     */

#Code:
    public void addTasting(WineTasting aTasting) {
        mTastings.add(aTasting);
        notifyDataSetChanged();
    }

#end
#end
#No. 185191
#File: E:\bishe\1\WinHttpCurrentUserIEProxyConfig.java
#Comment:
	/**
	 * Create WinHttpCurrentUserIeProxyConfig structure cast onto pre-allocated
	 * memory.
	 * 
	 * @param pointer
	 *            pointer to pre-allocated memory
	 */

#Code:
	public WinHttpCurrentUserIEProxyConfig(Pointer pointer) {
		super(pointer);
		read();
	}

#end
#end
#No. 185192
#File: E:\bishe\1\WinHttpCurrentUserIEProxyConfig.java
#Comment:
	/**
	 * Return this Structure's field names in their proper order. For example,
	 * 
	 * <pre>
	 * <code>
	 * protected List getFieldOrder() {
	 *     return Arrays.asList(new String[] { ... });
	 * }
	 * </code>
	 * </pre>
	 * 
	 * <strong>IMPORTANT</strong> When deriving from an existing Structure
	 * subclass, ensure that you augment the list provided by the superclass,
	 * e.g.
	 * 
	 * <pre>
	 * <code>
	 * protected List getFieldOrder() {
	 *     List fields = new ArrayList(super.getFieldOrder());
	 *     fields.addAll(Arrays.asList(new String[] { ... }));
	 *     return fields;
	 * }
	 * </code>
	 * </pre>
	 *
	 * Field order must be explicitly indicated, since the field order as
	 * returned by {@link Class#getFields()} is not guaranteed to be
	 * predictable.
	 * 
	 * @return ordered list of field names
	 */

#Code:
	@Override
	protected List<String> getFieldOrder() {
		return Arrays.asList("fAutoDetect", "lpszAutoConfigUrl", "lpszProxy", "lpszProxyBypass");
	}


#end
#end
#No. 185194
#File: E:\bishe\1\WinHttpProxyInfo.java
#Comment:
	/**
	 * Create WinHttpProxyInfo structure cast onto pre-allocated memory.
	 * 
	 * @param pointer
	 *            pointer to pre-allocated memory
	 */

#Code:
	public WinHttpProxyInfo(Pointer pointer) {
		super(pointer);
		read();
	}

#end
#end
#No. 185195
#File: E:\bishe\1\WinHttpProxyInfo.java
#Comment:
	/**
	 * Return this Structure's field names in their proper order. For example,
	 * 
	 * <pre>
	 * <code>
	 * protected List getFieldOrder() {
	 *     return Arrays.asList(new String[] { ... });
	 * }
	 * </code>
	 * </pre>
	 * 
	 * <strong>IMPORTANT</strong> When deriving from an existing Structure
	 * subclass, ensure that you augment the list provided by the superclass,
	 * e.g.
	 * 
	 * <pre>
	 * <code>
	 * protected List getFieldOrder() {
	 *     List fields = new ArrayList(super.getFieldOrder());
	 *     fields.addAll(Arrays.asList(new String[] { ... }));
	 *     return fields;
	 * }
	 * </code>
	 * </pre>
	 *
	 * Field order must be explicitly indicated, since the field order as
	 * returned by {@link Class#getFields()} is not guaranteed to be
	 * predictable.
	 * 
	 * @return ordered list of field names
	 */

#Code:
	@Override
	protected List<String> getFieldOrder() {
		return Arrays.asList("dwAccessType", "lpszProxy", "lpszProxyBypass");
	}

#end
#end
#No. 185196
#File: E:\bishe\1\WinOptionsTab.java
#Comment:
	/**
	 * Validate all fields on the tab.
	 * 
	 * @return <code>true</code> if all fields on the tab are valid; otherwise
	 *         return <code>false</code>
	 */

#Code:
	private boolean isTabValid() {
		setMessage(Messages.WinOptionsTab_Description);
		setErrorMessage(null);
		// firstly check if there are emulators in the SDK
		if (devices.isEmpty()) {
			setErrorMessage(Messages.WinOptionsTab_NoEmulatorsError);
			return false;
		}
		String projectName = projectText.getText();
		if (projectName.isEmpty()) {
			return false;
		}
		IProject project = ResourcesPlugin.getWorkspace().getRoot()
				.getProject(projectName);
		if (!project.exists()) {
			return false;
		}

		String device = devicesCombo.getText();
		if (device.isEmpty()) {
			return false;
		}
		return true;
	}


#end
#end
#No. 185198
#File: E:\bishe\1\WinProxySearchStrategy.java
#Comment:
	/*************************************************************************
	 * getProxySelector
	 * 
	 * @see com.github.markusbernhardt.proxy.ProxySearchStrategy#getProxySelector()
	 ************************************************************************/

#Code:

	@Override
	public ProxySelector getProxySelector() throws ProxyException {
		// TODO Rossi 08.05.2009 Implement this by using Win API calls.
		// new Win32ProxyUtils().winHttpGetDefaultProxyConfiguration()
		// Current fallback is to use the IE settings. This is better
		// because the registry settings are most of the time not set.
		// Some Windows server installations may use it though.
		return new IEProxySearchStrategy().getProxySelector();
	}

#end
#end
#No. 185199
#File: E:\bishe\1\WinProxySearchStrategy.java
#Comment:
	/*************************************************************************
	 * Gets the printable name of the search strategy.
	 * 
	 * @return the printable name of the search strategy
	 ************************************************************************/

#Code:

	@Override
	public String getName() {
		return "windows";
	}

#end
#end
#No. 185200
#File: E:\bishe\1\WinSrvPlugin.java
#Comment:
    /**
     * Return a File pointing to the location of the Jar file this Main method is executed from.
     * @return
     */

#Code:
    public File getWarLocation() {
        URL resource = WinSrvPlugin.class.getResource("/META-INF/jettyconsole/jettyconsole.properties");
        String file = resource.getFile();
        file = file.substring("file:".length(), file.indexOf("!"));
        try {
            file = URLDecoder.decode(file, "utf-8");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        return new File(file);
    }

#end
#end
#No. 185201
#File: E:\bishe\1\WinstoneResponse.java
#Comment:
	/**
	 * @deprecated
	 */

#Code:
	@Deprecated
	@Override
	public String encodeRedirectUrl(final String url) {
		return encodeRedirectURL(url);
	}

#end
#end
#No. 185202
#File: E:\bishe\1\WinstoneResponse.java
#Comment:
	/**
	 * @deprecated
	 */

#Code:
	@Deprecated
	@Override
	public String encodeUrl(final String url) {
		return encodeURL(url);
	}

#end
#end
#No. 185203
#File: E:\bishe\1\WinstoneResponse.java
#Comment:
	/**
	 * @deprecated
	 */

#Code:
	@Deprecated
	@Override
	public void setStatus(final int sc, final String sm) {
		setStatus(sc);
	}
#end
#end
#No. 185204
#File: E:\bishe\1\WinTabTabletManager.java
#Comment:
		/**
		 * This method is used to determine if the cursor is mapped in relative mode or absolute mode. This can be 
		 * deduced by comparing how close the wintab coordinates are to the actual on-screen cursor coordinates. If they
		 * are wildly off, we can assume the device is in relative mode and we cannot take advantage of the fractional
		 * coordinates provided by wintab.
		 * 
		 * @param tabletScreenX
		 * @param tabletScreenY
		 * @param mouseEvent
		 * @return the mouse position if in relative mode, null if in absolute
		 */

#Code:
		public Point updateRelativeMode(float tabletScreenX, float tabletScreenY, MouseEvent mouseEvent) {
			Point mouseScreen = mouseEvent.getLocationOnScreen();
			float dx = mouseScreen.x - tabletScreenX;
			float dy = mouseScreen.y - tabletScreenY;
			float distance = dx*dx+dy*dy;
			if (distance > 20*20) {
				relativeMode = true;
				absoluteCount = 0;
			} else if (distance < 5*5) {
				// It's possible (but rare) for the coordinates to match up when in relative mode, so we keep track of
				// how long they match before switching off of relative mode
				absoluteCount++;
				if (absoluteCount > 50) {
					relativeMode = false;
				}
			}
			return relativeMode ? mouseScreen : null;
		}

#end
#end
#No. 185206
#File: E:\bishe\1\WintInnerHackBase64.java
#Comment:
    /**
     * Tests a given byte array to see if it contains
     * only valid characters within the WintInnerHackBase64 alphabet.
     *
     * @param arrayOctect byte array to test
     * @return true if all bytes are valid characters in the WintInnerHackBase64
     *         alphabet or if the byte array is empty; false, otherwise
     */

#Code:
    public static boolean isArrayByteBase64(byte[] arrayOctect) {

        arrayOctect = discardWhitespace(arrayOctect);

        int length = arrayOctect.length;
        if (length == 0) {
            // shouldn't a 0 length array be valid base64 data?
            // return false;
            return true;
        }
        for (int i = 0; i < length; i++) {
            if (!isBase64(arrayOctect[i])) {
                return false;
            }
        }
        return true;
    }

#end
#end
#No. 185207
#File: E:\bishe\1\WintInnerHackBase64.java
#Comment:
    /**
     * Encodes binary data using the base64 algorithm but
     * does not chunk the output.
     *
     * @param binaryData binary data to encode
     * @return WintInnerHackBase64 characters
     */

#Code:
    public static byte[] encodeBase64(byte[] binaryData) {
        return encodeBase64(binaryData, false);
    }

#end
#end
#No. 185208
#File: E:\bishe\1\WintInnerHackBase64.java
#Comment:
    /**
     * Encodes binary data using the base64 algorithm and chunks
     * the encoded output into 76 character blocks
     *
     * @param binaryData binary data to encode
     * @return WintInnerHackBase64 characters chunked in 76 character blocks
     */

#Code:
    public static byte[] encodeBase64Chunked(byte[] binaryData) {
        return encodeBase64(binaryData, true);
    }

#end
#end
#No. 185209
#File: E:\bishe\1\WintInnerHackBase64.java
#Comment:
    /**
     * Decodes a byte[] containing containing
     * characters in the WintInnerHackBase64 alphabet.
     *
     * @param pArray A byte array containing WintInnerHackBase64 character data
     * @return a byte array containing binary data
     */

#Code:
    public byte[] decode(byte[] pArray) {
        return decodeBase64(pArray);
    }

#end
#end
#No. 185210
#File: E:\bishe\1\WintInnerHackBase64.java
#Comment:
    /**
     * Discards any whitespace from a base-64 encoded block.
     *
     * @param data The base-64 encoded data to discard the whitespace
     * from.
     * @return The data, less whitespace (see RFC 2045).
     */

#Code:
    static byte[] discardWhitespace(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;
        
        for (int i = 0; i < data.length; i++) {
            switch (data[i]) {
            case (byte) ' ' :
            case (byte) '\n' :
            case (byte) '\r' :
            case (byte) '\t' :
                    break;
            default:
                    groomedData[bytesCopied++] = data[i];
            }
        }

        byte packedData[] = new byte[bytesCopied];

        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);

        return packedData;
    }

#end
#end
#No. 185211
#File: E:\bishe\1\WintInnerHackBase64.java
#Comment:
    /**
     * Discards any characters outside of the base64 alphabet, per
     * the requirements on page 25 of RFC 2045 - "Any characters
     * outside of the base64 alphabet are to be ignored in base64
     * encoded data."
     *
     * @param data The base-64 encoded data to groom
     * @return The data, less non-base64 characters (see RFC 2045).
     */

#Code:
    static byte[] discardNonBase64(byte[] data) {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;

        for (int i = 0; i < data.length; i++) {
            if (isBase64(data[i])) {
                groomedData[bytesCopied++] = data[i];
            }
        }

        byte packedData[] = new byte[bytesCopied];

        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);

        return packedData;
    }

#end
#end
#No. 185212
#File: E:\bishe\1\WintInnerHackBase64.java
#Comment:
    /**
     * Encodes a byte[] containing binary data, into a byte[] containing
     * characters in the WintInnerHackBase64 alphabet.
     *
     * @param pArray a byte array containing binary data
     * @return A byte array containing only WintInnerHackBase64 character data
     */

#Code:
    public byte[] encode(byte[] pArray) {
        return encodeBase64(pArray, false);
    }

#end
#end
#No. 185213
#File: E:\bishe\1\WinUI.java
#Comment:
	/**
	 * Returns the shared instance
	 * 
	 * @return the shared instance
	 */

#Code:
	public static WinUI getDefault() {
		return plugin;
	}

#end
#end
#No. 185214
#File: E:\bishe\1\WipeMIDlet.java
#Comment:
	/**
	 * Creates several screens and navigates between them.
	 */

#Code:
	public WipeMIDlet() 	
	{
		
		UIManager.init(this);
		 UIManager.setTheme( new ClearTheme()  );

		 _form = new WipeManualForm(this);
		
	}


#end
#end
#No. 185216
#File: E:\bishe\1\WipePreferences.java
#Comment:
		/*
		 *  If this activity is started with preconfigured user preferences,
		 *  (which would be passed in as a bundle)
		 *  we must automatically populate them here
		 */

#Code:
		try {
			if(getIntent().getSerializableExtra(ITCConstants.Preference.WIPE_SELECTOR) != null) {
				Map<Integer,Boolean> wipePreferences = 
					((ArrayList<Map<Integer,Boolean>>) getIntent().getSerializableExtra(ITCConstants.Preference.WIPE_SELECTOR)).get(0);
				
				defaultContacts = wipePreferences.get(ITCConstants.Wipe.CONTACTS);
				defaultPhotos = wipePreferences.get(ITCConstants.Wipe.PHOTOS);
				defaultCallLog = wipePreferences.get(ITCConstants.Wipe.CALLLOG);
				defaultSMS = wipePreferences.get(ITCConstants.Wipe.SMS);
				defaultCalendar = wipePreferences.get(ITCConstants.Wipe.CALENDAR);
				defaultSDCard = wipePreferences.get(ITCConstants.Wipe.SDCARD);
				
				if(
					defaultContacts == true ||
					defaultPhotos == true ||
					defaultCallLog == true ||
					defaultSMS == true ||
					defaultCalendar == true ||
					defaultSDCard == true
				)
					defaultNone = false;
			}
			
			wipeOptions.add(new WipeSelector(
					getResources().getString(R.string.KEY_NONE),
					ITCConstants.Wipe.NONE,
					defaultNone
			));
		} catch(NullPointerException e) {}







#end
#end
#No. 185222
#File: E:\bishe\1\WireMillRecipes.java
#Comment:
    /**
     * Adds a drawing recipe.
     * 
     * @param input
     *            As an ItemStack
     * @param output
     *            As an ItemStack
     * @param ticks
     *            The ticks required for the recipe, seconds * 20.
     */

#Code:
    public void addProcessing(ItemStack input, ItemStack output, int ticks)
    {
        try
        {
            if (input != null && output != null && ticks > 0)
            {
                int nextRecipeID = this.recipeToOutput.size();
                this.inputToRecipe.put(stackSizeToOne(input) + "", nextRecipeID);
                this.recipeToInput.put(nextRecipeID, stackSizeToOne(input));
                this.recipeToOutput.put(nextRecipeID, output);
                this.recipeToTicks.put(nextRecipeID, ticks);
                this.recipeToInputQTY.put(nextRecipeID, input.stackSize);
            }
            else if (input == null)
                throw new IOException("Error: Input cannot be null.");
            else if (output == null)
                throw new IOException("Error: Output cannot be null.");
            else if (ticks <= 0)
                throw new IOException("Error: Ticks must be greater than 0.");
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }

#end
#end
#No. 185223
#File: E:\bishe\1\WireMillRecipes.java
#Comment:
    /**
     * Adds a drawing recipe.
     * 
     * @param input
     *            As Forge Ore-Dict. ID
     * @param output
     *            As an ItemStack
     * @param ticks
     *            The ticks required for the recipe, seconds * 20.
     */

#Code:
    public void addProcessing(String input, ItemStack output, int ticks)
    {
        for (ItemStack input2 : OreDictionary.getOres(input))
        {
            this.addProcessing(input2, output, ticks);
        }
    }

#end
#end
#No. 185224
#File: E:\bishe\1\WireMillRecipes.java
#Comment:
    /**
     * Used to get the resulting ItemStack from a source ItemStack Don't check
     * unless Electric Expansion is loaded and this has recipes registered.
     * 
     * @param item
     *            The Source ItemStack
     * @return The result ItemStack, null if the input is invalid
     */

#Code:
    public ItemStack getDrawingResult(ItemStack input)
    {
        try
        {
            int recipeID = 0;
            recipeID = this.inputToRecipe.get(stackSizeToOne(input) + "");
            if (input.stackSize >= this.recipeToInputQTY.get(recipeID))
                return this.recipeToOutput.get(recipeID);
            else
                return null;
        }
        catch (NullPointerException e)
        {
            return null;
        }
    }

#end
#end
#No. 185225
#File: E:\bishe\1\WireMillRecipes.java
#Comment:
    /**
     * Used to get the required ticks for a source ItemStack
     * 
     * @param item
     *            The Source ItemStack
     * @return The processing time, in ticks
     */

#Code:
    public Integer getDrawingTicks(ItemStack input)
    {
        try
        {
            int recipeID = 0;
            recipeID = this.inputToRecipe.get(stackSizeToOne(input) + "");
            if (input.stackSize >= this.recipeToInputQTY.get(recipeID))
                return this.recipeToTicks.get(recipeID);
            else
                return 0;
        }
        catch (NullPointerException e)
        {
            return 0;
        }
    }

#end
#end
#No. 185226
#File: E:\bishe\1\WireMillRecipes.java
#Comment:
    /**
     * 
     * @param i
     *            An ItemStack
     * @return The ItemStack, with StackSize set to 1
     */

#Code:
    public static ItemStack stackSizeToOne(ItemStack i)
    {
        if (i != null)
            return new ItemStack(i.itemID, 1, i.getItemDamage());
        else
            return null;
    }

#end
#end
#No. 185227
#File: E:\bishe\1\WireMillRecipes.java
#Comment:
    /**
     * A helper method for getting the recipes for NEI
     * 
     * @return Map<inputItemStack, int[]> int[] is (0:ID of output; 1:
     *         StackSize; 2: Metadata; 3: ticksRequired) requiredEnergy =
     *         ticksRequired *
     *         {@link electricexpansion.common.tile.TileEntityWireMill#WATTS_PER_TICK
     *         WATTS_PER_TICK}
     */

#Code:
    public Map<ItemStack, int[]> getRecipesForNEI()
    {
        Map<ItemStack, int[]> recipes = new HashMap<ItemStack, int[]>();
        for (int i = 0; i < this.recipeToInput.size(); i++)
        {
            ItemStack input = stackSizeChange(this.recipeToInput.get(i), this.recipeToInputQTY.get(i));
            int[] output = { this.recipeToOutput.get(i).itemID, this.recipeToOutput.get(i).stackSize, this.recipeToOutput.get(i).getItemDamage(), this.getDrawingTicks(input) };
            recipes.put(input, output);
        }
        return recipes;
    }

#end
#end
#No. 185228
#File: E:\bishe\1\WireMockActivityInstrumentationTestCase2.java
#Comment:
    /**
     * Test WireMock
     */

#Code:
    @Test
    public void testWiremock() {
        activity = activityRule.getActivity();
        String jsonBody = asset(activity, "atlanta-conditions.json");
        stubFor(get(urlMatching("/api/.*"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody(jsonBody)));

        String serviceEndpoint = "http://127.0.0.1:" + BuildConfig.PORT;
        logger.debug("WireMock Endpoint: " + serviceEndpoint);
        activity.setWeatherServiceManager(new WeatherServiceManager(serviceEndpoint));

        onView(ViewMatchers.withId(R.id.editText)).perform(typeText("atlanta"));
        onView(withId(R.id.button)).perform(click());
        onView(withId(R.id.textView)).check(matches(withText(containsString("GA"))));
    }

#end
#end
#No. 185229
#File: E:\bishe\1\WireMockAndroidTest1.java
#Comment:
    /**
     * Test WireMock
     */

#Code:
    @Test
    public void testWiremock() {
        Context applicationContext = InstrumentationRegistry.getTargetContext().getApplicationContext();
        activity = activityRule.launchActivity(new Intent(applicationContext, MainActivity.class));
        String jsonBody = asset(activity, "atlanta-conditions.json");
        stubFor(get(urlMatching("/api/.*"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody(jsonBody)));

        String serviceEndpoint = "http://127.0.0.1:" + BuildConfig.PORT;
        logger.debug("WireMock Endpoint: " + serviceEndpoint);
        activity.setWeatherServiceManager(new WeatherServiceManager(serviceEndpoint));

        onView(ViewMatchers.withId(R.id.editText)).perform(typeText("atlanta"));
        onView(withId(R.id.button)).perform(click());
        onView(withId(R.id.textView)).check(matches(withText(containsString("GA"))));
    }

#end
#end
#No. 185230
#File: E:\bishe\1\WireMockAndroidTest2.java
#Comment:
    /**
     * Test WireMock
     */

#Code:
    @Test
    public void testWiremock() {
        Context applicationContext = InstrumentationRegistry.getTargetContext().getApplicationContext();
        activity = activityRule.launchActivity(new Intent(applicationContext, MainActivity.class));
        String jsonBody = asset(activity, "atlanta-conditions.json");
        stubFor(get(urlMatching("/api/.*"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody(jsonBody)));

        String serviceEndpoint = "http://127.0.0.1:" + BuildConfig.PORT;
        logger.debug("WireMock Endpoint: " + serviceEndpoint);
        activity.setWeatherServiceManager(new WeatherServiceManager(serviceEndpoint));

        onView(ViewMatchers.withId(R.id.editText)).perform(typeText("atlanta"));
        onView(withId(R.id.button)).perform(click());
        onView(withId(R.id.textView)).check(matches(withText(containsString("GA"))));
    }

#end
#end
#No. 185231
#File: E:\bishe\1\WireMockApplicationTestCase.java
#Comment:
    /**
     * The @Rule - WireMockRule does NOT currently work for the ApplicationTestCase because it is not based on JUnit3 and not JUnit4 so we need to create & manage the WireMockServer ourselves
     * <p/>
     * As of 09.09.2015 - "To test an Android application object on the Android runtime you use the ApplicationTestCase class.
     * It is expected that Google will soon provide a special JUnit4 rule for testing the application object but at the moment his is not yet available."
     * <p/>
     * Reference: http://www.vogella.com/tutorials/AndroidTesting/article.html
     */

#Code:
    WireMockServer wireMockServer = new WireMockServer(BuildConfig.PORT);

    @Before
    public void setUp() {
        applicationContext = InstrumentationRegistry.getTargetContext().getApplicationContext();
        wireMockServer.start();
    }

#end
#end
#No. 185232
#File: E:\bishe\1\WireMockApplicationTestCase.java
#Comment:
    /**
     * Test WireMock, but just the Http Call.  Make sure the response matches the mock we want.
     */

#Code:
    @Test
    public void testWiremockPlusOkHttp() throws IOException {
        logger.debug("testWiremockPlusOkHttp");

        String uri = "/api/840dbdf2737a7ff9/conditions/q/CA/atlanta.json";

        String jsonBody = asset(applicationContext, "atlanta-conditions.json");
        assertFalse(jsonBody.isEmpty());
        wireMockServer.stubFor(get(urlMatching(uri))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withBody(jsonBody)));

        String serviceEndpoint = "http://127.0.0.1:" + BuildConfig.PORT;
        logger.debug("WireMock Endpoint: " + serviceEndpoint);

        OkHttpClient okHttpClient = new OkHttpClient();
        Request request = new Request.Builder()
                .url(serviceEndpoint + uri)
                .build();

        Response response = okHttpClient.newCall(request).execute();

        assertEquals(jsonBody, response.body().string());
    }

#end
#end
#No. 185234
#File: E:\bishe\1\WireMockApplicationTestCase2.java
#Comment:
    /**
     * Test WireMock, but just the Http Call.  Make sure the response matches the mock we want.
     */

#Code:
    public void testWiremockPlusOkHttp() throws IOException {
        logger.debug("testWiremockPlusOkHttp");

        String serviceEndpoint = "http://127.0.0.1:" + BuildConfig.PORT;
        logger.debug("WireMock Endpoint: " + serviceEndpoint);

        OkHttpClient okHttpClient = InjectionFactory.buildOkhttpClient();

        String uri = "/hello-world";
        Request request = new Request.Builder()
                .url(serviceEndpoint + uri)
                .build();

        Response response = okHttpClient.newCall(request).execute();

        String responseBodyStr = response.body().string();

        logger.debug("Response Body: " + responseBodyStr);
        assertEquals("hello world", responseBodyStr);
    }

#end
#end
#No. 185235
#File: E:\bishe\1\WireMockBinaryAssetsTestCase.java
#Comment:
//    /**
//     * Test WireMock
//     */

#Code:
//    @Test
//    public void testWiremock() {
//        String jsonBody = asset(activity, "atlanta-conditions.json");
//        stubFor(get(urlMatching("/api/.*"))
//                .willReturn(aResponse()
//                        .withStatus(200)
//                        .withBody(jsonBody)));
//
//        String serviceEndpoint = "http://127.0.0.1:" + BuildConfig.PORT;
//        logger.debug("WireMock Endpoint: " + serviceEndpoint);
//        activity.setWeatherServiceManager(new WeatherServiceManager(serviceEndpoint));
//
//        onView(ViewMatchers.withId(R.id.editText)).perform(typeText("atlanta"));
//        onView(withId(R.id.button)).perform(click());
//        onView(withId(R.id.textView)).check(matches(withText(containsString("GA"))));
//    }


#end
#end
#No. 185237
#File: E:\bishe\1\WireMockTest.java
#Comment:
/**
 * Test class annotation enabling a WireMock server in a spring integration
 * test.
 * 
 * As a result the following actions are performed.
 * 
 * <li>A bean of type {@link WireMockServer} gets put into the application
 * context.
 * <li>The WireMock server gets started once before running your test class.
 * <li>All feign/ribbon-based services get pre-configured to use the WireMock
 * server.
 * <li>A new <tt>wiremock.port</tt> property is set to the port WireMock is
 * running on.
 * 
 * @see WireMockServer
 * 
 */

#Code:
@Retention(RetentionPolicy.RUNTIME)
@Documented
//@Import({ WireMockAutoConfiguration.class })
@Target({ ElementType.TYPE, ElementType.METHOD })
public @interface WireMockTest {

	/**
	 * List the names of your ribbon/feign based services. These will be
	 * auto-configured to use the WireMock server as endpoint.
	 */
	String[] ribbonServices() default {};

	/**
	 * Set this property to the root folder of your JSON stubs. This folder gets
	 * looked up on the classpath and can be overwritten on a per-test basis, by
	 * repeating the {@link WireMockTest} annotation on method level.
	 */
	String stubPath() default "";

	/**
	 * Sets WireMock to a fixed port. By default WireMock is started on a dynamic port.
	 */
	int port() default 0;
}

#end
#end
#No. 185239
#File: E:\bishe\1\WishListResource.java
#Comment:
    /**
     * PUT  /wish-lists : Updates an existing wishList.
     *
     * @param wishList the wishList to update
     * @return the ResponseEntity with status 200 (OK) and with body the updated wishList,
     * or with status 400 (Bad Request) if the wishList is not valid,
     * or with status 500 (Internal Server Error) if the wishList couldnt be updated
     * @throws URISyntaxException if the Location URI syntax is incorrect
     */

#Code:
    @PutMapping("/wish-lists")
    @Timed
    public ResponseEntity<WishList> updateWishList(@Valid @RequestBody WishList wishList) throws URISyntaxException {
        log.debug("REST request to update WishList : {}", wishList);
        if (wishList.getId() == null) {
            return createWishList(wishList);
        }
        WishList result = wishListRepository.save(wishList);
        return ResponseEntity.ok()
            .headers(HeaderUtil.createEntityUpdateAlert("wishList", wishList.getId().toString()))
            .body(result);
    }

#end
#end
#No. 185240
#File: E:\bishe\1\WishListResource.java
#Comment:
    /**
     * GET  /wish-lists : get all the wishLists.
     *
     * @return the ResponseEntity with status 200 (OK) and the list of wishLists in body
     */

#Code:
    @GetMapping("/wish-lists")
    @Timed
    public List<WishList> getAllWishLists() {
        log.debug("REST request to get all WishLists");
        List<WishList> wishLists = wishListRepository.findAll();
        return wishLists;
    }

#end
#end
#No. 185241
#File: E:\bishe\1\WishListResource.java
#Comment:
    /**
     * GET  /wish-lists/:id : get the "id" wishList.
     *
     * @param id the id of the wishList to retrieve
     * @return the ResponseEntity with status 200 (OK) and with body the wishList, or with status 404 (Not Found)
     */

#Code:
    @GetMapping("/wish-lists/{id}")
    @Timed
    public ResponseEntity<WishList> getWishList(@PathVariable Long id) {
        log.debug("REST request to get WishList : {}", id);
        WishList wishList = wishListRepository.findOne(id);
        return Optional.ofNullable(wishList)
            .map(result -> new ResponseEntity<>(
                result,
                HttpStatus.OK))
            .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

#end
#end
#No. 185242
#File: E:\bishe\1\WishListResource.java
#Comment:
    /**
     * DELETE  /wish-lists/:id : delete the "id" wishList.
     *
     * @param id the id of the wishList to delete
     * @return the ResponseEntity with status 200 (OK)
     */

#Code:
    @DeleteMapping("/wish-lists/{id}")
    @Timed
    public ResponseEntity<Void> deleteWishList(@PathVariable Long id) {
        log.debug("REST request to delete WishList : {}", id);
        wishListRepository.delete(id);
        return ResponseEntity.ok().headers(HeaderUtil.createEntityDeletionAlert("wishList", id.toString())).build();
    }

#end
#end
#No. 185243
#File: E:\bishe\1\WishResource.java
#Comment:
    /**
     * PUT  /wishes : Updates an existing wish.
     *
     * @param wish the wish to update
     * @return the ResponseEntity with status 200 (OK) and with body the updated wish,
     * or with status 400 (Bad Request) if the wish is not valid,
     * or with status 500 (Internal Server Error) if the wish couldnt be updated
     * @throws URISyntaxException if the Location URI syntax is incorrect
     */

#Code:
    @PutMapping("/wishes")
    @Timed
    public ResponseEntity<Wish> updateWish(@Valid @RequestBody Wish wish) throws URISyntaxException {
        log.debug("REST request to update Wish : {}", wish);
        if (wish.getId() == null) {
            return createWish(wish);
        }
        Wish result = wishService.save(wish);
        return ResponseEntity.ok()
            .headers(HeaderUtil.createEntityUpdateAlert("wish", wish.getId().toString()))
            .body(result);
    }

#end
#end
#No. 185244
#File: E:\bishe\1\WishResource.java
#Comment:
    /**
     * GET  /wishes : get all the wishes.
     *
     * @param pageable the pagination information
     * @return the ResponseEntity with status 200 (OK) and the list of wishes in body
     * @throws URISyntaxException if there is an error to generate the pagination HTTP headers
     */

#Code:
    @GetMapping("/wishes")
    @Timed
    public ResponseEntity<List<Wish>> getAllWishes(Pageable pageable)
        throws URISyntaxException {
        log.debug("REST request to get a page of Wishes");
        Page<Wish> page = wishService.findAll(pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(page, "/api/wishes");
        return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
    }

#end
#end
#No. 185245
#File: E:\bishe\1\WishResource.java
#Comment:
    /**
     * GET  /wishes/:id : get the "id" wish.
     *
     * @param id the id of the wish to retrieve
     * @return the ResponseEntity with status 200 (OK) and with body the wish, or with status 404 (Not Found)
     */

#Code:
    @GetMapping("/wishes/{id}")
    @Timed
    public ResponseEntity<Wish> getWish(@PathVariable Long id) {
        log.debug("REST request to get Wish : {}", id);
        Wish wish = wishService.findOne(id);
        return Optional.ofNullable(wish)
            .map(result -> new ResponseEntity<>(
                result,
                HttpStatus.OK))
            .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
    }

#end
#end
#No. 185246
#File: E:\bishe\1\WishResource.java
#Comment:
    /**
     * DELETE  /wishes/:id : delete the "id" wish.
     *
     * @param id the id of the wish to delete
     * @return the ResponseEntity with status 200 (OK)
     */

#Code:
    @DeleteMapping("/wishes/{id}")
    @Timed
    public ResponseEntity<Void> deleteWish(@PathVariable Long id) {
        log.debug("REST request to delete Wish : {}", id);
        wishService.delete(id);
        return ResponseEntity.ok().headers(HeaderUtil.createEntityDeletionAlert("wish", id.toString())).build();
    }

#end
#end
#No. 185247
#File: E:\bishe\1\WISPrClient.java
#Comment:
        /**
         * @return Returns the otpPassword.
         */

#Code:
        public String getOtpPassword()
        {
            return otpPassword;
        }

#end
#end
#No. 185248
#File: E:\bishe\1\WISPrClient.java
#Comment:
        /**
         * @return Returns the otpUsername.
         */

#Code:
        public String getOtpUsername()
        {
            return otpUsername;
        }

#end
#end
#No. 185249
#File: E:\bishe\1\WithClasses.java
#Comment:
/**
 * Annotation allowing to specify which classes should be passed to the annotation processor for compilation.
 *
 * @author Hardy Ferentschik
 */

#Code:
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
public @interface WithClasses {
	Class<?>[] value();

	/**
	 * @return an array of classes which should be complied prior to compiling the actual test classes
	 */
	Class<?>[] preCompile() default { };
}

#end
#end
#No. 185250
#File: E:\bishe\1\WithComponentFactory.java
#Comment:
/**
 * Marks a screen as defining a {@link MortarScope}, with a factory class to
 * create its Dagger module.
 *
 * @see org.opensilk.common.mortar.WithComponent
 * @see org.opensilk.common.mortar.ScreenScoper
 */

#Code:
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME)
public @interface WithComponentFactory {
  Class<? extends ComponentFactory> value();
}
}


#end
#end
#No. 185254
#File: E:\bishe\1\WithEntityManager.java
#Comment:
/**
 * Use this annotation when not using the default entity manager. If there are more than one,
 * CDI Query needs to know which one to use for a specific DAO.
 * 
 * @author thomashug
 */

#Code:
@Target(TYPE)
@Retention(RUNTIME)
@Documented
@Inherited
public @interface WithEntityManager {
    Class<? extends Annotation>[] value();
}
}

#end
#end
#No. 185255
#File: E:\bishe\1\WithFactory.java
#Comment:
/**
 * Used by tests of {@link com.google.gwt.place.rebind.PlaceHistoryMapperGenerator}.
 */

#Code:
@WithTokenizers({Tokenizer4.class, Place6.Tokenizer.class})
public interface WithFactory extends
  PlaceHistoryMapperWithFactory<TokenizerFactory> {
}


#end
#end
#No. 185257
#File: E:\bishe\1\WithinCircleQueryPredicate.java
#Comment:
/**
 * This predicate returns {@code true} if a {@link io.sphere.sdk.models.GeoJSON} object
 * is within the circle given by the center and radius in meters.
 *
 * @param <T> the type for which this predicate can be instantiated
 */

#Code:
class WithinCircleQueryPredicate<T> extends QueryModelQueryPredicate<T> {
    private final Point center;
    private final Double radius;

    WithinCircleQueryPredicate(final QueryModel<T> queryModel, final Point center, final Double radius) {
        super(queryModel);
        this.center = center;
        this.radius = radius;
    }

    @Override
    protected String render() {
        return String.format(" within circle(%f, %f, %f)", center.getLongitude(), center.getLatitude(), radius);
    }
}

#end
#end
#No. 185258
#File: E:\bishe\1\WithItem.java
#Comment:
	/**
	 * Matches widgets which contains <code>item(s)</code>, as returned by <code>getItems</code> method, that match
	 * given matcher...i.e CTabFolder with Item with text "xyz"
	 * 
	 * @param itemMatcher the item matcher
	 */

#Code:
	WithItem(Matcher<?> itemMatcher) {
		this.itemMatcher = itemMatcher;
		matches = new ArrayList<T>();
	}

#end
#end
#No. 185259
#File: E:\bishe\1\WithItem.java
#Comment:
	/**
	 * Returns a matcher that matches objects containing an item that matches the matcher.
	 * <p>
	 * <strong>Note:</strong> This invokes getItems method on the object and expects to see an array as a return value.
	 * </p>
	 * 
	 * @param matcher the matcher.
	 * @return a matcher.
	 */

#Code:
	@Factory
	public static <T extends Item> WithItem<T> withItem(Matcher<?> matcher) {
		return new WithItem<T>(matcher);
	}

#end
#end
#No. 185265
#File: E:\bishe\1\WithLongPressFragment.java
#Comment:
        /**
         * create a view from resource Xml file, and hold the view that may be used in displaying data.
         *
         * @param layoutInflater
         */

#Code:
        @Override
        public View createView(LayoutInflater layoutInflater) {
            View view = layoutInflater.inflate(R.layout.with_long_press_list_view_item, null);
            mImageView = (CubeImageView) view.findViewById(R.id.with_long_press_list_image);
            return view;
        }

#end
#end
#No. 185266
#File: E:\bishe\1\WithLongPressFragment.java
#Comment:
        /**
         * using the held views to display data
         *
         * @param position
         * @param itemData
         */

#Code:
        @Override
        public void showData(int position, String itemData) {
            mImageView.loadImage(mImageLoader, itemData);
        }

#end
#end
#No. 185268
#File: E:\bishe\1\WithModule.java
#Comment:
/**
 * Marks a screen as defining a {@link MortarScope}, with the class of a Dagger module
 * to instantiate via reflection. The module must be a static type with a default
 * constructor. For more flexibility, use {@link WithModuleFactory}.
 *
 * @see ScreenScoper
 */

#Code:
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME)
public @interface WithModule {
  Class<?> value();
}
}

#end
#end
#No. 185269
#File: E:\bishe\1\WithModuleFactory.java
#Comment:
/**
 * Marks a screen as defining a {@link MortarScope}, with a factory class to
 * create its Dagger module.
 *
 * @see WithModule
 * @see ScreenScoper
 */

#Code:
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME)
public @interface WithModuleFactory {
  Class<? extends ModuleFactory> value();
}
}

#end
#end
#No. 185270
#File: E:\bishe\1\WithNameCqlGenerator.java
#Comment:
	/**
	 * Convenient synonymous method of {@link #getSpecification()}.
	 */

#Code:
	protected T spec() {
		return getSpecification();
	}


#end
#end
#No. 185273
#File: E:\bishe\1\WithPlugins.java
#Comment:
/**
 * @deprecated Use dependency injection with Play 2.4 instead of plugins
 */

#Code:
@Deprecated
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface WithPlugins {
  String[] value() default {};
}

#end
#end
#No. 185279
#File: E:\bishe\1\WizardDatasourceController.java
#Comment:
  /**
   * @return the datasourceMessages
   */

#Code:
  public DatasourceMessages getDatasourceMessages() {
    return datasourceMessages;
  }

#end
#end
#No. 185280
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Creates the checkbox tree and list for selecting resources.
	 * @param parent
	 *            the parent control
	 */

#Code:
	protected final void createResourcesGroup(Composite parent) {

		// create the input element, which has the root resource
		// as its only child
		List input = new ArrayList();
		IProject[] projects = ResourcesPlugin.getWorkspace().getRoot().getProjects();
		for (int i = 0; i < projects.length; i++) {
			if (projects[i].isOpen()) {
				input.add(projects[i]);
			}
		}

		this.resourceGroup = new ResourceTreeAndListGroup(parent, input, getResourceProvider(IResource.FOLDER
				| IResource.PROJECT), WorkbenchLabelProvider.getDecoratingWorkbenchLabelProvider(),
				getResourceProvider(IResource.FILE), WorkbenchLabelProvider.getDecoratingWorkbenchLabelProvider(),
				SWT.NONE, DialogUtil.inRegularFontMode(parent));

		ICheckStateListener listener = new ICheckStateListener() {
			public void checkStateChanged(CheckStateChangedEvent event) {
				updateWidgetEnablements();
			}
		};

		this.resourceGroup.addCheckStateListener(listener);
	}

#end
#end
#No. 185281
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/*
	 * @see WizardDataTransferPage.getErrorDialogTitle()
	 */

#Code:
	protected String getErrorDialogTitle() {
		return IDEWorkbenchMessages.WizardExportPage_errorDialogTitle;
	}



#end
#end
#No. 185283
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Returns a new subcollection containing only those resources which are not local.
	 * @param originalList
	 *            the original list of resources (element type: <code>IResource</code>)
	 * @return the new list of non-local resources (element type: <code>IResource</code>)
	 */

#Code:
	protected List extractNonLocalResources(List originalList) {
		Vector result = new Vector(originalList.size());
		Iterator resourcesEnum = originalList.iterator();

		while (resourcesEnum.hasNext()) {
			IResource currentResource = (IResource) resourcesEnum.next();
			if (!currentResource.isLocal(IResource.DEPTH_ZERO)) {
				result.addElement(currentResource);
			}
		}

		return result;
	}

#end
#end
#No. 185284
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Returns a content provider for <code>IResource</code>s that returns only children of the given resource type.
	 */

#Code:
	private ITreeContentProvider getResourceProvider(final int resourceType) {
		return new WorkbenchContentProvider() {
			public Object[] getChildren(Object o) {
				if (o instanceof IContainer) {
					IResource[] members = null;
					try {
						members = ((IContainer) o).members();
					} catch (CoreException e) {
						// just return an empty set of children
						return new Object[0];
					}

					// filter out the desired resource types
					ArrayList results = new ArrayList();
					for (int i = 0; i < members.length; i++) {
						if (members[i].getName().equals(".config") || members[i].getName().equals(".project") ||members[i].getName().equalsIgnoreCase(".temp") ) {
							defaultExportItems.add(members[i]);
							continue;
						}
						// And the test bits with the resource types to see if they are what we want
						if ((members[i].getType() & resourceType) > 0) {
							results.add(members[i]);
						}
					}
					return results.toArray();
				}
				// input element case
				if (o instanceof ArrayList) {
					return ((ArrayList) o).toArray();
				}
				return new Object[0];
			}
		};
	}

#end
#end
#No. 185285
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Returns this page's collection of currently-specified resources to be exported. This is the primary resource
	 * selection facility accessor for subclasses.
	 * @return a collection of resources currently selected for export (element type: <code>IResource</code>)
	 */

#Code:
	protected List getSelectedResources() {
		Iterator resourcesToExportIterator = this.getSelectedResourcesIterator();
		List resourcesToExport = new ArrayList();
		while (resourcesToExportIterator.hasNext()) {
			resourcesToExport.add(resourcesToExportIterator.next());
		}
		return resourcesToExport;
	}

#end
#end
#No. 185286
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Returns this page's collection of currently-specified resources to be exported. This is the primary resource
	 * selection facility accessor for subclasses.
	 * @return an iterator over the collection of resources currently selected for export (element type:
	 *         <code>IResource</code>). This will include white checked folders and individually checked files.
	 */

#Code:
	protected Iterator getSelectedResourcesIterator() {
		return this.resourceGroup.getAllCheckedListItems().iterator();
	}

#end
#end
#No. 185287
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Returns the resource extensions currently specified to be exported.
	 * @return the resource extensions currently specified to be exported (element type: <code>String</code>)
	 */

#Code:
	protected List getTypesToExport() {

		return selectedTypes;
	}

#end
#end
#No. 185288
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Returns this page's collection of currently-specified resources to be exported. This returns both folders and
	 * files - for just the files use getSelectedResources.
	 * @return a collection of resources currently selected for export (element type: <code>IResource</code>)
	 */

#Code:
	protected List getWhiteCheckedResources() {

		return this.resourceGroup.getAllWhiteCheckedItems();
	}

#end
#end
#No. 185289
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Queries the user for the types of resources to be exported and selects them in the checkbox group.
	 */

#Code:
	protected void handleTypesEditButtonPressed() {
		Object[] newSelectedTypes = queryResourceTypesToExport();

		if (newSelectedTypes != null) { // ie.- did not press Cancel
			this.selectedTypes = new ArrayList(newSelectedTypes.length);
			for (int i = 0; i < newSelectedTypes.length; i++) {
				this.selectedTypes.add(newSelectedTypes[i]);
			}
			setupSelectionsBasedOnSelectedTypes();
		}

	}

#end
#end
#No. 185290
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Returns whether the extension of the given resource name is an extension that has been specified for export by
	 * the user.
	 * @param resourceName
	 *            the resource name
	 * @return <code>true</code> if the resource name is suitable for export based upon its extension
	 */

#Code:
	protected boolean hasExportableExtension(String resourceName) {
		if (selectedTypes == null) {
			return true;
		}

		int separatorIndex = resourceName.lastIndexOf("."); //$NON-NLS-1$
		if (separatorIndex == -1) {
			return false;
		}

		String extension = resourceName.substring(separatorIndex + 1);

		Iterator it = selectedTypes.iterator();
		while (it.hasNext()) {
			if (extension.equalsIgnoreCase((String) it.next())) {
				return true;
			}
		}

		return false;
	}

#end
#end
#No. 185291
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Queries the user for the resource types that are to be exported and returns these types as an array.
	 * @return the resource types selected for export (element type: <code>String</code>), or <code>null</code> if the
	 *         user canceled the selection
	 */

#Code:
	protected Object[] queryResourceTypesToExport() {

		TypeFilteringDialog dialog = new TypeFilteringDialog(getContainer().getShell(), getTypesToExport());

		dialog.open();

		return dialog.getResult();
	}

#end
#end
#No. 185292
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Persists resource specification control setting that are to be restored in the next instance of this page.
	 * Subclasses wishing to persist additional setting for their controls should extend hook method
	 * <code>internalSaveWidgetValues</code>.
	 */

#Code:
	protected void saveWidgetValues() {

		// allow subclasses to save values
		internalSaveWidgetValues();

	}

#end
#end
#No. 185293
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Set the initial selections in the resource group.
	 */

#Code:
	protected void setupBasedOnInitialSelections() {

		Iterator it = this.initialResourceSelection.iterator();
		while (it.hasNext()) {
			IResource currentResource = (IResource) it.next();
			if (currentResource.getType() == IResource.FILE) {
				this.resourceGroup.initialCheckListItem(currentResource);
			} else {
				this.resourceGroup.initialCheckTreeItem(currentResource);
			}
		}
	}

#end
#end
#No. 185294
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Update the tree to only select those elements that match the selected types
	 */

#Code:
	private void setupSelectionsBasedOnSelectedTypes() {

		Runnable runnable = new Runnable() {
			public void run() {
				Map selectionMap = new Hashtable();
				// Only get the white selected ones
				Iterator resourceIterator = resourceGroup.getAllWhiteCheckedItems().iterator();
				while (resourceIterator.hasNext()) {
					// handle the files here - white checked containers require recursion
					IResource resource = (IResource) resourceIterator.next();
					if (resource.getType() == IResource.FILE) {
						if (hasExportableExtension(resource.getName())) {
							List resourceList = new ArrayList();
							IContainer parent = resource.getParent();
							if (selectionMap.containsKey(parent)) {
								resourceList = (List) selectionMap.get(parent);
							}
							resourceList.add(resource);
							selectionMap.put(parent, resourceList);
						}
					} else {
						setupSelectionsBasedOnSelectedTypes(selectionMap, (IContainer) resource);
					}
				}
				resourceGroup.updateSelections(selectionMap);
			}
		};

		BusyIndicator.showWhile(getShell().getDisplay(), runnable);

	}

#end
#end
#No. 185295
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Set up the selection values for the resources and put them in the selectionMap. If a resource is a file see if it
	 * matches one of the selected extensions. If not then check the children.
	 */

#Code:
	private void setupSelectionsBasedOnSelectedTypes(Map selectionMap, IContainer parent) {

		List selections = new ArrayList();
		IResource[] resources;
		boolean hasFiles = false;

		try {
			resources = parent.members();
		} catch (CoreException exception) {
			// Just return if we can't get any info
			return;
		}

		for (int i = 0; i < resources.length; i++) {
			IResource resource = resources[i];
			if (resource.getType() == IResource.FILE) {
				if (hasExportableExtension(resource.getName())) {
					hasFiles = true;
					selections.add(resource);
				}
			} else {
				setupSelectionsBasedOnSelectedTypes(selectionMap, (IContainer) resource);
			}
		}

		// Only add it to the list if there are files in this folder
		if (hasFiles) {
			selectionMap.put(parent, selections);
		}
	}

#end
#end
#No. 185296
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Save any editors that the user wants to save before export.
	 * @return boolean if the save was successful.
	 */

#Code:
	protected boolean saveDirtyEditors() {
		return IDEWorkbenchPlugin.getDefault().getWorkbench().saveAllEditors(true);
	}

#end
#end
#No. 185297
#File: E:\bishe\1\WizardExportResourcesPage2.java
#Comment:
	/**
	 * Check if widgets are enabled or disabled by a change in the dialog.
	 */

#Code:
	protected void updateWidgetEnablements() {

		boolean pageComplete = determinePageCompletion();
		setPageComplete(pageComplete);
		if (pageComplete) {
			setMessage(null);
		}
		super.updateWidgetEnablements();
	}

#end
#end
#No. 185298
#File: E:\bishe\1\WizardStageDialog.java
#Comment:
	/**
	 Invoked when wizard has reached last step and dialog is closing.
	 If {@link #forceOkProperty} is set to true and the wizard is not on the last step, this will not be invoked.
	 */

#Code:
	public void stepsComplete() {

	}

#end
#end
#No. 185299
#File: E:\bishe\1\WizardStep.java
#Comment:
	/**
	 Invoked when the step is no longer being presented to user

	 @param movingForward true if the next step is ahead of this step, false if the next step is behind this step
	 */

#Code:
	protected void stepLeft(boolean movingForward) {

	}

#end
#end
#No. 185300
#File: E:\bishe\1\WizardStep.java
#Comment:
	/**
	 Returns whatever {@link #stepIsCompleteProperty} is set to. Default value is true.

	 @return true if the wizard can progress, false if the step isn't complete yet.
	 */

#Code:
	protected final boolean stepIsComplete() {
		return stepIsCompleteProperty.get();
	}


#end
#end
#No. 185302
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Get a list of purchases which have not been ended yet using finishPurchase
	 *
	 * @param callbackContext Instance
	 **/

#Code:
	private void getPendingPurchases(CallbackContext callbackContext) throws JSONException {
		// Check if the Inventory is available
		if (mInventory != null) {
			// Get and return any previously purchased Items
			JSONArray jsonPurchaseList = new JSONArray();
			jsonPurchaseList = getPendingPurchases();
			// Return result
			callbackContext.success(jsonPurchaseList);
		} else {
			// Initialise the Plug-In
			cordova.getThreadPool().execute(new Runnable() {
				public void run() {
					List<String> skus = new ArrayList<String>();
					init(skus);
				}
			});
			// Retain the callback and wait
			mGetPendingCbContext = callbackContext;
			retainCallBack(mGetPendingCbContext);
		}
	}

#end
#end
#No. 185303
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Restore all Inventory products and purchases
	 *
	 * @param callbackContext Instance
	 **/

#Code:
	private void restoreAllPurchases(CallbackContext callbackContext) throws JSONException {
		// Check if the Inventory is available
		if (mInventory != null) {
			// Get the list of owned items
			List<Purchase> purchaseList = mInventory.getAllPurchases();
			setPurchasesAsPending(purchaseList);
			JSONArray jsonPurchaseList = convertToJSONArray(purchaseList);
			// Return result
			callbackContext.success(jsonPurchaseList);
		} else {
			// Initialise the Plug-In
			cordova.getThreadPool().execute(new Runnable() {
				public void run() {
					List<String> skus = new ArrayList<String>();
					init(skus);
				}
			});
			// Retain the callback and wait
			mRestoreAllCbContext = callbackContext;
			retainCallBack(mRestoreAllCbContext);
		}
	}

#end
#end
#No. 185304
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Get All Products Details
	 *
	 * @param args List of Product id to be retrieved
	 * @param callbackContext Instance
	 **/

#Code:
	private void getProductsDetails(JSONArray args, CallbackContext callbackContext) throws JSONException {
		// Retrieve all given Product Ids
		JSONArray jsonSkuList = new JSONArray(args.getString(0));
		mRequestDetailSkus = new ArrayList<String>();
		// Populate productId list
		for (int i = 0; i < jsonSkuList.length(); i++) {
			mRequestDetailSkus.add(jsonSkuList.get(i).toString());
		}
		// Retain the callback and wait
		mProductDetailCbContext = callbackContext;
		retainCallBack(mProductDetailCbContext);

		// Check if the Inventory is available
		if (mInventory != null) {
			// Get all the Sku details for the List
			getSkuDetails(mRequestDetailSkus);
		} else {
			// Initialise the Plug-In with the given list
			cordova.getThreadPool().execute(new Runnable() {
				public void run() {
					init(mRequestDetailSkus);
				}
			});
		}
	}

#end
#end
#No. 185305
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Make the Product Purchase
	 *
	 * @param args Product Id to be purchased and DeveloperPayload
	 * @param callbackContext Instance
	 **/

#Code:
	private void makePurchase(JSONArray args, CallbackContext callbackContext) throws JSONException {
		// Retain the callback and wait
		mMakePurchaseCbContext = callbackContext;
		retainCallBack(mMakePurchaseCbContext);
		// Instance the given product Id to be purchase
		final String productId = args.getString(0);
		// Update the DeveloperPayload with the given value. empty if not passed
		mDevPayload = args.optString(1);

		// Check if the Inventory is available
		if (mInventory != null) {
			// Set up the activity result callback to this class
			cordova.setActivityResultCallback(this);
			cordova.getThreadPool().execute(new Runnable() {
				public void run() {
					// Buy the product
					buy(productId);
				}
			});
		} else {
			// Initialise the Plug-In adding the product to be purchased
			cordova.getThreadPool().execute(new Runnable() {
				public void run() {
					List<String> skus = new ArrayList<String>();
					skus.add(0, productId);
					init(skus);
				}
			});
		}
	}

#end
#end
#No. 185306
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Finish the Purchase
	 *
	 * @param args Product id of the purchase to be finished and if it is consumable
	 * @param callbackContext Instance
	 **/

#Code:
	private void finishPurchase(JSONArray args, CallbackContext callbackContext) throws JSONException {
		// Retain the callback and wait
		mFinishPurchaseCbContext = callbackContext;
		retainCallBack(mFinishPurchaseCbContext);

		// Check if the Inventory is available
		if (mInventory != null) {
			// Finish product
			finishPurchase(args);
		} else {
			// Initialise the Plug-In
			cordova.getThreadPool().execute(new Runnable() {
				public void run() {
					List<String> skus = new ArrayList<String>();
					init(skus);
				}
			});
		}
	}

#end
#end
#No. 185307
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Buy the Product
	 *
	 * @param sku Product Sku to be purchase
	 **/

#Code:
	private void buy(final String sku) {
		setStartedPurchase(sku, true);
		// Process the purchase for the given product id and developerPayload
		mHelper.launchPurchaseFlow(
				cordova.getActivity(),
				sku,
				RC_REQUEST,
				mPurchaseFinishedListener,
				mDevPayload);
	}

#end
#end
#No. 185308
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Consume a purchase
	 *
	 * @param data Sku or Array of skus of products to be consumed
	 **/

#Code:
	private void finishPurchase(JSONArray data) throws JSONException {
		if (data.length() < 2) {
			mFinishPurchaseCbContext.error(ARGS_ARITY_MISMATCH);
			mFinishPurchaseCbContext = null;
			return;
		}

		String productId = data.getString(0);
		boolean isConsumable = data.getBoolean(1);

		Purchase purchase = mInventory.getPurchase(productId);
		if (purchase == null) {
			mFinishPurchaseCbContext.error(PURCHASE_NOT_FOUND);
			mFinishPurchaseCbContext = null;
			return;
		}

		Log.d(TAG, "Purchase is: " + purchase.toString());

		SharedPreferences pendingPurchasesCache = cordova.getActivity().getSharedPreferences(PENDING_PURCHASES_CACHE_NAME, 0);
		if (!pendingPurchasesCache.contains(purchase.getSku())) {
			mFinishPurchaseCbContext.error(PURCHASE_NOT_PENDING);
			mFinishPurchaseCbContext = null;
			return;
		}

		if (isConsumable) {
			// Process the consumption asynchronously
			mHelper.consumeAsync(purchase, mConsumeFinishedListener);
		} else {
			unsetPurchaseAsPending(purchase);
			mFinishPurchaseCbContext.success();
			mFinishPurchaseCbContext = null;
		}
	}

#end
#end
#No. 185309
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Set every purchase of the specified list as pending
	 *
	 * @param purchaseList List of purchases to set as pending
	 **/

#Code:
	private void setPurchasesAsPending(List<Purchase> purchaseList) {
		SharedPreferences pendingPurchasesCache = cordova.getActivity().getSharedPreferences(PENDING_PURCHASES_CACHE_NAME, 0);
		SharedPreferences.Editor editor = pendingPurchasesCache.edit();

		for (Purchase p : purchaseList) {
			editor.putBoolean(p.getSku(), true);
		}

		editor.commit();
	}

#end
#end
#No. 185310
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Remove a purchase from pending purchases' list
	 *
	 * @param purchase Purchase to unset as pending
	 **/

#Code:
	void unsetPurchaseAsPending(Purchase purchase) {
		SharedPreferences pendingPurchasesCache = cordova.getActivity().getSharedPreferences(PENDING_PURCHASES_CACHE_NAME, 0);
		SharedPreferences.Editor editor = pendingPurchasesCache.edit();
		editor.remove(purchase.getSku());
		editor.commit();
	}

#end
#end
#No. 185311
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Get the list of pending purchases
	 *
	 **/

#Code:
	private JSONArray getPendingPurchases() throws JSONException {
		// Get the list of owned items
		List<Purchase> purchaseList = mInventory.getAllPurchases();

		SharedPreferences pendingPurchasesCache = cordova.getActivity().getSharedPreferences(PENDING_PURCHASES_CACHE_NAME, 0);
		// Convert the java list to JSON
		JSONArray jsonPurchaseList = new JSONArray();
		// Iterate all products
		for (Purchase p : purchaseList) {
			if (pendingPurchasesCache.getBoolean(p.getSku(), false)) {
				jsonPurchaseList.put(convertToJSONObject(p));
			}
		}
		// Return the JSON list
		return jsonPurchaseList;
	}

#end
#end
#No. 185312
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Convert a List of Purchase objects in Java-land to an array of JSON Purchase objects to be returned to JS-land
	 *
	 * @param purchase List of purchases to transform to a JSON array
	 **/

#Code:
	JSONArray convertToJSONArray(List<Purchase> purchaseList) throws JSONException {
		// Convert the java list to JSON
		JSONArray jsonPurchaseList = new JSONArray();
		// Iterate all products
		for (Purchase p : purchaseList) {
			jsonPurchaseList.put(convertToJSONObject(p));
		}
		// Return the JSON list
		return jsonPurchaseList;
	}

#end
#end
#No. 185313
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Convert a Purchase object in Java-land to a JSON Purchase object to be returned to JS-land
	 *
	 * @param purchase Purchase to transform to a JSON object
	 **/

#Code:
	JSONObject convertToJSONObject(Purchase purchase) throws JSONException {
		JSONObject purchaseObject = new JSONObject();
		purchaseObject.put("platform", "android");
		purchaseObject.put("orderId", purchase.getOrderId());
		purchaseObject.put("packageName", cordova.getActivity().getPackageName());
		purchaseObject.put("productId", purchase.getSku());
		purchaseObject.put("purchaseTime", purchase.getPurchaseTime());
		purchaseObject.put("purchaseState", purchase.getPurchaseState());
		purchaseObject.put("developerPayload", purchase.getDeveloperPayload());
		purchaseObject.put("receipt", purchase.getToken());
		purchaseObject.put("json", purchase.getOriginalJson());
		purchaseObject.put("signature", purchase.getSignature());
		return purchaseObject;
	}

#end
#end
#No. 185314
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Get the SkuDetails
	 *
	 * @param skus List of product skus to be processed
	 **/

#Code:
	private void getSkuDetails(final List<String> skus){
		Log.d(TAG, "Querying inventory w/ SKUs.");
		mHelper.queryInventoryAsync(true, skus, mGotDetailsListener);
	}



#end
#end
#No. 185317
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Check if there is any errors in the iabResult and update the inventory
	 *
	 * @param result IabResult instance
	 * @param inventory Inventory instance
	 *
	 * @return Result of the check
	 **/

#Code:
	private Boolean hasErrorsAndUpdateInventory(IabResult result, Inventory inventory) {
		Log.d(TAG, "Update Inventory");
		// Check if the result failed
		if (result.isFailure()) {
			// Check if we have the handler
			Log.e(TAG, "Error: " + result.toString());
			if (mProductDetailCbContext != null) {
				// Dispatch the Error event
				mProductDetailCbContext.error(returnErrorCode(result.getResponse()));
				// Clear the handler
				mProductDetailCbContext = null;
			}

			if (mRestoreAllCbContext != null) {
				// Dispatch the Error event
				mRestoreAllCbContext.error(returnErrorCode(result.getResponse()));
				// Clear the handler
				mRestoreAllCbContext = null;
			}
			// Return true since we found an error
			return true;
		}
		// Update the inventory and return false (no error on result)
		mInventory = inventory;
		return false;
	}

#end
#end
#No. 185318
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Retain a Callback
	 *
	 * @param target CallBack Instance to retain
	 * @param source Source Callback instance
	 **/

#Code:
	private void retainCallBack(CallbackContext cb) {
		// Retain callback and wait
		PluginResult result = new PluginResult(PluginResult.Status.NO_RESULT);
		result.setKeepCallback(true);
		cb.sendPluginResult(result);
	}

#end
#end
#No. 185319
#File: E:\bishe\1\WizPurchase.java
#Comment:
	/**
	 * Error converter helper
	 * Map the given error index into a human readable error string
	 *
	 * @param error Error code to be converted
	 **/

#Code:
	private int returnErrorCode(int error) {

		// Define the default message
		int errorCode;
		// Update the message according to the given code
		if (error == -1001)      errorCode = REMOTE_EXCEPTION;
		else if (error == -1002) errorCode = BAD_RESPONSE;
		else if (error == -1003) errorCode = BAD_SIGNATURE;
		else if (error == -1004) errorCode = SEND_INTENT_FAILED;
		else if (error == -1005) errorCode = USER_CANCELLED;
		else if (error == -1006) errorCode = INVALID_PURCHASE;
		else if (error == -1007) errorCode = MISSING_TOKEN;
		else if (error == -1008) errorCode = UNKNOWN_ERROR;
		else if (error == -1009) errorCode = NO_SUBSCRIPTIONS;
		else if (error == -1010) errorCode = INVALID_CONSUMPTION;
		else if (error == 1)     errorCode = USER_CANCELLED;
		else if (error == 2)     errorCode = UNKNOWN_ERROR;
		else if (error == 3)     errorCode = CANNOT_PURCHASE;
		else if (error == 4)     errorCode = UNKNOWN_PRODUCT_ID;
		else if (error == 5)     errorCode = UNKNOWN_ERROR;
		else if (error == 6)     errorCode = INVALID_PURCHASE;
		else if (error == 7)     errorCode = ALREADY_OWNED;
		else if (error == 8)     errorCode = NOT_OWNED;
		else                     errorCode = UNKNOWN_ERROR;

		// Return the Message
		return errorCode;
	}


#end
#end
#No. 185321
#File: E:\bishe\1\WKBReader.java
#Comment:
	/**
	 * Parse a binary encoded geometry.
	 */

#Code:
	public void parse(byte[] value) {
		parseGeometry(valueGetterForEndian(value), 0);
	}

#end
#end
#No. 185322
#File: E:\bishe\1\WKBReader.java
#Comment:
	/**
	 * Parse a hex encoded geometry.
	 */

#Code:
	public void parse(String value) {
		byte[] b = hexStringToByteArray(value);
		if (b == null)
			return;

		parse(b);
	}

#end
#end
#No. 185323
#File: E:\bishe\1\WKBReader.java
#Comment:
	/**
	 * Parse an Array of "full" Geometries
	 *
	 * @param data
	 *            ...
	 * @param count
	 *            ...
	 */

#Code:
	private void parseGeometryArray(ValueGetter data, int count, int type) {
		mGeom.clear();

		for (int i = 0; i < count; i++) {
			if (i > 0) {
				if (type == Geometry.LINESTRING)
					mGeom.startLine();
				else if (type == Geometry.POLYGON)
					mGeom.startPolygon();
				else {
					mCallback.process(mGeom);
					mGeom.clear();
				}
			}
			parseGeometry(data, count);
			// mGeom.index[++mGeom.indexPos] = -1;
		}

		mCallback.process(mGeom);
		mGeom.clear();
	}

#end
#end
#No. 185324
#File: E:\bishe\1\WKBReader.java
#Comment:
	/**
	 * Converting a string of hex character to bytes
	 *
	 * from http://stackoverflow.com/questions/140131/convert-a-string-
	 * representation-of-a-hex-dump-to-a-byte-array-using-java
	 */

#Code:
	public static byte[] hexStringToByteArray(String s) {

		int len = s.length();
		if (len < 2)
			return null;

		byte[] data = new byte[len / 2];
		for (int i = 0; i < len; i += 2) {
			data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
			        + Character.digit(s.charAt(i + 1), 16));
		}
		return data;
	}

#end
#end
#No. 185325
#File: E:\bishe\1\WLocate.java
#Comment:
/**
 * Internal class, used for receiving the result
 */

#Code:
class wloc_res
{
   public byte  version,length;
   public byte  result,iresult;
   public short quality;
   public byte  cres6,cres7,cres8;
   public int   lat,lon;    
   public short ccode;
   public short wres34,wres56,wres78;
}

#end
#end
#No. 185326
#File: E:\bishe\1\WLocate.java
#Comment:
/**
 * Internal class, used for storing the position information
 */

#Code:
class wloc_position
{
   wloc_position()
   {   
   }
   
   double lat,lon;
   short  quality;
   short  ccode;
}

#end
#end
#No. 185327
#File: E:\bishe\1\WLQQTimePicker.java
#Comment:
    /**
     * set WLQQTimePicker date
     * @param date
     */

#Code:
    public void setDate(long date) {
        mCalendar = Calendar.getInstance(Locale.CHINA);
        mCalendar.setTimeInMillis(date);
        mYear = mCalendar.get(Calendar.YEAR);
        mMonth = mCalendar.get(Calendar.MONTH);
        mDay = mCalendar.get(Calendar.DAY_OF_MONTH);
        mHour = mCalendar.get(Calendar.HOUR_OF_DAY);

        mWheelYear.setData(getYearData());
        mWheelMonth.setData(getMonthData());
        mWheelDay.setData(getDayData(mCalendar.getActualMaximum(Calendar.DAY_OF_MONTH)));
        mWheelHour.setData(getHourData());

        mHandler.sendEmptyMessage(UPDATE_TITLE_MSG);
        mHandler.sendEmptyMessage(UPDATE_WHEEL);
    }

#end
#end
#No. 185328
#File: E:\bishe\1\WLUtils.java
#Comment:
	/**
	 * Function to get a string representation of the subtree described by the given index 
	 * 
	 * @param reverseDict
	 * @param index
	 * @return
	 */

#Code:
	public static String getFeatureDecription(Map<String,String> reverseDict, int index) {
		return getFeatureDescriptionRec(reverseDict, Integer.toString(index), false);
	}

#end
#end
#No. 185329
#File: E:\bishe\1\WLUtils.java
#Comment:
	/**
	 * Function to recursively "unravel" the subtree label generated by WL, note that this is based on knowledge of the WL implementation,
	 * ie. "_" are used to concatenate labels.
	 * 
	 * @param reverseDict
	 * @param index
	 * @return
	 */

#Code:
	private static String getFeatureDescriptionRec(Map<String,String> reverseDict, String index, boolean onlyFirst) {
		String lab = reverseDict.get(index);	

		// can we split the labels on "_"
		if (lab.contains("_")) {
			String[] split = lab.split("_");

			if (reverseDict.containsKey(split[0])) {  // if the first string is in the dict than we can assume that "_" were used for concat
				String output = getFeatureDescriptionRec(reverseDict, split[0], true);

				if (!onlyFirst) { // We only want to unfold the concatenated label once
					output += "->";

					output += "(";				 
					for (int i = 1; i < split.length; i++) {
						if (i != 1) {
							output += ",";
						}
						output += getFeatureDescriptionRec(reverseDict, split[i], false);
					}
					output += ")";
				}	
				return output;		

			} else { // "_" not used for concat, regular label, and also has to be end label, so this is a base case
				return lab;
			}		
		} else {
			if (reverseDict.containsKey(lab)) {
				return getFeatureDescriptionRec(reverseDict, lab, true);
			} else { // Other base case
				return lab;
			}
		}	
	}

#end
#end
#No. 185330
#File: E:\bishe\1\WMSRequest.java
#Comment:
/* This program is free software: you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public License
 as published by the Free Software Foundation, either version 3 of
 the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>. */

#Code:

package org.opentripplanner.analyst.parameter;

public enum WMSRequest {
    getMap,
    getCapabilities
}

#end
#end
#No. 185331
#File: E:\bishe\1\WmsServerType.java
#Comment:
/**
 * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`, `'qgis'`. These are servers that have vendor parameters beyond the WMS
 * specification that OpenLayers can make use of.
 * 
 * @author Peter Zanetti
 */

#Code:
public enum WmsServerType {
    
    CARMENTA_SERVER("carmentaserver"),
    GEOSERVER("geoserver"),
    MAPSERVER("mapserver"),
    QGIS("qgis");

    private final String value;

    /**
     * Constructs a(n) {@link WmsServerType} object.
     *
     * @param value
     */
    WmsServerType(final String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    public static final WmsServerType getInstance(String value) {
        
        for (WmsServerType wmsServerType : WmsServerType.class.getEnumConstants()) {
            if (Objects.equals(wmsServerType.getValue(), value)) {
                return wmsServerType;
            }
        }
        
        return null;
        
    }
    
}

#end
#end
#No. 185332
#File: E:\bishe\1\WNafPreCompInfo.java
#Comment:
/**
 * Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
 * algorithm.
 */

#Code:
class WNafPreCompInfo implements PreCompInfo
{
    /**
     * Array holding the precomputed <code>ECPoint</code>s used for the Window
     * NAF multiplication in <code>
     * {@link org.bouncycastle.math.ec.multiplier.WNafMultiplier.multiply()
     * WNafMultiplier.multiply()}</code>.

#end
#end
#No. 185333
#File: E:\bishe\1\WNafPreCompInfo.java
#Comment:
    /**
     * Holds an <code>ECPoint</code> representing twice(this). Used for the
     * Window NAF multiplication in <code>
     * {@link org.bouncycastle.math.ec.multiplier.WNafMultiplier.multiply()
     * WNafMultiplier.multiply()}</code>.
     */

#Code:
    private ECPoint twiceP = null;

    protected ECPoint[] getPreComp()
    {
        return preComp;
    }

#end
#end
#No. 185334
#File: E:\bishe\1\WodenFormGenerator.java
#Comment:
	/**
	 * Return the binding corresponding to the endpoint and the operation 
	 * @param wsEndpoint
	 * @param wsOperation
	 * @return The binding, null if the binding is not found
	 */

#Code:
	private BindingOperation getBindingOperation(WSEndpoint wsEndpoint, WSOperation wsOperation){
		Endpoint endpoint = wsdlDescription.getServices()[0].getEndpoint(new NCName(wsEndpoint.getName()));
		for(BindingOperation operation : endpoint.getBinding().getBindingOperations()){
			if(operation.getInterfaceOperation().getName().equals(wsOperation.getQName())){
				return operation;
			}
		}
		return null;
	}

#end
#end
#No. 185335
#File: E:\bishe\1\WodenFormGenerator.java
#Comment:
	/**
	 * Returns a list of fields corresponding to the operation and the message direction
	 * @param operation The operation for which to get the I/O fields
	 * @param direction The message direction
	 * @return A string list of fields 
	 */

#Code:
	private List<WSField> getFields(BindingOperation operation, Direction direction){
		ArrayList<WSField> outputFields = new ArrayList<WSField>();
		InterfaceMessageReference[] messages = operation.getInterfaceOperation().getInterfaceMessageReferences();		
		logger.debug("messages : " + messages.length);
		for(int i = 0; i <messages.length; i++){
			if(direction.equals(messages[i].getDirection())){
				XmlSchemaElement schemaElement =  (XmlSchemaElement) (messages[i].getElementDeclaration().getContent());				
				XmlSchemaElement elem = (XmlSchemaElement) (wsdlDescription.getElementDeclaration(schemaElement.getSchemaType().getQName()).getContent());
				XmlSchemaComplexType elemComplexType = (XmlSchemaComplexType)elem.getSchemaType();
				XmlSchemaSequence sequence = (XmlSchemaSequence)(elemComplexType.getParticle());			 	
				Iterator<XmlSchemaSequenceMember> iter = sequence.getItems().iterator();
				// Only compatible with XML Schema version 2.x
				//Iterator<Object> iter = sequence.getItems().getIterator();
				while(iter.hasNext()){
					Object obj = iter.next();
					if(obj instanceof XmlSchemaElement){
						XmlSchemaElement field = (XmlSchemaElement) obj;
						logger.debug("Field found = " + field.getName());
						outputFields.add(new WSField(field.getName(), "String"));
					}
				}
			}
		}
		return outputFields;		
	}

#end
#end
#No. 185336
#File: E:\bishe\1\WodenFormGenerator.java
#Comment:
	/**
	 * Return true is the WSDl version is 2.0, false othervise
	 * @param xmlSource The WSDL File to check
	 * @return True if the document version is 2.0, false otherwise 
	 * @throws Exception If a problem occurs
	 */

#Code:
	private boolean isWsdl2(String xmlSource) throws Exception {
		File file = new File(new URI(xmlSource));
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db = dbf.newDocumentBuilder();
		Document doc = db.parse(file);
		doc.getDocumentElement().normalize();
		if("definitions".equalsIgnoreCase(doc.getDocumentElement().getNodeName().substring(doc.getDocumentElement().getNodeName().indexOf(":")+1))){
			return false;
		}
		else {
			return true;
		}
	}


#end
#end
#No. 185338
#File: E:\bishe\1\WoodState.java
#Comment:
/**
 * Defines all types of wood.
 * 
 * @author MorbZ
 */

#Code:
@SuppressWarnings("javadoc")
public enum WoodState {
	OAK(0),
	SPRUCE(1),
	BIRCH(2),
	JUNGLE(3),
	ACACIA(4),
	DARK_OAK(5);
	
	private int value;
	private WoodState(int value) {
		this.value = value;
	}
	public int getValue() {
		return value;
	}
}

#end
#end
#No. 185339
#File: E:\bishe\1\WookieWidgetService.java
#Comment:
    /**
     * Get all widgets available from the configured Wookie server
     * @return an array of available widgets
     * @throws WookieConnectorException
     */

#Code:
    @SuppressWarnings("deprecation")
    public Widget[] getWidgets() throws WookieConnectorException{
        connectorService = getWookieConnectorService(wookieServerUrl, wookieApiKey, null);    
        Collection<org.apache.wookie.connector.framework.Widget> widgets = connectorService.getAvailableWidgets().values();
        ArrayList<Widget> raveWidgets = new ArrayList<Widget>();
        for (org.apache.wookie.connector.framework.Widget wookieWidget: widgets){
            Widget widget = new W3CWidget();
            widget.setUrl(wookieWidget.getIdentifier());
            widget.setDescription(wookieWidget.getDescription());
            widget.setTitle(wookieWidget.getTitle());
            widget.setThumbnailUrl(wookieWidget.getIcon().toString());
            //widget.setAuthor(wookieWidget.getAuthor());
            raveWidgets.add(widget);
        }
        return raveWidgets.toArray(new Widget[raveWidgets.size()]);
    }

#end
#end
#No. 185340
#File: E:\bishe\1\WookieWidgetService.java
#Comment:
    /**
     * Gets the Widget Instance corresponding to the RegionWidget and the Viewer
     * @param widget the type of Widget to obtain
     * @param sharedDataKey the context for data sharing
     * @param viewer the current viewer
     * @return a Widget
     */

#Code:
    @SuppressWarnings("deprecation")
    private W3CWidget getWidgetForViewer(Widget widget, String sharedDataKey, User viewer){
       try {
            connectorService = getWookieConnectorService(wookieServerUrl, wookieApiKey, sharedDataKey);
            org.apache.wookie.connector.framework.User user = new org.apache.wookie.connector.framework.User(String.valueOf(viewer.getUsername()), viewer.getUsername());
            connectorService.setCurrentUser(user);
            logger.debug("Getting widget:"+widget.getUrl()+" from:" +connectorService.getConnection().getURL());
            WidgetInstance instance = connectorService.getOrCreateInstance(widget.getUrl());
            return createWidget(instance);
        } catch (WookieConnectorException e) {
            logger.error("Unable to connect to Wookie server", e);
            // FIXME: provide a real error widget
            return createWidget(new WidgetInstance("error", "error", e.getMessage(), "100", "100"));
        } catch (IOException e) {
            logger.error("Problem communicating with Wookie server", e);
            // FIXME: provide a real error widget
            return createWidget(new WidgetInstance("error", "error", e.getMessage(), "100", "100"));
        }
    }

#end
#end
#No. 185341
#File: E:\bishe\1\WookieWidgetService.java
#Comment:
    /**
     * Create a Rave Widget object for the widget instance.
     * This is a transient object and is not persisted
     * @return
     */

#Code:
    private W3CWidget createWidget(WidgetInstance instance){
        W3CWidget widget = new W3CWidget();
        widget.setUrl(instance.getUrl());
        widget.setTitle(instance.getTitle());
        widget.setType("W3C");
        widget.setHeight(Integer.parseInt(instance.getHeight()));
        widget.setWidth(Integer.parseInt(instance.getWidth()));
        return widget;
    }

#end
#end
#No. 185342
#File: E:\bishe\1\WookiGenericDAOImpl.java
#Comment:
/**
 * Wooki Generic DAO. Provides convenience method for selecting only non deleted objects...
 * 
 * @param <T>
 * @param <PK>
 */

#Code:
public abstract class WookiGenericDAOImpl<T extends WookiEntity, PK extends Serializable> extends
        GenericDAOImpl<T, PK> implements WookiGenericDAO<T, PK>
{

    public WookiGenericDAOImpl(Session session)
    {
        super(session);
    }

}

#end
#end
#No. 185343
#File: E:\bishe\1\WookiGrantedAuthority.java
#Comment:
/**
 * This enum defines the list of granted authorities used in Wooki Application.
 * 
 * @author ccordenier
 */

#Code:
public enum WookiGrantedAuthority implements GrantedAuthority
{

    ROLE_AUTHOR, ROLE_ADMIN;

    public String getAuthority()
    {
        return this.toString();
    }

}


#end
#end
#No. 185345
#File: E:\bishe\1\WookiModule.java
#Comment:
    /**
     * Build messages catalog service for services.
     */

#Code:
    public ServicesMessages buildServicesMessages(
            @Symbol(SymbolConstants.APPLICATION_CATALOG) Resource appCatalogResource,
            @Inject ClasspathURLConverter urlConverter, @Inject ThreadLocale locale,
            @Inject LinkSource linkSource, @Inject UpdateListenerHub listenerHub,
            @Inject PropertiesFileParser fileParse)
    {
        ServicesMessages messages = new ServicesMessagesImpl(appCatalogResource, urlConverter,
                locale, linkSource, fileParse);
        listenerHub.addUpdateListener(messages);
        return messages;
    }

#end
#end
#No. 185346
#File: E:\bishe\1\WookiModule.java
#Comment:
    /**
     * Allow to return error code instance.
     * 
     * @param componentInstanceProcessor
     * @param configuration
     */

#Code:
    public void contributeComponentEventResultProcessor(
            @Traditional @ComponentInstanceProcessor ComponentEventResultProcessor componentInstanceProcessor,
            MappedConfiguration<Class, ComponentEventResultProcessor> configuration)
    {
        configuration.addInstance(HttpError.class, HttpErrorResultProcessor.class);
    }

#end
#end
#No. 185347
#File: E:\bishe\1\WookiModule.java
#Comment:
    /**
     * Add a filter to secure activation context in request.
     * 
     * @param filters
     * @param manager
     * @param response
     */

#Code:
    public static void contributeComponentRequestHandler(
            OrderedConfiguration<ComponentRequestFilter> filters, ActivationContextManager manager,
            Response response, MultipartDecoder decoder)
    {
        filters.add("secureActivationContextFilter", new SecureActivationContextRequestFilter(
                manager, response, decoder));
    }


#end
#end
#No. 185349
#File: E:\bishe\1\WookiModule.java
#Comment:
    /**
     * Store the last view page in session.
     */

#Code:
    public static void contributePageRenderRequestHandler(
            OrderedConfiguration<PageRenderRequestFilter> filters, WookiViewRefererFilter vrFilter)
    {
        filters.add("ViewRefererFilter", vrFilter);
        filters.addInstance("IESupport", BrowserSelection.class);
    }

#end
#end
#No. 185350
#File: E:\bishe\1\WookiModule.java
#Comment:
    /**
     * Add coercion tuple for parameter types...
     * 
     * @param configuration
     */

#Code:
    public static void contributeTypeCoercer(Configuration<CoercionTuple> configuration)
    {
        addTuple(configuration, String.class, ActivitySourceType.class, StringToEnumCoercion
                .create(ActivitySourceType.class));
        addTuple(configuration, String.class, AppendPosition.class, StringToEnumCoercion
                .create(AppendPosition.class));
    }

#end
#end
#No. 185351
#File: E:\bishe\1\WookiModule.java
#Comment:
    /**
     * Add request that shouldn't generate a referer.
     * 
     * @param excludePattern
     */

#Code:
    public static void contributeWookiViewRefererFilter(Configuration<String> excludePattern)
    {
        excludePattern.add("signin");
        excludePattern.add("signup");
        excludePattern.add(".*edit.*");
        excludePattern.add("dev.*");
        excludePattern.add("error.*");
    }

#end
#end
#No. 185352
#File: E:\bishe\1\WookiModule.java
#Comment:
    /**
     * Add jQuery in no conflict mode to default JavaScript Stack
     * 
     * @param receiver
     * @throws NoSuchMethodException
     * @throws SecurityException
     */

#Code:
    @SuppressWarnings("unchecked")
    @Match("ClientInfrastructure")
    public static void adviseClientInfrastructure(MethodAdviceReceiver receiver,
            final AssetSource source) throws SecurityException, NoSuchMethodException
    {

        MethodAdvice advice = new MethodAdvice()
        {
            public void advise(Invocation invocation)
            {
                invocation.proceed();
                List<Asset> jsStack = (List<Asset>) invocation.getResult();
                jsStack.add(0, source.getClasspathAsset("context:static/js/jquery.noconflict.js"));
                jsStack.add(0, source.getClasspathAsset("context:static/js/jquery-1.3.2.min.js"));
                jsStack.add(source.getClasspathAsset("context:static/js/wooki.js"));
                jsStack.add(source.getClasspathAsset("context:static/js/wooki-messages.js"));
            }
        };

        receiver.adviseMethod(receiver.getInterface().getMethod("getJavascriptStack"), advice);
    }

#end
#end
#No. 185353
#File: E:\bishe\1\Wool.java
#Comment:
  /**
   * @param match                       The match the wool belongs to.
   * @param id                          This wool's ID.
   * @param required                    Determines if this wool is required to win the match.
   * @param team                        The team that needs to capture this wool.
   * @param color                       The dye color of this wool.
   * @param monument                    The location for where the wool is placed when it is captured.
   * @param craftable                   Determines if this wool may be crafted with white wool and a dye.
   * @param show                        Determines if this wool shows on the scoreboard.
   * @param location                    The location of the wool room, used in proximity calculation.
   * @param woolProximityRule           The proximity rule that determines how to calculate proximity
   *                                    before picking up the wool.
   * @param monumentProximityRule       The proximity rule that determines how to calculate proximity
   *                                    after picking up the wool.
   */

#Code:
  public Wool(Match match, String id, boolean required, Team team, DyeColor color, Region monument, boolean craftable,
              boolean show, Vector location, ProximityRule woolProximityRule, ProximityRule monumentProximityRule) {
    super(match, id, required, show);
    this.team = team;
    this.color = color;
    this.monument = monument;
    this.craftable = craftable;
    this.location = location;
    this.woolProximityRule = woolProximityRule;
    this.monumentProximityRule = monumentProximityRule;
  }

#end
#end
#No. 185354
#File: E:\bishe\1\Wool.java
#Comment:
  /**
   * Gets the wool prefix for a given viewer team.
   * @param viewer The viewer team, null for observers.
   * @return Color and wool state character. Always 3 characters.
   */

#Code:
  public String getPrefix(Team viewer) {
    String result = Colors.convertDyeToChatColor(color) + "";
    if (isComplete()) {
      result += Characters.WOOL_COMPLETED;
    } else if (isTouched() && (viewer == null || viewer.equals(team))) {
      result += Characters.WOOL_TOUCHED;
    } else {
      result += Characters.WOOL_INCOMPLETE;
    }
    return result;
  }

#end
#end
#No. 185355
#File: E:\bishe\1\WoolModule.java
#Comment:
  /**
   * Checks if the wool has been picked up when a player clicks on an item in their inventory.
   *
   * @param event The event.
   */

#Code:
  @EventHandler(ignoreCancelled = true)
  public void onInventoryClick(InventoryClickEvent event) {
    for (Wool wool : getWools(Cardinal.getMatch(event.getWorld()))) {
      Player player = event.getActor();
      ItemStack item = event.getCurrentItem();
      Team team = wool.getTeam();
      Match match = Cardinal.getMatch(player);
      CompetitorContainer container = match.getPlayingContainer(player);
      if (!wool.isComplete()
          && item.getType().equals(Material.WOOL)
          && item.getData().getData() == wool.getColor().getData()
          && team.equals(container)) {
        wool.setTouched(true);
        boolean showMessage = false;
        if (wool.isShow() && !wool.hasPlayerTouched(player)) {
          wool.addPlayerTouched(player);
          showMessage = true;

          Channels.getTeamChannel(match, team).sendPrefixedMessage(
              new LocalizedComponentBuilder(
                  ChatConstant.getConstant("objective.wool.touched"),
                  Components.getName(player).build(),
                  wool.getComponent(),
                  new TeamComponent(wool.getTeam())
              ).build()
          );
          //todo: send message to observers
        }
      }
    }
  }

#end
#end
#No. 185356
#File: E:\bishe\1\WoolModule.java
#Comment:
  /**
   * Checks if the wool has been picked up when a player picks an item up from the ground.
   *
   * @param event The event.
   */

#Code:
  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
  public void onPlayerPickupItem(PlayerPickupItemEvent event) {
    for (Wool wool : getWools(Cardinal.getMatch(event.getWorld()))) {
      Player player = event.getPlayer();
      ItemStack item = event.getItem().getItemStack();
      Team team = wool.getTeam();
      Match match = Cardinal.getMatch(player);
      CompetitorContainer container = match.getPlayingContainer(player);
      if (!wool.isComplete()
          && item.getType().equals(Material.WOOL)
          && item.getData().getData() == wool.getColor().getData()
          && team.equals(container)) {
        wool.setTouched(true);
        if (wool.isShow() && !wool.hasPlayerTouched(player)) {
          wool.addPlayerTouched(player);

          Channels.getTeamChannel(match, team).sendPrefixedMessage(
              new LocalizedComponentBuilder(
                  ChatConstant.getConstant("objective.wool.touched"),
                  Components.getName(player).build(),
                  wool.getComponent(),
                  new TeamComponent(wool.getTeam())
              ).build()
          );
          //todo: send message to observers
        }
      }
    }
  }

#end
#end
#No. 185357
#File: E:\bishe\1\WoolModule.java
#Comment:
  /**
   * Checks if this wool has been captured when a block is placed.
   *
   * @param event The event.
   */

#Code:
  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
  public void onBlockPlace(BlockPlaceEvent event) {
    for (Wool wool : getWools(Cardinal.getMatch(event.getWorld()))) {
      if (wool.isComplete()) {
        continue;
      }
      Player player = event.getPlayer();
      Block block = event.getBlock();
      if (wool.getMonument().contains(block.getLocation().toVector()) && block.getType().equals(Material.WOOL)
          && ((org.bukkit.material.Wool) block.getState().getMaterialData()).getColor().equals(wool.getColor())) {
        wool.setComplete(true);

        if (wool.isShow()) {
          //fixme: unchecked cast
          Match match = Cardinal.getMatch(event.getWorld());
          Team team = (Team) match.getPlayingContainer(player);
          Channels.getGlobalChannel(match.getMatchThread()).sendMessage(
              new LocalizedComponentBuilder(ChatConstant.getConstant("objective.wool.completed"),
                  Components.getName(player).build(),
                  wool.getComponent(),
                  new TeamComponent(team)).color(ChatColor.GRAY).build());
        }
        Bukkit.getPluginManager().callEvent(new ObjectiveCompleteEvent(wool, player));
      }
    }
  }

#end
#end
#No. 185358
#File: E:\bishe\1\WoolModule.java
#Comment:
  /**
   * Prevents the wool from being crafted if specified when registering the wool.
   *
   * @param event The event.
   */

#Code:
  @EventHandler(ignoreCancelled = true)
  public void onCraftItem(CraftItemEvent event) {
    for (Wool wool : getWools(Cardinal.getMatch(event.getWorld()))) {
      if (event.getRecipe().getResult().equals(new ItemStack(Material.WOOL, 1, wool.getColor().getData()))
          && !wool.isCraftable()) {
        event.setCancelled(true);
        break;
      }
    }
  }

#end
#end
#No. 185359
#File: E:\bishe\1\WoolModule.java
#Comment:
  /**
   * Removes the player from the list of players who have touched the wool during their previous life.
   *
   * @param event The event.
   */

#Code:
  @EventHandler
  public void onPlayerDeath(PlayerDeathEvent event) {
    for (Wool wool : getWools(Cardinal.getMatch(event.getWorld()))) {
      wool.removePlayerTouched(event.getEntity());
    }
  }

#end
#end
#No. 185360
#File: E:\bishe\1\WoolMonumentPlace.java
#Comment:
  /**
   * Will create a wool monument applied region, that allows only the wool type to be placed by the correct team.
   * Custom messages for wrong team and wrong block will be sent to the player only if {@link Wool#isShow()};
   *
   * @param wool The wool to make the applied region for.
   */

#Code:
  public WoolMonumentPlace(Wool wool) {
    super(ApplyType.BLOCK_PLACE, wool.getMonument(),
        new AllFilter(
            new MaterialFilter(
                MaterialPattern.getSingleMaterialPattern(Material.WOOL, (int) wool.getColor().getWoolData())),
            new TeamFilter(wool.getTeam())),
        new LocalizedComponentBuilder(
            ChatConstant.getConstant("objective.wool.error.block"),
            wool.getComponent()
        ).color(ChatColor.RED).build());
    team = wool.getTeam();
    wrongTeam = Components.getWarningComponent(new LocalizedComponentBuilder(
        ChatConstant.getConstant("objective.wool.error.team"),
        new TeamComponentBuilder(wool.getTeam()).build(),
        wool.getComponent()
    ).color(ChatColor.RED).build());
    show = wool.isShow();
  }

#end
#end
#No. 185361
#File: E:\bishe\1\WoolScoreboardEntry.java
#Comment:
  /**
   * Creates a display entry for a wool on a scoreboard.
   * @param wool The wool this entry represents.
   * @param display The ScoreboardDisplay this entry belongs to.
   */

#Code:
  public WoolScoreboardEntry(Wool wool, ScoreboardDisplay display) {
    super(display, "", display.getEntry(" " + ChatColor.WHITE + wool.getComponent().toPlainText(), null), "");
    this.wool = wool;
    wool.getEntryHolder().addEntry(this);
  }

#end
#end
#No. 185362
#File: E:\bishe\1\word-segmentation.java
#Comment:
    /**
     * @param s: A string s
     * @param dict: A dictionary of words dict
     */

#Code:
    public boolean wordSegmentation(String s, Set<String> dict) {
        // write your code here   
        int len = s.length();
        boolean[] dp = new boolean[len + 1];
        
        
        // Last test case is SICK
        // without this validation it wont pass.
        int[] count = new int[26];
        for (String ss : dict) {
            for (int i = 0; i < ss.length(); i++) {
                count[ss.charAt(i) - 'a']++;
            }
        }
        for (int i = 0; i < s.length(); i++) {
            if (count[s.charAt(i) - 'a'] == 0) {
                return false;
            }
        }
        
        dp[0] = true;
        for (int i = 1; i <= len; i++) {
            for (int j = i - 1; j >= 0 ;j--) {
                if (!dp[j]) continue;
                String sub = s.substring(j, i);
                if (dict.contains(sub)) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[len];
    }


#end
#end
#No. 185378
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of lookup method, of class WordApi.
     */

#Code:
    @Test
    public void testLookup_String() throws Exception {
        System.out.println("lookup");
        String word = "cats";
        Word expResult = null;
        Word result = WordApi.lookup(word);
        assertNotNull(result);
        assertEquals(result.getWord(), word);
    }

#end
#end
#No. 185379
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of lookup method, of class WordApi.
     */

#Code:
    @Test
    public void testLookup_3args() throws Exception {
        System.out.println("lookup");
        String word = "cats";
        boolean useCanonical = true;
        boolean includeSuggestions = true;
        Word expResult = null;
        Word result = WordApi.lookup(word, useCanonical, includeSuggestions);
        assertNotNull(result);
        assertEquals(result.getWord(), "cat");

        useCanonical = false;
        result = WordApi.lookup(word, useCanonical, includeSuggestions);
        assertNotNull(result);
        assertEquals(result.getWord(), word);
        assertTrue(result.getSuggestions().size() > 0);
    }

#end
#end
#No. 185380
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of examples method, of class WordApi.
     */

#Code:
    @Test
    public void testExamples_String() throws Exception {
        System.out.println("examples");
        String word = "computer";

        SearchResults results = WordApi.examples(word);
        assertNotNull(results);
        assertEquals(results.getSearchResults().size(), 0);
        for (Example e : results.getExamples()) {
            assertEquals(e.getWord(), word);
        }
    }

#end
#end
#No. 185381
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of examples method, of class WordApi.
     */

#Code:
    @Test
    public void testExamples_6args() throws Exception {
        System.out.println("examples");
        String word = "computer";
        boolean includeDuplicates = false;
        String contentProvider = null;
        boolean useCanonical = true;
        int skip = 0;
        int limit = 0;

        SearchResults results = WordApi.examples(word, includeDuplicates, contentProvider, useCanonical, skip, limit);
        assertNotNull(results);
        assertEquals(results.getSearchResults().size(), 0);
        for (Example e : results.getExamples()) {
            assertEquals(e.getWord(), word);
        }

        limit = 1;
        results = WordApi.examples(word, includeDuplicates, contentProvider, useCanonical, skip, limit);
        assertNotNull(results);
        assertEquals(results.getSearchResults().size(), 0);
        for (Example e : results.getExamples()) {
            assertEquals(e.getWord(), word);
        }
        assertEquals(results.getExamples().size(), limit);
    }

#end
#end
#No. 185382
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of definitions method, of class WordApi.
     */

#Code:
    @Test
    public void testDefinitions() throws Exception {
        System.out.println("definitions");
        String word = "cat";
        List<Definition> result = WordApi.definitions(word);
        assertNotNull(result);
        assertTrue(result.size() > 0);
    }

#end
#end
#No. 185383
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of definitions method, of class WordApi.
     */

#Code:
    @Test
    public void testDefinitions_String_EnumSet() throws Exception {
        System.out.println("definitions");
        String word = "cat";
//		EnumSet<SourceDictionary> sourceDictionaries = EnumSet.of(SourceDictionary.ahd, SourceDictionary.cmu); // not working? 7/25/12 --jb
		EnumSet<SourceDictionary> sourceDictionaries = EnumSet.of(SourceDictionary.all);
        List<Definition> result = WordApi.definitions(word, sourceDictionaries);
        assertNotNull(result);
        assertTrue(result.size() > 0);
        for (Definition d : result) {
            assertNotNull(d.getAttributionText());
            System.out.println(d.toString());
        }
    }

#end
#end
#No. 185384
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of definitions method, of class WordApi.
     */

#Code:
    @Test
    public void testDefinitions_7args() throws Exception {
        System.out.println("definitions");
        String word = "cat";
        int limit = 5;
        EnumSet<PartOfSpeech> partOfSpeech = null;
        boolean includeRelated = false;
        EnumSet<SourceDictionary> sourceDictionaries = null;
        boolean useCanonical = false;
        boolean includeTags = false;
        List<Definition> result = WordApi.definitions(word, limit, partOfSpeech, includeRelated, sourceDictionaries, useCanonical, includeTags);
        assertNotNull(result);
        assertTrue(result.size() == 5);
    }

#end
#end
#No. 185385
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of frequency method, of class WordApi.
     */

#Code:
    @Test
    public void testFrequency_String() throws Exception {
        System.out.println("frequency");
        String word = "cat";

        FrequencySummary result = WordApi.frequency(word);

        assertNotNull(result);
        assertEquals(word, result.getWord());
        assertNotNull(result.getFrequencies());
        assertTrue(result.getFrequencies().size() > 0);
    }

#end
#end
#No. 185386
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of frequency method, of class WordApi.
     */

#Code:
    @Test
    public void testFrequency_String_boolean() throws Exception {
        System.out.println("frequency");
        String word = "cat";
        boolean useCanonical = true;

        FrequencySummary result = WordApi.frequency(word, useCanonical);
        assertNotNull(result);
        assertEquals(word, result.getWord());
        assertNotNull(result.getFrequencies());
        assertTrue(result.getFrequencies().size() > 0);
    }

#end
#end
#No. 185387
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of frequency method, of class WordApi.
     */

#Code:
    @Test
    public void testFrequency_4args_startOnly() throws Exception {
        System.out.println("frequency");
        String word = "cat";
        boolean useCanonical = false;
        int startYear = 1990;
        int endYear = 0;

        FrequencySummary result = WordApi.frequency(word, useCanonical, startYear, endYear);
        assertNotNull(result);
        assertEquals(word, result.getWord());
        assertNotNull(result.getFrequencies());
        assertTrue(result.getFrequencies().size() > 0);
    }

#end
#end
#No. 185388
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of frequency method, of class WordApi.
     */

#Code:
    @Test
    public void testFrequency_4args_endOnly() throws Exception {
        System.out.println("frequency");
        String word = "cat";
        boolean useCanonical = false;
        int startYear = 0;
        int endYear = 2000;

        FrequencySummary result = WordApi.frequency(word, useCanonical, startYear, endYear);
        assertNotNull(result);
        assertEquals(word, result.getWord());
        assertNotNull(result.getFrequencies());
        assertTrue(result.getFrequencies().size() > 0);
    }

#end
#end
#No. 185389
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of frequency method, of class WordApi.
     */

#Code:
    @Test
    public void testFrequency_4args() throws Exception {
        System.out.println("frequency");
        String word = "cat";
        boolean useCanonical = false;
        int startYear = 1990;
        int endYear = 2000;

        FrequencySummary result = WordApi.frequency(word, useCanonical, startYear, endYear);
        assertNotNull(result);
        assertEquals(word, result.getWord());
        assertNotNull(result.getFrequencies());
        assertTrue(result.getFrequencies().size() > 0);
    }

#end
#end
#No. 185390
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of related method, of class WordApi.
     */

#Code:
    @Test
    public void testRelated_String() throws Exception {
        System.out.println("related");
        String word = "cat";
        List<Related> result = WordApi.related(word);

        assertNotNull(result);
        assertTrue(result.get(0).getWords().size() > 0);

		// test "words" that are more than one word
		word = "baby blue";
		result = WordApi.related(word);
		assertNotNull(result);
    }

#end
#end
#No. 185391
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of related method, of class WordApi.
     */

#Code:
    @Test
    public void testRelated_6args() throws Exception {
        System.out.println("related");
        String word = "cat";
        int limitPerRelationshipType = 2;
        boolean useCanonical = false;
        EnumSet<RelationshipType> relationshipType = EnumSet.of(RelationshipType.synonym);

        List<Related> result = WordApi.related(word, useCanonical, relationshipType, limitPerRelationshipType);

        assertNotNull(result);
        assertEquals(result.get(0).getWords().size(), 2);
    }

#end
#end
#No. 185392
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of phrases method, of class WordApi.
     */

#Code:
    @Test
    public void testPhrases_String() throws Exception {
        System.out.println("phrases");
        String word = "cat";

        List<Phrase> result = WordApi.phrases(word);

        assertNotNull(result);
        assertTrue(result.size() > 0);
    }

#end
#end
#No. 185393
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of phrases method, of class WordApi.
     */

#Code:
    @Test
    public void testPhrases_4args() throws Exception {
        System.out.println("phrases");
        String word = "cat";
        int limit = 5;
        String wlmi = "";
        boolean useCanonical = false;

        List<Phrase> result = WordApi.phrases(word);

        assertNotNull(result);
        assertTrue(result.size() > 0);
        assertEquals(result.size(), 5);
    }

#end
#end
#No. 185394
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of hyphenation method, of class WordApi.
     */

#Code:
    @Test
    public void testHyphenation_String() throws Exception {
        System.out.println("hyphenation");
        String word = "computer";
        List<Syllable> result = WordApi.hyphenation(word);

        assertNotNull(result);
        assertEquals(result.size(), 3);
    }

#end
#end
#No. 185395
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of hyphenation method, of class WordApi.
     */

#Code:
    @Test
    public void testHyphenation_4args() throws Exception {
        System.out.println("hyphenation");
        String word = "computer";
        boolean useCanonical = false;
        SourceDictionary sourceDictionary = null;
        int limit = 0;

        List<Syllable> result = WordApi.hyphenation(word, useCanonical, sourceDictionary, limit);

        assertNotNull(result);
        assertEquals(result.size(), 3);
    }

#end
#end
#No. 185396
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of pronunciations method, of class WordApi.
     */

#Code:
    @Test
    public void testPronunciations_String() throws Exception {
        System.out.println("pronunciations");
        String word = "a";

        List<Pronunciation> result = WordApi.pronunciations(word);

        assertNotNull(result);
    }

#end
#end
#No. 185397
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of pronunciations method, of class WordApi.
     */

#Code:
    @Test
    public void testPronunciations_5args() throws Exception {
        System.out.println("pronunciations");
        String word = "a";
        boolean useCanonical = false;

        // NOTE: This dictionary seems to return several results,
        //       where others may return nothing. This may change
        //       in the future.
        SourceDictionary sourceDictionary = SourceDictionary.cmu;
        TypeFormat typeFormat = null;
        int limit = 1;

        List<Pronunciation> result = WordApi.pronunciations(word, useCanonical, sourceDictionary, typeFormat, limit);

        assertNotNull(result);
        System.out.println(result.toString());
        assertEquals(1, result.size());

        sourceDictionary = null;
        typeFormat = TypeFormat.gcide_diacritical;
        result = WordApi.pronunciations(word, useCanonical, sourceDictionary, typeFormat, limit);

        assertNotNull(result);
        System.out.println(result.toString());
        assertEquals(1, result.size());
    }

#end
#end
#No. 185398
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of audio method, of class WordApi.
     */

#Code:
    @Test
    public void testAudio_String() throws Exception {
        System.out.println("audio");
        String word = "a";

        List<AudioFileMetadata> result = WordApi.audio(word);

        assertNotNull(result);
    }

#end
#end
#No. 185399
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of audio method, of class WordApi.
     */

#Code:
    @Test
    public void testAudio_3args() throws Exception {
        System.out.println("audio");
        String word = "a";
        boolean useCanonical = false;
        int limit = 1;

        List<AudioFileMetadata> result = WordApi.audio(word, useCanonical, limit);

        assertNotNull(result);
        assertEquals(result.size(), 1);
    }

#end
#end
#No. 185400
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of getAudioData method, of class WordApi.
     */

#Code:
    @Test
    public void testGetAudioData() throws Exception {
        System.out.println("getAudioData");

        List<AudioFileMetadata> audio = WordApi.audio("a");
        assertNotNull(audio);
        assertTrue(audio.size() >= 1);

        byte[] result = WordApi.getAudioData(audio.get(0));

        assertNotNull(result);
        assertTrue(result.length > 0);
        System.out.println("Got " + result.length + " bytes of data.");

        audio.get(0).setFileUrl("http://api.wordnik.com/v4/audioFile.mp3/d7e9fd4ec39829cb61169850a4e8a9e3a8b15d7b730afbeac7c77ee558f73bfc");
        try {
            result = WordApi.getAudioData(audio.get(0));
        } catch (Exception e) {
            assertNotNull(e);
            System.out.println("This is testing a failure. You should see the headers in the excemption.");
            System.out.println(e);
        }
    }

#end
#end
#No. 185401
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of topExample method, of class WordApi.
     */

#Code:
    @Test
    public void testTopExample_String() throws Exception {
        System.out.println("topExample");
        String word = "cat";
        Example result = WordApi.topExample(word);
        assertNotNull(result);
        assertEquals(result.getWord(), word);
        assertNotNull(result.getProvider());
    }

#end
#end
#No. 185402
#File: E:\bishe\1\WordApiTest.java
#Comment:
    /**
     * Test of topExample method, of class WordApi.
     */

#Code:
    @Test
    public void testTopExample_3args() throws Exception {
        System.out.println("topExample");
        String word = "cat";
        String contentProvider = null;
        boolean useCanonical = false;
        Example result = WordApi.topExample(word, contentProvider, useCanonical);
        assertNotNull(result);
        assertEquals(result.getWord(), word);
        assertNotNull(result.getProvider());

        word = "cats";
        useCanonical = true;
        result = WordApi.topExample(word, contentProvider, useCanonical);
        assertNotNull(result);
        assertEquals(result.getWord(), "cat");
        assertNotNull(result.getProvider());
    }

#end
#end
#No. 185403
#File: E:\bishe\1\WordBreak.java
#Comment:
    /**
     * We make helper array length of given word+1 and with all fields false.
     * The array element is true if such a word exists in dictionary.
     */

#Code:
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>(wordDict);
        boolean[] a = new boolean[s.length() + 1];
        a[0] = true;
        for (int i = 0; i < a.length; i++) {
            if (a[i]) {
                for (int j = i + 1; j < a.length; j++) {
                    if (set.contains(s.substring(i, j)))
                        a[j] = true;
                }
            }
            if (a[a.length - 1]) return true;
        }
        return a[a.length - 1];
    }

#end
#end
#No. 185406
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Use the given WordSizer to pick fonts for each word.
	 * You can make your own, or use a pre-fab one from {@link Sizers}.
	 * 
         * @see WordSizer
	 * @see Sizers
	 * @param sizer the WordSizer to use.
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram withSizer(WordSizer sizer) {
		this.sizer = sizer;
		return this;
	}

#end
#end
#No. 185407
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Render words by randomly choosing from the given colors.
	 * Uses {@link Colorers#pickFrom(int...)}.
	 *
	 * <p> Note: if you want all your words to be, say, red,
	 * <i>don't</i> do this:
	 *
	 * <pre>
	 * ...withColors(255, 0, 0)...  // Not what you want!
	 * </pre>
         *
	 * You'll just see a blank WordCram.  Since <a
	 * href="http://processing.org/reference/color_datatype.html"
	 * target="blank">Processing stores colors as integers</a>,
	 * WordCram will see each integer as a different color, and
	 * it'll color about 1/3 of your words with the color
	 * represented by the integer 255, and the other 2/3 with the
	 * color represented by the integer 0.  The punchline is,
	 * Processing stores opacity (or alpha) in the highest bits
	 * (the ones used for storing really big numbers, from
	 * 2<sup>24</sup> to 2<sup>32</sup>), so your colors 0 and 255
	 * have, effectively, 0 opacity -- they're completely
	 * transparent.  Oops.
	 * 
	 * <p> Use this instead, and you'll get what you're after:
	 *
	 * <pre>
	 * ...withColors(color(255, 0, 0))...  // Much better!
	 * </pre>
	 * 
	 * @param colors the colors to randomly choose from.
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram withColors(int... colors) {
		return withColorer(Colorers.pickFrom(colors));
	}

#end
#end
#No. 185408
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Renders all words in the given color.
	 * @see #withColors(int...)
	 * @param color the color for each word.
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram withColor(int color) {
		return withColors(color);
	}

#end
#end
#No. 185409
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Use the given WordColorer to pick colors for each word.
	 * You can make your own, or use a pre-fab one from {@link Colorers}.
	 * 
	 * @see WordColorer
	 * @see Colorers
	 * @param colorer the WordColorer to use.
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram withColorer(WordColorer colorer) {
		this.colorer = colorer;
		return this;
	}


#end
#end
#No. 185412
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Use the given WordAngler to pick angles for each word.
	 * You can make your own, or use a pre-fab one from {@link Anglers}.
	 * 
	 * @see WordAngler
	 * @see Anglers
	 * @param angler the WordAngler to use.
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram withAngler(WordAngler angler) {
		this.angler = angler;
		return this;
	}

#end
#end
#No. 185413
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Use the given WordPlacer to pick locations for each word.
	 * You can make your own, or use a pre-fab one from {@link Placers}.
	 * 
	 * @see WordPlacer
	 * @see Placers
	 * @see PlottingWordPlacer
	 * @param placer the WordPlacer to use.
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram withPlacer(WordPlacer placer) {
		this.placer = placer;
		return this;
	}

#end
#end
#No. 185414
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Use the given WordNudger to pick angles for each word.
	 * You can make your own, or use a pre-fab one.
	 * 
	 * @see WordNudger
	 * @see SpiralWordNudger
	 * @see RandomWordNudger
	 * @see PlottingWordNudger
	 * @param nudger the WordNudger to use.
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram withNudger(WordNudger nudger) {
		this.nudger = nudger;
		return this;
	}

#end
#end
#No. 185415
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * How many attempts should be used to place a word.  Higher
	 * values ensure that more words get placed, but will make
	 * algorithm slower.
	 * @param maxAttempts
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram maxAttemptsToPlaceWord(int maxAttempts) {
		renderOptions.maxAttemptsToPlaceWord = maxAttempts;
		return this;
	}

#end
#end
#No. 185416
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * The maximum number of Words WordCram should try to draw.
	 * This might be useful if you have a whole bunch of words,
	 * and need an artificial way to cut down the list (for
	 * speed).  By default, it's unlimited.
	 * @param maxWords can be any value from 0 to Integer.MAX_VALUE. Values < 0 are treated as unlimited.
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram maxNumberOfWordsToDraw(int maxWords) {
		renderOptions.maxNumberOfWordsToDraw = maxWords;
		return this;
	}

#end
#end
#No. 185417
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * The smallest-sized Shape the WordCram should try to draw.
	 * By default, it's 7.
	 * @param minShapeSize the size of the smallest Shape.
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram minShapeSize(int minShapeSize) {
		renderOptions.minShapeSize = minShapeSize;
		return this;
	}

#end
#end
#No. 185418
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Use a custom canvas instead of the applet's default one.
	 * This may be needed if rendering in background or in other
	 * dimensions than the applet size is needed.
	 * @param canvas the canvas to draw to
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram withCustomCanvas(PGraphics canvas) {
		this.destination = canvas;
		return this;
	}

#end
#end
#No. 185419
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Add padding around each word, so they stand out from each other more.
	 * If you call this multiple times, the last value will be used.
	 * 
	 * WordCram uses a tree of java.awt.Rectangle objects to detect whether two words overlap.
	 * What this method actually does is call <code>Rectangle.grow(padding)</code> on the 
	 * leaves of that tree.
	 * 
	 * @param padding The number of pixels to grow each rectangle by. Defaults to zero.
	 * @return The WordCram, for further setup or drawing.
	 */

#Code:
	public WordCram withWordPadding(int padding) {
		renderOptions.wordPadding = padding;
		return this;
	}

#end
#end
#No. 185420
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * If you're drawing the words one-at-a-time using {@link
	 * #drawNext()}, this will tell you whether the WordCram has
	 * any words left to draw.
	 * @return true if the WordCram has any words left to draw; false otherwise.
	 * @see #drawNext()
	 */

#Code:
	public boolean hasMore() {
		return getWordCramEngine().hasMore();
	}

#end
#end
#No. 185421
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * If the WordCram has any more words to draw, draw the next
	 * one.
	 * @see #hasMore()
	 * @see #drawAll()
	 */

#Code:
	public void drawNext() {
		getWordCramEngine().drawNext();
	}

#end
#end
#No. 185422
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Just like it sounds: draw all the words.  Once the WordCram
	 * has everything set, call this and wait just a bit.
	 * @see #drawNext()
	 */

#Code:
	public void drawAll() {
		getWordCramEngine().drawAll();
	}

#end
#end
#No. 185423
#File: E:\bishe\1\WordCram.java
#Comment:
	/** 
	 * Get the Words that WordCram is drawing. This can be useful
	 * if you want to inspect exactly how the words were weighted,
	 * or see how they were colored, fonted, sized, angled, or
	 * placed, or why they were skipped.
	 */

#Code:
	public Word[] getWords() {
		Word[] wordsCopy = new Word[words.length];
		System.arraycopy(words, 0, wordsCopy, 0, words.length);
		return wordsCopy;
	}

#end
#end
#No. 185424
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Get the Word at the given (x,y) coordinates.
	 * 
	 * <p>This can be called while the WordCram is rendering, or
	 * after it's done.  If a Word is too small to render, or
	 * hasn't been placed yet, it will never be returned by this
	 * method.
	 * 
	 * @param x the X coordinate
	 * @param y the Y coordinate
	 * @return the Word that covers those coordinates, or null if there isn't one 
	 */

#Code:
	public Word getWordAt(float x, float y) {
		return getWordCramEngine().getWordAt(x, y);
	}

#end
#end
#No. 185425
#File: E:\bishe\1\WordCram.java
#Comment:
	/**
	 * Returns an array of words that could not be placed.
	 * @return An array of the skipped words
	 */

#Code:
	public Word[] getSkippedWords() {
		return getWordCramEngine().getSkippedWords();
	}




#end
#end
#No. 185428
#File: E:\bishe\1\WordDictionary.java
#Comment:
    /**
     * Adds a word into the data structure.
     */

#Code:
    public void addWord(String word) {
        TrieNode t = root;
        for (int i = 0; i < word.length(); i++) {
            int id = word.charAt(i) - 'a';
            if (t.children[id] == null)
                t.children[id] = new TrieNode(word.charAt(i));
            t = t.children[id];
        }
        t.isWord = true;
    }

#end
#end
#No. 185429
#File: E:\bishe\1\WordDictionary.java
#Comment:
    /**
     * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
     */

#Code:
    public boolean search(String word) {

        Set<TrieNode> set = new HashSet<>();
        set.add(root);
        for (int i = 0; i < word.length(); i++) {

            if (word.charAt(i) == '.') {
                Set<TrieNode> temp = new HashSet<>();
                for (TrieNode trieNode : set) {
                    for (int j = 0; j < trieNode.children.length; j++) {
                        if (trieNode.children[j] != null) {
                            temp.add(trieNode.children[j]);
                            if (i == word.length() - 1 && trieNode.children[j].isWord) return true;
                        }

                    }
                }
                set = temp;
            } else {
                Set<TrieNode> temp = new HashSet<>();
                boolean b = false;
                for (TrieNode trieNode : set) {
                    int id = word.charAt(i) - 'a';
                    if (trieNode.children[id] != null) {
                        temp.add(trieNode.children[id]);
                        b = true;
                        if (i == word.length() - 1 && trieNode.children[id].isWord) return true;
                    }
                }
                if (!b) return false;
                set = temp;
            }

        }

        return false;
    }


#end
#end
#No. 185432
#File: E:\bishe\1\WordLength.java
#Comment:
    /**
       returns a "state message" that contains whatever this feature needs to
       update ClassifierState.
     */

#Code:
    public Hashtable<String,Object> run(Hashtable<String,Object> data) {
	Hashtable<String,Double> instance = new Hashtable();
	Hashtable<String,Object> stateMessage = new Hashtable();

        if (! data.containsKey("content")) {
	    logger.severe("Requires a key/value pair to be stored in provided data of the form \"content\" => String[]");
	    return stateMessage;
	}

        String[] content = (String[]) data.get("content");
        int chars = 0;

        for (String word : content)
            chars += word.length();

	logger.config("inserting feature: " + featureID + " " + chars);
	insert(instance, featureID, chars);

	populateStateMessage(stateMessage,
			     instance,
			     (double) content.length);

	return stateMessage;
    }

#end
#end
#No. 185433
#File: E:\bishe\1\WordListApiTest.java
#Comment:
    /**
     * Test of createList method, of class WordListApi.
     */

#Code:
    @Test
    public void testCreateList() throws Exception {
        System.out.println("createList");
        ListType type = ListType.PUBLIC;
        WordList result = WordListApi.createList(token, testListName, testListDescription, type);

        assertNotNull(result);
        assertNotNull(result.getId());
        assertEquals(username, result.getUsername());
        assertEquals(token.getUserId(), result.getUserId());
        assertEquals(testListName, result.getName());
        assertEquals(testListDescription, result.getDescription());

        testList = result;
    }

#end
#end
#No. 185434
#File: E:\bishe\1\WordListApiTest.java
#Comment:
    /**
     * Test of getWordList method, of class WordListApi.
     */

#Code:
    @Test
    public void testGetWordList() throws Exception {
        System.out.println("getWordList");
        String permalink = testList.getPermalink();
        WordList expResult = null;
        WordList result = WordListApi.getWordList(token, permalink);

        assertNotNull(result);
        assertEquals(username, result.getUsername());
        assertEquals(token.getUserId(), result.getUserId());
        assertEquals(testListName, result.getName());
        assertEquals(testListDescription, result.getDescription());
    }

#end
#end
#No. 185435
#File: E:\bishe\1\WordListApiTest.java
#Comment:
    /**
     * Test adding one word.
     * This should be followed by updating one word and deleting one word.
     *
     * @throws Exception
     */

#Code:
    @Test
    public void testAddWordToList() throws Exception {
        System.out.println("addWordToList");
        String permalink = testList.getPermalink();
        WordListApi.addWordToList(token, permalink, "test");
    }

#end
#end
#No. 185436
#File: E:\bishe\1\WordListApiTest.java
#Comment:
    /**
     * Test of deleteWordFromList method, of class WordListApi.
     */

#Code:
    @Test
    public void testDeleteWordFromList() throws Exception {
        System.out.println("deleteWordFromList");

        String permalink = testList.getPermalink();
        String word = "test";
        WordListApi.deleteWordFromList(token, permalink, word);

        // check that the list is now empty
        List<WordListWord> result = WordListApi.getWordsFromList(token, permalink);
        KnickerLogger.getLogger().log("****************************************");
        KnickerLogger.getLogger().log(result.toString());
        KnickerLogger.getLogger().log("****************************************");

       assertEquals(result.size(), 0);
    }

#end
#end
#No. 185437
#File: E:\bishe\1\WordListApiTest.java
#Comment:
    /**
     * Test of addWordToList method, of class WordListApi.
     */

#Code:
    @Test
    public void testAddWordsToList() throws Exception {
        System.out.println("addWordsToList");
        String permalink = testList.getPermalink();

        WordListApi.addWordsToList(token, permalink, testWordList);
    }

#end
#end
#No. 185438
#File: E:\bishe\1\WordListApiTest.java
#Comment:
    /**
     * Test of getWordsFromList method, of class WordListApi.
     */

#Code:
    @Test
    public void testGetWordsFromList_AuthenticationToken_String() throws Exception {
        System.out.println("getWordsFromList");
        String permalink = testList.getPermalink();
        List<WordListWord> result = WordListApi.getWordsFromList(token, permalink);

        assertNotNull(result);
        for (WordListWord word : result) {
            assertEquals(word.getUsername(), username);
        }
    }

#end
#end
#No. 185439
#File: E:\bishe\1\WordListApiTest.java
#Comment:
    /**
     * Test of getWordsFromList method, of class WordListApi.
     */

#Code:
    @Test
    public void testGetWordsFromList_6args() throws Exception {
        System.out.println("testGetWordsFromList_6args");
        String permalink = testList.getPermalink();
        Knicker.SortBy sortBy = null;
        SortOrder sortOrder = null;
        int skip = 0;
        int limit = 0;
        List<WordListWord> result = WordListApi.getWordsFromList(token, permalink, sortBy, sortOrder, skip, limit);

        assertNotNull(result);
        for (WordListWord word : result) {
            assertEquals(word.getUsername(), username);
        }

        sortOrder = SortOrder.ASCENDING;
        sortBy = Knicker.SortBy.alpha;
        result = WordListApi.getWordsFromList(token, permalink, sortBy, sortOrder, skip, limit);
        assertNotNull(result);
        assertEquals(result.get(0).getWord(), testWord1);
        assertEquals(result.get(1).getWord(), testWord2);

        sortOrder = SortOrder.DESCENDING;
        result = WordListApi.getWordsFromList(token, permalink, sortBy, sortOrder, skip, limit);
        assertNotNull(result);
        assertEquals(result.get(0).getWord(), testWord2);
        assertEquals(result.get(1).getWord(), testWord1);

        limit = 1;
        result = WordListApi.getWordsFromList(token, permalink, sortBy, sortOrder, skip, limit);
        assertNotNull(result);
        assertEquals(result.get(0).getWord(), testWord2);
    }

#end
#end
#No. 185440
#File: E:\bishe\1\WordListApiTest.java
#Comment:
    /**
     * Test of deleteWordsFromList method, of class WordListApi.
     */

#Code:
    @Test
    public void testDeleteWordsFromList() throws Exception {
        System.out.println("deleteWordsFromList");

        String permalink = testList.getPermalink();
        WordListApi.deleteWordsFromList(token, permalink, testWordList);

        // check that the list is now empty
        List<WordListWord> result = WordListApi.getWordsFromList(token, permalink);
        assertEquals(result.size(), 0);
    }

#end
#end
#No. 185441
#File: E:\bishe\1\WordListApiTest.java
#Comment:
    /**
     * Test of updateWordList method, of class WordListApi.
     */

#Code:
    @Test
    public void testUpdateWordList() throws Exception {
        System.out.println("updateWordList");

        String newDescription = "Changed the description.";
        String newName = "TEST LIST NEW NAME";

        testList.setDescription(newDescription);
        testList.setName(newName);
        testList.setType(ListType.PRIVATE);
        WordListApi.updateWordList(token, testList);

        // check that the list has 2 items
        WordList result = WordListApi.getWordList(token, testList.getPermalink());
        assertEquals(result.getDescription(), newDescription);
        assertEquals(result.getName(), newName);
        assertEquals(result.getType(), ListType.PRIVATE);
        assertEquals(result.getId(), testList.getId());
        assertEquals(result.getNumberWordsInList(), testList.getNumberWordsInList());
        assertEquals(result.getPermalink(), testList.getPermalink());
        assertEquals(result.getUserId(), testList.getUserId());
        assertEquals(result.getUsername(), testList.getUsername());
        assertFalse(result.getUpdatedAt().equals(testList.getUpdatedAt()));
    }

#end
#end
#No. 185442
#File: E:\bishe\1\WordListApiTest.java
#Comment:
    /**
     * Test of deleteList method, of class WordListApi.
     */

#Code:
    @Test
    public void testDeleteList() throws Exception {
        System.out.println("deleteList");
        String permalink = testList.getPermalink();

        WordListApi.deleteList(token, permalink);
    }

#end
#end
#No. 185443
#File: E:\bishe\1\WordListOpenHelper.java
#Comment:
    /**
     * Adds the initial data set to the database.
     * According to the docs, onCreate for the open helper does not run on the UI thread.
     *
     * @param db Database to fill with data since the member variables are not initialized yet.
     */

#Code:
    public void fillDatabaseWithData(SQLiteDatabase db) {

        String[] words = {"Android", "Adapter", "ListView", "AsyncTask", "Android Studio",
                "SQLiteDatabase", "SQLOpenHelper", "Data model", "ViewHolder",
                "Android Performance", "OnClickListener"};

        // Create a container for the data.
        ContentValues values = new ContentValues();

        for (int i=0; i < words.length;i++) {
            // Put column/value pairs into the container. put() overwrites existing values.
            values.put(KEY_WORD, words[i]);
            db.insert(WORD_LIST_TABLE, null, values);
        }
    }

#end
#end
#No. 185444
#File: E:\bishe\1\WordListOpenHelper.java
#Comment:
    /**
     * Queries the database for an entry at a given position.
     *
     * @param position The Nth row in the table.
     * @return a WordItem with the requested database entry.
     */

#Code:
    public WordItem query(int position) {
        String query = "SELECT  * FROM " + WORD_LIST_TABLE +
                " ORDER BY " + KEY_WORD + " ASC " +
                "LIMIT " + position + ",1";

        Cursor cursor = null;
        WordItem entry = new WordItem();

        try {
            if (mReadableDB == null) {mReadableDB = getReadableDatabase();}
            cursor = mReadableDB.rawQuery(query, null);
            cursor.moveToFirst();
            entry.setId(cursor.getInt(cursor.getColumnIndex(KEY_ID)));
            entry.setWord(cursor.getString(cursor.getColumnIndex(KEY_WORD)));
        } catch (Exception e) {
            Log.d(TAG, "QUERY EXCEPTION! " + e.getMessage());
        } finally {
            // Must close cursor and db now that we are done with it.
            cursor.close();
            return entry;
        }
    }

#end
#end
#No. 185445
#File: E:\bishe\1\WordListOpenHelper.java
#Comment:
    /**
     * Adds a single word row/entry to the database.
     *
     * @param  word New word.
     * @return The id of the inserted word.
     */

#Code:
    public long insert(String word) {
        long newId = 0;
        ContentValues values = new ContentValues();
        values.put(KEY_WORD, word);
        try {
            if (mWritableDB == null) {mWritableDB = getWritableDatabase();}
            newId = mWritableDB.insert(WORD_LIST_TABLE, null, values);
        } catch (Exception e) {
            Log.d(TAG, "INSERT EXCEPTION! " + e.getMessage());
        }
        return newId;
    }

#end
#end
#No. 185446
#File: E:\bishe\1\WordListOpenHelper.java
#Comment:
    /**
     * Updates the word with the supplied id to the supplied value.
     *
     * @param id Id of the word to update.
     * @param word The new value of the word.
     * @return The number of rows affected or -1 of nothing was updated.
     */

#Code:
    public int update(int id, String word) {
        int mNumberOfRowsUpdated = -1;
        try {
            if (mWritableDB == null) {mWritableDB = getWritableDatabase();}
            ContentValues values = new ContentValues();
            values.put(KEY_WORD, word);

            mNumberOfRowsUpdated = mWritableDB.update(WORD_LIST_TABLE, //table to change
                    values, // new values to insert
                    KEY_ID + " = ?", // selection criteria for row (in this case, the _id column)
                    new String[]{String.valueOf(id)}); //selection args; the actual value of the id

        } catch (Exception e) {
            Log.d (TAG, "UPDATE EXCEPTION! " + e.getMessage());
        }
        return mNumberOfRowsUpdated;
    }

#end
#end
#No. 185447
#File: E:\bishe\1\WordListOpenHelper.java
#Comment:
    /**
     * Called when a database needs to be upgraded. The most basic version of this method drops
     * the tables, and then recreates them. All data is lost, which is why for a production app,
     * you want to back up your data first. If this method fails, changes are rolled back.
     *
     * @param db
     * @param oldVersion
     * @param newVersion
     */

#Code:
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        Log.w(WordListOpenHelper.class.getName(),
                "Upgrading database from version " + oldVersion + " to "
                        + newVersion + ", which will destroy all old data");
        db.execSQL("DROP TABLE IF EXISTS " + WORD_LIST_TABLE);
        onCreate(db);
    }


#end
#end
#No. 185449
#File: E:\bishe\1\WordMean.java
#Comment:
  /**
   * Maps words from line of text into 2 key-value pairs; one key-value pair for
   * counting the word, another for counting its length.
   */

#Code:
  public static class WordMeanMapper extends
      Mapper<Object, Text, Text, LongWritable> {

    private LongWritable wordLen = new LongWritable();

    /**
     * Emits 2 key-value pairs for counting the word and its length. Outputs are
     * (Text, LongWritable).
     * 
     * @param value
     *          This will be a line of text coming in from our input file.
     */
    public void map(Object key, Text value, Context context)
        throws IOException, InterruptedException {
      StringTokenizer itr = new StringTokenizer(value.toString());
      while (itr.hasMoreTokens()) {
        String string = itr.nextToken();
        this.wordLen.set(string.length());
        context.write(LENGTH, this.wordLen);
        context.write(COUNT, ONE);
      }
    }
  }


#end
#end
#No. 185451
#File: E:\bishe\1\WordMean.java
#Comment:
  /**
   * Only valuable after run() called.
   * 
   * @return Returns the mean value.
   */

#Code:
  public double getMean() {
    return mean;
  }

#end
#end
#No. 185452
#File: E:\bishe\1\WordMedian.java
#Comment:
  /**
   * Maps words from line of text into a key-value pair; the length of the word
   * as the key, and 1 as the value.
   */

#Code:
  public static class WordMedianMapper extends
      Mapper<Object, Text, IntWritable, IntWritable> {

    private IntWritable length = new IntWritable();

    /**
     * Emits a key-value pair for counting the word. Outputs are (IntWritable,
     * IntWritable).
     * 
     * @param value
     *          This will be a line of text coming in from our input file.
     */
    public void map(Object key, Text value, Context context)
        throws IOException, InterruptedException {
      StringTokenizer itr = new StringTokenizer(value.toString());
      while (itr.hasMoreTokens()) {
        String string = itr.nextToken();
        length.set(string.length());
        context.write(length, ONE);
      }
    }
  }

#end
#end
#No. 185453
#File: E:\bishe\1\WordMedian.java
#Comment:
  /**
   * Performs integer summation of all the values for each key.
   */

#Code:
  public static class WordMedianReducer extends
      Reducer<IntWritable, IntWritable, IntWritable, IntWritable> {

    private IntWritable val = new IntWritable();

    /**
     * Sums all the individual values within the iterator and writes them to the
     * same key.
     * 
     * @param key
     *          This will be a length of a word that was read.
     * @param values
     *          This will be an iterator of all the values associated with that
     *          key.
     */
    public void reduce(IntWritable key, Iterable<IntWritable> values,
        Context context) throws IOException, InterruptedException {

      int sum = 0;
      for (IntWritable value : values) {
        sum += value.get();
      }
      val.set(sum);
      context.write(key, val);
    }
  }

#end
#end
#No. 185454
#File: E:\bishe\1\WordNetAPI.java
#Comment:
	/**
	 * Gets the lemma of a word.
	 * 
	 * @param word a word
	 * @param pos part of speech
	 * @return lemma or the input if it could not be lemmatized
	 */

#Code:
	public static String getLemma(String word, POS pos) {
		if (wDict == null) return word;
		IndexWord indexWord = null;

		try {
			indexWord = wDict.lookupIndexWord(pos, word);
		} catch (JWNLException e) {}

		return (indexWord != null) ? indexWord.getLemma() : word;
	}




#end
#end
#No. 185474
#File: E:\bishe\1\WordsApiTest.java
#Comment:
	/**
	 * Test of randomWord method, of class WordsApi.
	 */

#Code:
	@Test
	public void testRandomWord_0args() throws Exception {
		System.out.println("randomWord");
		Word result = WordsApi.randomWord();

		assertNotNull(result);
		assertNotNull(result.getWord());
		assertTrue(result.getWord().length() > 0);

	}

#end
#end
#No. 185475
#File: E:\bishe\1\WordsApiTest.java
#Comment:
	/**
	 * Test of randomWords method, of class WordsApi.
	 */

#Code:
	@Test
	public void testRandomWords_0args() throws Exception {
		System.out.println("randomWords");
		List<Word> result = WordsApi.randomWords();

		assertNotNull(result);
		assertEquals(10, result.size());
	}

#end
#end
#No. 185476
#File: E:\bishe\1\WordsApiTest.java
#Comment:
	/**
	 * Test of randomWords method, of class WordsApi.
	 */

#Code:
	@Test
	public void testRandomWords_12args() throws Exception {
		System.out.println("randomWords");
		boolean hasDictionaryDef = false;
		EnumSet<PartOfSpeech> includePartOfSpeech = null;
		EnumSet<PartOfSpeech> excludePartOfSpeech = null;
		int minCorpusCount = 0;
		int maxCorpusCount = 0;
		int minDictionaryCount = 0;
		int maxDictionaryCount = 0;
		int minLength = 0;
		int maxLength = 0;
		SortBy sortBy = null;
		SortDirection sortDirection = null;
		int limit = 2;


		List<Word> result = WordsApi.randomWords(hasDictionaryDef, includePartOfSpeech, excludePartOfSpeech, minCorpusCount, maxCorpusCount, minDictionaryCount, maxDictionaryCount, minLength, maxLength, sortBy, sortDirection, limit);

		assertNotNull(result);
		assertEquals(2, result.size());


		minLength = 10;
		maxLength = 10;
		result = WordsApi.randomWords(hasDictionaryDef, includePartOfSpeech, excludePartOfSpeech, minCorpusCount, maxCorpusCount, minDictionaryCount, maxDictionaryCount, minLength, maxLength, sortBy, sortDirection, limit);

		assertNotNull(result);
		assertEquals(2, result.size());
		for (Word w : result) {
			assertEquals(minLength, w.getWord().length());
		}
	}

#end
#end
#No. 185477
#File: E:\bishe\1\WordsApiTest.java
#Comment:
	/**
	 * Test of wordOfTheDay method, of class WordsApi.
	 */

#Code:
	@Test
	public void testWordOfTheDay() throws Exception {
		System.out.println("wordOfTheDay");
		WordOfTheDay result = WordsApi.wordOfTheDay();
		assertNotNull(result);
		assertTrue(result.getDefinitions().size() > 0);
		assertTrue(result.getExamples().size() > 0);
	}

#end
#end
#No. 185478
#File: E:\bishe\1\WordsApiTest.java
#Comment:
	/**
	 * Test of search method, of class WordsApi.
	 */

#Code:
	@Test
	public void testSearch_String() throws Exception {
		System.out.println("search");
		String query = "computer";
		SearchResults result = WordsApi.search(query);
		assertNotNull(result);
		assertTrue(result.getSearchResults().size() > 0);
		assertTrue(result.getTotal() > 0);
	}

#end
#end
#No. 185479
#File: E:\bishe\1\WordsApiTest.java
#Comment:
	/**
	 * Test of search method, of class WordsApi.
	 */

#Code:
	@Test
	public void testSearch_12args() throws Exception {
		System.out.println("search");
		String query = "quest";
		boolean caseSensitive = true;
		EnumSet<PartOfSpeech> includePartOfSpeech = null;
		EnumSet<PartOfSpeech> excludePartOfSpeech = null;
		int minCorpusCount = 0;
		int maxCorpusCount = 0;
		int minDictionaryCount = 0;
		int maxDictionaryCount = 0;
		int minLength = 0;
		int maxLength = 0;
		int skip = 0;
		int limit = 0;
		SearchResults result = WordsApi.search(query, caseSensitive, includePartOfSpeech, excludePartOfSpeech, minCorpusCount, maxCorpusCount, minDictionaryCount, maxDictionaryCount, minLength, maxLength, skip, limit);
		assertNotNull(result);
		assertTrue(result.getSearchResults().size() > 0);
		assertTrue(result.getTotal() > 0);

		caseSensitive = false;
		limit = 2;
		result = WordsApi.search(query, caseSensitive, includePartOfSpeech, excludePartOfSpeech, minCorpusCount, maxCorpusCount, minDictionaryCount, maxDictionaryCount, minLength, maxLength, skip, limit);
		assertNotNull(result);
//		TODO: This test is broken. More than two results are returned from the API. Wordnik bug?
//		assertEquals(2, result.getSearchResults().size());
	}

#end
#end
#No. 185480
#File: E:\bishe\1\WordSet.java
#Comment:
	/**
	 * Sets how strong or powerful this keyword is. Some keywords are more
	 * important than others, and can in a way, override the others
	 * 
	 * @param strength
	 *            How strong this KeyWord is compared to other keywords. Should
	 *            be between 0 and 1. Default is 0.5;
	 * @return
	 */

#Code:
	public WordSet setStrength(float strength)
	{
		this.strength = strength;
		return this;
	}

#end
#end
#No. 185481
#File: E:\bishe\1\WordSet.java
#Comment:
	/**
	 * 
	 * @param words
	 * @return -1 If the verb is not found, otherwise Returns two shorts
	 *         compiled into one integer. First 16 bits are the index The second
	 *         16 bits is the word count.
	 * 
	 *         otherwise returns the index in the word array where it was found.
	 */

#Code:
	public int containsWord(String[] words)
	{
		return containsWord(alias, words, canPlural);
	}

#end
#end
#No. 185482
#File: E:\bishe\1\WordSet.java
#Comment:
	/**
	 * 
	 * @param alias
	 *            The words to search for. The Needle. The Base Words
	 * @param words
	 *            The words to search in. The Haystack. The input words.
	 * @param canHavePlurals
	 *            Whether the will equal if plural.
	 * @return Two shorts in one int. First 16 bytes are the word index. Second
	 *         16 bytes is the word length. i.e. how many words.
	 */

#Code:
	public static int containsWord(String[] alias, String[] words, boolean canHavePlurals)
	{
		for (int a = 0; a < alias.length; a++)
		{
			String baseWord = alias[a];

			for (int b = 0; b < words.length; b++)
			{
				if (baseWord.contains(" "))
				{
					String[] split = baseWord.split(" ");
					int c = 0;
					for (; c < split.length && c + b < words.length; c++)
					{
						if (!areWordsSimilar(split[c], words[c + b], canHavePlurals))
						{
							break;
						}
					}
					if (c == split.length)
					{
						return b | (split.length << 16);
					}
				}
				else
				{
					if (areWordsSimilar(words[b], baseWord, canHavePlurals))
					{
						return b | (1 << 16);
					}
				}

			}
		}
		return -1;
	}

#end
#end
#No. 185483
#File: E:\bishe\1\WordSet.java
#Comment:
	/**
	 * 
	 * @param base
	 *            The singular version of the word to check
	 * @param toCheck
	 *            The word to check
	 * @param canPlural
	 *            Whether the word to check may be a plural
	 * @return
	 */

#Code:
	public static boolean areWordsSimilar(String base, String toCheck, boolean canPlural)
	{
		return toCheck.equalsIgnoreCase(base) || (canPlural && toCheck.length() > 1 && toCheck.substring(0, toCheck.length() - 1).equalsIgnoreCase(base));
	}


#end
#end
#No. 185489
#File: E:\bishe\1\WordStandardDeviation.java
#Comment:
  /**
   * Maps words from line of text into 3 key-value pairs; one key-value pair for
   * counting the word, one for counting its length, and one for counting the
   * square of its length.
   */

#Code:
  public static class WordStandardDeviationMapper extends
      Mapper<Object, Text, Text, LongWritable> {

    private LongWritable wordLen = new LongWritable();
    private LongWritable wordLenSq = new LongWritable();

    /**
     * Emits 3 key-value pairs for counting the word, its length, and the
     * squares of its length. Outputs are (Text, LongWritable).
     * 
     * @param value
     *          This will be a line of text coming in from our input file.
     */
    public void map(Object key, Text value, Context context)
        throws IOException, InterruptedException {
      StringTokenizer itr = new StringTokenizer(value.toString());
      while (itr.hasMoreTokens()) {
        String string = itr.nextToken();

        this.wordLen.set(string.length());

        // the square of an integer is an integer...
        this.wordLenSq.set((long) Math.pow(string.length(), 2.0));

        context.write(LENGTH, this.wordLen);
        context.write(SQUARE, this.wordLenSq);
        context.write(COUNT, ONE);
      }
    }
  }

#end
#end
#No. 185490
#File: E:\bishe\1\WordStandardDeviation.java
#Comment:
  /**
   * Performs integer summation of all the values for each key.
   */

#Code:
  public static class WordStandardDeviationReducer extends
      Reducer<Text, LongWritable, Text, LongWritable> {

    private LongWritable val = new LongWritable();

    /**
     * Sums all the individual values within the iterator and writes them to the
     * same key.
     * 
     * @param key
     *          This will be one of 2 constants: LENGTH_STR, COUNT_STR, or
     *          SQUARE_STR.
     * @param values
     *          This will be an iterator of all the values associated with that
     *          key.
     */
    public void reduce(Text key, Iterable<LongWritable> values, Context context)
        throws IOException, InterruptedException {

      int sum = 0;
      for (LongWritable value : values) {
        sum += value.get();
      }
      val.set(sum);
      context.write(key, val);
    }
  }

#end
#end
#No. 185491
#File: E:\bishe\1\WordTrie.java
#Comment:
    /**
     * Recursive helper method for `toList()`.
     * @param node
     *   The node to add.
     * @param prefix
     *   The string prefix corresponding to this node.
     * @param results
     *   The list of results to add to.
     */

#Code:
    private static void addToList(Node node, String prefix, List<String> results) {
        if (node.isMember)
            // This node corresponds to a word in the trie.  Add it.
            results.add(prefix);

        if (node.children != null)
            // Recurse into children.
            for (char letter : LETTERS) {
                final Node child = node.children[getIndex(letter)];
                if (child != null)
                    // Each child represents a prefix one letter longer than this one.
                    addToList(child, prefix + letter, results);
            }
    }

#end
#end
#No. 185492
#File: E:\bishe\1\WordUtil.java
#Comment:
   /**
    * Determines if the string contains either x or z
    * @param text the string to test for x or z
    * @return true if the string contains x or z, ignoring case.
    *  Otherwise false
    */

#Code:
   public  boolean isXOrZ(String text)
   {
       String lower = text.toLowerCase();
       boolean found = false;
       int i = 0;

       // TODO: complete the loop header
       while (!found && i < lower.length())
       {
           String letter = lower.substring(i, i +1);
           // TODO: complete the loop to determine if 
           // lower contains x or z
           if ("ZzXx".contains(letter))
           {
        	   found = true;
           }
           i++;
       }
       return found;
   }

#end
#end
#No. 185493
#File: E:\bishe\1\WordWrapUtils.java
#Comment:
    /**
     * Toggles the word wrap property of a given editor.
     * 
     * @param editor
     *            Editor in which the word wrap will be toggled
     * @author Florian We?ling <flo@cdhq.de>
     */

#Code:
    public static void toggleWordWrap(IEditorPart editor) {
        if (editor == null) {
            return;
        }

        // editor (IEditorPart) adapter returns StyledText
        Object text = editor.getAdapter(Control.class);
        if (text instanceof StyledText) {
            StyledText styledText = (StyledText) text;

            // toggle wrapping
            styledText.setWordWrap(!styledText.getWordWrap());
        }
    }

#end
#end
#No. 185494
#File: E:\bishe\1\WordWrapUtils.java
#Comment:
    /**
     * Sets the word wrap property of a given editor.
     * 
     * @param editor
     *            Editor in which the word wrap will be toggled
     * @param state
     *            The desired state of the word wrap
     * @author Florian We?ling <flo@cdhq.de>
     */

#Code:
    public static void setWordWrap(IEditorPart editor, boolean state) {
        if (editor == null) {
            return;
        }

        // editor (IEditorPart) adapter returns StyledText
        Object text = editor.getAdapter(Control.class);
        if (text instanceof StyledText) {
            StyledText styledText = (StyledText) text;

            // set wrapping
            styledText.setWordWrap(state);
        }
    }

#end
#end
#No. 185495
#File: E:\bishe\1\WordWrapUtils.java
#Comment:
    /**
     * Sets the word wrap property of all editors of a given workbench window.
     * 
     * @param window
     *            Workbench window in which the editors will be altered
     * @param state
     *            Desired state of word wrap
     * @author Florian We?ling <flo@cdhq.de>
     */

#Code:
    public static void setWordWrapInWindow(IWorkbenchWindow window, boolean state) {
        if (window == null) {
            return;
        }

        IWorkbenchPage page = window.getActivePage();

        // iterate all open editors
        IEditorReference[] editors = page.getEditorReferences();

        for (IEditorReference e : editors) {
            // get editor and reactivate it
            IEditorPart editor = e.getEditor(true);

            WordWrapUtils.setWordWrap(editor, state);
        }
    }

#end
#end
#No. 185496
#File: E:\bishe\1\WorkArea.java
#Comment:
	/**
	 * Initializes a ByteBuffer and sets value of matching fields for use as 
	 * input to a function call (Work Area One).
	 * @param parameters Work Area One function arguments
	 * @return Initialized ByteBuffer with values in the specified field positions.
	 */

#Code:
	public ByteBuffer createBuffer(Map<String, Object> parameters)
	{
		ByteBuffer buffer = createByteBuffer();
		for (Field field : fields)
		{
			log.trace("Before write ByteBuffer.position={}", buffer.position());
			field.write(resolveInputValue(parameters, field), buffer);
			log.trace("After write ByteBuffer.position={}", buffer.position());
		}
		buffer.flip();
		return buffer;
	}

#end
#end
#No. 185497
#File: E:\bishe\1\WorkArea.java
#Comment:
	/**
	 * Initializes an empty ByteBuffer sized for the fields in this WorkArea.
	 * Used to create a properly sized Work Area Two buffer.
	 * @return initialized and empty ByteBuffer
	 */

#Code:
	public ByteBuffer createBuffer()
	{
		ByteBuffer buffer = createByteBuffer();
		for (Field field : fields)
		{
			field.write(buffer);
		}
		buffer.flip();
		return buffer;
	}

#end
#end
#No. 185498
#File: E:\bishe\1\WorkbenchShellHandler.java
#Comment:
	/**
	 * Gets instance of WorkbenchShellHandler.
	 * 
	 * @return instance of WorkbenchShellHandler
	 */

#Code:
	public static WorkbenchShellHandler getInstance(){
		if(instance == null){
			instance = new WorkbenchShellHandler();
		}
		return instance;
	}

#end
#end
#No. 185499
#File: E:\bishe\1\WorkbenchShellHandler.java
#Comment:
	/**
	 * Closes all opened {@link Shell}s except the workbench shell.
	 */

#Code:
	public void closeAllNonWorbenchShells(){
		this.closeAllNonWorbenchShells(null);
	}

#end
#end
#No. 185500
#File: E:\bishe\1\WorkbenchShellHandler.java
#Comment:
	/**
	 * Closes all opened {@link Shell}s except the workbench shell.
	 * There can be executed action before closing shells.
	 * 
	 * @param beforeShellIsClosed callback method is 
	 * {@link IBeforeShellIsClosed#runBeforeShellIsClosed(Shell)} called before 
	 * shells are closed
	 */

#Code:
	public void closeAllNonWorbenchShells(IBeforeShellIsClosed beforeShellIsClosed) {
		log.info("Closing all shells...");
		List<Shell> shells = getNonWorbenchShellsToClose();
		long timeOut = System.currentTimeMillis() + (TimePeriod.VERY_LONG.getSeconds() * 1000);
		do {
			// first try to close active shell and reload shells list
			Shell s = getFilteredActiveShell(shells);
			// if no active shell present close first one
			try{
				if (s == null && shells.size() > 0){
					s = shells.get(0);
				}
				if (s != null && !s.isDisposed()) {
					if (beforeShellIsClosed != null){
						beforeShellIsClosed.runBeforeShellIsClosed(s);
					}
					closeShellSafely(s);
				}
			} catch (CoreLayerException ex){
				if(!ShellHandler.getInstance().isDisposed(s)){
					throw ex;
				}
			}
			// reload current shells list
			shells = getNonWorbenchShellsToClose();
		} while ((shells.size() > 0) && (System.currentTimeMillis() < timeOut));
	}

#end
#end
#No. 185501
#File: E:\bishe\1\WorkbenchShellHandler.java
#Comment:
	/**
	 * Close shell safely.
	 *
	 * @param swtShell
	 *            the swt shell
	 */

#Code:
	private void closeShellSafely(Shell swtShell) {
		try{
			String text = ShellHandler.getInstance().getText(swtShell);
			log.info("Close shell " + text);
			try {
				clickCancelButton();
			} catch (Exception e) {
				ShellHandler.getInstance().notifyWidget(SWT.Close, swtShell);
				ShellHandler.getInstance().closeShell(swtShell);
			}
			new WaitWhile(new ShellIsAvailable(text));
		} catch (Exception e) {
			if(swtShell.isDisposed()){
				//ok, shell is disposed
			} else {
				throw e;
			}
		}
	}

#end
#end
#No. 185502
#File: E:\bishe\1\WorkbenchShellLookup.java
#Comment:
	/**
	 * Gets instance of ShellLookup.
	 * 
	 * @return ShellLookup instance
	 */

#Code:
	public static WorkbenchShellLookup getInstance() {
		if (instance == null)
			instance = new WorkbenchShellLookup();
		return instance;
	}

#end
#end
#No. 185503
#File: E:\bishe\1\WorkbenchShellLookup.java
#Comment:
	/**
	 * Gets active workbench shell.
	 * 
	 * @return active workbench shell
	 */

#Code:
	public Shell getWorkbenchShell() {
		return Display.syncExec(new ResultRunnable<Shell>() {
			@Override
			public Shell run() {
				return PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
			}
		});
	}

#end
#end
#No. 185504
#File: E:\bishe\1\WorkbookService.java
#Comment:
    /**
     * Get ID of loaded workbook
     *
     * @return A workbook ID which is acceptable by <code>LoaderService</code>
     */

#Code:
    public String getCurrent() {
        return current;
    }

#end
#end
#No. 185505
#File: E:\bishe\1\WorkbookService.java
#Comment:
    /**
     * Switch to `name`d sheet. If there does not exist any sheet with the given
     * name, the active sheet is renamed to the given name.
     *
     * The rule is derived from the following use-case.
     *
     * If the user select a sheet from drop-down menu, this means that the sheet
     * already exist. So we can switch to that sheet. If the sheet does not
     * exist, we can say that the user has not selected it from drop-down but
     * directly modified the name of existing in the input text box.
     *
     * @param name Worksheet name
     */

#Code:
    public void setActiveSheet(String name) {
        com.aspose.cells.Worksheet ws = getAsposeWorksheets().get(name);
        if (ws != null) {
            int i = ws.getIndex();
            getAsposeWorksheets().setActiveSheetIndex(i);
        } else {
            com.aspose.cells.Workbook wb = getAsposeWorkbook();
            wb.getWorksheets().get(wb.getWorksheets().getActiveSheetIndex()).setName(name);
        }

        purge();
    }


#end
#end
#No. 185508
#File: E:\bishe\1\Workdays.java
#Comment:
	/**
     * Get Workdays by Company
     *
     * @param   company Company ID
     * @param   fromDate Start date
     * @param   tillDate End date
     * @param   params (Optional) Parameters
     * @throws	JSONException If error occurred
	 * @return	{@link JSONObject}
     */

#Code:
    public JSONObject getByCompany(String company, String fromDate, String tillDate, HashMap<String, String> params) throws JSONException {
        return oClient.get("/team/v2/workdays/companies/" + company + "/" + fromDate + "," + tillDate, params);
    }

#end
#end
#No. 185509
#File: E:\bishe\1\Workdays.java
#Comment:
    /**
     * Get Workdays by Contract
     *
     * @param   contract Contract ID
     * @param   fromDate Start date
     * @param   tillDate End date
     * @param   params (Optional) Parameters
     * @throws	JSONException If error occurred
	 * @return	{@link JSONObject}
     */

#Code:
    public JSONObject getByContract(String contract, String fromDate, String tillDate, HashMap<String, String> params) throws JSONException {
        return oClient.get("/team/v2/workdays/contracts/" + contract + "/" + fromDate + "," + tillDate, params);
    }

#end
#end
#No. 185511
#File: E:\bishe\1\Workdiary.java
#Comment:
	/**
     * Get Workdiary
     *
     * @param   company Company ID
     * @param   username User ID
     * @param   date Date
     * @param   params (Optional) Parameters
     * @throws	JSONException If error occurred
	 * @return	{@link JSONObject}
     */

#Code:
    public JSONObject get(String company, String username, String date, HashMap<String, String> params) throws JSONException {
        return oClient.get("/team/v1/workdiaries/" + company + "/" + username + "/" + date, params);
    }

#end
#end
#No. 185512
#File: E:\bishe\1\Workdiary.java
#Comment:
    /**
     * Get Work Diary by Contract
     *
     * @param   contract Contract ID
     * @param   date Date
     * @param   params (Optional) Parameters
     * @throws	JSONException If error occurred
	 * @return	{@link JSONObject}
     */

#Code:
    public JSONObject getByContract(String contract, String date, HashMap<String, String> params) throws JSONException {
        return oClient.get("/team/v2/workdiaries/contracts/" + contract + "/" + date, params);
    }

#end
#end
#No. 185513
#File: E:\bishe\1\WorkDir.java
#Comment:
    /**
     * Clean up a raw string to fit within the rules of a valid filename on all OS's.
     * 
     * @param raw
     *            the raw string to cleanup
     * @return the cleaned up version
     */

#Code:
    public static String toSafeFilename(String raw) {
        char[] filename = raw.toCharArray();
        int len = filename.length;
        for (int i = 0; i < len; i++) {
            switch (filename[i]) {
            case '/':
            case '\\':
            case '?':
            case '%':
            case '*':
            case ':':
            case '|':
            case '"':
            case '<':
            case '>':
            case ' ':
                filename[i] = '_';
                break;
            }
        }
        return String.valueOf(filename);
    }

#end
#end
#No. 185514
#File: E:\bishe\1\WorkDirHelper.java
#Comment:
	/**
	 * Find the {@code work} directory, starting at the {@code user.dir} directory. Search
	 * is performed by walking the parent directories.
	 * @return the {@link File} pointing to the {@code work} directory
	 * @throws IllegalStateException If the {@code work} directory cannot be found.
	 */

#Code:
	public static File findWorkDir() {
		return findWorkDir(new File(System.getProperty("user.dir")));
	}

#end
#end
#No. 185515
#File: E:\bishe\1\WorkDirHelper.java
#Comment:
	/**
	 * Find the {@code work} directory, starting at the given {@code directory}. Search is
	 * performed by walking the parent directories.
	 * @return the {@link File} pointing to the {@code work} directory
	 * @throws IllegalStateException If the {@code work} directory cannot be found.
	 */

#Code:
	public static File findWorkDir(File directory) {

		File searchLevel = directory;
		while (searchLevel.getParentFile() != null
				&& searchLevel.getParentFile() != searchLevel) {

			File work = new File(searchLevel, "work");
			if (work.isDirectory() && work.exists()) {
				return work;
			}

			searchLevel = searchLevel.getParentFile();
		}

		throw new IllegalStateException(String.format(
				"Cannot find work directory in %s or any parent directories",
				directory.getAbsoluteFile()));
	}

#end
#end
#No. 185516
#File: E:\bishe\1\WorkdirManager.java
#Comment:
  /**
   * Returns the path to the local GIT repository for the specified project. Creates the folder if
   * it does not exist.
   *
   * @param projectId ID of the project whose working directory to find.
   * @return path to the local GIT repository of the specified project.
   */

#Code:
  public Path getLocalGitRoot(Long projectId) {
    Project project = projectRepository.findOne(projectId);
    Path workdir = config.getWorkdir().resolve("projects/" + project.getWorkdirName());
    createDirIfNecessary(workdir);
    return workdir;
  }

#end
#end
#No. 185517
#File: E:\bishe\1\WorkerAdapter.java
#Comment:
    /**
     * Provides an optional argument that will be passed to {@link com.j_spaces.worker.IWorker#init(com.j_spaces.core.IJSpace,
     * String, String)} (the last argument).
     */

#Code:
    public void setArgument(String argument) {
        this.argument = argument;
    }

#end
#end
#No. 185518
#File: E:\bishe\1\WorkerAdapter.java
#Comment:
    /**
     * Sets the worker name that will be used as the second parameter to the worker init method.
     */

#Code:
    public void setWorkerName(String workerName) {
        this.workerName = workerName;
    }

#end
#end
#No. 185519
#File: E:\bishe\1\WorkerAdapter.java
#Comment:
    /**
     * Should the worker be active only when the Space is in primary mode. Defaults to
     * <code>false</code>. Setting this to <code>true</code> means that the worker will start
     * regardless of the space state.
     */

#Code:
    public void setActiveWhenBackup(boolean activeWhenBackup) {
        this.activeWhenBackup = activeWhenBackup;
    }



#end
#end
#No. 185521
#File: E:\bishe\1\WorkerCompleteStatus.java
#Comment:
	/**
	 * @param upTime
	 * @param configuration
	 * @param masterPeer
	 * @param status
	 * @param currentPlaypenDirPath
	 */

#Code:
	@Req("REQ095")
	public WorkerCompleteStatus( long upTime, String configuration, WorkerStatus status, 
			PeerStatusInfo peerInfo, String currentPlaypenDirPath) {
		this(upTime, configuration, status, peerInfo, currentPlaypenDirPath, null);
	}

#end
#end
#No. 185522
#File: E:\bishe\1\WorkerControlResource.java
#Comment:
    /**
     * @param controllerId the controller acquiring the lock
     * @return 204 on success, 412 on failure
     */

#Code:
    @POST
    @Path("acquireLock/{controllerId}")
    public Response acquireLock(@PathParam("controllerId") UUID controllerId) {
        synchronized (this) {
            Response response = expectLockStatus(false);
            if (response != null) {
                return response;
            }

            logger.info("Lock granted to controllerId <" + controllerId + ">");
            lockingControllerId = controllerId;
            locked = true;
        }

#end
#end
#No. 185523
#File: E:\bishe\1\WorkerControlResource.java
#Comment:
    /**
     * @param controllerId the controller acquiring the lock; must be the one who acquired the lock
     * @return 204 on success, 412 on failure
     */

#Code:
    @POST
    @Path("releaseLock/{controllerId}")
    public synchronized Response releaseLock(@PathParam("controllerId") UUID controllerId) {
        synchronized (this) {
            Response response = expectLockStatus(true);
            if (response != null) {
                return response;
            }

            if (!controllerId.equals(lockingControllerId)) {
                logger.info(
                    "Attempt to unlock with controllerId <" + controllerId + "> but locked by <" + lockingControllerId +
                        ">");
                return Response.status(Response.Status.PRECONDITION_FAILED).build();
            }

            logger.info("controllerId <" + controllerId + "> released lock");
            lockingControllerId = null;
            locked = false;
        }

#end
#end
#No. 185524
#File: E:\bishe\1\WorkerControlResource.java
#Comment:
    /**
     * @return the JSON LockStatus object
     */

#Code:
    @GET
    @Path("lockStatus")
    public synchronized LockStatus getLockStatus() {
        return new LockStatus(locked, lockingControllerId);
    }

#end
#end
#No. 185525
#File: E:\bishe\1\WorkerControlResource.java
#Comment:
    /**
     * @param expected expected state of {@code locked}
     * @return Response null if the check succeeds (so no error response needs to be sent back), or an error response if
     *         the check failed
     */

#Code:
    @Nullable
    private Response expectLockStatus(boolean expected) {
        logger.debug("Expecting lockStatus to be " + expected + " (it is " + locked + ")");

        if (locked != expected) {
            lockingControllerId = null;
            return Response.status(Response.Status.PRECONDITION_FAILED).build();
        }

        return null;
    }


#end
#end
#No. 185527
#File: E:\bishe\1\WorkerEntry.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public String getPeerID() {
		return this.request.getPeerID();
	}

#end
#end
#No. 185528
#File: E:\bishe\1\WorkerFailureResponseTO.java
#Comment:
	/**
	 * @return the wmAddress
	 */

#Code:
	public String getWmAddress() {
		return wmAddress;
	}

#end
#end
#No. 185529
#File: E:\bishe\1\WorkerFailureResponseTO.java
#Comment:
	/**
	 * @param wmAddress the wmAddress to set
	 */

#Code:
	public void setWmAddress(String wmAddress) {
		this.wmAddress = wmAddress;
	}

#end
#end
#No. 185530
#File: E:\bishe\1\WorkerFailureResponseTO.java
#Comment:
	/**
	 * @return the serviceName
	 */

#Code:
	public String getServiceName() {
		return serviceName;
	}

#end
#end
#No. 185531
#File: E:\bishe\1\WorkerFailureResponseTO.java
#Comment:
	/**
	 * @param serviceName the serviceName to set
	 */

#Code:
	public void setServiceName(String serviceName) {
		this.serviceName = serviceName;
	}

#end
#end
#No. 185532
#File: E:\bishe\1\WorkerGroup.java
#Comment:
    /**
     * Changes the event loop used to process IO for all workers.  When a worker group is in use by a SSConnection,
     * backend connections held by its workers should share the same event loop as the client connection,
     * so that passing IO between frontend and backend sockets doesn't require any locking or context switching.
     *
     * @param preferredEventLoop
     */

#Code:
    public void bindToClientThread(EventLoopGroup preferredEventLoop) {
        if (preferredEventLoop == null)
            this.clientEventLoop = SharedEventLoopHolder.getLoop();
        else
            this.clientEventLoop = preferredEventLoop;

        if (workerMap != null){
            for (Worker worker : workerMap.values()){
                try {
                    worker.bindToClientThread(preferredEventLoop);
                } catch (PESQLException e) {
                    logger.warn(this+" encountered problem binding worker to client event loop",e);
                }
            }
        }
    }

#end
#end
#No. 185534
#File: E:\bishe\1\WorkerLoadStats.java
#Comment:
  /**
   * Performs a deep copy on <i>other</i>.
   */

#Code:
  public WorkerLoadStats(WorkerLoadStats other) {
    __isset_bit_vector.clear();
    __isset_bit_vector.or(other.__isset_bit_vector);
    this.one_minute_load = other.one_minute_load;
    this.five_minutes_load = other.five_minutes_load;
    this.fifteen_minutes_load = other.fifteen_minutes_load;
  }

#end
#end
#No. 185535
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */

#Code:
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INSTANCE_TYPE
            return INSTANCE_TYPE;
          default:
            return null;
        }
      }

#end
#end
#No. 185536
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */

#Code:
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

#end
#end
#No. 185537
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */

#Code:
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

#end
#end
#No. 185538
#File: E:\bishe\1\WorkerManager.java
#Comment:
    /**
     * Performs a deep copy on <i>other</i>.
     */

#Code:
    public add_worker_args(add_worker_args other) {
      if (other.is_set_instance_type()) {
        this.instance_type = other.instance_type;
      }
    }

#end
#end
#No. 185539
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */

#Code:
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // NE
            return NE;
          default:
            return null;
        }
      }

#end
#end
#No. 185540
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */

#Code:
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

#end
#end
#No. 185541
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */

#Code:
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

#end
#end
#No. 185542
#File: E:\bishe\1\WorkerManager.java
#Comment:
    /**
     * Performs a deep copy on <i>other</i>.
     */

#Code:
    public add_worker_result(add_worker_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.is_set_ne()) {
        this.ne = new NebuException(other.ne);
      }
    }

#end
#end
#No. 185543
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */

#Code:
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INSTANCE_NAME
            return INSTANCE_NAME;
          default:
            return null;
        }
      }

#end
#end
#No. 185544
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */

#Code:
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

#end
#end
#No. 185545
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */

#Code:
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

#end
#end
#No. 185546
#File: E:\bishe\1\WorkerManager.java
#Comment:
    /**
     * Performs a deep copy on <i>other</i>.
     */

#Code:
    public remove_worker_args(remove_worker_args other) {
      if (other.is_set_instance_name()) {
        this.instance_name = other.instance_name;
      }
    }

#end
#end
#No. 185547
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */

#Code:
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // NE
            return NE;
          default:
            return null;
        }
      }

#end
#end
#No. 185548
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */

#Code:
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

#end
#end
#No. 185549
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */

#Code:
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

#end
#end
#No. 185550
#File: E:\bishe\1\WorkerManager.java
#Comment:
    /**
     * Performs a deep copy on <i>other</i>.
     */

#Code:
    public remove_worker_result(remove_worker_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.is_set_ne()) {
        this.ne = new NebuException(other.ne);
      }
    }

#end
#end
#No. 185551
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */

#Code:
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // INSTANCE_NAME
            return INSTANCE_NAME;
          default:
            return null;
        }
      }

#end
#end
#No. 185552
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */

#Code:
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

#end
#end
#No. 185553
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */

#Code:
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

#end
#end
#No. 185554
#File: E:\bishe\1\WorkerManager.java
#Comment:
    /**
     * Performs a deep copy on <i>other</i>.
     */

#Code:
    public update_status_args(update_status_args other) {
      if (other.is_set_instance_name()) {
        this.instance_name = other.instance_name;
      }
    }

#end
#end
#No. 185555
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */

#Code:
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // NE
            return NE;
          default:
            return null;
        }
      }

#end
#end
#No. 185556
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */

#Code:
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

#end
#end
#No. 185557
#File: E:\bishe\1\WorkerManager.java
#Comment:
      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */

#Code:
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

#end
#end
#No. 185558
#File: E:\bishe\1\WorkerManager.java
#Comment:
    /**
     * Performs a deep copy on <i>other</i>.
     */

#Code:
    public update_status_result(update_status_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.is_set_ne()) {
        this.ne = new NebuException(other.ne);
      }
    }

#end
#end
#No. 185559
#File: E:\bishe\1\WorkerManagerSync.java
#Comment:
/**
 * The WorkerManagerSync message allows the sender to make
 * sure the workermanager has processed all pending messages
 * (such as async ReturnWorkerRequest messages)
 */

#Code:
public class WorkerManagerSync extends WorkerManagerRequest implements
		Serializable {

	private static final long serialVersionUID = 1L;

	@Override
	public ResponseMessage executeRequest(Envelope e, WorkerManager wm)
			throws PEException {
		return new GenericResponse().success();
	}

	@Override
	public MessageType getMessageType() {
		return null;
	}

	@Override
	public MessageVersion getVersion() {
		return null;
	}

}

#end
#end
#No. 185560
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param brokerPublicKey
	 * @return
	 */

#Code:
	public static String getUnknownConsumerDisposingWorkerMessage(
			String brokerPublicKey) {
		return "Ignoring an unknown consumer which disposed a worker. Consumer public key: " + 
				brokerPublicKey;
	}

#end
#end
#No. 185561
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param brokerPublicKey
	 * @return
	 */

#Code:
	public static String getNotLoggedConsumerDisposingWorkerMessage(
			String brokerPublicKey) {
		return "Ignoring a not logged consumer which disposed a worker. Consumer public key: " + 
				brokerPublicKey;
	}

#end
#end
#No. 185562
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public static String getNullConsumerChangeStatusToAllocatedForBroker() {
		return "Allocation with a null consumer. The status change was ignored.";
	}

#end
#end
#No. 185563
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public static String getDifferentConsumerChangeStatusToAllocatedForBroker() {
		return "Allocation with a different consumer. The status change was ignored.";
	}

#end
#end
#No. 185564
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public static String getNullConsumerChangeStatusToAllocatedForPeer() {
		return "Allocation with a null consumer. The status change was ignored.";
	}

#end
#end
#No. 185565
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public static String getDifferentConsumerChangeStatusToAllocatedForPeer() {
		return "Allocation with a different consumer. The status change was ignored.";
	}

#end
#end
#No. 185566
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param brokerPublicKey
	 * @return
	 */

#Code:
	public static String getNotLoggedUserDisposingWorkerMessage(String brokerPublicKey) {
		return "A not logged consumer disposed a worker. This disposal was ignored. Consumer public key " + 
				brokerPublicKey;
	}

#end
#end
#No. 185567
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param localWorker
	 * @param lwpcOID
	 * @return
	 */

#Code:
	public static String getConsumerDisposingNotAllocatedWorkerMessage(String wAddress,
			String lwpcOID) {
		return "The consumer [" + lwpcOID + "] disposed the worker " +
				"[" + wAddress + "], that is not allocated for him. This disposal was ignored.";
	}

#end
#end
#No. 185568
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param lwpcOID
	 * @return
	 */

#Code:
	public static String getUnknownWorkerDisposalMessage(String lwpcOID) {
		return "The consumer [" + lwpcOID + 
				"] disposed an unknown worker. This disposal was ignored.";
	}

#end
#end
#No. 185569
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param lwpc
	 * @return
	 */

#Code:
	public static String getNullWorkerDisposalMessage(String lwpcDID) {
		return "The consumer [" + lwpcDID + 
				"] disposed a null worker. This disposal was ignored.";
	}

#end
#end
#No. 185570
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param providerID
	 * @param workerID
	 * @return
	 */

#Code:
	public static String getDisposingWorkerToRemoteProviderMessage(
			String providerID, String workerID) {
		return "The remote worker " + workerID +" does not match any request. " +
				"Disposing it back to its provider: "+ providerID+ ".";
	}

#end
#end
#No. 185571
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param brokerPublicKey
	 * @return
	 */

#Code:
	public static String getUnknownConsumerMarkedUnwantedWorkerMessage(
			String brokerPublicKey) {
		return "Ignoring an unknown consumer that set a worker as unwanted. Consumer public key: " + brokerPublicKey;
	}

#end
#end
#No. 185572
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param lwpcString
	 * @return
	 */

#Code:
	public static String getNullUnwantedWorkerMessage(String lwpcString) {
		return "Ignoring the consumer [" + lwpcString + "] that set a null worker as unwanted.";
	}

#end
#end
#No. 185573
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param lwpcString
	 * @param workerString
	 * @return
	 */

#Code:
	public static String getUnknownUnwantedWorkerMessage(String lwpcString,
			String workerString) {
		return "Ignoring the consumer [" + lwpcString + "] that set the unknown worker " +
				"[" + workerString + "] as unwanted.";
	}

#end
#end
#No. 185574
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param lwpcString
	 * @param workerString
	 * @return
	 */

#Code:
	public static String getNotAllocatedUnwantedWorkerMessage(String lwpcString,
			String workerString) {
		return "Ignoring the consumer [" + lwpcString + "] that set a not allocated worker " +
				"[" + workerString + "] as unwanted.";
	}

#end
#end
#No. 185575
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param lwpcString
	 * @param workerString
	 * @param isLocal
	 * @return
	 */

#Code:
	public static String getNullRequestUnwantedWorkerMessage(String lwpcString,
			String workerString, boolean isLocal) {
		return "Ignoring the consumer [" + lwpcString + "] that set the " +
				(isLocal ? "" : "remote ") + "worker [" + workerString + "]" +
						" as unwanted for a null request.";
	}

#end
#end
#No. 185576
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param requestID
	 * @param lwpcString
	 * @param workerString
	 * @param isLocal
	 * @return
	 */

#Code:
	public static String getInvalidRequestUnwantedWorkerMessage(
			long requestID, String lwpcString,
			String workerString, boolean isLocal) {
		return "Ignoring the consumer [" + lwpcString + "] that set the " +
				(isLocal ? "" : "remote ") + "worker [" + workerString + "]" +
						" as unwanted for an invalid request [" + requestID + "].";
	}

#end
#end
#No. 185577
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param remoteWorkerID
	 * @return
	 */

#Code:
	public static String getRemoteWorkerFailureMessage(String remoteWorkerID) {
		return "The remote Worker [" + remoteWorkerID + "] has failed. Disposing this Worker.";
	}

#end
#end
#No. 185578
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param remoteWorkerID
	 * @return
	 */

#Code:
	public static String getAlreadyDeliveredRemoteWorkerFailureMessage(
			String remoteWorkerID) {
//		return "Failure of a remote Worker [" + remoteWorkerID + "] that was already delivered. " +
//				"This notification was ignored.";
		return "Failure of a remote Worker [" + remoteWorkerID + "] that was already delivered.";
	}

#end
#end
#No. 185579
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param remoteWorkerID
	 * @return
	 */

#Code:
	public static String getUnknownOrDisposedRemoteWorkerFailureMessage(String remoteWorkerID) {
		return "Failure of an unknown or already disposed remote Worker [" + remoteWorkerID  + "]. This notification was ignored.";
	}

#end
#end
#No. 185580
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param remoteWorkerID
	 * @return
	 */

#Code:
	public static String getUnknownOrDisposedPreemptedRemoteWorkerMessage(String remoteWorkerPublicKey) {
		return "Preemption of an unknown or already disposed remote Worker " +
				"with public key[" + remoteWorkerPublicKey  + "]. This notification was ignored.";
	}

#end
#end
#No. 185581
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param lwpcOID
	 * @param rwmOID
	 * @return
	 */

#Code:
	public static String getGivingRemoteWorkerMessage(String lwpcOID, String rwmOID) {
		return "Giving the remote worker [" + rwmOID + "] to [" + lwpcOID + "].";
	}

#end
#end
#No. 185582
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param workerString
	 * @return
	 */

#Code:
	public static String getNullRemoteWorkerStatusChangedMessage(
			String workerString) {
		return "The remote worker " + workerString +
				" changed its status to ALLOCATED FOR BROKER, but it did not provide a worker reference. " +
				"This status change was ignored.";
	}

#end
#end
#No. 185583
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param wmPublicKey
	 * @return
	 */

#Code:
	public static String getUnknownRemoteWorkerStatusChangedMessage(String wmPublicKey) {
		return "An unknown worker changed its status to Allocated for Broker. " +
				"It will be ignored. Worker public key: " + wmPublicKey;
	}

#end
#end
#No. 185584
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param providerString
	 * @return
	 */

#Code:
	public static String getReceivingNullRemoteWorkerMessage(
			String providerString) {
		return "Ignoring a null worker, which was received from the provider: " + providerString;
	}

#end
#end
#No. 185585
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param senderPublicKey
	 * @return
	 */

#Code:
	public static String getReceivingNullRemoteProviderMessage(String senderPublicKey) {
		return "Ignoring a null provider. Sender public key: " + senderPublicKey;
	}

#end
#end
#No. 185586
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param providerString
	 * @return
	 */

#Code:
	public static String getReceivingNullWorkerSpecRemoteWorkerMessage(
			String providerString) {
		return "Ignoring a worker without specification, which was received from the provider: " + providerString;
	}

#end
#end
#No. 185587
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param workerString
	 * @return
	 */

#Code:
	public static String getReceivingAlreadyAllocatedRemoteWorkerMessage(
			String workerString) {
		return "Receiving a remote worker ["+ workerString +"] that is already allocated in this peer. " +
				"This message was ignored.";
	}

#end
#end
#No. 185588
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param providerString
	 * @param workerString
	 * @return
	 */

#Code:
	public static String getReceivedRemoteWorkerMessage(String providerString,
			String workerString) {
		return "Received a worker ["+ workerString +"] from a remote worker provider ["+ providerString + "].";
	}

#end
#end
#No. 185589
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param workerString
	 * @param newAttributes
	 * @return
	 */

#Code:
	public static String getWorkerSpecUpdatedMessage(String workerString,
			Map<String, String> newAttributes) {
		return "The Worker [" + workerString + "] updated its specification. Updated attributes: "
				+ newAttributes + ".";
	}

#end
#end
#No. 185590
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param workerPublicKey
	 * @return
	 */

#Code:
	public static String getUnknownWorkerUpdatingSpecMessage(String workerPublicKey) {
		return "An unknown Worker has updated its specification. This message was ignored." +
				" Unknown worker public key: [" + workerPublicKey + "]";
	}

#end
#end
#No. 185591
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param failedWorkerOID
	 * @return
	 */

#Code:
	public static String getFailedWorkerMessage(String failedWorkerAddress) {
		return "Worker <" + failedWorkerAddress + "> is now DOWN";
	}

#end
#end
#No. 185592
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param failedWorkerOID
	 * @return
	 */

#Code:
	public static String getNonRecoveredWorkerFailureMessage(String failedWorkerAddress) {
		return "Failure of a non-recovered worker: " + failedWorkerAddress;
	}

#end
#end
#No. 185593
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param failedWorkerAddress
	 * @return
	 */

#Code:
	public static String getNonExistentWorkerFailureMessage(String failedWorkerAddress) {
		return "Failure of a non-existent worker: " + failedWorkerAddress;
	}

#end
#end
#No. 185594
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param recoveredWorkerID
	 * @return
	 */

#Code:
	public static String getNotSetWorkerRecoveryMessage(String recoveredWorkerAddress) {
		return "Receiving a worker that was not set by 'setworkers': " + recoveredWorkerAddress;
	}

#end
#end
#No. 185595
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param recoveredWorkerID
	 * @return
	 */

#Code:
	public static String getExistentWorkerRecoveryMessage(String recoveredWorkerAddress) {
		return "Receiving an already existent worker: " + recoveredWorkerAddress;
	}

#end
#end
#No. 185596
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param recoveredWorkerID
	 * @return
	 */

#Code:
	public static String getWorkerRecoveryMessage(String recoveredWorkerAddress) {
		return "Worker <" + recoveredWorkerAddress + "> is now UP";
	}

#end
#end
#No. 185597
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param localWorkerID
	 * @return
	 */

#Code:
	public static String getInvalidStatusChangeMessage(String localWorkerString, 
			LocalWorkerState localWorkerState) {
		return "The worker <" + localWorkerString + "> (" + localWorkerState + 
				") changed its status to ALLOCATED_FOR_BROKER. This status change was ignored.";
	}

#end
#end
#No. 185598
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param workerOID
	 * @return
	 */

#Code:
	public static String getWrongPublicKeyForWorkerMessage(String workerString) {
		return "Wrong public key for Worker: " + workerString;
	}

#end
#end
#No. 185599
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param workerPubKey
	 * @return
	 */

#Code:
	public static String getUnknownWorkerChangingStatusMessage(String workerPubKey, WorkerStatus newState) {
		return "Unknown worker changed status: " + workerPubKey +"/"+ newState;
	}

#end
#end
#No. 185600
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param workerID
	 * @return
	 */

#Code:
	public static String getIgnoredStatusChangeMessage(String workerContainerID, LocalWorkerState oldState, WorkerStatus newState) {
		return "The worker <" + workerContainerID + "> (" + oldState + ") changed " +
				"its status to " + newState + ". This status change was ignored.";
	}

#end
#end
#No. 185601
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param localWorker
	 * @param rwpc
	 * @return
	 */

#Code:
	public static String getDonatingWorkerMessage(String workerContainerID, String rwpcContainerID) {
		return "Donating Worker <" + workerContainerID + "> to <" + rwpcContainerID + ">";
	}

#end
#end
#No. 185602
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param workerID
	 * @return
	 */

#Code:
	public static String getNullWorkerStatusChangedMessage(String workerID, WorkerStatus newStatus) {
		return "Worker <" + workerID + "> changed its status to" +
				" " + newStatus + ", but it did not provide a worker reference. This status change was ignored.";
	}

#end
#end
#No. 185603
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param localWorker
	 * @param allocable
	 * @return
	 */

#Code:
	public static String getGivingWorkerMessage(String workerID, String consumerID) {
		return "Giving Worker <" + workerID + "> to <" + consumerID + ">";
	}

#end
#end
#No. 185604
#File: E:\bishe\1\WorkerMessages.java
#Comment:
	/**
	 * @param workerID
	 * @param newState
	 * @return
	 */

#Code:
	public static String getStatusChangedMessage(String workerContainerID, LocalWorkerState newState) {
		return "Worker <" + workerContainerID + "> is now " + newState; 
	}

#end
#end
#No. 185605
#File: E:\bishe\1\WorkerMountStats.java
#Comment:
  /**
   * Performs a deep copy on <i>other</i>.
   */

#Code:
  public WorkerMountStats(WorkerMountStats other) {
    if (other.is_set_fs_sizes()) {
      Map<String,List<Integer>> __this__fs_sizes = new HashMap<String,List<Integer>>();
      for (Map.Entry<String, List<Integer>> other_element : other.fs_sizes.entrySet()) {

        String other_element_key = other_element.getKey();
        List<Integer> other_element_value = other_element.getValue();

        String __this__fs_sizes_copy_key = other_element_key;

        List<Integer> __this__fs_sizes_copy_value = new ArrayList<Integer>();
        for (Integer other_element_value_element : other_element_value) {
          __this__fs_sizes_copy_value.add(other_element_value_element);
        }

        __this__fs_sizes.put(__this__fs_sizes_copy_key, __this__fs_sizes_copy_value);
      }
      this.fs_sizes = __this__fs_sizes;
    }
  }


#end
#end
#No. 185609
#File: E:\bishe\1\WorkerSideMsgHandler.java
#Comment:
  /**
   * Hand over values given from the server to {@link AsyncWorkerHandler}.
   * Throws an exception if messages of an unexpected type arrive.
   */

#Code:
  @Override
  public void onNext(final Message<AvroParameterServerMsg> msg) {
    LOG.entering(WorkerSideMsgHandler.class.getSimpleName(), "onNext");

    final AvroParameterServerMsg innerMsg = SingleMessageExtractor.extract(msg);
    switch (innerMsg.getType()) {
    case ReplyMsg:
      onReplyMsg(innerMsg.getReplyMsg());
      break;

    default:
      throw new RuntimeException("Unexpected message type: " + innerMsg.getType().toString());
    }

    LOG.exiting(WorkerSideMsgHandler.class.getSimpleName(), "onNext");
  }

#end
#end
#No. 185610
#File: E:\bishe\1\WorkerState.java
#Comment:
/**
 * It presents the states of {@link Worker}.
 */

#Code:
public enum WorkerState {
  /** New worker */
  NEW,

  /** Running worker */
  RUNNING,

  /** Worker is unhealthy */
  UNHEALTHY,

  /** worker is out of service */
  DECOMMISSIONED,

  /** worker has not sent a heartbeat for some configured time threshold */
  LOST;

  @SuppressWarnings("unused")
  public boolean isUnusable() {
    return (this == UNHEALTHY || this == DECOMMISSIONED || this == LOST);
  }
}

#end
#end
#No. 185611
#File: E:\bishe\1\WorkerStatusChange.java
#Comment:
	/**
	 * @return the id
	 */

#Code:
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	public Integer getId() {
		return id;
	}

#end
#end
#No. 185612
#File: E:\bishe\1\WorkerStatusChange.java
#Comment:
	/**
	 * @param id
	 *            the id to set
	 */

#Code:
	public void setId(Integer id) {
		this.id = id;
	}

#end
#end
#No. 185613
#File: E:\bishe\1\WorkerStatusChange.java
#Comment:
	/**
	 * @return the worker
	 */

#Code:
	@ManyToOne
	public Worker getWorker() {
		return worker;
	}

#end
#end
#No. 185614
#File: E:\bishe\1\WorkerStatusChange.java
#Comment:
	/**
	 * @param worker
	 *            the worker to set
	 */

#Code:
	public void setWorker(Worker worker) {
		this.worker = worker;
	}

#end
#end
#No. 185615
#File: E:\bishe\1\WorkerStatusChange.java
#Comment:
	/**
	 * @return the changeTime
	 */

#Code:
	public Long getTimeOfChange() {
		return timeOfChange;
	}

#end
#end
#No. 185616
#File: E:\bishe\1\WorkerStatusChange.java
#Comment:
	/**
	 * @param changeTime
	 *            the changeTime to set
	 */

#Code:
	public void setTimeOfChange(Long changeTime) {
		this.timeOfChange = changeTime;
	}

#end
#end
#No. 185617
#File: E:\bishe\1\WorkerStatusChange.java
#Comment:
	/**
	 * @return the status
	 */

#Code:
	@Enumerated(EnumType.STRING)
	public WorkerStatus getStatus() {
		return status;
	}

#end
#end
#No. 185618
#File: E:\bishe\1\WorkerStatusChange.java
#Comment:
	/**
	 * @param status
	 *            the status to set
	 */

#Code:
	public void setStatus(WorkerStatus status) {
		this.status = status;
	}

#end
#end
#No. 185619
#File: E:\bishe\1\WorkerStatusChange.java
#Comment:
	/**
	 * @return the lastModified
	 */

#Code:
	public Long getLastModified() {
		return lastModified;
	}

#end
#end
#No. 185620
#File: E:\bishe\1\WorkerStatusChange.java
#Comment:
	/**
	 * @param lastModified the lastModified to set
	 */

#Code:
	public void setLastModified(Long lastModified) {
		this.lastModified = lastModified;
	}

#end
#end
#No. 185621
#File: E:\bishe\1\WorkerThreadTest.java
#Comment:
	/**
	 * @return the suite of tests being tested
	 */

#Code:
	public static Test suite() {
		return new TestSuite(WorkerThreadTest.class);
	}

#end
#end
#No. 185622
#File: E:\bishe\1\WorkerTopologyContext.java
#Comment:
    /**
     * Gets all the task ids that are running in this worker process
     * (including the task for this task).
     */

#Code:
    public List<Integer> getThisWorkerTasks() {
        return _workerTasks;
    }

#end
#end
#No. 185623
#File: E:\bishe\1\WorkerTopologyContext.java
#Comment:
    /**
     * Gets the location of the external resources for this worker on the
     * local filesystem. These external resources typically include bolts implemented
     * in other languages, such as Ruby or Python.
     */

#Code:
    public String getCodeDir() {
        return _codeDir;
    }

#end
#end
#No. 185624
#File: E:\bishe\1\WorkerTopologyContext.java
#Comment:
    /**
     * If this task spawns any subprocesses, those subprocesses must immediately
     * write their PID to this directory on the local filesystem to ensure that
     * Storm properly destroys that process when the worker is shutdown.
     */

#Code:
    public String getPIDDir() {
        return _pidDir;
    }

#end
#end
#No. 185625
#File: E:\bishe\1\WorkflowBuilderTest.java
#Comment:
	/**
	 * Create StartNode1 -> JoinNode -> EndNode
	 * 
	 * @throws FlowExecutionException
	 */

#Code:
	@Test
	public void testCreateWorkflowShort() throws FlowExecutionException{

		WorkflowBuilder builder = new WorkflowBuilder("org.neuro4j.TestWorkflow1", "StartNode1");;

		builder.addNext(createJoinNode());
		builder.addNext(createEndNode());
		
		Workflow workflow =  builder.build();
		
		
		WorkflowEngine engine = new WorkflowEngine(new ConfigBuilder());
		ExecutionResult result = engine.execute(workflow, "StartNode1", new WorkflowRequest());	
		assertNotNull(result);
		assertNull(result.getException());
	}

#end
#end
#No. 185626
#File: E:\bishe\1\WorkflowBuilderTest.java
#Comment:
	/**
	 * Create StartNode2 -> CustomNode(o.n.w.c.SystemOutBlock) ->JoinNode -> EndNode
	 *                         |- onError-> EndNode; 
	 *
	 *                          
	 * @throws FlowExecutionException
	 */

#Code:
	@Test
	public void testCreateWorkflowWithCustomNode() throws FlowExecutionException{

		Workflow workflow = new WorkflowBuilder("org.neuro4j.TestWorkflow1", "StartNode2") // creates workflow and StartNode
				                .addCustomNode("org.neuro4j.workflow.core.SystemOutBlock")
				                    // add mapping name -> varToPrint
				                   .withInputParam("varToPrint", "name")
				                      .withOnError(createEndNode()).done()
				                .addJoinNode()
				                .build(); // creates EndNode if does not exist

		
		// running workflow
		WorkflowEngine engine = new WorkflowEngine(new ConfigBuilder().withLoader(new ClasspathWorkflowLoader(converter)));
		
		WorkflowRequest request = new WorkflowRequest();
	
		request.addParameter("name", "Hello!!!");
		
		ExecutionResult result = engine.execute(workflow, "StartNode2", request);	
		assertNotNull(result);
		assertNull(result.getException());
	}

#end
#end
#No. 185634
#File: E:\bishe\1\WorkflowInstanceInclude.java
#Comment:
/**
 * The properties of a workflow instance that can be loaded if needed when using WorkflowInstanceService.getWorkflowInstance.
 */

#Code:
public enum WorkflowInstanceInclude {

  /**
   * The execution start date of the first action of the workflow instance (WorkflowInstance.started).
   */
  STARTED,

  /**
   * The most recent values of all state variables (WorkflowInstance.stateVariables).
   */
  CURRENT_STATE_VARIABLES,

  /**
   * The child workflow identifiers (WorkflowInstance.childWorkflows).
   */
  CHILD_WORKFLOW_IDS,

  /**
   * The actions related to this workflow instance (WorkflowInstance.actions).
   */
  ACTIONS,

  /**
   * The state variables for each action. Ignored if ACTIONS are not loaded (WorkflowInstanceAction.updatedStateVariables).
   */
  ACTION_STATE_VARIABLES

}

#end
#end
#No. 185635
#File: E:\bishe\1\WorkflowMode.java
#Comment:
/**
 * This enumerates the modes of the workflows that are currently known to Dockstore.
 *
 * @author dyuen
 */

#Code:
@ApiModel(description = "This enumerates the modes of the workflows that are currently known to Dockstore.")
public enum WorkflowMode {
    /**
     * A full workflow entry means that a user has attempted to publish this workflow. We should look at all branches
     * and tags for workflows
     */
    FULL, /**
     * A stub workflow entry means that we're aware of a repo. However, we should not do a full refresh or scan into that repo
     * to conserve quota
     */
    STUB
}


#end
#end
#No. 185639
#File: E:\bishe\1\WorkflowServiceTest.java
#Comment:
    /**
     * All Failures test for the workflowService
     */

#Code:
    public void testFaillureWorkflowService()
    {
        // //////////////////
        // PROCESS DEFINITION
        // //////////////////
        ProcessDefinition def = getProcessDefinition("wrongId");
        Assert.assertNull(def);

        // //////////////////
        // PROCESS
        // //////////////////
    }

#end
#end
#No. 185640
#File: E:\bishe\1\WorkflowStateProcessor.java
#Comment:
  /**
   * Handle retries for the state execution. Moves the workflow to a failure state after the maximum retry attempts is exceeded.
   * If there is no failure state defined for the retried state, moves the workflow to the generic error state and stops
   * processing. Error state handler method, if it exists, is not executed. If the maximum retry attempts is not exceeded,
   * schedules the next attempt for the state based on workflow settings. This method is called when an unexpected exception
   * happens during state method handling.
   *
   * @param execution
   *          State execution information.
   * @param definition
   *          Workflow definition
   */

#Code:
  void handleRetry(StateExecutionImpl execution, AbstractWorkflowDefinition<?> definition) {
    handleRetryAfter(execution, definition.getSettings().getErrorTransitionActivation(execution.getRetries()), definition);
  }

#end
#end
#No. 185641
#File: E:\bishe\1\WorkflowStateProcessor.java
#Comment:
  /**
   * Handle retries for the state execution. Moves the workflow to a failure state after the maximum retry attempts is exceeded.
   * If there is no failure state defined for the retried state, moves the workflow to the generic error state and stops
   * processing. Error state handler method, if it exists, is not executed. If the maximum retry attempts is not exceeded,
   * schedules the next attempt to the given activation time. This method is called when a retry attempt is explicitly requested
   * by a state handling method.
   *
   * @param execution
   *          State execution information.
   * @param activation
   *          Time for next retry attempt.
   * @param definition
   *          Workflow definition
   */

#Code:
  void handleRetryAfter(StateExecutionImpl execution, DateTime activation, AbstractWorkflowDefinition<?> definition) {
    if (execution.getRetries() >= definition.getSettings().maxRetries) {
      execution.setRetry(false);
      execution.setRetryCountExceeded();
      String currentStateName = execution.getCurrentStateName();
      WorkflowState failureState = definition.getFailureTransitions().get(currentStateName);
      WorkflowState currentState = definition.getState(currentStateName);
      if (failureState != null) {
        execution.setNextState(failureState);
        execution.setNextStateReason("Max retry count exceeded, going to failure state");
        execution.setNextActivation(now());
      } else {
        WorkflowState errorState = definition.getErrorState();
        execution.setNextState(errorState);
        if (errorState.equals(currentState)) {
          execution.setNextStateReason("Max retry count exceeded when handling error state, processing stopped");
          execution.setNextActivation(null);
        } else {
          execution.setNextStateReason("Max retry count exceeded, no failure state defined, going to error state");
          execution.setNextActivation(now());
        }
      }
    } else {
      execution.setNextActivation(activation);
    }
  }

#end
#end
#No. 185642
#File: E:\bishe\1\WorkflowStateSubmissionElement.java
#Comment:
	/**
	 * @param context
	 * @param encounterDatetime
	 * @param workflow
	 * @return
	 */

#Code:
	private PatientState getActivePatientState(Patient patient, Date encounterDatetime, ProgramWorkflow workflow) {
		PatientProgram patientProgram = HtmlFormEntryUtil.getPatientProgramByWorkflow(patient, workflow);
		if (patientProgram != null) {
			for (PatientState patientState : patientProgram.statesInWorkflow(workflow,false)) {
				if (patientState.getActive(encounterDatetime)) {
					return patientState;
				}
			}
		}
		return null;
	}

#end
#end
#No. 185643
#File: E:\bishe\1\WorkflowStateSubmissionElement.java
#Comment:
	/**
	 * @see org.openmrs.module.htmlformentry.action.FormSubmissionControllerAction#validateSubmission(org.openmrs.module.htmlformentry.FormEntryContext,
	 *      javax.servlet.http.HttpServletRequest)
	 */

#Code:
	@Override
	public Collection<FormSubmissionError> validateSubmission(FormEntryContext context, HttpServletRequest submission) {
		List<FormSubmissionError> errors = new ArrayList<FormSubmissionError>();
		return errors;
	}

#end
#end
#No. 185644
#File: E:\bishe\1\WorkflowStateSubmissionElement.java
#Comment:
	/**
	 * @see org.openmrs.module.htmlformentry.element.HtmlGeneratorElement#generateHtml(org.openmrs.module.htmlformentry.FormEntryContext)
	 */

#Code:
	@Override
	public String generateHtml(FormEntryContext context) {
		StringBuilder ret = new StringBuilder();
		if (label != null) {
			ret.append(label);
		}
		ret.append(widget.generateHtml(context));
		return ret.toString();
	}

#end
#end
#No. 185645
#File: E:\bishe\1\WorkflowStateTag.java
#Comment:
	/**
	 * @return the workflowId
	 */

#Code:
	public String getWorkflowId() {
		return workflowId;
	}

#end
#end
#No. 185646
#File: E:\bishe\1\WorkflowStateTag.java
#Comment:
	/**
	 * @return the stateIds
	 */

#Code:
	public List<String> getStateIds() {
		return stateIds;
	}

#end
#end
#No. 185647
#File: E:\bishe\1\WorkflowStateTag.java
#Comment:
	/**
	 * @return the stateLabels
	 */

#Code:
	public List<String> getStateLabels() {
		return stateLabels;
	}

#end
#end
#No. 185648
#File: E:\bishe\1\WorkflowStateTag.java
#Comment:
	/**
	 * @return the type
	 */

#Code:
	public String getType() {
		return type;
	}

#end
#end
#No. 185649
#File: E:\bishe\1\WorkflowStateTag.java
#Comment:
	/**
	 * @return the labelText
	 */

#Code:
	public String getLabelText() {
		return labelText;
	}

#end
#end
#No. 185650
#File: E:\bishe\1\WorkflowStateTag.java
#Comment:
	/**
	 * @return the labelCode
	 */

#Code:
	public String getLabelCode() {
		return labelCode;
	}

#end
#end
#No. 185651
#File: E:\bishe\1\WorkflowStateTag.java
#Comment:
	/**
	 * @return the allowedStyles
	 */

#Code:
	public Set<String> getAllowedTypes() {
		return allowedTypes;
	}

#end
#end
#No. 185652
#File: E:\bishe\1\WorkflowStateTagTest.java
#Comment:
    /**
	 * @param session
	 */

#Code:
	private void assertNotPresent(FormEntrySession session, String state) throws Exception {
		Assert.assertFalse("No " + state + " in result:" + session.getHtmlToDisplay(),
		    session.getHtmlToDisplay().contains(state));
	}

#end
#end
#No. 185653
#File: E:\bishe\1\WorkflowStateTagTest.java
#Comment:
	/**
	 * @param session
	 */

#Code:
	private void assertPresent(FormEntrySession session, String state) throws Exception {
		Assert.assertTrue(state + " in result: " + session.getHtmlToDisplay(), session.getHtmlToDisplay().contains(state));
	}

#end
#end
#No. 185654
#File: E:\bishe\1\WorkflowStateTagTest.java
#Comment:
	/**
	 * @param results
	 * @param state
	 * @return
	 */

#Code:
	private PatientProgram getPatientProgramByWorkflow(Patient patient, ProgramWorkflow workflow, Date activeDate) {
		List<PatientProgram> patientPrograms = Context.getProgramWorkflowService().getPatientPrograms(patient,
		    workflow.getProgram(), null, null, null, null, false);
		for (PatientProgram patientProgram : patientPrograms) {
			for (PatientState patientState : patientProgram.getStates()) {
				if (patientState.getState().getProgramWorkflow().equals(workflow)) {
					if (activeDate != null) {
						if (patientState.getActive(activeDate)) {
							return patientProgram;
						}
					} else {
						return patientProgram;
					}
				}
			}
		}
		return null;
	}

#end
#end
#No. 185655
#File: E:\bishe\1\WorkflowStateTagTest.java
#Comment:
	/**
	 * @param results
	 * @param state
	 * @return
	 */

#Code:
	private PatientProgram getPatientProgramByState(Patient patient, ProgramWorkflowState state, Date activeDate) {
		List<PatientProgram> patientPrograms = Context.getProgramWorkflowService().getPatientPrograms(patient,
		    state.getProgramWorkflow().getProgram(), null, null, null, null, false);
		for (PatientProgram patientProgram : patientPrograms) {
			for (PatientState patientState : patientProgram.getStates()) {
				if (patientState.getState().equals(state)) {
					if (activeDate != null) {
						if (patientState.getActive(activeDate)) {
							return patientProgram;
						}
					} else {
						return patientProgram;
					}
				}
			}
		}
		return null;
	}

#end
#end
#No. 185656
#File: E:\bishe\1\WorkflowStateTagTest.java
#Comment:
	/**
	 * @param patientProgram
	 * @param state
	 * @param activeDate
	 * @return
	 */

#Code:
	private PatientState getPatientState(PatientProgram patientProgram, ProgramWorkflowState state, Date activeDate) {
		for (PatientState patientState : patientProgram.getStates()) {
			if (patientState.getState().equals(state)) {
				if (activeDate != null) {
					if (patientState.getActive(activeDate)) {
						return patientState;
					}
				} else {
					return patientState;
				}
			}
		}
		return null;
	}

#end
#end
#No. 185657
#File: E:\bishe\1\WorkflowTaskListType.java
#Comment:
    /**
     * Gets the value of the workflowTasksGroup property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the workflowTasksGroup property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getWorkflowTasksGroup().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProvisionType }
     * {@link IfNotUserExistsType }
     * {@link AddGroupType }
     * {@link ResyncType }
     * {@link IfAttrHasValueType }
     * {@link IfAttrExistsType }
     * {@link AddAttributeType }
     * {@link MappingType }
     * {@link ApprovalType }
     * {@link CallWorkflowType }
     * {@link NotifyUserType }
     * {@link CustomTaskType }
     * {@link DeleteType }
     * 
     * 
     */

#Code:
    public List<WorkflowTaskType> getWorkflowTasksGroup() {
        if (workflowTasksGroup == null) {
            workflowTasksGroup = new ArrayList<WorkflowTaskType>();
        }
        return this.workflowTasksGroup;
    }

#end
#end
#No. 185658
#File: E:\bishe\1\WorkflowTasksType.java
#Comment:
    /**
     * Gets the value of the workflowTasksGroup property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the workflowTasksGroup property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getWorkflowTasksGroup().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProvisionType }
     * {@link IfNotUserExistsType }
     * {@link AddGroupType }
     * {@link ResyncType }
     * {@link IfAttrHasValueType }
     * {@link IfAttrExistsType }
     * {@link AddAttributeType }
     * {@link MappingType }
     * {@link ApprovalType }
     * {@link CallWorkflowType }
     * {@link NotifyUserType }
     * {@link CustomTaskType }
     * {@link DeleteType }
     * 
     * 
     */

#Code:
    public List<WorkflowTaskType> getWorkflowTasksGroup() {
        if (workflowTasksGroup == null) {
            workflowTasksGroup = new ArrayList<WorkflowTaskType>();
        }
        return this.workflowTasksGroup;
    }

#end
#end
#No. 185659
#File: E:\bishe\1\WorkflowTools.java
#Comment:
    /**
     * Is the given item in the DSpace workflow?
     *
     * This method queries the database directly to determine if this is the
     * case rather than using the DSpace API (which is very slow).
     *
     * @param context
     * @param item
     * @throws DSpaceSwordException
     */

#Code:
    public boolean isItemInWorkflow(Context context, Item item)
            throws DSpaceSwordException
    {
        try
        {
            //if(ConfigurationManager.getProperty("workflow","workflow.framework").equals("xmlworkflow")){
            //    return XmlWorkflowItem.findByItem(context, item) != null;
            //}else{
                return WorkflowItem.findByItem(context, item) != null;
            //}
        }
        catch (SQLException e)
        {
            throw new DSpaceSwordException(e);
        }
    }

#end
#end
#No. 185660
#File: E:\bishe\1\WorkflowTools.java
#Comment:
    /**
     * Is the given item in a DSpace workspace?
     *
     * This method queries the database directly to determine if this is the
     * case rather than using the DSpace API (which is very slow).
     *
     * @param context
     * @param item
     * @throws DSpaceSwordException
     */

#Code:
    public boolean isItemInWorkspace(Context context, Item item)
            throws DSpaceSwordException
    {
        try
        {
            return WorkspaceItem.findByItem(context, item) != null;
        }
        catch (SQLException e)
        {
            throw new DSpaceSwordException(e);
        }
    }

#end
#end
#No. 185661
#File: E:\bishe\1\WorkflowTools.java
#Comment:
    /**
     * Obtain the WorkflowItem object which wraps the given Item.
     *
     * This method queries the database directly to determine if this is the
     * case rather than using the DSpace API (which is very slow).
     *
     * @param context
     * @param item
     * @throws DSpaceSwordException
     */

#Code:
    public InProgressSubmission getWorkflowItem(Context context, Item item)
            throws DSpaceSwordException
    {
        try
        {
            //if(ConfigurationManager.getProperty("workflow","workflow.framework").equals("xmlworkflow")){
            //    return XmlWorkflowItem.findByItem(context, item);
            //}else{
                return WorkflowItem.findByItem(context, item);
            //}
        }
        catch (SQLException e)
        {
            throw new DSpaceSwordException(e);
        }
    }

#end
#end
#No. 185662
#File: E:\bishe\1\WorkflowTools.java
#Comment:
    /**
     * Obtain the WorkspaceItem object which wraps the given Item.
     *
     * This method queries the database directly to determine if this is the
     * case rather than using the DSpace API (which is very slow).
     *
     * @param context
     * @param item
     * @throws DSpaceSwordException
     */

#Code:
    public WorkspaceItem getWorkspaceItem(Context context, Item item)
            throws DSpaceSwordException
    {
        try
        {
            return WorkspaceItem.findByItem(context, item);
        }
        catch (SQLException e)
        {
            throw new DSpaceSwordException(e);
        }
    }

#end
#end
#No. 185663
#File: E:\bishe\1\WorkflowTools.java
#Comment:
    /**
     * Stop the DSpace workflow, and return the item to the user workspace
     *
     * @param item
     * @throws DSpaceSwordException
     */

#Code:
    public void stopWorkflow(Context context, Item item)
            throws DSpaceSwordException
    {
        try
        {
            // find the item in the workflow if it exists
            InProgressSubmission wfi = this.getWorkflowItem(context, item);

            // abort the workflow
            if (wfi != null)
            {
                if(wfi instanceof WorkflowItem)
                {
                    WorkflowManager.abort(context, (WorkflowItem) wfi, context.getCurrentUser());
                } //else{
                  //  XmlWorkflowManager.abort(context, (XmlWorkflowItem) wfi, context.getCurrentUser());
                //}
            }
        }
        catch (SQLException e)
        {
            throw new DSpaceSwordException(e);
        }
        catch (AuthorizeException e)
        {
            throw new DSpaceSwordException(e);
        }
        catch (IOException e)
        {
            throw new DSpaceSwordException(e);
        }
    }

#end
#end
#No. 185664
#File: E:\bishe\1\WorkflowTypeAPI.java
#Comment:
    /**
     * This method calls proc UpdateWorkflowType and updates the values of the instance of
     * WorkflowType passed. It also validates the values passed.
     *
     * @param workflowType  Instance of WorkflowType.
     * @param bindingResult
     * @return restWrapper Updated instance of WorkflowType.
     */

#Code:
    @RequestMapping(value = {"/", ""}, method = RequestMethod.POST)


    @ResponseBody
    public RestWrapper update(@ModelAttribute("processtype")
                       @Valid WorkflowType workflowType, BindingResult bindingResult, Principal principal) {

        RestWrapper restWrapper = null;
        if (bindingResult.hasErrors()) {
            BindingResultError bindingResultError = new BindingResultError();
            return bindingResultError.errorMessage(bindingResult);
        }

#end
#end
#No. 185665
#File: E:\bishe\1\WorkflowTypeAPI.java
#Comment:
    /**
     * This method calls proc InsertWorkflowType and adds in record in the database. It also validates the values
     * of the record passed.
     *
     * @param workflowType  Instance of WorkflowType.
     * @param bindingResult
     * @return restWrapper Instance of WorkflowType passed.
     */

#Code:
    @RequestMapping(value = {"/", ""}, method = RequestMethod.PUT)


    @ResponseBody
    public RestWrapper insert(@ModelAttribute("processtype")
                       @Valid WorkflowType workflowType, BindingResult bindingResult, Principal principal) {

        RestWrapper restWrapper = null;
        if (bindingResult.hasErrors()) {
            BindingResultError bindingResultError = new BindingResultError();
            return bindingResultError.errorMessage(bindingResult);
        }

#end
#end
#No. 185666
#File: E:\bishe\1\WorkflowTypeAPI.java
#Comment:
    /**
     * This method is used to get the dropdown list of WorkflowType.
     *
     * @return
     */

#Code:
    @RequestMapping(value = {"/optionslist"}, method = RequestMethod.POST)


    @ResponseBody
    public RestWrapperOptions listOptions() {

        RestWrapperOptions restWrapperOptions = null;
        try {
            List<WorkflowType> workflowTypes = new ArrayList<WorkflowType>();
            List<com.wipro.ats.bdre.md.dao.jpa.WorkflowType> jpaWorkflowTypes = workflowTypeDAO.list(0, 0);

            for (com.wipro.ats.bdre.md.dao.jpa.WorkflowType wfType : jpaWorkflowTypes) {
                WorkflowType workflowType = new WorkflowType();
                workflowType.setWorkflowId(wfType.getWorkflowId());
                workflowType.setWorkflowTypeName(wfType.getWorkflowTypeName());
                workflowType.setCounter(jpaWorkflowTypes.size());
                workflowTypes.add(workflowType);
            }

            LOGGER.debug(workflowTypes.get(0).getWorkflowId());
            if (workflowTypes.get(0).getWorkflowId() == 0) {
                workflowTypes.remove(0);
            }
            List<RestWrapperOptions.Option> options = new ArrayList<RestWrapperOptions.Option>();

            for (WorkflowType type : workflowTypes) {
                RestWrapperOptions.Option option = new RestWrapperOptions.Option(type.getWorkflowTypeName(), type.getWorkflowId());
                options.add(option);
                LOGGER.debug(option.getDisplayText());
            }
            restWrapperOptions = new RestWrapperOptions(options, RestWrapperOptions.OK);
        } catch (Exception e) {
            LOGGER.error(e);
            restWrapperOptions = new RestWrapperOptions(e.getMessage(), RestWrapperOptions.ERROR);
        }
        return restWrapperOptions;
    }


#end
#end
#No. 185671
#File: E:\bishe\1\WorkingMemoryEventMock.java
#Comment:
	/**
	 * @see org.drools.event.rule.WorkingMemoryEvent#getPropagationContext()
	 */

#Code:
	public PropagationContext getPropagationContext() {
		return null;
	}

#end
#end
#No. 185672
#File: E:\bishe\1\WorkingMemoryEventMock.java
#Comment:
	/**
	 * @see org.drools.event.KnowledgeRuntimeEvent#getKnowledgeRuntime()
	 */

#Code:
	public KnowledgeRuntime getKnowledgeRuntime() {
		return null;
	}

#end
#end
#No. 185675
#File: E:\bishe\1\WorkingTableScope.java
#Comment:
/**
 * Working-tables scopes.
 * 
 * @author Ralf Wisser
 */

#Code:
public enum WorkingTableScope {
	
	/**
	 * Create the working-tables (JAILER_*) in the source database.
	 */
	GLOBAL,
	
	/**
	 * Create the working-tables (JAILER_*) as temporary tables in the source database.
	 */
	SESSION_LOCAL,
	
	/**
	 * Not supported.
	 */
	TRANSACTION_LOCAL, // not supported
	
	/**
	 * Create a local database (H2) for the working-tables (JAILER_*).
	 */
	LOCAL_DATABASE
	
}

#end
#end
#No. 185676
#File: E:\bishe\1\WorkItemMonitor.java
#Comment:
    /**
     * This method will set up the memory checking job. It assumes that the corresponding system setting for running
     * this job is true.
     */

#Code:
    public static void start() {
        Common.backgroundProcessing.schedule(new WorkItemMonitor());
    }

#end
#end
#No. 185677
#File: E:\bishe\1\WorkItemUtil.java
#Comment:
    /**
     * Creates and saves a new work item.
     * 
     * @param teamRepository
     *            the repository to use
     * @param projectArea
     *            the project area to use.
     * @param summary
     *            the summary for the work item
     * @return the handle for the new work item
     * @throws Exception
     *             Throw all exceptions back to JUnit.
     */

#Code:
    public static IWorkItemHandle createWorkItem(ITeamRepository teamRepository, final IProjectArea projectArea,
            final String summary) throws Exception {
        final IWorkItemClient workItemClient = (IWorkItemClient) teamRepository.getClientLibrary(IWorkItemClient.class);

        WorkItemOperation operation = new WorkItemOperation("Create work item", IWorkItem.FULL_PROFILE) { //$NON-NLS-1$
            protected void execute(WorkItemWorkingCopy workingCopy, IProgressMonitor monitor)
                    throws TeamRepositoryException {
                workingCopy.getWorkItem().setHTMLSummary(XMLString.createFromPlainText(summary));
                List<ICategory> findCategories= workItemClient.findCategories(projectArea, ICategory.FULL_PROFILE, null);
                ICategory category;
                if (findCategories.isEmpty()) {
                	category = workItemClient.createCategory(projectArea, ProcessUtil.DEFAULT_PROCESS_AREA, monitor);
                    category = workItemClient.saveCategory(category, monitor);
                } else {
                	category = findCategories.get(0);
                }
                workingCopy.getWorkItem().setCategory(category);
            }
        };

        List<IWorkItemType> workItemTypes = workItemClient.findWorkItemTypes(projectArea, null);

        IWorkItemHandle workItemHandle = operation.run(workItemTypes.get(0), new NullProgressMonitor());
        return workItemHandle;
    }

#end
#end
#No. 185678
#File: E:\bishe\1\WorkLoadFactory.java
#Comment:
    /**
     * 
     * @param jobInstanceId
     * @return
     */

#Code:
    public IncreasingWorkLoad getModelRunner(int jobInstanceId) {
        JobInstance job = jobInstanceDao.findById(jobInstanceId);
        JobRequest request = jobToJobRequest(job);
        return new IncreasingWorkLoad(channel, agentDispatcher, request);
    }

#end
#end
#No. 185679
#File: E:\bishe\1\WorkLoadFactory.java
#Comment:
    /**
     * @param job
     * @return
     */

#Code:
    private Set<Integer> getDataFileIds(JobInstance job) {
        DataFileDao dataFileDao = new DataFileDao();
        Set<Integer> ret = new HashSet<Integer>();
        for (EntityVersion version : job.getDataFileVersions()) {
            DataFile dataFile = dataFileDao.findRevision(version.getObjectId(), version.getVersionId());
            if (dataFile != null) {
                ret.add(dataFile.getId());
            } else {
                LOG.warn("Attempt to add dataFile that does not exist.");
            }
        }
        return ret;
    }

#end
#end
#No. 185680
#File: E:\bishe\1\WorkLoadFactory.java
#Comment:
    /**
     * @param job
     * @return
     */

#Code:
    private Set<? extends Notification> getNotifications(JobInstance job) {
        HashSet<JobNotification> ret = new HashSet<JobNotification>();
        JobNotificationDao dao = new JobNotificationDao();
        for (EntityVersion version : job.getNotificationVersions()) {
            JobNotification notification = dao.findRevision(version.getObjectId(), version.getVersionId());
            if (notification != null) {
                ret.add(notification);
            } else {
                LOG.warn("Attempt to add Notification that does not exist.");
            }
        }
        return ret;
    }

#end
#end
#No. 185681
#File: E:\bishe\1\WorkloadScripts.java
#Comment:
    /**
     * initializes the current group object.
     */

#Code:
    public void initCurrentGroup() {
        currentScriptGroup = new ScriptGroup();
        currentScriptGroup.setLoop(1);
        this.insertIndex = -1;
        Map<String, String> params = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap();
        String param = params.get("insertIndex");
        if (param != null && NumberUtils.isNumber(param)) {
            insertIndex = Integer.parseInt(param);
        }
    }

#end
#end
#No. 185682
#File: E:\bishe\1\WorkloadScripts.java
#Comment:
    /**
     * Initializes the class variables with appropriate references
     * 
     * @param project
     * @param workload
     */

#Code:
    public void init() {
        initScriptSelectionModel();
    }

#end
#end
#No. 185683
#File: E:\bishe\1\WorkloadScripts.java
#Comment:
    /**
     * @return the list of script groups in the workload
     */

#Code:
    public List<ScriptGroup> getScriptGroups() {
        return currentTestPlan.getScriptGroups();
    }

#end
#end
#No. 185684
#File: E:\bishe\1\WorkloadScripts.java
#Comment:
    /**
     * Adds current script group to the workload.
     */

#Code:
    public void addScriptGroup() {
        if ("<Script Group Name>".equalsIgnoreCase(currentScriptGroup.getName())) {
            messages.error("Please give the Script Group a name.");
        } else {
            currentTestPlan.addScriptGroupAt(currentScriptGroup, insertIndex);
        }
    }

#end
#end
#No. 185685
#File: E:\bishe\1\WorkloadScripts.java
#Comment:
    /**
     * Deletes the script group from the workload. This does not persist the changes to the database.
     * 
     * @param group
     */

#Code:
    public void delete(ScriptGroup group) {
        if (!currentTestPlan.getScriptGroups().remove(group)) {
            messages.warn("Could not remove Script Group " + group.getName() + ".");
        } else {
            messages.info("Script Group " + group.getName() + " has been removed.");
        }
    }

#end
#end
#No. 185686
#File: E:\bishe\1\WorkloadScripts.java
#Comment:
    /**
     * Saves the workload.
     */

#Code:
    public void saveGroup() {
        save();
    }

#end
#end
#No. 185687
#File: E:\bishe\1\WorkloadScripts.java
#Comment:
    /**
     * persists the workload in the database
     */

#Code:
    public void save() {
        // this.workload = new WorkloadDao().saveOrUpdate(workload);
        if (tabIndex >= projectBean.getWorkload().getTestPlans().size()) {
            tabIndex = 0;
        }
        this.setCurrentTestPlan(projectBean.getWorkload().getTestPlans().get(tabIndex));
    }

#end
#end
#No. 185688
#File: E:\bishe\1\WorkloadScripts.java
#Comment:
    /**
     * Helps in creating a new script group
     */

#Code:
    public void newScriptGroup() {
        throw new NotImplementedException();
    }

#end
#end
#No. 185689
#File: E:\bishe\1\WorkloadScripts.java
#Comment:
    /**
     * @return the scriptSelectionModel
     */

#Code:
    public DualListModel<Script> getScriptSelectionModel() {
        return scriptSelectionModel;
    }

#end
#end
#No. 185690
#File: E:\bishe\1\WorkloadScripts.java
#Comment:
    /**
     * @param scriptSelectionModel
     *            the scriptSelectionModel to set
     */

#Code:
    public void setScriptSelectionModel(DualListModel<Script> scriptSelectionModel) {
        this.scriptSelectionModel = scriptSelectionModel;
    }

#end
#end
#No. 185691
#File: E:\bishe\1\WorkManager.java
#Comment:
/**
 * Specifies the JNDI-bound WorkManager, either the
 * <code>commonj.work.WorkManager</code> (when type is {@link org.specs2.spring.annotation.WorkManager.Kind#CommonJ}) or
 * <code>javax.spi.resource.work.WorkManager</code> (when type is {@link org.specs2.spring.annotation.WorkManager.Kind#Javax}).<br/>
 * The specified WorkManager will be bound at the given {@link #name()} and its thread pool will be configured to have
 * at least {@link #minimumThreads()} and at most {@link #maximumThreads()}.<br/>
 * The {@link #minimumThreads()} should be smaller than {@link #maximumThreads()}.
 *
 * @author janmachacek
 */

#Code:
public @interface WorkManager {

	/**
	 * The type of WorkManager to create
	 */
	public static enum Kind {
		/**
		 * Create the <code>commonj.work.WorkManager</code>
		 */
		CommonJ,
		/**
		 * Create the <code>javax.spi.resource.work.WorkManager</code>
		 */
		Javax
	}


#end
#end
#No. 185693
#File: E:\bishe\1\Workpool.java
#Comment:
   /**
    * Determine if workpool is in a processing state. This also means that
    * after processing it will reach and end state.
    *
    * @return
    */

#Code:
   @JsonIgnore
   public boolean isProcessing() {
      if (getState() == null) {
         return false;
      }
      switch (getState()) {
         case available:
         case deleted:
         case unavailable:
            return false;
         case created:
         case waitingForInstancer:
         case resetting:
         case deleting:
      }
      return true;
   }


#end
#end
#No. 185697
#File: E:\bishe\1\WorkpoolClientTestNG.java
#Comment:
   /**
    * Test-case to delete the Workpool created from an ISO on the vCenter datastore.

    * @param wpUrl
    * @param isoWorkPoolCreatedName
    */

#Code:
   @Test(dependsOnMethods = {"createLinkedWP_FromISO", "createLinkedWP_deleteWP_ExistingVMImage"})
   @Parameters({ "wpUrl",  "isoWorkPoolCreatedName" })
   public void deleteLinkedWP_FromISO(String wpUrl, String isoWorkPoolCreatedName) {
      String workPoolUrl =  wpUrl + "/workpools";
      WorkpoolClient wpClient = new WorkpoolClient(workPoolUrl);

      System.out.println("Do a list() on the Workpool after deleting the pool");
      List<Workpool> wpList = wpClient.list();
      assertNotNull(wpList);
      assertFalse(wpList.size() <= 0);
      assertEquals(isoWorkPoolCreatedName,wpList.get(0).getName());

      int numPoolsBeforeDelete = wpList.size();
      System.out.println("Current Pool size Before pool deletion: " + numPoolsBeforeDelete);

      System.out.println("Deleting the WP obtained using Get");
      wpClient.delete(wpList.get(0));

      System.out.println("Do a list() on the Workpool after deleting the pool");
      wpList = wpClient.list();
      System.out.println(wpList.size());
      int numPoolsAfterDelete = wpList.size();
      System.out.println("Current Pool size After pool deletion: " + numPoolsAfterDelete);
      assertTrue((numPoolsBeforeDelete -1 ) == numPoolsAfterDelete,"Pool Sizes do not match after deletion");

   }

#end
#end
#No. 185698
#File: E:\bishe\1\WorkQueueExecutionController.java
#Comment:
	/**
	 * Verifies if new <code>Replica</code>s can be scheduled for this
	 * 
	 * @return <code>true</code> if it can.
	 */

#Code:
	public boolean canSchedule(Task task) {
		
		if (!verifyTaskCanBeProcessed(task)) {
			return false;
		}
		
		if (!task.hasRunnigGridProcess()) {
			return true;
		}
		
		if (task.getState().equals(GridProcessState.RUNNING) &&  task.getJob().hasUnallocatedTasks()) {
			return false;
		}

		return verifyRunningProccess(task);
	}

#end
#end
#No. 185699
#File: E:\bishe\1\WorkQueueExecutionController.java
#Comment:
	/**
	 * Verifies if new <code>Replica</code>s can be created for this
	 * <code>Task</code>. One can be created if the task is still in the
	 * <code>RUNNING</code> state and the current number of running
	 * <code>Replica</code>s is lesser than the <code>maxreplicas</code>
	 * defined for this <code>Task</code>.
	 * 
	 * @return <code>true</code> if it can.
	 */

#Code:
	public boolean canReplicate(Task task) {
		
		if (!verifyTaskCanBeProcessed(task)) {
			return false;
		}

		return verifyRunningProccess(task);
	}


#end
#end
#No. 185701
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Release resources only needed when running
     */

#Code:
    public void close() {
        ArchiveUtils.closeQuietly(uriUniqFilter);     
        ArchiveUtils.closeQuietly(allQueues);
    }

#end
#end
#No. 185702
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Accept the given CrawlURI for scheduling, as it has
     * passed the alreadyIncluded filter. 
     * 
     * Choose a per-classKey queue and enqueue it. If this
     * item has made an unready queue ready, place that 
     * queue on the readyClassQueues queue. 
     * @param caUri CrawlURI.
     */

#Code:
    protected void processScheduleAlways(CrawlURI curi) {
//        assert Thread.currentThread() == managerThread;
        assert KeyedProperties.overridesActiveFrom(curi); 
        
        prepForFrontier(curi);
        sendToQueue(curi);
    }

#end
#end
#No. 185703
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Arrange for the given CrawlURI to be visited, if it is not
     * already enqueued/completed. 
     * 
     * Differs from superclass in that it operates in calling thread, rather 
     * than deferring operations via in-queue to managerThread. TODO: settle
     * on either defer or in-thread approach after testing. 
     *
     * @see org.archive.crawler.framework.Frontier#schedule(org.archive.modules.CrawlURI)
     */

#Code:
    @Override
    public void schedule(CrawlURI curi) {
        sheetOverlaysManager.applyOverlaysTo(curi);
        try {
            KeyedProperties.loadOverridesFrom(curi);
            if(curi.getClassKey()==null) {
                // remedial processing
                preparer.prepare(curi);
            }
            processScheduleIfUnique(curi);
        } finally {
            KeyedProperties.clearOverridesFrom(curi); 
        }
    }

#end
#end
#No. 185704
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Arrange for the given CrawlURI to be visited, if it is not
     * already scheduled/completed.
     *
     * @see org.archive.crawler.framework.Frontier#schedule(org.archive.modules.CrawlURI)
     */

#Code:
    protected void processScheduleIfUnique(CrawlURI curi) {
//        assert Thread.currentThread() == managerThread;
        assert KeyedProperties.overridesActiveFrom(curi); 
        
        // Canonicalization may set forceFetch flag.  See
        // #canonicalization(CrawlURI) javadoc for circumstance.
        String canon = curi.getCanonicalString();
        if (curi.forceFetch()) {
            uriUniqFilter.addForce(canon, curi);
        } else {
            uriUniqFilter.add(canon, curi);
        }
    }

#end
#end
#No. 185705
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Send a CrawlURI to the appropriate subqueue.
     * 
     * @param curi
     */

#Code:
    protected void sendToQueue(CrawlURI curi) {
//        assert Thread.currentThread() == managerThread;
        
        WorkQueue wq = getQueueFor(curi.getClassKey());
        synchronized(wq) {
            int originalPrecedence = wq.getPrecedence();
            wq.enqueue(this, curi);
            // always take budgeting values from current curi
            // (whose overlay settings should be active here)
            wq.setSessionBudget(getBalanceReplenishAmount());
            wq.setTotalBudget(getQueueTotalBudget());
            
            if(!wq.isRetired()) {
                incrementQueuedUriCount();
                int currentPrecedence = wq.getPrecedence();
                if(!wq.isManaged() || currentPrecedence < originalPrecedence) {
                    // queue newly filled or bumped up in precedence; ensure enqueuing
                    // at precedence level (perhaps duplicate; if so that's handled elsewhere)
                    deactivateQueue(wq);
                }
            }
        }
        // Update recovery log.
        doJournalAdded(curi);
        wq.makeDirty();
        largestQueues.update(wq.getClassKey(), wq.getCount());
    }

#end
#end
#No. 185706
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Put the given queue on the readyClassQueues queue
     * @param wq
     */

#Code:
    protected void readyQueue(WorkQueue wq) {
//        assert Thread.currentThread() == managerThread;

        try {
            readyClassQueues.put(wq.getClassKey());
            if(logger.isLoggable(Level.FINE)) {
                logger.log(Level.FINE,
                        "queue readied: " + wq.getClassKey());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            System.err.println("unable to ready queue "+wq);
            // propagate interrupt up 
            throw new RuntimeException(e);
        }
    }

#end
#end
#No. 185707
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Put the given queue on the inactiveQueues queue
     * @param wq
     */

#Code:
    protected void deactivateQueue(WorkQueue wq) {
        int precedence = wq.getPrecedence();

        synchronized(wq) {
            wq.noteDeactivated();
            inProcessQueues.remove(wq);
            if(wq.getCount()==0) {
                System.err.println("deactivate empty queue?");
            }

            synchronized (getInactiveQueuesByPrecedence()) {
                getInactiveQueuesForPrecedence(precedence).add(wq.getClassKey());
                if(wq.getPrecedence() < highestPrecedenceWaiting ) {
                    highestPrecedenceWaiting = wq.getPrecedence();
                }
            }

            if(logger.isLoggable(Level.FINE)) {
                logger.log(Level.FINE,
                        "queue deactivated to p" + precedence 
                        + ": " + wq.getClassKey());
            }
        }
    }

#end
#end
#No. 185708
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Get the queue of inactive uri-queue names at the given precedence. 
     * 
     * @param precedence
     * @return queue of inacti
     */

#Code:
    protected Queue<String> getInactiveQueuesForPrecedence(int precedence) {
        Map<Integer,Queue<String>> inactiveQueuesByPrecedence = 
            getInactiveQueuesByPrecedence();
        Queue<String> candidate = inactiveQueuesByPrecedence.get(precedence);
        if(candidate==null) {
            candidate = createInactiveQueueForPrecedence(precedence);
            inactiveQueuesByPrecedence.put(precedence,candidate);
        }
        return candidate;
    }

#end
#end
#No. 185709
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Put the given queue on the retiredQueues queue
     * @param wq
     */

#Code:
    protected void retireQueue(WorkQueue wq) {
//        assert Thread.currentThread() == managerThread;

        inProcessQueues.remove(wq);
        getRetiredQueues().add(wq.getClassKey());
        decrementQueuedCount(wq.getCount());
        wq.setRetired(true);
        if(logger.isLoggable(Level.FINE)) {
            logger.log(Level.FINE,
                    "queue retired: " + wq.getClassKey());
        }
    }

#end
#end
#No. 185710
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /** 
     * Accommodate any changes in retirement-determining settings (like
     * total-budget or force-retire changes/overlays. 
     * 
     * (Essentially, exists to be called from tools like the UI 
     * Scripting Console when the operator knows it's necessary.)
     */

#Code:
    public void reconsiderRetiredQueues() {

        // The rules for a 'retired' queue may have changed; so,
        // unretire all queues to 'inactive'. If they still qualify
        // as retired/overbudget next time they come up, they'll
        // be re-retired; if not, they'll get a chance to become
        // active under the new rules.
        
        // TODO: Do this automatically, only when necessary.
        
        String key = getRetiredQueues().poll();
        while (key != null) {
            WorkQueue q = (WorkQueue)this.allQueues.get(key);
            if(q != null) {
                unretireQueue(q);
                q.makeDirty();
            }
            key = getRetiredQueues().poll();
        }
    }

#end
#end
#No. 185711
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Restore a retired queue to the 'inactive' state. 
     * 
     * @param q
     */

#Code:
    private void unretireQueue(WorkQueue q) {
//        assert Thread.currentThread() == managerThread;

        deactivateQueue(q);
        q.setRetired(false); 
        incrementQueuedUriCount(q.getCount());
    }

#end
#end
#No. 185712
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Check for any future-scheduled URIs now eligible for reenqueuing
     */

#Code:
    protected void checkFutures() {
//        assert Thread.currentThread() == managerThread;
        // TODO: consider only checking this every set interval
        if(!futureUris.isEmpty()) {
            synchronized(futureUris) {
                Iterator<CrawlURI> iter = 
                    futureUris.headMap(System.currentTimeMillis())
                        .values().iterator();
                while(iter.hasNext()) {
                    CrawlURI curi = iter.next();
                    curi.setRescheduleTime(-1); // unless again set elsewhere
                    iter.remove();
                    futureUriCount.decrementAndGet();
                    receive(curi);
                }
            }
        }
    }

#end
#end
#No. 185713
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Activate an inactive queue, if any are available. 
     */

#Code:
    protected boolean activateInactiveQueue() {
        for (Entry<Integer, Queue<String>> entry: getInactiveQueuesByPrecedence().entrySet()) {
            int expectedPrecedence = entry.getKey();
            Queue<String> queueOfWorkQueueKeys = entry.getValue();

            while (true) {
                String workQueueKey;
                synchronized (getInactiveQueuesByPrecedence()) {
                    workQueueKey = queueOfWorkQueueKeys.poll();
                    if (workQueueKey == null) {
                        break;
                    }
                    updateHighestWaiting(expectedPrecedence);
                }

                WorkQueue candidateQ = (WorkQueue) this.allQueues.get(workQueueKey);
                if (candidateQ.getPrecedence() > expectedPrecedence) {
                    // queue demoted since placed; re-deactivate
                    deactivateQueue(candidateQ);
                    candidateQ.makeDirty();
                    continue;
                }

                try {
                    readyClassQueues.put(workQueueKey);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }

                return true;
            }
        }

        return false;
    }

#end
#end
#No. 185714
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Recalculate the value of thehighest-precedence queue waiting
     * among inactive queues. 
     * 
     * @param startFrom start looking at this precedence value
     */

#Code:
    protected void updateHighestWaiting(int startFrom) {
        // probe for new highestWaiting
        for(int precedenceKey : getInactiveQueuesByPrecedence().tailMap(startFrom).keySet()) {
            if(!getInactiveQueuesByPrecedence().get(precedenceKey).isEmpty()) {
                highestPrecedenceWaiting = precedenceKey;
                return;
            }
        }
        // nothing waiting
        highestPrecedenceWaiting = Integer.MAX_VALUE;
    }

#end
#end
#No. 185715
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Enqueue the given queue to either readyClassQueues or inactiveQueues,
     * as appropriate.
     * 
     * @param wq
     */

#Code:
    protected void reenqueueQueue(WorkQueue wq) { 
        if (logger.isLoggable(Level.FINE)) {
            logger.fine("queue reenqueued: " +
                wq.getClassKey());
        }
        if(highestPrecedenceWaiting < wq.getPrecedence() 
            || wq.getPrecedence() >= getPrecedenceFloor()) {
            // if still over budget, deactivate
            deactivateQueue(wq);
        } else {
            readyQueue(wq);
        }
    }

#end
#end
#No. 185716
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Utility method for advanced users/experimentation: force wake all snoozed
     * queues -- for example to kick a crawl where connectivity problems have
     * put all queues in slow-retry-snoozes back to busy-ness. 
     */

#Code:
    public void forceWakeQueues() {
        Iterator<DelayedWorkQueue> iterSnoozed = snoozedClassQueues.iterator();
        while(iterSnoozed.hasNext()) {
            WorkQueue queue = iterSnoozed.next().getWorkQueue(WorkQueueFrontier.this);
            queue.setWakeTime(0);
            reenqueueQueue(queue);
            queue.makeDirty();
            iterSnoozed.remove(); 
        }
        Iterator<DelayedWorkQueue> iterOverflow = snoozedOverflow.values().iterator();
        while(iterOverflow.hasNext()) {
            WorkQueue queue = iterOverflow.next().getWorkQueue(WorkQueueFrontier.this);
            queue.setWakeTime(0);
            reenqueueQueue(queue);
            queue.makeDirty();
            iterOverflow.remove(); 
            snoozedOverflowCount.decrementAndGet();
        }
    }

#end
#end
#No. 185717
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Wake any queues sitting in the snoozed queue whose time has come.
     */

#Code:
    protected void wakeQueues() {
        DelayedWorkQueue waked; 
        while((waked = snoozedClassQueues.poll())!=null) {
            WorkQueue queue = waked.getWorkQueue(this);
            queue.setWakeTime(0);
            queue.makeDirty();
            reenqueueQueue(queue);
        }
        // also consider overflow (usually empty)
        if(!snoozedOverflow.isEmpty()) {
            synchronized(snoozedOverflow) {
                Iterator<DelayedWorkQueue> iter = 
                    snoozedOverflow.headMap(System.currentTimeMillis()).values().iterator();
                while(iter.hasNext()) {
                    DelayedWorkQueue dq = iter.next();
                    iter.remove();
                    snoozedOverflowCount.decrementAndGet();
                    WorkQueue queue = dq.getWorkQueue(this);
                    queue.setWakeTime(0);
                    queue.makeDirty();
                    reenqueueQueue(queue);
                }
            }
        }
    }

#end
#end
#No. 185718
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Send an active queue to its next state, based on the supplied 
     * parameters.
     * 
     * @param wq
     * @param forceRetire
     * @param now
     * @param delay_ms
     */

#Code:
    protected void handleQueue(WorkQueue wq, boolean forceRetire, long now, long delay_ms) {
        inProcessQueues.remove(wq);
        if(forceRetire) {
            retireQueue(wq);
        } else if (delay_ms > 0) {
            snoozeQueue(wq, now, delay_ms);
        } else {
            getQueuePrecedencePolicy().queueReevaluate(wq);
            reenqueueQueue(wq);
        }
    }

#end
#end
#No. 185719
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Place the given queue into 'snoozed' state, ineligible to
     * supply any URIs for crawling, for the given amount of time. 
     * 
     * @param wq queue to snooze 
     * @param now time now in ms 
     * @param delay_ms time to snooze in ms
     */

#Code:
    private void snoozeQueue(WorkQueue wq, long now, long delay_ms) {
        long nextTime = now + delay_ms;
        wq.setWakeTime(nextTime);
        DelayedWorkQueue dq = new DelayedWorkQueue(wq);
        if(snoozedClassQueues.size()<MAX_SNOOZED_IN_MEMORY) {
            snoozedClassQueues.add(dq);
        } else {
            synchronized(snoozedOverflow) {
                snoozedOverflow.put(nextTime, dq);
                snoozedOverflowCount.incrementAndGet();
            }
        }
    }

#end
#end
#No. 185720
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Forget the given CrawlURI. This allows a new instance
     * to be created in the future, if it is reencountered under
     * different circumstances.
     *
     * @param curi The CrawlURI to forget
     */

#Code:
    protected void forget(CrawlURI curi) {
        logger.finer("Forgetting " + curi);
        uriUniqFilter.forget(curi.getCanonicalString(), curi);
    }

#end
#end
#No. 185721
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * @param match String to  match.
     * @return Number of items deleted.
     */

#Code:
    public long deleteURIs(String queueRegex, String uriRegex) {
        long count = 0;
        Pattern queuePat = Pattern.compile(queueRegex);
        for (String qname: allQueues.keySet()) {
            if (queuePat.matcher(qname).matches()) {
                WorkQueue wq = getQueueFor(qname);
                wq.unpeek(null);
                long delCount = wq.deleteMatching(this, uriRegex);
                if (!wq.isRetired()) {
                	count += delCount;
                }
                wq.makeDirty();
            }
        }
        decrementQueuedCount(count);
        return count;
    }

#end
#end
#No. 185722
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * @param w Where to write to.
     */

#Code:
    @Override
    public void shortReportLineTo(PrintWriter w) {
        if (!isRunning()) return; //???
        
        if (this.allQueues == null) {
            return;
        }
        int allCount = allQueues.size();
        int inProcessCount = inProcessQueues.size();
        int readyCount = readyClassQueues.size();
        int snoozedCount = getSnoozedCount();
        int activeCount = inProcessCount + readyCount + snoozedCount;
        int inactiveCount = getTotalEligibleInactiveQueues();
        int ineligibleCount = getTotalIneligibleInactiveQueues();
        int retiredCount = getRetiredQueues().size();
        int exhaustedCount = 
            allCount - activeCount - inactiveCount - retiredCount;
        State last = lastReachedState;
        w.print(last);
        w.print(" - ");
        w.print(allCount);
        w.print(" URI queues: ");
        w.print(activeCount);
        w.print(" active (");
        w.print(inProcessCount);
        w.print(" in-process; ");
        w.print(readyCount);
        w.print(" ready; ");
        w.print(snoozedCount);
        w.print(" snoozed); ");
        w.print(inactiveCount);
        w.print(" inactive; ");
        w.print(ineligibleCount);
        w.print(" ineligible; ");
        w.print(retiredCount);
        w.print(" retired; ");
        w.print(exhaustedCount);
        w.print(" exhausted");        
        w.flush();
    }

#end
#end
#No. 185723
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Total of all URIs in inactive queues at all precedences
     * @return int total 
     */

#Code:
    protected int getTotalInactiveQueues() {
        return tallyInactiveTotals(getInactiveQueuesByPrecedence());
    }

#end
#end
#No. 185724
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Total of all URIs in inactive queues at precedences above the floor
     * @return int total 
     */

#Code:
    protected int getTotalEligibleInactiveQueues() {
        return tallyInactiveTotals(
                getInactiveQueuesByPrecedence().headMap(getPrecedenceFloor()));
    }

#end
#end
#No. 185725
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Total of all URIs in inactive queues at precedences at or below the floor
     * @return int total 
     */

#Code:
    protected int getTotalIneligibleInactiveQueues() {
        return tallyInactiveTotals(
                getInactiveQueuesByPrecedence().tailMap(getPrecedenceFloor()));
    }

#end
#end
#No. 185726
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * @param iqueue 
     * @return
     */

#Code:
    private int tallyInactiveTotals(SortedMap<Integer,Queue<String>> iqueues) {
        int inactiveCount = 0; 
        for(Queue<String> q : iqueues.values()) {
            inactiveCount += q.size();
        }
        return inactiveCount;
    }

#end
#end
#No. 185727
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /** Compact report of all nonempty queues (one queue per line)
     * 
     * @param writer
     */

#Code:
    public void allNonemptyReportTo(PrintWriter writer) {
        ArrayList<WorkQueue> inProcessQueuesCopy;
        synchronized(this.inProcessQueues) {
            // grab a copy that will be stable against mods for report duration 
            Collection<WorkQueue> inProcess = this.inProcessQueues;
            inProcessQueuesCopy = new ArrayList<WorkQueue>(inProcess);
        }
        writer.print("\n -----===== IN-PROCESS QUEUES =====-----\n");
        queueSingleLinesTo(writer, inProcessQueuesCopy.iterator());

        writer.print("\n -----===== READY QUEUES =====-----\n");
        queueSingleLinesTo(writer, this.readyClassQueues.iterator());

        writer.print("\n -----===== SNOOZED QUEUES =====-----\n");
        queueSingleLinesTo(writer, this.snoozedClassQueues.iterator());
        queueSingleLinesTo(writer, this.snoozedOverflow.values().iterator());
        
        writer.print("\n -----===== INACTIVE QUEUES =====-----\n");
        for(Queue<String> inactiveQueues : getInactiveQueuesByPrecedence().values()) {
            queueSingleLinesTo(writer, inactiveQueues.iterator());
        }
        
        writer.print("\n -----===== RETIRED QUEUES =====-----\n");
        queueSingleLinesTo(writer, getRetiredQueues().iterator());
    }

#end
#end
#No. 185728
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /** Compact report of all nonempty queues (one queue per line)
     * 
     * @param writer
     */

#Code:
    public void allQueuesReportTo(PrintWriter writer) {
        queueSingleLinesTo(writer, allQueues.keySet().iterator());
    }

#end
#end
#No. 185729
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Writer the single-line reports of all queues in the
     * iterator to the writer 
     * 
     * @param writer to receive report
     * @param iterator over queues of interest.
     */

#Code:
    private void queueSingleLinesTo(PrintWriter writer, Iterator<?> iterator) {
        Object obj;
        WorkQueue q;
        boolean legendWritten = false;
        while( iterator.hasNext()) {
            obj = iterator.next();
            if (obj ==  null) {
                continue;
            }
            if(obj instanceof WorkQueue) {
                q = (WorkQueue)obj;
            } else if (obj instanceof DelayedWorkQueue) {
                q = ((DelayedWorkQueue)obj).getWorkQueue(this);
            } else {
                try {
                    q = this.allQueues.get((String)obj);
                } catch (ClassCastException cce) {
                    logger.log(Level.SEVERE,"not convertible to workqueue:"+obj,cce);
                    q = null; 
                }
            }

            if(q != null) {
                if(!legendWritten) {
                    writer.println(q.shortReportLegend());
                    legendWritten = true;
                }
                q.shortReportLineTo(writer);
            } else {
                writer.print(" ERROR: "+obj);
            }
        }       
    }

#end
#end
#No. 185730
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Extract some of the elements in the given collection to an
     * ArrayList.  This method synchronizes on the given collection's
     * monitor.  The returned list will never contain more than the
     * specified maximum number of elements.
     * 
     * @param c    the collection whose elements to extract
     * @param max  the maximum number of elements to extract
     * @return  the extraction
     */

#Code:
    private static <T> ArrayList<T> extractSome(Collection<T> c, int max) {
        // Try to guess a sane initial capacity for ArrayList
        // Hopefully given collection won't grow more than 10 items
        // between now and the synchronized block...
        int initial = Math.min(c.size() + 10, max);
        int count = 0;
        ArrayList<T> list = new ArrayList<T>(initial);
        synchronized (c) {
            Iterator<T> iter = c.iterator();
            while (iter.hasNext() && (count < max)) {
                list.add(iter.next());
                count++;
            }
        }
        return list;
    }

#end
#end
#No. 185731
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /**
     * Append queue report to general Frontier report.
     * @param w StringBuffer to append to.
     * @param iterator An iterator over 
     * @param total
     * @param max
     */

#Code:
    @SuppressWarnings("rawtypes")
    protected void appendQueueReports(PrintWriter w, String label, Iterator<?> iterator,
            int total, int max) {
        Object obj;
        WorkQueue q;
        int count;
        for(count = 0; iterator.hasNext() && (count < max); count++) {
            obj = iterator.next();
            if (obj ==  null) {
                continue;
            }
            if(obj instanceof WorkQueue) {
                q = (WorkQueue)obj;
            } else if (obj instanceof DelayedWorkQueue) {
                q = (WorkQueue)((DelayedWorkQueue)obj).getWorkQueue(this);
            } else if (obj instanceof Map.Entry) {
                q = this.allQueues.get((String)((Map.Entry)obj).getKey());
            } else {
                q = this.allQueues.get((String)obj);
            }
            if(q != null) {
                w.println(label+"#"+count+":");
                q.reportTo(w);
            } else {
                w.print("WARNING: No report for queue "+obj);
            }
        }
        count++;
        if(count < total) {
            w.print("...and " + (total - count) + " more "+label+".\n");
        }
    }


#end
#end
#No. 185733
#File: E:\bishe\1\WorkQueueFrontier.java
#Comment:
    /** 
     * Return whether frontier is exhausted: all crawlable URIs done (none
     * waiting or pending). Only gives precise answer inside managerThread.
     * 
     * @see org.archive.crawler.framework.Frontier#isEmpty()
     */

#Code:
    public boolean isEmpty() {
        return queuedUriCount.get() == 0 
            && (uriUniqFilter == null || uriUniqFilter.pending() == 0)
            && futureUriCount.get() == 0;
    }

#end
#end
#No. 185734
#File: E:\bishe\1\WorkQueueReplication.java
#Comment:
	/**
	 * Executes the grid process of this job that are ready to run.
	 * @param job
	 * @param heuristic 
	 */

#Code:
	private void execute(Job job, List<IResponseTO> responses) {

		for (Task task : job.getTasks()) {
			for (GridProcess gridProcess : task.getReadyToRunGridProcesses()) {

				ReplicaParser replicaParser = new ReplicaParser(gridProcess, new MatcherImpl());

				replicaParser.parse();

				GridProcessOperations executionOperations = replicaParser.getExecutionOperations();

				responses.add(new LoggerResponseTO(SchedulerMessages.getExecutingReplicaMessage(
						gridProcess.getHandle(), gridProcess.getWorkerEntry().getWorkerID()), 
						LoggerResponseTO.DEBUG));

				gridProcess.setOperations(executionOperations);
				gridProcess.setAsRunning();

				String workerAddress = StringUtil.deploymentIDToAddress(gridProcess.getWorkerEntry().getWorkerID());

				StartWorkResponseTO to = new StartWorkResponseTO();
				to.setJobID(gridProcess.getHandle().getJobID());
				to.setProcessID(gridProcess.getHandle().getReplicaID());
				to.setRequestID(gridProcess.getWorkerEntry().getRequestID());
				to.setTaskID(gridProcess.getHandle().getTaskID());
				to.setWorkerAddress(workerAddress);

				responses.add(to);
			}
		}
	}

#end
#end
#No. 185735
#File: E:\bishe\1\WorkQueues.java
#Comment:
    /*
     * The key that is used for storing URLs determines the order
     * they are crawled. Lower key values results in earlier crawling.
     * Here our keys are 6 bytes. The first byte comes from the URL priority.
     * The second byte comes from depth of crawl at which this URL is first found.
     * The rest of the 4 bytes come from the docid of the URL. As a result,
     * URLs with lower priority numbers will be crawled earlier. If priority
     * numbers are the same, those found at lower depths will be crawled earlier.
     * If depth is also equal, those found earlier (therefore, smaller docid) will
     * be crawled earlier.
     */

#Code:
    protected static DatabaseEntry getDatabaseEntryKey(WebURL url) {
        byte[] keyData = new byte[6];
        keyData[0] = url.getPriority();
        keyData[1] = ((url.getDepth() > Byte.MAX_VALUE) ? Byte.MAX_VALUE : (byte) url.getDepth());
        Util.putIntInByteArray(url.getDocid(), keyData, 2);
        return new DatabaseEntry(keyData);
    }

#end
#end
#No. 185736
#File: E:\bishe\1\WorkServiceCallbackHandler.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void handle(Callback[] arg0) throws IOException, UnsupportedCallbackException {
        for (int i = 0; i < arg0.length; i++) {
            WSPasswordCallback pc = (WSPasswordCallback) arg0[i];
            String password = _passwords.get(pc.getIdentifier());
            if (password != null) {
                pc.setPassword(password);
                return;
            }
        }
    }


#end
#end
#No. 185738
#File: E:\bishe\1\WorkspaceConfigPreferencePage.java
#Comment:
/**
 * Preference Page to configure the workspace configuration process.
 */

#Code:
public class WorkspaceConfigPreferencePage extends FieldEditorPreferencePage implements
    IWorkbenchPreferencePage {


  /** {@inheritDoc} */
  @Override
  public void init(IWorkbench workbench) {
    setPreferenceStore(WorkspaceConfigurationUIPlugin.getDefault().getPreferenceStore());
  }

  /** {@inheritDoc} */
  @Override
  protected void createFieldEditors() {
  
    addField(new EditableUrlStringListFieldEditor(WorkspaceConfigurationConstants.CONFIG_URL,
        WorkspaceConfigurationUIPlugin.getDefault().getText("preference.page.url.label"),
        getFieldEditorParent(), WorkspaceConfigurationUIPlugin.getDefault(), true));

    addField(new EditableStringListFieldEditor(WorkspaceConfigurationConstants.CONFIG_ENV_REPLACEMENT_LIST,
        WorkspaceConfigurationUIPlugin.getDefault().getText("preference.page.envreplace.list"),
        getFieldEditorParent(), WorkspaceConfigurationUIPlugin.getDefault()));
    
    addField(new BooleanFieldEditor(WorkspaceConfigurationConstants.CONFIG_STARTUP_CHECK,
        WorkspaceConfigurationUIPlugin.getDefault().getText("preference.page.check.label"),
        getFieldEditorParent()));
  }
  

}
#end
#end
#No. 185739
#File: E:\bishe\1\WorkspaceDelegate.java
#Comment:
    /**
     * Builds a command which gets executed and retrieves the following return data
     *
     * @return Map with Workspace name as key and Workspace Object as value.
     * @throws IOException Failed to execute command or Parse data.
     */

#Code:
    private Map<String, AccurevWorkspace> getWorkspaces() throws IOException {
        listener.getLogger().println("Getting a list of workspaces...");
        String depot = scm.getDepot();
        final ArgumentListBuilder cmd = new ArgumentListBuilder();
        cmd.add("show");
        Command.addServer(cmd, server);
        cmd.add("-fx");
        cmd.add("-p");
        cmd.add(depot);
        cmd.add("wspaces");
        XmlPullParserFactory parser = XmlParserFactory.getFactory();
        if (parser == null) throw new IOException("No XML Parser");
        return AccurevLauncher.runCommand("Show workspaces command", accurevTool, launcher, cmd, scm.getOptionalLock(),
            accurevEnv, jenkinsWorkspace, listener, logger, parser, new ParseShowWorkspaces(), null);
    }

#end
#end
#No. 185741
#File: E:\bishe\1\WorkspaceExplorerView.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	public void setFocus() {
		viewer.setFocus();
	}

#end
#end
#No. 185742
#File: E:\bishe\1\WorkspaceExplorerView.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	public void refresh() {
		viewer.refresh();
	}


#end
#end
#No. 185744
#File: E:\bishe\1\WorkspaceHomeProperty.java
#Comment:
    /**
     * Get the home folder.
     * 
     * @return The home folder
     */

#Code:
    public String getHome() {
	return home;
    }

#end
#end
#No. 185745
#File: E:\bishe\1\WorkspaceHomeProperty.java
#Comment:
    /**
     * Get the home directory for the given node.
     * 
     * @param node
     *            The node
     * @return The home directory
     */

#Code:
    public static FilePath get(Node node) {
	// Get the potential properties
	WorkspaceHomeProperty[] properties = new WorkspaceHomeProperty[] {
		node.getNodeProperties().get(WorkspaceHomeProperty.class),
		Jenkins.getInstance().getGlobalNodeProperties().get(WorkspaceHomeProperty.class) };
	// Go threw the properties
	for (WorkspaceHomeProperty property : properties)
	    // Check if exists
	    if (property != null)
		// Check if valid
		if (Util.fixEmpty(property.getHome()) != null)
		    // Return the home folder
		    return new FilePath(node.getChannel(), property.getHome());
	// Else relative to root
	return node.getRootPath().child(Workspace.BASENAME).child("jobs");
    }

#end
#end
#No. 185746
#File: E:\bishe\1\WorkspaceLabelProvider.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public String getText(Object element) {
		if (element instanceof IResource) {
			IResource resource = (IResource) element;
			return resource.getName();
		}
		return null;
	}

#end
#end
#No. 185747
#File: E:\bishe\1\WorkspaceLabelProvider.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public Image getImage(Object element) {
		if (element instanceof IProject) {
			return createImage(TYPE_PROJECT_ICON_URL);
		}
		if (element instanceof IFolder) {
			return getCollectionImageByName(((IFolder) element).getName());
		}
		if (element instanceof IFile) {
			return getResourceImage(((IFile) element).getName());
		}
		return null;
	}

#end
#end
#No. 185748
#File: E:\bishe\1\WorkspaceModifyOperation.java
#Comment:
	/**
	 * The <code>WorkspaceModifyOperation</code> implementation of this
	 * <code>IRunnableWithProgress</code> method initiates a batch of changes by
	 * invoking the <code>execute</code> method as a workspace runnable (
	 * <code>IWorkspaceRunnable</code>).
	 */

#Code:
	public synchronized final void run(IProgressMonitor monitor)
			throws InvocationTargetException, InterruptedException {
		final InvocationTargetException[] iteHolder = new InvocationTargetException[1];
		try {
			IWorkspaceRunnable workspaceRunnable = new IWorkspaceRunnable() {
				public void run(IProgressMonitor pm) throws CoreException {
					try {
						execute(pm);
					} catch (InvocationTargetException e) {
						// Pass it outside the workspace runnable
						iteHolder[0] = e;
					} catch (InterruptedException e) {
						// Re-throw as OperationCanceledException, which will be
						// caught and re-thrown as InterruptedException below.
						throw new OperationCanceledException(e.getMessage()); // NOPMD
					}
					// CoreException and OperationCanceledException are
					// propagated
				}
			};
			IDEWorkbenchPlugin.getPluginWorkspace().run(workspaceRunnable,
					rule, IResource.NONE, monitor);
		} catch (CoreException e) {
			throw new InvocationTargetException(e);
		} catch (OperationCanceledException e) {
			throw new InterruptedException(e.getMessage()); // NOPMD
		}
		// Re-throw the InvocationTargetException, if any occurred
		if (iteHolder[0] != null) {
			throw iteHolder[0];
		}
	}

#end
#end
#No. 185749
#File: E:\bishe\1\WorkspaceModifyOperation.java
#Comment:
	/**
	 * The scheduling rule. Should not be modified.
	 * 
	 * @return the scheduling rule, or <code>null</code>.
	 * @since 3.4
	 */

#Code:
	public ISchedulingRule getRule() {
		return rule;
	}

#end
#end
#No. 185750
#File: E:\bishe\1\WorkspacePerspective.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	@Override
	public void createInitialLayout(IPageLayout layout) {
		String editorArea = layout.getEditorArea();
		layout.setEditorAreaVisible(true);

		// Left
		IFolderLayout left = layout.createFolder("left", IPageLayout.LEFT, //$NON-NLS-1$
				0.40f, editorArea);
		left.addView(WORKSPACE_EXPLORER_VIEW_ID);
		layout.getViewLayout(WORKSPACE_EXPLORER_VIEW_ID).setCloseable(false);

		// TODO - Throws exceptions that the view has been already registered?!
		// // Right
		// IFolderLayout right = layout.createFolder("right", IPageLayout.RIGHT,
		// 0.85f, editorArea);
		// right.addView(CHEAT_SHEET_VIEW_ID);

		// Logs
		IFolderLayout logs = layout.createFolder("logs", //$NON-NLS-1$
				IPageLayout.BOTTOM, 0.75f, editorArea);
		logs.addView(LOG_CONSOLE_VIEW_ID);
		logs.addView(LOGS_VIEW_ID);

		// Bottom
		IFolderLayout bottom = layout.createFolder("bottom", //$NON-NLS-1$
				IPageLayout.BOTTOM, 0.35f, editorArea);
		bottom.addView(WEB_VIEWER_VIEW_ID);
		layout.getViewLayout(WEB_VIEWER_VIEW_ID).setCloseable(false);
		bottom.addView(PROPERTY_SHEET_VIEW_ID);
		// bottom.addView(CONTENT_OUTLINE_VIEW_ID);
		bottom.addView(SECURITY_MANAGER_VIEW_ID);

		layout.addShowViewShortcut(WORKSPACE_EXPLORER_VIEW_ID);
		layout.addShowViewShortcut(PROPERTY_SHEET_VIEW_ID);
		layout.addShowViewShortcut(WEB_VIEWER_VIEW_ID);
		layout.addShowViewShortcut(CHEAT_SHEET_VIEW_ID);
		// layout.addShowViewShortcut(CONTENT_OUTLINE_VIEW_ID);
		layout.addPerspectiveShortcut(PERSPECTIVE_ID);
	}

#end
#end
#No. 185751
#File: E:\bishe\1\WorkspaceResourceRegistry.java
#Comment:
	/**
	 Get the {@link WorkspaceResourceRegistry} for the instance returned by {@link Workspace#getWorkspace()}

	 @return registry
	 */

#Code:
	@NotNull
	public static WorkspaceResourceRegistry getInstance() {
		return Workspace.getWorkspace().getGlobalResourceRegistry();
	}

#end
#end
#No. 185752
#File: E:\bishe\1\WorkspaceRoot.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	public void delete(boolean deleteContent, boolean force,
			IProgressMonitor monitor) throws CoreException {
		int flags = (deleteContent ? IResource.ALWAYS_DELETE_PROJECT_CONTENT
				: IResource.NEVER_DELETE_PROJECT_CONTENT)
				| (force ? FORCE : IResource.NONE);
		delete(flags, monitor);
	}

#end
#end
#No. 185753
#File: E:\bishe\1\WorkspaceRoot.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	public IContainer getContainerForLocation(IPath location) {
		IWorkspaceRoot root = workspace.getRoot();
		if (!root.getLocation().isPrefixOf(location)) {
			return null;
		}
		IResource resource = workspace.newResource(location);
		if (resource instanceof IContainer) {
			return (IContainer) resource;
		}
		return null;
	}

#end
#end
#No. 185754
#File: E:\bishe\1\WorkspaceRoot.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	public IFile getFileForLocation(IPath location) {
		IResource resource = workspace.newResource(location);
		if (resource instanceof IFile) {
			return (IFile) resource;
		}
		return null;
	}

#end
#end
#No. 185755
#File: E:\bishe\1\WorkspaceRoot.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	public IProject getProject(String name) {
		// boolean segmentIsValid = Path.ROOT.isValidSegment(name);
		// if (!segmentIsValid) {
		// throw new IllegalArgumentException("Project name is not valid.");
		// }
		IPath resourcePath = path.append(name);
		if (resourcePath.segmentCount() != 1) {
			throw new IllegalArgumentException(
					THE_PROJECT_PATH_MUST_HAVE_EXACTLY_ONE_SEGMENT);
		}
		IProject project = new Project(resourcePath, workspace);
		return project;
	}

#end
#end
#No. 185756
#File: E:\bishe\1\WorkspaceRoot.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	public IProject[] getProjects() {
		return getProjects(IResource.NONE);
	}

#end
#end
#No. 185757
#File: E:\bishe\1\WorkspaceRoot.java
#Comment:
	/**
	 * {@inheritDoc}
	 */

#Code:
	public IProject[] getProjects(int memeberFlags) {
		try {
			IResource[] children = members();
			IProject[] projects = new IProject[children.length];
			try {
				System.arraycopy(children, 0, projects, 0, children.length);
			} catch (ArrayStoreException ex) {
				throw new IllegalStateException(
						ONLY_PROJECTS_SHOULD_BE_CHILDREN_OF_THE_ROOT, ex);
			}
			return projects;
		} catch (CoreException ex) {
			return new IProject[0];
		}
	}

#end
#end
#No. 185758
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
  /**
   * List Workspaces
   * Gets information about the Workspaces that have been created.
   * @param accountId The external account number (int) or account ID Guid.
   * @param WorkspacesApi.ListWorkspacesOptions Options for modifying the method behavior.
   * @return WorkspaceList
   */

#Code:
  public WorkspaceList listWorkspaces(String accountId) throws ApiException {
  
    Object postBody = null;
    
     // verify the required parameter 'accountId' is set
     if (accountId == null) {
        throw new ApiException(400, "Missing the required parameter 'accountId' when calling listWorkspaces");
     }
     
    // create path and map variables
    String path = "/v2/accounts/{accountId}/workspaces".replaceAll("\\{format\\}","json")
      .replaceAll("\\{" + "accountId" + "\\}", apiClient.escapeString(accountId.toString()));

    // query params
    java.util.List<Pair> queryParams = new java.util.ArrayList<Pair>();
    java.util.Map<String, String> headerParams = new java.util.HashMap<String, String>();
    java.util.Map<String, Object> formParams = new java.util.HashMap<String, Object>();

    

    final String[] accepts = {
      "application/json"
    };
    final String accept = apiClient.selectHeaderAccept(accepts);

    final String[] contentTypes = {
      
    };
    final String contentType = apiClient.selectHeaderContentType(contentTypes);

    String[] authNames = new String[] { "docusignAccessCode" };

    
    GenericType<WorkspaceList> returnType = new GenericType<WorkspaceList>() {};
    return apiClient.invokeAPI(path, "GET", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    
  }

#end
#end
#No. 185759
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
  /**
   * Create a Workspace
   * Creates a new workspace.
   * @param accountId The external account number (int) or account ID Guid.
   * @param WorkspacesApi.CreateWorkspaceOptions Options for modifying the method behavior.
   * @return Workspace
   */

#Code:
  public Workspace createWorkspace(String accountId, Workspace workspace) throws ApiException {
  
    Object postBody = workspace;
    
     // verify the required parameter 'accountId' is set
     if (accountId == null) {
        throw new ApiException(400, "Missing the required parameter 'accountId' when calling createWorkspace");
     }
     
    // create path and map variables
    String path = "/v2/accounts/{accountId}/workspaces".replaceAll("\\{format\\}","json")
      .replaceAll("\\{" + "accountId" + "\\}", apiClient.escapeString(accountId.toString()));

    // query params
    java.util.List<Pair> queryParams = new java.util.ArrayList<Pair>();
    java.util.Map<String, String> headerParams = new java.util.HashMap<String, String>();
    java.util.Map<String, Object> formParams = new java.util.HashMap<String, Object>();

    

    final String[] accepts = {
      "application/json"
    };
    final String accept = apiClient.selectHeaderAccept(accepts);

    final String[] contentTypes = {
      
    };
    final String contentType = apiClient.selectHeaderContentType(contentTypes);

    String[] authNames = new String[] { "docusignAccessCode" };

    
    GenericType<Workspace> returnType = new GenericType<Workspace>() {};
    return apiClient.invokeAPI(path, "POST", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);
    
  }

#end
#end
#No. 185760
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * The maximum number of results to be returned by this request. 
	 */

#Code:
	public void setCount(String count) {
		this.count = count;
	}

#end
#end
#No. 185761
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * When set to **true**, file information is returned in the response along with folder information. The default is **false**. 
	 */

#Code:
	public void setIncludeFiles(String includeFiles) {
		this.includeFiles = includeFiles;
	}

#end
#end
#No. 185762
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * When set to **true**, information about the sub-folders of the current folder is returned. The default is **false**. 
	 */

#Code:
	public void setIncludeSubFolders(String includeSubFolders) {
		this.includeSubFolders = includeSubFolders;
	}

#end
#end
#No. 185763
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * When set to **true**, thumbnails are returned as part of the response.  The default is **false**. 
	 */

#Code:
	public void setIncludeThumbnails(String includeThumbnails) {
		this.includeThumbnails = includeThumbnails;
	}

#end
#end
#No. 185764
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * Set to **true** to return extended details about the user. The default is **false**. 
	 */

#Code:
	public void setIncludeUserDetail(String includeUserDetail) {
		this.includeUserDetail = includeUserDetail;
	}

#end
#end
#No. 185765
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * The position within the total result set from which to start returning values. 
	 */

#Code:
	public void setStartPosition(String startPosition) {
		this.startPosition = startPosition;
	}

#end
#end
#No. 185766
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * If set, then the results are filtered to those associated with the specified userId. 
	 */

#Code:
	public void setWorkspaceUserId(String workspaceUserId) {
		this.workspaceUserId = workspaceUserId;
	}

#end
#end
#No. 185767
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
   /**
   * List Workspace Folder Contents
   * Retrieves workspace folder contents, which can include sub folders and files.
   * @param accountId The external account number (int) or account ID Guid.
   * @param workspaceId Specifies the workspace ID GUID.
   * @param folderId The ID of the folder being accessed.
   * @return WorkspaceFolderContents
   */ 

#Code:
  public WorkspaceFolderContents listWorkspaceFolderItems(String accountId, String workspaceId, String folderId) throws ApiException {
    return listWorkspaceFolderItems(accountId, workspaceId, folderId, null);
  }

#end
#end
#No. 185768
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * When set to **true**, the Content-Disposition header is set in the response. The value of the header provides the filename of the file. Default is **false**. 
	 */

#Code:
	public void setIsDownload(String isDownload) {
		this.isDownload = isDownload;
	}

#end
#end
#No. 185769
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * When set to **true** the file returned as a PDF. 
	 */

#Code:
	public void setPdfVersion(String pdfVersion) {
		this.pdfVersion = pdfVersion;
	}

#end
#end
#No. 185770
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
   /**
   * Get Workspace File
   * Retrieves a workspace file (the binary).
   * @param accountId The external account number (int) or account ID Guid.
   * @param workspaceId Specifies the workspace ID GUID.
   * @param folderId The ID of the folder being accessed.
   * @param fileId Specifies the room file ID GUID.
   * @return void
   */ 

#Code:
  public void getWorkspaceFile(String accountId, String workspaceId, String folderId, String fileId) throws ApiException {
  getWorkspaceFile(accountId, workspaceId, folderId, fileId, null);
  }

#end
#end
#No. 185771
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * The maximum number of results to be returned by this request. 
	 */

#Code:
	public void setCount(String count) {
		this.count = count;
	}

#end
#end
#No. 185772
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * Number of dots per inch for the resulting image. The default if not used is 94. The range is 1-310. 
	 */

#Code:
	public void setDpi(String dpi) {
		this.dpi = dpi;
	}

#end
#end
#No. 185773
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * Sets the maximum height (in pixels) of the returned image. 
	 */

#Code:
	public void setMaxHeight(String maxHeight) {
		this.maxHeight = maxHeight;
	}

#end
#end
#No. 185774
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * Sets the maximum width (in pixels) of the returned image. 
	 */

#Code:
	public void setMaxWidth(String maxWidth) {
		this.maxWidth = maxWidth;
	}

#end
#end
#No. 185775
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
	/*
	 * The position within the total result set from which to start returning values. The value **thumbnail** may be used to return the page image. 
	 */

#Code:
	public void setStartPosition(String startPosition) {
		this.startPosition = startPosition;
	}

#end
#end
#No. 185776
#File: E:\bishe\1\WorkspacesApi.java
#Comment:
   /**
   * List File Pages
   * Retrieves a workspace file as rasterized pages.
   * @param accountId The external account number (int) or account ID Guid.
   * @param workspaceId Specifies the workspace ID GUID.
   * @param folderId The ID of the folder being accessed.
   * @param fileId Specifies the room file ID GUID.
   * @return PageImages
   */ 

#Code:
  public PageImages listWorkspaceFilePages(String accountId, String workspaceId, String folderId, String fileId) throws ApiException {
    return listWorkspaceFilePages(accountId, workspaceId, folderId, fileId, null);
  }

#end
#end
#No. 185779
#File: E:\bishe\1\WorkSurfaceCraftingManager.java
#Comment:
    /**
     * Returns the static instance of this class
     */

#Code:
    public static final WorkSurfaceCraftingManager getInstance()
    {
        /** The static instance of this class */
        return instance;
    }

#end
#end
#No. 185780
#File: E:\bishe\1\WorkSurfaceCraftingManager.java
#Comment:
    /**
     * returns the List<> of all recipes
     */

#Code:
    public List getRecipeList()
    {
        return this.recipes;
    }

#end
#end
#No. 185781
#File: E:\bishe\1\WorkSurfaceShapedRecipes.java
#Comment:
    /**
     * Used to check if a recipe matches current crafting inventory
     */

#Code:
    public boolean matches(InventoryCrafting par1InventoryCrafting, World par2World)
    {
        for (int i = 0; i <= 5 - this.recipeWidth; ++i)
        {
            for (int j = 0; j <= 5 - this.recipeHeight; ++j)
            {
                if (this.checkMatch(par1InventoryCrafting, i, j, true))
                {
                    return true;
                }

                if (this.checkMatch(par1InventoryCrafting, i, j, false))
                {
                    return true;
                }
            }
        }

        return false;
    }

#end
#end
#No. 185782
#File: E:\bishe\1\WorkSurfaceShapedRecipes.java
#Comment:
    /**
     * Returns an Item that is the result of this recipe
     */

#Code:
    public ItemStack getCraftingResult(InventoryCrafting par1InventoryCrafting)
    {
        ItemStack itemstack = this.getRecipeOutput().copy();

        if (this.field_92101_f)
        {
            for (int i = 0; i < par1InventoryCrafting.getSizeInventory(); ++i)
            {
                ItemStack itemstack1 = par1InventoryCrafting.getStackInSlot(i);

                if (itemstack1 != null && itemstack1.hasTagCompound())
                {
                    itemstack.setTagCompound((NBTTagCompound)itemstack1.stackTagCompound.copy());
                }
            }
        }

        return itemstack;
    }

#end
#end
#No. 185783
#File: E:\bishe\1\WorkSurfaceShapedRecipes.java
#Comment:
    /**
     * Returns the size of the recipe area
     */

#Code:
    public int getRecipeSize()
    {
        return this.recipeWidth * this.recipeHeight;
    }

#end
#end
#No. 185784
#File: E:\bishe\1\WorkSurfaceShapelessRecipes.java
#Comment:
    /**
     * Used to check if a recipe matches current crafting inventory
     */

#Code:
    public boolean matches(InventoryCrafting par1InventoryCrafting, World par2World)
    {
        ArrayList arraylist = new ArrayList(this.recipeItems);

        for (int i = 0; i < 5; ++i)
        {
            for (int j = 0; j < 5; ++j)
            {
                ItemStack itemstack = par1InventoryCrafting.getStackInRowAndColumn(j, i);

                if (itemstack != null)
                {
                    boolean flag = false;
                    Iterator iterator = arraylist.iterator();

                    while (iterator.hasNext())
                    {
                        ItemStack itemstack1 = (ItemStack)iterator.next();

                        if (itemstack.getItem() == itemstack1.getItem() && (itemstack1.getItemDamage() == 32767 || itemstack.getItemDamage() == itemstack1.getItemDamage()))
                        {
                            flag = true;
                            arraylist.remove(itemstack1);
                            break;
                        }
                    }

                    if (!flag)
                    {
                        return false;
                    }
                }
            }
        }

        return arraylist.isEmpty();
    }

#end
#end
#No. 185785
#File: E:\bishe\1\WorkSurfaceShapelessRecipes.java
#Comment:
    /**
     * Returns an Item that is the result of this recipe
     */

#Code:
    public ItemStack getCraftingResult(InventoryCrafting par1InventoryCrafting)
    {
        return this.recipeOutput.copy();
    }

#end
#end
#No. 185786
#File: E:\bishe\1\WorkSurfaceShapelessRecipes.java
#Comment:
    /**
     * Returns the size of the recipe area
     */

#Code:
    public int getRecipeSize()
    {
        return this.recipeItems.size();
    }


#end
#end
#No. 185788
#File: E:\bishe\1\WorkTimeType.java
#Comment:
   /**
    * Gets the value of the start property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getStart()
   {
      return start;
   }

#end
#end
#No. 185789
#File: E:\bishe\1\WorkTimeType.java
#Comment:
   /**
    * Sets the value of the start property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setStart(Date value)
   {
      this.start = value;
   }

#end
#end
#No. 185790
#File: E:\bishe\1\WorkTimeType.java
#Comment:
   /**
    * Gets the value of the finish property.
    *
    * @return
    *     possible object is
    *     {@link String }
    *
    */

#Code:
   public Date getFinish()
   {
      return finish;
   }

#end
#end
#No. 185791
#File: E:\bishe\1\WorkTimeType.java
#Comment:
   /**
    * Sets the value of the finish property.
    *
    * @param value
    *     allowed object is
    *     {@link String }
    *
    */

#Code:
   public void setFinish(Date value)
   {
      this.finish = value;
   }



#end
#end
#No. 185795
#File: E:\bishe\1\WorldActivity.java
#Comment:
    /**
     * Short-hand for opening special entries with openEditableNbtDbEntry(keyName)
     */

#Code:
    public EditableNBT openSpecialEditableNbtDbEntry(final World.SpecialDBEntryType entryType)
            throws IOException {
        return openEditableNbtDbEntry(entryType.keyName);
    }

#end
#end
#No. 185796
#File: E:\bishe\1\WorldActivity.java
#Comment:
    /**
     * Loads local player data "~local-player" or level.dat>"Player" into an EditableNBT.
     * @return EditableNBT, local player NBT data wrapped in a handle to use for saving + metadata
     * @throws Exception
     */

#Code:
    public EditableNBT getEditablePlayer() throws Exception {

        /*
                Logic path:
                1. try to find the player-data in the db:
                        if found -> return that
                        else -> go to 2
                2. try to find the player-data in the level.dat:
                        if found -> return that
                        else -> go to 3
                3. no player-data available: warn the user
         */

        EditableNBT editableNBT;
        try {
            editableNBT = openSpecialEditableNbtDbEntry(World.SpecialDBEntryType.LOCAL_PLAYER);
        } catch (IOException e){
            e.printStackTrace();
            throw new Exception("Failed to read \"~local_player\" from the database.");
        }

        //check if it is not found in the DB
        if(editableNBT == null) editableNBT = openEditableNbtLevel("Player");

        //check if it is not found in level.dat as well
        if(editableNBT == null) throw new Exception("Failed to find \"~local_player\" in DB and \"Player\" in level.dat!");


        return editableNBT;

    }

#end
#end
#No. 185799
#File: E:\bishe\1\WorldChunkLoading.java
#Comment:
    /**
     * Gets whether this section is enabled.
     * 
     * @return is enabled
     */

#Code:
    public boolean isEnabled() {
        return this.enabled;
    }

#end
#end
#No. 185800
#File: E:\bishe\1\WorldChunkManagerCaves.java
#Comment:
    /**
     * Returns the BiomeGenBase related to the x, z position on the world.
     */

#Code:
    @Override
    public BiomeGenBase getBiomeGenAt(int par1, int par2)
    {
        return this.biomeToUse;
    }

#end
#end
#No. 185801
#File: E:\bishe\1\WorldChunkManagerCaves.java
#Comment:
    /**
     * Returns an array of biomes for the location input.
     */

#Code:
    @Override
    public BiomeGenBase[] getBiomesForGeneration(BiomeGenBase[] par1ArrayOfBiomeGenBase, int par2, int par3, int par4, int par5)
    {
        if (par1ArrayOfBiomeGenBase == null || par1ArrayOfBiomeGenBase.length < par4 * par5)
        {
            par1ArrayOfBiomeGenBase = new BiomeGenBase[par4 * par5];
        }

        Arrays.fill(par1ArrayOfBiomeGenBase, 0, par4 * par5, this.biomeToUse);
        return par1ArrayOfBiomeGenBase;
    }

#end
#end
#No. 185802
#File: E:\bishe\1\WorldChunkManagerCaves.java
#Comment:
    /**
     * Returns a list of temperatures to use for the specified blocks.  Args: listToReuse, x, y, width, length
     */

#Code:
    public float[] getTemperatures(float[] par1ArrayOfFloat, int par2, int par3, int par4, int par5)
    {
        if (par1ArrayOfFloat == null || par1ArrayOfFloat.length < par4 * par5)
        {
            par1ArrayOfFloat = new float[par4 * par5];
        }

        Arrays.fill(par1ArrayOfFloat, 0, par4 * par5, this.hellTemperature);
        return par1ArrayOfFloat;
    }

#end
#end
#No. 185803
#File: E:\bishe\1\WorldChunkManagerCaves.java
#Comment:
    /**
     * Returns a list of rainfall values for the specified blocks. Args: listToReuse, x, z, width, length.
     */

#Code:
    @Override
    public float[] getRainfall(float[] par1ArrayOfFloat, int par2, int par3, int par4, int par5)
    {
        if (par1ArrayOfFloat == null || par1ArrayOfFloat.length < par4 * par5)
        {
            par1ArrayOfFloat = new float[par4 * par5];
        }

        Arrays.fill(par1ArrayOfFloat, 0, par4 * par5, this.rainfall);
        return par1ArrayOfFloat;
    }

#end
#end
#No. 185804
#File: E:\bishe\1\WorldChunkManagerCaves.java
#Comment:
    /**
     * Returns biomes to use for the blocks and loads the other data like temperature and humidity onto the
     * WorldChunkManager Args: oldBiomeList, x, z, width, depth
     */

#Code:
    @Override
    public BiomeGenBase[] loadBlockGeneratorData(BiomeGenBase[] par1ArrayOfBiomeGenBase, int par2, int par3, int par4, int par5)
    {
        if (par1ArrayOfBiomeGenBase == null || par1ArrayOfBiomeGenBase.length < par4 * par5)
        {
            par1ArrayOfBiomeGenBase = new BiomeGenBase[par4 * par5];
        }

        Arrays.fill(par1ArrayOfBiomeGenBase, 0, par4 * par5, this.biomeToUse);
        return par1ArrayOfBiomeGenBase;
    }

#end
#end
#No. 185805
#File: E:\bishe\1\WorldChunkManagerCaves.java
#Comment:
    /**
     * Return a list of biomes for the specified blocks. Args: listToReuse, x, y, width, length, cacheFlag (if false,
     * don't check biomeCache to avoid infinite loop in BiomeCacheBlock)
     */

#Code:
    @Override
    public BiomeGenBase[] getBiomeGenAt(BiomeGenBase[] par1ArrayOfBiomeGenBase, int par2, int par3, int par4, int par5, boolean par6)
    {
        return this.loadBlockGeneratorData(par1ArrayOfBiomeGenBase, par2, par3, par4, par5);
    }

#end
#end
#No. 185806
#File: E:\bishe\1\WorldChunkManagerCaves.java
#Comment:
    /**
     * Finds a valid position within a range, that is in one of the listed biomes. Searches {par1,par2} +-par3 blocks.
     * Strongly favors positive y positions.
     */

#Code:
    @SuppressWarnings("rawtypes")
	@Override
    public ChunkPosition findBiomePosition(int par1, int par2, int par3, List par4List, Random par5Random)
    {
        return par4List.contains(this.biomeToUse) ? new ChunkPosition(par1 - par3 + par5Random.nextInt(par3 * 2 + 1), 0, par2 - par3 + par5Random.nextInt(par3 * 2 + 1)) : null;
    }

#end
#end
#No. 185807
#File: E:\bishe\1\WorldChunkManagerCaves.java
#Comment:
    /**
     * checks given Chunk's Biomes against List of allowed ones
     */

#Code:
    @SuppressWarnings("rawtypes")
	@Override
    public boolean areBiomesViable(int par1, int par2, int par3, List par4List)
    {
        return par4List.contains(this.biomeToUse);
    }

#end
#end
#No. 185808
#File: E:\bishe\1\WorldChunkManagerTofu.java
#Comment:
    /**
     * Gets the list of valid biomes for the player to spawn in.
     */

#Code:
    @Override
    public List getBiomesToSpawnIn()
    {
        return this.biomesToSpawnIn;
    }

#end
#end
#No. 185809
#File: E:\bishe\1\WorldChunkManagerTofu.java
#Comment:
    /**
     * Returns the BiomeGenTofuBase related to the x, z position on the world.
     */

#Code:
    @Override
    public BiomeGenBase getBiomeGenAt(int par1, int par2)
    {
        return this.biomeCache.getBiomeGenAt(par1, par2);
    }

#end
#end
#No. 185810
#File: E:\bishe\1\WorldChunkManagerTofu.java
#Comment:
    /**
     * Returns a list of rainfall values for the specified blocks. Args: listToReuse, x, z, width, length.
     */

#Code:
    @Override
    public float[] getRainfall(float[] par1ArrayOfFloat, int par2, int par3, int par4, int par5)
    {
        IntCache.resetIntCache();

        if (par1ArrayOfFloat == null || par1ArrayOfFloat.length < par4 * par5)
        {
            par1ArrayOfFloat = new float[par4 * par5];
        }

        int[] aint = this.genBiomes.getInts(par2, par3, par4, par5);

        for (int i1 = 0; i1 < par4 * par5; ++i1)
        {
            float f = BiomeGenTofuBase.getBiome(aint[i1]).getIntRainfall() / 65536.0F;

            if (f > 1.0F)
            {
                f = 1.0F;
            }

            par1ArrayOfFloat[i1] = f;
        }

        return par1ArrayOfFloat;
    }

#end
#end
#No. 185811
#File: E:\bishe\1\WorldChunkManagerTofu.java
#Comment:
    /**
     * Return an adjusted version of a given temperature based on the y height
     */

#Code:
    @Override
    public float getTemperatureAtHeight(float par1, int par2)
    {
        return par1;
    }

#end
#end
#No. 185813
#File: E:\bishe\1\WorldChunkManagerTofu.java
#Comment:
    /**
     * Returns an array of biomes for the location input.
     */

#Code:
    @Override
    public BiomeGenBase[] getBiomesForGeneration(BiomeGenBase[] par1ArrayOfBiomeGenBase, int par2, int par3, int par4, int par5)
    {
        IntCache.resetIntCache();

        if (par1ArrayOfBiomeGenBase == null || par1ArrayOfBiomeGenBase.length < par4 * par5)
        {
            par1ArrayOfBiomeGenBase = new BiomeGenBase[par4 * par5];
        }

        int[] aint = this.genBiomes.getInts(par2, par3, par4, par5);

        for (int i1 = 0; i1 < par4 * par5; ++i1)
        {
            par1ArrayOfBiomeGenBase[i1] = BiomeGenTofuBase.getBiomeGenArray()[aint[i1]];
        }

        return par1ArrayOfBiomeGenBase;
    }

#end
#end
#No. 185814
#File: E:\bishe\1\WorldChunkManagerTofu.java
#Comment:
    /**
     * Returns biomes to use for the blocks and loads the other data like temperature and humidity onto the
     * WorldChunkManager Args: oldBiomeList, x, z, width, depth
     */

#Code:
    @Override
    public BiomeGenBase[] loadBlockGeneratorData(BiomeGenBase[] par1ArrayOfBiomeGenBase, int par2, int par3, int par4, int par5)
    {
        return this.getBiomeGenAt(par1ArrayOfBiomeGenBase, par2, par3, par4, par5, true);
    }

#end
#end
#No. 185815
#File: E:\bishe\1\WorldChunkManagerTofu.java
#Comment:
    /**
     * Return a list of biomes for the specified blocks. Args: listToReuse, x, y, width, length, cacheFlag (if false,
     * don't check biomeCache to avoid infinite loop in BiomeCacheBlock)
     */

#Code:
    @Override
    public BiomeGenBase[] getBiomeGenAt(BiomeGenBase[] par1ArrayOfBiomeGenBase, int par2, int par3, int par4, int par5, boolean par6)
    {
        IntCache.resetIntCache();

        if (par1ArrayOfBiomeGenBase == null || par1ArrayOfBiomeGenBase.length < par4 * par5)
        {
            par1ArrayOfBiomeGenBase = new BiomeGenBase[par4 * par5];
        }

        if (par6 && par4 == 16 && par5 == 16 && (par2 & 15) == 0 && (par3 & 15) == 0)
        {
            BiomeGenBase[] aBiomeGenBase1 = this.biomeCache.getCachedBiomes(par2, par3);
            System.arraycopy(aBiomeGenBase1, 0, par1ArrayOfBiomeGenBase, 0, par4 * par5);
            return par1ArrayOfBiomeGenBase;
        }
        else
        {
            int[] aint = this.genBiomes.getInts(par2, par3, par4, par5);

            for (int i1 = 0; i1 < par4 * par5; ++i1)
            {
                par1ArrayOfBiomeGenBase[i1] = BiomeGenTofuBase.getBiomeGenArray()[aint[i1]];
            }

            return par1ArrayOfBiomeGenBase;
        }
    }

#end
#end
#No. 185816
#File: E:\bishe\1\WorldChunkManagerTofu.java
#Comment:
    /**
     * checks given Chunk's Biomes against List of allowed ones
     */

#Code:
    @Override
    public boolean areBiomesViable(int par1, int par2, int par3, List par4List)
    {
        IntCache.resetIntCache();
        int l = par1 - par3 >> 2;
        int i1 = par2 - par3 >> 2;
        int j1 = par1 + par3 >> 2;
        int k1 = par2 + par3 >> 2;
        int l1 = j1 - l + 1;
        int i2 = k1 - i1 + 1;
        int[] aint = this.genBiomes.getInts(l, i1, l1, i2);

        for (int j2 = 0; j2 < l1 * i2; ++j2)
        {
            BiomeGenBase biomeGenTofuBase = BiomeGenTofuBase.getBiomeGenArray()[aint[j2]];

            if (!par4List.contains(biomeGenTofuBase))
            {
                return false;
            }
        }

        return true;
    }

#end
#end
#No. 185817
#File: E:\bishe\1\WorldChunkManagerTofu.java
#Comment:
    /**
     * Finds a valid position within a range, that is in one of the listed biomes. Searches {par1,par2} +-par3 blocks.
     * Strongly favors positive y positions.
     */

#Code:
    @Override
    public ChunkPosition findBiomePosition(int par1, int par2, int par3, List par4List, Random par5Random)
    {
        IntCache.resetIntCache();
        int l = par1 - par3 >> 2;
        int i1 = par2 - par3 >> 2;
        int j1 = par1 + par3 >> 2;
        int k1 = par2 + par3 >> 2;
        int l1 = j1 - l + 1;
        int i2 = k1 - i1 + 1;
        int[] aint = this.genBiomes.getInts(l, i1, l1, i2);
        ChunkPosition chunkposition = null;
        int j2 = 0;

        for (int k2 = 0; k2 < l1 * i2; ++k2)
        {
            int l2 = l + k2 % l1 << 2;
            int i3 = i1 + k2 / l1 << 2;
            BiomeGenBase biomeGenTofuBase = BiomeGenTofuBase.getBiomeGenArray()[aint[k2]];

            if (par4List.contains(biomeGenTofuBase) && (chunkposition == null || par5Random.nextInt(j2 + 1) == 0))
            {
                chunkposition = new ChunkPosition(l2, 0, i3);
                ++j2;
            }
        }

        return chunkposition;
    }

#end
#end
#No. 185818
#File: E:\bishe\1\WorldChunkManagerTofu.java
#Comment:
    /**
     * Calls the WorldChunkManager's biomeCache.cleanupCache()
     */

#Code:
    @Override
    public void cleanupCache()
    {
        this.biomeCache.cleanupCache();
    }

#end
#end
#No. 185819
#File: E:\bishe\1\WorldConfigStore.java
#Comment:
	/**
	 * Gets the World Configuration of a world, while forcing a particular environment.
	 * 
	 * @param worldname to get the configuration of
	 * @param worldmode to force, use null to use the current
	 * @return World Config of the world
	 */

#Code:
	public static WorldConfig get(String worldname, WorldMode worldmode) {
		WorldConfig c = worldConfigs.get(worldname);
		if (c == null) {
			c = create(worldname);
			if (worldmode != null) {
				c.worldmode = worldmode;
			}
			c.reset();
		} else if (worldmode != null) {
			c.worldmode = worldmode;
		}
		return c;
	}

#end
#end
#No. 185820
#File: E:\bishe\1\WorldConfigStore.java
#Comment:
	/**
	 * Gets the World Configuration of the main world
	 * 
	 * @return Main world configuration
	 */

#Code:
	public static WorldConfig getMain() {
		return get(MyWorlds.getMainWorld());
	}

#end
#end
#No. 185821
#File: E:\bishe\1\WorldConfigStore.java
#Comment:
	/**
	 * Gets the Default Properties configuration.A null return indicates that no defaults
	 * are available, which can occur after MyWorlds disabled.
	 * 
	 * @return The default properties configuration, or null if unavailable
	 */

#Code:
	public static ConfigurationNode getDefaultProperties() {
		return defaultProperties == null ? null : defaultProperties.clone();
	}

#end
#end
#No. 185822
#File: E:\bishe\1\WorldConfigStore.java
#Comment:
	/**
	 * Removes a specific World Configuration from this storage.
	 * Please note that this method can NOT be used async.
	 * 
	 * @param worldname to remove
	 */

#Code:
	public static void remove(String worldname) {
		// Unregister the world configuration to remove it
		worldConfigs.remove(worldname);
		// Remove references to this World Configuration in other worlds
		for (WorldConfig otherConfig : all()) {
			if (worldname.equalsIgnoreCase(otherConfig.getNetherPortal())) {
				otherConfig.setNetherPortal(null);
			}
			if (worldname.equalsIgnoreCase(otherConfig.getEnderPortal())) {
				otherConfig.setEnderPortal(null);
			}
			otherConfig.inventory.remove(worldname, false);
		}
	}

#end
#end
#No. 185823
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get the spawn protection size
     *
     * @return an integer between 0 and INTMAX, 16 on failure.
     */

#Code:
    public int getSpawnProtectionSize() {
        return cfg.getInt("spawn-protection", 16);
    }

#end
#end
#No. 185824
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether auto heal is enabled.
     *
     * @return true or false. Returns value of canSpawnMonsters() if auto-heal is 'default'
     */

#Code:
    public boolean isAutoHealEnabled() {
        if (cfg.getString("auto-heal", "default").equals("default")) {
            return this.canSpawnMonsters();
        }
        return getBoolean("auto-heal", false);
    }

#end
#end
#No. 185825
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether experience is enabled
     *
     * @return true when enabled, false otherwise. Default is true.
     */

#Code:
    public boolean isExperienceEnabled() {
        return getBoolean("enable-experience", true);
    }

#end
#end
#No. 185826
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether health is enabled.
     *
     * @return true when enabled, false otherwise. Default is true.
     */

#Code:
    public boolean isHealthEnabled() {
        return getBoolean("enable-health", true);
    }

#end
#end
#No. 185827
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get an Array of String of spawnable animals
     *
     * @return animals array
     */

#Code:
    public String[] getSpawnableAnimals() {
        return cfg.getStringArray("natural-animals", animals);
    }

#end
#end
#No. 185828
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get an Array of String of spawnable water animals
     *
     * @return water animals array
     */

#Code:
    public String[] getSpawnableWaterAnimals() {
        return cfg.getStringArray("natural-wateranimals", wateranimals);
    }

#end
#end
#No. 185829
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get an Array of String of spawnable monsters
     *
     * @return monster array
     */

#Code:
    public String[] getSpawnableMobs() {
        return cfg.getStringArray("natural-monsters", monsters);
    }

#end
#end
#No. 185830
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get an Array of String of spawnable golems
     *
     * @return golem array
     */

#Code:
    public String[] getSpawnableGolems() {
        return cfg.getStringArray("natural-golems", golems);
    }

#end
#end
#No. 185831
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get the block types allowed for enderman to move.
     *
     * @return An integer array containing the block types.
     */

#Code:
    public int[] getEnderBlocks() {
        return cfg.getIntArray("ender-blocks", enderblocks);
    }

#end
#end
#No. 185832
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get the block types banned.
     *
     * @return An integer array containing the block types.
     */

#Code:
    public int[] getBannedBlocks() {
        return cfg.getIntArray("disallowed-blocks", disallowedblocks);
    }

#end
#end
#No. 185833
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * See if a given animal is allowed to spawn
     * This method looks in both the normal and water animal lists.
     *
     * @param name
     *         the name of the Animal
     *
     * @return true or false
     */

#Code:
    public boolean isAnimalSpawnable(String name) {
        for (String animal : cfg.getStringArray("natural-animals")) {
            if (name.equals(animal)) {
                return true;
            }
        }
        for (String animal : cfg.getStringArray("natural-wateranimals")) {
            if (name.equals(animal)) {
                return true;
            }
        }
        return false;
    }

#end
#end
#No. 185834
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * See if a given mob is allowed to spawn
     *
     * @param name
     *         the name of the Mob
     *
     * @return true or false
     */

#Code:
    public boolean isMobSpawnable(String name) {
        for (String mob : cfg.getStringArray("natural-monsters")) {
            if (name.equals(mob)) {
                return true;
            }
        }
        return false;
    }

#end
#end
#No. 185835
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get the world name
     *
     * @return a string with the world name
     */

#Code:
    public String getWorldName() {
        return cfg.getString("world-name", worldname);
    }

#end
#end
#No. 185836
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get the world type.
     *
     * @return a String with the world type. Default is DEFAULT
     */

#Code:
    public WorldType getWorldType() {
        return WorldType.fromString(cfg.getString("world-type", "DEFAULT"));
    }

#end
#end
#No. 185837
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get the world seed.
     *
     * @return a string containing the world seed
     */

#Code:
    public String getWorldSeed() {
        return cfg.getString("world-seed", "");
    }

#end
#end
#No. 185838
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether the nether is allowed
     *
     * @return true when allowed, false otherwise
     */

#Code:
    public boolean isNetherAllowed() {
        return getBoolean("allow-nether", true);
    }

#end
#end
#No. 185839
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether the end is allowed
     *
     * @return true when allowed, false otherwise
     */

#Code:
    public boolean isEndAllowed() {
        return getBoolean("allow-end", true);
    }

#end
#end
#No. 185840
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether flight is allowed
     *
     * @return true when allowed, false otherwise
     */

#Code:
    public boolean isFlightAllowed() {
        return getBoolean("allow-flight", true);
    }

#end
#end
#No. 185841
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether NPCs can be spawned
     *
     * @return true or false
     */

#Code:
    public boolean canSpawnVillagers() {
        return getBoolean("spawn-villagers", true);
    }

#end
#end
#No. 185842
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether animals can be spawned
     *
     * @return true or false
     */

#Code:
    public boolean canSpawnAnimals() {
        return getBoolean("spawn-animals", true);
    }

#end
#end
#No. 185843
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether monsters can be spawned
     *
     * @return true or false
     */

#Code:
    public boolean canSpawnMonsters() {
        return getBoolean("spawn-monsters", true);
    }

#end
#end
#No. 185844
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether golems can be spawned
     *
     * @return true or false
     */

#Code:
    public boolean canSpawnGolems() {
        return getBoolean("spawn-golems", true);
    }

#end
#end
#No. 185845
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether structures must be generated
     *
     * @return true or false
     */

#Code:
    public boolean generatesStructures() {
        return getBoolean("generate-structures", true);
    }

#end
#end
#No. 185846
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get the maximum build height
     *
     * @return an integer, defaulting to 256
     */

#Code:
    public int getMaxBuildHeight() {
        return MathHelp.setInRange(cfg.getInt("max-build-height", 256), 1, 256);
    }

#end
#end
#No. 185847
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get whether PVP is enabled
     *
     * @return true when enabled, false otherwise. Default is true.
     */

#Code:
    public boolean isPvpEnabled() {
        return getBoolean("pvp", true);
    }

#end
#end
#No. 185848
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get the difficulty
     *
     * @return difficulty
     */

#Code:
    public World.Difficulty getDifficulty() {
        return World.Difficulty.fromId(cfg.getInt("difficulty", 1));
    }

#end
#end
#No. 185849
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get the game mode for this world
     *
     * @return game mode
     */

#Code:
    public GameMode getGameMode() {
        return GameMode.fromId(cfg.getInt("gamemode", 0));
    }

#end
#end
#No. 185850
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Get the natural spawn rate, a percentage.
     *
     * @return A value from 0 to 100, default is 100.
     */

#Code:
    public int getNaturalSpawnRate() {
        return MathHelp.setInRange(cfg.getInt("natural-spawn-rate", 100), 0, 100);
    }

#end
#end
#No. 185851
#File: E:\bishe\1\WorldConfiguration.java
#Comment:
    /**
     * Gets the World Generator settings
     *
     * @return world generator settings
     */

#Code:
    public String getGeneratorSettings() {
        return cfg.getString("generator-settings", "");
    }

#end
#end
#No. 185852
#File: E:\bishe\1\WorldCoordinates.java
#Comment:
    /**
     * Compare the coordinate with another coordinate
     */

#Code:
    public int compareWorldCoordinate(WorldCoordinates par1)
    {
        return this.dim == par1.dim ? (
        		this.y == par1.y ? (this.z == par1.z ? this.x - par1.x : this.z - par1.z) : this.y - par1.y) : -1;
    }

#end
#end
#No. 185853
#File: E:\bishe\1\WorldCoordinates.java
#Comment:
    /**
     * Returns the squared distance between this coordinates and the coordinates given as argument.
     */

#Code:
    public float getDistanceSquared(int par1, int par2, int par3)
    {
        float f = (float)(this.x - par1);
        float f1 = (float)(this.y - par2);
        float f2 = (float)(this.z - par3);
        return f * f + f1 * f1 + f2 * f2;
    }

#end
#end
#No. 185854
#File: E:\bishe\1\WorldCoordinates.java
#Comment:
    /**
     * Return the squared distance between this coordinates and the ChunkCoordinates given as argument.
     */

#Code:
    public float getDistanceSquaredToWorldCoordinates(WorldCoordinates par1ChunkCoordinates)
    {
        return this.getDistanceSquared(par1ChunkCoordinates.x, par1ChunkCoordinates.y, par1ChunkCoordinates.z);
    }

#end
#end
#No. 185855
#File: E:\bishe\1\WorldEditCUI.java
#Comment:
   /**
    * @return By default true is returned
    * @see com.sijobe.spc.core.IHook#isEnabled()
    */

#Code:
   @Override
   public boolean isEnabled() {
      return handleEvents;
   }

#end
#end
#No. 185856
#File: E:\bishe\1\WorldEditCUI.java
#Comment:
   /**
    * @see com.sijobe.spc.core.IHook#init(java.lang.Object[])
    */

#Code:
   @Override
   public void init(Object... params) {
   }

#end
#end
#No. 185857
#File: E:\bishe\1\WorldEditCUI.java
#Comment:
   /**
    * @see com.sijobe.spc.core.ICUIEventHandler#handleCUIEvent(java.lang.String, java.lang.String[])
   */

#Code:
	@Override
	public void handleCUIEvent(String type, String[] params) {   
		if(!hasWorldEditCUILL && !hasWorldEditCUIML) {
         // neither version of mod was installed
         handleEvents = false;
			return;
		}

      if(!hasModLoader && !hasLiteLoader) {
         // mod was installed but no LiteLoader or ModLoader
         handleEvents = false;
         return;
      }
      
		if(!loadedWorldEditCUI) {
         if(!setWorldEditCUIMod()) {
            System.out.println("SPC/WECUI: WorldEditCUI incorrectly loaded.");
            handleEvents = false;
            return;
         }
		}

		try {
         WorldEditCUIHelper.handleCUIEvent(WorldEditCUIMod, type, params);		
		} catch (Throwable t) {
			System.out.println("SPC/WECUI: WorldEditCUI not initialized.");
         handleEvents = false;
			t.printStackTrace();
		}
	}


#end
#end
#No. 185859
#File: E:\bishe\1\WorldGenDeadTree.java
#Comment:
    /**
     * Gets the rough size of a layer of the tree.
     */

#Code:
    float layerSize(int p_76490_1_)
    {
        if ((float)p_76490_1_ < (float)this.heightLimit * 0.3F)
        {
            return -1.0F;
        }
        else
        {
            float f = (float)this.heightLimit / 2.0F;
            float f1 = f - (float)p_76490_1_;
            float f2 = MathHelper.sqrt_float(f * f - f1 * f1);

            if (f1 == 0.0F)
            {
                f2 = f;
            }
            else if (Math.abs(f1) >= f)
            {
                return 0.0F;
            }

            return f2 * 0.5F;
        }
    }

#end
#end
#No. 185860
#File: E:\bishe\1\WorldGenDeadTree.java
#Comment:
    /**
     * Indicates whether or not a leaf node requires additional wood to be added to preserve integrity.
     */

#Code:
    boolean leafNodeNeedsBase(int p_76493_1_)
    {
        return (double)p_76493_1_ >= (double)this.heightLimit * 0.2D;
    }

#end
#end
#No. 185861
#File: E:\bishe\1\WorldGenDeadTree.java
#Comment:
    /**
     * Returns a boolean indicating whether or not the current location for the tree, spanning basePos to to the height
     * limit, is valid.
     */

#Code:
    private boolean validTreeLocation()
    {
        BlockPos down = this.blockPosOrigin.down();
        net.minecraft.block.state.IBlockState state = this.world.getBlockState(down);
        boolean isSoil = state.getBlock().canSustainPlant(this.world, down, net.minecraft.util.EnumFacing.UP, ((net.minecraft.block.BlockSapling)Blocks.sapling));

        if (!isSoil)
        {
            return false;
        }
        else
        {
            int i = this.func_175936_a(this.blockPosOrigin, this.blockPosOrigin.up(this.heightLimit - 1));

            if (i == -1)
            {
                return true;
            }
            else if (i < 6)
            {
                return false;
            }
            else
            {
                this.heightLimit = i;
                return true;
            }
        }
    }

#end
#end
#No. 185862
#File: E:\bishe\1\WorldGeneratorMenrilTree.java
#Comment:
    /**
     * Make a new instance.
     *
     * @param doNotify If the generator should notify the world.
     */

#Code:
    public WorldGeneratorMenrilTree(boolean doNotify) {
        super(doNotify);
    }

#end
#end
#No. 185863
#File: E:\bishe\1\WorldGenGreatOak.java
#Comment:
    /**
     * Gets the rough size of a layer of the tree.
     */

#Code:
    float layerSize(int p_76490_1_)
    {
        if ((float)p_76490_1_ < (float)this.heightLimit * 0.3F)
        {
            return -1.0F;
        }
        else
        {
            float f = (float)this.heightLimit / 2.0F;
            float f1 = f - (float)p_76490_1_;
            float f2 = MathHelper.sqrt_float(f * f - f1 * f1);

            if (f1 == 0.0F)
            {
                f2 = f;
            }
            else if (Math.abs(f1) >= f)
            {
                return 0.0F;
            }

            return f2 * 0.5F;
        }
    }

#end
#end
#No. 185864
#File: E:\bishe\1\WorldGenGreatOak.java
#Comment:
    /**
     * Indicates whether or not a leaf node requires additional wood to be added to preserve integrity.
     */

#Code:
    boolean leafNodeNeedsBase(int p_76493_1_)
    {
        return (double)p_76493_1_ >= (double)this.heightLimit * 0.2D;
    }

#end
#end
#No. 185865
#File: E:\bishe\1\WorldGenGreatOak.java
#Comment:
    /**
     * Returns a boolean indicating whether or not the current location for the tree, spanning basePos to to the height
     * limit, is valid.
     */

#Code:
    private boolean validTreeLocation()
    {
        BlockPos down = this.blockPosOrigin.down();
        net.minecraft.block.state.IBlockState state = this.world.getBlockState(down);
        boolean isSoil = state.getBlock().canSustainPlant(this.world, down, net.minecraft.util.EnumFacing.UP, ((net.minecraft.block.BlockSapling)Blocks.sapling));

        if (!isSoil)
        {
            return false;
        }
        else
        {
            int i = this.func_175936_a(this.blockPosOrigin, this.blockPosOrigin.up(this.heightLimit - 1));

            if (i == -1)
            {
                return true;
            }
            else if (i < 6)
            {
                return false;
            }
            else
            {
                this.heightLimit = i;
                return true;
            }
        }
    }


#end
#end
#No. 185867
#File: E:\bishe\1\WorldGenMTreeBase.java
#Comment:
    /**
     * @param leafBlock Blocks.leaves = oak, spruce, birch, jungle.  Blocks.leaves2 = acacia, dark oak
     * @param woodBlock Blocks.log = oak, spruce, birch, jungle.  Blocks.log2 = acacia, dark oak
     * @param leafBlockMeta 0 = oak, acacia, 1 = spruce, dark oak, 2 = birch, 3 = jungle
     * @param woodBlockMeta 0 = oak, acacia, 1 = spruce, dark oak, 2 = birch, 3 = jungle
     * @param minH Minimum height of the tree trunk
     * @param maxH Maximum height of the tree trunk
     * @param notify False for world generation, true for saplings
     */

#Code:
    public WorldGenMTreeBase(Block leafBlock, Block woodBlock, int leafBlockMeta, int woodBlockMeta, int minH, int maxH, boolean notify)
    {
    	super(notify);
        leaves = leafBlock;
        wood = woodBlock;
        woodMeta = woodBlockMeta;
        leafMeta = leafBlockMeta;
        minHeight = minH;
        maxHeight = maxH;
        notifyFlag = notify;
    }





#end
#end
#No. 185872
#File: E:\bishe\1\WorldGenTaintedTree.java
#Comment:
    /**
     * Grows vines downward from the given block for a given length. Args: World, x, starty, z, vine-length
     */

#Code:
    private void growVines(World p_76529_1_, int p_76529_2_, int p_76529_3_, int p_76529_4_, int p_76529_5_)
    {
        this.setBlockAndNotifyAdequately(p_76529_1_, p_76529_2_, p_76529_3_, p_76529_4_, Blocks.vine, p_76529_5_);
        int i1 = 4;

        while (true)
        {
            --p_76529_3_;

            if (!p_76529_1_.getBlock(p_76529_2_, p_76529_3_, p_76529_4_).isAir(p_76529_1_, p_76529_2_, p_76529_3_, p_76529_4_) || i1 <= 0)
            {
                return;
            }

            this.setBlockAndNotifyAdequately(p_76529_1_, p_76529_2_, p_76529_3_, p_76529_4_, Blocks.vine, p_76529_5_);
            --i1;
        }
    }

#end
#end
#No. 185873
#File: E:\bishe\1\WorldGenTcTreesBase.java
#Comment:
    /**
     * Grows vines downward from the given block for a given length. Args: World, x, starty, z, vine-length
     */

#Code:
    private void growVines(World par1World, int par2, int par3, int par4, int par5)
    {
        this.setBlockAndNotifyAdequately(par1World, par2, par3, par4, Blocks.vine, par5);
        int var6 = 4;

        while (true)
        {
            --par3;

            if (par1World.getBlock(par2, par3, par4).isAir(par1World, par2, par3, par4) || var6 <= 0)
            {
                return;
            }

            this.setBlockAndNotifyAdequately(par1World, par2, par3, par4, Blocks.vine, par5);
            --var6;
        }
    }

#end
#end
#No. 185874
#File: E:\bishe\1\WorldGenTofuDungeons.java
#Comment:
    /**
     * Picks potentially a random item to add to a dungeon chest.
     */

#Code:
    private ItemStack pickCheckLootItem(Random par1Random)
    {
        return ChestGenHooks.getOneItem(ChestGenHooks.DUNGEON_CHEST, par1Random);
    }

#end
#end
#No. 185875
#File: E:\bishe\1\WorldGenVolcano.java
#Comment:
        /**
         * Generates a blob of lava or obsidian
         * @param center beginning point
         * @param size number of blocks to generate
         */

#Code:
        private void genBlob(BlockCoord center, int size)
        {
            int filled = 0;
            BlockCoord b = null;
            ArrayList<BlockCoord> workplace = new ArrayList<BlockCoord>();
            THashSet<BlockCoord> done = new THashSet<BlockCoord>();
            workplace.add(center);
            while (filled < size && !workplace.isEmpty())
            {
                b = workplace.remove(rand.nextInt(workplace.size()));
                VolcanoHelper.setVolcanoFill(world, b, active);
                done.add(b);
                for (BlockCoord t : b.getAdjacent())
                {
                    if (!done.contains(t))
                        workplace.add(t);
                }
                filled++;
            }
        }

#end
#end
#No. 185876
#File: E:\bishe\1\WorldGenVolcano.java
#Comment:
        /**
         * Encases a blob of lava or obsidian in basalt
         * @param origin beginning point
         * @param thickness average thickness for encasement
         */

#Code:
        private void encaseBlob(BlockCoord origin, int thickness)
        {
            ArrayList<BlockCoord> workplace = new ArrayList<BlockCoord>();
            THashSet<BlockCoord> done = new THashSet<BlockCoord>();
            BlockCoord b;
            workplace.add(origin);
            while (!workplace.isEmpty())
            {
                b = workplace.remove(rand.nextInt(workplace.size()));
                done.add(b);
                for (BlockCoord t : b.getRadiusBlocks(1 + rand.nextInt(thickness - 1)))
                {
                    Block k = t.getBlock(world);
                    if (b.getDistance(t) <= thickness && !VolcanoHelper.isVolcanicFill(k) && !VolcanoHelper.isVolcanicBlock(k))
                        VolcanoHelper.setVolcanoBlock(world, t);
                    else if (VolcanoHelper.isVolcanicFill(k) && !done.contains(t) && !workplace.contains(t))
                        workplace.add(t);
                }
            }
        }

#end
#end
#No. 185877
#File: E:\bishe\1\WorldGenVolcano.java
#Comment:
        /**
         * Generates a lava tube composed of basalt from start to the surface
         * @param start beginning point
         */

#Code:
        private List<BlockCoord> genTube(BlockCoord start)
        {
            BlockCoord b = start.copy();
            int height = VolcanoHelper.getHighestSolidOrFillBlock(world, b.x, b.z)+1;
            int tubeSize = rand.nextInt(5)+1;
            List<BlockCoord> tubeBlocks = new ArrayList<BlockCoord>();
            tubeBlocks.add(b);
            while (tubeBlocks.size() < tubeSize)
            {
                int side = rand.nextInt(4)+2;
                if (!tubeBlocks.contains(b.getAdjacent()[side]))
                    tubeBlocks.add(b.getAdjacent()[side]);
            }
            while (b.y < height)
            {
                for (BlockCoord t : tubeBlocks)
                {
                    if (!VolcanoHelper.isVolcanicFill(t.getBlock(world)))
                        VolcanoHelper.setVolcanoFill(world, t, active);
                    for (BlockCoord n : t.getNearby())
                    {
                        if (n.y > t.y || VolcanoHelper.isVolcanicFill(n.getBlock(world)))
                            continue;
                        VolcanoHelper.setVolcanoBlock(world, n);
                    }
                    t.y++;
                }
            }
            return tubeBlocks;
        }

#end
#end
#No. 185878
#File: E:\bishe\1\WorldGenVolcano.java
#Comment:
        /**
         * Generate a simulated lava flow
         * @param start beginning point
         */

#Code:
        private void genFlow(BlockCoord start, int flowSize)
        {
            int flowed = 0;
            BlockCoord b;
            BlockCoord c;
            List<BlockCoord> open = VolcanoHelper.getOpenSides(world, start);
            while (open.size() == 0)
            {
                start.offset(ForgeDirection.UP);
                open = VolcanoHelper.getOpenSides(world, start);
                VolcanoHelper.setVolcanoFill(world, start, active);
                for (BlockCoord n : start.getAdjacent())
                {
                    if (n.y == start.y && VolcanoHelper.isVolcanicFill(n.copy().offset(ForgeDirection.DOWN).getBlock(world)))
                        VolcanoHelper.setVolcanoFill(world, n, active);
                }
            }
            while (flowed < flowSize && open.size() > 0)
            {
                b = open.get(0);
                c = b.copy();
                VolcanoHelper.setVolcanoBlock(world, b);
                while (VolcanoHelper.isReplaceable(world, c.offset(ForgeDirection.DOWN)))
                    VolcanoHelper.setVolcanoBlock(world, c);
                open = VolcanoHelper.getOpenSides(world, c);
                flowed++;
            }
        }

#end
#end
#No. 185879
#File: E:\bishe\1\WorldGenVolcano.java
#Comment:
        /**
         * Simulate the piling of tephra (volcanic debris)
         * @param start point of ejection
         * @param amount number of blocks to pile
         */

#Code:
        private void genTephra(BlockCoord start, int amount)
        {
            int dropped = 0;
            int radius = amount/3;
            BlockCoord b;
            List<BlockCoord> done = new ArrayList<BlockCoord>();
            while (dropped < amount)
            {
                b = VolcanoHelper.snapToHighest(world, VolcanoHelper.get2dINVERSEDistributedCoord(world, start, MiscUtils.randWithin50(rand, amount)));
                if (!done.contains(b) && !VolcanoHelper.isVolcanicFill(b.getBlock(world)))
                {
                    VolcanoHelper.setVolcanoTephra(world, b.offset(ForgeDirection.UP));
                    done.add(b);
                    dropped++;
                }
            }
        }

#end
#end
#No. 185880
#File: E:\bishe\1\WorldGenVolcano.java
#Comment:
        /**
         * Generate random pieces of lava
         * @param start center point
         * @param amount max number to place
         */

#Code:
        private void genLavaBits(BlockCoord start, int amount)
        {
            BlockCoord b = start.copy();
            while (VolcanoHelper.isVolcanicFill(b.getBlock(world)) || VolcanoHelper.isVolcanicBlock(b.getBlock(world)))
            {
                if (b.y > 255)
                    return;
                if (!(VolcanoHelper.isVolcanicFill(b.copy().offset(ForgeDirection.UP).getBlock(world)) || VolcanoHelper.isVolcanicBlock(b.copy().offset(ForgeDirection.UP).getBlock(world))))
                    break;
                else
                    b.offset(ForgeDirection.UP);
            }
            ArrayList<BlockCoord> toCover = new ArrayList<BlockCoord>();
            ArrayList<BlockCoord> done = new ArrayList<BlockCoord>();
            int num = 0;
            toCover.add(b);
            while (num < amount && !toCover.isEmpty())
            {
                b = toCover.remove(rand.nextInt(toCover.size()));
                if (world.isAirBlock(b.x, b.y+1, b.z) && rand.nextInt(16) == 0)
                {
                    world.setBlock(b.x, b.y, b.z, Blocks.lava, 0, 3);
                    num++;
                }
                done.add(b);
                for (BlockCoord t : b.getNearby())
                {
                    if (!toCover.contains(t) && !done.contains(t) && VolcanoHelper.isVolcanicBlock(t.getBlock(world)) && !t.copy().offset(ForgeDirection.UP).getBlock(world).isOpaqueCube())
                        toCover.add(t);
                }
            }
        }

#end
#end
#No. 185881
#File: E:\bishe\1\WorldGenVolcano.java
#Comment:
        /**
         * Give an existing volcano formation a caldera
         * @param start beginning point
         * @param amount number of blocks to excise
         */

#Code:
        private void genCaldera(BlockCoord start, int amount)
        {

        }

#end
#end
#No. 185882
#File: E:\bishe\1\WorldGenVolcano.java
#Comment:
        /**
         * Replace top blocks of a volcanic feature with biome-appropriate substitutes, and decorates them with flora
         * @param start beginning point
         */

#Code:
        private void coverFeature(BlockCoord start)
        {
            BlockCoord b = start.copy();
            BiomeGenBase biome;
            while ((VolcanoHelper.isVolcanicFill(b.getBlock(world)) || VolcanoHelper.isVolcanicBlock(b.getBlock(world))))
            {
                if (b.y > 255)
                    return;
                if (!(VolcanoHelper.isVolcanicFill(b.copy().offset(ForgeDirection.UP).getBlock(world)) || VolcanoHelper.isVolcanicBlock(b.copy().offset(ForgeDirection.UP).getBlock(world))))
                    break;
                else
                    b.offset(ForgeDirection.UP);
            }
            ArrayDeque<BlockCoord> toCover = new ArrayDeque<BlockCoord>();
            toCover.add(b);
            while (!toCover.isEmpty())
            {
                b = toCover.pop();
                biome = world.getBiomeGenForCoords(b.x, b.y);
                if (biome.topBlock != null && !b.copy().offset(ForgeDirection.UP).getBlock(world).isOpaqueCube() && b.copy().offset(ForgeDirection.UP).isAir(world))
                    b.setBlock(world, biome.topBlock, 0, false);
                else if (biome.fillerBlock != null && !b.copy().offset(ForgeDirection.UP).getBlock(world).isOpaqueCube())
                    b.setBlock(world, biome.fillerBlock, 0, false);
                if (world.isAirBlock(b.x, b.y+1, b.z))
                {
                    if (rand.nextInt(16) == 0)
                        biome.getRandomWorldGenForGrass(rand).generate(world, rand, b.x, b.y, b.z);
                    else if (rand.nextInt(16) == 0)
                        biome.plantFlower(world, rand, b.x, b.y+1, b.z);
                }
                for (BlockCoord t : b.getNearby())
                {
                    if (!toCover.contains(t) && VolcanoHelper.isVolcanicBlock(t.getBlock(world)) && !t.copy().offset(ForgeDirection.UP).getBlock(world).isOpaqueCube())
                        toCover.add(t);
                }
            }
        }

#end
#end
#No. 185883
#File: E:\bishe\1\WorldGrid.java
#Comment:
    /**
     * Initialize
     *
     * @param width      the width of the world
     * @param height     the height of the world
     * @param tileWidth  the width of the tiles
     * @param tileHeight the height of the tiles.
     */

#Code:
    public WorldGrid(int width, int height, int tileWidth, int tileHeight) {
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;

        this.width = width;
        this.height = height;

        worldGrid = generateGrid();

    }

#end
#end
#No. 185884
#File: E:\bishe\1\WorldGrid.java
#Comment:
    /**
     * Generate the grid based on width and height.
     */

#Code:
    public List<Rectangle> generateGrid() {
        List<Rectangle> list = new ArrayList<>();

        for (int x = 0; x <= width; x += tileWidth) {
            for (int y = 0; y <= height; y += tileHeight) {
                list.add(new Rectangle(x, y, tileWidth, tileHeight));
            }
        }

        return list;

    }

#end
#end
#No. 185885
#File: E:\bishe\1\WorldGrid.java
#Comment:
    /**
     * Draw the grid.
     */

#Code:
    public void drawGrid(Graphics graphics) {
        worldGrid.forEach(rec -> graphics.drawRect((int) rec.getX(), (int) rec.getY(), (int) rec.getWidth(), (int) rec.getHeight()));
    }

#end
#end
#No. 185886
#File: E:\bishe\1\WorldGrid.java
#Comment:
    /**
     * This can return null if the grid has not been generated.
     *
     * @return a list of rectangles that represent the grid.
     */

#Code:
    public List<Rectangle> getWorldGrid() {
        return worldGrid;
    }

#end
#end
#No. 185887
#File: E:\bishe\1\WorldGrid.java
#Comment:
    /**
     * @return the tile width
     */

#Code:
    public int getTileWidth() {
        return tileWidth;
    }

#end
#end
#No. 185888
#File: E:\bishe\1\WorldGrid.java
#Comment:
    /**
     * @return the tile height
     */

#Code:
    public int getTileHeight() {
        return tileHeight;
    }

#end
#end
#No. 185889
#File: E:\bishe\1\WorldGrid.java
#Comment:
    /**
     * @return the width
     */

#Code:
    public int getWidth() {
        return width;
    }

#end
#end
#No. 185890
#File: E:\bishe\1\WorldGrid.java
#Comment:
    /**
     * @return the height
     */

#Code:
    public int getHeight() {
        return height;
    }

#end
#end
#No. 185891
#File: E:\bishe\1\WorldGuardHandler5.java
#Comment:
	/**
	 * Build a DefaultDomain from a RegionAccessSet.
	 * @param regionAccessSet RegionAccessSet to read
	 * @return DefaultDomain containing the entities from the RegionAccessSet
	 */

#Code:
	private DefaultDomain buildDomain(RegionAccessSet regionAccessSet) {
		DefaultDomain owners = new DefaultDomain();

		for(String playerName : regionAccessSet.getPlayerNames()) {
			owners.addPlayer(playerName);
		}

		// Add by name since UUIDs were not yet supported
		for(UUID uuid : regionAccessSet.getPlayerUniqueIds()) {
			OfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(uuid);
			if(offlinePlayer != null && offlinePlayer.getName() != null) {
				owners.addPlayer(offlinePlayer.getName());
			}
		}

		for(String group : regionAccessSet.getGroupNames()) {
			owners.addGroup(group);
		}

		return owners;
	}

#end
#end
#No. 185892
#File: E:\bishe\1\WorldGuardHandler6.java
#Comment:
	/**
	 * Build a DefaultDomain from a RegionAccessSet.
	 * @param regionAccessSet RegionAccessSet to read
	 * @return DefaultDomain containing the entities from the RegionAccessSet
	 */

#Code:
	private DefaultDomain buildDomain(RegionAccessSet regionAccessSet) {
		DefaultDomain owners = new DefaultDomain();

		for(String playerName : regionAccessSet.getPlayerNames()) {
			owners.addPlayer(playerName);
		}

		for(UUID uuid : regionAccessSet.getPlayerUniqueIds()) {
			owners.addPlayer(uuid);
		}

		for(String group : regionAccessSet.getGroupNames()) {
			owners.addGroup(group);
		}

		return owners;
	}

#end
#end
#No. 185893
#File: E:\bishe\1\WorldGuardRegionFlagsFeature.java
#Comment:
	/**
	 * Set the region flags/options to the values of a ConfigurationSection.
	 * @param region The region to update the flags for
	 * @return true if the flags have been set correctly, otherwise false
	 */

#Code:
	private boolean updateRegionFlags(GeneralRegion region) {
		boolean result = true;

		// Get section defining the region flag profile
		ConfigurationSection flagProfileSection = region.getConfigurationSectionSetting("general.flagProfile", "flagProfiles");
		if(flagProfileSection == null) {
			return false;
		}

		// Region flags for all states
		ConfigurationSection allFlags = flagProfileSection.getConfigurationSection("ALL");
		if(allFlags != null) {
			result = result && updateRegionFlags(region, allFlags);
		}

		// Region flags for the current state
		ConfigurationSection stateFlags = flagProfileSection.getConfigurationSection(region.getState().getValue());

		// If in reselling mode, fallback to 'resale' section if 'resell' is not found (legacy configuration problem: https://github.com/NLthijs48/AreaShop/issues/303)
		if(stateFlags == null && region.getState() == GeneralRegion.RegionState.RESELL) {
			stateFlags = flagProfileSection.getConfigurationSection("resale");
		}

		if(stateFlags != null) {
			result = result && updateRegionFlags(region, stateFlags);
		}

		return result;
	}

#end
#end
#No. 185894
#File: E:\bishe\1\WorldGuardRegionFlagsFeature.java
#Comment:
	/**
	 * Build an RegionAccessSet from an input that specifies player names, player uuids and groups.
	 * @param input Input string defining the access set
	 * @return RegionAccessSet containing the entities parsed from the input
	 */

#Code:
	public RegionAccessSet parseAccessSet(String input) {
		RegionAccessSet result = new RegionAccessSet();

		String[] inputParts = input.split(", ");
		for(String access : inputParts) {
			if(access != null && !access.isEmpty()) {
				// Check for groups
				if(access.startsWith("g:")) {
					if(access.length() > 2) {
						result.getGroupNames().add(access.substring(2));
					}
				} else if(access.startsWith("n:")) {
					if(access.length() > 2) {
						result.getPlayerNames().add(access.substring(2));
					}
				} else {
					try {
						result.getPlayerUniqueIds().add(UUID.fromString(access));
					} catch(IllegalArgumentException e) {
						AreaShop.warn("Tried using '" + access + "' as uuid for a region member/owner, is your flagProfiles section correct?");
					}
				}
			}
		}

		return result;
	}

#end
#end
#No. 185895
#File: E:\bishe\1\WorldGuardRegionFlagsFeature.java
#Comment:
	/**
	 * Set a WorldGuard region flag.
	 * @param region The WorldGuard region to set
	 * @param flag   The flag to set
	 * @param value  The value to set the flag to
	 * @param <V>    They type of flag to set
	 * @throws InvalidFlagFormat When the value of the flag is wrong
	 */

#Code:
	private <V> void setFlag(ProtectedRegion region, Flag<V> flag, String value) throws InvalidFlagFormat {
		V current = region.getFlag(flag);
		V next = plugin.getWorldGuardHandler().parseFlagInput(flag, value);

		if(!Objects.equals(current, next)) {
			region.setFlag(flag, next);
		}
	}

#end
#end
#No. 185896
#File: E:\bishe\1\WorldGuardRegionFlagsFeature.java
#Comment:
	/**
	 * Translate the color codes you put in greeting/farewell messages to the weird color codes of WorldGuard.
	 * @param message The message where the color codes should be translated (this message has bukkit color codes)
	 * @return The string with the WorldGuard color codes
	 */

#Code:
	private String translateBukkitToWorldGuardColors(String message) {
		String result = message;
		result = result.replace("&c", "&r");
		result = result.replace("&4", "&R");
		result = result.replace("&e", "&y");
		result = result.replace("&6", "&Y");
		result = result.replace("&a", "&g");
		result = result.replace("&2", "&G");
		result = result.replace("&b", "&c");
		result = result.replace("&3", "&C");
		result = result.replace("&9", "&b");
		result = result.replace("&1", "&B");
		result = result.replace("&d", "&p");
		result = result.replace("&5", "&P");
		result = result.replace("&0", "&0");
		result = result.replace("&8", "&1");
		result = result.replace("&7", "&2");
		result = result.replace("&f", "&w");
		result = result.replace("&r", "&x");
		return result;
	}

#end
#end
#No. 185897
#File: E:\bishe\1\WorldInventory.java
#Comment:
	/**
	 * Gets the World name in which all the inventories of this bundle are saved
	 * 
	 * @return shared world name
	 */

#Code:
	public String getSharedWorldName() {
		if (this.worldname == null || !WorldUtil.getWorldFolder(this.worldname).exists()) {
			this.worldname = getSharedWorldName(this.worlds);
			if (this.worldname == null) {
				throw new RuntimeException("Unable to locate a valid World folder to use for player data");
			}
		}
		return this.worldname;
	}

#end
#end
#No. 185898
#File: E:\bishe\1\WorldItemListActivity.java
#Comment:
    /**
     * Checks if the app has permission to write to device storage
     *
     * If the app does not has permission then the user will be prompted to grant permissions
     *
     */

#Code:
    public static boolean verifyStoragePermissions(Activity activity) {
        // Check if we have write permission
        int permission = ActivityCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE);

        if (permission != PackageManager.PERMISSION_GRANTED) {
            // We don't have permission so prompt the user
            ActivityCompat.requestPermissions(
                    activity,
                    PERMISSIONS_STORAGE,
                    REQUEST_EXTERNAL_STORAGE
            );
            return false;
        } else return true;
    }



#end
#end
#No. 185900
#File: E:\bishe\1\WorldMapSymbol.java
#Comment:
/**
 * A symbol in a WorldMap.
 */

#Code:
class WorldMapSymbol {

  private static final WorldMapSymbol HERO_SYMBOL = new WorldMapSymbol('@', Color.WHITE);
  private static final WorldMapSymbol NOT_YET_GENERATED_SYMBOL = new WorldMapSymbol('~', Color.GRAY);

  private final String character;
  private final Color color;

  private WorldMapSymbol(char character, @NotNull Color color) {
    this.character = String.valueOf(character);
    this.color = color;
  }

#end
#end
#No. 185901
#File: E:\bishe\1\WorldMapSymbolFactory.java
#Comment:
  /**
   * Constructs a new WorldMapSymbolFactory for the specified World and Hero position. All locations will have their
   * symbols revealed.
   */

#Code:
  WorldMapSymbolFactory(World world, Point heroPosition) {
    this.world = world;
    this.heroPosition = heroPosition;
    this.explorationStatistics = null;
  }

#end
#end
#No. 185902
#File: E:\bishe\1\WorldMapSymbolFactory.java
#Comment:
  /**
   * Constructs a new WorldMapSymbolFactory for the specified World and Hero position. Just the locations that the
   * player has already seen will have their symbols revealed.
   */

#Code:
  WorldMapSymbolFactory(World world, Point heroPosition, @NotNull ExplorationStatistics explorationStatistics) {
    this.world = world;
    this.heroPosition = heroPosition;
    this.explorationStatistics = explorationStatistics;
  }

  WorldMapSymbol getSymbol(Point position) {
    if (position.equals(heroPosition)) {
      return WorldMapSymbol.getHeroSymbol();
    } else if (explorationStatistics == null || explorationStatistics.hasBeenSeen(position)) {
      return WorldMapSymbol.makeSymbol(world.getLocation(position));
    } else {
      return WorldMapSymbol.getNotYetGeneratedSymbol();
    }
  }

#end
#end
#No. 185903
#File: E:\bishe\1\WorldMapWriter.java
#Comment:
  /**
   * Writes a WorldMap to the screen. This erases all the content currently on the screen.
   *
   * @param map a WorldMap, not null
   */

#Code:
  private static void renderMap(@NotNull WorldMap map) {
    DungeonString string = new DungeonString();
    WorldMapSymbol[][] worldMapSymbolMatrix = map.getSymbolMatrix();
    for (int i = 0; i < worldMapSymbolMatrix.length; i++) {
      for (WorldMapSymbol symbol : worldMapSymbolMatrix[i]) {
        // OK as setColor verifies if the color change is necessary (does not replace a color by itself).
        string.setColor(symbol.getColor());
        string.append(symbol.getCharacterAsString());
      }
      if (i < worldMapSymbolMatrix.length - 1) {
        string.append("\n");
      }
    }

#end
#end
#No. 185904
#File: E:\bishe\1\WorldMode.java
#Comment:
	/**
	 * Parses a piece of text and obtains the WorldMode stored in it.
	 * 
	 * @param text to parse
	 * @return WorldMode, or NORMAL if none was identified
	 */

#Code:
	public static WorldMode get(String text) {
		return get(text, NORMAL);
	}

#end
#end
#No. 185905
#File: E:\bishe\1\WorldMode.java
#Comment:
	/**
	 * Parses a piece of text and obtains the WorldMode stored in it.
	 * 
	 * @param text to parse
	 * @param defaultMode to return upon failure
	 * @return WorldMode, or defaultMode if none was identified
	 */

#Code:
	public static WorldMode get(String text, WorldMode defaultMode) {
		String fixedText = text.toLowerCase(Locale.ENGLISH);
		WorldMode mode = byName.get(fixedText);
		int start;
		while (mode == null && (start = fixedText.indexOf('_')) != -1) {
			fixedText = fixedText.substring(start + 1);
			mode = byName.get(fixedText);
		}
		return LogicUtil.fixNull(mode, defaultMode);
	}

#end
#end
#No. 185909
#File: E:\bishe\1\WorldPortalsApi.java
#Comment:
    /**
     * Get the IApi implementation for World Portals.
     *
     * @return returns the IApi implementation from world portals. May be the ApiDummy if World Portals has not loaded.
     */

#Code:
    public static IApi getApiImpl()
    {
        return apiImpl;
    }

#end
#end
#No. 185910
#File: E:\bishe\1\WorldPortalsApi.java
#Comment:
    /**
     * Sets the IApi implementation for World Portals.
     * For use of World Portals, so please don't actually use this.
     *
     * @param apiImpl API implementation to set.
     */

#Code:
    public static void setApiImpl(IApi apiImpl)
    {
        WorldPortalsApi.apiImpl = apiImpl;
    }

#end
#end
#No. 185911
#File: E:\bishe\1\WorldProviderCaves.java
#Comment:
	/**
	 * creates a new world chunk manager for WorldProvider
	 */

#Code:
	@Override
	public void registerWorldChunkManager()
	{
		this.worldChunkMgr = new WorldChunkManagerCaves(EnviroMine.caves, 1.0F, 0.0F);
		this.isHellWorld = false;
		this.hasNoSky = true;
		this.dimensionId = EM_Settings.caveDimID;
	}

#end
#end
#No. 185912
#File: E:\bishe\1\WorldProviderCaves.java
#Comment:
	/**
	 * Return Vec3D with biome specific fog color
	 */

#Code:
	@SideOnly(Side.CLIENT)
	@Override
	public Vec3 getFogColor(float par1, float par2)
	{
        float f2 = 1F;//MathHelper.cos(1F * (float)Math.PI * 2.0F) * 2.0F + 0.5F;

        if (f2 < 0.0F)
        {
            f2 = 0.0F;
        }

        if (f2 > 1.0F)
        {
            f2 = 1.0F;
        }

        float f3 = 0.7529412F;
        float f4 = 0.84705883F;
        float f5 = 1.0F;
        f3 *= f2 * 0.94F + 0.06F;
        f4 *= f2 * 0.94F + 0.06F;
        f5 *= f2 * 0.91F + 0.09F;
        return Vec3.createVectorHelper((double)f3, (double)f4, (double)f5);
	}

#end
#end
#No. 185913
#File: E:\bishe\1\WorldProviderCaves.java
#Comment:
	/**
	 * Creates the light to brightness table
	 */

#Code:
	@Override
	protected void generateLightBrightnessTable()
	{
		float f = 0F;
		
		for (int i = 0; i <= 15; ++i)
		{
			float f1 = 1.0F - (float)i / 15.0F;
			this.lightBrightnessTable[i] = (1.0F - f1) / (f1 * 3.0F + 1.0F) * (1.0F - f) + f;
		}
	}

#end
#end
#No. 185914
#File: E:\bishe\1\WorldProviderCaves.java
#Comment:
	/**
	 * Returns a double value representing the Y value relative to the top of the map at which void fog is at its
	 * maximum. The default factor of 0.03125 relative to 256, for example, means the void fog will be at its maximum at
	 * (256*0.03125), or 8.
	 */

#Code:
	public double getVoidFogYFactor()
	{
		return 0.000000000001D;
	}





#end
#end
#No. 185918
#File: E:\bishe\1\WorldProviderCaves.java
#Comment:
	/**
	 * True if the player can respawn in this dimension (true = overworld, false = nether).
	 */

#Code:
	@Override
	public boolean canRespawnHere()
	{
		return EM_Settings.caveRespawn;
	}



#end
#end
#No. 185920
#File: E:\bishe\1\WorldProviderCaves.java
#Comment:
	/**
	 * Returns the dimension's name, e.g. "The End", "Nether", or "Overworld".
	 */

#Code:
	@Override
	public String getDimensionName()
	{
		return "Caves";
	}

#end
#end
#No. 185921
#File: E:\bishe\1\WorldProviderTofu.java
#Comment:
    /**
     * creates a new world chunk manager for WorldProvider
     */

#Code:
    @Override
    public void registerWorldChunkManager()
    {
        this.worldChunkMgr = new WorldChunkManagerTofu(worldObj);
        this.dimensionId = Settings.tofuDimNo;
    }

#end
#end
#No. 185922
#File: E:\bishe\1\WorldProviderTofu.java
#Comment:
    /**
     * Returns a new chunk provider register generates chunks for this world
     */

#Code:
    @Override
    public IChunkProvider createChunkGenerator()
    {
        long newSeed = Utils.getSeedForTofuWorld(this.worldObj);
        return new ChunkProviderTofu(this.worldObj, newSeed, true);
    }

#end
#end
#No. 185923
#File: E:\bishe\1\WorldProviderTofu.java
#Comment:
    /**
     * Returns the dimension's name, e.g. "The End", "Nether", or "Overworld".
     */

#Code:
    @Override
    public String getDimensionName()
    {
        return "Tofu World";
    }

#end
#end
#No. 185924
#File: E:\bishe\1\WorldProviderTofu.java
#Comment:
    /**
     * A Message to display to the user when they transfer out of this dismension.
     *
     * @return The message to be displayed
     */

#Code:
    @Override
    public String getDepartMessage()
    {
        return "Leaving the Tofu World";
    }

#end
#end
#No. 185925
#File: E:\bishe\1\WorldRenderer.java
#Comment:
	/**
	 * Minecraft chunk populating logic works as follows:
	 * // If the chunk isn't populated and the chunks to the southeast, east,
	 * and south are loaded, populate the chunk.
	 * // If the chunk to the north is loaded, but isn't populated and the
	 * chunks to the northeast, east, and north are loaded, populate the chunk
	 * to the north.
	 * // If the chunk to the west is loaded, but isn't populated and the chunks
	 * to the southwest, west, and south are loaded, populate the chunk to the
	 * west.
	 * // If the chunk to the northwest is loaded, but isn't populated and the
	 * chunks to the northwest, west, and north are loaded, populate the chunk
	 * to the northwest.
	 */

#Code:
	private static void loadChunk(World world, int x, int z) {
		world.loadChunk(x + 1, z + 1);
		world.loadChunk(x + 1, z);
		world.loadChunk(x, z + 1);
		world.loadChunk(x, z);
	}

#end
#end
#No. 185926
#File: E:\bishe\1\WorldServer.java
#Comment:
    /**
     * Get the canary player manager wrapper for this dimension
     *
     * @return
     */

#Code:
    public CanaryPlayerManager getPlayerManager() {
        return K.getPlayerManager();
    }


#end
#end
#No. 185931
#File: E:\bishe\1\WorldTest.java
#Comment:
    /**
     * Test of addGenerator method, of class World.
     */

#Code:
    @Test
    public void testGenerators()
    {
        System.out.println("Add / remove generators");
        
        
    }

#end
#end
#No. 185933
#File: E:\bishe\1\WorldTypeHighlands.java
#Comment:
    /**
     * Gets the translation key for the name of this world type.
     */

#Code:
    @SideOnly(Side.CLIENT)
    @Override
    public String getTranslateName()
    {
        return this.wtname;
    }

#end
#end
#No. 185934
#File: E:\bishe\1\WorldTypeHighlands.java
#Comment:
    /**
     * Get the height to render the clouds for this world type
     * @return The height to render clouds at
     */

#Code:
    public float getCloudHeight()
    {
        return 212.0F;
    }

#end
#end
#No. 185935
#File: E:\bishe\1\WorldTypeHighlands.java
#Comment:
    /**
     * Creates the GenLayerBiome used for generating the world with the specified ChunkProviderSettings JSON String
     * *IF AND ONLY IF* this WorldType == WorldType.CUSTOMIZED.
     *
     *
     * @param worldSeed The world seed
     * @param parentLayer The parent layer to feed into any layer you return
     * @param chunkProviderSettingsJson The JSON string to use when initializing ChunkProviderSettings.Factory
     * @return A GenLayer that will return ints representing the Biomes to be generated, see GenLayerBiome
     */

#Code:
    public GenLayer getBiomeLayer(long worldSeed, GenLayer parentLayer, String chunkProviderSettingsJson)
    {
        GenLayer ret = new GenLayerBiomeHighlands(200L, parentLayer, this, chunkProviderSettingsJson);
        ret = GenLayerZoom.magnify(1000L, ret, 2);
        ret = new GenLayerBiomeEdge(1000L, ret);
        return ret;
    }



#end
#end
#No. 185937
#File: E:\bishe\1\WorldUtilities.java
#Comment:
	/**
	 * Checks if a position is inside a circle
	 *
	 * @param m_midXPos	middle x coordinate of circle
	 * @param m_midZPos	middle y coordinate of circle
	 * @param inPointX	point x value
	 * @param inPointZ	point y value
	 * @param inRadius	radius
	 * @return			true if inside, false if not
	 */

#Code:
	public static boolean isInCircle(double m_midXPos, double m_midZPos, double inPointX, double inPointZ, int inRadius)
	{
		double newX = (m_midXPos - inPointX);
		double newZ = (m_midZPos - inPointZ);
		return newX * newX + newZ * newZ < inRadius * inRadius;
	}

#end
#end
#No. 185938
#File: E:\bishe\1\WorldUtilities.java
#Comment:
	/**
	 * Gets the closest village to an entity
	 *
	 * @param inEntity	entity
	 * @return			village
	 */

#Code:
	public static Village getClosestVillage(Entity inEntity)
	{
		return inEntity.world.villages.getClosestVillage(MathHelper.floor(inEntity.locX), MathHelper.floor(inEntity.locY), MathHelper.floor(inEntity.locZ), 32);
	}

#end
#end
#No. 185939
#File: E:\bishe\1\WorldUtilities.java
#Comment:
	/**
	 * Gets the NMS entity from a bukkit entity.
	 *
	 * @param inEntity  The bukkit entity
	 * @return          NMS entity
	 */

#Code:
	public static EntityLiving getNMSEntity(org.bukkit.entity.LivingEntity inEntity)
	{
		return ((CraftLivingEntity)inEntity).getHandle();
	}

#end
#end
#No. 185940
#File: E:\bishe\1\WorldUtilities.java
#Comment:
	/**
	 * Gets the players which are nearby this entity.
	 *
	 * @param inEntity      The entity in which range the players should be
	 * @param inDistance    The maximum distance to check
	 * @return              List of found players
	 */

#Code:
	public static List<Player> getNearbyPlayers(org.bukkit.entity.Entity inEntity, double inDistance)
	{
		List<Player> players = new ArrayList<Player>();

		for(org.bukkit.entity.Entity entity : inEntity.getNearbyEntities(inDistance, inDistance, inDistance))
		{
			if(entity instanceof Player)
				players.add((Player)entity);
		}

		return players;
	}

#end
#end
#No. 185941
#File: E:\bishe\1\WorldUtilities.java
#Comment:
	/**
	 * Sends a packet to a player.
	 *
	 * @param inPlayer  The player to send the packet to
	 * @param inPacket  The packet to send
	 */

#Code:
	public static void sendPacketToPlayer(Player inPlayer, Packet inPacket)
	{
		((CraftPlayer)inPlayer).getHandle().playerConnection.sendPacket(inPacket);
	}

#end
#end
#No. 185942
#File: E:\bishe\1\WoTIdentity.java
#Comment:
	/**
	 * Generates a unique id from a {@link FreenetURI}. 
	 * It is simply a String representing it's routing key.
	 * We use this to identify identities and perform requests on the database. 
	 * 
	 * @param uri The requestURI of the Identity
	 * @return A string to uniquely identify an Identity
	 */

#Code:
	// TODO: Replace with IdentityID.constructFromURI
	public static String getIDFromURI (FreenetURI uri) {
		/* WARNING: This is a copy of the code of plugins.WoT.Identity. Freetalk is not allowed to have its own custom IDs, you cannot change
		 * this code here. */
		return Base64.encode(uri.getRoutingKey());
	}

#end
#end
#No. 185943
#File: E:\bishe\1\WoTIdentity.java
#Comment:
	/**
	 * Returns a Freetalk-address with a maximal content length.
	 * The format will be "nickname@abbreviated_routing_key...", i.e. 3 dots will be appended if the length exceeds the maximal length.
	 * The "@" and "..." are not included in the length computation - therefore its called maximal <b>content</b> length, not maximal length.
	 * If the nickname does not fit in the maximal length it is NOT abbreviated, the full nickname is returned then.
	 * 
	 * The reason for this weird definition is to allow easy computation of nicknames which have a shortest unique length...
	 * See {@link WoTIdentityManager.updateShortestUniqueNicknameCache} for how this is used.
	 */

#Code:
	protected String getFreetalkAddress(int maxContentLength) {
		final String address = getFreetalkAddress();
		
		if(getNickname().length() > maxContentLength)
			return getNickname();
		
		if(address.length() > maxContentLength) {
			return address.substring(0, maxContentLength+1) + "..."; // "+1" because the "@" does not count as length.
		}
		return address;
	}

#end
#end
#No. 185944
#File: E:\bishe\1\WoTIdentity.java
#Comment:
	/**
	 * Set the ID of the identity fetch in which this identity was last received from the WoT plugin to the given unique ID.
	 */

#Code:
	public synchronized void setLastReceivedFromWoT(long fetchID) {
		checkedActivate(1);
		mLastReceivedFromWoT = fetchID;
		storeWithoutCommit(); // TODO: Move store() calls outside of class identity
	}

#end
#end
#No. 185945
#File: E:\bishe\1\WoTIdentity.java
#Comment:
	/**
	 * Validates the nickname. If it is valid, nothing happens. If it is invalid, an exception is thrown which exactly describes what is
	 * wrong about the nickname.
	 * 
	 * @throws InvalidParameterException If the nickname is invalid, the exception contains a description of the problem as message. 
	 */

#Code:
	/* IMPORTANT: This code is duplicated in plugins.WoT.Identity.isNicknameValid().
	 * Please also modify it there if you modify it here */
	public static void validateNickname(String newNickname) throws InvalidParameterException {
		if(!StringValidityChecker.containsNoIDNBlacklistCharacters(newNickname)
		|| !StringValidityChecker.containsNoInvalidCharacters(newNickname)
		|| !StringValidityChecker.containsNoLinebreaks(newNickname)
		|| !StringValidityChecker.containsNoControlCharacters(newNickname)
		|| !StringValidityChecker.containsNoInvalidFormatting(newNickname)
		|| newNickname.contains("@")) // Must not be allowed since we use it to generate "identity@public-key-hash" unique nicknames
			throw new InvalidParameterException("Nickname contains invalid characters"); /* TODO: Tell the user which ones are invalid!!! */
		
		if(newNickname.length() == 0) throw new InvalidParameterException("Blank nickname.");
		if(newNickname.length() > 30) throw new InvalidParameterException("Nickname is too long, the limit is 30 characters.");
	}

#end
#end
#No. 185946
#File: E:\bishe\1\WoTIdentity.java
#Comment:
	/**
	 * You have to synchronize on this object before modifying the identity and calling storeAndCommit. 
	 */

#Code:
	public void storeAndCommit() {
		synchronized(Persistent.transactionLock(mDB)) {
			storeWithoutCommit();
			checkedCommit(this);
		}
	}




#end
#end
#No. 185953
#File: E:\bishe\1\WoTIdentityManager.java
#Comment:
	/**
	 * Get the number of trust values for a given identity with the ability to select which values should be counted.
	 * 
	 * Not synchronized, the involved identity might be deleted during the query - which is not really a problem.
	 * 
	 * @param selection Use 1 for counting trust values greater than or equal to zero, 0 for counting trust values exactly equal to 0 and -1 for counting trust
	 * 		values less than zero.
	 */

#Code:
	public int getReceivedTrustsCount(Identity trustee, int selection) throws Exception {
		SimpleFieldSet request = new SimpleFieldSet(true);
		request.putOverwrite("Message", "GetTrustersCount");
		request.putOverwrite("Identity", trustee.getID());
		request.putOverwrite("Context", Freetalk.WOT_CONTEXT);
		
		if(selection > 0)
			request.putOverwrite("Selection", "+");
		else if(selection == 0)
			request.putOverwrite("Selection", "0");
		else
			request.putOverwrite("Selection", "-");
		
		try {
			SimpleFieldSet answer = sendFCPMessageBlocking(request, null, "TrustersCount").params;
			return Integer.parseInt(answer.get("Value"));
		}
		catch(PluginNotFoundException e) {
			throw new WoTDisconnectedException();
		}
	}

#end
#end
#No. 185954
#File: E:\bishe\1\WoTIdentityManager.java
#Comment:
	/**
	 * Get a set of introduction puzzle IDs which the given own identity might solve.
	 * 
	 * The puzzle's data is not returned because when generating HTML for displaying the puzzles we must reference them with a IMG-tag and we cannot
	 * embed the data of the puzzles in the IMG-tag because embedding image-data has only recently been added to browsers and many do not support it yet.
	 * 
	 * @param ownIdentity The identity which wants to solve the puzzles.
	 * @param amount The amount of puzzles to request.
	 * @return A list of the IDs of the puzzles. The amount might be less than the requested amount and even zero if WoT has not downloaded puzzles yet.
	 * @throws Exception 
	 */

#Code:
	public List<String> getIntroductionPuzzles(WoTOwnIdentity ownIdentity, int amount) throws Exception {
		ArrayList<String> puzzleIDs = new ArrayList<String>(amount + 1);
		
		SimpleFieldSet params = new SimpleFieldSet(true);
		params.putOverwrite("Message", "GetIntroductionPuzzles");
		params.putOverwrite("Identity", ownIdentity.getID());
		params.putOverwrite("Type", "Captcha"); // TODO: Don't hardcode the String
		params.put("Amount", amount);
		
		try {
			SimpleFieldSet result = sendFCPMessageBlocking(params, null, "IntroductionPuzzles").params;
			
			for(int idx = 0; ; idx++) {
				String id = result.get("Puzzle" + idx);
				
				if(id == null || id.equals("")) /* TODO: Figure out whether the second condition is necessary */
					break;
				
				puzzleIDs.add(id);
			}
		}
		catch(PluginNotFoundException e) {
			Logger.error(this, "Getting puzzles failed", e);
		}
		
		return puzzleIDs;
	}

#end
#end
#No. 185955
#File: E:\bishe\1\WoTIdentityManager.java
#Comment:
	/**
	 * Fetches the identities with positive score from WoT and stores them in the database.
	 * @throws Exception 
	 */

#Code:
	private void fetchIdentities() throws Exception {		
		// parseIdentities() acquires and frees the WoTIdentityManager-lock for each identity to allow other threads to access the identity manager while the
		// parsing is in progress. Therefore, we do not take the lock for the whole execution of this function.
		synchronized(this) {
			if(mIdentityFetchInProgress)
				return;
			
			long now = CurrentTimeUTC.getInMillis();
			if((now - mLastIdentityFetchTime) < MINIMAL_IDENTITY_FETCH_DELAY)
				return;
			
			mIdentityFetchInProgress = true;
		}
		
		try {
			Logger.normal(this, "Requesting identities with positive score from WoT ...");
			SimpleFieldSet p1 = new SimpleFieldSet(true);
			p1.putOverwrite("Message", "GetIdentitiesByScore");
			p1.putOverwrite("Selection", "+");
			p1.putOverwrite("Context", Freetalk.WOT_CONTEXT);
			parseIdentities(sendFCPMessageBlocking(p1, null, "Identities").params, false);
		}
		finally {
			synchronized(this) {
				mIdentityFetchInProgress = false;
				// Disable garbage collection for the next iteration since importing failed
				mLastIdentityFetchID = 0;
			}
		}
	
			
		// We usually call garbageCollectIdentities() after calling this function, it updates the cache already...
		// if(mShortestUniqueNicknameCacheNeedsUpdate)
		//	updateShortestUniqueNicknameCache();
	}

#end
#end
#No. 185956
#File: E:\bishe\1\WoTIdentityManager.java
#Comment:
	/**
	 * Fetches the own identities with positive score from WoT and stores them in the database.
	 * @throws Exception 
	 */

#Code:
	private void fetchOwnIdentities() throws Exception {
		// parseIdentities() acquires and frees the WoTIdentityManager-lock for each identity to allow other threads to access the identity manager while the
		// parsing is in progress. Therefore, we do not take the lock for the whole execution of this function.
		synchronized(this) {
			if(mOwnIdentityFetchInProgress)
				return;

			long now = CurrentTimeUTC.getInMillis();
			if((now - mLastOwnIdentityFetchTime) < MINIMAL_OWN_IDENTITY_FETCH_DELAY)
				return;
			
			mOwnIdentityFetchInProgress = true;
		}
		
		try {
			Logger.normal(this, "Requesting own identities from WoT ...");
			SimpleFieldSet p2 = new SimpleFieldSet(true);
			p2.putOverwrite("Message","GetOwnIdentities");
			parseIdentities(sendFCPMessageBlocking(p2, null, "OwnIdentities").params, true);
		}
		finally {
			synchronized(this) {
				mOwnIdentityFetchInProgress = false;
				// Disable garbage collection for the next iteration since importing failed
				mLastOwnIdentityFetchID = 0;
			}
		}
		
		// We usually call garbageCollectIdentities() after calling this function, it updates the cache already...
		// if(mShortestUniqueNicknameCacheNeedsUpdate)
		//	updateShortestUniqueNicknameCache();
	}

#end
#end
#No. 185957
#File: E:\bishe\1\WoTIdentityManager.java
#Comment:
	/**
	 * Called by this WoTIdentityManager after a new WoTIdentity has been stored to the database and before committing the transaction.
	 * 
	 * You have to lock this WoTIdentityManager, the PersistentTaskManager and the database before calling this function.
	 * 
	 * @param newIdentity
	 * @throws Exception If adding the Freetalk context to the identity in WoT failed.
	 */

#Code:
	private void onNewOwnIdentityAdded(OwnIdentity identity) {
		Logger.normal(this, "onNewOwnIdentityAdded " + identity);
		
		WoTOwnIdentity newIdentity = (WoTOwnIdentity)identity;
		
		// TODO: Do after an own message is posted. I have not decided at which place to do this :|
		try {
			addFreetalkContext(newIdentity);
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
			
		PersistentTask introductionTask = new IntroduceIdentityTask((WoTOwnIdentity)newIdentity);
		mFreetalk.getTaskManager().storeTaskWithoutCommit(introductionTask);
		
		doNewOwnIdentityCallbacks(newIdentity);
		onShouldFetchStateChanged(newIdentity, false, true);
	}

#end
#end
#No. 185958
#File: E:\bishe\1\WoTIdentityManager.java
#Comment:
	/**
	 * Deletes all identities whose mLastReceivedFromWoT field does not match the ID of the last fetch (which is stored in mLast(Own)IdentityFetchID)
	 */

#Code:
	@SuppressWarnings("unchecked")
	private void garbageCollectIdentities(boolean ownIdentities) {
		final MessageManager messageManager = mFreetalk.getMessageManager();
		final PersistentTaskManager taskManager = mFreetalk.getTaskManager();
		
		synchronized(this) {
			// We must abort garbage collection if an identity fetch is in progress since the mLast(Own)IdentityFetchID which we use to delete
			// identities is updated AFTER the fetch has succeeded but the IDs which are stored in the identities are updated sequentially
			// in single transactions. So if we GC'ed while a fetch was in progress, we would delete lots of identities because their fetch ID 
			// would mismatch mLast(Own)IdentityFetchID
			if(mIdentityFetchInProgress || mOwnIdentityFetchInProgress)
				return;
			
			if((ownIdentities && mLastOwnIdentityFetchID == 0) || (!ownIdentities && mLastIdentityFetchID == 0))
				return;

			long acceptID = ownIdentities ? mLastOwnIdentityFetchID : mLastIdentityFetchID;

			Query q = db.query();
			if(ownIdentities)
				q.constrain(WoTOwnIdentity.class);
			else {
				q.constrain(WoTIdentity.class);
				q.constrain(WoTOwnIdentity.class).not();
			}
			
			q.descend("mLastReceivedFromWoT").constrain(acceptID).not();
			ObjectSet<WoTIdentity> result = q.execute();

			for(WoTIdentity identity : result) {
				identity.initializeTransient(mFreetalk);
				if(logDEBUG) Logger.debug(this, "Garbage collecting identity " + identity);
				deleteIdentity(identity, messageManager, taskManager);
			}

			if(mShortestUniqueNicknameCacheNeedsUpdate)
				updateShortestUniqueNicknameCache();
		}
	}

#end
#end
#No. 185959
#File: E:\bishe\1\WoTIdentityManager.java
#Comment:
	/**
	 * Checks for duplicate identity objects and deletes duplicates if they exist.
	 * I have absolutely NO idea why Bombe does happen to have a duplicate identity, I see no code path which could cause this.
	 * TODO: Get rid of this function if nobody reports a duplicate for some time - the function was added at 2011-01-10
	 */

#Code:
	private synchronized void deleteDuplicateIdentities() {
		WoTMessageManager messageManager = mFreetalk.getMessageManager();
		PersistentTaskManager taskManager = mFreetalk.getTaskManager();
		
		synchronized(messageManager) {
		synchronized(taskManager) {
		synchronized(Persistent.transactionLock(db)) {
			try {
				HashSet<String> deleted = new HashSet<String>();

				Logger.debug(this, "Searching for duplicate identities ...");

				for(WoTIdentity identity : getAllIdentities()) {
					Query q = db.query();
					q.constrain(WoTIdentity.class);
					q.descend("mID").constrain(identity.getID());
					q.constrain(identity).identity().not();
					ObjectSet<WoTIdentity> duplicates = new Persistent.InitializingObjectSet<WoTIdentity>(mFreetalk, q);
					
					for(WoTIdentity duplicate : duplicates) {
						if(deleted.contains(duplicate.getID()) == false) {
							Logger.error(duplicate, "Deleting duplicate identity " + duplicate.getRequestURI());
							deleteIdentity(duplicate, messageManager, taskManager);
						}
					}
					deleted.add(identity.getID());
				}
				Persistent.checkedCommit(db, this);

				Logger.debug(this, "Finished searching for duplicate identities.");
			}
			catch(RuntimeException e) {
				Persistent.checkedRollback(db, this, e);
			}
		}
		}
		}
	}

#end
#end
#No. 185960
#File: E:\bishe\1\WoTMessageFetcher.java
#Comment:
	/**
	 * Checks the database for unfetched messages and starts message fetches until this fetches is running the maximum of MAX_PARALLEL_MESSAGE_FETCH_COUNT fetches.
	 * Does not abort fetches which were started by previous calls to this function: We use a finite retry count for each started fetch so the node should
	 * call onFailure / onSuccess after a finite amount of time which causes not working message fetches to be aborted.
	 * 
	 * You have to synchronize on this <code>WoTMessageFetcher</code> when using this function.
	 */

#Code:
	private void fetchMessages() {
		final int fetchCount = fetchCount();
		
		if(fetchCount >= MAX_PARALLEL_MESSAGE_FETCH_COUNT) { // Check before we do the expensive database query.
			if(logMINOR) Logger.minor(this, "Got " + fetchCount + "fetches, not fetching any more.");
			return;
		}
		
		if(logMINOR) Logger.minor(this, "Trying to start more message fetches, amount of fetches now: " + fetchCount);
		
		synchronized(mIdentityManager) { // TODO: Get rid of this lock by making anyOwnIdentityWantsMessagesFrom use a cache
		synchronized(mMessageManager) { 
			/* TODO: Obtain WoTMessageLists only, not all. */
			final ObjectSet<MessageList.MessageReference> notDownloadedMessages = mMessageManager.notDownloadedMessageIterator();
			
			for(MessageList.MessageReference ref : notDownloadedMessages) {
				try {
					// TODO: This should maybe be done inside the database query
					if(mIdentityManager.anyOwnIdentityWantsMessagesFrom(ref.getMessageList().getAuthor()))
						fetchMessage(ref);
				}
				catch(Exception e) {
					Logger.error(this, "Error while trying to fetch message " + ref.getURI(), e);
				}

				if(fetchCount() >= MAX_PARALLEL_MESSAGE_FETCH_COUNT)
					break;
			}
		}
		}
	}

#end
#end
#No. 185961
#File: E:\bishe\1\WoTMessageFetcher.java
#Comment:
	/**
	 * Starts a fetch for the given message.
	 * Uses a finite amount of retries, so the fetch will definitely finish in a finite amount of time.
	 * 
	 * You have to synchronize on this <code>WoTMessageFetcher</code> when using this function.
	 */

#Code:
	private void fetchMessage(MessageList.MessageReference ref) throws FetchException {
		final FreenetURI uri = ref.getURI(); 
		
		if(mMessages.add(uri) == false)// The message is already being fetched.
			return;

		try {
			FetchContext fetchContext = mClient.getFetchContext();
			// We MUST use a finite amount of retries because this function is specified to do so and the callers rely on that.
			fetchContext.maxSplitfileBlockRetries = 2;
			fetchContext.maxNonSplitfileRetries = 2;
			fetchContext.maxOutputLength = WoTMessageXML.MAX_XML_SIZE; // TODO: fetch() also takes a maxSize parameter, why?
			ClientGetter g = mClient.fetch(uri, WoTMessageXML.MAX_XML_SIZE, requestClient, this, fetchContext, RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS);
			addFetch(g);
			mMessageLists.put(g, ref.getMessageList().getID());
			Logger.normal(this, "Trying to fetch message from " + uri);
		}
		catch(RuntimeException e) {
			mMessages.remove(uri);
			throw e;
		}
	}



#end
#end
#No. 185965
#File: E:\bishe\1\WoTMessageList.java
#Comment:
	/**
	 * Get the USK URI of a message list with the given identity and index.
	 * @param identity
	 * @param index
	 * @return
	 */

#Code:
	public static FreenetURI generateURI(WoTIdentity identity, long index) {
		return assembleURI(identity.getRequestURI(), index);
	}

#end
#end
#No. 185966
#File: E:\bishe\1\WoTMessageListXMLTest.java
#Comment:
		/* Now we check every message reference we receive from the decoded XML. For each seen [message, board] pair we remove that
		 * pair from the messageBoards table. If the table is empty at the end, the XML decoding has not dropped any of the pairs */

#Code:
		for(MessageList.MessageReference ref : decodedList) {
			WoTOwnMessage message = (WoTOwnMessage)mMessageManager.getOwnMessage(ref.getMessageID());
			assertTrue("A board was listed in the message list multiple times: " + ref.getBoard().getName(),
					mMessageBoards.containsElement(message.getID(), ref.getBoard().getName()));
			
			mMessageBoards.removeElement(message.getID(), ref.getBoard().getName());
		}



#end
#end
#No. 185970
#File: E:\bishe\1\WoTMessageManager.java
#Comment:
	/**
	 * ATTENTION: Due to a db4o bug you must check whether the messages are really not inserted by using testFreenetURIisNull() on them
	 * TODO: Remove this workaround notice for the db4o bug as soon as we are sure that it does not happen anymore.
	 */

#Code:
	public synchronized ObjectSet<WoTOwnMessage> getNotInsertedOwnMessages() {
		final Query query = db.query();
		query.constrain(WoTOwnMessage.class);
		query.descend("mFreenetURI").constrain(null).identity();
		return new Persistent.InitializingObjectSet<WoTOwnMessage>(mFreetalk, query);
	}

#end
#end
#No. 185971
#File: E:\bishe\1\WoTMessageManager.java
#Comment:
	/**
	 * Returns <code>OwnMessageList</code> objects which are marked as not inserted and not being inserted.
	 */

#Code:
	public synchronized ObjectSet<WoTOwnMessageList> getNotInsertedOwnMessageLists() {
		Query query = db.query();
		query.constrain(WoTOwnMessageList.class);
		query.descend("mWasInserted").constrain(false);
		query.descend("mIsBeingInserted").constrain(false);
		return new Persistent.InitializingObjectSet<WoTOwnMessageList>(mFreetalk, query);
	}

#end
#end
#No. 185972
#File: E:\bishe\1\WoTMessageManager.java
#Comment:
	/**
	 * Get the highest index of a not fetched message list of the given identity.
	 * 
	 * Notice that this uses a cached number from the IdentityStatistics object and it is possible that there are message lists with
	 * higher index numbers which HAVE been fetched already. This function is for being used in scheduling message list fetches so this is
	 * not a problem.
	 */

#Code:
	public synchronized long getUnavailableNewMessageListIndex(Identity identity) {
		try {
			return getIdentityStatistics(identity).getIndexOfLatestAvailableMessageList() + 1;
		} catch(NoSuchObjectException e) {
			return 0;
		}
	}

#end
#end
#No. 185973
#File: E:\bishe\1\WoTMessageManager.java
#Comment:
	/**
	 * Get a hint for the highest index of a not fetched message list of the given identity.
	 * In the current implementation, this just calls {@link getUnavailableNewMessageListIndex}
	 * 
	 * Notice that this uses a cached number from the IdentityStatistics object and it is possible that there are message lists with
	 * higher index numbers which HAVE been fetched already. This function is for being used in scheduling message list fetches so this is
	 * not a problem.
	 */

#Code:
	public long getNewMessageListIndexEditionHint(Identity identity) {
		// TODO: Implement storage of edition hints in message lists.
		return getUnavailableNewMessageListIndex(identity);
	}

#end
#end
#No. 185974
#File: E:\bishe\1\WoTMessageManager.java
#Comment:
	/**
	 * Get a hint for the lowest index of a not fetched message list of the given identity.
	 * 
	 * Notice that this uses a cached number from the IdentityStatistics object and it is possible that there are message lists with
	 * lower index numbers which HAVE been fetched already. This function is for being used in scheduling message list fetches so this is
	 * not a problem.
	 */

#Code:
	public synchronized long getUnavailableOldMessageListIndex(Identity identity) throws NoSuchMessageListException {
		long unavailableIndex; 
		
		try {
			unavailableIndex = getIdentityStatistics(identity).getIndexOfOldestAvailableMessageList() - 1;
		} catch(NoSuchObjectException e) {
			unavailableIndex = 0;
		}
		
		if(unavailableIndex < 0)
			throw new NoSuchMessageListException("");
		
		return unavailableIndex;
	}

#end
#end
#No. 185976
#File: E:\bishe\1\WoTMessageRating.java
#Comment:
	/**
	 * @throws IllegalArgumentException If the addition of the value would cause the trust value limit to be exceeded.
	 */

#Code:
	private void addValueToWoTTrust(final byte value) throws NoSuchIdentityException {
		final WoTIdentityManager identityManager = mFreetalk.getIdentityManager();
		final WoTOwnIdentity rater = (WoTOwnIdentity)getRater();
		final WoTIdentity messageAuthor = (WoTIdentity)getMessageAuthor();
		
		byte trustValue;
		
		try {
			trustValue = identityManager.getTrust(rater, messageAuthor);
		} catch(NoSuchIdentityException e) {
			throw e;
		} catch (NotTrustedException e) {
			trustValue = 0;
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
					
		trustValue += value;
		
		int signum = Integer.signum(trustValue);
		
		if(trustValue*signum > 100)
			throw new IllegalArgumentException("The rating cannot be assigned because the limit of +/- 100 for trust values would be exceeded.");		
		
		try {
			identityManager.setTrust(rater, messageAuthor, trustValue, "Freetalk web interface");
		} catch(NoSuchIdentityException e) {
			throw e;
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

#end
#end
#No. 185977
#File: E:\bishe\1\WoTMessageRating.java
#Comment:
	/**
	 * @param undoTrustChange Whether to undo the application of the trust value of this rating to WoT. Must not be set to true during automatic operation
	 * 		because it can fail if the user has manually adjusted the trust value.
	 */

#Code:
	protected void deleteAndCommit(boolean undoTrustChange) {
		synchronized(Persistent.transactionLock(mDB)) {
			if(logDEBUG) Logger.debug(this, "Deleting rating " + this);
			if(undoTrustChange) {
			try {
				substractValueFromWoTTrust();
			} catch(NoSuchIdentityException e) {
				throw new RuntimeException(e);
			}
			}
		
			try {
				super.deleteWithoutCommit();
				super.checkedCommit(this);
			} catch(RuntimeException e1) {
				try {
					addValueToWoTTrust();
				} catch(NoSuchIdentityException e) {
					Logger.error(this, "Deleting the MessageRating failed and re-adding the trust value also failed because the identity was deleted already.", e);
				} catch(RuntimeException e2) {
					super.checkedRollbackAndThrow(
					 new RuntimeException("Fatal error: The rating was removed from WoT, deleting it in Freetalk failed and restoring the rating in WoT also failed!" +
							"This means that the rating still appears in Freetalk but the trust value of the identity does not contain it anymore." +
							"Please manually remove the rating from the trust value of the identity! The original error was: " + e1 + " and the second " + e2)
					);
				}
				super.checkedRollbackAndThrow(e1);
			}
		}
	}

#end
#end
#No. 185978
#File: E:\bishe\1\WoTNewMessageListFetcher.java
#Comment:
	/**
	 * Subscribes to the {@link WoTMessageListUSK} of the given identity, using the latest unavailable message list index.
	 * If the identity is already being fetched, logs an error and does nothing.
	 */

#Code:
	private synchronized void fetch(WoTIdentity identity) throws Exception {
		if(mRequests.get(identity.getID()) != null) {
			Logger.error(this, "Fetch already exists for identity " + identity);
			return;
		}

		final USK usk;
		final long editionHint;
		
		synchronized(mMessageManager) { // Don't acquire the lock twice
			usk = USK.create(WoTMessageList.generateURI(identity, mMessageManager.getUnavailableNewMessageListIndex(identity)));
			editionHint = mMessageManager.getNewMessageListIndexEditionHint(identity);
		}
			
		final USKRetriever retriever = fetch(usk);
		mRequests.put(identity.getID(), retriever);
		updateEditionHint(retriever, editionHint);
	}

#end
#end
#No. 185979
#File: E:\bishe\1\WoTNewMessageListFetcher.java
#Comment:
	/**
	 * Has to be called when the edition hint of the given identity was updated. Tells the USKManager about the new hint.
	 * @throws Exception 
	 */

#Code:
	private synchronized void updateEditionHint(String identityID) throws Exception {
		try {
			final WoTIdentity identity = mIdentityManager.getIdentity(identityID);
			final USKRetriever retriever = mRequests.get(identityID);
				
			if(retriever == null)
				throw new NoSuchIdentityException("updateEdtitionHint() called for an identity which is not being fetched: " + identityID);

			final long editionHint = mMessageManager.getNewMessageListIndexEditionHint(identity);
				
			if(logDEBUG) Logger.debug(this, "Updating edition hint to " + editionHint + " for " + identityID);
			updateEditionHint(retriever, editionHint);
		} catch (NoSuchIdentityException e) {
			Logger.error(this, "Updating edition hint failed, the identity was deleted already.", e);
		}
	}

#end
#end
#No. 185980
#File: E:\bishe\1\WoTNewMessageListFetcher.java
#Comment:
	/**
	 * Fetches the given USK and returns the new USKRetriever. Does not check whether there is already a fetch for that USK.
	 */

#Code:
	private USKRetriever fetch(USK usk) throws MalformedURLException {
		FetchContext fetchContext = mClient.getFetchContext();
		fetchContext.maxSplitfileBlockRetries = -1; // retry forever
		fetchContext.maxNonSplitfileRetries = -1; // retry forever
		fetchContext.maxOutputLength = WoTMessageListXML.MAX_XML_SIZE;
		if(logDEBUG) Logger.debug(this, "Subscribing to WoTMessageList queue " + usk); 
		return mUSKManager.subscribeContent(usk, this, true, fetchContext, RequestStarter.UPDATE_PRIORITY_CLASS, mRequestClient);
	}

#end
#end
#No. 185981
#File: E:\bishe\1\WoTNewMessageListFetcher.java
#Comment:
	/**
	 * Stops all running requests.
	 */

#Code:
	public synchronized void stop() {
		if(logDEBUG) Logger.debug(this, "Trying to stop all requests");
		
		mTicker.shutdown();
		
		USKRetriever[] retrievers = mRequests.values().toArray(new USKRetriever[mRequests.size()]);		
		int counter = 0;		 
		for(USKRetriever r : retrievers) {
			r.cancel(null, mClientContext);
			mUSKManager.unsubscribeContent(r.getOriginalUSK(), r, true);
			 ++counter;
		}
		mRequests.clear();
		
		if(logDEBUG) Logger.debug(this, "Stopped " + counter + " current requests");
	}

#end
#end
#No. 185982
#File: E:\bishe\1\WoTNewMessageListFetcher.java
#Comment:
	/**
	 * Called by the {@link IdentityManager} when the should-fetch state of an identity changed.
	 * This happens when a new identity is added or an existing one is deleted.
	 * 
	 * Schedules start-fetch/abort-fetch commands.
	 */

#Code:
	@Override public void onShouldFetchStateChanged(
			Identity messageAuthor, boolean oldShouldFetch, boolean newShouldFetch) {
		
		if(oldShouldFetch == newShouldFetch) {
			throw new IllegalArgumentException("oldShouldFetch==newShouldFetch==" + newShouldFetch);
		}
		
		if(newShouldFetch == true) {
			storeStartFetchCommandWithoutCommit((WoTIdentity)messageAuthor);
		} else {
			storeAbortFetchCommandWithoutCommit((WoTIdentity)messageAuthor);
		}
	}

#end
#end
#No. 185983
#File: E:\bishe\1\WoTNewMessageListFetcher.java
#Comment:
	/**
	 * Called when a {@link WoTMessageList} was successfully fetched.
	 */

#Code:
	@Override public void onFound(USK origUSK, long edition, FetchResult result) {
		final FreenetURI uri = origUSK.getURI().setSuggestedEdition(edition);
		
		Logger.normal(this, "Fetched WoTMessageList: " + uri);

		Bucket bucket = null;
		InputStream inputStream = null;
		
		try {
			bucket = result.asBucket();
			inputStream = bucket.getInputStream();
			
			synchronized(mIdentityManager) {
				final WoTIdentity identity = (WoTIdentity)mIdentityManager.getIdentityByURI(uri);
				
				synchronized(mMessageManager) {
					try {
						WoTMessageList list = mXML.decode(mFreetalk, identity, uri, inputStream);
						mMessageManager.onMessageListReceived(list);
					}
					catch (Exception e) {
						Logger.error(this, "Parsing failed for MessageList " + uri, e);
						mMessageManager.onMessageListFetchFailed(identity, uri, FetchFailedMarker.Reason.ParsingFailed);
					}
				}
			}
		}

#end
#end
#No. 185984
#File: E:\bishe\1\WoTOldMessageListFetcher.java
#Comment:
	/**
	 * Starts fetches of MessageLists from MAX_PARALLEL_MESSAGELIST_FETCH_COUNT different identities. For each identity, it is attempted to start a fetch
	 * of the latest old message list.
	 * 
	 * The identities are put in a LRU queue, so in the next iteration, fetches will not be allowed from identities of the previous iteration.
	 */

#Code:
	private synchronized void fetchMessageLists() {
		final int fetchCount = fetchCount();
		
		if(fetchCount >= MAX_PARALLEL_MESSAGELIST_FETCH_COUNT) { // Check before we do the expensive database query.
			if(logDEBUG) Logger.debug(this, "Got " + fetchCount + " fetches, not fetching any more.");
			return;
		}
		
		if(logDEBUG) Logger.debug(this, "Trying to start more message list fetches, amount of fetches now: " + fetchCount);
		
		fetchMessageListsCore();
		
		if(fetchCount() == 0 && !mIdentities.isEmpty()) {
			synchronized(mIdentities) {
				mIdentities.clear();
				fetchMessageListsCore();
			}
		}
	}





#end
#end
#No. 185988
#File: E:\bishe\1\WoTOwnMessage.java
#Comment:
	/**
	 * Generate the insert URI for a message.
	 */

#Code:
	@Override public synchronized FreenetURI getInsertURI() {
		return FreenetURI.EMPTY_CHK_URI;
	}

}
}



#end
#end
#No. 185990
#File: E:\bishe\1\WoTOwnMessageList.java
#Comment:
	/**
	 * Returns true if the XML of this message list fits into a single SSK block.
	 */

#Code:
	@Override protected boolean fitsIntoContainer() {
		if(!super.fitsIntoContainer())
			return false;
	
		if(getMessageCount() > 5)
			return false;
		
		// TODO: Implement a real fitsIntoContainer which compresses the XML and checks the size. (Bug 4041) 
		return true;
	}

}
}

#end
#end
#No. 185992
#File: E:\bishe\1\WpadProxySearchStrategy.java
#Comment:
  /*************************************************************************
   * Loads the proxy settings from a PAC file. The location of the PAC file is
   * determined automatically.
   * 
   * @return a configured ProxySelector, null if none is found.
   * @throws ProxyException
   *           on error.
   ************************************************************************/

#Code:

  @Override
  public ProxySelector getProxySelector() throws ProxyException {
    try {
      Logger.log(getClass(), LogLevel.TRACE, "Using WPAD to find a proxy");

      String pacScriptUrl = detectScriptUrlPerDHCP();
      if (pacScriptUrl == null) {
        pacScriptUrl = detectScriptUrlPerDNS();
      }
      if (pacScriptUrl == null) {
        return null;
      }
      Logger.log(getClass(), LogLevel.TRACE, "PAC script url found: {0}", pacScriptUrl);
      return ProxyUtil.buildPacSelectorForUrl(pacScriptUrl);
    } catch (IOException e) {
      Logger.log(getClass(), LogLevel.ERROR, "Error during WPAD search.", e);
      throw new ProxyException(e);
    }
  }

#end
#end
#No. 185993
#File: E:\bishe\1\WpadProxySearchStrategy.java
#Comment:
  /*************************************************************************
   * Gets the printable name of the search strategy.
   * 
   * @return the printable name of the search strategy
   ************************************************************************/

#Code:

  @Override
  public String getName() {
    return "wpad";
  }

#end
#end
#No. 185994
#File: E:\bishe\1\WpadProxySearchStrategy.java
#Comment:
  /*************************************************************************
   * Loads the settings and stores them in a properties map.
   * 
   * @return the settings.
   ************************************************************************/

#Code:

  public Properties readSettings() {
    try {
      String pacScriptUrl = detectScriptUrlPerDHCP();
      if (pacScriptUrl == null) {
        pacScriptUrl = detectScriptUrlPerDNS();
      }
      if (pacScriptUrl == null) {
        return null;
      }
      Properties result = new Properties();
      result.setProperty("url", pacScriptUrl);
      return result;
    } catch (IOException e) {
      // Ignore and return empty properties.
      return new Properties();
    }
  }

#end
#end
#No. 185995
#File: E:\bishe\1\WpadProxySearchStrategy.java
#Comment:
  /*************************************************************************
   * Uses DNS to find the script URL. Attention: this detection method is known
   * to have some severe security issues.
   * 
   * @return the URL, null if not found.
   ************************************************************************/

#Code:

  private String detectScriptUrlPerDNS() throws IOException {

    String fqdn = InetAddress.getLocalHost().getCanonicalHostName();
    if (fqdn.equalsIgnoreCase("localhost") || fqdn.length() == 0 || Character.isDigit(fqdn.charAt(0))) {
      return null;
    }

    Logger.log(getClass(), LogLevel.TRACE, "Searching per DNS guessing.");

    String[] fqdnParts = fqdn.split("\\.");
    for (int i = 0; i < fqdnParts.length; i++) {
      // Build URL
      StringBuilder stringBuilder = new StringBuilder("http://wpad");
      for (int j = i + 1; j < fqdnParts.length; j++) {
        stringBuilder.append('.');
        stringBuilder.append(fqdnParts[j]);
      }
      stringBuilder.append("/wpad.dat");

      // Try to connect to URL
      try {
        URL lookupURL = new URL(stringBuilder.toString());
        Logger.log(getClass(), LogLevel.TRACE, "Trying url: {0}", lookupURL);

        HttpURLConnection con = (HttpURLConnection) lookupURL.openConnection(Proxy.NO_PROXY);
        con.setInstanceFollowRedirects(true);
        con.setRequestProperty("accept", "application/x-ns-proxy-autoconfig");
        if (con.getResponseCode() == 200) {
          return lookupURL.toString();
        }
        con.disconnect();
      } catch (UnknownHostException e) {
        Logger.log(getClass(), LogLevel.DEBUG, "Not available!");
        // Not a real error, try next address
      }
    }

    return null;
  }

#end
#end
#No. 185996
#File: E:\bishe\1\WpadProxySearchStrategy.java
#Comment:
  /*************************************************************************
   * Uses DHCP to find the script URL.
   * 
   * @return the URL, null if not found.
   ************************************************************************/

#Code:

  private String detectScriptUrlPerDHCP() {
    Logger.log(getClass(), LogLevel.DEBUG, "Searching per DHCP not supported yet.");
    // TODO Rossi 28.04.2009 Not implemented yet.
    return null;
  }

#end
#end
#No. 185998
#File: E:\bishe\1\WpadProxySearchStrategyWithDHPC.java
#Comment:
	/*************************************************************************
	 * Loads the proxy settings from a PAC file. The location of the PAC file is
	 * determined automatically.
	 * 
	 * @return a configured ProxySelector, null if none is found.
	 * @throws ProxyException
	 *             on error.
	 ************************************************************************/

#Code:

	@Override
	public ProxySelector getProxySelector() throws ProxyException {
		try {
			Logger.log(getClass(), LogLevel.TRACE, "Using WPAD to find a proxy");

			String pacScriptUrl = detectScriptUrlPerDHCP();
			if (pacScriptUrl == null) {
				pacScriptUrl = detectScriptUrlPerDNS();
			}
			if (pacScriptUrl == null) {
				return null;
			}
			Logger.log(getClass(), LogLevel.TRACE, "PAC script url found: {0}", pacScriptUrl);
			return ProxyUtil.buildPacSelectorForUrl(pacScriptUrl);
		} catch (IOException e) {
			Logger.log(getClass(), LogLevel.ERROR, "Error during WPAD search.", e);
			throw new ProxyException(e);
		}
	}

#end
#end
#No. 185999
#File: E:\bishe\1\WpadProxySearchStrategyWithDHPC.java
#Comment:
	/*************************************************************************
	 * Gets the printable name of the search strategy.
	 * 
	 * @return the printable name of the search strategy
	 ************************************************************************/

#Code:

	@Override
	public String getName() {
		return "wpad";
	}

#end
#end
#No. 186000
#File: E:\bishe\1\WpadProxySearchStrategyWithDHPC.java
#Comment:
	/*************************************************************************
	 * Loads the settings and stores them in a properties map.
	 * 
	 * @return the settings.
	 ************************************************************************/

#Code:

	public Properties readSettings() {
		try {
			String pacScriptUrl = detectScriptUrlPerDHCP();
			if (pacScriptUrl == null) {
				pacScriptUrl = detectScriptUrlPerDNS();
			}
			if (pacScriptUrl == null) {
				return null;
			}
			Properties result = new Properties();
			result.setProperty("url", pacScriptUrl);
			return result;
		} catch (IOException e) {
			// Ignore and return empty properties.
			return new Properties();
		}
	}

#end
#end
#No. 186001
#File: E:\bishe\1\WpadProxySearchStrategyWithDHPC.java
#Comment:
	/*************************************************************************
	 * Uses DNS to find the script URL. Attention: this detection method is
	 * known to have some severe security issues.
	 * 
	 * @return the URL, null if not found.
	 ************************************************************************/

#Code:

	private String detectScriptUrlPerDNS() throws IOException {
		String result = null;
		String fqdn = InetAddress.getLocalHost().getCanonicalHostName();

		Logger.log(getClass(), LogLevel.TRACE, "Searching per DNS guessing.");

		int index = fqdn.indexOf('.');
		while (index != -1 && result == null) {
			fqdn = fqdn.substring(index + 1);

			// if we are already on TLD level then escape
			if (fqdn.indexOf('.') == -1) {
				break;
			}

			// Try to connect to URL
			try {
				URL lookupURL = new URL("http://wpad." + fqdn + "/wpad.dat");
				Logger.log(getClass(), LogLevel.TRACE, "Trying url: {0}", lookupURL);

				HttpURLConnection con = (HttpURLConnection) lookupURL.openConnection(Proxy.NO_PROXY);
				con.setInstanceFollowRedirects(true);
				con.setRequestProperty("accept", "application/x-ns-proxy-autoconfig");
				if (con.getResponseCode() == 200) {
					result = lookupURL.toString();
				}
				con.disconnect();
			} catch (UnknownHostException e) {
				Logger.log(getClass(), LogLevel.DEBUG, "Not available!");
				// Not a real error, try next address
			}

			index = fqdn.indexOf('.');
		}

		return result;
	}

#end
#end
#No. 186002
#File: E:\bishe\1\WpadProxySearchStrategyWithDHPC.java
#Comment:
	/*************************************************************************
	 * Uses DHCP to find the script URL.
	 * 
	 * @return the URL, null if not found.
	 ************************************************************************/

#Code:

	private String detectScriptUrlPerDHCP() {
		Logger.log(getClass(), LogLevel.DEBUG, "Searching per DHCP not supported yet.");
		// TODO Rossi 28.04.2009 Not implemented yet.
		return null;
	}

#end
#end
#No. 186006
#File: E:\bishe\1\WPCore.java
#Comment:
	/**
	 * Get path to Windows Phone SDK root folder.
	 * 
	 * @return path to Windows Phone SDK root folder or <code>null</code> if SDK
	 *         cannot be retrieved from preferences or detected from Windows
	 *         registry.
	 * @throws CoreException 
	 */

#Code:
	public static String getSDKLocation() throws CoreException {
		String sdkLocation = Platform.getPreferencesService().getString(
				THYM_UI_ID, WPConstants.WINDOWS_PHONE_SDK_LOCATION_PREF, null,
				null);
		if (sdkLocation == null) {
			File location = detectSDK();
			if (location != null && location.exists()) {
				sdkLocation = location.getAbsolutePath();
				IEclipsePreferences prefs = InstanceScope.INSTANCE
						.getNode(THYM_UI_ID);
				prefs.put(WPConstants.WINDOWS_PHONE_SDK_LOCATION_PREF,
						sdkLocation);
			}
		}
		return sdkLocation;
	}

#end
#end
#No. 186007
#File: E:\bishe\1\WpException.java
#Comment:
/**
 * Class for all exceptions thrown from the workpool package.
 *
 * @author Keerthi Singri
 * @since M8, 15 August, 2011
 */

#Code:
public class WpException
   extends BaseException
{
   private static final long serialVersionUID = 12322345L;

   /**
    * Create a new instance from the specified cause.
    * @param message
    */
   public WpException(String message)
   {
      super(message);
   }

   /**
    * @param cause
    */
   public WpException(Throwable cause) {
      super(cause);
   }

}


#end
#end
#No. 186009
#File: E:\bishe\1\WrapAsyncTask.java
#Comment:
/**
 * client send local ip & port to server.
 */

#Code:
class SendPeerInfoAsyncTask extends
		AsyncTask<String, Void, Boolean> {

	Context context;

	public SendPeerInfoAsyncTask(Context context) {
		this.context = context;
	}

	@Override
	protected Boolean doInBackground(String... params) {
		assert (params.length == 2);		
		String host = params[0];
		int port = Integer.parseInt(params[1]);
		if (Utility.sendPeerInfo(host, port))
			return Boolean.TRUE;
		else
			return Boolean.FALSE;
	}

	@Override
	protected void onPostExecute(Boolean result) {
		Log.d("SendPeerInfoAsyncTask", "onPostExecute end.");
		String tips = "";
		if (result.booleanValue())
			tips = "Send peer's info ok.";
		else
			tips = "Send peer's info failed.";
		Toast toast = Toast.makeText(context, tips, Toast.LENGTH_LONG);
		toast.setGravity(Gravity.CENTER, 0, 0);
		toast.show();
	}
}

#end
#end
#No. 186010
#File: E:\bishe\1\WrapAsyncTask.java
#Comment:
/**
 * client send a stream to host:port.
 */

#Code:
class SendStreamAsyncTask extends
		AsyncTask<InputStream, Void, Boolean> {

	Context context;
	private String host;
	private int port;

	public SendStreamAsyncTask(Context context, String host, int port) {
		this.context = context;
		this.host = host;
		this.port = port;
	}

	@Override
	protected Boolean doInBackground(InputStream... params) {
		assert (params.length == 1);
		if (Utility.sendStream(host, port, params[0]))
			return Boolean.TRUE;
		else
			return Boolean.FALSE;
	}

	@Override
	protected void onPostExecute(Boolean result) {
		Log.d("SendStringAsyncTask", "onPostExecute end.");
		String tips = "";
		if (result.booleanValue())
			tips = "Send ok.";
		else
			tips = "Send failed.";
		Toast toast = Toast.makeText(context, tips, Toast.LENGTH_LONG);
		toast.setGravity(Gravity.CENTER, 0, 0);
		toast.show();
	}
}



#end
#end
#No. 186016
#File: E:\bishe\1\WrappedConciseBitmap.java
#Comment:
  /**
   * Create a bitmap wrappign the given bitmap
   *
   * @param conciseSet bitmap to be wrapped
   */

#Code:
  public WrappedConciseBitmap(ConciseSet conciseSet)
  {
    this.bitmap = conciseSet;
  }

#end
#end
#No. 186017
#File: E:\bishe\1\WrappedDataSource.java
#Comment:
	/**
	 * Wrapper of the default datasource provided by the underlying platform
	 * It has some fault tolerance features, which are not available by default in the popular JDBC drivers
	 *
	 * @param originalDataSource the original data source
	 */

#Code:
	public WrappedDataSource(DataSource originalDataSource) {
		super();
		this.originalDataSource = originalDataSource;
	}

#end
#end
#No. 186018
#File: E:\bishe\1\WrappedFileReferenceProvider.java
#Comment:
    /**
     * @return Relative path to $file according to $relativeTo. "/" at the end is included if necessary
     */

#Code:
    private String relativePathTo(VirtualFile file, VirtualFile relativeTo) {
        final VirtualFile commonAncestor = VfsUtil.getCommonAncestor(file, relativeTo);

        if(commonAncestor == null) return null;

        int level = 0;
        for(VirtualFile parent=relativeTo; !parent.equals(commonAncestor); parent=parent.getParent()) {
            level++;
        }

        final String[] parts = new String[level];

        for(int i=0; i<level; i++) {
            parts[i] = "..";
        }

        if (parts.length == 0) {
            final String path = StringUtil.trimStart(file.getPath().replace(commonAncestor.getPath(), ""), "/");

            return path.length() > 0 ? path + "/" : "";
        }

        return StringUtil.trimEnd(StringUtil.join(parts, "/") + "/" + StringUtil.trimStart(file.getPath().replace(commonAncestor.getPath(), ""), "/"), '/')+"/";
    }


#end
#end
#No. 186020
#File: E:\bishe\1\WrappedImmutableConciseBitmap.java
#Comment:
  /**
   * Wrap an ImmutableConciseSet
   *
   * @param immutableConciseSet bitmap to be wrapped
   */

#Code:
  public WrappedImmutableConciseBitmap(ImmutableConciseSet immutableConciseSet)
  {
    this.bitmap = immutableConciseSet;
  }


#end
#end
#No. 186022
#File: E:\bishe\1\WrappedImmutableRoaringBitmap.java
#Comment:
  /**
   * Wrap an ImmutableRoaringBitmap
   *
   * @param immutableRoaringBitmap bitmap to be wrapped
   */

#Code:
  public WrappedImmutableRoaringBitmap(ImmutableRoaringBitmap immutableRoaringBitmap)
  {
    this.bitmap = immutableRoaringBitmap;
  }


#end
#end
#No. 186024
#File: E:\bishe\1\WrappedIntegerIdEntity.java
#Comment:
	/**
	 * @return the id
	 */

#Code:
	public WrappedIntegerId getId() {
		return id;
	}

#end
#end
#No. 186025
#File: E:\bishe\1\WrappedIntegerIdEntity.java
#Comment:
	/**
	 * @param id
	 *            the id to set
	 */

#Code:
	public void setId(WrappedIntegerId id) {
		this.id = id;
	}

#end
#end
#No. 186026
#File: E:\bishe\1\WrappedIntegerIdEntity.java
#Comment:
	/**
	 * @return the name
	 */

#Code:
	public String getName() {
		return name;
	}

#end
#end
#No. 186027
#File: E:\bishe\1\WrappedIntegerIdEntity.java
#Comment:
	/**
	 * @param name
	 *            the name to set
	 */

#Code:
	public void setName(String name) {
		this.name = name;
	}

#end
#end
#No. 186028
#File: E:\bishe\1\WrappedIterator.java
#Comment:
   /**
    * If the delegate changed since the iterator was created, the iterator is no
    * longer valid.
    */

#Code:
   void validateIterator()
   {
      collection.refreshIfEmpty();
      if (collection.delegate != originalDelegate)
      {
         throw new ConcurrentModificationException();
      }
   }

#end
#end
#No. 186029
#File: E:\bishe\1\WrappedKeystore.java
#Comment:
/**
 * Special wrapper for a KeyStore.
 *
 * @author Sylvain Pedneault
 */

#Code:
class WrappedKeystore extends InputStream {
  private final KeyStore keystore;

  WrappedKeystore(final KeyStore keystore) {
    this.keystore = keystore;
  }

  public KeyStore getKeystore() {
    return keystore;
  }

  @Override
  public int read() throws IOException {
    return 0;
  }
}

#end
#end
#No. 186030
#File: E:\bishe\1\WrappedListView.java
#Comment:
    /**
    * A clickable container for creating lists with variable height.
    */

#Code:
    public static class ListItem
            extends Container {

        private final Button leadComponent = new Button();

        public ListItem(String text, ActionListener listener) {
            setLayout(new BorderLayout());
            setUIID("ListItem");
            
            leadComponent.addActionListener(listener);
            
            // Add leadComponent to the container to gain traversal functionality
            addComponent(BorderLayout.NORTH, leadComponent);
            leadComponent.setVisible(false);

            setLeadComponent(leadComponent);
            
            // Create the TextArea and add it to the Container
            TextArea textArea = new TextArea();
            textArea.setText(text);
            textArea.setUIID("ListItem");
            textArea.setEditable(false);
            textArea.setRows(2);
            textArea.setGrowByContent(true);
            addComponent(BorderLayout.CENTER, textArea);
        }
        
        /**
         * Capture fire clicked event, so that lead component can be notified.
         * Cannot call leadComponents fireClicked directly, but this is what
         * Button would basically do. This would happen automatically in an
         * ideal world.
         */
        protected void fireClicked() {
            leadComponent.pressed();
            leadComponent.released();
        }
    }

#end
#end
#No. 186031
#File: E:\bishe\1\WrappedLogger.java
#Comment:
	/**
	 * The constructor
	 *
	 * @param context plugin instance
	 */

#Code:
	public WrappedLogger(Plugin context) {
		super(context);
	}

#end
#end
#No. 186032
#File: E:\bishe\1\WrappedLongIdEntity.java
#Comment:
	/**
	 * @return the id
	 */

#Code:
	public WrappedLongId getId() {
		return id;
	}

#end
#end
#No. 186033
#File: E:\bishe\1\WrappedLongIdEntity.java
#Comment:
	/**
	 * @param id
	 *            the id to set
	 */

#Code:
	public void setId(WrappedLongId id) {
		this.id = id;
	}

#end
#end
#No. 186034
#File: E:\bishe\1\WrappedLongIdEntity.java
#Comment:
	/**
	 * @return the name
	 */

#Code:
	public String getName() {
		return name;
	}

#end
#end
#No. 186035
#File: E:\bishe\1\WrappedLongIdEntity.java
#Comment:
	/**
	 * @param name
	 *            the name to set
	 */

#Code:
	public void setName(String name) {
		this.name = name;
	}

#end
#end
#No. 186036
#File: E:\bishe\1\WrappedLongObjectIdEntity.java
#Comment:
	/**
	 * @return the id
	 */

#Code:
	public WrappedLongObjectId getId() {
		return id;
	}

#end
#end
#No. 186037
#File: E:\bishe\1\WrappedLongObjectIdEntity.java
#Comment:
	/**
	 * @param id
	 *            the id to set
	 */

#Code:
	public void setId(WrappedLongObjectId id) {
		this.id = id;
	}

#end
#end
#No. 186038
#File: E:\bishe\1\WrappedLongObjectIdEntity.java
#Comment:
	/**
	 * @return the name
	 */

#Code:
	public String getName() {
		return name;
	}

#end
#end
#No. 186039
#File: E:\bishe\1\WrappedLongObjectIdEntity.java
#Comment:
	/**
	 * @param name
	 *            the name to set
	 */

#Code:
	public void setName(String name) {
		this.name = name;
	}



#end
#end
#No. 186044
#File: E:\bishe\1\WrappedRoaringBitmap.java
#Comment:
  /**
   * Creates a new WrappedRoaringBitmap wrapping an empty MutableRoaringBitmap
   *
   * @param compressRunOnSerialization indicates whether to call {@link RoaringBitmap#runOptimize()} before serializing
   */

#Code:
  public WrappedRoaringBitmap(boolean compressRunOnSerialization)
  {
    this.bitmap = new MutableRoaringBitmap();
    this.compressRunOnSerialization = compressRunOnSerialization;
  }

#end
#end
#No. 186045
#File: E:\bishe\1\WrappedRunWith.java
#Comment:
/**
 * This annotation used to indicate which runner is to be wrapped when a
 * wrapping runner is given in the &#64;RunWith(...) annotation.
 * 
 * @see WrappingParameterizedRunner
 */

#Code:
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Inherited
public @interface WrappedRunWith {
	Class<? extends Runner> value();
}
}

#end
#end
#No. 186046
#File: E:\bishe\1\WrappedStringIdEntity.java
#Comment:
	/**
	 * @return the id
	 */

#Code:
	public WrappedStringId getId() {
		return id;
	}

#end
#end
#No. 186047
#File: E:\bishe\1\WrappedStringIdEntity.java
#Comment:
	/**
	 * @param id
	 *            the id to set
	 */

#Code:
	public void setId(WrappedStringId id) {
		this.id = id;
	}

#end
#end
#No. 186048
#File: E:\bishe\1\WrappedStringIdEntity.java
#Comment:
	/**
	 * @return the name
	 */

#Code:
	public String getName() {
		return name;
	}

#end
#end
#No. 186049
#File: E:\bishe\1\WrappedStringIdEntity.java
#Comment:
	/**
	 * @param name
	 *            the name to set
	 */

#Code:
	public void setName(String name) {
		this.name = name;
	}




#end
#end
#No. 186053
#File: E:\bishe\1\WrapperHandshakeClientSetProtocol.java
#Comment:
    /**
     * Retrieve the new protocol version. 
     * <p>
     * This is 4 as of 1.7.2. Note to be confused with the old protocol versions.
     * @return The current Protocol Version
    */

#Code:
    public int getProtocolVersion() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186054
#File: E:\bishe\1\WrapperHandshakeClientSetProtocol.java
#Comment:
    /**
     * Set the new protocol version.
     * <p>
     * This is 4 as of 1.7.2.
     * @param value - new value.
    */

#Code:
    public void setProtocolVersion(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186055
#File: E:\bishe\1\WrapperHandshakeClientSetProtocol.java
#Comment:
    /**
     * Retrieve the server hostname or IP.
     * @return The current server hostname.
    */

#Code:
    public String getServerHostname() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186056
#File: E:\bishe\1\WrapperHandshakeClientSetProtocol.java
#Comment:
    /**
     * Set the server hostname.
     * @param value - new value.
    */

#Code:
    public void setServerHostname(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186057
#File: E:\bishe\1\WrapperHandshakeClientSetProtocol.java
#Comment:
    /**
     * Retrieve the TCP port number, typically 25565.
     * @return The current server port
    */

#Code:
    public short getServerPort() {
        return handle.getIntegers().read(1).shortValue();
    }

#end
#end
#No. 186058
#File: E:\bishe\1\WrapperHandshakeClientSetProtocol.java
#Comment:
    /**
     * Set the TCP port number.
     * @param value - new value.
    */

#Code:
    public void setServerPort(short value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186059
#File: E:\bishe\1\WrapperHandshakeClientSetProtocol.java
#Comment:
    /**
     * Retrieve the next protocol to use.
     * @return The next protocol.
    */

#Code:
    public Protocol getNextProtocol() {
        return handle.getProtocols().read(0);
    }

#end
#end
#No. 186060
#File: E:\bishe\1\WrapperHandshakeClientSetProtocol.java
#Comment:
    /**
     * Set the next protocol to use.
     * @param value - new protocll.
    */

#Code:
    public void setNextProtocol(Protocol value) {
        handle.getProtocols().write(0, value);
    }


#end
#end
#No. 186062
#File: E:\bishe\1\WrapperListAdapterAssert.java
#Comment:
/**
 * Assertions for {@link WrapperListAdapter} instances.
 * <p>
 * This class is final. To extend use {@link AbstractWrapperListAdapterAssert}.
 */

#Code:
public final class WrapperListAdapterAssert
    extends AbstractWrapperListAdapterAssert<WrapperListAdapterAssert, WrapperListAdapter> {
  public WrapperListAdapterAssert(WrapperListAdapter actual) {
    super(actual, WrapperListAdapterAssert.class);
  }
}

#end
#end
#No. 186063
#File: E:\bishe\1\WrapperLoginClientEncryptionBegin.java
#Comment:
    /**
     * Retrieve the shared secret data.
     * @return The shared data.
    */

#Code:
    public byte[] getSharedSecret() {
        return handle.getByteArrays().read(0);
    }

#end
#end
#No. 186064
#File: E:\bishe\1\WrapperLoginClientEncryptionBegin.java
#Comment:
    /**
     * Set the shared secret data.
     * @param value - new value.
    */

#Code:
    public void setSharedSecret(byte[] value) {
        handle.getByteArrays().write(0, value);
    }

#end
#end
#No. 186065
#File: E:\bishe\1\WrapperLoginClientEncryptionBegin.java
#Comment:
    /**
     * Retrieve the token response.
     * @return The shared data.
    */

#Code:
    public byte[] getVerifyTokenResponse() {
        return handle.getByteArrays().read(1);
    }

#end
#end
#No. 186066
#File: E:\bishe\1\WrapperLoginClientEncryptionBegin.java
#Comment:
    /**
     * Set token reponse.
     * @param value - new value.
    */

#Code:
    public void setVerifyTokenResponse(byte[] value) {
        handle.getByteArrays().write(1, value);
    }

#end
#end
#No. 186067
#File: E:\bishe\1\WrapperLoginClientStart.java
#Comment:
    /**
     * Retrieve the initial game profile.
     * <p>
     * Note that the UUID is NULL.
     * @return The current profile.
    */

#Code:
    public WrappedGameProfile getProfile() {
        return handle.getGameProfiles().read(0);
    }

#end
#end
#No. 186068
#File: E:\bishe\1\WrapperLoginClientStart.java
#Comment:
    /**
     * Set the initial game profile.
     * @param value - new profile.
    */

#Code:
    public void setProfile(WrappedGameProfile value) {
        handle.getGameProfiles().write(0, value);
    }   

#end
#end
#No. 186069
#File: E:\bishe\1\WrapperLoginServerDisconnect.java
#Comment:
    /**
     * Retrieve the message that is displayed to the client when the connection terminates.
     * @return The current JSON message.
    */

#Code:
    public WrappedChatComponent getJsonData() {
        return handle.getChatComponents().read(0);
    }

#end
#end
#No. 186070
#File: E:\bishe\1\WrapperLoginServerDisconnect.java
#Comment:
    /**
     * Set the message that is displayed to the client when the connection terminates.
     * @param value - new message.
    */

#Code:
    public void setJsonData(WrappedChatComponent value) {
        handle.getChatComponents().write(0, value);
    }

#end
#end
#No. 186071
#File: E:\bishe\1\WrapperLoginServerEncryptionBegin.java
#Comment:
    /**
     * Retrieve the server ID.
     * @return The current Server id
    */

#Code:
    public String getServerId() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186072
#File: E:\bishe\1\WrapperLoginServerEncryptionBegin.java
#Comment:
    /**
     * Set the server ID.
     * @param value - new value.
    */

#Code:
    public void setServerId(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186073
#File: E:\bishe\1\WrapperLoginServerEncryptionBegin.java
#Comment:
    /**
     * Retrieve the public key instance.
     * @return The current Public key length
    */

#Code:
    public PublicKey getPublicKey() {
        return handle.getSpecificModifier(PublicKey.class).read(0);
    }

#end
#end
#No. 186074
#File: E:\bishe\1\WrapperLoginServerEncryptionBegin.java
#Comment:
    /**
     * Set the public key instance.
     * @param value - new value.
    */

#Code:
    public void setPublicKey(PublicKey value) {
        handle.getSpecificModifier(PublicKey.class).write(0, value);
    }

#end
#end
#No. 186075
#File: E:\bishe\1\WrapperLoginServerEncryptionBegin.java
#Comment:
    /**
     * Retrieve the verify token.
     * @return The current Public key
    */

#Code:
    public byte[] getVerifyToken() {
        return handle.getByteArrays().read(0);
    }

#end
#end
#No. 186076
#File: E:\bishe\1\WrapperLoginServerEncryptionBegin.java
#Comment:
    /**
     * Set the verify token.
     * @param value - new value.
    */

#Code:
    public void getVerifyToken(byte[] value) {
        handle.getByteArrays().write(0, value);
    }

#end
#end
#No. 186077
#File: E:\bishe\1\WrapperLoginServerSuccess.java
#Comment:
    /**
     * Retrieve the UUID and player name of the connected client.
     * @return The current client profile.
    */

#Code:
    public WrappedGameProfile getProfile() {
        return handle.getGameProfiles().read(0);
    }

#end
#end
#No. 186078
#File: E:\bishe\1\WrapperLoginServerSuccess.java
#Comment:
    /**
     * Set the UUID and player name of the connected client as a game profile.
     * @param value - new profile.
    */

#Code:
    public void setProfile(WrappedGameProfile value) {
        handle.getGameProfiles().write(0, value);
    }

#end
#end
#No. 186079
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Retrieve whether or not the current player is in creative mode.
     * @return Creative mode.
    */

#Code:
    public boolean isCreativeMode() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186080
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Set whether or not the current player is in creative mode.
     * @param value - new value.
    */

#Code:
    public void setCreativeMode(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186081
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Retrieve whether or not the current player is flying.
     * @return Creative mode.
    */

#Code:
    public boolean isFlying() {
        return handle.getSpecificModifier(boolean.class).read(1);
    }

#end
#end
#No. 186082
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Set whether or not the current player is flying.
     * @param value - new value.
    */

#Code:
    public void setFlying(boolean value) {
        handle.getSpecificModifier(boolean.class).write(1, value);
    }

#end
#end
#No. 186083
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Retrieve whether or not the current player is allowed to fly.
     * @return Creative mode.
    */

#Code:
    public boolean isFlyingAllowed() {
        return handle.getSpecificModifier(boolean.class).read(2);
    }

#end
#end
#No. 186084
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Set whether or not the current player is allowed to fly.
     * @param value - new value.
    */

#Code:
    public void setFlyingAllowed(boolean value) {
        handle.getSpecificModifier(boolean.class).write(2, value);
    }

#end
#end
#No. 186085
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Retrieve whether or not the current player is in god mode.
     * @return Creative mode.
    */

#Code:
    public boolean isGodMode() {
        return handle.getSpecificModifier(boolean.class).read(3);
    }

#end
#end
#No. 186086
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Set whether or not the current player is in god mode.
     * @param value - new value.
    */

#Code:
    public void setGodMode(boolean value) {
        handle.getSpecificModifier(boolean.class).write(3, value);
    }

#end
#end
#No. 186087
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Retrieve the current flying speed.
     * @return The current Flying speed
    */

#Code:
    public float getFlyingSpeed() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186088
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Set the current flying speed.
     * @param value - new value.
    */

#Code:
    public void setFlyingSpeed(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186089
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Retrieve the current walking speed.
     * @return The current walking speed
    */

#Code:
    public float getWalkingSpeed() {
        return handle.getFloat().read(1);
    }

#end
#end
#No. 186090
#File: E:\bishe\1\WrapperPlayClientAbilities.java
#Comment:
    /**
     * Set the current walking speed.
     * @param value - walking value.
    */

#Code:
    public void setWalkingSpeed(float value) {
        handle.getFloat().write(1, value);
    }

#end
#end
#No. 186091
#File: E:\bishe\1\WrapperPlayClientArmAnimation.java
#Comment:
    /**
     * Retrieve the player ID.
     * @return The current EID
    */

#Code:
    public int getEntityID() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186092
#File: E:\bishe\1\WrapperPlayClientArmAnimation.java
#Comment:
    /**
     * Set the player ID.
     * @param value - new value.
    */

#Code:
    public void setEntityID(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186093
#File: E:\bishe\1\WrapperPlayClientArmAnimation.java
#Comment:
    /**
     * Retrieve the player's entity object.
     * @param world - the word the player has joined.
     * @return The player's entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186094
#File: E:\bishe\1\WrapperPlayClientArmAnimation.java
#Comment:
    /**
     * Retrieve the player's entity object.
     * @param event - the packet event.
     * @return The player's entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186095
#File: E:\bishe\1\WrapperPlayClientArmAnimation.java
#Comment:
    /**
     * Retrieve animation ID.
     * @return The current Animation
    */

#Code:
    public int getAnimation() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186096
#File: E:\bishe\1\WrapperPlayClientArmAnimation.java
#Comment:
    /**
     * Set animation ID.
     * @param value - new value.
    */

#Code:
    public void setAnimation(int value) {
        handle.getIntegers().write(1, value);
    }

#end
#end
#No. 186097
#File: E:\bishe\1\WrapperPlayClientBlockDig.java
#Comment:
    /**
     * Retrieve the action the player is taking against the block.
     * @return The current Status
    */

#Code:
    public Status getStatus() {
        return Status.values()[handle.getIntegers().read(4)];
    }

#end
#end
#No. 186098
#File: E:\bishe\1\WrapperPlayClientBlockDig.java
#Comment:
    /**
     * Set the action the player is taking against the block.
     * @param value - new action.
    */

#Code:
    public void setStatus(Status value) {
        handle.getIntegers().write(4, value.ordinal());
    }

#end
#end
#No. 186099
#File: E:\bishe\1\WrapperPlayClientBlockDig.java
#Comment:
    /**
     * Retrieve block position.
     * @return The current X
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186100
#File: E:\bishe\1\WrapperPlayClientBlockDig.java
#Comment:
    /**
     * Set block position.
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186101
#File: E:\bishe\1\WrapperPlayClientBlockDig.java
#Comment:
    /**
     * Retrieve block position.
     * @return The current Y
    */

#Code:
    public byte getY() {
        return handle.getIntegers().read(1).byteValue();
    }

#end
#end
#No. 186102
#File: E:\bishe\1\WrapperPlayClientBlockDig.java
#Comment:
    /**
     * Set block position.
     * @param value - new value.
    */

#Code:
    public void setY(byte value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186103
#File: E:\bishe\1\WrapperPlayClientBlockDig.java
#Comment:
    /**
     * Retrieve block position.
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186104
#File: E:\bishe\1\WrapperPlayClientBlockDig.java
#Comment:
    /**
     * Set block position.
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186105
#File: E:\bishe\1\WrapperPlayClientBlockDig.java
#Comment:
    /**
     * Retrieve the face being hit. See {@link Packet0EPlayerDigging.BlockSide BlockSide}.
     * @return The current block side.
    */

#Code:
    public int getFace() {
        return handle.getIntegers().read(3).byteValue();
    }

#end
#end
#No. 186106
#File: E:\bishe\1\WrapperPlayClientBlockDig.java
#Comment:
    /**
     * Set the face being hit. See {@link Packet0EPlayerDigging.BlockSide BlockSide}.
     * @param value - new value.
    */

#Code:
    public void setFace(int value) {
        handle.getIntegers().write(3, value);
    }

#end
#end
#No. 186107
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Retrieve the x block position.
     * @return The current X
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186108
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Set the x block position.
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186109
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Retrieve the y block position.
     * @return The current Y
    */

#Code:
    public byte getY() {
        return handle.getIntegers().read(1).byteValue();
    }

#end
#end
#No. 186110
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Set the y block position.
     * @param value - new value.
    */

#Code:
    public void setY(byte value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186111
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Retrieve the z block position.
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186112
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Set the z block position.
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186113
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Retrieve the offset to use for block/item placement.
     * @return The current Direction
    */

#Code:
    public byte getDirection() {
        return handle.getIntegers().read(3).byteValue();
    }

#end
#end
#No. 186114
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Set the offset to use for block/item placement.
     * @param value - new value.
    */

#Code:
    public void setDirection(byte value) {
        handle.getIntegers().write(3, (int) value);
    }

#end
#end
#No. 186115
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Retrieve the currently held item.
     * @return The current Held item
    */

#Code:
    public ItemStack getHeldItem() {
        return handle.getItemModifier().read(0);
    }

#end
#end
#No. 186116
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Set the currently held item.
     * @param value - new value.
    */

#Code:
    public void setHeldItem(ItemStack value) {
        handle.getItemModifier().write(0, value);
    }

#end
#end
#No. 186117
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Retrieve the x position of the crosshair on the block.
     * @return The current cursor position X
    */

#Code:
    public float getCursorPositionX() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186118
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Set the x position of the crosshair on the block.
     * @param value - new value.
    */

#Code:
    public void setCursorPositionX(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186119
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Retrieve the y position of the cursor.
     * @return The current Cursor position Y
    */

#Code:
    public float getCursorPositionY() {
        return handle.getFloat().read(1);
    }

#end
#end
#No. 186120
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Set the y position of the cursor.
     * @param value - new value.
    */

#Code:
    public void setCursorPositionY(float value) {
        handle.getFloat().write(1, value);
    }

#end
#end
#No. 186121
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Retrieve the z position of the cursor.
     * @return The current Cursor position Z
    */

#Code:
    public byte getCursorPositionZ() {
        return handle.getFloat().read(2).byteValue();
    }

#end
#end
#No. 186122
#File: E:\bishe\1\WrapperPlayClientBlockPlace.java
#Comment:
    /**
     * Set the z position of the cursor.
     * @param value - new value.
    */

#Code:
    public void setCursorPositionZ(byte value) {
        handle.getFloat().write(2, (float) value);
    }

#end
#end
#No. 186123
#File: E:\bishe\1\WrapperPlayClientChat.java
#Comment:
    /**
     * Retrieve the message sent by this player.
     * @return The current Message
    */

#Code:
    public String getMessage() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186124
#File: E:\bishe\1\WrapperPlayClientChat.java
#Comment:
    /**
     * Set the message sent by this player.
     * @param value - new value.
    */

#Code:
    public void setMessage(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186125
#File: E:\bishe\1\WrapperPlayClientCloseWindow.java
#Comment:
    /**
     * Retrieve this is the id of the window that was closed. 0 for inventory.
     * @return The current Window id
    */

#Code:
    public byte getWindowId() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186126
#File: E:\bishe\1\WrapperPlayClientCloseWindow.java
#Comment:
    /**
     * Set this is the id of the window that was closed. 0 for inventory.
     * @param value - new value.
    */

#Code:
    public void setWindowId(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186127
#File: E:\bishe\1\WrapperPlayClientCustomPayload.java
#Comment:
    /**
     * Retrieve name of the "channel" used to send the data..
     * @return The current Channel
    */

#Code:
    public String getChannel() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186128
#File: E:\bishe\1\WrapperPlayClientCustomPayload.java
#Comment:
    /**
     * Set name of the "channel" used to send the data..
     * @param value - new value.
    */

#Code:
    public void setChannel(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186129
#File: E:\bishe\1\WrapperPlayClientCustomPayload.java
#Comment:
    /**
     * Retrieve length of the following byte array.
     * @return The current Length
    */

#Code:
    public short getLength() {
        return handle.getIntegers().read(0).shortValue();
    }

#end
#end
#No. 186130
#File: E:\bishe\1\WrapperPlayClientCustomPayload.java
#Comment:
    /**
     * Set length of the following byte array.
     * @param value - new value.
    */

#Code:
    public void setLength(short value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186131
#File: E:\bishe\1\WrapperPlayClientCustomPayload.java
#Comment:
    /**
     * Retrieve any data..
     * @return The current Data
    */

#Code:
    public byte[] getData() {
        return handle.getByteArrays().read(0);
    }

#end
#end
#No. 186132
#File: E:\bishe\1\WrapperPlayClientCustomPayload.java
#Comment:
    /**
     * Set the data to sent.
     * <p>
     * This will automatically update the length.
     * @param value - new value.
    */

#Code:
    public void setData(byte[] value) {
    	setLength((short) value.length);
        handle.getByteArrays().write(0, value);
    }

#end
#end
#No. 186133
#File: E:\bishe\1\WrapperPlayClientEnchantItem.java
#Comment:
    /**
     * Retrieve the ID sent by open window.
     * @return The current Window ID
    */

#Code:
    public byte getWindowId() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186134
#File: E:\bishe\1\WrapperPlayClientEnchantItem.java
#Comment:
    /**
     * Set the ID sent by open window.
     * @param value - new value.
    */

#Code:
    public void setWindowId(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186135
#File: E:\bishe\1\WrapperPlayClientEnchantItem.java
#Comment:
    /**
     * Retrieve the position of the enchantment on the enchantment table window, starting with 0 as the top-most one.
     * @return The current Enchantment
    */

#Code:
    public byte getEnchantment() {
        return handle.getIntegers().read(1).byteValue();
    }

#end
#end
#No. 186136
#File: E:\bishe\1\WrapperPlayClientEnchantItem.java
#Comment:
    /**
     * Set the position of the enchantment on the enchantment table window, starting with 0 as the top-most one.
     * @param value - new value.
    */

#Code:
    public void setEnchantment(byte value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186137
#File: E:\bishe\1\WrapperPlayClientEntityAction.java
#Comment:
    /**
     * Retrieve player ID.
     * @return The current EID
    */

#Code:
    public int getEntityID() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186138
#File: E:\bishe\1\WrapperPlayClientEntityAction.java
#Comment:
    /**
     * Set player ID.
     * @param value - new value.
    */

#Code:
    public void setEntityID(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186139
#File: E:\bishe\1\WrapperPlayClientEntityAction.java
#Comment:
    /**
     * Retrieve the player's entity object.
     * @param world - the word the player has joined.
     * @return The player's entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186140
#File: E:\bishe\1\WrapperPlayClientEntityAction.java
#Comment:
    /**
     * Retrieve the player's entity object.
     * @param event - the packet event.
     * @return The player's entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186141
#File: E:\bishe\1\WrapperPlayClientEntityAction.java
#Comment:
    /**
     * Retrieve the ID of the action.
     * @see {@link WrapperPlayClientEntityAction.Action}
     * @return The current Action ID
    */

#Code:
    public byte getActionId() {
        return handle.getIntegers().read(1).byteValue();
    }

#end
#end
#No. 186142
#File: E:\bishe\1\WrapperPlayClientEntityAction.java
#Comment:
    /**
     * Set the ID of the action, see below.
     * @see {@link WrapperPlayClientEntityAction.Action}
     * @param value - new value.
    */

#Code:
    public void setActionId(byte value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186143
#File: E:\bishe\1\WrapperPlayClientEntityAction.java
#Comment:
    /**
     * Retrieve horse jump boost. Ranged from 0 -> 100..
     * @return The current Jump Boost
    */

#Code:
    public int getJumpBoost() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186144
#File: E:\bishe\1\WrapperPlayClientEntityAction.java
#Comment:
    /**
     * Set horse jump boost. Ranged from 0 -> 100..
     * @param value - new value.
    */

#Code:
    public void setJumpBoost(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186145
#File: E:\bishe\1\WrapperPlayClientFlying.java
#Comment:
    /**
     * Retrieve the ground state.
     * <p>
     * True if the client is on the ground, false otherwise.
     * @return The current On Ground
    */

#Code:
    public boolean getOnGround() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186146
#File: E:\bishe\1\WrapperPlayClientFlying.java
#Comment:
    /**
     * Set the ground state.
     * <p>
     * True if the client is on the ground, false otherwise.
     * @param value - new value.
    */

#Code:
    public void setOnGround(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186147
#File: E:\bishe\1\WrapperPlayClientHeldItemSlot.java
#Comment:
    /**
     * Retrieve the slot which the player has selected (0-8).
     * @return The current Slot
    */

#Code:
    public short getSlot() {
        return handle.getIntegers().read(0).shortValue();
    }

#end
#end
#No. 186148
#File: E:\bishe\1\WrapperPlayClientHeldItemSlot.java
#Comment:
    /**
     * Set the slot which the player has selected (0-8).
     * @param value - new value.
    */

#Code:
    public void setSlot(short value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186149
#File: E:\bishe\1\WrapperPlayClientLook.java
#Comment:
    /**
     * Retrieve absolute rotation on the X Axis, in degrees.
     * @return The current Yaw
    */

#Code:
    public float getYaw() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186150
#File: E:\bishe\1\WrapperPlayClientLook.java
#Comment:
    /**
     * Set absolute rotation on the X Axis, in degrees.
     * @param value - new value.
    */

#Code:
    public void setYaw(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186151
#File: E:\bishe\1\WrapperPlayClientLook.java
#Comment:
    /**
     * Retrieve absolute rotation on the Y Axis, in degrees.
     * @return The current Pitch
    */

#Code:
    public float getPitch() {
        return handle.getFloat().read(1);
    }

#end
#end
#No. 186152
#File: E:\bishe\1\WrapperPlayClientLook.java
#Comment:
    /**
     * Set absolute rotation on the Y Axis, in degrees.
     * @param value - new value.
    */

#Code:
    public void setPitch(float value) {
        handle.getFloat().write(1, value);
    }

#end
#end
#No. 186153
#File: E:\bishe\1\WrapperPlayClientPosition.java
#Comment:
    /**
     * Retrieve absolute position.
     * @return The current X
    */

#Code:
    public double getX() {
        return handle.getDoubles().read(0);
    }

#end
#end
#No. 186154
#File: E:\bishe\1\WrapperPlayClientPosition.java
#Comment:
    /**
     * Set absolute position.
     * @param value - new value.
    */

#Code:
    public void setX(double value) {
        handle.getDoubles().write(0, value);
    }

#end
#end
#No. 186155
#File: E:\bishe\1\WrapperPlayClientPosition.java
#Comment:
    /**
     * Retrieve absolute position.
     * @return The current Y
    */

#Code:
    public double getY() {
        return handle.getDoubles().read(1);
    }

#end
#end
#No. 186156
#File: E:\bishe\1\WrapperPlayClientPosition.java
#Comment:
    /**
     * Set absolute position.
     * @param value - new value.
    */

#Code:
    public void setY(double value) {
        handle.getDoubles().write(1, value);
    }


#end
#end
#No. 186159
#File: E:\bishe\1\WrapperPlayClientPosition.java
#Comment:
    /**
     * Retrieve absolute position.
     * @return The current Z
    */

#Code:
    public double getZ() {
        return handle.getDoubles().read(2);
    }

#end
#end
#No. 186160
#File: E:\bishe\1\WrapperPlayClientPosition.java
#Comment:
    /**
     * Set absolute position.
     * @param value - new value.
    */

#Code:
    public void setZ(double value) {
        handle.getDoubles().write(2, value);
    }

#end
#end
#No. 186161
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Retrieve absolute position.
     * @return The current X
    */

#Code:
    public double getX() {
        return handle.getDoubles().read(0);
    }

#end
#end
#No. 186162
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Set absolute position.
     * @param value - new value.
    */

#Code:
    public void setX(double value) {
        handle.getDoubles().write(0, value);
    }

#end
#end
#No. 186163
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Retrieve absolute position.
     * @return The current Y
    */

#Code:
    public double getY() {
        return handle.getDoubles().read(1);
    }

#end
#end
#No. 186164
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Set absolute position.
     * @param value - new value.
    */

#Code:
    public void setY(double value) {
        handle.getDoubles().write(1, value);
    }

#end
#end
#No. 186165
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Retrieve used to modify the players bounding box when going up stairs, crouching, etc.
     * @return The current Stance
    */

#Code:
    public double getStance() {
        return handle.getDoubles().read(3);
    }

#end
#end
#No. 186166
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Set used to modify the players bounding box when going up stairs, crouching, etc.
     * @param value - new value.
    */

#Code:
    public void setStance(double value) {
        handle.getDoubles().write(3, value);
    }

#end
#end
#No. 186167
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Retrieve absolute position.
     * @return The current Z
    */

#Code:
    public double getZ() {
        return handle.getDoubles().read(2);
    }

#end
#end
#No. 186168
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Set absolute position.
     * @param value - new value.
    */

#Code:
    public void setZ(double value) {
        handle.getDoubles().write(2, value);
    }

#end
#end
#No. 186169
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Retrieve absolute rotation on the X Axis.
     * @return The current Yaw
    */

#Code:
    public float getYaw() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186170
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Set absolute rotation on the X Axis.
     * @param value - new value.
    */

#Code:
    public void setYaw(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186171
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Retrieve absolute rotation on the Y Axis.
     * @return The current Pitch
    */

#Code:
    public float getPitch() {
        return handle.getFloat().read(1);
    }

#end
#end
#No. 186172
#File: E:\bishe\1\WrapperPlayClientPositionLook.java
#Comment:
    /**
     * Set absolute rotation on the Y Axis.
     * @param value - new value.
    */

#Code:
    public void setPitch(float value) {
        handle.getFloat().write(1, value);
    }

#end
#end
#No. 186173
#File: E:\bishe\1\WrapperPlayClientSetCreativeSlot.java
#Comment:
    /**
     * Retrieve the inventory slot index.
     * @return The current Slot
    */

#Code:
    public short getSlot() {
        return handle.getIntegers().read(0).shortValue();
    }

#end
#end
#No. 186174
#File: E:\bishe\1\WrapperPlayClientSetCreativeSlot.java
#Comment:
    /**
     * Set the inventory slot index.
     * @param value - new value.
    */

#Code:
    public void setSlot(short value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186175
#File: E:\bishe\1\WrapperPlayClientSetCreativeSlot.java
#Comment:
    /**
     * Retrieve the clicked item stack.
     * @return The current Clicked item
    */

#Code:
    public ItemStack getClickedItem() {
        return handle.getItemModifier().read(0);
    }

#end
#end
#No. 186176
#File: E:\bishe\1\WrapperPlayClientSetCreativeSlot.java
#Comment:
    /**
     * Set the clicked item stack.
     * @param value - new value.
    */

#Code:
    public void setClickedItem(ItemStack value) {
        handle.getItemModifier().write(0, value);
    }

#end
#end
#No. 186177
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Retrieve en_GB.
     * @return The current Locale
    */

#Code:
    public String getLocale() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186178
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Set en_GB.
     * @param value - new value.
    */

#Code:
    public void setLocale(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186179
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Retrieve 0-3 for 'far', 'normal', 'short', 'tiny'.
     * @return The current View distance
    */

#Code:
    public byte getViewDistance() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186180
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Set 0-3 for 'far', 'normal', 'short', 'tiny'..
     * @param value - new value.
    */

#Code:
    public void setViewDistance(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186181
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Retrieve chat settings.
     * @return The current chat settings,
    */

#Code:
    public ChatVisibility getChatVisibility() {
        return handle.getChatVisibilities().read(0);
    }

#end
#end
#No. 186182
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Set chat settings.
     * @param value - new value.
    */

#Code:
    public void setChatFlags(ChatVisibility value) {
    	handle.getChatVisibilities().write(0, value);
    }

#end
#end
#No. 186183
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Retrieve whether or not the colours multiplayer setting is enabled.
     * @return The current Chat colours
    */

#Code:
    public boolean getChatColours() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186184
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Set whether or not the colours multiplayer setting is enabled.
     * @param value - new value.
    */

#Code:
    public void setChatColours(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, (boolean) value);
    }

#end
#end
#No. 186185
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Retrieve the client-side difficulty.
     * @return The current Difficulty
    */

#Code:
    public Difficulty getDifficulty() {
        return handle.getDifficulties().read(0);
    }

#end
#end
#No. 186186
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Set the client-side difficulty.
     * @param value - new value.
    */

#Code:
    public void setDifficulty(Difficulty difficulty) {
    	handle.getDifficulties().write(0, difficulty);
    }

#end
#end
#No. 186187
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Retrieve the client-side "show cape" option.
     * @return The current Show Cape
    */

#Code:
    public boolean getShowCape() {
        return handle.getSpecificModifier(boolean.class).read(1);
    }

#end
#end
#No. 186188
#File: E:\bishe\1\WrapperPlayClientSettings.java
#Comment:
    /**
     * Set the client-side "show cape" option.
     * @param value - new value.
    */

#Code:
    public void setShowCape(boolean value) {
        handle.getSpecificModifier(boolean.class).write(1, (boolean) value);
    }   

#end
#end
#No. 186189
#File: E:\bishe\1\WrapperPlayClientSteerVehicle.java
#Comment:
    /**
     * Retrieve positive to the left of the player.
     * @return The current Sideways
    */

#Code:
    public float getSideways() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186190
#File: E:\bishe\1\WrapperPlayClientSteerVehicle.java
#Comment:
    /**
     * Set positive to the left of the player.
     * @param value - new value.
    */

#Code:
    public void setSideways(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186191
#File: E:\bishe\1\WrapperPlayClientSteerVehicle.java
#Comment:
    /**
     * Retrieve positive forward.
     * @return The current Forward
    */

#Code:
    public float getForward() {
        return handle.getFloat().read(1);
    }

#end
#end
#No. 186192
#File: E:\bishe\1\WrapperPlayClientSteerVehicle.java
#Comment:
    /**
     * Set positive forward.
     * @param value - new value.
    */

#Code:
    public void setForward(float value) {
        handle.getFloat().write(1, value);
    }

#end
#end
#No. 186193
#File: E:\bishe\1\WrapperPlayClientSteerVehicle.java
#Comment:
    /**
     * Retrieve whether or not the mounted player is jumping.
     * @return The current Jump
    */

#Code:
    public boolean getJump() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186194
#File: E:\bishe\1\WrapperPlayClientSteerVehicle.java
#Comment:
    /**
     * Set whether or not the mounted player is jumping.
     * @param value - new value.
    */

#Code:
    public void setJump(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, (boolean) value);
    }

#end
#end
#No. 186195
#File: E:\bishe\1\WrapperPlayClientSteerVehicle.java
#Comment:
    /**
     * Retrieve true when leaving the vehicle.
     * @return The current Unmount
    */

#Code:
    public boolean getUnmount() {
        return handle.getSpecificModifier(boolean.class).read(1);
    }

#end
#end
#No. 186196
#File: E:\bishe\1\WrapperPlayClientSteerVehicle.java
#Comment:
    /**
     * Set true when leaving the vehicle.
     * @param value - new value.
    */

#Code:
    public void setUnmount(boolean value) {
        handle.getSpecificModifier(boolean.class).write(1, value);
    }

#end
#end
#No. 186197
#File: E:\bishe\1\WrapperPlayClientTransaction.java
#Comment:
    /**
     * Retrieve the id of the window that the action occurred in.
     * @return The current Window id
    */

#Code:
    public byte getWindowId() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186198
#File: E:\bishe\1\WrapperPlayClientTransaction.java
#Comment:
    /**
     * Set the id of the window that the action occurred in..
     * @param value - new value.
    */

#Code:
    public void setWindowId(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186199
#File: E:\bishe\1\WrapperPlayClientTransaction.java
#Comment:
    /**
     * Retrieve every action that is to be accepted has a unique number. 
     * <p>
     * This field corresponds to that number..
     * @return The current Action number
    */

#Code:
    public short getActionNumber() {
        return handle.getShorts().read(0);
    }

#end
#end
#No. 186200
#File: E:\bishe\1\WrapperPlayClientTransaction.java
#Comment:
    /**
     * Set every action that is to be accepted has a unique number. 
     * <p>
     * This field corresponds to that number.
     * @param value - new value.
    */

#Code:
    public void setActionNumber(short value) {
        handle.getShorts().write(0, value);
    }

#end
#end
#No. 186201
#File: E:\bishe\1\WrapperPlayClientTransaction.java
#Comment:
    /**
     * Retrieve whether or not the action was accepted.
     * @return The current Accepted?
    */

#Code:
    public boolean getAccepted() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186202
#File: E:\bishe\1\WrapperPlayClientTransaction.java
#Comment:
    /**
     * Set whether or not the action was accepted.
     * @param value - new value.
    */

#Code:
    public void setAccepted(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186203
#File: E:\bishe\1\WrapperPlayClientUpdateSign.java
#Comment:
    /**
     * Retrieve block X Coordinate.
     * @return The current X
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186204
#File: E:\bishe\1\WrapperPlayClientUpdateSign.java
#Comment:
    /**
     * Set block X Coordinate.
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186205
#File: E:\bishe\1\WrapperPlayClientUpdateSign.java
#Comment:
    /**
     * Retrieve block Y Coordinate.
     * @return The current Y
    */

#Code:
    public short getY() {
        return handle.getIntegers().read(1).shortValue();
    }

#end
#end
#No. 186206
#File: E:\bishe\1\WrapperPlayClientUpdateSign.java
#Comment:
    /**
     * Set block Y Coordinate.
     * @param value - new value.
    */

#Code:
    public void setY(short value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186207
#File: E:\bishe\1\WrapperPlayClientUpdateSign.java
#Comment:
    /**
     * Retrieve block Z Coordinate.
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186208
#File: E:\bishe\1\WrapperPlayClientUpdateSign.java
#Comment:
    /**
     * Set block Z Coordinate.
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186209
#File: E:\bishe\1\WrapperPlayClientUpdateSign.java
#Comment:
    /**
     * Retrieve the location of the current particle.
     * @param event - the packet event.
     * @return The location.
     */

#Code:
    public Location getLocation(PacketEvent event) {
    	return new Location(event.getPlayer().getWorld(), getX(), getY(), getZ());
    }

#end
#end
#No. 186210
#File: E:\bishe\1\WrapperPlayClientUpdateSign.java
#Comment:
    /**
     * Set the location of the particle to send.
     * @param loc - the location.
     */

#Code:
    public void setLocation(Location loc) {
    	if (loc == null)
    		throw new IllegalArgumentException("Location cannot be NULL.");
    	setX(loc.getBlockX());
    	setY((short) loc.getBlockY());
    	setZ(loc.getBlockZ());
    }

#end
#end
#No. 186211
#File: E:\bishe\1\WrapperPlayClientUpdateSign.java
#Comment:
    /**
     * Retrieve the lines of text represented by a four-element String array.
     * @return The current lines.
    */

#Code:
    public String[] getLines() {
        return handle.getStringArrays().read(0);
    }

#end
#end
#No. 186212
#File: E:\bishe\1\WrapperPlayClientUpdateSign.java
#Comment:
    /**
     * Set the lines of text represented by a four-element String array..
     * @param value - new value.
    */

#Code:
    public void setLines(@Nonnull String[] lines) {
    	if (lines == null)
    		throw new IllegalArgumentException("Array cannot be NULL.");
    	if (lines.length != 4)
    		throw new IllegalArgumentException("The lines array must be four elements long.");
        handle.getStringArrays().write(0, lines);
    }
}
#end
#end
#No. 186213
#File: E:\bishe\1\WrapperPlayClientUseEntity.java
#Comment:
    /**
     * Retrieve the entity ID the player is interacting with.
     * @return The current Target
    */

#Code:
    public int getTargetID() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186214
#File: E:\bishe\1\WrapperPlayClientUseEntity.java
#Comment:
    /**
     * Retrieve the entity the player is interacting with.
     * @param event - the world this event occured in.
     * @return The target entity.
     */

#Code:
    public Entity getTarget(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186215
#File: E:\bishe\1\WrapperPlayClientUseEntity.java
#Comment:
    /**
     * Retrieve the entity the player is interacting with.
     * @param event - the current packet event.
     * @return The target entity.
     */

#Code:
    public Entity getTarget(PacketEvent event) {
    	return getTarget(event.getPlayer().getWorld());
    }

#end
#end
#No. 186216
#File: E:\bishe\1\WrapperPlayClientUseEntity.java
#Comment:
    /**
     * Set the entity ID the player is interacting with.
     * @param value - new value.
    */

#Code:
    public void setTargetID(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186217
#File: E:\bishe\1\WrapperPlayClientUseEntity.java
#Comment:
    /**
     * Retrieve the use action.
     * @return The action.
    */

#Code:
    public EntityUseAction getMouse() {
        return handle.getEntityUseActions().read(0);
    }

#end
#end
#No. 186218
#File: E:\bishe\1\WrapperPlayClientUseEntity.java
#Comment:
    /**
     * Set the use action.
     * @param value - new action.
    */

#Code:
    public void setMouse(EntityUseAction value) {
        handle.getEntityUseActions().write(0, value);
    }

#end
#end
#No. 186219
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Retrieve the id of the window which was clicked. 
     * <p>
     * Use 0 for the player inventory.
     * @return The current Window id
    */

#Code:
    public byte getWindowId() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186220
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Set the id of the window which was clicked. 
     * <p>
     * Use 0 for the player inventory.
     * @param value - new value.
    */

#Code:
    public void setWindowId(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186221
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Retrieve the clicked slot index.
     * @return The current Slot
    */

#Code:
    public short getSlot() {
        return handle.getIntegers().read(1).shortValue();
    }

#end
#end
#No. 186222
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Set the clicked slot index.
     * @param value - new value.
    */

#Code:
    public void setSlot(short value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186223
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Retrieve the mouse button that was clicked.
     * <p>
     * Here zero is left click, one is right click and three is middle click.
     * @return The current Mouse button
    */

#Code:
    public byte getMouseButton() {
        return handle.getIntegers().read(2).byteValue();
    }

#end
#end
#No. 186224
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Set the mouse button that was clicked.
     * <p>
     * Here zero is left click, one is right click and three is middle click.
     * @param value - new value.
    */

#Code:
    public void setMouseButton(byte value) {
        handle.getIntegers().write(2, (int) value);
    }

#end
#end
#No. 186225
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Retrieve a unique number for the action, used for transaction handling (See the Transaction packet)..
     * @return The current Action number
    */

#Code:
    public short getActionNumber() {
        return handle.getShorts().read(0);
    }

#end
#end
#No. 186226
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Set a unique number for the action, used for transaction handling (See the Transaction packet)..
     * @param value - new value.
    */

#Code:
    public void setActionNumber(short value) {
        handle.getShorts().write(0, value);
    }

#end
#end
#No. 186227
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Retrieve the click mode.
     * <p>
     * See <a href="http://wiki.vg/Protocol#Click_Window">Click Window</a> for more details.
     * @return The current mode.
    */

#Code:
    public int getMode() {
        return handle.getIntegers().read(3);
    }

#end
#end
#No. 186228
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Set the click mode.
     * <p>
     * See <a href="http://wiki.vg/Protocol#Click_Window">Click Window</a> for more details.
     * @param value - new value.
    */

#Code:
    public void setMode(int mode) {
        handle.getIntegers().write(3, mode);
    }

#end
#end
#No. 186229
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Retrieve the item that was clicked in the inventory.
     * @return The current Clicked item
    */

#Code:
    public ItemStack getClickedItem() {
        return handle.getItemModifier().read(0);
    }

#end
#end
#No. 186230
#File: E:\bishe\1\WrapperPlayClientWindowClick.java
#Comment:
    /**
     * Set the item that was clicked in the inventory.
     * @param value - new value.
    */

#Code:
    public void setClickedItem(ItemStack value) {
        handle.getItemModifier().write(0, value);
    }

#end
#end
#No. 186231
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Retrieve whether or not the current player is in creative mode.
     * @return Creative mode.
    */

#Code:
    public boolean isCreativeMode() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186232
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Set whether or not the current player is in creative mode.
     * @param value - new value.
    */

#Code:
    public void setCreativeMode(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186233
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Retrieve whether or not the current player is flying.
     * @return Creative mode.
    */

#Code:
    public boolean isFlying() {
        return handle.getSpecificModifier(boolean.class).read(1);
    }

#end
#end
#No. 186234
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Set whether or not the current player is flying.
     * @param value - new value.
    */

#Code:
    public void setFlying(boolean value) {
        handle.getSpecificModifier(boolean.class).write(1, value);
    }

#end
#end
#No. 186235
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Retrieve whether or not the current player is allowed to fly.
     * @return Creative mode.
    */

#Code:
    public boolean isFlyingAllowed() {
        return handle.getSpecificModifier(boolean.class).read(2);
    }

#end
#end
#No. 186236
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Set whether or not the current player is allowed to fly.
     * @param value - new value.
    */

#Code:
    public void setFlyingAllowed(boolean value) {
        handle.getSpecificModifier(boolean.class).write(2, value);
    }

#end
#end
#No. 186237
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Retrieve whether or not the current player is in god mode.
     * @return Creative mode.
    */

#Code:
    public boolean isGodMode() {
        return handle.getSpecificModifier(boolean.class).read(3);
    }

#end
#end
#No. 186238
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Set whether or not the current player is in god mode.
     * @param value - new value.
    */

#Code:
    public void setGodMode(boolean value) {
        handle.getSpecificModifier(boolean.class).write(3, value);
    }

#end
#end
#No. 186239
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Retrieve the current flying speed.
     * @return The current Flying speed
    */

#Code:
    public float getFlyingSpeed() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186240
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Set the current flying speed.
     * @param value - new value.
    */

#Code:
    public void setFlyingSpeed(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186241
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Retrieve the current walking speed.
     * @return The current walking speed
    */

#Code:
    public float getWalkingSpeed() {
        return handle.getFloat().read(1);
    }

#end
#end
#No. 186242
#File: E:\bishe\1\WrapperPlayServerAbilities.java
#Comment:
    /**
     * Set the current walking speed.
     * @param value - walking value.
    */

#Code:
    public void setWalkingSpeed(float value) {
        handle.getFloat().write(1, value);
    }

#end
#end
#No. 186243
#File: E:\bishe\1\WrapperPlayServerAnimation.java
#Comment:
    /**
     * Retrieve the player ID.
     * @return The current EID
    */

#Code:
    public int getEntityID() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186244
#File: E:\bishe\1\WrapperPlayServerAnimation.java
#Comment:
    /**
     * Set the player ID.
     * @param value - new value.
    */

#Code:
    public void setEntityID(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186245
#File: E:\bishe\1\WrapperPlayServerAnimation.java
#Comment:
    /**
     * Retrieve the player's entity object.
     * @param world - the word the player has joined.
     * @return The player's entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186246
#File: E:\bishe\1\WrapperPlayServerAnimation.java
#Comment:
    /**
     * Retrieve the player's entity object.
     * @param event - the packet event.
     * @return The player's entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186247
#File: E:\bishe\1\WrapperPlayServerAnimation.java
#Comment:
    /**
     * Retrieve animation ID.
     * @see {@link WrapperPlayServerAnimation.Animations}.
     * @return The current Animation
    */

#Code:
    public int getAnimation() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186248
#File: E:\bishe\1\WrapperPlayServerAnimation.java
#Comment:
    /**
     * Set animation ID.
     * @see {@link WrapperPlayServerAnimation.Animations}.
     * @param value - new value.
    */

#Code:
    public void setAnimation(int value) {
        handle.getIntegers().write(1, value);
    }

#end
#end
#No. 186249
#File: E:\bishe\1\WrapperPlayServerAttachEntity.java
#Comment:
    /**
     * Retrieve whether or not the entity is leached onto the vehicle.
     * @return TRUE if it is, FALSE otherwise.
    */

#Code:
    public boolean getLeached() {
        return handle.getIntegers().read(0) != 0;
    }

#end
#end
#No. 186250
#File: E:\bishe\1\WrapperPlayServerAttachEntity.java
#Comment:
    /**
     * Set whether or not the entity is leached onto the vehicle.
     * @param value - TRUE if it is leached, FALSE otherwise.
    */

#Code:
    public void setLeached(boolean value) {
        handle.getIntegers().write(0, value ? 1 : 0);
    }

#end
#end
#No. 186251
#File: E:\bishe\1\WrapperPlayServerAttachEntity.java
#Comment:
    /**
     * Retrieve the player entity ID being attached.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186252
#File: E:\bishe\1\WrapperPlayServerAttachEntity.java
#Comment:
    /**
     * Set the player entity ID being attached.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(1, value);
    }

#end
#end
#No. 186253
#File: E:\bishe\1\WrapperPlayServerAttachEntity.java
#Comment:
    /**
     * Retrieve the entity being attached.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(1);
    }

#end
#end
#No. 186254
#File: E:\bishe\1\WrapperPlayServerAttachEntity.java
#Comment:
    /**
     * Retrieve the entity being attached.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186255
#File: E:\bishe\1\WrapperPlayServerAttachEntity.java
#Comment:
    /**
     * Retrieve the vehicle entity ID attached to (-1 for unattaching).
     * @return The current Vehicle ID
    */

#Code:
    public int getVehicleId() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186256
#File: E:\bishe\1\WrapperPlayServerAttachEntity.java
#Comment:
    /**
     * Set the vehicle entity ID attached to (-1 for unattaching).
     * @param value - new value.
    */

#Code:
    public void setVehicleId(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186257
#File: E:\bishe\1\WrapperPlayServerAttachEntity.java
#Comment:
    /**
     * Retrieve the vehicle entity attached to (NULL for unattaching).
     * @param world - the current world of the entity.
     * @return The vehicle.
     */

#Code:
    public Entity getVehicle(World world) {
    	return handle.getEntityModifier(world).read(2);
    }

#end
#end
#No. 186258
#File: E:\bishe\1\WrapperPlayServerAttachEntity.java
#Comment:
    /**
     * Retrieve the vehicle entity attached to (NULL for unattaching).
     * @param event - the packet event.
     * @return The vehicle.
     */

#Code:
    public Entity getVehicle(PacketEvent event) {
    	return getVehicle(event.getPlayer().getWorld());
    }

#end
#end
#No. 186260
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Retrieve block X Coordinate.
     * @return The current X
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186261
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Set block X Coordinate.
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186262
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Retrieve block Y Coordinate.
     * @return The current Y
    */

#Code:
    public int getY() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186263
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Set block Y Coordinate.
     * @param value - new value.
    */

#Code:
    public void setY(short value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186264
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Retrieve block Z Coordinate.
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186265
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Set block Z Coordinate.
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186266
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Retrieve the block id this action is set for.
     * @return The current Block ID
    */

#Code:
    @SuppressWarnings("deprecation")
	public short getBlockId() {
        return (short) getBlockType().getId();
    }

#end
#end
#No. 186267
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Set the block id this action is set for.
     * @param value - new value.
    */

#Code:
    @SuppressWarnings("deprecation")
	public void setBlockId(short value) {
    	setBlockType(Material.getMaterial(value));
    }

#end
#end
#No. 186268
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Retrieve the block type for the block.
     * @return The current Block Type
    */

#Code:
    public Material getBlockType() {
        return handle.getBlocks().read(0);
    }

#end
#end
#No. 186269
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Set the block type for the block.
     * @param value - new value.
    */

#Code:
    public void setBlockType(Material value) {
        handle.getBlocks().write(0, value);
    }

#end
#end
#No. 186270
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Retrieve varies depending on block.
     * @return The current Byte 1
    */

#Code:
    public byte getByte1() {
        return handle.getIntegers().read(3).byteValue();
    }

#end
#end
#No. 186271
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Set varies depending on block.
     * @param value - new value.
    */

#Code:
    public void setByte1(byte value) {
        handle.getIntegers().write(3, (int) value);
    }

#end
#end
#No. 186272
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Retrieve varies depending on block.
     * @return The current Byte 2
    */

#Code:
    public byte getByte2() {
        return handle.getIntegers().read(4).byteValue();
    }

#end
#end
#No. 186273
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    /**
     * Set varies depending on block.
     * @param value - new value.
    */

#Code:
    public void setByte2(byte value) {
        handle.getIntegers().write(4, (int) value);
    }

#end
#end
#No. 186274
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    	/**
    	 * Get the instrument type.
    	 * @return Instrument type.
    	 */

#Code:
    	@SuppressWarnings("deprecation")
		public Instrument getInstrument() {
    		return Instrument.getByType(getByte1());
    	}

#end
#end
#No. 186275
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    	/**
    	 * Set the instrument type.
    	 * @param value - new instrument type.
    	 */

#Code:
    	@SuppressWarnings("deprecation")
		public void setInstrument(Instrument value) {
    		setByte1(value.getType());
    	}

#end
#end
#No. 186276
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    	/**
    	 * Retrieve the pitch of the note block.
    	 * <p>
    	 * This is between 0-24 inclusive, where 0 is the lowest and 24 is the highest.
    	 * @return The pitch of the note block.
    	 */

#Code:
    	public byte getPitch() {
    		return getByte2();
    	}

#end
#end
#No. 186277
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    	/**
    	 * Set the pitch of the note block.
    	 * <p>
    	 * This is between 0-24 inclusive, where 0 is the lowest and 24 is the highest.
    	 * @param value - the new note block pitch.
    	 */

#Code:
    	public void setPitch(byte value) {
    		setByte2(value);
    	}

#end
#end
#No. 186278
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    	/**
    	 * Get the state the piston changes to.
    	 * <p>
    	 * Zero is pushing, one is pulling.  
    	 * @return Piston state.
    	 */

#Code:
    	public byte getState() {
    		return getByte1();
    	}

#end
#end
#No. 186279
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    	/**
    	 * Set the state the piston changes to.
    	 * <p>
    	 * Zero is pushing, one is pulling.  
    	 * @return Piston state.
    	 */

#Code:
    	public void setState(byte value) {
    		setByte1(value);
    	}

#end
#end
#No. 186280
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    	/**
    	 * Get the block face direction the piston is pushing.
    	 * <p>
    	 * See {@link BlockFaceDirection} for more information.
    	 * @return The direction.
    	 */

#Code:
    	public int getDirection() {
    		return getByte2();
    	}

#end
#end
#No. 186281
#File: E:\bishe\1\WrapperPlayServerBlockAction.java
#Comment:
    	/**
    	 * Set the block face  direction the piston is pushing.
    	 * <p>
    	 * See {@link BlockFaceDirection} for more information.
    	 * @return The direction.
    	 */

#Code:
    	public void setDirection(int value) {
    		setByte2((byte) value);
    	}

#end
#end
#No. 186282
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Retrieve the entity breaking the block.
     * @return The current EID?
    */

#Code:
    public int getEntityID() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186283
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Set the entity breaking the block.
     * @param value - new value.
    */

#Code:
    public void setEntityID(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186284
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Retrieve the entity.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186285
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Retrieve the entity.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186286
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Retrieve the x axis of the block coordinate.
     * @return The current X
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186287
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Set the x axis of the block coordinate.
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(1, value);
    }

#end
#end
#No. 186288
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Retrieve the y axis of the block coordinate.
     * @return The current Y
    */

#Code:
    public int getY() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186289
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Set the y axis of the block coordinate.
     * @param value - new value.
    */

#Code:
    public void setY(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186290
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Retrieve the z axis of the block coordinate.
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(3);
    }

#end
#end
#No. 186291
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Set the z axis of the block coordinate.
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(3, value);
    }

#end
#end
#No. 186292
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Retrieve how far destroyed this block is (0 - 9).
     * @return The current Destroy Stage
    */

#Code:
    public byte getDestroyStage() {
        return handle.getIntegers().read(4).byteValue();
    }

#end
#end
#No. 186293
#File: E:\bishe\1\WrapperPlayServerBlockBreakAnimation.java
#Comment:
    /**
     * Set how far destroyed this block is (0 - 9).
     * @param value - new value.
    */

#Code:
    public void setDestroyStage(byte value) {
        handle.getIntegers().write(4, (int) value);
    }

#end
#end
#No. 186294
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Retrieve block X Coordinate.
     * @return The current X
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186295
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Set block X Coordinate.
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186296
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Retrieve block Y Coordinate.
     * @return The current Y
    */

#Code:
    public int getY() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186297
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Set block Y Coordinate.
     * @param value - new value.
    */

#Code:
    public void setY(int value) {
        handle.getIntegers().write(1, value);
    }

#end
#end
#No. 186298
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Retrieve block Z Coordinate.
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186299
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Set block Z Coordinate.
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186300
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Retrieve the location of the block that is changing.
     * @param event - the parent event.
     * @return The location.
     */

#Code:
    public Location getLocation(PacketEvent event) {
    	return new Location(event.getPlayer().getWorld(), getX(), getY(), getZ());
    }

#end
#end
#No. 186301
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Set the location of the block that is changing.
     * @param loc - the new location.
     */

#Code:
    public void setLocation(Location loc) {
    	setX(loc.getBlockX());
    	setY((byte) loc.getBlockY());
    	setZ(loc.getBlockZ());
    }

#end
#end
#No. 186302
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Retrieve the new type of the block.
     * @return The current Block ID
    */

#Code:
    public Material getBlockType() {
        return handle.getBlocks().read(0);
    }

#end
#end
#No. 186303
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Set the new type of the block.
     * @param value - new value.
    */

#Code:
    public void setBlockType(Material value) {
        handle.getBlocks().write(0, value);
    }

#end
#end
#No. 186304
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Retrieve the new Metadata for the block.
     * @return The current Block Metadata
    */

#Code:
    public byte getBlockMetadata() {
        return handle.getIntegers().read(3).byteValue();
    }

#end
#end
#No. 186305
#File: E:\bishe\1\WrapperPlayServerBlockChange.java
#Comment:
    /**
     * Set the new Metadata for the block.
     * @param value - new value.
    */

#Code:
    public void setBlockMetadata(byte value) {
        handle.getIntegers().write(3, (int) value);
    }

#end
#end
#No. 186306
#File: E:\bishe\1\WrapperPlayServerChat.java
#Comment:
    /**
     * Retrieve the chat message.
     * @return The current JSON Data
    */

#Code:
    public WrappedChatComponent getMessage() {
        return handle.getChatComponents().read(0);
    }

#end
#end
#No. 186307
#File: E:\bishe\1\WrapperPlayServerChat.java
#Comment:
    /**
     * Set the chat message.
     * @param value - new value.
    */

#Code:
    public void setMessage(WrappedChatComponent value) {
        handle.getChatComponents().write(0, value);
    }

#end
#end
#No. 186308
#File: E:\bishe\1\WrapperPlayServerCloseWindow.java
#Comment:
    /**
     * Retrieve this is the id of the window that was or should be closed.
     * @return The current Window id
    */

#Code:
    public byte getWindowId() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186309
#File: E:\bishe\1\WrapperPlayServerCloseWindow.java
#Comment:
    /**
     * Set this is the id of the window that was or should be closed. 
     * @param value - new value.
    */

#Code:
    public void setWindowId(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186310
#File: E:\bishe\1\WrapperPlayServerCraftProgressBar.java
#Comment:
    /**
     * Retrieve the id of the window to update.
     * @return The current Window id
    */

#Code:
    public byte getWindowId() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186311
#File: E:\bishe\1\WrapperPlayServerCraftProgressBar.java
#Comment:
    /**
     * Set the id of the window to update.
     * @param value - new value.
    */

#Code:
    public void setWindowId(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186312
#File: E:\bishe\1\WrapperPlayServerCraftProgressBar.java
#Comment:
    /**
     * Retrieve which property should be updated.
     * <p>
     * For the enchantment table, this is the slot ID.
     * @see {@link FurnaceProperties}
     * @return The current Property
    */

#Code:
    public short getProperty() {
        return handle.getIntegers().read(1).shortValue();
    }

#end
#end
#No. 186313
#File: E:\bishe\1\WrapperPlayServerCraftProgressBar.java
#Comment:
    /**
     * Set which property should be updated.
     * <p>
     * For the enchantment table, this is the slot ID.
     * @see {@link FurnaceProperties}
     * @param value - new value.
    */

#Code:
    public void setProperty(short value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186314
#File: E:\bishe\1\WrapperPlayServerCraftProgressBar.java
#Comment:
    /**
     * Retrieve the new value for the property.
     * <p>
     * For the enchantment table, this is the enchanting level in the given slot.
     * @return The current Value
    */

#Code:
    public short getValue() {
        return handle.getIntegers().read(2).shortValue();
    }

#end
#end
#No. 186315
#File: E:\bishe\1\WrapperPlayServerCraftProgressBar.java
#Comment:
    /**
     * Set the new value for the property.
     * <p>
     * For the enchantment table, this is the enchanting level in the given slot.
     * @param value - new value.
    */

#Code:
    public void setValue(short value) {
        handle.getIntegers().write(2, (int) value);
    }

#end
#end
#No. 186316
#File: E:\bishe\1\WrapperPlayServerCustomPayload.java
#Comment:
    /**
     * Retrieve name of the "channel" used to send the data..
     * @return The current Channel
    */

#Code:
    public String getChannel() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186317
#File: E:\bishe\1\WrapperPlayServerCustomPayload.java
#Comment:
    /**
     * Set name of the "channel" used to send the data..
     * @param value - new value.
    */

#Code:
    public void setChannel(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186318
#File: E:\bishe\1\WrapperPlayServerCustomPayload.java
#Comment:
    /**
     * Retrieve the custom data that sent in this message.
     * @return The current data
    */

#Code:
    public byte[] getData() {
        return handle.getByteArrays().read(0);
    }

#end
#end
#No. 186319
#File: E:\bishe\1\WrapperPlayServerCustomPayload.java
#Comment:
    /**
     * Set the custom data that is sent.
     * @param value - new value.
    */

#Code:
    public void setData(byte[] value) {
        handle.getByteArrays().write(0, value);
    }

#end
#end
#No. 186320
#File: E:\bishe\1\WrapperPlayServerEntity.java
#Comment:
    /**
     * Retrieve entity ID.
     * @return The current EID
    */

#Code:
    public int getEntityID() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186321
#File: E:\bishe\1\WrapperPlayServerEntity.java
#Comment:
    /**
     * Set entity ID.
     * @param value - new value.
    */

#Code:
    public void setEntityID(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186322
#File: E:\bishe\1\WrapperPlayServerEntity.java
#Comment:
    /**
     * Retrieve the entity.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186323
#File: E:\bishe\1\WrapperPlayServerEntity.java
#Comment:
    /**
     * Retrieve the entity.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186324
#File: E:\bishe\1\WrapperPlayServerEntityDestroy.java
#Comment:
    /**
     * Retrieve the IDs of the entities that will be destroyed.
     * @return The current entities.
    */

#Code:
    public List<Integer> getEntities() {
        return Ints.asList(handle.getIntegerArrays().read(0));
    }

#end
#end
#No. 186325
#File: E:\bishe\1\WrapperPlayServerEntityDestroy.java
#Comment:
    /**
     * Set the entities that will be destroyed.
     * @param value - new value.
    */

#Code:
    public void setEntities(int[] entities) {
        handle.getIntegerArrays().write(0, entities);
    }

#end
#end
#No. 186326
#File: E:\bishe\1\WrapperPlayServerEntityDestroy.java
#Comment:
    /**
     * Set the entities that will be destroyed.
     * @param value - new value.
    */

#Code:
    public void setEntities(List<Integer> entities) {
        setEntities(Ints.toArray(entities));
    }

#end
#end
#No. 186327
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Retrieve entity ID of a player.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186328
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Set entity ID of a player.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186329
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Retrieve the entity.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186330
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Retrieve the entity.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186331
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Retrieve the effect ID.
     * @return The current effect ID
    */

#Code:
    public byte getEffectId() {
        return handle.getBytes().read(0);
    }

#end
#end
#No. 186332
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Set the effect id.
     * @param value - new value.
    */

#Code:
    public void setEffectId(byte value) {
        handle.getBytes().write(0, value);
    }

#end
#end
#No. 186333
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Retrieve the effect.
     * @return The current effect
    */

#Code:
    @SuppressWarnings("deprecation")
	public PotionEffectType getEffect() {
        return PotionEffectType.getById(getEffectId());
    }

#end
#end
#No. 186334
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Set the effect id.
     * @param value - new value.
    */

#Code:
    @SuppressWarnings("deprecation")
	public void setEffect(PotionEffectType value) {
        setEffectId((byte) value.getId());
    }

#end
#end
#No. 186335
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Retrieve the amplifier.
     * @return The current Amplifier
    */

#Code:
    public byte getAmplifier() {
        return handle.getBytes().read(1);
    }

#end
#end
#No. 186336
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Set the amplifier.
     * @param value - new value.
    */

#Code:
    public void setAmplifier(byte value) {
        handle.getBytes().write(1, value);
    }

#end
#end
#No. 186337
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Retrieve duration in ticks.
     * @return The current Duration
    */

#Code:
    public short getDuration() {
        return handle.getShorts().read(0);
    }

#end
#end
#No. 186338
#File: E:\bishe\1\WrapperPlayServerEntityEffect.java
#Comment:
    /**
     * Set the duration in ticks.
     * @param value - new value.
    */

#Code:
    public void setDuration(short value) {
        handle.getShorts().write(0, value);
    }

#end
#end
#No. 186339
#File: E:\bishe\1\WrapperPlayServerEntityEquipment.java
#Comment:
    /**
     * Retrieve named Entity ID.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186340
#File: E:\bishe\1\WrapperPlayServerEntityEquipment.java
#Comment:
    /**
     * Retrieve the entity.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186341
#File: E:\bishe\1\WrapperPlayServerEntityEquipment.java
#Comment:
    /**
     * Retrieve the entity.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186342
#File: E:\bishe\1\WrapperPlayServerEntityEquipment.java
#Comment:
    /**
     * Set named Entity ID.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186343
#File: E:\bishe\1\WrapperPlayServerEntityEquipment.java
#Comment:
    /**
     * Retrieve equipment slot.
     * <p>
     * Here zero indicates a held weapon or item, while 1 is boots, 2 is leggings, 
     * 3 is chestplate and 4 is helmet.
     * @return The current slot
    */

#Code:
    public short getSlot() {
        return handle.getIntegers().read(1).shortValue();
    }

#end
#end
#No. 186344
#File: E:\bishe\1\WrapperPlayServerEntityEquipment.java
#Comment:
    /**
     * Set equipment slot.
     * <p>
     * Here zero indicates a held weapon or item, while 1 is boots, 2 is leggings, 
     * 3 is chestplate and 4 is helmet.
     * @param value - new value.
     */

#Code:
    public void setSlot(short value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186345
#File: E:\bishe\1\WrapperPlayServerEntityEquipment.java
#Comment:
    /**
     * Retrieve the equipped item.
     * @return The current item
    */

#Code:
    public ItemStack getItem() {
        return handle.getItemModifier().read(0);
    }

#end
#end
#No. 186346
#File: E:\bishe\1\WrapperPlayServerEntityEquipment.java
#Comment:
    /**
     * Set the equipped item.
     * @param value - new value.
    */

#Code:
    public void setItem(ItemStack value) {
        handle.getItemModifier().write(0, value);
    }

#end
#end
#No. 186347
#File: E:\bishe\1\WrapperPlayServerEntityHeadRotation.java
#Comment:
    /**
     * Retrieve the entity ID.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186348
#File: E:\bishe\1\WrapperPlayServerEntityHeadRotation.java
#Comment:
    /**
     * Set the entity ID.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186349
#File: E:\bishe\1\WrapperPlayServerEntityHeadRotation.java
#Comment:
    /**
     * Retrieve the entity.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186350
#File: E:\bishe\1\WrapperPlayServerEntityHeadRotation.java
#Comment:
    /**
     * Retrieve the entity.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186351
#File: E:\bishe\1\WrapperPlayServerEntityHeadRotation.java
#Comment:
    /**
     * Retrieve the yaw of the entity's head.
     * @return The current yaw.
    */

#Code:
    public float getHeadYaw() {
        return (handle.getBytes().read(0) * 360.F) / 256.0F;
    }

#end
#end
#No. 186352
#File: E:\bishe\1\WrapperPlayServerEntityHeadRotation.java
#Comment:
    /**
     * Set the yaw of the entity's head.
     * @param value - new yaw.
    */

#Code:
    public void setHeadYaw(float value) {
        handle.getBytes().write(0, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186353
#File: E:\bishe\1\WrapperPlayServerEntityLook.java
#Comment:
    /**
     * Retrieve the yaw of the current entity.
     * @return The current Yaw
    */

#Code:
    public float getYaw() {
        return (handle.getBytes().read(3) * 360.F) / 256.0F;
    }

#end
#end
#No. 186354
#File: E:\bishe\1\WrapperPlayServerEntityLook.java
#Comment:
    /**
     * Set the yaw of the current entity.
     * @param value - new yaw.
    */

#Code:
    public void setYaw(float value) {
        handle.getBytes().write(3, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186355
#File: E:\bishe\1\WrapperPlayServerEntityLook.java
#Comment:
    /**
     * Retrieve the pitch of the current entity.
     * @return The current pitch
    */

#Code:
    public float getPitch() {
        return (handle.getBytes().read(4) * 360.F) / 256.0F;
    }

#end
#end
#No. 186356
#File: E:\bishe\1\WrapperPlayServerEntityLook.java
#Comment:
    /**
     * Set the pitch of the current entity.
     * @param value - new pitch.
    */

#Code:
    public void setPitch(float value) {
        handle.getBytes().write(4, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186357
#File: E:\bishe\1\WrapperPlayServerEntityMetadata.java
#Comment:
    /**
     * Retrieve unique entity ID to update.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186358
#File: E:\bishe\1\WrapperPlayServerEntityMetadata.java
#Comment:
    /**
     * Set unique entity ID to update.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186359
#File: E:\bishe\1\WrapperPlayServerEntityMetadata.java
#Comment:
    /**
     * Retrieve the entity.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186360
#File: E:\bishe\1\WrapperPlayServerEntityMetadata.java
#Comment:
    /**
     * Retrieve the entity.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186361
#File: E:\bishe\1\WrapperPlayServerEntityMetadata.java
#Comment:
    /**
     * Retrieve a list of all the watchable objects.
     * <p>
     * This can be converted to a data watcher using {@link WrappedDataWatcher#WrappedDataWatcher(List) WrappedDataWatcher(List)}
     * @return The current metadata
    */

#Code:
    public List<WrappedWatchableObject> getEntityMetadata() {
        return handle.getWatchableCollectionModifier().read(0);
    }

#end
#end
#No. 186362
#File: E:\bishe\1\WrapperPlayServerEntityMetadata.java
#Comment:
    /**
     * Set the list of the watchable objects (meta data).
     * @param value - new value.
    */

#Code:
    public void setEntityMetadata(List<WrappedWatchableObject> value) {
        handle.getWatchableCollectionModifier().write(0, value);
    }

#end
#end
#No. 186363
#File: E:\bishe\1\WrapperPlayServerEntityMoveLook.java
#Comment:
    /**
     * Retrieve the relative movement in the x axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @return The current dX
    */

#Code:
    public double getDx() {
        return handle.getBytes().read(0) / 32.0D;
    }

#end
#end
#No. 186364
#File: E:\bishe\1\WrapperPlayServerEntityMoveLook.java
#Comment:
    /**
     * Set the relative movement in the x axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @param value - new value.
    */

#Code:
    public void setDx(double value) {
    	if (Math.abs(value) > 4)
    		throw new IllegalArgumentException("Displacement cannot exceed 4 meters.");
        handle.getBytes().write(0, (byte) Math.min(Math.floor(value * 32.0D), 127));
    }

#end
#end
#No. 186365
#File: E:\bishe\1\WrapperPlayServerEntityMoveLook.java
#Comment:
    /**
     * Retrieve the relative movement in the y axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @return The current dY
    */

#Code:
    public double getDy() {
        return handle.getBytes().read(1) / 32.0D;
    }

#end
#end
#No. 186366
#File: E:\bishe\1\WrapperPlayServerEntityMoveLook.java
#Comment:
    /**
     * Set the relative movement in the y axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @param value - new value.
    */

#Code:
    public void setDy(double value) {
    	if (Math.abs(value) > 4)
    		throw new IllegalArgumentException("Displacement cannot exceed 4 meters.");
        handle.getBytes().write(1, (byte) Math.min(Math.floor(value * 32.0D), 127));
    }

#end
#end
#No. 186367
#File: E:\bishe\1\WrapperPlayServerEntityMoveLook.java
#Comment:
    /**
     * Retrieve the relative movement in the z axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @return The current dZ
    */

#Code:
    public double getDz() {
        return handle.getBytes().read(2) / 32.0D;
    }

#end
#end
#No. 186368
#File: E:\bishe\1\WrapperPlayServerEntityMoveLook.java
#Comment:
    /**
     * Set the relative movement in the z axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @param value - new value.
    */

#Code:
    public void setDz(double value) {
    	if (Math.abs(value) > 4)
    		throw new IllegalArgumentException("Displacement cannot exceed 4 meters.");
        handle.getBytes().write(2, (byte) Math.min(Math.floor(value * 32.0D), 127));
    }

#end
#end
#No. 186369
#File: E:\bishe\1\WrapperPlayServerEntityMoveLook.java
#Comment:
    /**
     * Retrieve the yaw of the current entity.
     * @return The current Yaw
    */

#Code:
    public float getYaw() {
        return (handle.getBytes().read(3) * 360.F) / 256.0F;
    }

#end
#end
#No. 186370
#File: E:\bishe\1\WrapperPlayServerEntityMoveLook.java
#Comment:
    /**
     * Set the yaw of the current entity.
     * @param value - new yaw.
    */

#Code:
    public void setYaw(float value) {
        handle.getBytes().write(3, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186371
#File: E:\bishe\1\WrapperPlayServerEntityMoveLook.java
#Comment:
    /**
     * Retrieve the pitch of the current entity.
     * @return The current pitch
    */

#Code:
    public float getPitch() {
        return (handle.getBytes().read(4) * 360.F) / 256.0F;
    }

#end
#end
#No. 186372
#File: E:\bishe\1\WrapperPlayServerEntityMoveLook.java
#Comment:
    /**
     * Set the pitch of the current entity.
     * @param value - new pitch.
    */

#Code:
    public void setPitch(float value) {
        handle.getBytes().write(4, (byte) (value * 256.0F / 360.0F));
    }


#end
#end
#No. 186374
#File: E:\bishe\1\WrapperPlayServerEntityStatus.java
#Comment:
    /**
     * Retrieve the entity ID.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186375
#File: E:\bishe\1\WrapperPlayServerEntityStatus.java
#Comment:
    /**
     * Retrieve the entity.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186376
#File: E:\bishe\1\WrapperPlayServerEntityStatus.java
#Comment:
    /**
     * Retrieve the entity.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186377
#File: E:\bishe\1\WrapperPlayServerEntityStatus.java
#Comment:
    /**
     * Set the entity ID.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186378
#File: E:\bishe\1\WrapperPlayServerEntityStatus.java
#Comment:
    /**
     * Retrieve entity status. See {@link Status}.
     * @return The current Entity Status
    */

#Code:
    public int getEntityStatus() {
        return handle.getBytes().read(0).intValue();
    }

#end
#end
#No. 186379
#File: E:\bishe\1\WrapperPlayServerEntityStatus.java
#Comment:
    /**
     * Set the entity status. See {@link Status}.
     * @param value - new value.
    */

#Code:
    public void setEntityStatus(int value) {
        handle.getBytes().write(0, (byte) value);
    }

#end
#end
#No. 186380
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Retrieve entity ID.
     * @return The current EID
    */

#Code:
    public int getEntityID() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186381
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Set entity ID.
     * @param value - new value.
    */

#Code:
    public void setEntityID(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186382
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Retrieve the entity.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186383
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Retrieve the entity.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186384
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Retrieve the x axis of the new position.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current X
    */

#Code:
    public double getX() {
        return handle.getIntegers().read(1) / 32.0D;
    }

#end
#end
#No. 186385
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Set the x axis of the new position.
     * @param value - new value.
    */

#Code:
    public void setX(double value) {
        handle.getIntegers().write(1, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186386
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Retrieve the y axis of the new position.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current y
    */

#Code:
    public double getY() {
        return handle.getIntegers().read(2) / 32.0D;
    }

#end
#end
#No. 186387
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Set the y axis of the new position.
     * @param value - new value.
    */

#Code:
    public void setY(double value) {
        handle.getIntegers().write(2, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186388
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Retrieve the z axis of the new position.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current z
    */

#Code:
    public double getZ() {
        return handle.getIntegers().read(3) / 32.0D;
    }

#end
#end
#No. 186389
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Set the z axis of the new position.
     * @param value - new value.
    */

#Code:
    public void setZ(double value) {
        handle.getIntegers().write(3, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186390
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Retrieve the yaw of the current entity.
     * @return The current Yaw
    */

#Code:
    public float getYaw() {
        return (handle.getBytes().read(0) * 360.F) / 256.0F;
    }

#end
#end
#No. 186391
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Set the yaw of the current entity.
     * @param value - new yaw.
    */

#Code:
    public void setYaw(float value) {
        handle.getBytes().write(0, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186392
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Retrieve the pitch of the current entity.
     * @return The current pitch
    */

#Code:
    public float getPitch() {
        return (handle.getBytes().read(1) * 360.F) / 256.0F;
    }

#end
#end
#No. 186393
#File: E:\bishe\1\WrapperPlayServerEntityTeleport.java
#Comment:
    /**
     * Set the pitch of the current entity.
     * @param value - new pitch.
    */

#Code:
    public void setPitch(float value) {
        handle.getBytes().write(1, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186394
#File: E:\bishe\1\WrapperPlayServerEntityVelocity.java
#Comment:
    /**
     * Retrieve the entity ID.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186395
#File: E:\bishe\1\WrapperPlayServerEntityVelocity.java
#Comment:
    /**
     * Retrieve the entity that will have its velocity updated.
     * @param world - the current world of the entity.
     * @return The spawned entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186396
#File: E:\bishe\1\WrapperPlayServerEntityVelocity.java
#Comment:
    /**
     * Retrieve the entity that will have its velocity updated.
     * @param event - the packet event.
     * @return The spawned entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186397
#File: E:\bishe\1\WrapperPlayServerEntityVelocity.java
#Comment:
    /**
     * Set the entity ID.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186398
#File: E:\bishe\1\WrapperPlayServerEntityVelocity.java
#Comment:
    /**
     * Retrieve the velocity in the x axis.
     * @return The current velocity X
    */

#Code:
    public double getVelocityX() {
        return handle.getIntegers().read(1) / 8000.0D;
    }

#end
#end
#No. 186399
#File: E:\bishe\1\WrapperPlayServerEntityVelocity.java
#Comment:
    /**
     * Set the velocity in the x axis.
     * @param value - new value.
    */

#Code:
    public void setVelocityX(double value) {
        handle.getIntegers().write(1, (int) (value * 8000.0D));
    }

#end
#end
#No. 186400
#File: E:\bishe\1\WrapperPlayServerEntityVelocity.java
#Comment:
    /**
     * Retrieve the velocity in the y axis.
     * @return The current velocity y
    */

#Code:
    public double getVelocityY() {
        return handle.getIntegers().read(2) / 8000.0D;
    }

#end
#end
#No. 186401
#File: E:\bishe\1\WrapperPlayServerEntityVelocity.java
#Comment:
    /**
     * Set the velocity in the y axis.
     * @param value - new value.
    */

#Code:
    public void setVelocityY(double value) {
        handle.getIntegers().write(2, (int) (value * 8000.0D));
    }

#end
#end
#No. 186402
#File: E:\bishe\1\WrapperPlayServerEntityVelocity.java
#Comment:
    /**
     * Retrieve the velocity in the z axis.
     * @return The current velocity z
    */

#Code:
    public double getVelocityZ() {
        return handle.getIntegers().read(3) / 8000.0D;
    }

#end
#end
#No. 186403
#File: E:\bishe\1\WrapperPlayServerEntityVelocity.java
#Comment:
    /**
     * Set the velocity in the z axis.
     * @param value - new value.
    */

#Code:
    public void setVelocityZ(double value) {
        handle.getIntegers().write(3, (int) (value * 8000.0D));
    }

#end
#end
#No. 186404
#File: E:\bishe\1\WrapperPlayServerExperience.java
#Comment:
    /**
     * Retrieve the new amount of experience in the experience bar as a value between 0 and 1.
     * @return The current Experience bar
    */

#Code:
    public float getExperienceBar() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186405
#File: E:\bishe\1\WrapperPlayServerExperience.java
#Comment:
    /**
     * Set the new amount of experience in the experience bar as a value between 0 and 1.
     * @param value - new value.
    */

#Code:
    public void setExperienceBar(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186406
#File: E:\bishe\1\WrapperPlayServerExperience.java
#Comment:
    /**
     * Retrieve the displayed level.
     * @return The current Level
    */

#Code:
    public short getLevel() {
        return handle.getIntegers().read(1).shortValue();
    }

#end
#end
#No. 186407
#File: E:\bishe\1\WrapperPlayServerExperience.java
#Comment:
    /**
     * Set the displayed level.
     * @param value - new value.
    */

#Code:
    public void setLevel(short value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186408
#File: E:\bishe\1\WrapperPlayServerExperience.java
#Comment:
    /**
     * Retrieve the total amount of experienced gained.
     * @return The current Total experience
    */

#Code:
    public short getTotalExperience() {
        return handle.getIntegers().read(0).shortValue();
    }

#end
#end
#No. 186409
#File: E:\bishe\1\WrapperPlayServerExperience.java
#Comment:
    /**
     * Set the total amount of experience gained.
     * @param value - new value.
    */

#Code:
    public void setTotalExperience(short value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186410
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Retrieve the x coordinate of the center of the explosion.
     * @return The current X
    */

#Code:
    public double getX() {
        return handle.getDoubles().read(0);
    }

#end
#end
#No. 186411
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Set the x coordinate of the center of the explosion.
     * @param value - new value.
    */

#Code:
    public void setX(double value) {
        handle.getDoubles().write(0, value);
    }

#end
#end
#No. 186412
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Retrieve the y coordinate of the center of the explosion.
     * @return The current Y
    */

#Code:
    public double getY() {
        return handle.getDoubles().read(1);
    }

#end
#end
#No. 186413
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Set the y coordinate of the center of the explosion.
     * @param value - new value.
    */

#Code:
    public void setY(double value) {
        handle.getDoubles().write(1, value);
    }

#end
#end
#No. 186414
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Retrieve the z coordinate of the center of the explosion.
     * @return The current Z
    */

#Code:
    public double getZ() {
        return handle.getDoubles().read(2);
    }

#end
#end
#No. 186415
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Set the z coordinate of the center of the explosion.
     * @param value - new value.
    */

#Code:
    public void setZ(double value) {
        handle.getDoubles().write(2, value);
    }

#end
#end
#No. 186416
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Retrieve the explosion radius.
     * <p>
     * Note: Currently unused in the client.
     * @return The current Radius
    */

#Code:
    public float getRadius() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186417
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Set the explosion radius.
     * <p>
     * Note: Currently unused in the client.
     * @param value - new value.
    */

#Code:
    public void setRadius(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186418
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Retrieve the absolute coordinates of each affected block in the explosion.
     * @return The current records.
    */

#Code:
    public List<ChunkPosition> getRecords() {
        return handle.getPositionCollectionModifier().read(0);
    }

#end
#end
#No. 186419
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Set the absolute coordinates of each affected block in the explosion.
     * @param value - new value.
    */

#Code:
    public void setRecords(List<ChunkPosition> value) {
        handle.getPositionCollectionModifier().write(0, value);
    }

#end
#end
#No. 186420
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Retrieve x velocity of the player being pushed by the explosion.
     * @return The current Player Motion X
    */

#Code:
    public float getPlayerMotionX() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186421
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Set x velocity of the player being pushed by the explosion.
     * @param value - new value.
    */

#Code:
    public void setPlayerMotionX(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186422
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Retrieve y velocity of the player being pushed by the explosion.
     * @return The current Player Motion Y
    */

#Code:
    public float getPlayerMotionY() {
        return handle.getFloat().read(1);
    }

#end
#end
#No. 186423
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Set y velocity of the player being pushed by the explosion.
     * @param value - new value.
    */

#Code:
    public void setPlayerMotionY(float value) {
        handle.getFloat().write(1, value);
    }

#end
#end
#No. 186424
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Retrieve z velocity of the player being pushed by the explosion.
     * @return The current Player Motion Z
    */

#Code:
    public float getPlayerMotionZ() {
        return handle.getFloat().read(2);
    }

#end
#end
#No. 186425
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Set z velocity of the player being pushed by the explosion.
     * @param value - new value.
    */

#Code:
    public void setPlayerMotionZ(float value) {
        handle.getFloat().write(2, value);
    }

#end
#end
#No. 186426
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Retrieve velocity of the player being pushed by the explosion.
     * @return New velocity.
     */

#Code:
    public Vector getPlayerMotion() {
    	return new Vector(getPlayerMotionX(), getPlayerMotionY(), getPlayerMotionZ());
    }

#end
#end
#No. 186427
#File: E:\bishe\1\WrapperPlayServerExplosion.java
#Comment:
    /**
     * Set the velocity of the player being pushed by the explosion.
     * @param motion - new velocity.
     */

#Code:
    public void setPlayerMotion(Vector motion) {
    	setPlayerMotionX((float) motion.getX());
    	setPlayerMotionY((float) motion.getY());
    	setPlayerMotionZ((float) motion.getZ());
    }

#end
#end
#No. 186428
#File: E:\bishe\1\WrapperPlayServerGameStateChange.java
#Comment:
    /**
     * Retrieve the reason the game state changed.
     * @see {@link Reasons}.
     * @return The current Reason
    */

#Code:
    public int getReason() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186429
#File: E:\bishe\1\WrapperPlayServerGameStateChange.java
#Comment:
    /**
     * Set the reason the game state changed.
     * @see {@link Reasons}.
     * @param value - new value.
    */

#Code:
    public void setReason(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186430
#File: E:\bishe\1\WrapperPlayServerGameStateChange.java
#Comment:
    /**
     * Retrieve the new game mode.
     * <p>
     * Only used when reason is 3.
     * @return The current Game mode
    */

#Code:
    @SuppressWarnings("deprecation")
	public GameMode getGameMode() {
        return GameMode.getByValue(handle.getIntegers().read(1));
    }

#end
#end
#No. 186431
#File: E:\bishe\1\WrapperPlayServerGameStateChange.java
#Comment:
    /**
     * Set the new game mode.
     * <p>
     * Only used when reason is 3.
     * @param value - new value.
    */

#Code:
    @SuppressWarnings("deprecation")
	public void setGameMode(GameMode value) {
        handle.getIntegers().write(1, value.getValue());
    }

#end
#end
#No. 186432
#File: E:\bishe\1\WrapperPlayServerHeldItemSlot.java
#Comment:
    /**
     * Retrieve the slot which the player has selected (0-8).
     * @return The current Slot ID
    */

#Code:
    public short getSlotId() {
        return handle.getIntegers().read(0).shortValue();
    }

#end
#end
#No. 186433
#File: E:\bishe\1\WrapperPlayServerHeldItemSlot.java
#Comment:
    /**
     * Set the slot which the player has selected (0-8).
     * @param value - new value.
    */

#Code:
    public void setSlotId(short value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186434
#File: E:\bishe\1\WrapperPlayServerKickDisconnect.java
#Comment:
    /**
     * Retrieve the reason that is displayed to the client when the connection terminates. 
     * @return The current Reason
    */

#Code:
    public WrappedChatComponent getReason() {
        return handle.getChatComponents().read(0);
    }

#end
#end
#No. 186435
#File: E:\bishe\1\WrapperPlayServerKickDisconnect.java
#Comment:
    /**
     * Set the reason that is displayed to the client when the connection terminates.
     * @param value - new reason.
    */

#Code:
    public void setReason(WrappedChatComponent value) {
        handle.getChatComponents().write(0, value);
    }   

#end
#end
#No. 186436
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Retrieve the player's Entity ID.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186437
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Set the player's Entity ID.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186438
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Retrieve the player's entity object.
     * @param world - the word the player has joined.
     * @return The player's entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186439
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Retrieve the player's entity object.
     * @param event - the packet event.
     * @return The player's entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186440
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Retrieve the game mode of the initial world.
     * @return The current gamemode.
    */

#Code:
    public NativeGameMode getGamemode() {
        return handle.getGameModes().read(0);
    }

#end
#end
#No. 186441
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Set the game mode of the initial world.
     * @param value - new value.
    */

#Code:
    public void setGamemode(NativeGameMode value) {
        handle.getGameModes().write(0, value);
    }

#end
#end
#No. 186442
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Retrieve whether or not this is a hardcore world.
     * @return TRUE if it is, FALSE otherwise.
    */

#Code:
    public boolean isHardcore() {
        return handle.getBooleans().read(0);
    }

#end
#end
#No. 186443
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Set whether or not this is a hardcore world.
     * @param value - TRUE if it is, FALSE otherwise.
    */

#Code:
    public void setHardcore(boolean value) {
        handle.getBooleans().write(0, value);
    }

#end
#end
#No. 186444
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Retrieve -1: nether, 0: overworld, 1: end.
     * @return The current Dimension
    */

#Code:
    public int getDimension() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186445
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Set -1: nether, 0: overworld, 1: end.
     * @param value - new value.
    */

#Code:
    public void setDimension(int value) {
    	handle.getIntegers().write(1, value);
    }

#end
#end
#No. 186446
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Retrieve the difficulty of the initial world.
     * @return The current difficulty
    */

#Code:
    public Difficulty getDifficulty() {
        return handle.getDifficulties().read(0);
    }

#end
#end
#No. 186447
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Set the difficulty of the initial world.
     * @param value - new difficulty.
    */

#Code:
    public void setDifficulty(Difficulty difficulty) {
        handle.getDifficulties().write(0, difficulty);
    }

#end
#end
#No. 186448
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Retrieve the maximum number of players.
     * <p>
     * This is used by the client to draw the player list.
     * @return The current max players.
    */

#Code:
    public byte getMaxPlayers() {
        return handle.getIntegers().read(2).byteValue();
    }

#end
#end
#No. 186449
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Set used by the client to draw the player list.
     * @param value - new value.
    */

#Code:
    public void setMaxPlayers(byte value) {
        handle.getIntegers().write(2, (int) value);
    }

#end
#end
#No. 186450
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Retrieve the world type.
     * <p>
     * This is the level-type settign (default, flat, or largeBiomes) in server.properties.
     * @return The current world type.
    */

#Code:
    public WorldType getLevelType() {
        return handle.getWorldTypeModifier().read(0);
    }

#end
#end
#No. 186451
#File: E:\bishe\1\WrapperPlayServerLogin.java
#Comment:
    /**
     * Set the world type.
     * <p>
     * This is the level-type settign (default, flat, or largeBiomes) in server.properties.
     * @param value - new value.
    */

#Code:
    public void setLevelType(WorldType type) {
        handle.getWorldTypeModifier().write(0, type);
    }    

#end
#end
#No. 186452
#File: E:\bishe\1\WrapperPlayServerMap.java
#Comment:
    /**
     * Retrieve the damage value of the map being modified.
     * @return The current damage value.
    */

#Code:
    public int getItemDamage() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186453
#File: E:\bishe\1\WrapperPlayServerMap.java
#Comment:
    /**
     * Set the damage value of the item being modified.
     * @param value - new value.
    */

#Code:
    public void setItemDamage(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186454
#File: E:\bishe\1\WrapperPlayServerMap.java
#Comment:
    /**
     * Retrieve length of following byte array.
     * @return The current Text length
    */

#Code:
    public byte[] getData() {
        return handle.getByteArrays().read(0);
    }

#end
#end
#No. 186455
#File: E:\bishe\1\WrapperPlayServerMap.java
#Comment:
    /**
     * Set length of following byte array.
     * @param value - new value.
    */

#Code:
    public void setData(@Nonnull byte[] value) {
    	if (value == null)
    		throw new IllegalArgumentException("Array cannot be NULL.");
        handle.getByteArrays().write(0, value);
    }
}
#end
#end
#No. 186456
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Retrieve chunk X Coordinate (multiply by 16 to get the true X).
     * @return The current X
    */

#Code:
    public int getChunkX() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186457
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Set chunk X Coordinate (multiply by 16 to get the true X).
     * @param value - new value.
    */

#Code:
    public void setChunkX(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186458
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Retrieve chunk Z Coordinate (multiply by 16 to get the true Z).
     * @return The current Z
    */

#Code:
    public int getChunkZ() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186459
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Set chunk Z Coordinate (multiply by 16 to get the true Z).
     * @param value - new value.
    */

#Code:
    public void setChunkZ(int value) {
        handle.getIntegers().write(1, value);
    }

#end
#end
#No. 186460
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Retrieve whether or not the packet represents all sections in this vertical column. 
     * <p>
     * The primary bit map specifies exactly which sections are included, and which are air.
     * @return The current Ground-up continuous
    */

#Code:
    public boolean getGroundUpContinuous() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186461
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Set whether or not this packet represents all sections in this vertical column. 
     * <p>
     * The primary bit map specifies exactly which sections are included, and which are air.
     * @param value - new value.
    */

#Code:
    public void setGroundUpContinuous(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186462
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Retrieve a bitmask indicating which 16x16x16 section is stored in the compressed data.
     * @return The current Primary bit map
    */

#Code:
    public short getPrimaryBitMap() {
        return handle.getIntegers().read(2).shortValue();
    }

#end
#end
#No. 186463
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Set a bitmask indicating which 16x16x16 section is stored in the compressed data.
     * @param value - new value.
    */

#Code:
    public void setPrimaryBitMap(short value) {
        handle.getIntegers().write(2, (int) value);
    }

#end
#end
#No. 186464
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Retrieve a bitmask similar to {@link #getPrimaryBitMap()}, but this is used exclusively for the 'add' portion of the payload.
     * @return The current add bit map
    */

#Code:
    public short getAddBitMap() {
        return handle.getIntegers().read(3).shortValue();
    }

#end
#end
#No. 186465
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Set a bitmask similar to {@link #getPrimaryBitMap()}, which is used exclusively for the 'add' portion of the payload.
     * @param value - new value.
    */

#Code:
    public void setAddBitMap(short value) {
        handle.getIntegers().write(3, (int) value);
    }

#end
#end
#No. 186466
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Retrieve size of compressed chunk data.
     * @return The current Compressed size
    */

#Code:
    public int getCompressedSize() {
        return handle.getIntegers().read(4);
    }

#end
#end
#No. 186467
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Set size of compressed chunk data..
     * @param value - new value.
    */

#Code:
    public void setCompressedSize(int value) {
        handle.getIntegers().write(4, value);
    }

#end
#end
#No. 186468
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Retrieve the chunk data that is compressed using ZLib Deflate function.
     * <p>
     * This is the data that will be transmitted to the client.
     * @return The current Compressed data
    */

#Code:
    public byte[] getCompressedData() {
        return (byte[]) handle.getByteArrays().read(0);
    }

#end
#end
#No. 186469
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Set the chunk data that has been compressed using ZLib Deflate function.
     * <p>
     * This is the data that will be transmitted to the client.
     * @param value - new value.
    */

#Code:
    public void setCompressedData(byte[] value) {
        handle.getByteArrays().write(0, (byte[]) value);
    }

#end
#end
#No. 186470
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Retrieve the chunk data that is compressed using ZLib Deflate function.
     * <p>
     * This will not be transmitted to the client.
     * @return The current Compressed data
    */

#Code:
    public byte[] getUncompressedData() {
        return (byte[]) handle.getByteArrays().read(1);
    }

#end
#end
#No. 186471
#File: E:\bishe\1\WrapperPlayServerMapChunk.java
#Comment:
    /**
     * Set the originally uncompressed chunk data.
     * <p>
     * This will not be transmitted to the client.
     * @param value - new value.
    */

#Code:
    public void setUncompressedData(byte[] value) {
        handle.getByteArrays().write(1, (byte[]) value);
    }

#end
#end
#No. 186472
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Retrieve the size of the data field.
     * @return The current Data length
    */

#Code:
    public int getDataLength() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186473
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Set the size of the data field.
     * @param value - new value.
    */

#Code:
    public void setDataLength(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186474
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Retrieve whether or not the chunk data contains a light nibble array. 
     * <p>
     * This is true in the main world, false in the end + nether.
     * @return The current Sky light sent
    */

#Code:
    public boolean getSkyLightSent() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186475
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Set whether or not the chunk data contains a light nibble array. 
     * <p>
     * This is true in the main world, false in the end + nether.
     * @param value - new value.
    */

#Code:
    public void setSkyLightSent(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186476
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Retrieve the x coordinates for each chunk segment.
     * @return Chunk x coordindates.
    */

#Code:
    public int[] getChunksX() {
        return handle.getIntegerArrays().read(0);
    }

#end
#end
#No. 186477
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Set the x coordinates for each chunk segment.
     * @param value - new value.
    */

#Code:
    public void setChunksX(int[] value) {
        handle.getIntegerArrays().write(0, value);
    }

#end
#end
#No. 186478
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Retrieve the y coordinates for each chunk segment.
     * @return Chunk y coordindates.
    */

#Code:
    public int[] getChunksY() {
        return handle.getIntegerArrays().read(1);
    }

#end
#end
#No. 186479
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Set the y coordinates for each chunk segment.
     * @param value - new value.
    */

#Code:
    public void setChunksY(int[] value) {
        handle.getIntegerArrays().write(1, value);
    }

#end
#end
#No. 186480
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Retrieve the chunk mask for each chunk segment.
     * @return Chunk x coordindates.
    */

#Code:
    public int[] getChunksMask() {
        return handle.getIntegerArrays().read(2);
    }

#end
#end
#No. 186481
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Set the chunk mask for each chunk segment.
     * @param value - new value.
    */

#Code:
    public void setChunksMask(int[] value) {
        handle.getIntegerArrays().write(2, value);
    }

#end
#end
#No. 186482
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Retrieve the mask for the extra data in each chunk segment.
     * @return Chunk x coordindates.
    */

#Code:
    public int[] getChunksExtraMask() {
        return handle.getIntegerArrays().read(3);
    }

#end
#end
#No. 186483
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Set the mask for the extra data in each chunk segment.
     * @param value - new value.
    */

#Code:
    public void setChunksExtraMask(int[] value) {
        handle.getIntegerArrays().write(3, value);
    }

#end
#end
#No. 186484
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Retrieve the inflated buffer for each chunk segment.
     * @return Array of each chunk data array.
    */

#Code:
    public byte[][] getChunksInflatedBuffers() {
        return handle.getSpecificModifier(byte[][].class).read(0);
    }

#end
#end
#No. 186485
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Set the inflated buffer for each chunk segment.
     * @param value - new value.
    */

#Code:
    public void setChunksExtraMask(byte[][] value) {
        handle.getSpecificModifier(byte[][].class).write(0, value);
    }

#end
#end
#No. 186486
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Retrieve the uncompressed chunks data that will be compressed and sent.
     * @return The uncompressed chunks data.
     */

#Code:
    public byte[] getUncompressedData() {
    	return handle.getByteArrays().read(1);
    }

#end
#end
#No. 186487
#File: E:\bishe\1\WrapperPlayServerMapChunkBulk.java
#Comment:
    /**
     * Set the uncompressed chunks data that will be compressed and sent.
     * @param value - the uncompressed data.
     */

#Code:
    public void setUncompressedData(byte[] value) {
    	handle.getByteArrays().write(1, value);
    }

#end
#end
#No. 186488
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve player ID.
     * @return The current EID
    */

#Code:
    public int getEntityID() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186489
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set player ID.
     * @param value - new value.
    */

#Code:
    public void setEntityID(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186490
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the player's entity object.
     * @param world - the word the player has joined.
     * @return The player's entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186491
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the player's entity object.
     * @param event - the packet event.
     * @return The player's entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186492
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the player name.
     * <p>
     * Max length of 16.
     * @return The current player Name, or NULL if not set.
    */

#Code:
    public String getPlayerName() {
    	WrappedGameProfile profile = getProfile();
        return profile != null ? profile.getName() : null;
    }

#end
#end
#No. 186493
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the player name.
     * <p>
     * Max length of 16.
     * @param value - new value.
    */

#Code:
    public void setPlayerName(String value) {
    	if (value != null && value.length() > 16)
    		throw new IllegalArgumentException("Maximum player name lenght is 16 characters.");
    	setProfile(new WrappedGameProfile(getPlayerUUID(), value));
    }

#end
#end
#No. 186494
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the UUID of the player.
     * @return The UUID, or NULL if not set.
     */

#Code:
    public String getPlayerUUID() {
    	WrappedGameProfile profile = getProfile();
        return profile != null ? profile.getId() : null;
    }

#end
#end
#No. 186495
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the UUID of the player.
     * @param uuid - the UUID.
     */

#Code:
    public void setPlayerUUID(String uuid) {
    	setProfile(new WrappedGameProfile(uuid, getPlayerName()));
    }

#end
#end
#No. 186496
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve player's full profile.
     * @return The spawner player's profile.
    */

#Code:
    public WrappedGameProfile getProfile() {
        return handle.getGameProfiles().read(0);
    }

#end
#end
#No. 186497
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the spawned player's profile.
     * @param value - new profile.
    */

#Code:
    public void setProfile(WrappedGameProfile value) {
        handle.getGameProfiles().write(0, value);
    }

#end
#end
#No. 186498
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the position of the spawned entity as a vector.
     * @return The position as a vector.
     */

#Code:
    public Vector getPosition() {
    	return new Vector(getX(), getY(), getZ());
    }

#end
#end
#No. 186499
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the position of the spawned entity using a vector.
     * @param position - the new position.
     */

#Code:
    public void setPosition(Vector position) {
    	setX(position.getX());
    	setY(position.getY());
    	setZ(position.getZ());
    }

#end
#end
#No. 186500
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the x axis of the position.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current X
    */

#Code:
    public double getX() {
        return handle.getIntegers().read(1) / 32.0D;
    }

#end
#end
#No. 186501
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the x axis of the position.
     * @param value - new value.
    */

#Code:
    public void setX(double value) {
        handle.getIntegers().write(1, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186502
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the y axis of the position.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current y
    */

#Code:
    public double getY() {
        return handle.getIntegers().read(2) / 32.0D;
    }

#end
#end
#No. 186503
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the y axis of the position.
     * @param value - new value.
    */

#Code:
    public void setY(double value) {
        handle.getIntegers().write(2, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186504
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the z axis of the new position.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current z
    */

#Code:
    public double getZ() {
        return handle.getIntegers().read(3) / 32.0D;
    }

#end
#end
#No. 186505
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the z axis of the new position.
     * @param value - new value.
    */

#Code:
    public void setZ(double value) {
        handle.getIntegers().write(3, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186506
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the yaw of the spawned entity.
     * @return The current Yaw
    */

#Code:
    public float getYaw() {
        return (handle.getBytes().read(0) * 360.F) / 256.0F;
    }

#end
#end
#No. 186507
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the yaw of the spawned entity.
     * @param value - new yaw.
    */

#Code:
    public void setYaw(float value) {
        handle.getBytes().write(0, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186508
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the pitch of the spawned entity.
     * @return The current pitch
    */

#Code:
    public float getPitch() {
        return (handle.getBytes().read(1) * 360.F) / 256.0F;
    }

#end
#end
#No. 186509
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the pitch of the spawned entity.
     * @param value - new pitch.
    */

#Code:
    public void setPitch(float value) {
        handle.getBytes().write(1, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186510
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the item the player is currently holding. 
     * <p>
     * Note that this should be 0 for "no item", unlike -1 used in other packets. A negative value crashes clients.
     * @return The current item.
    */

#Code:
    public short getCurrentItem() {
        return handle.getIntegers().read(4).shortValue();
    }

#end
#end
#No. 186511
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the item the player is currently holding. 
     * <p>
     * Note that this should be 0 for "no item", unlike -1 used in other packets. A negative value crashes clients.
     * @param value - new value.
    */

#Code:
    public void setCurrentItem(short value) {
        handle.getIntegers().write(4, (int) value);
    }

#end
#end
#No. 186512
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Retrieve the associated metadata object.
     * <p>
     * Note that the 1.3 client crashes on packets with no metadata, but the server can send any metadata 
     * key of 0, 1 or 8 and the client is fine.
     * @return The current metadata.
    */

#Code:
    public WrappedDataWatcher getMetadata() {
        return handle.getDataWatcherModifier().read(0);
    }

#end
#end
#No. 186513
#File: E:\bishe\1\WrapperPlayServerNamedEntitySpawn.java
#Comment:
    /**
     * Set the associated metadata object. 
     * <p>
     * Note that the 1.3 client crashes on packets with no metadata, but the server can send any metadata 
     * key of 0, 1 or 8 and the client is fine..
     * @param value - new value.
    */

#Code:
    public void setMetadata(WrappedDataWatcher value) {
        handle.getDataWatcherModifier().write(0, value);
    }

#end
#end
#No. 186514
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Retrieve the sound name.
     * @see {@link NamedSoundEffects}.
     * @return The current Sound name
    */

#Code:
    public String getSoundName() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186515
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Set the sound name.
     * @see {@link NamedSoundEffects}.
     * @param value - new value.
    */

#Code:
    public void setSoundName(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186516
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Retrieve the location of the effect.
     * @param event - the current event.
     * @return The effect location.
     */

#Code:
    public Location getEffectPosition(PacketEvent event) {
    	return getEffectPosition(event.getPlayer().getWorld());
    }

#end
#end
#No. 186517
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Retrieve the location of the effect.
     * @param world - the current world.
     * @return The effect location.
     */

#Code:
    public Location getEffectPosition(World world) {
    	return new Location(world, getEffectPositionX(), getEffectPositionY(), getEffectPositionZ());
    }

#end
#end
#No. 186518
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Retrieve the x coordinate of the effect.
     * @return The current effect position X
    */

#Code:
    public double getEffectPositionX() {
        return handle.getIntegers().read(0) / 8.0;
    }

#end
#end
#No. 186519
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Set the x coordinate of the effect.
     * <p>
     * Note that the value is rounded of to the nearest 1/8.
     * @param value - new value.
    */

#Code:
    public void setEffectPositionX(double value) {
        handle.getIntegers().write(0, (int) (value * 8.0));
    }

#end
#end
#No. 186520
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Retrieve the y coordinate of the effect.
     * <p>
     * Note that the value is rounded of to the nearest 1/8.
     * @return The current effect position Y
    */

#Code:
    public double getEffectPositionY() {
        return handle.getIntegers().read(1) / 8.0;
    }

#end
#end
#No. 186521
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Set the y coordinate of the effect.
     * <p>
     * Note that the value is rounded of to the nearest 1/8.
     * @param value - new value.
    */

#Code:
    public void setEffectPositionY(double value) {
        handle.getIntegers().write(1, (int) (value * 8.0));
    }

#end
#end
#No. 186522
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Retrieve the z coordinate of the effect.
     * <p>
     * Note that the value is rounded of to the nearest 1/8.
     * @return The current effect position z
    */

#Code:
    public double getEffectPositionZ() {
        return handle.getIntegers().read(2) / 8.0;
    }

#end
#end
#No. 186523
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Set the z coordinate of the effect.
     * <p>
     * Note that the value is rounded of to the nearest 1/8.
     * @param value - new value.
    */

#Code:
    public void setEffectPositionZ(double value) {
        handle.getIntegers().write(2, (int) (value * 8.0));
    }

#end
#end
#No. 186524
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Retrieve the volumne.
     * <p>
     * One (1) is 100%, can be more.
     * @return The current Volume
    */

#Code:
    public float getVolume() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186525
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Set the volume.
     * <p>
     * One (1) is 100%, can be more.
     * @param value - new value.
    */

#Code:
    public void setVolume(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186526
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Retrieve the pitch.
     * <p>
     * One (1) is 100%, can be up to 3.9.
     * @return The current Pitch
    */

#Code:
    public float getPitch() {
        return handle.getIntegers().read(3) / 63.0F;
    }

#end
#end
#No. 186527
#File: E:\bishe\1\WrapperPlayServerNamedSoundEffect.java
#Comment:
    /**
     * Set the pitch.
     * <p>
     * One (1) is 100%, can be up to 3.9.
     * @param value - new value.
    */

#Code:
    public void setPitch(float value) {
        handle.getIntegers().write(3, (int) (value * 63.0F));
    }

#end
#end
#No. 186528
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Retrieve a unique id number for the window to be displayed. 
     * <p>
     * Notchian server implementation is a counter, starting at 1.
     * @return The current Window id
    */

#Code:
    public byte getWindowId() {
        return (byte) handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186529
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Set a unique id number for the window to be displayed. Notchian server implementation is a counter, starting at 1..
     * @param value - new value.
    */

#Code:
    public void setWindowId(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186530
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Retrieve the window type to use for display. 
     * @return The current inventory type
    */

#Code:
    public InventoryType getInventoryType() {
    	int id = handle.getIntegers().read(1);
    	
    	if (id >= 0 && id <= inventoryByID.size())
    		return inventoryByID.get(id);
    	else
    		throw new IllegalArgumentException("Cannot find inventory type " + id);
    }

#end
#end
#No. 186531
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Set the window type to use for display. 
     * @param value - new value.
    */

#Code:
    public void setInventoryType(InventoryType value) {
    	int id = inventoryByID.indexOf(value);
    	
    	if (id > 0)
    		handle.getIntegers().write(1, id);
    	else
    		throw new IllegalArgumentException("Cannot find the ID of " + value);
    }

#end
#end
#No. 186532
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Retrieve the title of the window..
     * @return The current Window title
    */

#Code:
    public String getWindowTitle() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186533
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Set the title of the window..
     * @param value - new value.
    */

#Code:
    public void setWindowTitle(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186534
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Retrieve number of slots in the window.
     * <p>
     * This excludes the number of slots in the player inventory.
     * @return The current Number of Slots
    */

#Code:
    public byte getNumberOfSlots() {
        return handle.getIntegers().read(2).byteValue();
    }

#end
#end
#No. 186535
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Set number of slots in the window
     * <p>
     * This excludes the number of slots in the player inventory.
     * @param value - new value.
    */

#Code:
    public void setNumberOfSlots(byte value) {
        handle.getIntegers().write(2, (int) value);
    }

#end
#end
#No. 186536
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Set whether or not the title will be used as is.
     * <p>
     * If false, the client will look up a string like "window.minecart". If true, the client uses what the server provides. 
     * @param value - new value.
    */

#Code:
    public void setTitleExact(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186537
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Retrieve whether or not the title will be used as is.
     * <p>
     * If false, the client will look up a string like "window.minecart". If true, the client uses what the server provides. 
     * @return TRUE if it is, FALSE otherwise.
    */

#Code:
    public boolean isTitleExact() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186538
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Retrieve the entity horse's entity ID.
     * <p>
     * Only sent when window type is equal to 11 
     * @return The unknown field.
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(3);
    }

#end
#end
#No. 186539
#File: E:\bishe\1\WrapperPlayServerOpenWindow.java
#Comment:
    /**
     * Set the entity horse's entity ID.
     * <p>
     * Only sent when window type is equal to 11 
     * @param value - new value of the unknown field.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(3, value);
    }

#end
#end
#No. 186540
#File: E:\bishe\1\WrapperPlayServerPlayerInfo.java
#Comment:
    /**
     * Retrieve the player name.
     * <p>
     * Supports chat colouring. limited to 16 characters.
     * @return The current Player name
    */

#Code:
    public String getPlayerName() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186541
#File: E:\bishe\1\WrapperPlayServerPlayerInfo.java
#Comment:
    /**
     * Set the player name.
     * <p>
     * Supports chat colouring. Limited to 16 characters.
     * @param value - new value.
    */

#Code:
    public void setPlayerName(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186542
#File: E:\bishe\1\WrapperPlayServerPlayerInfo.java
#Comment:
    /**
     * Retrieve whether or not to remove the given player from the list of online players.
     * @return The current Online
    */

#Code:
    public boolean getOnline() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186543
#File: E:\bishe\1\WrapperPlayServerPlayerInfo.java
#Comment:
    /**
     * Set whether or not to remove the given player from the list of online players.
     * @param value - new value.
    */

#Code:
    public void setOnline(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186544
#File: E:\bishe\1\WrapperPlayServerPlayerInfo.java
#Comment:
    /**
     * Retrieve ping in milliseconds.
     * @return The current Ping
    */

#Code:
    public short getPing() {
        return handle.getIntegers().read(0).shortValue();
    }

#end
#end
#No. 186545
#File: E:\bishe\1\WrapperPlayServerPlayerInfo.java
#Comment:
    /**
     * Set ping in milliseconds.
     * @param value - new value.
    */

#Code:
    public void setPing(short value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186546
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Retrieve absolute position.
     * @return The current X
    */

#Code:
    public double getX() {
        return handle.getDoubles().read(0);
    }

#end
#end
#No. 186547
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Set absolute position.
     * @param value - new value.
    */

#Code:
    public void setX(double value) {
        handle.getDoubles().write(0, value);
    }

#end
#end
#No. 186548
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Retrieve absolute position.
     * @return The current Y
    */

#Code:
    public double getY() {
        return handle.getDoubles().read(1);
    }

#end
#end
#No. 186549
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Set absolute position.
     * @param value - new value.
    */

#Code:
    public void setY(double value) {
        handle.getDoubles().write(1, value);
    }

#end
#end
#No. 186550
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Retrieve absolute position.
     * @return The current Z
    */

#Code:
    public double getZ() {
        return handle.getDoubles().read(2);
    }

#end
#end
#No. 186551
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Set absolute position.
     * @param value - new value.
    */

#Code:
    public void setZ(double value) {
        handle.getDoubles().write(2, value);
    }

#end
#end
#No. 186552
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Retrieve absolute rotation on the X Axis, in degrees.
     * @return The current Yaw
    */

#Code:
    public float getYaw() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186553
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Set absolute rotation on the X Axis, in degrees.
     * @param value - new value.
    */

#Code:
    public void setYaw(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186554
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Retrieve absolute rotation on the Y Axis, in degrees.
     * @return The current Pitch
    */

#Code:
    public float getPitch() {
        return handle.getFloat().read(1);
    }

#end
#end
#No. 186555
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Set absolute rotation on the Y Axis, in degrees.
     * @param value - new value.
    */

#Code:
    public void setPitch(float value) {
        handle.getFloat().write(1, value);
    }

#end
#end
#No. 186556
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Retrieve true if the client is on the ground, False otherwise.
     * @return The current On Ground
    */

#Code:
    public boolean getOnGround() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186557
#File: E:\bishe\1\WrapperPlayServerPosition.java
#Comment:
    /**
     * Set true if the client is on the ground, False otherwise.
     * @param value - new value.
    */

#Code:
    public void setOnGround(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186558
#File: E:\bishe\1\WrapperPlayServerRelEntityMove.java
#Comment:
    /**
     * Retrieve the relative movement in the x axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @return The current dX
    */

#Code:
    public double getDx() {
        return handle.getBytes().read(0) / 32.0D;
    }

#end
#end
#No. 186559
#File: E:\bishe\1\WrapperPlayServerRelEntityMove.java
#Comment:
    /**
     * Set the relative movement in the x axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @param value - new value.
    */

#Code:
    public void setDx(double value) {
    	if (Math.abs(value) > 4)
    		throw new IllegalArgumentException("Displacement cannot exceed 4 meters.");
        handle.getBytes().write(0, (byte) Math.min(Math.floor(value * 32.0D), 127));
    }

#end
#end
#No. 186560
#File: E:\bishe\1\WrapperPlayServerRelEntityMove.java
#Comment:
    /**
     * Retrieve the relative movement in the y axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @return The current dY
    */

#Code:
    public double getDy() {
        return handle.getBytes().read(1) / 32.0D;
    }

#end
#end
#No. 186561
#File: E:\bishe\1\WrapperPlayServerRelEntityMove.java
#Comment:
    /**
     * Set the relative movement in the y axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @param value - new value.
    */

#Code:
    public void setDy(double value) {
    	if (Math.abs(value) > 4)
    		throw new IllegalArgumentException("Displacement cannot exceed 4 meters.");
        handle.getBytes().write(1, (byte) Math.min(Math.floor(value * 32.0D), 127));
    }

#end
#end
#No. 186562
#File: E:\bishe\1\WrapperPlayServerRelEntityMove.java
#Comment:
    /**
     * Retrieve the relative movement in the z axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @return The current dZ
    */

#Code:
    public double getDz() {
        return handle.getBytes().read(2) / 32.0D;
    }

#end
#end
#No. 186563
#File: E:\bishe\1\WrapperPlayServerRelEntityMove.java
#Comment:
    /**
     * Set the relative movement in the z axis.
     * <p>
     * Note that this cannot exceed 4 blocks in either direction.
     * @param value - new value.
    */

#Code:
    public void setDz(double value) {
    	if (Math.abs(value) > 4)
    		throw new IllegalArgumentException("Displacement cannot exceed 4 meters.");
        handle.getBytes().write(2, (byte) Math.min(Math.floor(value * 32.0D), 127));
    }

#end
#end
#No. 186564
#File: E:\bishe\1\WrapperPlayServerRemoveEntityEffect.java
#Comment:
    /**
     * Retrieve entity ID of a player.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186565
#File: E:\bishe\1\WrapperPlayServerRemoveEntityEffect.java
#Comment:
    /**
     * Set entity ID of a player.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186566
#File: E:\bishe\1\WrapperPlayServerRemoveEntityEffect.java
#Comment:
    /**
     * Retrieve the entity.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186567
#File: E:\bishe\1\WrapperPlayServerRemoveEntityEffect.java
#Comment:
    /**
     * Retrieve the entity.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186568
#File: E:\bishe\1\WrapperPlayServerRemoveEntityEffect.java
#Comment:
    /**
     * Retrieve the ID of the effect to remove.
     * @return The current Effect ID
    */

#Code:
    public byte getEffectId() {
        return handle.getBytes().read(1);
    }

#end
#end
#No. 186569
#File: E:\bishe\1\WrapperPlayServerRemoveEntityEffect.java
#Comment:
    /**
     * Set the ID of the effect to remove.
     * @param value - new value.
    */

#Code:
    public void setEffectId(byte value) {
        handle.getBytes().write(1, value);
    }

#end
#end
#No. 186570
#File: E:\bishe\1\WrapperPlayServerRemoveEntityEffect.java
#Comment:
    /**
     * Retrieve the effect.
     * @return The current effect
    */

#Code:
    @SuppressWarnings("deprecation")
	public PotionEffectType getEffect() {
        return PotionEffectType.getById(getEffectId());
    }

#end
#end
#No. 186571
#File: E:\bishe\1\WrapperPlayServerRemoveEntityEffect.java
#Comment:
    /**
     * Set the effect id.
     * @param value - new value.
    */

#Code:
    @SuppressWarnings("deprecation")
	public void setEffect(PotionEffectType value) {
        setEffectId((byte) value.getId());
    }

#end
#end
#No. 186572
#File: E:\bishe\1\WrapperPlayServerRespawn.java
#Comment:
    /**
     * Retrieve -1: The Nether, 0: The Overworld, 1: The End.
     * @return The current Dimension
    */

#Code:
    public int getDimension() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186573
#File: E:\bishe\1\WrapperPlayServerRespawn.java
#Comment:
    /**
     * Set -1: The Nether, 0: The Overworld, 1: The End.
     * @param value - new value.
    */

#Code:
    public void setDimension(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186574
#File: E:\bishe\1\WrapperPlayServerRespawn.java
#Comment:
    /**
     * Retrieve the difficulty level.
     * @return The current Difficulty
    */

#Code:
    public Difficulty getDifficulty() {
        return handle.getDifficulties().read(0);
    }

#end
#end
#No. 186575
#File: E:\bishe\1\WrapperPlayServerRespawn.java
#Comment:
    /**
     * Set the difficulty level. 
     * @param value - new value.
    */

#Code:
    public void setDifficulty(Difficulty value) {
        handle.getDifficulties().write(0, value);
    }

#end
#end
#No. 186576
#File: E:\bishe\1\WrapperPlayServerRespawn.java
#Comment:
    /**
     * Retrieve the game mode of the current player.
     * @return The current game mode
    */

#Code:
    public NativeGameMode getGameMode() {
        return handle.getGameModes().read(0);
    }

#end
#end
#No. 186577
#File: E:\bishe\1\WrapperPlayServerRespawn.java
#Comment:
    /**
     * Set the game mode of the current player.
     * @param mode - new value.
    */

#Code:
    public void setGameMode(NativeGameMode mode) {
        handle.getGameModes().write(0, mode);
    }

#end
#end
#No. 186578
#File: E:\bishe\1\WrapperPlayServerRespawn.java
#Comment:
    /**
     * Retrieve the current level type.
     * @return The current level type
    */

#Code:
    public WorldType getLevelType() {
        return handle.getWorldTypeModifier().read(0);
    }

#end
#end
#No. 186579
#File: E:\bishe\1\WrapperPlayServerRespawn.java
#Comment:
    /**
     * Set see 0x01 login.
     * @param value - new world type.
    */

#Code:
    public void setLevelType(WorldType value) {
        handle.getWorldTypeModifier().write(0, value);
    }

#end
#end
#No. 186580
#File: E:\bishe\1\WrapperPlayServerScoreboardDisplayObjective.java
#Comment:
    /**
     * Retrieve the {@link Positions} of the scoreboard.
     * @return The current Position
    */

#Code:
    public byte getPosition() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186581
#File: E:\bishe\1\WrapperPlayServerScoreboardDisplayObjective.java
#Comment:
    /**
     * Set the {@link Positions} of the scoreboard. 
     * @param value - new value.
    */

#Code:
    public void setPosition(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186582
#File: E:\bishe\1\WrapperPlayServerScoreboardDisplayObjective.java
#Comment:
    /**
     * Retrieve the unique name for the scoreboard to be displayed..
     * @return The current Score Name
    */

#Code:
    public String getScoreName() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186583
#File: E:\bishe\1\WrapperPlayServerScoreboardDisplayObjective.java
#Comment:
    /**
     * Set the unique name for the scoreboard to be displayed..
     * @param value - new value.
    */

#Code:
    public void setScoreName(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186584
#File: E:\bishe\1\WrapperPlayServerScoreboardObjective.java
#Comment:
    /**
     * Retrieve an unique name for the objective.
     * @return The current Objective name
    */

#Code:
    public String getObjectiveName() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186585
#File: E:\bishe\1\WrapperPlayServerScoreboardObjective.java
#Comment:
    /**
     * Set an unique name for the objective.
     * @param value - new value.
    */

#Code:
    public void setObjectiveName(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186586
#File: E:\bishe\1\WrapperPlayServerScoreboardObjective.java
#Comment:
    /**
     * Retrieve the text to be displayed for the score.
     * @return The current Objective value
    */

#Code:
    public String getObjectiveValue() {
        return handle.getStrings().read(1);
    }

#end
#end
#No. 186587
#File: E:\bishe\1\WrapperPlayServerScoreboardObjective.java
#Comment:
    /**
     * Set the text to be displayed for the score.
     * @param value - new value.
    */

#Code:
    public void setObjectiveValue(String value) {
        handle.getStrings().write(1, value);
    }

#end
#end
#No. 186588
#File: E:\bishe\1\WrapperPlayServerScoreboardObjective.java
#Comment:
    /**
     * Retrieve the current packet {@link Modes}. 
     * <p>
     * This determines if the objective is added or removed.
     * @see {@link WrapperPlayServerScoreboardObjective.Modes}
     * @return The current Create/Remove
    */

#Code:
    public byte getPacketMode() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186589
#File: E:\bishe\1\WrapperPlayServerScoreboardObjective.java
#Comment:
    /**
     * Set the current packet {@link Modes}. 
     * <p>
     * This determines if the objective is added or removed.
     * @see {@link WrapperPlayServerScoreboardObjective.Modes}
     * @param value - new value.
    */

#Code:
    public void setPacketMode(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186590
#File: E:\bishe\1\WrapperPlayServerScoreboardScore.java
#Comment:
    /**
     * Retrieve an unique name to be displayed in the list..
     * @return The current Item Name
    */

#Code:
    public String getItemName() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186591
#File: E:\bishe\1\WrapperPlayServerScoreboardScore.java
#Comment:
    /**
     * Set an unique name to be displayed in the list..
     * @param value - new value.
    */

#Code:
    public void setItemName(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186592
#File: E:\bishe\1\WrapperPlayServerScoreboardScore.java
#Comment:
    /**
     * Retrieve the current packet {@link Modes}.
     * <p>
     * This determines if the objective is added or removed.
     * @return The current mode.
    */

#Code:
    public byte getPacketMode() {
        return handle.getIntegers().read(1).byteValue();
    }

#end
#end
#No. 186593
#File: E:\bishe\1\WrapperPlayServerScoreboardScore.java
#Comment:
    /**
     * Set the current packet {@link Modes}.
     * <p>
     * This determines if the objective is added or removed.
     * @param value - new value.
    */

#Code:
    public void setPacketMode(byte value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186594
#File: E:\bishe\1\WrapperPlayServerScoreboardScore.java
#Comment:
    /**
     * Retrieve the unique name for the scoreboard to be updated. Only sent when setting a score.
     * @return The current Score Name
    */

#Code:
    public String getScoreName() {
    	return handle.getStrings().read(1);
    }

#end
#end
#No. 186595
#File: E:\bishe\1\WrapperPlayServerScoreboardScore.java
#Comment:
    /**
     * Set the unique name for the scoreboard to be updated. Only sent when setting a score.
     * @param value - new value.
    */

#Code:
    public void setScoreName(String value) {
    	handle.getStrings().write(1, (String) value);
    }

#end
#end
#No. 186596
#File: E:\bishe\1\WrapperPlayServerScoreboardScore.java
#Comment:
    /**
     * Retrieve the score to be displayed next to the entry. Only sent when setting a score.
     * @return The current Value
    */

#Code:
    public int getValue() {
    	return handle.getIntegers().read(0); 
    }

#end
#end
#No. 186597
#File: E:\bishe\1\WrapperPlayServerScoreboardScore.java
#Comment:
    /**
     * Set the score to be displayed next to the entry. Only sent when setting a score.
     * @param value - new value.
    */

#Code:
    public void setValue(int value) {
    	handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186598
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Retrieve an unique name for the team. (Shared with scoreboard)..
     * @return The current Team Name
    */

#Code:
    public String getTeamName() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186599
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Set an unique name for the team. (Shared with scoreboard)..
     * @param value - new value.
    */

#Code:
    public void setTeamName(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186600
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Retrieve the current packet {@link Modes}.
     * <p>
     * This determines whether or not team information is added or removed.
     * @return The current packet mode.
    */

#Code:
    public byte getPacketMode() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186601
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Set the current packet {@link Modes}.
     * <p>
     * This determines whether or not team information is added or removed.
     * @param value - new value.
    */

#Code:
    public void setPacketMode(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186602
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Retrieve the team display name.
     * <p>
     * A team must be created or updated.
     * @return The current display name.
    */

#Code:
    public String getTeamDisplayName() {
        return handle.getStrings().read(1);
    }

#end
#end
#No. 186603
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Set the team display name.
     * <p>
     * A team must be created or updated.
     * @param value - new value.
    */

#Code:
    public void setTeamDisplayName(String value) {
    	handle.getStrings().write(1, value);
    }

#end
#end
#No. 186604
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Retrieve the team prefix. This will be inserted before the name of each team member.
     * <p>
     * A team must be created or updated.
     * @return The current Team Prefix
    */

#Code:
    public String getTeamPrefix() {
        return handle.getStrings().read(2);
    }

#end
#end
#No. 186605
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Set the team prefix. This will be inserted before the name of each team member.
     * <p>
     * A team must be created or updated.
     * @param value - new value.
    */

#Code:
    public void setTeamPrefix(String value) {
        handle.getStrings().write(2, value);
    }

#end
#end
#No. 186606
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Set the team suffix. This will be inserted after the name of each team member.
     * <p>
     * A team must be created or updated.
     * @return The current Team Suffix
    */

#Code:
    public String getTeamSuffix() {
        return handle.getStrings().read(3);
    }

#end
#end
#No. 186607
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Set only if Mode = 0 or 2. This will be after before the name of each team member.
     * <p>
     * A team must be created or updated.
     * @param value - new value.
    */

#Code:
    public void setTeamSuffix(String value) {
        handle.getStrings().write(3, value);
    }

#end
#end
#No. 186608
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Retrieve whether or not friendly fire is enabled.
     * <p>
     * A team must be created or updated.
     * @return The current Friendly fire
    */

#Code:
    public byte getFriendlyFire() {
        return handle.getIntegers().read(1).byteValue();
    }

#end
#end
#No. 186609
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Set whether or not friendly fire is enabled.
     * <p>
     * A team must be created or updated.
     * @param value - new value.
    */

#Code:
    public void setFriendlyFire(byte value) {
    	handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186610
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Retrieve the list of player names.
     * <p>
     * Packet mode must be one of the following for this to be valid:
     * <ul>
     *  <li>{@link Modes#TEAM_CREATED}</li>
     *  <li>{@link Modes#PLAYERS_ADDED}</li>
     *  <li>{@link Modes#PLAYERS_REMOVED}</li>
     * </ul>
     * @return A list of player names.
    */

#Code:
    @SuppressWarnings("unchecked")
	public Collection<String> getPlayers() {
        return handle.getSpecificModifier(Collection.class).read(0);
    }

#end
#end
#No. 186611
#File: E:\bishe\1\WrapperPlayServerScoreboardTeam.java
#Comment:
    /**
     * Set the list of player names.
     * <p>
     * Packet mode must be one of the following for this to be valid:
     * <ul>
     *  <li>{@link Modes#TEAM_CREATED}</li>
     *  <li>{@link Modes#PLAYERS_ADDED}</li>
     *  <li>{@link Modes#PLAYERS_REMOVED}</li>
     * </ul>
     * @param value - new value.
    */

#Code:
    public void setPlayers(Collection<String> players) {
    	handle.getSpecificModifier(Collection.class).write(0, players);
    }

#end
#end
#No. 186612
#File: E:\bishe\1\WrapperPlayServerSetSlot.java
#Comment:
    /**
     * Retrieve the window which is being updated. 
     * <p>
     * Use 0 for the player inventory. This packet will only be sent for the currently opened window while the player is 
     * performing actions, even if it affects the player inventory. After the window is closed, a number of these packets
     * are sent to update the player's inventory window.
     * @return The current Window id
    */

#Code:
    public byte getWindowId() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186613
#File: E:\bishe\1\WrapperPlayServerSetSlot.java
#Comment:
    /**
     * Set the window which is being updated. 
     * <p>
     * Use 0 for the player inventory. This packet will only be sent for the currently opened window while the player is 
     * performing actions, even if it affects the player inventory. After the window is closed, a number of these packets
     * are sent to update the player's inventory window.
     * @param value - new value.
    */

#Code:
    public void setWindowId(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186614
#File: E:\bishe\1\WrapperPlayServerSetSlot.java
#Comment:
    /**
     * Retrieve the index of the slot that should be changed.
     * @return The current slot
    */

#Code:
    public short getSlot() {
        return handle.getIntegers().read(1).shortValue();
    }

#end
#end
#No. 186615
#File: E:\bishe\1\WrapperPlayServerSetSlot.java
#Comment:
    /**
     * Set the index of the slot that should be changed.
     * @param value - new value.
    */

#Code:
    public void setSlot(short value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186616
#File: E:\bishe\1\WrapperPlayServerSetSlot.java
#Comment:
    /**
     * Retrieve the new updated item stack.
     * @return The current Slot data
    */

#Code:
    public ItemStack getSlotData() {
        return handle.getItemModifier().read(0);
    }

#end
#end
#No. 186617
#File: E:\bishe\1\WrapperPlayServerSetSlot.java
#Comment:
    /**
     * Set the new item stack.
     * @param value - new value.
    */

#Code:
    public void setSlotData(ItemStack value) {
        handle.getItemModifier().write(0, value);
    }

#end
#end
#No. 186618
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve entity ID of the Object.
     * @return The current EID
    */

#Code:
    public int getEntityID() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186619
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the entity that will be spawned.
     * @param world - the current world of the entity.
     * @return The spawned entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186620
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the entity that will be spawned.
     * @param event - the packet event.
     * @return The spawned entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186621
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set entity ID of the Object.
     * @param value - new value.
    */

#Code:
    public void setEntityID(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186622
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the type of object. See {@link ObjectTypes}
     * @return The current Type
    */

#Code:
    public int getType() {
        return handle.getIntegers().read(9);
    }

#end
#end
#No. 186623
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set the type of object. See {@link ObjectTypes}.
     * @param value - new value.
    */

#Code:
    public void setType(int value) {
        handle.getIntegers().write(9, value);
    }

#end
#end
#No. 186624
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the x position of the object.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current X
    */

#Code:
    public double getX() {
        return handle.getIntegers().read(1) / 32.0D;
    }

#end
#end
#No. 186625
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set the x position of the object.
     * @param value - new value.
    */

#Code:
    public void setX(double value) {
        handle.getIntegers().write(1, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186626
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the y position of the object.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current y
    */

#Code:
    public double getY() {
        return handle.getIntegers().read(2) / 32.0D;
    }

#end
#end
#No. 186627
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set the y position of the object.
     * @param value - new value.
    */

#Code:
    public void setY(double value) {
        handle.getIntegers().write(2, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186628
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the z position of the object.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current z
    */

#Code:
    public double getZ() {
        return handle.getIntegers().read(3) / 32.0D;
    }

#end
#end
#No. 186629
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set the z position of the object.
     * @param value - new value.
    */

#Code:
    public void setZ(double value) {
        handle.getIntegers().write(3, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186630
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the optional speed x.
     * <p>
     * This is ignored if {@link #getObjectData()} is zero.
     * @return The optional speed x.
    */

#Code:
    public double getOptionalSpeedX() {
        return handle.getIntegers().read(4) / 8000.0D;
    }

#end
#end
#No. 186631
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set the optional speed x.
     * @param value - new value.
    */

#Code:
    public void setOptionalSpeedX(double value) {
        handle.getIntegers().write(4, (int) (value * 8000.0D));
    }

#end
#end
#No. 186632
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the optional speed y.
     * <p>
     * This is ignored if {@link #getObjectData()} is zero.
     * @return The optional speed y.
    */

#Code:
    public double getOptionalSpeedY() {
        return handle.getIntegers().read(5) / 8000.0D;
    }

#end
#end
#No. 186633
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set the optional speed y.
     * @param value - new value.
    */

#Code:
    public void setOptionalSpeedY(double value) {
        handle.getIntegers().write(5, (int) (value * 8000.0D));
    }

#end
#end
#No. 186634
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the optional speed z.
     * <p>
     * This is ignored if {@link #getObjectData()} is zero.
     * @return The optional speed z.
    */

#Code:
    public double getOptionalSpeedZ() {
        return handle.getIntegers().read(6) / 8000.0D;
    }

#end
#end
#No. 186635
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set the optional speed z.
     * @param value - new value.
    */

#Code:
    public void setOptionalSpeedZ(double value) {
        handle.getIntegers().write(6, (int) (value * 8000.0D));
    }

#end
#end
#No. 186636
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the yaw.
     * @return The current Yaw
    */

#Code:
    public float getYaw() {
        return (handle.getIntegers().read(7) * 360.F) / 256.0F;
    }

#end
#end
#No. 186637
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set the yaw of the object spawned.
     * @param value - new yaw.
    */

#Code:
    public void setYaw(float value) {
        handle.getIntegers().write(7, (int) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186638
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve the pitch.
     * @return The current pitch.
    */

#Code:
    public float getPitch() {
    	return (handle.getIntegers().read(8) * 360.F) / 256.0F;
    }

#end
#end
#No. 186639
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set the pitch.
     * @param value - new pitch.
    */

#Code:
    public void setPitch(float value) {
        handle.getIntegers().write(8, (int) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186640
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Retrieve object data.
     * <p>
     * The content depends on the object type:
     * <table border="1" cellpadding="4">
     *  <tr>
     *   <th>Object Type:</th>
     *   <th>Name:</th>
     *   <th>Description</th>
     *  </tr>
     *  <tr>
     *   <td>ITEM_FRAME</td>
     *   <td>Orientation</td>
     *   <td>0-3: South, West, North, East</td>
     *  </tr>
     *  <tr>
     *   <td>FALLING_BLOCK</td>
     *   <td>Block Type</td>
     *   <td>BlockID | (Metadata << 0xC)</td>
     *  </tr>
     *  <tr>
     *   <td>Projectiles</td>
     *   <td>Entity ID</td>
     *   <td>The entity ID of the thrower</td>
     *  </tr>
     *  <tr>
     *   <td>Splash Potions</td>
     *   <td>Data Value</td>
     *   <td>Potion data value.</td>
     *  </tr>
     * </table>
     * @return The current object Data
    */

#Code:
    public int getObjectData() {
        return handle.getIntegers().read(10);
    }

#end
#end
#No. 186641
#File: E:\bishe\1\WrapperPlayServerSpawnEntity.java
#Comment:
    /**
     * Set object Data.
     * <p>
     * The content depends on the object type. See {@link #getObjectData()} for more information.
     * @param value - new object data.
    */

#Code:
    public void setObjectData(int value) {
        handle.getIntegers().write(10, value);
    }

#end
#end
#No. 186642
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Retrieve the entity ID of the experience orb.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186643
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Retrieve the experience orb entity.
     * @param world - the current world of the entity.
     * @return The spawned entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186644
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Retrieve the experience orb entity.
     * @param event - the packet event.
     * @return The spawned entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186645
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Set the entity ID of the experience orb to spawn.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186646
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Retrieve the x position of the object.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current X
    */

#Code:
    public double getX() {
        return handle.getIntegers().read(1) / 32.0D;
    }

#end
#end
#No. 186647
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Set the x position of the object.
     * @param value - new value.
    */

#Code:
    public void setX(double value) {
        handle.getIntegers().write(1, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186648
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Retrieve the y position of the object.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current y
    */

#Code:
    public double getY() {
        return handle.getIntegers().read(2) / 32.0D;
    }

#end
#end
#No. 186649
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Set the y position of the object.
     * @param value - new value.
    */

#Code:
    public void setY(double value) {
        handle.getIntegers().write(2, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186650
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Retrieve the z position of the object.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current z
    */

#Code:
    public double getZ() {
        return handle.getIntegers().read(3) / 32.0D;
    }

#end
#end
#No. 186651
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Set the z position of the object.
     * @param value - new value.
    */

#Code:
    public void setZ(double value) {
        handle.getIntegers().write(3, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186652
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Retrieve the number of experience orbs to spawn.
     * @return The current count
    */

#Code:
    public short getCount() {
        return handle.getIntegers().read(4).shortValue();
    }

#end
#end
#No. 186653
#File: E:\bishe\1\WrapperPlayServerSpawnEntityExperienceOrb.java
#Comment:
    /**
     * Set the number of experience orbs to spawn.
     * @param value - new value.
    */

#Code:
    public void setCount(short value) {
        handle.getIntegers().write(4, (int) value);
    }

#end
#end
#No. 186654
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve entity ID.
     * @return The current EID
    */

#Code:
    public int getEntityID() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186655
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the entity that will be spawned.
     * @param world - the current world of the entity.
     * @return The spawned entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186656
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the entity that will be spawned.
     * @param event - the packet event.
     * @return The spawned entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186657
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set entity ID.
     * @param value - new value.
    */

#Code:
    public void setEntityID(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186658
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the type of mob.
     * @return The current Type
    */

#Code:
    @SuppressWarnings("deprecation")
	public EntityType getType() {
        return EntityType.fromId(handle.getIntegers().read(1));
    }

#end
#end
#No. 186659
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the type of mob.
     * @param value - new value.
    */

#Code:
    @SuppressWarnings("deprecation")
	public void setType(EntityType value) {
        handle.getIntegers().write(1, (int) value.getTypeId());
    }

#end
#end
#No. 186660
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the x position of the object.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current X
    */

#Code:
    public double getX() {
        return handle.getIntegers().read(2) / 32.0D;
    }

#end
#end
#No. 186661
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the x position of the object.
     * @param value - new value.
    */

#Code:
    public void setX(double value) {
        handle.getIntegers().write(2, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186662
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the y position of the object.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current y
    */

#Code:
    public double getY() {
        return handle.getIntegers().read(3) / 32.0D;
    }

#end
#end
#No. 186663
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the y position of the object.
     * @param value - new value.
    */

#Code:
    public void setY(double value) {
        handle.getIntegers().write(3, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186664
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the z position of the object.
     * <p>
     * Note that the coordinate is rounded off to the nearest 1/32 of a meter.
     * @return The current z
    */

#Code:
    public double getZ() {
        return handle.getIntegers().read(4) / 32.0D;
    }

#end
#end
#No. 186665
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the z position of the object.
     * @param value - new value.
    */

#Code:
    public void setZ(double value) {
        handle.getIntegers().write(4, (int) Math.floor(value * 32.0D));
    }

#end
#end
#No. 186666
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the yaw.
     * @return The current Yaw
    */

#Code:
    public float getYaw() {
        return (handle.getBytes().read(0) * 360.F) / 256.0F;
    }

#end
#end
#No. 186667
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the yaw of the spawned mob.
     * @param value - new yaw.
    */

#Code:
    public void setYaw(float value) {
        handle.getBytes().write(0, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186668
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the pitch.
     * @return The current pitch
    */

#Code:
    public float getHeadPitch() {
        return (handle.getBytes().read(1) * 360.F) / 256.0F;
    }

#end
#end
#No. 186669
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the pitch of the spawned mob.
     * @param value - new pitch.
    */

#Code:
    public void setHeadPitch(float value) {
        handle.getBytes().write(1, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186670
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the yaw of the mob's head.
     * @return The current yaw.
    */

#Code:
    public float getHeadYaw() {
        return (handle.getBytes().read(2) * 360.F) / 256.0F;
    }

#end
#end
#No. 186671
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the yaw of the mob's head.
     * @param value - new yaw.
    */

#Code:
    public void setHeadYaw(float value) {
        handle.getBytes().write(2, (byte) (value * 256.0F / 360.0F));
    }

#end
#end
#No. 186672
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the velocity in the x axis.
     * @return The current velocity X
    */

#Code:
    public double getVelocityX() {
        return handle.getIntegers().read(5) / 8000.0D;
    }

#end
#end
#No. 186673
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the velocity in the x axis.
     * @param value - new value.
    */

#Code:
    public void setVelocityX(double value) {
        handle.getIntegers().write(5, (int) (value * 8000.0D));
    }

#end
#end
#No. 186674
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the velocity in the y axis.
     * @return The current velocity y
    */

#Code:
    public double getVelocityY() {
        return handle.getIntegers().read(6) / 8000.0D;
    }

#end
#end
#No. 186675
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the velocity in the y axis.
     * @param value - new value.
    */

#Code:
    public void setVelocityY(double value) {
        handle.getIntegers().write(6, (int) (value * 8000.0D));
    }

#end
#end
#No. 186676
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the velocity in the z axis.
     * @return The current velocity z
    */

#Code:
    public double getVelocityZ() {
        return handle.getIntegers().read(7) / 8000.0D;
    }

#end
#end
#No. 186677
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the velocity in the z axis.
     * @param value - new value.
    */

#Code:
    public void setVelocityZ(double value) {
        handle.getIntegers().write(7, (int) (value * 8000.0D));
    }

#end
#end
#No. 186678
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Retrieve the data watcher. 
     * <p>
     * Content varies by mob, see Entities.
     * @return The current Metadata
    */

#Code:
    public WrappedDataWatcher getMetadata() {
        return handle.getDataWatcherModifier().read(0);
    }

#end
#end
#No. 186679
#File: E:\bishe\1\WrapperPlayServerSpawnEntityLiving.java
#Comment:
    /**
     * Set the data watcher.
     * @param value - new value.
    */

#Code:
    public void setMetadata(WrappedDataWatcher value) {
        handle.getDataWatcherModifier().write(0, value);
    }

#end
#end
#No. 186680
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Retrieve unique entity ID.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186681
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Retrieve the entity of the painting that will be spawned.
     * @param world - the current world of the entity.
     * @return The spawned entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186682
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Retrieve the entity of the painting that will be spawned.
     * @param event - the packet event.
     * @return The spawned entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186683
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Set unique entity ID.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186684
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Retrieve name of the painting; max length 13 (length of "SkullAndRoses").
     * @return The current Title
    */

#Code:
    public String getTitle() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186685
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Set name of the painting; max length 13 (length of "SkullAndRoses").
     * @param value - new value.
    */

#Code:
    public void setTitle(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186686
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Retrieve center X coordinate.
     * @return The current X
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186687
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Set center X coordinate.
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(1, value);
    }

#end
#end
#No. 186688
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Retrieve center Y coordinate.
     * @return The current Y
    */

#Code:
    public int getY() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186689
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Set center Y coordinate.
     * @param value - new value.
    */

#Code:
    public void setY(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186690
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Retrieve center Z coordinate.
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(3);
    }

#end
#end
#No. 186691
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Set center Z coordinate.
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(3, value);
    }

#end
#end
#No. 186692
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Retrieve direction the painting faces.
     * <p>
     * Here zero is -z, one is -x, two is +z and three is +x.
     * @return The current Direction
    */

#Code:
    public int getDirection() {
        return handle.getIntegers().read(4);
    }

#end
#end
#No. 186693
#File: E:\bishe\1\WrapperPlayServerSpawnEntityPainting.java
#Comment:
    /**
     * Set direction the painting faces.
     * <p>
     * Here zero is -z, one is -x, two is +z and three is +x.
     * @param value - new value.
    */

#Code:
    public void setDirection(int value) {
        handle.getIntegers().write(4, value);
    }

#end
#end
#No. 186694
#File: E:\bishe\1\WrapperPlayServerSpawnEntityWeather.java
#Comment:
    /**
     * Retrieve the entity ID of the thunderbolt.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186695
#File: E:\bishe\1\WrapperPlayServerSpawnEntityWeather.java
#Comment:
    /**
     * Set the entity ID of the thunderbolt.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186696
#File: E:\bishe\1\WrapperPlayServerSpawnEntityWeather.java
#Comment:
    /**
     * Retrieve the global entity type.
     * <p>
     * Currently always 1 for thunderbolt.
     * @return The current Type
    */

#Code:
    public byte getType() {
        return handle.getIntegers().read(4).byteValue();
    }

#end
#end
#No. 186697
#File: E:\bishe\1\WrapperPlayServerSpawnEntityWeather.java
#Comment:
    /**
     * Set the global entity type.
     * <p>
     * Currently always 1 for thunderbolt.
     * @param value - new value.
    */

#Code:
    public void setType(byte value) {
        handle.getIntegers().write(4, (int) value);
    }

#end
#end
#No. 186698
#File: E:\bishe\1\WrapperPlayServerSpawnEntityWeather.java
#Comment:
    /**
     * Retrieve the x coordinate of the thunderbolt.
     * @return The current X
    */

#Code:
    public double getX() {
        return handle.getIntegers().read(1) / 32.0D;
    }

#end
#end
#No. 186699
#File: E:\bishe\1\WrapperPlayServerSpawnEntityWeather.java
#Comment:
    /**
     * Set the x coordinate of the thunderbolt.
     * @param value - new value.
    */

#Code:
    public void setX(double value) {
        handle.getIntegers().write(1, (int) (value * 32.0D));
    }

#end
#end
#No. 186700
#File: E:\bishe\1\WrapperPlayServerSpawnEntityWeather.java
#Comment:
    /**
     * Retrieve the y coordinate of the thunderbolt.
     * @return The current y
    */

#Code:
    public double getY() {
        return handle.getIntegers().read(2) / 32.0D;
    }

#end
#end
#No. 186701
#File: E:\bishe\1\WrapperPlayServerSpawnEntityWeather.java
#Comment:
    /**
     * Set the y coordinate of the thunderbolt.
     * @param value - new value.
    */

#Code:
    public void setY(double value) {
        handle.getIntegers().write(2, (int) (value * 32.0D));
    }

#end
#end
#No. 186702
#File: E:\bishe\1\WrapperPlayServerSpawnEntityWeather.java
#Comment:
    /**
     * Retrieve the z coordinate of the thunderbolt.
     * @return The current z
    */

#Code:
    public double getZ() {
        return handle.getIntegers().read(3) / 32.0D;
    }

#end
#end
#No. 186703
#File: E:\bishe\1\WrapperPlayServerSpawnEntityWeather.java
#Comment:
    /**
     * Set the z coordinate of the thunderbolt.
     * @param value - new value.
    */

#Code:
    public void setZ(double value) {
        handle.getIntegers().write(3, (int) (value * 32.0D));
    }

#end
#end
#No. 186704
#File: E:\bishe\1\WrapperPlayServerSpawnPosition.java
#Comment:
    /**
     * Retrieve the X coordinate of the spawn point.
     * @return The current x coordinate.
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186705
#File: E:\bishe\1\WrapperPlayServerSpawnPosition.java
#Comment:
    /**
     * Set the X coordinate of the spawn point.
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186706
#File: E:\bishe\1\WrapperPlayServerSpawnPosition.java
#Comment:
    /**
     * Retrieve the Y coordinate of the spawn point.
     * @return The current Y
    */

#Code:
    public int getY() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186707
#File: E:\bishe\1\WrapperPlayServerSpawnPosition.java
#Comment:
    /**
     * Set the Y coordinate of the spawn point.
     * @param value - new value.
    */

#Code:
    public void setY(int value) {
        handle.getIntegers().write(1, value);
    }

#end
#end
#No. 186708
#File: E:\bishe\1\WrapperPlayServerSpawnPosition.java
#Comment:
    /**
     * Retrieve the Z coordinate of the spawn point.
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186709
#File: E:\bishe\1\WrapperPlayServerSpawnPosition.java
#Comment:
    /**
     * Set the Z coordinate of the spawn point..
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186710
#File: E:\bishe\1\WrapperPlayServerSpawnPosition.java
#Comment:
    /**
     * Set the spawn location using a vector.
     * @param point - the new spawn location.
     */

#Code:
    public void setLocation(Vector point) {
    	setX(point.getBlockX());
    	setY(point.getBlockY());
    	setZ(point.getBlockZ());
    }

#end
#end
#No. 186711
#File: E:\bishe\1\WrapperPlayServerSpawnPosition.java
#Comment:
    /**
     * Retrieve the spawn location as a vector.
     * @return The spawn location.
     */

#Code:
    public Vector getLocation() {
    	return new Vector(getX(), getY(), getZ());
    }

#end
#end
#No. 186712
#File: E:\bishe\1\WrapperPlayServerStatistics.java
#Comment:
    /**
     * Retrieve a map of every statistic in this packet.
     * <p>
     * Note that you must write back the map to save any changes.
     * @return Map of every statistics sent to the player.
    */

#Code:
    public Map<WrappedStatistic, Integer> getStatistics() {
        return handle.getStatisticMaps().read(0);
    }

#end
#end
#No. 186713
#File: E:\bishe\1\WrapperPlayServerStatistics.java
#Comment:
    /**
     * Set every statistic and associated integer value to send to the player.
     * @param changes - the changed map of statistics and data.
     */

#Code:
    public void setStatistics(Map<WrappedStatistic, Integer> changes) {
        handle.getStatisticMaps().write(0, changes);
    }

#end
#end
#No. 186714
#File: E:\bishe\1\WrapperPlayServerTabComplete.java
#Comment:
    /**
     * Retrieve the tab-completed text alternatives.
     * @return The current Text
    */

#Code:
    public String[] getText() {
        return handle.getStringArrays().read(0);
    }

#end
#end
#No. 186715
#File: E:\bishe\1\WrapperPlayServerTabComplete.java
#Comment:
    /**
     * Set the tab-completed text alternatives.
     * @param value - new values.
    */

#Code:
    public void setText(String[] value) {
        handle.getStringArrays().write(0, value);
    }

#end
#end
#No. 186716
#File: E:\bishe\1\WrapperPlayServerTileEntityData.java
#Comment:
    /**
     * Retrieve the x coordinate of the block associated with this tile entity.
     * @return The current X
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186717
#File: E:\bishe\1\WrapperPlayServerTileEntityData.java
#Comment:
    /**
     * Set the x coordinate of the block associated with this tile entity.
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186718
#File: E:\bishe\1\WrapperPlayServerTileEntityData.java
#Comment:
    /**
     * Retrieve the y coordinate of the block associated with this tile entity.
     * @return The current Y
    */

#Code:
    public short getY() {
        return handle.getIntegers().read(1).shortValue();
    }

#end
#end
#No. 186719
#File: E:\bishe\1\WrapperPlayServerTileEntityData.java
#Comment:
    /**
     * Set the y coordinate of the block associated with this tile entity.
     * @param value - new value.
    */

#Code:
    public void setY(short value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186720
#File: E:\bishe\1\WrapperPlayServerTileEntityData.java
#Comment:
    /**
     * Retrieve the z coordinate of the block associated with this tile entity.
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186721
#File: E:\bishe\1\WrapperPlayServerTileEntityData.java
#Comment:
    /**
     * Set the z coordinate of the block associated with this tile entity.
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186722
#File: E:\bishe\1\WrapperPlayServerTileEntityData.java
#Comment:
    /**
     * Retrieve the type of update to perform.
     * @return The current Action
    */

#Code:
    public byte getAction() {
        return handle.getIntegers().read(3).byteValue();
    }

#end
#end
#No. 186723
#File: E:\bishe\1\WrapperPlayServerTileEntityData.java
#Comment:
    /**
     * Set the type of update to perform.
     * @param value - new value.
    */

#Code:
    public void setAction(byte value) {
        handle.getIntegers().write(3, (int) value);
    }

#end
#end
#No. 186724
#File: E:\bishe\1\WrapperPlayServerTileEntityData.java
#Comment:
    /**
     * Retrieve the NBT data of the current tile entity.
     * @return The current tile entity.
    */

#Code:
    public NbtBase<?> getNbtData() {
        return handle.getNbtModifier().read(0);
    }

#end
#end
#No. 186725
#File: E:\bishe\1\WrapperPlayServerTileEntityData.java
#Comment:
    /**
     * Set the NBT data of the current tile entity.
     * @param value - new value.
    */

#Code:
    public void setNbtData(NbtBase<?> value) {
        handle.getNbtModifier().write(0, value);
    }

#end
#end
#No. 186726
#File: E:\bishe\1\WrapperPlayServerTransaction.java
#Comment:
    /**
     * Retrieve the id of the window that the action occurred in.
     * @return The current Window id
    */

#Code:
    public byte getWindowId() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186727
#File: E:\bishe\1\WrapperPlayServerTransaction.java
#Comment:
    /**
     * Set the id of the window that the action occurred in..
     * @param value - new value.
    */

#Code:
    public void setWindowId(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186728
#File: E:\bishe\1\WrapperPlayServerTransaction.java
#Comment:
    /**
     * Retrieve every action that is to be accepted has a unique number. 
     * <p>
     * This field corresponds to that number..
     * @return The current Action number
    */

#Code:
    public short getActionNumber() {
        return handle.getShorts().read(0);
    }

#end
#end
#No. 186729
#File: E:\bishe\1\WrapperPlayServerTransaction.java
#Comment:
    /**
     * Set every action that is to be accepted has a unique number. 
     * <p>
     * This field corresponds to that number.
     * @param value - new value.
    */

#Code:
    public void setActionNumber(short value) {
        handle.getShorts().write(0, value);
    }

#end
#end
#No. 186730
#File: E:\bishe\1\WrapperPlayServerTransaction.java
#Comment:
    /**
     * Retrieve whether or not the action was accepted.
     * @return The current Accepted?
    */

#Code:
    public boolean getAccepted() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186731
#File: E:\bishe\1\WrapperPlayServerTransaction.java
#Comment:
    /**
     * Set whether or not the action was accepted.
     * @param value - new value.
    */

#Code:
    public void setAccepted(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186732
#File: E:\bishe\1\WrapperPlayServerUpdateAttributes.java
#Comment:
    /**
     * Retrieve the entity's ID.
     * @return The current Entity ID
    */

#Code:
    public int getEntityId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186733
#File: E:\bishe\1\WrapperPlayServerUpdateAttributes.java
#Comment:
    /**
     * Set the entity's ID.
     * @param value - new value.
    */

#Code:
    public void setEntityId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186734
#File: E:\bishe\1\WrapperPlayServerUpdateAttributes.java
#Comment:
    /**
     * Retrieve the entity.
     * @param world - the current world of the entity.
     * @return The entity.
     */

#Code:
    public Entity getEntity(World world) {
    	return handle.getEntityModifier(world).read(0);
    }

#end
#end
#No. 186735
#File: E:\bishe\1\WrapperPlayServerUpdateAttributes.java
#Comment:
    /**
     * Retrieve the entity.
     * @param event - the packet event.
     * @return The entity.
     */

#Code:
    public Entity getEntity(PacketEvent event) {
    	return getEntity(event.getPlayer().getWorld());
    }

#end
#end
#No. 186736
#File: E:\bishe\1\WrapperPlayServerUpdateAttributes.java
#Comment:
    /**
     * Retrieve the collection of attributes associated with the entity.
     * @return The current attributes.
    */

#Code:
    public List<WrappedAttribute> getAttributes() {
        return handle.getAttributeCollectionModifier().read(0);
    }

#end
#end
#No. 186737
#File: E:\bishe\1\WrapperPlayServerUpdateAttributes.java
#Comment:
    /**
     * Set the new or updated attributes associated with the entity.
     * @param value - new/updated attributes.
    */

#Code:
    public void setAttributes(List<WrappedAttribute> value) {
        handle.getAttributeCollectionModifier().write(0, value);
    }

#end
#end
#No. 186738
#File: E:\bishe\1\WrapperPlayServerUpdateHealth.java
#Comment:
    /**
     * Retrieve the health of the current player.
     * <p>
     * Value zero or less is dead. 20 is the full HP.
     * @return The current Health
    */

#Code:
    public float getHealth() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186739
#File: E:\bishe\1\WrapperPlayServerUpdateHealth.java
#Comment:
    /**
     * Set the health of the current player.
     * <p>
     * Value zero or less is dead. 20 is the full HP.
     * @param value - new value.
    */

#Code:
    public void setHealth(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186740
#File: E:\bishe\1\WrapperPlayServerUpdateHealth.java
#Comment:
    /**
     * Retrieve the food level.
     * <p>
     * Valid range: 0 - 20.
     * @return The current food level.
    */

#Code:
    public short getFood() {
        return handle.getIntegers().read(0).shortValue();
    }

#end
#end
#No. 186741
#File: E:\bishe\1\WrapperPlayServerUpdateHealth.java
#Comment:
    /**
     * Set the food level.
     * <p>
     * Valid range: 0 - 20.
     * @param value - new value.
    */

#Code:
    public void setFood(short value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186742
#File: E:\bishe\1\WrapperPlayServerUpdateHealth.java
#Comment:
    /**
     * Retrieve the food saturation.
     * <p>
     * Varies from 0.0 to 5.0 in integer increments.
     * @return The current Food Saturation
    */

#Code:
    public float getFoodSaturation() {
        return handle.getFloat().read(1);
    }

#end
#end
#No. 186743
#File: E:\bishe\1\WrapperPlayServerUpdateHealth.java
#Comment:
    /**
     * Set the food saturation.
     * <p>
     * Varies from 0.0 to 5.0 in integer increments.
     * @param value - new value.
    */

#Code:
    public void setFoodSaturation(float value) {
        handle.getFloat().write(1, value);
    }

#end
#end
#No. 186744
#File: E:\bishe\1\WrapperPlayServerUpdateSign.java
#Comment:
    /**
     * Retrieve block X Coordinate.
     * @return The current X
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186745
#File: E:\bishe\1\WrapperPlayServerUpdateSign.java
#Comment:
    /**
     * Set block X Coordinate.
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186746
#File: E:\bishe\1\WrapperPlayServerUpdateSign.java
#Comment:
    /**
     * Retrieve block Y Coordinate.
     * @return The current Y
    */

#Code:
    public short getY() {
        return handle.getIntegers().read(1).shortValue();
    }

#end
#end
#No. 186747
#File: E:\bishe\1\WrapperPlayServerUpdateSign.java
#Comment:
    /**
     * Set block Y Coordinate.
     * @param value - new value.
    */

#Code:
    public void setY(short value) {
        handle.getIntegers().write(1, (int) value);
    }

#end
#end
#No. 186748
#File: E:\bishe\1\WrapperPlayServerUpdateSign.java
#Comment:
    /**
     * Retrieve block Z Coordinate.
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186749
#File: E:\bishe\1\WrapperPlayServerUpdateSign.java
#Comment:
    /**
     * Set block Z Coordinate.
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186750
#File: E:\bishe\1\WrapperPlayServerUpdateSign.java
#Comment:
    /**
     * Retrieve the location of the current particle.
     * @param event - the packet event.
     * @return The location.
     */

#Code:
    public Location getLocation(PacketEvent event) {
    	return new Location(event.getPlayer().getWorld(), getX(), getY(), getZ());
    }

#end
#end
#No. 186751
#File: E:\bishe\1\WrapperPlayServerUpdateSign.java
#Comment:
    /**
     * Set the location of the particle to send.
     * @param loc - the location.
     */

#Code:
    public void setLocation(Location loc) {
    	if (loc == null)
    		throw new IllegalArgumentException("Location cannot be NULL.");
    	setX(loc.getBlockX());
    	setY((short) loc.getBlockY());
    	setZ(loc.getBlockZ());
    }

#end
#end
#No. 186752
#File: E:\bishe\1\WrapperPlayServerUpdateSign.java
#Comment:
    /**
     * Retrieve the lines of text represented by a four-element String array.
     * @return The current lines.
    */

#Code:
    public String[] getLines() {
        return handle.getStringArrays().read(0);
    }

#end
#end
#No. 186753
#File: E:\bishe\1\WrapperPlayServerUpdateSign.java
#Comment:
    /**
     * Set the lines of text represented by a four-element String array..
     * @param value - new value.
    */

#Code:
    public void setLines(@Nonnull String[] lines) {
    	if (lines == null)
    		throw new IllegalArgumentException("Array cannot be NULL.");
    	if (lines.length != 4)
    		throw new IllegalArgumentException("The lines array must be four elements long.");
        handle.getStringArrays().write(0, lines);
    }
}
#end
#end
#No. 186754
#File: E:\bishe\1\WrapperPlayServerUpdateTime.java
#Comment:
    /**
     * Retrieve the age of the world in ticks. 
     * <p>
     * This cannot be changed by server commands.
     * @return The current age of the world
    */

#Code:
    public long getAgeOfTheWorld() {
        return handle.getLongs().read(0);
    }

#end
#end
#No. 186755
#File: E:\bishe\1\WrapperPlayServerUpdateTime.java
#Comment:
    /**
     * Set the age of the world in ticks.
     * <p>
     * This cannot be changed by server commands.
     * @param value - new value.
    */

#Code:
    public void setAgeOfTheWorld(long value) {
        handle.getLongs().write(0, value);
    }

#end
#end
#No. 186756
#File: E:\bishe\1\WrapperPlayServerUpdateTime.java
#Comment:
    /**
     * Retrieve the world (or region) time, in ticks.
     * @return The current Time of Day
    */

#Code:
    public long getTimeOfDay() {
        return handle.getLongs().read(1);
    }

#end
#end
#No. 186757
#File: E:\bishe\1\WrapperPlayServerUpdateTime.java
#Comment:
    /**
     * Set the world (or region) time, in ticks.
     * @param value - new value.
    */

#Code:
    public void setTimeOfDay(long value) {
        handle.getLongs().write(1, value);
    }

#end
#end
#No. 186758
#File: E:\bishe\1\WrapperPlayServerWindowItems.java
#Comment:
    /**
     * Retrieve the ID of the window which is being updated. 
     * <p>
     * Use 0 for the player inventory.
     * @return The current Window id
    */

#Code:
    public byte getWindowId() {
        return handle.getIntegers().read(0).byteValue();
    }

#end
#end
#No. 186759
#File: E:\bishe\1\WrapperPlayServerWindowItems.java
#Comment:
    /**
     * Set the ID of the window which is being updated. 
     * <p>
     * Use 0 for the player inventory.
     * @param value - new value.
    */

#Code:
    public void setWindowId(byte value) {
        handle.getIntegers().write(0, (int) value);
    }

#end
#end
#No. 186760
#File: E:\bishe\1\WrapperPlayServerWindowItems.java
#Comment:
    /**
     * Retrieve the items in the inventory indexed by slot index.
     * @return The items that will fill the inventory.
    */

#Code:
    public ItemStack[] getItems() {
        return handle.getItemArrayModifier().read(0);
    }

#end
#end
#No. 186761
#File: E:\bishe\1\WrapperPlayServerWindowItems.java
#Comment:
    /**
     * Set the items in the inventory indexed by slot index.
     * @param value - new value.
    */

#Code:
    public void setItems(ItemStack[] value) {
        handle.getItemArrayModifier().write(0, value);
    }

#end
#end
#No. 186762
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    	/**
    	 * Retrieve an instance of the smoke direction enum.
    	 * @return Smoke direction enum.
    	 */

#Code:
    	public static SmokeDirections getInstance() {
    		return INSTANCE;
    	}

#end
#end
#No. 186763
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Retrieve the ID of the effect.
     * @see {@link SoundEffects} and {@link ParticleEffects}.
     * @return The current Effect ID
    */

#Code:
    public int getEffectId() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186764
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Set the ID of the effect.
     * @see {@link SoundEffects} and {@link ParticleEffects}.
     * @param value - new value.
    */

#Code:
    public void setEffectId(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186765
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Retrieve the X location of the effect..
     * @return The current X
    */

#Code:
    public int getX() {
        return handle.getIntegers().read(2);
    }

#end
#end
#No. 186766
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Set the X location of the effect..
     * @param value - new value.
    */

#Code:
    public void setX(int value) {
        handle.getIntegers().write(2, value);
    }

#end
#end
#No. 186767
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Retrieve the Y location of the effect..
     * @return The current Y
    */

#Code:
    public int getY() {
        return handle.getIntegers().read(3);
    }

#end
#end
#No. 186768
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Set the Y location of the effect..
     * @param value - new value.
    */

#Code:
    public void setY(int value) {
        handle.getIntegers().write(3, value);
    }

#end
#end
#No. 186769
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Retrieve the Z location of the effect..
     * @return The current Z
    */

#Code:
    public int getZ() {
        return handle.getIntegers().read(4);
    }

#end
#end
#No. 186770
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Set the Z location of the effect..
     * @param value - new value.
    */

#Code:
    public void setZ(int value) {
        handle.getIntegers().write(4, value);
    }

#end
#end
#No. 186771
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Retrieve the location of this particle or sound effect. 
     * @param world - the containing world.
     * @return The location.
     */

#Code:
    public Location getLocation(World world) {
    	return new Location(world, getX(), getY(), getZ());
    }

#end
#end
#No. 186772
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Set the location of this particle or sound effect.
     * @param loc - the location.
     */

#Code:
    public void setLocation(Location loc) {
    	setX(loc.getBlockX());
    	setY(loc.getBlockY());
    	setZ(loc.getBlockZ());
    }

#end
#end
#No. 186773
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Retrieve extra data for certain effects.
     * @see {@link SmokeDirections}
     * @return The current Data
    */

#Code:
    public int getData() {
        return handle.getIntegers().read(1);
    }

#end
#end
#No. 186774
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Set extra data for certain effects.
     * @see {@link SmokeDirections}
     * @param value - new value.
    */

#Code:
    public void setData(int value) {
        handle.getIntegers().write(1, value);
    }

#end
#end
#No. 186775
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Retrieve whether or not to ignore the distance of a sound.
     * <p>
     * If TRUE, the effect will always be played 2 blocks away in the correct direction.
     * @return The current Disable relative volume
    */

#Code:
    public boolean getDisableRelativeVolume() {
        return handle.getSpecificModifier(boolean.class).read(0);
    }

#end
#end
#No. 186776
#File: E:\bishe\1\WrapperPlayServerWorldEvent.java
#Comment:
    /**
     * Set whether or not to ignore the distance of a sound.
     * <p>
     * If TRUE, the effect will always be played 2 blocks away in the correct direction.
     * @param value - TRUE to disable distance, FALSE otherwise.
    */

#Code:
    public void setDisableRelativeVolume(boolean value) {
        handle.getSpecificModifier(boolean.class).write(0, value);
    }

#end
#end
#No. 186777
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Construct a new particle packet.
     */

#Code:
    public WrapperPlayServerWorldParticles() {
        super(new PacketContainer(TYPE), TYPE);
        handle.getModifier().writeDefaults();
    }

#end
#end
#No. 186778
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Construct a particle packet that reads and modifies a given native packet.
     * @param packet - the native packet.
     */

#Code:
    public WrapperPlayServerWorldParticles(PacketContainer packet) {
        super(packet, TYPE);
    }

#end
#end
#No. 186779
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Constructs a new particle packet with the given parameters.
     * @param effect - the particle effect.
     * @param count - the number of particles to spawn.
     * @param location - the spawn location.
     * @param offset - the random offset that will be applied to each particle.
     */

#Code:
    public WrapperPlayServerWorldParticles(ParticleEffect effect, int count, Location location, Vector offset) {
    	this();
    	setParticleEffect(effect);
    	setNumberOfParticles(count);
    	setLocation(location);
    	setOffset(offset);
    }

#end
#end
#No. 186780
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the name of the particle to create. A list can be found here.
     * @return The current Particle name
    */

#Code:
    public String getParticleName() {
        return handle.getStrings().read(0);
    }

#end
#end
#No. 186781
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set the name of the particle to create. A list can be found here.
     * @param value - new value.
    */

#Code:
    public void setParticleName(String value) {
        handle.getStrings().write(0, value);
    }

#end
#end
#No. 186782
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the particle effect.
     * @return The particle effect, or NULL if not known.
     */

#Code:
    public ParticleEffect getParticleEffect() {
    	return ParticleEffect.fromName(getParticleName());
    }

#end
#end
#No. 186783
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set the particle effect to use.
     * @param effect - the particle effect.
     */

#Code:
    public void setParticleEffect(ParticleEffect effect) {
    	if (effect == null)
    		throw new IllegalArgumentException("effect cannot be NULL.");
    	setParticleName(effect.getParticleName());
    }

#end
#end
#No. 186784
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the location of the current particle.
     * @param event - the packet event.
     * @return The location.
     */

#Code:
    public Location getLocation(PacketEvent event) {
    	return getLocation(event.getPlayer().getWorld());
    }

#end
#end
#No. 186785
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the location of the current particle.
     * @param world - the containing world.
     * @return The location.
     */

#Code:
    public Location getLocation(World world) {
    	return new Location(world, getX(), getY(), getZ());
    }

#end
#end
#No. 186786
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set the location of the particle to send.
     * @param loc - the location.
     */

#Code:
    public void setLocation(Location loc) {
    	if (loc == null)
    		throw new IllegalArgumentException("Location cannot be NULL.");
    	setX((float) loc.getX());
    	setY((float) loc.getY());
    	setZ((float) loc.getZ());
    }

#end
#end
#No. 186787
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set the random offset (multiplied by a random gaussian) to be applied after the particles are created.
     * @param vector - the random vector offset.
     */

#Code:
    public void setOffset(Vector vector) {
    	if (vector == null)
    		throw new IllegalArgumentException("Vector cannot be NULL.");
    	setOffsetX((float) vector.getX());
    	setOffsetY((float) vector.getY());
    	setOffsetZ((float) vector.getZ());
    }

#end
#end
#No. 186788
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the random offset that will be multiplied by a random gaussian and applied to each created particle.
     * @return The random offset.
     */

#Code:
    public Vector getOffset() {
    	return new Vector(getX(), getY(), getZ());
    }

#end
#end
#No. 186789
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the x position of the particle.
     * @return The current position.
    */

#Code:
    public float getX() {
        return handle.getFloat().read(0);
    }

#end
#end
#No. 186790
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set the x position of the particle.
     * @param value - new position.
    */

#Code:
    public void setX(float value) {
        handle.getFloat().write(0, value);
    }

#end
#end
#No. 186791
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the y position of the particle.
     * @return The current Y position.
    */

#Code:
    public float getY() {
        return handle.getFloat().read(1);
    }

#end
#end
#No. 186792
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set the y position of the particle.
     * @param value - new position.
    */

#Code:
    public void setY(float value) {
        handle.getFloat().write(1, value);
    }

#end
#end
#No. 186793
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the z position of the particle.
     * @return The current Z position.
    */

#Code:
    public float getZ() {
        return handle.getFloat().read(2);
    }

#end
#end
#No. 186794
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set the z position of the particle.
     * @param value - new position.
    */

#Code:
    public void setZ(float value) {
        handle.getFloat().write(2, value);
    }

#end
#end
#No. 186795
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the offset added to the X position after being multiplied by random.nextGaussian().
     * @return The current Offset X
    */

#Code:
    public float getOffsetX() {
        return handle.getFloat().read(3);
    }

#end
#end
#No. 186796
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set this the offset added to the X position after being multiplied by random.nextGaussian().
     * @param value - new value.
    */

#Code:
    public void setOffsetX(float value) {
        handle.getFloat().write(3, value);
    }

#end
#end
#No. 186797
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the offset added to the Y position after being multiplied by random.nextGaussian().
     * @return The current Offset Y
    */

#Code:
    public float getOffsetY() {
        return handle.getFloat().read(4);
    }

#end
#end
#No. 186798
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set the offset added to the Y position after being multiplied by random.nextGaussian().
     * @param value - new value.
    */

#Code:
    public void setOffsetY(float value) {
        handle.getFloat().write(4, value);
    }

#end
#end
#No. 186799
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the offset added to the Z position after being multiplied by random.nextGaussian().
     * @return The current Offset Z
    */

#Code:
    public float getOffsetZ() {
        return handle.getFloat().read(5);
    }

#end
#end
#No. 186800
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set offset added to the Z position after being multiplied by random.nextGaussian().
     * @param value - new value.
    */

#Code:
    public void setOffsetZ(float value) {
        handle.getFloat().write(5, value);
    }

#end
#end
#No. 186801
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the speed of each particle.
     * @return The current particle speed
    */

#Code:
    public float getParticleSpeed() {
        return handle.getFloat().read(6);
    }

#end
#end
#No. 186802
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set the speed of each particle.
     * @param value - new speed.
    */

#Code:
    public void setParticleSpeed(float value) {
        handle.getFloat().write(6, value);
    }

#end
#end
#No. 186803
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Retrieve the number of particles to create.
     * @return The current number of particles
    */

#Code:
    public int getNumberOfParticles() {
        return handle.getIntegers().read(0);
    }

#end
#end
#No. 186804
#File: E:\bishe\1\WrapperPlayServerWorldParticles.java
#Comment:
    /**
     * Set the number of particles to create.
     * @param value - new count.
    */

#Code:
    public void setNumberOfParticles(int value) {
        handle.getIntegers().write(0, value);
    }

#end
#end
#No. 186805
#File: E:\bishe\1\WrapperProperty.java
#Comment:
    /**
     * @return A new {@link Property} that corresponds to the inverted type of the {@link WrapperProperty}. Convenience
     * for types that have different DB representations.
     */

#Code:
    @SuppressWarnings("ConstantConditions")
    @NonNull
    public Property<T> invertProperty() {
        if (databaseProperty == null) {
            databaseProperty = new WrapperProperty<>(table, nameAlias);
        }
        return databaseProperty;
    }

#end
#end
#No. 186811
#File: E:\bishe\1\WrapperResultSet.java
#Comment:
  /**
   * Is called before the CallabelStatement is executed. It is usually used to set parameters. The CallableStatement may not be executed. The default implementaion does nothing.
   */

#Code:
  protected void setParameter( PreparedStatement pPreparedStatement ) throws SQLException
  {
    if( _parameters != null )
    {
      for( int i = 0; i < _parameters.size(); i++ )
      {
        pPreparedStatement.setObject( i + 1, _parameters.get( i ) );
      }
    }
  }

#end
#end
#No. 186812
#File: E:\bishe\1\WrapperReturnValueFromResultSet.java
#Comment:
  /**
   * Executes and Returns the Value. This method has to be used instaed of execute (it internally exceutes execute).
   */

#Code:
  public final synchronized Object executeForValue()
  {
    execute();

    return _tempReturnValue;
  }

#end
#end
#No. 186813
#File: E:\bishe\1\WrapperService.java
#Comment:
/**
 * A service for managing {@link WrapperPlugin}s of a particular type. A
 * {@link WrapperPlugin} is a stateful {@link TypedPlugin} which wraps a
 * particular object of its associated data type. For any given data object, the
 * service is capable of wrapping it with the most appropriate wrapper by
 * sequentially querying each {@link WrapperPlugin} on its list for
 * compatibility.
 * <p>
 * Note that like {@link PTService}, {@link SingletonService} and
 * {@link TypedService}, {@code WrapperService} is not a service interface
 * defining API for a specific concrete service implementation, but rather a
 * more general layer in a type hierarchy intended to ease creation of services
 * that fit its pattern.
 * </p>
 * 
 * @author Curtis Rueden
 * @param <DT> Base data type
 * @param <PT> Plugin type
 * @see WrapperPlugin
 * @see PTService
 */

#Code:
public interface WrapperService<DT, PT extends WrapperPlugin<DT>> extends
	TypedService<DT, PT>
{

	/**
	 * Creates a new plugin instance wrapping the given associated data object.
	 * 
	 * @return An appropriate plugin instance, or null if the data is not
	 *         compatible with any available plugin.
	 */
	default <D extends DT> PT create(final D data) {
		final PT instance = find(data);
		if (instance != null) instance.set(data);
		return instance;
	}

	// -- Service methods --

	@Override
	default void initialize() {
		if (log() != null) {
			log().debug("Found " + getPlugins().size() + " " +
				getPluginType().getSimpleName() + " plugins.");
		}
	}

	// -- Typed methods --

	@Override
	default boolean supports(final DT data) {
		return find(data) != null;
	}
}

#end
#end
#No. 186814
#File: E:\bishe\1\WrapperStatusClientInPing.java
#Comment:
    /**
     * Retrieve the random token we are sending.
     * @return The current random token.
    */

#Code:
    public long getToken() {
        return handle.getLongs().read(0);
    }

#end
#end
#No. 186815
#File: E:\bishe\1\WrapperStatusClientInPing.java
#Comment:
    /**
     * Set the random token we are sending.
     * @param value - new token.
    */

#Code:
    public void setToken(long value) {
        handle.getLongs().write(0, value);
    }   

#end
#end
#No. 186816
#File: E:\bishe\1\WrapperStatusServerOutPing.java
#Comment:
    /**
     * Retrieve the random token that should be the same as sent by the client.
     * @return The current token.
    */

#Code:
    public long getTime() {
        return handle.getLongs().read(0);
    }

#end
#end
#No. 186817
#File: E:\bishe\1\WrapperStatusServerOutPing.java
#Comment:
    /**
     * Set the random token that should be the same as sent by the client.
     * @param value - new token.
    */

#Code:
    public void setToken(long value) {
        handle.getLongs().write(0, value);
    }

#end
#end
#No. 186818
#File: E:\bishe\1\WrapperStatusServerOutServerInfo.java
#Comment:
    /**
     * Retrieve the server information to display in the multiplayer menu.
     * @return The current ping information.
    */

#Code:
    public WrappedServerPing getServerPing() {
        return handle.getServerPings().read(0);
    }

#end
#end
#No. 186819
#File: E:\bishe\1\WrapperStatusServerOutServerInfo.java
#Comment:
    /**
     * Set the server information to display in the multiplayer menu.
     * @param value - new information.
    */

#Code:
    public void setServerPing(WrappedServerPing value) {
        handle.getServerPings().write(0, value);
    }

#end
#end
#No. 186820
#File: E:\bishe\1\WrapperTarget.java
#Comment:
/**
 * Glide target for fixed sized Drawables that require sync return.
 * It bridges the gap between sync and async by providing a drawable that can be used immediately,
 * but filling in the contents later.
 * To make it work with animation the user will have subscribe to the Drawable's invalidate events:
 * <pre><code>
 * Drawable asyncWrapper = imageTarget.getLazyDrawable();
 * asyncWrapper.setCallback((Drawable.Callback)this);
 *
 * public void invalidateDrawable(Drawable who) {
 *     targetView.invalidate();
 * }
 * </code></pre>
 */

#Code:
class WrapperTarget extends SimpleTarget<GlideDrawable> {
	/** Workaround because the AppCompat DrawableWrapper doesn't support null drawable as the API23 version does */
	private final ColorDrawable nullObject = new ColorDrawable(Color.TRANSPARENT);
	private final DrawableWrapper
			wrapper = new DrawableWrapper(null/* temporarily null until a setDrawable call*/);
	public WrapperTarget(int height,int width) {
		super(height, width);
		setDrawable(null);
		// set wrapper bounds to fix the size of the view, TextViews don't like ImageSpans git  dimensions
		wrapper.setBounds(0, 0, height, width);
	}

	public Drawable getLazyDrawable() {
		return wrapper;
	}

	@Override public void onLoadStarted(Drawable placeholder) {
		setDrawable(placeholder);
	}

#end
#end
#No. 186821
#File: E:\bishe\1\WrappingExecutorService.java
#Comment:
    /**
     * Wraps a {@code Runnable} for submission to the underlying executor. The
     * default implementation delegates to {@link #wrapTask(Callable)}.
     */

#Code:
    protected Runnable wrapTask(Runnable command) {
        final Callable<Object> wrapped = wrapTask(
                Executors.callable(command, null));
        return () -> {
            try {
                wrapped.call();
            } catch (Exception e) {
                Throwables.propagate(e);
            }
        };
    }

#end
#end
#No. 186822
#File: E:\bishe\1\WrappingExecutorService.java
#Comment:
    /**
     * Wraps a collection of tasks.
     *
     * @throws NullPointerException if any element of {@code tasks} is null
     */

#Code:
    private final <T> ImmutableList<Callable<T>> wrapTasks(
            Collection<? extends Callable<T>> tasks) {
        ImmutableList.Builder<Callable<T>> builder = ImmutableList.builder();
        for (Callable<T> task : tasks) {
            builder.add(wrapTask(task));
        }
        return builder.build();
    }

#end
#end
#No. 186823
#File: E:\bishe\1\WrappingScheduledExecutorService.java
#Comment:
/**
 * An abstract {@code ScheduledExecutorService} that allows subclasses to
 * {@linkplain #wrapTask(Callable) wrap} tasks before they are submitted to the underlying executor.
 * <p>
 * <p>Note that task wrapping may occur even if the task is never executed.
 *
 * @author Luke Sandberg
 */

#Code:
abstract class WrappingScheduledExecutorService extends WrappingExecutorService
        implements ScheduledExecutorService {
    final ScheduledExecutorService delegate;

    protected WrappingScheduledExecutorService(ScheduledExecutorService delegate) {
        super(delegate);
        this.delegate = delegate;
    }

    @Override
    public final ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        return delegate.schedule(wrapTask(command), delay, unit);
    }

    @Override
    public final <V> ScheduledFuture<V> schedule(Callable<V> task, long delay, TimeUnit unit) {
        return delegate.schedule(wrapTask(task), delay, unit);
    }

    @Override
    public final ScheduledFuture<?> scheduleAtFixedRate(
            Runnable command, long initialDelay, long period, TimeUnit unit) {
        return delegate.scheduleAtFixedRate(wrapTask(command), initialDelay, period, unit);
    }

    @Override
    public final ScheduledFuture<?> scheduleWithFixedDelay(
            Runnable command, long initialDelay, long delay, TimeUnit unit) {
        return delegate.scheduleWithFixedDelay(wrapTask(command), initialDelay, delay, unit);
    }
}

#end
#end
#No. 186824
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Wraps the given drawable with a new {@link ScaleTypeDrawable}.
     *
     * <p> If the provided drawable or scale type is null, the given drawable is returned without
     * being wrapped.
     *
     * @return the wrapping scale type drawable, or the original drawable if the wrapping didn't
     * take place
     */

#Code:
    @Nullable
    static Drawable maybeWrapWithScaleType(
            @Nullable Drawable drawable,
            @Nullable ScaleType scaleType,
            @Nullable PointF focusPoint) {
        if (drawable == null || scaleType == null) {
            return drawable;
        }

#end
#end
#No. 186825
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Wraps the given drawable with a new {@link MatrixDrawable}.
     *
     * <p> If the provided drawable or matrix is null, the given drawable is returned without
     * being wrapped.
     *
     * @return the wrapping matrix drawable, or the original drawable if the wrapping didn't
     * take place
     */

#Code:
    @Nullable
    static Drawable maybeWrapWithMatrix(
            @Nullable Drawable drawable,
            @Nullable Matrix matrix) {
        if (drawable == null || matrix == null) {
            return drawable;
        }

#end
#end
#No. 186826
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Wraps the parent's child with a ScaleTypeDrawable.
     */

#Code:
    static ScaleTypeDrawable wrapChildWithScaleType(DrawableParent parent, ScaleType scaleType) {
        Drawable child = parent.setDrawable(sEmptyDrawable);
        child = maybeWrapWithScaleType(child, scaleType);
        parent.setDrawable(child);
        Preconditions.checkNotNull(child, "Parent has no child drawable!");
        return (ScaleTypeDrawable) child;
    }

#end
#end
#No. 186827
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Updates the overlay-color rounding of the parent's child drawable.
     *
     * <ul>
     * <li>If rounding mode is OVERLAY_COLOR and the child is not a RoundedCornersDrawable,
     * a new RoundedCornersDrawable is created and the child gets wrapped with it.
     * <li>If rounding mode is OVERLAY_COLOR and the child is already wrapped with a
     * RoundedCornersDrawable, its rounding parameters are updated.
     * <li>If rounding mode is not OVERLAY_COLOR and the child is wrapped with a
     * RoundedCornersDrawable, the rounded drawable gets removed and its child gets
     * attached directly to the parent.
     * </ul>
     */

#Code:
    static void updateOverlayColorRounding(
            DrawableParent parent,
            @Nullable RoundingParams roundingParams) {
        Drawable child = parent.getDrawable();
        if (roundingParams != null &&
                roundingParams.getRoundingMethod() == RoundingParams.RoundingMethod.OVERLAY_COLOR) {
            // Overlay rounding requested - either update the overlay params or add a new
            // drawable that will do the requested rounding.
            if (child instanceof RoundedCornersDrawable) {
                RoundedCornersDrawable roundedCornersDrawable = (RoundedCornersDrawable) child;
                applyRoundingParams(roundedCornersDrawable, roundingParams);
                roundedCornersDrawable.setOverlayColor(roundingParams.getOverlayColor());
            } else {
                // Important: remove the child before wrapping it with a new parent!
                child = parent.setDrawable(sEmptyDrawable);
                child = maybeWrapWithRoundedOverlayColor(child, roundingParams);
                parent.setDrawable(child);
            }
        } else if (child instanceof RoundedCornersDrawable) {
            // Overlay rounding no longer required so remove drawable that was doing the rounding.
            RoundedCornersDrawable roundedCornersDrawable = (RoundedCornersDrawable) child;
            // Important: remove the child before wrapping it with a new parent!
            child = roundedCornersDrawable.setCurrent(sEmptyDrawable);
            parent.setDrawable(child);
            // roundedCornersDrawable is removed and will get garbage collected, clear the child callback
            sEmptyDrawable.setCallback(null);
        }

#end
#end
#No. 186828
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Updates the leaf rounding of the parent's child drawable.
     *
     * <ul>
     * <li>If rounding mode is BITMAP_ONLY and the child is not a rounded drawable,
     * it gets rounded with a new rounded drawable.
     * <li>If rounding mode is BITMAP_ONLY and the child is already rounded,
     * its rounding parameters are updated.
     * <li>If rounding mode is not BITMAP_ONLY and the child is rounded,
     * its rounding parameters are reset so that no rounding occurs.
     * </ul>
     */

#Code:
    static void updateLeafRounding(
            DrawableParent parent,
            @Nullable RoundingParams roundingParams,
            Resources resources) {
        parent = findDrawableParentForLeaf(parent);
        Drawable child = parent.getDrawable();
        if (roundingParams != null &&
                roundingParams.getRoundingMethod() == RoundingParams.RoundingMethod.BITMAP_ONLY) {
            // Leaf rounding requested - either update the params or wrap the current drawable in a
            // drawable that will round it.
            if (child instanceof Rounded) {
                Rounded rounded = (Rounded) child;
                applyRoundingParams(rounded, roundingParams);
            } else if (child != null) {
                // Important: remove the child before wrapping it with a new parent!
                parent.setDrawable(sEmptyDrawable);
                Drawable rounded = applyLeafRounding(child, roundingParams, resources);
                parent.setDrawable(rounded);
            }
        } else if (child instanceof Rounded) {
            // No rounding requested - reset rounding params so no rounding occurs.
            resetRoundingParams((Rounded) child);
        }
    }

#end
#end
#No. 186829
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Wraps the given drawable with a new {@link RoundedCornersDrawable}.
     *
     * <p> If the provided drawable is null, or if the rounding params do not specify OVERLAY_COLOR
     * mode, the given drawable is returned without being wrapped.
     *
     * @return the wrapping rounded drawable, or the original drawable if the wrapping didn't
     * take place
     */

#Code:
    static Drawable maybeWrapWithRoundedOverlayColor(
            @Nullable Drawable drawable,
            @Nullable RoundingParams roundingParams) {
        if (drawable == null || roundingParams == null ||
                roundingParams.getRoundingMethod() != RoundingParams.RoundingMethod.OVERLAY_COLOR) {
            return drawable;
        }

#end
#end
#No. 186830
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Applies rounding on the drawable's leaf.
     *
     * <p> Currently only {@link BitmapDrawable} or {@link ColorDrawable} leafs can be rounded.
     * <p> If the leaf cannot be rounded, or the rounding params do not specify BITMAP_ONLY mode,
     * the given drawable is returned without being rounded.
     * <p> If the given drawable is a leaf itself, and it can be rounded, then the rounded drawable
     * is returned.
     * <p> If the given drawable is not a leaf, and its leaf can be rounded, the leaf gets rounded,
     * and the original drawable is returned.
     *
     * @return the rounded drawable, or the original drawable if the rounding didn't take place
     * or it took place on a drawable's child
     */

#Code:
    static Drawable maybeApplyLeafRounding(
            @Nullable Drawable drawable,
            @Nullable RoundingParams roundingParams,
            Resources resources) {
        if (drawable == null || roundingParams == null ||
                roundingParams.getRoundingMethod() != RoundingParams.RoundingMethod.BITMAP_ONLY) {
            return drawable;
        }
        if (drawable instanceof ForwardingDrawable) {
            DrawableParent parent = findDrawableParentForLeaf((ForwardingDrawable) drawable);
            Drawable child = parent.setDrawable(sEmptyDrawable);
            child = applyLeafRounding(child, roundingParams, resources);
            parent.setDrawable(child);
            return drawable;
        } else {
            return applyLeafRounding(drawable, roundingParams, resources);
        }
    }

#end
#end
#No. 186831
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Rounds the given drawable with a {@link RoundedBitmapDrawable} or {@link RoundedColorDrawable}.
     *
     * <p> If the given drawable is not a {@link BitmapDrawable} or a {@link ColorDrawable}, it is
     * returned without being rounded.
     *
     * @return the rounded drawable, or the original drawable if rounding didn't take place
     */

#Code:
    private static Drawable applyLeafRounding(
            Drawable drawable,
            RoundingParams roundingParams,
            Resources resources) {
        if (drawable instanceof BitmapDrawable) {
            final BitmapDrawable bitmapDrawable = (BitmapDrawable) drawable;
            RoundedBitmapDrawable roundedBitmapDrawable =
                    new RoundedBitmapDrawable(
                            resources,
                            bitmapDrawable.getBitmap(),
                            bitmapDrawable.getPaint());
            applyRoundingParams(roundedBitmapDrawable, roundingParams);
            return roundedBitmapDrawable;
        }
        if (drawable instanceof ColorDrawable &&
                Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
            RoundedColorDrawable roundedColorDrawable =
                    RoundedColorDrawable.fromColorDrawable((ColorDrawable) drawable);
            applyRoundingParams(roundedColorDrawable, roundingParams);
            return roundedColorDrawable;
        }
        return drawable;
    }

#end
#end
#No. 186832
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Applies the given rounding params on the specified rounded drawable.
     */

#Code:
    static void applyRoundingParams(Rounded rounded, RoundingParams roundingParams) {
        rounded.setCircle(roundingParams.getRoundAsCircle());
        rounded.setRadii(roundingParams.getCornersRadii());
        rounded.setBorder(roundingParams.getBorderColor(), roundingParams.getBorderWidth());
        rounded.setPadding(roundingParams.getPadding());
    }

#end
#end
#No. 186833
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Resets the rounding params on the specified rounded drawable, so that no rounding occurs.
     */

#Code:
    static void resetRoundingParams(Rounded rounded) {
        rounded.setCircle(false);
        rounded.setRadius(0);
        rounded.setBorder(Color.TRANSPARENT, 0);
        rounded.setPadding(0);
    }

#end
#end
#No. 186834
#File: E:\bishe\1\WrappingUtils.java
#Comment:
    /**
     * Finds the immediate parent of a leaf drawable.
     */

#Code:
    static DrawableParent findDrawableParentForLeaf(DrawableParent parent) {
        while (true) {
            Drawable child = parent.getDrawable();
            if (child == parent || !(child instanceof DrawableParent)) {
                break;
            }
            parent = (DrawableParent) child;
        }
        return parent;
    }

#end
#end
#No. 186835
#File: E:\bishe\1\WrathSpawnerLogic.java
#Comment:
    /**
     * Gets the entity name that should be spawned.
     */

#Code:
    public String getEntityNameToSpawn() {
        return this.mobID;
    }

#end
#end
#No. 186836
#File: E:\bishe\1\WrathSpawnerLogic.java
#Comment:
    /**
     * Checks if the entity's current position is a valid location to spawn this
     * entity.
     */

#Code:
    public boolean entityCanSpawn(EntityLiving entity) {
        return entity.worldObj.checkNoEntityCollision(entity.boundingBox) && entity.worldObj.getCollidingBoundingBoxes(entity, entity.boundingBox).isEmpty() && !entity.worldObj.isAnyLiquid(entity.boundingBox);
    }

#end
#end
#No. 186837
#File: E:\bishe\1\WrathSpawnerLogic.java
#Comment:
    /**
     * Sets the delay to minDelay if parameter given is 1, else return false.
     */

#Code:
    public boolean setDelayToMin(int par1) {
        if (par1 == 1 && this.getSpawnerWorld().isRemote) {
            this.spawnDelay = this.minSpawnDelay;
            return true;
        } else {
            return false;
        }
    }



#end
#end
#No. 186840
#File: E:\bishe\1\WritableBerkeleyDBWiktionaryEdition.java
#Comment:
/**
 * Extends the Berkeley DB implementation by providing the possibility for 
 * modifying the contents. This is required by the parsers which need writing
 * access to the database, but not by the querying and iterating interface. 
 * @author Christian M. Meyer
 */

#Code:
public class WritableBerkeleyDBWiktionaryEdition extends BerkeleyDBWiktionaryEdition
		implements IWritableWiktionaryEdition {

	protected long pageCount;
	protected long entryCount;
	protected long senseCount;
	
	// default = false; old behaviour of before 0.15.1; this needs significantly longer time!
	protected boolean entryIndexByTitle;
	
	/** Shorthand for {@link #WritableBerkeleyDBWiktionaryEdition(File, 
	 *  boolean, Long)} with a cacheSize set to half the size of the the +

#end
#end
#No. 186841
#File: E:\bishe\1\WritableBerkeleyDBWiktionaryEdition.java
#Comment:
	/** Instanciates the writable Wiktionary database for the given 
	 *  database path. 
	 *  @param overwriteExisting if set to <code>false</code>, parsing a 
	 *  	Wiktionary dump using this database will cause an exception if the 
	 *  	database path is not empty. Otherwise, an existing parsed Wiktionary
	 *  	database will be overwritten. 
	 *  @param cacheSize denotes the size of the cache (in Bytes) used by the
	 *  	Berkeley DB. */

#Code:
	public WritableBerkeleyDBWiktionaryEdition(final File dbPath, 
			boolean overwriteExisting, final Long cacheSize) {
		super(dbPath, false, true, overwriteExisting, cacheSize);
		pageCount = 0;
		entryCount = 0;
		senseCount = 0;
	}

#end
#end
#No. 186842
#File: E:\bishe\1\WritableBerkeleyDBWiktionaryEdition.java
#Comment:
	/** Returns the setting if {@link IWiktionaryEntry}s should be ordered 
   *  alphabetically. */

#Code:
	public boolean getEntryIndexByTitle() {
		return entryIndexByTitle;
	}


#end
#end
#No. 186844
#File: E:\bishe\1\WritableBerkeleyDBWiktionaryEdition.java
#Comment:
	/** Adds the given Wiktionary page to the database. 
	 *  @throws DatabaseException if the page could not be stored, which is,
	 *      i.e. the case if the DB is in read-only mode. */

#Code:
	public void savePage(final WiktionaryPage page) throws DatabaseException {
		WiktionaryPage existing = pageById.put(page);
		if (existing == null) {
			for (WiktionaryEntry entry : page.entries()) {
				entryByKey.put(new WiktionaryEntryProxy(entry));
				for (WiktionarySense sense : entry.senses()) {
					senseByKey.put(new WiktionarySenseProxy(sense));
					senseCount++;
				}
				entryCount++;
			}
			pageCount++;
		}
	}

#end
#end
#No. 186845
#File: E:\bishe\1\WritableBulkImportStatus.java
#Comment:
/**
 * Defines a fully writable interface to the <code>BulkImportStatus</code>.
 *
 * @author Peter Monks (pmonks@gmail.com)
 * @see org.alfresco.extension.bulkimport.source.BulkImportSourceStatus
 *
 */

#Code:
public interface WritableBulkImportStatus
    extends BulkImportSourceStatus
{
    void importStarted(String                       initiatingUserId,
                       BulkImportSource             source,
                       String                       targetSpace,
                       BulkImportThreadPoolExecutor threadPool,
                       long                         batchWeight,
                       boolean                      inPlaceImportPossible,
                       boolean                      isDryRun);
    void scanningComplete();
    void pauseRequested();
    void resumeRequested();
    void stopRequested();
    void importComplete();
    void unexpectedError(Throwable t);

    void setCurrentlyImporting(String name);
    void batchCompleted(Batch batch);
    
    void preregisterTargetCounters(String[] counterNames);
    void incrementTargetCounter(String counterName);
    void incrementTargetCounter(String counterName, long value);
}

#end
#end
#No. 186848
#File: E:\bishe\1\WritableComparator.java
#Comment:
  /** Compare two WritableComparables.
   *
   * <p> The default implementation uses the natural ordering, calling {@link
   * Comparable#compareTo(Object)}. */

#Code:
  @SuppressWarnings("unchecked")
  public int compare(WritableComparable a, WritableComparable b) {
    return a.compareTo(b);
  }

#end
#end
#No. 186849
#File: E:\bishe\1\WritableComparator.java
#Comment:
  /**
   * Reads a zero-compressed encoded long from a byte array and returns it.
   * @param bytes byte array with decode long
   * @param start starting index
   * @throws java.io.IOException 
   * @return deserialized long
   */

#Code:
  public static long readVLong(byte[] bytes, int start) throws IOException {
    int len = bytes[start];
    if (len >= -112) {
      return len;
    }
    boolean isNegative = (len < -120);
    len = isNegative ? -(len + 120) : -(len + 112);
    if (start+1+len>bytes.length)
      throw new IOException(
                            "Not enough number of bytes for a zero-compressed integer");
    long i = 0;
    for (int idx = 0; idx < len; idx++) {
      i = i << 8;
      i = i | (bytes[start+1+idx] & 0xFF);
    }
    return (isNegative ? (i ^ -1L) : i);
  }

#end
#end
#No. 186850
#File: E:\bishe\1\WritableComparator.java
#Comment:
  /**
   * Reads a zero-compressed encoded integer from a byte array and returns it.
   * @param bytes byte array with the encoded integer
   * @param start start index
   * @throws java.io.IOException 
   * @return deserialized integer
   */

#Code:
  public static int readVInt(byte[] bytes, int start) throws IOException {
    return (int) readVLong(bytes, start);
  }



#end
#end
#No. 186853
#File: E:\bishe\1\WritableFlaggingCache.java
#Comment:
/**
 * A {@link FlaggingCache} that can be written to.
 *
 * @author Bastian Gloeckle
 */

#Code:
public interface WritableFlaggingCache<K1 extends Comparable<K1>, K2 extends Comparable<K2>, V>
    extends FlaggingCache<K1, K2, V>, WritableCache<K1, K2, V> {
  /**
   * Offer an element to the cache and flag it right away.
   * 
   * <p>
   * This will either lead to flagging the currently available entry in the cache for that (K1,K2), or to adding the new
   * value and flagging it. After calling this method, there will be an entry in the cache for the given (K1, K2).
   * 
   * @see #flagAndGet(Comparable, Comparable, long)
   * @param key1
   *          key part one.
   * @param key2
   *          key part two.
   * @param value
   *          The value to be cached.
   * @param flagUntilNanos
   *          {@link System#nanoTime()} of when the flag should be removed from the value earliest.
   * @return The value instance now stored in the cache.
   */
  public V offerAndFlag(K1 key1, K2 key2, V value, long flagUntilNanos);
}


#end
#end
#No. 186855
#File: E:\bishe\1\WritableHelper.java
#Comment:
    /**
     * Writes out the provided writable instance to the data outout.
     *
     * @param out      the data output
     * @param writable the writable isntance (must not be null)
     * @throws IOException if an io error occurs
     */

#Code:
    public static void writeInstance(DataOutput out, Writable writable) throws IOException {
        if (writable == null) {
            throw new IllegalArgumentException("The writable instance must not be null");
        }
        Bytes.writeByteArray(out, Bytes.toBytes(writable.getClass().getName()));
        writable.write(out);
    }

#end
#end
#No. 186856
#File: E:\bishe\1\WritableHelper.java
#Comment:
    /**
     * Writes out the provided writable instance to the data outout.
     *
     * @param out      the data output
     * @param writable the writable isntance (can be null)
     * @throws IOException if an io error occurs
     */

#Code:
    public static void writeInstanceNullable(DataOutput out, Writable writable) throws IOException {
        if (writable == null) {
            out.writeBoolean(false);
        } else {
            out.writeBoolean(true);
            writeInstance(out, writable);
        }
    }

#end
#end
#No. 186857
#File: E:\bishe\1\WritableResourceHandler.java
#Comment:
/**
 * Maven 2 Index writable {@link ResourceHandler}, is capable of saving resources too. Needed only if incremental index
 * updates are wanted, to store the index state locally, and be able to calculate incremental diffs on next {@link
 * IndexReader} invocation. Is used by single thread only.
 *
 * @see ResourceHandler
 * @since 5.1.2
 */

#Code:
public interface WritableResourceHandler
    extends ResourceHandler
{
  interface WritableResource
      extends Resource, Closeable
  {
    /**
     * Returns the {@link OutputStream} stream of the resource, if exists, it will replace the existing content, or if
     * not exists, the resource will be created. The stream should be closed by caller, otherwise resource leaks might
     * be introduced. How and when content is written is left to implementation, but it is guaranteed that this method
     * is called only once, and will be followed by {@link #close()} on the resource itself. Implementation does not
     * have to be "read consistent", in a way to worry what subsequent {@link #read()} method will return, as mixed
     * calls will not happen on same instance of resource.
     */
    OutputStream write() throws IOException;
  }

  /**
   * Returns the {@link WritableResource} with {@code name}. Returned locator should be handled as
   * resource, is {@link Closeable}.
   *
   * @param name Resource name, guaranteed to be non-{@code null} and is FS and URL safe string.
   */
  WritableResource locate(String name) throws IOException;
}

#end
#end
#No. 186858
#File: E:\bishe\1\WritableRpcEngine.java
#Comment:
  /** Construct a client-side proxy object that implements the named protocol,
   * talking to a server at the named address. */

#Code:
  @Override
  public <T extends VersionedProtocol> T getProxy(
      Class<T> protocol, long clientVersion,
      InetSocketAddress addr, Configuration conf, int rpcTimeout)
    throws IOException {
    if (this.client == null) {
      throw new IOException("Client must be initialized by calling setConf(Configuration)");
    }

    T proxy =
          (T) Proxy.newProxyInstance(
              protocol.getClassLoader(), new Class[] { protocol },
              new Invoker(client, protocol, addr, userProvider.getCurrent(), conf,
                  HBaseRPC.getRpcTimeout(rpcTimeout)));

    /*
     * TODO: checking protocol version only needs to be done once when we setup a new
     * HBaseClient.Connection.  Doing it every time we retrieve a proxy instance is resulting
     * in unnecessary RPC traffic.
     */
    long serverVersion = ((VersionedProtocol)proxy)
      .getProtocolVersion(protocol.getName(), clientVersion);
    if (serverVersion != clientVersion) {
      throw new HBaseRPC.VersionMismatch(protocol.getName(), clientVersion,
                                    serverVersion);
    }

    return proxy;
  }

#end
#end
#No. 186859
#File: E:\bishe\1\WritableRpcEngine.java
#Comment:
  /** Construct a server for a protocol implementation instance listening on a
   * port and address. */

#Code:
  public Server getServer(Class<? extends VersionedProtocol> protocol,
                          Object instance,
                          Class<?>[] ifaces,
                          String bindAddress, int port,
                          int numHandlers,
                          int metaHandlerCount, boolean verbose,
                          Configuration conf, int highPriorityLevel)
    throws IOException {
    return new Server(instance, ifaces, conf, bindAddress, port, numHandlers,
        metaHandlerCount, verbose, highPriorityLevel);
  }

#end
#end
#No. 186860
#File: E:\bishe\1\WritableRpcEngine.java
#Comment:
    /** Construct an RPC server.
     * @param instance the instance whose methods will be called
     * @param conf the configuration to use
     * @param bindAddress the address to bind on to listen for connection
     * @param port the port to listen for connections on
     * @param numHandlers the number of method handler threads to run
     * @param verbose whether each call should be logged
     * @throws IOException e
     */

#Code:
    public Server(Object instance, final Class<?>[] ifaces,
                  Configuration conf, String bindAddress,  int port,
                  int numHandlers, int metaHandlerCount, boolean verbose,
                  int highPriorityLevel) throws IOException {
      super(bindAddress, port, Invocation.class, numHandlers, metaHandlerCount,
          conf, classNameBase(instance.getClass().getName()),
          highPriorityLevel);
      this.instance = instance;
      this.implementation = instance.getClass();
      this.verbose = verbose;

      this.ifaces = ifaces;

      // create metrics for the advertised interfaces this server implements.
      String [] metricSuffixes = new String [] {ABOVE_ONE_SEC_METRIC};
      this.rpcMetrics.createMetrics(this.ifaces, false, metricSuffixes);

      this.authorize =
        conf.getBoolean(
            ServiceAuthorizationManager.SERVICE_AUTHORIZATION_CONFIG, false);

      this.warnResponseTime = conf.getInt(WARN_RESPONSE_TIME,
          DEFAULT_WARN_RESPONSE_TIME);
      this.warnResponseSize = conf.getInt(WARN_RESPONSE_SIZE,
          DEFAULT_WARN_RESPONSE_SIZE);
    }

#end
#end
#No. 186861
#File: E:\bishe\1\WritableSettings.java
#Comment:
    /**
     * @return the settings
     */

#Code:
    public Settings getSettings() {
        Settings s;
        synchronized (lock) {
            s = settings;
        }
        return new LayeredSettings(ns, new PropertiesWrapper(writeLayer), s);
    }

#end
#end
#No. 186862
#File: E:\bishe\1\WritableSettings.java
#Comment:
    /**
     * @param settings the settings to set
     */

#Code:
    public void setSettings(Settings settings) {
        synchronized (lock) {
            this.settings = settings;
        }
    }


#end
#end
#No. 186864
#File: E:\bishe\1\WritableToValueFunction.java
#Comment:
/**
 * Translates a key and message in {@link Writable}s format to value objects.
 *
 * @see ValueToWritableFunction
 */

#Code:
final class WritableToValueFunction<K,M>
    implements PairFunction<Tuple2<Writable,Writable>,K,M> {

  private final Class<K> keyClass;
  private final Class<M> messageClass;
  private final Class<? extends Writable> keyWritableClass;
  private final Class<? extends Writable> messageWritableClass;
  private transient ValueWritableConverter<K> keyConverter;
  private transient ValueWritableConverter<M> messageConverter;

  WritableToValueFunction(Class<K> keyClass,
                          Class<M> messageClass,
                          Class<? extends Writable> keyWritableClass,
                          Class<? extends Writable> messageWritableClass) {
    this.keyClass = keyClass;
    this.messageClass = messageClass;
    this.keyWritableClass = keyWritableClass;
    this.messageWritableClass = messageWritableClass;
    initConverters();
  }

  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject();
    initConverters();
  }

  private void initConverters() {
    keyConverter = new ValueWritableConverter<>(keyClass, keyWritableClass);
    messageConverter = new ValueWritableConverter<>(messageClass, messageWritableClass);
  }

  @Override
  public Tuple2<K,M> call(Tuple2<Writable,Writable> keyMessage) {
    return new Tuple2<>(keyConverter.fromWritable(keyMessage._1()),
                        messageConverter.fromWritable(keyMessage._2()));
  }

}

#end
#end
#No. 186865
#File: E:\bishe\1\WriteActiveProfileProperties.java
#Comment:
/**
 * Writes properties of all active profiles to a file.
 *
 * @author <a href="mailto:zarars@gmail.com">Zarar Siddiqi</a>
 * @version $Id$
 * @goal write-active-profile-properties
 */

#Code:
public class WriteActiveProfileProperties
    extends AbstractWritePropertiesMojo
{
    /** {@inheritDoc} */
    public void execute()
        throws MojoExecutionException
    {
        validateOutputFile();
        List<?> list = getProject().getActiveProfiles();
        if ( getLog().isInfoEnabled() )
        {
            getLog().debug( list.size() + " profile(s) active" );
        }
        Properties properties = new Properties();
        for ( Iterator<?> iter = list.iterator(); iter.hasNext(); )
        {
            Profile profile = (Profile) iter.next();
            if ( profile.getProperties() != null )
            {
                properties.putAll( profile.getProperties() );
            }
        }

        writeProperties( properties, getOutputFile() );
    }
}


#end
#end
#No. 186867
#File: E:\bishe\1\WriteAheadMutationBatchExecutor.java
#Comment:
    /**
     * Replay records from the WAL
     */

#Code:
    public List<ListenableFuture<OperationResult<Void>>> replayWal(int count) {
        List<ListenableFuture<OperationResult<Void>>> futures = Lists.newArrayList();
        WriteAheadEntry walEntry;
        while (null != (walEntry = wal.readNextEntry()) && count-- > 0) {
            MutationBatch m = keyspace.prepareMutationBatch();
            try {
                walEntry.readMutation(m);
                futures.add(executeWalEntry(walEntry, m));
            }
            catch (WalException e) {
                wal.removeEntry(walEntry);
            }
        }
        return futures;
    }

#end
#end
#No. 186868
#File: E:\bishe\1\WriteAheadMutationBatchExecutor.java
#Comment:
    /**
     * Write a mutation to the wal and execute it
     */

#Code:
    public ListenableFuture<OperationResult<Void>> execute(final MutationBatch m) throws WalException {
        final WriteAheadEntry walEntry = wal.createEntry();
        walEntry.writeMutation(m);
        return executeWalEntry(walEntry, m);
    }


#end
#end
#No. 186870
#File: E:\bishe\1\WriteApi.java
#Comment:
/**
 * Generates an XML file with system data for a file and/or directory
 * 
 * 
 * TODO - move this to java commons libs
 *
 */

#Code:
class GenerateFileData {
	/**
	 * This implementation is cribbed from http://www.rgagnon.com/javadetails/java-0416.html
	 * 
	 * @param filename Path to file to generate checksum for
	 * @return Checksum for file
	 * @throws Exception
	 */
	public static byte[] createChecksum(String filename) throws FileNotFoundException, NoSuchAlgorithmException, IOException {
		InputStream   fis      =  new FileInputStream(filename);
		byte[]        buffer   = new byte[1024];
		MessageDigest complete = MessageDigest.getInstance("MD5");
		
		int numRead;
		do {
			numRead = fis.read(buffer);
			if (numRead > 0) {
				complete.update(buffer, 0, numRead);
			}
		} while (numRead != -1);
		fis.close();
		return complete.digest();
	}
	
	/**
	 * Faster version of the above
	 * 
	 * @param filename Path to file to generate checksum for
	 * @return Checksum for file
	 * @throws Exception
	 */
	public static String getMD5Checksum(String filename) throws FileNotFoundException, NoSuchAlgorithmException, IOException {
		byte[] b = createChecksum(filename);
		String result = "";
		for (int i=0; i < b.length; i++) {
			result += Integer.toString( ( b[i] & 0xff ) + 0x100, 16).substring( 1 );
		}
		return result;
	}
}



#end
#end
#No. 186878
#File: E:\bishe\1\WriteBufferDeviceTest.java
#Comment:
    /**
     * Test buffered write with 8kb blocks on the device.
     * 
     * @throws Exception
     *             These should never be thrown.
     */

#Code:
    @Test
    public final void testReadWriteBeginning8kb() throws Exception {

        int writeBlockCount = 50;
        int blockFactor = testDataBlock8kb.length / device.getBlockSize();
        long address = 0;

        for (int i = 0; i < writeBlockCount; i++) {
            device.write(address + i * blockFactor, testDataBlock8kb);
        }
        device.flush();
        for (int j = 0; j < writeBlockCount; j++) {
            byte[] result = new byte[testDataBlock8kb.length];
            device.read(address + j * blockFactor, result);
            for (int i = 0; i < testDataBlock8kb.length; i++) {
                assertEquals(result[i], testDataBlock8kb[i]);
            }
        }
    }

#end
#end
#No. 186879
#File: E:\bishe\1\WriteBufferDeviceTest.java
#Comment:
    /**
     * Test buffered write with 128kb blocks on the device.
     * 
     * @throws Exception
     *             These should never be thrown.
     */

#Code:
    @Test
    public final void testReadWriteBeginning128kb() throws Exception {

        int writeBlockCount = 50;
        int blockFactor = testDataBlock128kb.length / device.getBlockSize();
        long address = 0;

        for (int i = 0; i < writeBlockCount; i++) {
            device.write(address + i * blockFactor, testDataBlock128kb);
        }
        device.flush();
        for (int j = 0; j < writeBlockCount; j++) {
            byte[] result = new byte[testDataBlock128kb.length];
            device.read(address + j * blockFactor, result);
            for (int i = 0; i < testDataBlock128kb.length; i++) {
                assertEquals(result[i], testDataBlock128kb[i]);
            }
        }
    }

#end
#end
#No. 186880
#File: E:\bishe\1\WriteBytesChat.java
#Comment:
    /**
     * @return true if done with this chat
     */

#Code:
    public boolean init(Conversation conversation, SelectionKey key) {
        this.conversation = conversation;
        return process(key);
    }

#end
#end
#No. 186881
#File: E:\bishe\1\WriteBytesChat.java
#Comment:
    /**
     * @return true if done with this chat
     */

#Code:
    public boolean process(SelectionKey key) {
        return write(key, msg);
    }






#end
#end
#No. 186887
#File: E:\bishe\1\WriteClassNameTest_bytes.java
#Comment:
    /**
     * Encode a byte array to hex string
     *
     * @param bytes array of byte to encode
     * @return return encoded string
     */

#Code:
    public static String hex(byte[] bytes) {
        if (bytes == null) {
            return null;
        }

        int bytesLen = bytes.length;
        char[] chars = new char[bytesLen * 2];
        for (int i = 0; i < bytes.length; i++) {
            int a = bytes[i] & 0xFF;
            int b0 = a >> 4;
            int b1 = a & 0xf;

            chars[i * 2] = (char) (b0 + (b0 < 10 ? 48 : 55)); //hexChars[b0];
            chars[i * 2 + 1] = (char) (b1 + (b1 < 10 ? 48 : 55));
        }
        return new String(chars);
    }

#end
#end
#No. 186888
#File: E:\bishe\1\WriteClassNameTest_bytes.java
#Comment:
    /**
     * Decode hex string to a byte array
     *
     * @param hex encoded string
     * @return return array of byte to encode
     */

#Code:
    public static byte[] hex(String hex) {
        if (hex == null)
            return null;

        int len = hex.length();
        if (len % 2 != 0)
            return null;

        char[] chars = hex.toCharArray();
        byte[] bytes = new byte[len / 2];
        for (int i = 0; i < bytes.length; i++) {
            char c0 = chars[i * 2];
            char c1 = chars[i * 2 + 1];
            int b0 = c0 - (c0 <= 57 ? 48 : 55);
            int b1 = c1 - (c1 <= 57 ? 48 : 55);
            bytes[i] = (byte) ((b0 << 4) | b1);
        }
        return bytes;
    }

#end
#end
#No. 186890
#File: E:\bishe\1\WriteConcern.java
#Comment:
  /**
   *
   * @return the timeout in millis
   */

#Code:
  @Nonnegative
  public int getTimeout() {
    return timeout;
  }

#end
#end
#No. 186891
#File: E:\bishe\1\WriteConcern.java
#Comment:
  /**
   * Write operations wait until flush data to disk.
   */

#Code:
  public static WriteConcern fsync() {
    return new IntWriteConcern(SyncMode.FSYNC, 0, 0);
  }

#end
#end
#No. 186892
#File: E:\bishe\1\WriteConcern.java
#Comment:
  /**
   * Write operations wait until flush journa to disk.
   */

#Code:
  public static WriteConcern journal() {
    return new IntWriteConcern(SyncMode.JOURNAL, 0, 0);
  }


#end
#end
#No. 186901
#File: E:\bishe\1\WriteGeoLocationNfcAsync.java
#Comment:
    /**
     * Instantiates a new WriteGeoLocationNfcAsync.
     *
     * @param asyncUiCallback the async ui callback
     * @param asyncOperationCallback the async operation callback
     * @param nfcWriteUtility the nfc write utility
     */

#Code:
    public WriteGeoLocationNfcAsync(@Nullable AsyncUiCallback asyncUiCallback, @NotNull AsyncOperationCallback asyncOperationCallback, @NotNull NfcWriteUtility nfcWriteUtility) {
        super(asyncUiCallback, asyncOperationCallback, nfcWriteUtility);
    }

    @Override
    public void executeWriteOperation(final Intent intent, final Object... args) {
        if (checkDoubleArguments(args.getClass()) || args.length != 2 || intent == null) {
            throw new UnsupportedOperationException("Invalid arguments");
        }

        setAsyncOperationCallback(new AsyncOperationCallback() {
            @Override
            public boolean performWrite(NfcWriteUtility writeUtility) throws ReadOnlyTagException, InsufficientCapacityException, TagNotPresentException, FormatException {
                return writeUtility.writeGeolocationToTagFromIntent((Double) args[0], (Double) args[1], intent);
            }
        });

        super.executeWriteOperation();
    }

#end
#end
#No. 186902
#File: E:\bishe\1\WriteHttpJsonMetricsEndpoint.java
#Comment:
  /**
   * Generates a metric name from json format:
     {
     "values": [197141504, 175136768],
     "dstypes": ["counter", "counter"],
     "dsnames": ["read", "write"],
     "time": 1251533299,
     "interval": 10,
     "host": "leeloo.lan.home.verplant.org",
     "plugin": "disk",
     "plugin_instance": "sda",
     "type": "disk_octets",
     "type_instance": ""
    }

    host "/" plugin ["-" plugin instance] "/" type ["-" type instance] =>
    {plugin}[.{plugin_instance}].{type}[.{type_instance}]
  */

#Code:
  private String getMetricName(final JsonNode metric, int index) {
    JsonNode plugin = metric.get("plugin");
    JsonNode plugin_instance = metric.get("plugin_instance");
    JsonNode type = metric.get("type");
    JsonNode type_instance = metric.get("type_instance");

    if (plugin == null || type == null) {
      throw new IllegalArgumentException("plugin or type is missing");
    }

    StringBuilder sb = new StringBuilder();
    sb.append(plugin.textValue());
    sb.append('.');
    if (plugin_instance != null) {
      String value = plugin_instance.textValue();
      if (value != null && !value.isEmpty()) {
        sb.append(value);
        sb.append('.');
      }
    }
    sb.append(type.textValue());
    sb.append('.');
    if (type_instance != null) {
      String value = type_instance.textValue();
      if (value != null && !value.isEmpty()) {
        sb.append(value);
        sb.append('.');
      }
    }

    JsonNode dsnames = metric.get("dsnames");
    if (dsnames == null || !dsnames.isArray() || dsnames.size() <= index) {
      throw new IllegalArgumentException("dsnames is not set");
    }
    sb.append(dsnames.get(index).textValue());
    return sb.toString();
  }


#end
#end
#No. 186906
#File: E:\bishe\1\WriteOnlyFieldFilter.java
#Comment:
/**
 * This <code>MemberVisitor</code> delegates its visits to program fields to
 * other given <code>MemberVisitor</code> instances, but only when the visited
 * field has been marked as write-only.
 *
 * @see ReadWriteFieldMarker
 * @author Eric Lafortune
 */

#Code:
public class WriteOnlyFieldFilter
extends      SimplifiedVisitor
implements   MemberVisitor
{
    private final MemberVisitor writeOnlyFieldVisitor;


    /**
     * Creates a new WriteOnlyFieldFilter.
     * @param writeOnlyFieldVisitor the <code>MemberVisitor</code> to which
     *                              visits to write-only fields will be delegated.
     */
    public WriteOnlyFieldFilter(MemberVisitor writeOnlyFieldVisitor)
    {
        this.writeOnlyFieldVisitor = writeOnlyFieldVisitor;
    }


    // Implementations for MemberVisitor.

    public void visitProgramField(ProgramClass programClass, ProgramField programField)
    {

        if (ReadWriteFieldMarker.isWritten(programField) &&
            !ReadWriteFieldMarker.isRead(programField))
        {
            writeOnlyFieldVisitor.visitProgramField(programClass, programField);
        }
    }
}

#end
#end
#No. 186907
#File: E:\bishe\1\WriteOption.java
#Comment:
/**
 * Enum representing the mongoDB Java Driver's {@link com.mongodb.WriteConcern}
 *
 * @author <a href="mailto:nscavell@redhat.com">Nick Scavelli</a>
 */

#Code:
public enum WriteOption {
  /**
   * @see com.mongodb.WriteConcern#ACKNOWLEDGED
   */
  ACKNOWLEDGED,
  /**
   * @see com.mongodb.WriteConcern#UNACKNOWLEDGED
   */
  UNACKNOWLEDGED,
  /**
   * @see com.mongodb.WriteConcern#FSYNCED
   */
  FSYNCED,
  /**
   * @see com.mongodb.WriteConcern#JOURNALED
   */
  JOURNALED,
  /**
   * @see com.mongodb.WriteConcern#REPLICA_ACKNOWLEDGED
   */
  REPLICA_ACKNOWLEDGED,
  /**
   * @see com.mongodb.WriteConcern#MAJORITY
   */
  MAJORITY
}

#end
#end
#No. 186908
#File: E:\bishe\1\WritePendingException.java
#Comment:
/**
 * Unchecked exception thrown when an attempt is made to write to an
 * asynchronous socket channel and a previous write has not completed.
 *
 * @since 1.7
 */

#Code:

public class WritePendingException
    extends IllegalStateException
{

    private static final long serialVersionUID = 7031871839266032276L;

    /**
     * Constructs an instance of this class.
     */
    public WritePendingException() { }

}

#end
#end
#No. 186909
#File: E:\bishe\1\WritePhoneNfcAsync.java
#Comment:
    /**
     * Instantiates a new WritePhoneNfcAsync.
     *
     * @param asyncUiCallback the async ui callback
     * @param asyncOperationCallback the async operation callback
     * @param nfcWriteUtility the nfc write utility
     */

#Code:
    public WritePhoneNfcAsync(@Nullable AsyncUiCallback asyncUiCallback, @NotNull AsyncOperationCallback asyncOperationCallback, @NotNull NfcWriteUtility nfcWriteUtility) {
        super(asyncUiCallback, asyncOperationCallback, nfcWriteUtility);
    }

    @Override
    public void executeWriteOperation(final Intent intent, final Object... args) {
        if (checkStringArguments(args.getClass()) || args.length != 1 || intent == null) {
            throw new UnsupportedOperationException("Invalid arguments");
        }

        setAsyncOperationCallback(new AsyncOperationCallback() {
            @Override
            public boolean performWrite(NfcWriteUtility writeUtility) throws ReadOnlyTagException, InsufficientCapacityException, TagNotPresentException, FormatException {
                return writeUtility.writeTelToTagFromIntent((String) args[0], intent);
            }
        });
        super.executeWriteOperation();
    }

#end
#end
#No. 186910
#File: E:\bishe\1\WriteProjectProperties.java
#Comment:
/**
 * Writes project properties to a file.
 *
 * @author <a href="mailto:zarars@gmail.com">Zarar Siddiqi</a>
 * @version $Id$
 */

#Code:
@Mojo( name = "write-project-properties", defaultPhase = LifecyclePhase.NONE, threadSafe = true )
public class WriteProjectProperties
    extends AbstractWritePropertiesMojo
{
    /** {@inheritDoc} */
    public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        validateOutputFile();
        Properties projProperties = new Properties();
        projProperties.putAll( getProject().getProperties() );

        Properties systemProperties = System.getProperties();

        // allow system properties to over write key/value found in maven properties
        Enumeration<?> enumeration = systemProperties.keys();
        while ( enumeration.hasMoreElements() )
        {
            String key = (String) enumeration.nextElement();
            String value = systemProperties.getProperty( key );
            if ( projProperties.get( key ) != null )
            {
                projProperties.put( key, value );
            }

        }

        writeProperties( projProperties, getOutputFile() );
    }
}




#end
#end
#No. 186914
#File: E:\bishe\1\WriterNode.java
#Comment:
    /**
     * Deal with the cancel signal.
     */

#Code:
    private void cancel() {
        // just set stopped flag to true so that the writer is not used anymore
        this.isStopped.set(true);
    }

#end
#end
#No. 186915
#File: E:\bishe\1\WriterPool.java
#Comment:
    /**
     * Discard a previously-used writer, cleanly closing it and leaving it out
     * of the pool. 
     * @param writer
     * @throws IOException
     */

#Code:
    public synchronized void destroyWriter(WriterPoolMember writer) throws IOException {
        currentActive--; 
        writer.close();
    }

#end
#end
#No. 186916
#File: E:\bishe\1\WriterPool.java
#Comment:
    /**
     * Return a writer, for likely reuse unless (1) writer's current file has 
     * reached its target size; and (2) there's been no demand for additional 
     * writers since the last time a new writer-file was rolled-over. In that
     * case, the possibly-superfluous writer instance is discarded. 
	 * @param writer Writer to return to the pool.
	 * @throws IOException Problem returning File to pool.
	 */

#Code:
    public void returnFile(WriterPoolMember writer)
    throws IOException {
        synchronized(this) {
            if(writer.isOversize()) {
            // maybe retire writer rather than recycle
                if(lastWriterNeededTime<=lastWriterRolloverTime) {
                    // no timeouts waiting for recycled writer since last writer rollover
                    destroyWriter(writer);
                    return;
                } else {
                    // reuse writer instance, causing new file to be created
                    lastWriterRolloverTime = System.currentTimeMillis();
                }
            }
        }
        if(!availableWriters.offer(writer)) {
            logger.log(Level.WARNING, "writer unreturnable to available pool; closing early");
            destroyWriter(writer); 
        }
    }

#end
#end
#No. 186917
#File: E:\bishe\1\WriterPool.java
#Comment:
    /**
     * Close and discard a writer that experienced a potentially-corrupting
     * error. 
     * @param f writer with problem 
     * @throws IOException
     */

#Code:
    public synchronized void invalidateFile(WriterPoolMember f)
    throws IOException {
        try {
            destroyWriter(f);
        } catch (Exception e) {
            // Convert exception.
            throw new IOException(e.getMessage());
        }
        // It'll have been closed.  Rename with an '.invalid' suffix so it
        // gets attention.
        File file = f.getFile();
        file.renameTo(new File(file.getAbsoluteFile() +
                WriterPoolMember.INVALID_SUFFIX));
    }

#end
#end
#No. 186918
#File: E:\bishe\1\WriterPool.java
#Comment:
	/**
	 * @return Number of {@link WriterPoolMember}s checked out of pool.
	 * @throws java.lang.UnsupportedOperationException
	 */

#Code:
    public synchronized int getNumActive()
    throws UnsupportedOperationException {
        return currentActive - getNumIdle();
    }

#end
#end
#No. 186919
#File: E:\bishe\1\WriterPool.java
#Comment:
	/**
	 * @return Number of {@link WriterPoolMember} instances still in the pool.
	 * @throws java.lang.UnsupportedOperationException
	 */

#Code:
    public int getNumIdle()
    throws UnsupportedOperationException {
        return availableWriters.size();
    }

#end
#end
#No. 186920
#File: E:\bishe\1\WriterPool.java
#Comment:
	/**
	 * Close all {@link WriterPoolMember}s in pool.
	 */

#Code:
    public void close() {
        Collection<WriterPoolMember> writers = drainAllWriters();
        for (WriterPoolMember writer: writers) {
            try {
                destroyWriter(writer);
            } catch (IOException e) {
                logger.log(Level.WARNING,"problem closing writer",e); 
            }
        }
    }

#end
#end
#No. 186921
#File: E:\bishe\1\WriterPool.java
#Comment:
	/**
	 * @return Returns settings.
	 */

#Code:
    public WriterPoolSettings getSettings() {
        return this.settings;
    }

#end
#end
#No. 186922
#File: E:\bishe\1\WriterPool.java
#Comment:
    /**
     * @return State of the pool string
     */

#Code:
    protected String getPoolState() {
        StringBuffer buffer = new StringBuffer("Active ");
        buffer.append(getNumActive());
        buffer.append(" of max ");
        buffer.append(maxActive);
        buffer.append(", idle ");
        buffer.append(getNumIdle());
        return buffer.toString();
    }

#end
#end
#No. 186923
#File: E:\bishe\1\WriterPool.java
#Comment:
    /**
     * Returns the atomic integer used to generate serial numbers
     * for files.
     * 
     * @return  the serial number generator
     */

#Code:
    public AtomicInteger getSerialNo() {
        return serialNo;
    }

#end
#end
#No. 186924
#File: E:\bishe\1\WriterPool.java
#Comment:
    /**
     * Drains all the active writers from {@link #availableWriters}, blocking to
     * wait for any writers currently in use to become available.
     * 
     * <p>
     * When finished with writers, call availableWriters.addAll(...) to put them
     * back into the rotation.
     * 
     * @return all the active writers
     */

#Code:
    protected synchronized Collection<WriterPoolMember> drainAllWriters() {
        LinkedList<WriterPoolMember> writers = new LinkedList<WriterPoolMember>();
        availableWriters.drainTo(writers);

        while (writers.size() < currentActive) {
            try {
                WriterPoolMember w = availableWriters.take();
                writers.add(w);
            } catch (InterruptedException e) {
                logger.severe("caught " + e + " while waiting for writers to free up; returning only "
                        + writers.size() + " of " + currentActive + " active writers");
                break;
            }
        }
        
        return writers;
    }





#end
#end
#No. 186931
#File: E:\bishe\1\WriterPoolProcessor.java
#Comment:
    /**
     * Whether to close output files and start new ones on checkpoint. True by
     * default. If false, merely flushes writers.
     */

#Code:
    public void setStartNewFilesOnCheckpoint(boolean startNewFilesOnCheckpoint) {
        this.startNewFilesOnCheckpoint = startNewFilesOnCheckpoint;
    }


#end
#end
#No. 186933
#File: E:\bishe\1\WriterPoolProcessor.java
#Comment:
    /**
     * Whether the given CrawlURI should be written to archive files.
     * Annotates CrawlURI with a reason for any negative answer.
     * 
     * @param curi CrawlURI
     * @return true if URI should be written; false otherwise
     */

#Code:
    protected boolean shouldWrite(CrawlURI curi) {
        if (getSkipIdenticalDigests()
            && IdenticalDigestDecideRule.hasIdenticalDigest(curi)) {
            curi.getAnnotations().add(ANNOTATION_UNWRITTEN 
                    + ":identicalDigest");
            return false;
        }
        
        boolean retVal;
        String scheme = curi.getUURI().getScheme().toLowerCase();
        // TODO: possibly move this sort of isSuccess() test into CrawlURI
        if (scheme.equals("dns")) {
            retVal = curi.getFetchStatus() == S_DNS_SUCCESS;
        } else if (scheme.equals("whois")) {
            retVal = curi.getFetchStatus() == S_WHOIS_SUCCESS;
        } else if (scheme.equals("http") || scheme.equals("https")) {
            retVal = curi.getFetchStatus() > 0 && curi.isHttpTransaction();
        } else if (scheme.equals("ftp")) {
            retVal = curi.getFetchStatus() > 0;
        } else {
            logger.info("This writer does not write out scheme " +
                    scheme + " content");
            curi.getAnnotations().add(ANNOTATION_UNWRITTEN
                    + ":scheme");
            return false;
        }
        
        if (retVal == false) {
            // status not deserving writing
            curi.getAnnotations().add(ANNOTATION_UNWRITTEN + ":status");
            return false;
        }
        
        return true; 
    }

#end
#end
#No. 186934
#File: E:\bishe\1\WriterPoolProcessor.java
#Comment:
    /**
     * Return IP address of given URI suitable for recording (as in a
     * classic ARC 5-field header line).
     * 
     * @param curi CrawlURI
     * @return String of IP address
     */

#Code:
    protected String getHostAddress(CrawlURI curi) {
        // special handling for DNS URIs: want address of DNS server
        if (curi.getUURI().getScheme().toLowerCase().equals("dns")) {
            return (String)curi.getData().get(A_DNS_SERVER_IP_LABEL);
        }
        // otherwise, host referenced in URI
        // TODO:FIXME: have fetcher insert exact IP contacted into curi,
        // use that rather than inferred by CrawlHost lookup 
        CrawlHost h = getServerCache().getHostFor(curi.getUURI());
        if (h == null) {
            throw new NullPointerException("Crawlhost is null for " +
                curi + " " + curi.getVia());
        }
        InetAddress a = h.getIP();
        if (a == null) {
            throw new NullPointerException("Address is null for " +
                curi + " " + curi.getVia() + ". Address " +
                ((h.getIpFetched() == CrawlHost.IP_NEVER_LOOKED_UP)?
                     "was never looked up.":
                     (System.currentTimeMillis() - h.getIpFetched()) +
                         " ms ago."));
        }
        return h.getIP().getHostAddress();
    }

#end
#end
#No. 186935
#File: E:\bishe\1\WriterPoolProcessor.java
#Comment:
    /**
     * If this fetch is identical to the last written (archived) fetch, then
     * copy forward the writeTag. This method should generally be called when
     * writeTag is present from a previous identical fetch, even though this
     * particular fetch is not being written anywhere (not even a revisit
     * record).
     */

#Code:
    protected void copyForwardWriteTagIfDupe(CrawlURI curi) {
        if (IdenticalDigestDecideRule.hasIdenticalDigest(curi)) {
            Map<String,Object>[] history = curi.getFetchHistory();
            if (history != null && history[1].containsKey(A_WRITE_TAG)) {
                history[0].put(A_WRITE_TAG, history[1].get(A_WRITE_TAG));
            }
        }
    }

#end
#end
#No. 186936
#File: E:\bishe\1\WriteSmsNfcAsync.java
#Comment:
    /**
     * Instantiates a new WriteSmsNfcAsync.
     *
     * @param asyncUiCallback the async ui callback
     * @param asyncOperationCallback the async operation callback
     * @param nfcWriteUtility the nfc write utility
     */

#Code:
    public WriteSmsNfcAsync(@Nullable AsyncUiCallback asyncUiCallback, @NotNull AsyncOperationCallback asyncOperationCallback, @NotNull NfcWriteUtility nfcWriteUtility) {
        super(asyncUiCallback, asyncOperationCallback, nfcWriteUtility);
    }

    @Override
    public void executeWriteOperation(final Intent intent, final Object... args) {
        if (checkStringArguments(args.getClass()) || args.length != 2 || intent == null) {
            throw new UnsupportedOperationException("Invalid arguments");
        }

        setAsyncOperationCallback(new AsyncOperationCallback() {
            @Override
            public boolean performWrite(NfcWriteUtility writeUtility) throws ReadOnlyTagException, InsufficientCapacityException, TagNotPresentException, FormatException {
                return writeUtility.writeSmsToTagFromIntent((String) args[0], (String) args[1], intent);
            }
        });
        super.executeWriteOperation();
    }


#end
#end
#No. 186943
#File: E:\bishe\1\WriteTagActivity.java
#Comment:
    /*
     * This is called for activities that set launchMode to "singleTop" or
     * "singleTask" in their manifest package, or if a client used the
     * FLAG_ACTIVITY_SINGLE_TOP flag when calling startActivity(Intent).
     */

#Code:
    @Override
    protected void onNewIntent(Intent intent) {
        Log.d(TAG, "onNewIntent: " + intent);

        if (mWriteMode) {
            // Currently in tag WRITING mode
            if (intent.getAction().equals(NfcAdapter.ACTION_TAG_DISCOVERED)) {
                Tag detectedTag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
                writeTag(buildNdefMessage(), detectedTag);
                	
                mImageViewImage.setImageDrawable(getResources().getDrawable(R.drawable.android_blue_logo));
                mEditTextData.setEnabled(true);
            }
        }
    }    

#end
#end
#No. 186948
#File: E:\bishe\1\WriteTests.java
#Comment:
	/**
	 * <p>
	 *    Parses a string for a Long value, guarding against null and parse
	 *    exceptions
	 * </p>
	 * 
	 * @param val String to parse for Long value
	 * @return Long value
	 */

#Code:
	private Long castToLong(String val){
		if(val == null){
			return null;
		}
		
		Long ret = null;
		try{
			ret = new Long(val);
		}
		catch(Exception e){
			return null;
		}
		
		return ret;
	}

#end
#end
#No. 186949
#File: E:\bishe\1\WriteTestServlet.java
#Comment:
    /**
     * Processes requests for both HTTP
     * <code>GET</code> and
     * <code>POST</code> methods.
     *
     * @param request servlet request
     * @param response servlet response
     * @throws ServletException if a servlet-specific error occurs
     * @throws IOException if an I/O error occurs
     */

#Code:
    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        try (PrintWriter out = response.getWriter()) {
            out.println("<!DOCTYPE html>");
            out.println("<html>");
            out.println("<head>");
            out.println("<title>Writing Asynchronously</title>");
            out.println("</head>");
            out.println("<body>");
            out.println("<h1>Writing Asynchronously</h1>");

            AsyncContext context = request.startAsync();
            ServletOutputStream output = response.getOutputStream();
            output.setWriteListener(new MyWriteListener(output, context));

            out.println("</body>");
            out.println("</html>");
        }
    }

#end
#end
#No. 186950
#File: E:\bishe\1\WriteTestServlet.java
#Comment:
    /**
     * Handles the HTTP
     * <code>GET</code> method.
     *
     * @param request servlet request
     * @param response servlet response
     * @throws ServletException if a servlet-specific error occurs
     * @throws IOException if an I/O error occurs
     */

#Code:
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        processRequest(request, response);
    }

#end
#end
#No. 186951
#File: E:\bishe\1\WriteTestServlet.java
#Comment:
    /**
     * Handles the HTTP
     * <code>POST</code> method.
     *
     * @param request servlet request
     * @param response servlet response
     * @throws ServletException if a servlet-specific error occurs
     * @throws IOException if an I/O error occurs
     */

#Code:
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        processRequest(request, response);
    }

#end
#end
#No. 186952
#File: E:\bishe\1\WriteTestServlet.java
#Comment:
    /**
     * Returns a short description of the servlet.
     *
     * @return a String containing servlet description
     */

#Code:
    @Override
    public String getServletInfo() {
        return "Short description";
    }// </editor-fold>


#end
#end
#No. 186954
#File: E:\bishe\1\WriteType.java
#Comment:
/**
 * The type of a Cassandra write query.
 * <p>
 * This information is returned by Cassandra when a write timeout is raised to
 * indicate what type of write timed out. This information is useful to decide
 * which retry policy to adopt.
 */

#Code:
public enum WriteType
{
    /** A write to a single partition key. Such writes are guaranteed to be atomic and isolated. */
    SIMPLE,
    /**
     * A write to a multiple partition key that used the distributed batch log to ensure atomicity
     * (atomicity meaning that if any statement in the batch succeeds, all will eventually succeed).
     */
    BATCH,
    /** A write to a multiple partition key that doesn't use the distributed batch log. Atomicity for such writes is not guaranteed */
    UNLOGGED_BATCH,
    /** A counter write (that can be for one or multiple partition key). Such write should not be replayed to avoid over-counting. */
    COUNTER,
    /** The initial write to the distributed batch log that Cassandra performs internally before a BATCH write. */
    BATCH_LOG,
    /**
     * A conditional write. If a timeout has this {@code WriteType}, the timeout has happened while doing the compare-and-swap for
     * an conditional update. In this case, the update may or may not have been applied.
     */
    CAS;
}



#end
#end
#No. 186958
#File: E:\bishe\1\WrongArgumentsException.java
#Comment:
/**
 * Implements an exception thrown when the CLI is given wrong arguments.
 */

#Code:
public class WrongArgumentsException
        extends AbnormalTerminationException {

    private static final long serialVersionUID = 1;

    /**
     * Creates an exception thrown when the CLI is given wrong arguments.
     */
    public WrongArgumentsException() {
        super("Wrong arguments. Use 'Cli -help' for help.");
    }

    /**
     * Creates an exception thrown when the CLI is given wrong arguments.
     *
     * @param s A string describing the problem.
     */
    public WrongArgumentsException(String s) {
        super(s + ". Use 'Cli -help' for help.");
    }
}



#end
#end
#No. 186962
#File: E:\bishe\1\WrongPlaceholderDetector.java
#Comment:
    /**
     * Check all private method invocation, to detect {@code SLF4J_PLACE_HOLDER_MISMATCH}.
     * 
     * @see https://github.com/KengoTODA/findbugs-slf4j/issues/35
     */

#Code:
    private void validatePrivateMethodCall() {
        for (Cell<Method, Integer, List<PotentialPlaceHolderMismatch>> cell : potentialPlaceHolderMismatch.cellSet()) {
            Method method = cell.getRowKey();
            Integer argumentIndex = cell.getColumnKey();
            List<Object> constants = getConstantsToCall(method, argumentIndex);
            if (constants == null) {
                continue;
            }
            for (PotentialPlaceHolderMismatch bug : cell.getValue()) {
                for (Object constant : constants) {
                    int placeholders = countPlaceholder(constant.toString());
                    if (placeholders != bug.getParameterCount()) {
                        getBugReporter().reportBug(bug.getRawBug(placeholders));
                    }
                }
            }
        }
        for (Cell<Method, Integer, List<PotentialSignOnlyFormat>> cell : potentialSignOnlyFormat.cellSet()) {
            Method method = cell.getRowKey();
            Integer argumentIndex = cell.getColumnKey();
            List<Object> constants = getConstantsToCall(method, argumentIndex);
            if (constants == null) {
                continue;
            }
            for (PotentialSignOnlyFormat bug : cell.getValue()) {
                for (Object constant : constants) {
                    String format = constant.toString();
                    if (!verifyFormat(format)) {
                        getBugReporter().reportBug(bug.getRawBug(format));
                    }
                }
            }
        }
    }

#end
#end
#No. 186963
#File: E:\bishe\1\WrongPlaceholderDetector.java
#Comment:
    /**
     * @return true if given formatString is valid
     */

#Code:
    private boolean verifyFormat(@Nonnull String formatString) {
        CodepointIterator iterator = new CodepointIterator(formatString);
        while (iterator.hasNext()) {
            if (Character.isLetter(iterator.next().intValue())) {
                // found non-sign character.
                return true;
            }
        }

#end
#end
#No. 186964
#File: E:\bishe\1\WrongReccordDatasException.java
#Comment:
	/**
	 * @param text
	 *            the source of the exception
	 */

#Code:
	public WrongReccordDatasException(String text) {
		super(text);
	}

#end
#end
#No. 186967
#File: E:\bishe\1\WS2RESTAdapter.java
#Comment:
    /**
     * Get name of channel from input message. Expected format of message: {"channel":"my_channel"}. Method return {@code null} if message
     * is invalid.
     */

#Code:
    private String parseSubscriptionMessage(InputMessage input) {
        final JsonParser p = new JsonParser();
        try {
            p.parse(new StringReader(input.getBody()));
        } catch (JsonException e) {
            return null;
        }
        final JsonValue jv = p.getJsonObject().getElement("channel");
        return jv != null ? jv.getStringValue() : null;
    }

#end
#end
#No. 186968
#File: E:\bishe\1\WSBaseActivity.java
#Comment:
    /**
     * Initialize the view.
     *
     * This has to be done after onCreate() because the various drawer resources need to exist
     * already, so this is called explicitly in the constructor of child objects.
     *
     * @return
     *   true if the caller should continue processing
     *   false if authentication is needed and the caller should finish()
     */

#Code:
    protected boolean initView() {
        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
        mLeftDrawerList = (ListView) mDrawerLayout.findViewById(R.id.left_drawer);
        mLeftDrawerList.setChoiceMode(ListView.CHOICE_MODE_SINGLE);

        mToolbar = (Toolbar) findViewById(R.id.toolbar);
        mNavDrawerListAdapter = new NavDrawerListAdapter(this, mNavRowList, mCurrentActivity);
        mLeftDrawerList.setAdapter(mNavDrawerListAdapter);
        mLeftDrawerList.setOnItemClickListener(this);

        if (mToolbar != null) {
            mToolbar.setTitle(mActivityFriendly);
            setSupportActionBar(mToolbar);
        }

        mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, mToolbar, R.string.drawer_open, R.string.drawer_close) {

            @Override
            public void onDrawerClosed(View drawerView) {
                super.onDrawerClosed(drawerView);
            }

            @Override
            public void onDrawerOpened(View drawerView) {
                super.onDrawerOpened(drawerView);
            }
        };
        mDrawerLayout.setDrawerListener(mDrawerToggle);

        // Make sure we have an active account, or go to authentication screen
        if (!setupCredentials()) {
            return(false);
        }
        initDrawer();

        return true;
    }

#end
#end
#No. 186969
#File: E:\bishe\1\WSBaseActivity.java
#Comment:
    /**
     * Handle click from ListView in NavigationDrawer
     *
     * @param parent
     * @param view
     * @param position
     * @param id
     */

#Code:
    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        String[] activities = getResources().getStringArray(R.array.nav_menu_activities);
        if (mActivityName.equals(activities[position])) return;

        try {
            Class activityClass = Class.forName(this.getPackageName() + ".activity." + activities[position]);
            Intent i = new Intent(this, activityClass);
            startActivity(i);
        } catch (ClassNotFoundException e) {
            Log.i(TAG, "Class not found: " + activities[position]);
        }

        mDrawerLayout.closeDrawers();
    }

#end
#end
#No. 186970
#File: E:\bishe\1\WSBaseActivity.java
#Comment:
    /**
     * @return true if we already have an account set up in the AccountManager
     * false if we have to wait for the auth screen to process
     */

#Code:
    public boolean setupCredentials() {
        try {
            AuthenticationHelper.getWarmshowersAccount();
            if (MemberInfo.getInstance() == null) {
                MemberInfo.initInstance(null); // Try to get persisted information
            }
            return true;
        } catch (NoAccountException e) {

            if (this.getClass() != AuthenticatorActivity.class) {  // Would be circular, so don't do it.
                Intent i = new Intent(this, AuthenticatorActivity.class);
                i.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
                startActivity(i);
            }
            return false;
        }
    }

#end
#end
#No. 186971
#File: E:\bishe\1\WSBindingInfoProvider.java
#Comment:
	/**
	 * 
	 * @param frascatiScaImporter
	 */

#Code:
	public WSBindingInfoProvider(AbstractScaImporterBase frascatiScaImporter) {
		super(frascatiScaImporter);
	}

#end
#end
#No. 186982
#File: E:\bishe\1\WSClient.java
#Comment:
    /**
     * Connect to server endpoint.
     *
     * @param timeout
     *         connection timeout value in seconds
     * @throws IOException
     *         if connection failed
     * @throws SocketTimeoutException
     *         if timeout occurs while try to connect to server endpoint
     * @throws IllegalArgumentException
     *         if {@code timeout} zero or negative
     */

#Code:
    public void connect(int timeout) throws IOException, DeploymentException {
        if (timeout < 1) {
            throw new IllegalArgumentException(String.format("Invalid timeout: %d", timeout));
        }
        final WebSocketContainer container = getWebSocketContainer();
        container.setAsyncSendTimeout(1);
        try {
            executor.submit(new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    final Session session = container.connectToServer(WSClient.this, serverUri);
                    final Basic remoteEndpoint = session.getBasicRemote();
                    for (String channel : channels) {
                        remoteEndpoint.sendObject(newSubscribeChannelMessage(uuid(), channel));
                    }
                    return null;
                }
            }).get(timeout, SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } catch (TimeoutException e) {
            throw new SocketTimeoutException("Connection timeout");
        } catch (ExecutionException e) {
            propagateIfPossible(e.getCause(), IOException.class, DeploymentException.class);
            propagate(e);
        }
    }

#end
#end
#No. 186983
#File: E:\bishe\1\WSConnectionContext.java
#Comment:
    /**
     * Send message to all connections subscribed to the channel. Method tries to send message to as many connections as
     * possible. Even if method fails to send message to the first connection it will try to send message to other
     * connections, if any. After that a first occurred error is rethrown.
     *
     * @param message
     *         message
     * @throws EncodeException
     *         if message cannot be serialized
     * @throws IOException
     *         if any i/o error occurs when try to send message to client
     * @see org.everrest.websockets.message.ChannelBroadcastMessage#getChannel()
     */

#Code:
    public static void sendMessage(ChannelBroadcastMessage message) throws EncodeException, IOException {
        final String channel = message.getChannel();
        final RestOutputMessage transport = newRestOutputMessage(message);
        Exception error = null;
        for (WSConnectionImpl connection : connections.values()) {
            if (connection.getChannels().contains(channel)) {
                try {
                    connection.sendMessage(transport);
                } catch (EncodeException | IOException e) {
                    if (error == null) {
                        error = e;
                    }
                }
            }
        }
        if (error instanceof EncodeException) {
            throw (EncodeException)error;
        } else if (error != null) {
            // If error is not null then may be IOException only.
            throw (IOException)error;
        }
    }


#end
#end
#No. 186987
#File: E:\bishe\1\Wsdl2ByteCodesTest.java
#Comment:
	/**
	 * @see org.jaxws.wsdl2bytecodes.service.Wsdl2ByteCodes#generatePakcageName
	 */

#Code:
	@Test
	public void testGeneratePakcageName() {
		String packageName = generatePakcageName(formatDate(new Date(), "yyyyMMddHHmmssSSS"));
		System.out.println(packageName);
	}

#end
#end
#No. 186988
#File: E:\bishe\1\Wsdl2Html.java
#Comment:
	/**
	 * 
	 * 
	 * 
	 * @param wsdlUrl
	 * @return
	 * @throws WsdlImportException
	 */

#Code:
	public static String generateHtml(String wsdlUrl) throws WsdlImportException {
		FreemarkerWebServiceDisplayEngine displayEngine = ClasspathFreemarkerWebServiceDisplayEngine.createEngine();
		String byteCodesDirParent = System.getProperty("java.io.tmpdir") + "/wsdl2html";
		return generateHtml(byteCodesDirParent, wsdlUrl, displayEngine);
	}





#end
#end
#No. 186993
#File: E:\bishe\1\WSDLService.java
#Comment:
	/**
	 * Application name
	 * @return Application name
	 */

#Code:
	public String getAppName() {
		return appName;
	}

#end
#end
#No. 186994
#File: E:\bishe\1\WSDLService.java
#Comment:
	/**
	 * Service name
	 * @return Service name
	 */

#Code:
	public String getServiceName(){
		return serviceName;
	}

#end
#end
#No. 186995
#File: E:\bishe\1\WSDLService.java
#Comment:
	/**
	 * Service URL
	 * @return Service URL
	 */

#Code:
	public String getUrl() {
		return url;
	}



#end
#end
#No. 187001
#File: E:\bishe\1\WsFrameEncodingSupport.java
#Comment:
    /**
     * Encode WebSocket message as a single frame, with the provided masking value applied.
     */

#Code:
    public static ByteBuffer rfc6455Encode(WsMessage message, int maskValue) {
        final boolean mask = true;

        boolean fin = true;   // TODO continued frames?

        ByteBuffer buf = message.getBytes();
        
        int remaining = buf.remaining();

        int offset = 2 + (mask ? 4 : 0) + calculateLengthSize(remaining);
        
        ByteBuffer b = ByteBuffer.allocate(offset + remaining);

        int start = b.position();

        byte b1 = (byte) (fin ? 0x80 : 0x00);
        byte b2 = (byte) (mask ? 0x80 : 0x00);

        b1 = doEncodeOpcode(b1, message);
        b2 |= lenBits(remaining);

        b.put(b1).put(b2);

        doEncodeLength(b, remaining);

        if (mask) {
            b.putInt(maskValue);
        }
        //put message data
        b.put(buf);
        
           if ( mask ) {
               b.position(offset);
            mask(b, maskValue);
        }
        
          b.limit(b.position());
           b.position(start);
           return b;
    }

#end
#end
#No. 187002
#File: E:\bishe\1\WsFrameEncodingSupport.java
#Comment:
    /**
     * Encode a WebSocket opcode onto a byte that might have some high bits set.
     *
     * @param b
     * @param message
     * @return
     */

#Code:
    private static byte doEncodeOpcode(byte b, WsMessage message) {
        switch (message.getKind()) {
        case TEXT: {
            b |= Opcode.TEXT.getCode();
            break;
        }
        case BINARY: {
            b |= Opcode.BINARY.getCode();
            break;
        }
        case PING: {
            b |= Opcode.PING.getCode();
            break;
        }
        case PONG: {
            b |= Opcode.PONG.getCode();
            break;
        }
        case CLOSE: {
            b |= Opcode.CLOSE.getCode();
            break;
        }
        default:
            throw new IllegalArgumentException("Unrecognized frame type: " + message.getKind());
        }
        return b;
    }

#end
#end
#No. 187003
#File: E:\bishe\1\WsFrameEncodingSupport.java
#Comment:
    /**
     * Performs an in-situ masking of the readable buf bytes.
     * Preserves the position of the buffer whilst masking all the readable bytes,
     * such that the masked bytes will be readable after this invocation.
     *
     * @param buf   the buffer containing readable bytes to be masked.
     * @param mask  the mask to apply against the readable bytes of buffer.
     */

#Code:
    public static void mask(ByteBuffer buf, int mask) {
        // masking is the same as unmasking due to the use of bitwise XOR.
        unmask(buf, mask);
    }

#end
#end
#No. 187004
#File: E:\bishe\1\WsFrameEncodingSupport.java
#Comment:
    /**
     * Performs an in-situ unmasking of the readable buf bytes.
     * Preserves the position of the buffer whilst unmasking all the readable bytes,
     * such that the unmasked bytes will be readable after this invocation.
     *
     * @param buf   the buffer containing readable bytes to be unmasked.
     * @param mask  the mask to apply against the readable bytes of buffer.
     */

#Code:
    public static void unmask(ByteBuffer buf, int mask) {
        byte b;
        int remainder = buf.remaining() % 4;
        int remaining = buf.remaining() - remainder;
        int end = remaining + buf.position();

        // xor a 32bit word at a time as long as possible
        while (buf.position() < end) {
            int plaintext = buf.getInt(buf.position()) ^ mask;
            buf.putInt(plaintext);
        }

        // xor the remaining 3, 2, or 1 bytes
        switch (remainder) {
        case 3:
            b = (byte) (buf.get(buf.position()) ^ ((mask >> 24) & 0xff));
            buf.put(b);
            b = (byte) (buf.get(buf.position()) ^ ((mask >> 16) & 0xff));
            buf.put(b);
            b = (byte) (buf.get(buf.position()) ^ ((mask >> 8) & 0xff));
            buf.put(b);
            break;
        case 2:
            b = (byte) (buf.get(buf.position()) ^ ((mask >> 24) & 0xff));
            buf.put(b);
            b = (byte) (buf.get(buf.position()) ^ ((mask >> 16) & 0xff));
            buf.put(b);
            break;
        case 1:
            b = (byte) (buf.get(buf.position()) ^ (mask >> 24));
            buf.put(b);
            break;
        case 0:
        default:
                break;
        }
    }


#end
#end
#No. 187007
#File: E:\bishe\1\WsImportTest.java
#Comment:
    /**
     * Create a generated test WSDL in a new temporary directory.
     * @return
     * @throws IOException
     */

#Code:
    private static File generateTempWsdl() throws IOException {
        File dir = createTempDirectory();
        File tmpWsdl = new File(dir, "test.wsdl");
        String doc = XmlSchemaEnhancerTest.readWsdl(PersonService.class);
        FileUtils.write(tmpWsdl, doc);
        return tmpWsdl;
    }



#end
#end
#No. 187010
#File: E:\bishe\1\WsimportTool.java
#Comment:
        /**
         * User-specified error listener.
         * This field can be null, in which case errors need to be discarded.
         */

#Code:
    	private WsimportListener wsimportListener;

		@Override
		public void error(SAXParseException exception) {
			if (wsimportListener != null) {
				wsimportListener.error(exception);
			}
		}


#end
#end
#No. 187013
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * Executes a command on a remote shell by communicating with the WinRM server from the remote host.
     * Method creates a shell, runs a command on the shell, waits for the command execution to finnish, retrieves the result then deletes the shell.
     *
     * @param wsManRequestInputs
     * @return a map with the result of the command and the exit code of the command execution.
     * @throws RuntimeException
     * @throws IOException
     * @throws InterruptedException
     * @throws ParserConfigurationException
     * @throws TransformerException
     * @throws XPathExpressionException
     * @throws TimeoutException
     * @throws URISyntaxException
     * @throws SAXException
     */

#Code:
    public Map<String, String> runCommand(WSManRequestInputs wsManRequestInputs) throws RuntimeException, IOException, InterruptedException, ParserConfigurationException, TransformerException, XPathExpressionException, TimeoutException, URISyntaxException, SAXException {
        CSHttpClient csHttpClient = new CSHttpClient();
        HttpClientInputs httpClientInputs = new HttpClientInputs();
        URL url = buildURL(wsManRequestInputs, WSMAN_RESOURCE_URI);
        httpClientInputs = setCommonHttpInputs(httpClientInputs, url, wsManRequestInputs);
        String shellId = createShell(csHttpClient, httpClientInputs, wsManRequestInputs);
        WSManUtils.validateUUID(shellId, SHELL_ID);
        String commandStr = POWERSHELL_SCRIPT_PREFIX + " " + EncoderDecoder.encodeStringInBase64(wsManRequestInputs.getScript(), Charsets.UTF_16LE);
        String commandId = executeCommand(csHttpClient, httpClientInputs, shellId, wsManRequestInputs, commandStr);
        WSManUtils.validateUUID(commandId, COMMAND_ID);
        Map<String, String> scriptResults = receiveCommandResult(csHttpClient, httpClientInputs, shellId, commandId, wsManRequestInputs);
        deleteShell(csHttpClient, httpClientInputs, shellId, wsManRequestInputs);
        return scriptResults;
    }

#end
#end
#No. 187014
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * Configures the HttpClientInputs object with the most common http parameters.
     *
     * @param httpClientInputs
     * @param url
     * @param wsManRequestInputs
     * @return the configured HttpClientInputs object.
     * @throws MalformedURLException
     */

#Code:
    private static HttpClientInputs setCommonHttpInputs(HttpClientInputs httpClientInputs, URL url, WSManRequestInputs wsManRequestInputs) throws MalformedURLException {
        httpClientInputs.setUrl(url.toString());
        httpClientInputs.setUsername(wsManRequestInputs.getUsername());
        httpClientInputs.setPassword(wsManRequestInputs.getPassword());
        httpClientInputs.setAuthType(wsManRequestInputs.getAuthType());
        httpClientInputs.setKerberosConfFile(wsManRequestInputs.getKerberosConfFile());
        httpClientInputs.setKerberosLoginConfFile(wsManRequestInputs.getKerberosLoginConfFile());
        httpClientInputs.setKerberosSkipPortCheck(wsManRequestInputs.getKerberosSkipPortForLookup());
        httpClientInputs.setTrustAllRoots(wsManRequestInputs.getTrustAllRoots());
        httpClientInputs.setX509HostnameVerifier(wsManRequestInputs.getX509HostnameVerifier());
        httpClientInputs.setProxyHost(wsManRequestInputs.getProxyHost());
        httpClientInputs.setProxyPort(wsManRequestInputs.getProxyPort());
        httpClientInputs.setProxyUsername(wsManRequestInputs.getProxyUsername());
        httpClientInputs.setProxyPassword(wsManRequestInputs.getProxyPassword());
        httpClientInputs.setKeystore(wsManRequestInputs.getKeystore());
        httpClientInputs.setKeystorePassword(wsManRequestInputs.getKeystorePassword());
        httpClientInputs.setTrustKeystore(wsManRequestInputs.getTrustKeystore());
        httpClientInputs.setTrustPassword(wsManRequestInputs.getTrustPassword());
        String headers = httpClientInputs.getHeaders();
        if (StringUtils.isEmpty(headers)) {
            httpClientInputs.setHeaders(CONTENT_TYPE_HEADER);
        } else {
            httpClientInputs.setHeaders(headers + NEW_LINE_SEPARATOR + CONTENT_TYPE_HEADER);
        }
        httpClientInputs.setMethod(HttpPost.METHOD_NAME);
        return httpClientInputs;
    }

#end
#end
#No. 187015
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * This method executes a request with the given CSHttpClient, HttpClientInputs and body.
     *
     * @param csHttpClient
     * @param httpClientInputs
     * @param requestMessage
     * @return the result of the request execution.
     */

#Code:
    private Map<String, String> executeRequest(CSHttpClient csHttpClient, HttpClientInputs httpClientInputs, String requestMessage) {
        httpClientInputs.setBody(requestMessage);
        Map<String, String> requestResponse = csHttpClient.execute(httpClientInputs);
        if (UNAUTHORIZED_STATUS_CODE.equals(requestResponse.get(STATUS_CODE))) {
            throw new RuntimeException(UNAUTHORIZED_EXCEPTION_MESSAGE);
        }
        return requestResponse;
    }

#end
#end
#No. 187016
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * Creates a shell on the remote server and returns the shell id.
     *
     * @param csHttpClient
     * @param httpClientInputs
     * @param wsManRequestInputs
     * @return the id of the created shell.
     * @throws RuntimeException
     * @throws IOException
     * @throws URISyntaxException
     * @throws TransformerException
     * @throws XPathExpressionException
     * @throws SAXException
     * @throws ParserConfigurationException
     */

#Code:
    private String createShell(CSHttpClient csHttpClient, HttpClientInputs httpClientInputs, WSManRequestInputs wsManRequestInputs)
            throws RuntimeException, IOException, URISyntaxException,
            TransformerException, XPathExpressionException, SAXException, ParserConfigurationException {
        String document = ResourceLoader.loadAsString(CREATE_SHELL_REQUEST_XML);
        document = createCreateShellRequestBody(document, httpClientInputs.getUrl(), String.valueOf(wsManRequestInputs.getMaxEnvelopeSize()),
                wsManRequestInputs.getWinrmLocale(), String.valueOf(wsManRequestInputs.getOperationTimeout()));
        Map<String, String> createShellResult = executeRequest(csHttpClient, httpClientInputs, document);
        return getResourceId(createShellResult.get(RETURN_RESULT), CREATE_RESPONSE_ACTION, CREATE_RESPONSE_SHELL_ID_XPATH,
                SHELL_ID_NOT_RETRIEVED);
    }

#end
#end
#No. 187017
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * Executes a command on the given shell.
     *
     * @param csHttpClient
     * @param httpClientInputs
     * @param shellId
     * @param wsManRequestInputs
     * @return the command id.
     * @throws RuntimeException
     * @throws IOException
     * @throws URISyntaxException
     * @throws TransformerException
     * @throws XPathExpressionException
     * @throws SAXException
     * @throws ParserConfigurationException
     */

#Code:
    private String executeCommand(CSHttpClient csHttpClient, HttpClientInputs httpClientInputs, String shellId,
                                  WSManRequestInputs wsManRequestInputs, String command) throws RuntimeException,
            IOException, URISyntaxException, TransformerException, XPathExpressionException, SAXException, ParserConfigurationException {
        String documentStr = ResourceLoader.loadAsString(EXECUTE_COMMAND_REQUEST_XML);
        documentStr = createExecuteCommandRequestBody(documentStr, httpClientInputs.getUrl(), shellId, command, String.valueOf(wsManRequestInputs.getMaxEnvelopeSize()),
                wsManRequestInputs.getWinrmLocale(), String.valueOf(wsManRequestInputs.getOperationTimeout()));
        commandExecutionStartTime = System.currentTimeMillis() / 1000;
        Map<String, String> executeCommandResult = executeRequest(csHttpClient, httpClientInputs, documentStr);
        return getResourceId(executeCommandResult.get(RETURN_RESULT), COMMAND_RESPONSE_ACTION, COMMAND_RESULT_COMMAND_ID_XPATH,
                COMMAND_ID_NOT_RETRIEVED);
    }

#end
#end
#No. 187018
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * Waits for a specific command that is running on a remote shell to finnish it's execution.
     *
     * @param csHttpClient
     * @param httpClientInputs
     * @param shellId
     * @param commandId
     * @param wsManRequestInputs
     * @return the command execution result and exit code.
     * @throws RuntimeException
     * @throws IOException
     * @throws URISyntaxException
     * @throws TransformerException
     * @throws TimeoutException
     * @throws XPathExpressionException
     * @throws SAXException
     * @throws ParserConfigurationException
     * @throws InterruptedException
     */

#Code:
    private Map<String, String> receiveCommandResult(CSHttpClient csHttpClient, HttpClientInputs httpClientInputs,
                                                     String shellId, String commandId, WSManRequestInputs wsManRequestInputs) throws RuntimeException,
            IOException, URISyntaxException, TransformerException, TimeoutException, XPathExpressionException, SAXException,
            ParserConfigurationException, InterruptedException {
        String documentStr = ResourceLoader.loadAsString(RECEIVE_REQUEST_XML);
        documentStr = createReceiveRequestBody(documentStr, httpClientInputs.getUrl(), shellId, commandId, String.valueOf(wsManRequestInputs.getMaxEnvelopeSize()), wsManRequestInputs.getWinrmLocale(), String.valueOf(wsManRequestInputs.getOperationTimeout()));
        Map<String, String> receiveResult;
        while (true) {
            receiveResult = executeRequest(csHttpClient, httpClientInputs, documentStr);
            if (executionIsTimedOut(commandExecutionStartTime, wsManRequestInputs.getOperationTimeout())) {
                throw new TimeoutException(EXECUTION_TIMED_OUT);
            } else if (WSManUtils.isSpecificResponseAction(receiveResult.get(RETURN_RESULT), RECEIVE_RESPONSE_ACTION) &&
                    WSManUtils.commandExecutionIsDone(receiveResult.get(RETURN_RESULT))) {
                return processCommandExecutionResponse(receiveResult);
            } else if (WSManUtils.isFaultResponse(receiveResult.get(RETURN_RESULT))) {
                throw new RuntimeException(WSManUtils.getResponseFault(receiveResult.get(RETURN_RESULT)));
            }

            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                throw e;
            }
        }

    }

#end
#end
#No. 187019
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * This method retrieves the resource id from the create resource request response and throws the appropriate exceptions in case of failure.
     *
     * @param response
     * @param resourceResponseAction
     * @param resourceIdXpath
     * @param resourceIdExceptionMessage
     * @return
     * @throws ParserConfigurationException
     * @throws SAXException
     * @throws XPathExpressionException
     * @throws IOException
     */

#Code:
    private String getResourceId(String response, String resourceResponseAction, String resourceIdXpath, String resourceIdExceptionMessage) throws ParserConfigurationException, SAXException, XPathExpressionException, IOException {
        if (WSManUtils.isSpecificResponseAction(response, resourceResponseAction)) {
            String shellId = XMLUtils.parseXml(response, resourceIdXpath);
            if (StringUtils.isNotBlank(shellId)) {
                return shellId;
            } else {
                throw new RuntimeException(resourceIdExceptionMessage);
            }
        } else if (WSManUtils.isFaultResponse(response)) {
            throw new RuntimeException(WSManUtils.getResponseFault(response));
        } else {
            throw new RuntimeException(UNEXPECTED_SERVICE_RESPONSE + response);
        }
    }

#end
#end
#No. 187020
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * Deletes the remote shell.
     *
     * @param csHttpClient
     * @param httpClientInputs
     * @param shellId
     * @param wsManRequestInputs
     * @throws RuntimeException
     * @throws IOException
     * @throws URISyntaxException
     * @throws TransformerException
     * @throws XPathExpressionException
     * @throws SAXException
     * @throws ParserConfigurationException
     */

#Code:
    private void deleteShell(CSHttpClient csHttpClient, HttpClientInputs httpClientInputs, String shellId, WSManRequestInputs wsManRequestInputs)
            throws RuntimeException, IOException, URISyntaxException, TransformerException, XPathExpressionException, SAXException, ParserConfigurationException {
        String documentStr = ResourceLoader.loadAsString(DELETE_SHELL_REQUEST_XML);
        documentStr = createDeleteShellRequestBody(documentStr, httpClientInputs.getUrl(), shellId, String.valueOf(wsManRequestInputs.getMaxEnvelopeSize()), wsManRequestInputs.getWinrmLocale(), String.valueOf(wsManRequestInputs.getOperationTimeout()));
        Map<String, String> deleteShellResult = executeRequest(csHttpClient, httpClientInputs, documentStr);
        if (WSManUtils.isSpecificResponseAction(deleteShellResult.get(RETURN_RESULT), DELETE_RESPONSE_ACTION)) {
            return;
        } else if (WSManUtils.isFaultResponse(deleteShellResult.get(RETURN_RESULT))) {
            throw new RuntimeException(WSManUtils.getResponseFault(deleteShellResult.get(RETURN_RESULT)));
        } else {
            throw new RuntimeException(UNEXPECTED_SERVICE_RESPONSE + deleteShellResult.get(RETURN_RESULT));
        }
    }

#end
#end
#No. 187021
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * This method separates the stdout and stderr response streams from the received execution response.
     *
     * @param receiveResult A map containing the response from the service.
     * @return a map containing the stdout, stderr streams and the script exit code.
     * @throws ParserConfigurationException
     * @throws SAXException
     * @throws XPathExpressionException
     * @throws IOException
     */

#Code:
    private Map<String, String> processCommandExecutionResponse(Map<String, String> receiveResult) throws ParserConfigurationException, SAXException, XPathExpressionException, IOException {
        Map<String, String> scriptResults = new HashMap<>();
        scriptResults.put(RETURN_RESULT, buildResultFromResponseStreams(receiveResult.get(RETURN_RESULT), OutputStream.STDOUT));
        scriptResults.put(Constants.OutputNames.STDERR, buildResultFromResponseStreams(receiveResult.get(RETURN_RESULT), OutputStream.STDERR));
        scriptResults.put(Constants.OutputNames.SCRIPT_EXIT_CODE, WSManUtils.getScriptExitCode(receiveResult.get(RETURN_RESULT)));
        return scriptResults;
    }

#end
#end
#No. 187022
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * Constructs the executed command response from multiple streams of data containing the encoded result of the execution.
     *
     * @param response
     * @param outputStream
     * @return the decoded result of the command in a string.
     * @throws ParserConfigurationException
     * @throws SAXException
     * @throws XPathExpressionException
     * @throws IOException
     */

#Code:
    private String buildResultFromResponseStreams(String response, OutputStream outputStream) throws ParserConfigurationException, SAXException, XPathExpressionException, IOException {
        StringBuilder commandResult = new StringBuilder();
        int noOfStreams = WSManUtils.countStreamElements(response);
        for (int streamNo = 0; streamNo < noOfStreams; streamNo++) {
            String stream = XMLUtils.parseXml(response, String.format(RECEIVE_RESPONSE_XPATH, outputStream.getValue(), streamNo));
            if (!"DQo=".equals(stream)) {
                commandResult.append(EncoderDecoder.decodeBase64String(stream));
            }
        }
        return commandResult.toString();
    }

#end
#end
#No. 187023
#File: E:\bishe\1\WSManRemoteShellService.java
#Comment:
    /**
     * Check whether or not the command execution reach the timeout value.
     *
     * @param aStartTime A start time in seconds.
     * @param aTimeout   A timeout value in seconds.
     * @return true if it reaches timeout.
     */

#Code:
    private boolean executionIsTimedOut(long aStartTime, int aTimeout) {
        if (aTimeout != 0) {
            long now = System.currentTimeMillis() / 1000;
            if ((now - aStartTime) >= aTimeout) {
                return true;
            }
        }
        return false;
    }

#end
#end
#No. 187024
#File: E:\bishe\1\WSManUtils.java
#Comment:
    /**
     * Checks if a string is a valid UUID or not.
     *
     * @param string The UUID value.
     * @return true if input is a valid UUID or false if input is empty or an invalid UUID format.
     */

#Code:
    public static boolean isUUID(String string) {
        try {
            if (string != null) {
                UUID.fromString(string);
                return true;
            } else {
                return false;
            }
        } catch (IllegalArgumentException ex) {
            return false;
        }
    }

#end
#end
#No. 187025
#File: E:\bishe\1\WSManUtils.java
#Comment:
    /**
     * Validates a UUID value and throws a specific exception if UUID is invalid.
     *
     * @param uuid        The UUID value to validate.
     * @param uuidValueOf The property associated to the given UUID value.
     * @throws RuntimeException
     */

#Code:
    public static void validateUUID(String uuid, String uuidValueOf) throws RuntimeException {
        if (!WSManUtils.isUUID(uuid)) {
            throw new RuntimeException("The returned " + uuidValueOf + " is not a valid UUID value! " + uuidValueOf + ": " + uuid);
        }
    }


#end
#end
#No. 187027
#File: E:\bishe\1\WsMessageHandler.java
#Comment:
    /**
     * We implement this to catch the websocket handshake completing
     * successfully. At that point we'll setup this client connection.
     */

#Code:
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt)
            throws Exception
    {
        if (evt == WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HANDSHAKE_COMPLETE) {
            configureClient(ctx);
        }
    }



#end
#end
#No. 187030
#File: E:\bishe\1\WSPage.java
#Comment:
    /**
     * @param sets
     */

#Code:
    protected void setInput(Object[] elements) {
        tv.setInput(elements);
        for (int i = 0; i < elements.length; i++) {
            IWorkingSet workingSet = (IWorkingSet) elements[i];
            tv.setChecked(workingSet, workingSet.isVisible() && !workingSet.isEmpty());
        }
    }

#end
#end
#No. 187031
#File: E:\bishe\1\WSRequest.java
#Comment:
	/**
	 * Parse a JSON expression and transform it to a WSRequest object
	 * @param jsonString
	 * @return
	 * @throws JSONException
	 */

#Code:
	public static final WSRequest parseJSON(String jsonString) throws JSONException{
		JSONObject jsonParametersObject = new JSONObject(jsonString);
		JSONObject jsonRequest = jsonParametersObject.getJSONObject("wsRequest");
		WSRequest request = new WSRequest();
		request.service = jsonRequest.getString("service");
		request.binding = jsonRequest.getString("binding");
		request.operation = jsonRequest.getString("operation");
		request.wsdlUrl = jsonRequest.getString("wsdlUrl");
		JSONArray paramsArray =	jsonParametersObject.getJSONArray("formParameters");
		for(int i=0; i<paramsArray.length(); i++){
			if(!request.getParamList().containsKey(paramsArray.getJSONObject(i).getString("paramName"))){
				List<String> valueList = new ArrayList<String>();
				valueList.add(paramsArray.getJSONObject(i).getString("paramValue"));
				request.getParamList().put(paramsArray.getJSONObject(i).getString("paramName"), valueList);
			} else {
				request.getParamList().get(paramsArray.getJSONObject(i).getString("paramName")).add(paramsArray.getJSONObject(i).getString("paramValue"));
			}
		}
		return request;
	}

#end
#end
#No. 187036
#File: E:\bishe\1\WTauNafPreCompInfo.java
#Comment:
/**
 * Class holding precomputation data for the WTNAF (Window
 * <code>&tau;</code>-adic Non-Adjacent Form) algorithm.
 */

#Code:
class WTauNafPreCompInfo implements PreCompInfo
{
    /**
     * Array holding the precomputed <code>ECPoint.F2m</code>s used for the
     * WTNAF multiplication in <code>
     * {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
     * WTauNafMultiplier.multiply()}</code>.

#end
#end
#No. 187037
#File: E:\bishe\1\WTauNafPreCompInfo.java
#Comment:
    /**
     * Constructor for <code>WTauNafPreCompInfo</code>
     * @param preComp Array holding the precomputed <code>ECPoint.F2m</code>s
     * used for the WTNAF multiplication in <code>
     * {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
     * WTauNafMultiplier.multiply()}</code>.
     */

#Code:
    WTauNafPreCompInfo(ECPoint.F2m[] preComp)
    {
        this.preComp = preComp;
    }

#end
#end
#No. 187038
#File: E:\bishe\1\WTauNafPreCompInfo.java
#Comment:
    /**
     * @return the array holding the precomputed <code>ECPoint.F2m</code>s
     * used for the WTNAF multiplication in <code>
     * {@link org.bouncycastle.math.ec.multiplier.WTauNafMultiplier.multiply()
     * WTauNafMultiplier.multiply()}</code>.
     */

#Code:
    protected ECPoint.F2m[] getPreComp()
    {
        return preComp;
    }


#end
#end
#No. 187042
#File: E:\bishe\1\WtmpEntryParser.java
#Comment:
	/**
	 * read null terminated string
	 * 
	 * @param b
	 *            byte buffer
	 * @return the string
	 */

#Code:
	public static String readString(byte[] b) {
		int i = 0;
		while (i < b.length && b[i] != 0)
			i++;

		return new String(b, 0, i);
	}

#end
#end
#No. 187044
#File: E:\bishe\1\WTranslationEntryEn.java
#Comment:
    /** Returns true if this is one of templates:
     * {{t}}, {{t+}}, {{t-}}, {{trad}}, or {{trad-}}.
     */

#Code:
    private static boolean isValidTemplateT (String template_name)
    {
        if(null == template_name)
            return false;

        if( template_name.equalsIgnoreCase("t") ||
            template_name.equalsIgnoreCase("t+") ||
            template_name.equalsIgnoreCase("t-") ||
            template_name.equalsIgnoreCase("trad") ||
            template_name.equalsIgnoreCase("trad-")
          )
            return true;

        return false;
    }

#end
#end
#No. 187045
#File: E:\bishe\1\WurmAPI.java
#Comment:
    /**
     * Creates new WurmAPI instance. This method must be used on existing and valid world directory.
     * 
     * @param worldDirectory path to existing world directory.
     * @return WurmAPI instance
     */

#Code:
    public static WurmAPI open(String worldDirectory) throws IOException {
        return new WurmAPI(worldDirectory);
    }

#end
#end
#No. 187046
#File: E:\bishe\1\WurmAPI.java
#Comment:
    /**
     * Creates new WurmAPI instance.
     * 
     * @param worldDirectory path to new or existing world directory.
     * @param powerOfTwo power of two of new map (must be between 10 and 15)
     * @return WurmAPI instance
     */

#Code:
    public static WurmAPI create(String worldDirectory, int powerOfTwo) throws IOException {
        return new WurmAPI(worldDirectory, powerOfTwo);
    }

#end
#end
#No. 187047
#File: E:\bishe\1\WurmAPI.java
#Comment:
    /**
     * Releases all native resources used by WurmAPI. It shouldn't be used after calling this method.
     */

#Code:
    public void close() {
        mapData.close();
    }


#end
#end
#No. 187124
#File: E:\bishe\1\WXApplication.java
#Comment:
  /**
   * @param enable enable remote debugger. valid only if host not to be "DEBUG_SERVER_HOST".
   *               true, you can launch a remote debugger and inspector both.
   *               false, you can  just launch a inspector.
   * @param host   the debug server host, must not be "DEBUG_SERVER_HOST", a ip address or domain will be OK.
   *               for example "127.0.0.1".
   */

#Code:
  private void initDebugEnvironment(boolean connectable,boolean enable, String host) {
    if (!"DEBUG_SERVER_HOST".equals(host)) {
      WXEnvironment.sDebugServerConnectable = connectable;
      WXEnvironment.sRemoteDebugMode = enable;
      WXEnvironment.sRemoteDebugProxyUrl = "ws://" + host + ":8088/debugProxy/native";
    }
  }


#end
#end
#No. 187126
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * Get attribute of xml
   */

#Code:
  private void getAttrs(Context context) {
    radius = WXViewUtils.dip2px(5);
    circlePadding = WXViewUtils.dip2px(5);
    pageColor = Color.parseColor("#ffffff");
    //		strokeWidth= WAViewUtils.dip2px((float)1.5);
    //		strokeColor = Color.parseColor("#FFDDDDDD");
    fillColor = Color.parseColor("#ffd545");
  }

#end
#end
#No. 187127
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @param context
   * @param attrs
   */

#Code:
  public WXBaseCircleIndicator(Context context, AttributeSet attrs) {
    super(context, attrs);
    getAttrs(context);
    init();
  }

#end
#end
#No. 187128
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @return the mCircleViewPager
   */

#Code:
  public WXCircleViewPager getCircleViewPager() {
    return mCircleViewPager;
  }

#end
#end
#No. 187129
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @param mCircleViewPager the mCircleViewPager to set
   */

#Code:
  public void setCircleViewPager(WXCircleViewPager mCircleViewPager) {
    this.mCircleViewPager = mCircleViewPager;
    if (this.mCircleViewPager != null) {
      this.mCircleViewPager.setOnPageChangeListener(this);
    }
    requestLayout();
  }

#end
#end
#No. 187130
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @return the radius
   */

#Code:
  public float getRadius() {
    return radius;
  }

#end
#end
#No. 187131
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @param radius the radius to set
   */

#Code:
  public void setRadius(float radius) {
    this.radius = radius;
  }

#end
#end
#No. 187132
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @return the circlePadding
   */

#Code:
  public float getCirclePadding() {
    return circlePadding;
  }

#end
#end
#No. 187133
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @param circlePadding the circlePadding to set
   */

#Code:
  public void setCirclePadding(float circlePadding) {
    this.circlePadding = circlePadding;
  }

#end
#end
#No. 187134
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @return the fillColor
   */

#Code:
  public int getFillColor() {
    return fillColor;
  }

#end
#end
#No. 187135
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @param fillColor the fillColor to set
   */

#Code:
  public void setFillColor(int fillColor) {
    this.fillColor = fillColor;
    mPaintFill.setColor(fillColor);
  }

#end
#end
#No. 187136
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @return the realCurrentItem
   */

#Code:
  public int getRealCurrentItem() {
    return realCurrentItem;
  }

#end
#end
#No. 187137
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @param realCurrentItem the realCurrentItem to set
   */

#Code:
  public void setRealCurrentItem(int realCurrentItem) {
    this.realCurrentItem = realCurrentItem;
  }

#end
#end
#No. 187142
#File: E:\bishe\1\WXBaseCircleIndicator.java
#Comment:
  /**
   * @return the count
   */

#Code:
  public int getCount() {
    if (mCircleViewPager == null || mCircleViewPager.getCirclePageAdapter() == null) {
      return 0;
    }
    return mCircleViewPager.getCirclePageAdapter().getRealCount();
  }


#end
#end
#No. 187144
#File: E:\bishe\1\WXCircleViewPager.java
#Comment:
  /**
   * Override the Scroller instance with our own class so we can change the
   * duration
   */

#Code:
  private void postInitViewPager() {
    if (isInEditMode()) {
      return;
    }
    try {
      Field scroller = ViewPager.class.getDeclaredField("mScroller");
      scroller.setAccessible(true);
      Field interpolator = ViewPager.class
          .getDeclaredField("sInterpolator");
      interpolator.setAccessible(true);

      mScroller = new WXSmoothScroller(getContext(),
          (Interpolator) interpolator.get(null));
      scroller.set(this, mScroller);
    } catch (Exception e) {
      WXLogUtils.e("[CircleViewPager] postInitViewPager: ", e);
    }
  }

#end
#end
#No. 187145
#File: E:\bishe\1\WXCircleViewPager.java
#Comment:
  /**
   * Start auto scroll. Must be called after {@link #setAdapter(PagerAdapter)}
   */

#Code:
  public void startAutoScroll() {
    isAutoScroll = true;
    //		mViewPager.setCurrentItem(0);
    mCircleHandler.sendEmptyMessageDelayed(0, intervalTime);
  }

#end
#end
#No. 187146
#File: E:\bishe\1\WXCircleViewPager.java
#Comment:
  /**
   * Stop auto scroll.
   */

#Code:
  public void stopAutoScroll() {
    isAutoScroll = false;
    mCircleHandler.removeCallbacksAndMessages(null);
  }

#end
#end
#No. 187147
#File: E:\bishe\1\WXCircleViewPager.java
#Comment:
  /**
   * set real item
   *
   */

#Code:
  @Override
  public void setCurrentItem(int item, boolean smoothScroll) {
    if (getAdapter().getCount() == 0) {
      super.setCurrentItem(item, smoothScroll);
      return;
    }
    item = getOffsetAmount() + (item % getAdapter().getCount());
    super.setCurrentItem(item, smoothScroll);
  }

#end
#end
#No. 187148
#File: E:\bishe\1\WXCircleViewPager.java
#Comment:
  /**
   * @return the circlePageAdapter
   */

#Code:
  public WXCirclePageAdapter getCirclePageAdapter() {
    return (WXCirclePageAdapter) getAdapter();
  }

#end
#end
#No. 187149
#File: E:\bishe\1\WXCircleViewPager.java
#Comment:
  /**
   * @param circlePageAdapter the circlePageAdapter to set
   */

#Code:
  public void setCirclePageAdapter(WXCirclePageAdapter circlePageAdapter) {
    this.setAdapter(circlePageAdapter);
  }

#end
#end
#No. 187150
#File: E:\bishe\1\WXCircleViewPager.java
#Comment:
  /**
   * Get auto scroll interval. The time unit is micro second.
   * The default time interval is 3000 micro second
   * @return the intervalTime
   */

#Code:
  public long getIntervalTime() {
    return intervalTime;
  }

#end
#end
#No. 187151
#File: E:\bishe\1\WXCircleViewPager.java
#Comment:
  /**
   * Set auto scroll interval. The time unit is micro second.
   * The default time interval is 3000 micro second
   * @param intervalTime the intervalTime to set
   */

#Code:
  public void setIntervalTime(long intervalTime) {
    this.intervalTime = intervalTime;
  }



#end
#end
#No. 187155
#File: E:\bishe\1\WXCustomStyleSpan.java
#Comment:
  /**
   * Returns the font family set for this StyleSpan.
   */

#Code:
  public String getFontFamily() {
    return mFontFamily;
  }


#end
#end
#No. 187157
#File: E:\bishe\1\WXDataStructureUtil.java
#Comment:
  /**
   * Returns a capacity that is sufficient to keep the map from being resized as long as it grows no
   * larger than expectedSize and the load factor is >= its default (0.75).
   */

#Code:
  private static int capacity(int expectedSize) {
    if (expectedSize < 3) {
      checkNonnegative(expectedSize, "expectedSize");
      return expectedSize + 1;
    }
    if (expectedSize < MAX_POWER_OF_TWO) {
      // This is the calculation used in JDK8 to resize when a putAll
      // happens; it seems to be the most conservative calculation we
      // can make.  0.75 is the default load factor.
      return (int) ((float) expectedSize / 0.75F + 1.0F);
    }
    return Integer.MAX_VALUE; // any large value
  }

#end
#end
#No. 187158
#File: E:\bishe\1\WXDomManager.java
#Comment:
  /**
   * Invoke the {@link WXDomStatement} for removing the event listener of the corresponding {@link
   * WXDomObject}.
   * @param instanceId {@link com.taobao.weex.WXSDKInstance#mInstanceId} for the instance
   * @param ref {@link WXDomObject#ref} of the dom.
   * @param type the type of the event, this may be a plain event defined in
   * {@link com.taobao.weex.ui.component.WXEventType} or a gesture defined in {@link com.taobao
   * .weex.ui.view.gesture.WXGestureType}
   */

#Code:
  void removeEvent(String instanceId, String ref, String type) {
    if (!isDomThread()) {
      throw new WXRuntimeException("RemoveEvent operation must be done in dom thread");
    }
    WXDomStatement statement = mDomRegistries.get(instanceId);
    if (statement == null) {
      return;
    }
    statement.removeEvent(ref, type);
  }

#end
#end
#No. 187159
#File: E:\bishe\1\WXDomManager.java
#Comment:
  /**
   * Invoke the {@link WXDomStatement} for scrolling the given view to the specified position.
   * @param instanceId {@link com.taobao.weex.WXSDKInstance#mInstanceId} for the instance to
   *                                                                    scroll.
   * @param ref {@link WXDomObject#ref} of the dom.
   * @param options the specified position
   */

#Code:
  void scrollToDom(String instanceId, String ref, JSONObject options) {
    if (!isDomThread()) {
      throw new WXRuntimeException("ScrollToDom operation must be done in dom thread");
    }
    WXDomStatement statement = mDomRegistries.get(instanceId);
    if (statement == null) {
      return;
    }
    statement.scrollToDom(ref, options);
  }

#end
#end
#No. 187160
#File: E:\bishe\1\WXDomManager.java
#Comment:
  /**
   * Notify the creating of whole dom tree has finished. This message is sent by JS.
   * @param instanceId {@link com.taobao.weex.WXSDKInstance#mInstanceId} for the instance to
   *                                                                    notify.
   */

#Code:
  void createFinish(String instanceId) {
    if (!isDomThread()) {
      throw new WXRuntimeException("CreateFinish operation must be done in dom thread");
    }
    WXDomStatement statement = mDomRegistries.get(instanceId);
    if (statement == null) {
      return;
    }
    statement.createFinish();
  }

#end
#end
#No. 187161
#File: E:\bishe\1\WXDomManager.java
#Comment:
  /**
   * Notify the refreshing has finished.
   * @param instanceId {@link com.taobao.weex.WXSDKInstance#mInstanceId} for the instance to
   *                                                                    notify.
   */

#Code:
  void refreshFinish(String instanceId) {
    if (!isDomThread()) {
      throw new WXRuntimeException("RefreshFinish operation must be done in dom thread");
    }
    WXDomStatement statement = mDomRegistries.get(instanceId);
    if (statement == null) {
      return;
    }
    statement.refreshFinish();
  }

#end
#end
#No. 187162
#File: E:\bishe\1\WXDomManager.java
#Comment:
  /**
   * Notify the update has finished.
   * @param instanceId {@link com.taobao.weex.WXSDKInstance#mInstanceId} for the instance to
   *                                                                    notify.
   */

#Code:
  void updateFinish(String instanceId) {
    if (!isDomThread()) {
      throw new WXRuntimeException("RefreshFinish operation must be done in dom thread");
    }
    WXDomStatement statement = mDomRegistries.get(instanceId);
    if (statement == null) {
      return;
    }
    statement.updateFinish();
  }

#end
#end
#No. 187163
#File: E:\bishe\1\WXDomStatement.java
#Comment:
  /**
   * Create a command object for removing the event listener of the corresponding {@link
   * WXDomObject} and put the command event in the queue.
   * @param ref {@link WXDomObject#ref} of the dom.
   * @param type the type of the event, this may be a plain event defined in
   * {@link com.taobao.weex.ui.component.WXEventType} or a gesture defined in {@link com.taobao
   * .weex.ui.view.gesture.WXGestureType}
   */

#Code:
  void removeEvent(final String ref, final String type) {
    if (mDestroy) {
      return;
    }
    WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(mInstanceId);
    WXDomObject domObject = mRegistry.get(ref);
    if (domObject == null) {
      if (instance != null) {
        instance.commitUTStab(WXConst.DOM_MODULE, WXErrorCode.WX_ERR_DOM_REMOVEEVENT);
      }
      return;
    }
    domObject.removeEvent(type);
    mNormalTasks.add(new IWXRenderTask() {

      @Override
      public void execute() {
        mWXRenderManager.removeEvent(mInstanceId, ref, type);
      }

      @Override
      public String toString() {
        return "removeEvent";
      }
    });

    mDirty = true;
    if (instance != null) {
      instance.commitUTStab(WXConst.DOM_MODULE, WXErrorCode.WX_SUCCESS);
    }
  }

#end
#end
#No. 187164
#File: E:\bishe\1\WXDomStatement.java
#Comment:
  /**
   * Create a command object for scroll the given view to the specified position.
   * @param ref {@link WXDomObject#ref} of the dom.
   * @param options the specified position
   */

#Code:
  void scrollToDom(final String ref, final JSONObject options) {
    if (mDestroy) {
      return;
    }
    WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(mInstanceId);

    mNormalTasks.add(new IWXRenderTask() {

      @Override
      public void execute() {
        mWXRenderManager.scrollToComponent(mInstanceId, ref, options);
      }

      @Override
      public String toString() {
        return "scrollToPosition";
      }
    });

    mDirty = true;
    if (instance != null) {
      instance.commitUTStab(WXConst.DOM_MODULE, WXErrorCode.WX_SUCCESS);
    }
  }

#end
#end
#No. 187165
#File: E:\bishe\1\WXDomStatement.java
#Comment:
  /**
   * Create a command object for notifying {@link WXRenderManager} that the process of creating
   * given view is finished, and put the command object in the queue.
   */

#Code:
  void createFinish() {
    if (mDestroy) {
      return;
    }

    final WXDomObject root = mRegistry.get(WXDomObject.ROOT);
    mNormalTasks.add(new IWXRenderTask() {

      @Override
      public void execute() {
        mWXRenderManager.createFinish(mInstanceId,
                                      (int) root.getLayoutWidth(),
                                      (int) root.getLayoutHeight());
      }

      @Override
      public String toString() {
        return "createFinish";
      }
    });

    mDirty = true;
    WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(mInstanceId);
    if (instance != null) {
      instance.commitUTStab(WXConst.DOM_MODULE, WXErrorCode.WX_SUCCESS);
    }
  }

#end
#end
#No. 187166
#File: E:\bishe\1\WXDomStatement.java
#Comment:
  /**
   * Create a command object for notifying {@link WXRenderManager} that the process of refreshing
   * given view is finished, and put the command object in the queue.
   */

#Code:
  void refreshFinish() {
    if (mDestroy) {
      return;
    }
    final WXDomObject root = mRegistry.get(WXDomObject.ROOT);
    mNormalTasks.add(new IWXRenderTask() {

      @Override
      public void execute() {
        int realWidth = (int) root.getLayoutWidth();
        int realHeight = (int) root.getLayoutHeight();
        mWXRenderManager.refreshFinish(mInstanceId, realWidth, realHeight);
      }

      @Override
      public String toString() {
        return "refreshFinish";
      }
    });

    mDirty = true;
    WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(mInstanceId);
    if (instance != null) {
      instance.commitUTStab(WXConst.DOM_MODULE, WXErrorCode.WX_SUCCESS);
    }
  }

#end
#end
#No. 187167
#File: E:\bishe\1\WXDomStatement.java
#Comment:
  /**
   * Create a command object for notifying {@link WXRenderManager} that the process of update
   * given view is finished, and put the command object in the queue.
   */

#Code:
  void updateFinish() {
    if (mDestroy) {
      return;
    }
    mNormalTasks.add(new IWXRenderTask() {

      @Override
      public void execute() {
        mWXRenderManager.updateFinish(mInstanceId);
      }

      @Override
      public String toString() {
        return "updateFinish";
      }
    });

    mDirty = true;
    WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(mInstanceId);
    if (instance != null) {
      instance.commitUTStab(WXConst.DOM_MODULE, WXErrorCode.WX_SUCCESS);
    }
  }

#end
#end
#No. 187168
#File: E:\bishe\1\WXEnvironment.java
#Comment:
  /**
   * Get the version of the current app.
   */

#Code:
  private static String getAppVersionName() {
    String versionName = "";
    PackageManager manager;
    PackageInfo info = null;
    try {
      manager = sApplication.getPackageManager();
      info = manager.getPackageInfo(sApplication.getPackageName(), 0);
      versionName = info.versionName;
    } catch (Exception e) {
      WXLogUtils.e("WXEnvironment getAppVersionName Exception: ", e);
    }
    return versionName;
  }








#end
#end
#No. 187173
#File: E:\bishe\1\WXFileUtils.java
#Comment:
  /**
   * Load file in asset directory.
   * @param path FilePath
   * @param context Weex Context
   * @return the Content of the file
   */

#Code:
  public static String loadAsset(String path, Context context) {
    if(path == null || context == null){
      return null;
    }
    StringBuilder builder ;
    try {
      InputStream in = context.getAssets().open(path);

      builder = new StringBuilder(in.available()+10);

      BufferedReader localBufferedReader = new BufferedReader(new InputStreamReader(in));
      char[] data = new char[2048];
      int len = -1;
      while ((len = localBufferedReader.read(data)) > 0) {
        builder.append(data, 0, len);
      }
      localBufferedReader.close();
      if (in != null) {
        try {
          in.close();
        } catch (IOException e) {
          WXLogUtils.e("WXFileUtils loadAsset: ", e);
        }
      }
      return builder.toString();

    } catch (IOException e) {
      e.printStackTrace();
      WXLogUtils.e("", e);
    }

    return "";
  }

#end
#end
#No. 187174
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Handle low-level gesture
   * @param WXGestureType possible low-level gesture, defined in {@link WXEventType}
   * @param motionEvent motionEvent, which contains all pointers event in a period of time
   * @return true if this event is handled, otherwise false.
   */

#Code:
  private boolean handleMotionEvent(WXGestureType WXGestureType, MotionEvent motionEvent) {
    if (component.containsGesture(WXGestureType)) {
      List<Map<String, Object>> list = createFireEventParam(motionEvent);
      for (Map<String, Object> map : list) {
        WXSDKManager.getInstance().fireEvent(component.mInstanceId, component.mDomObj.ref,
                                             WXGestureType.toString(), map);
      }
      return true;
    } else {
      return false;
    }
  }

#end
#end
#No. 187175
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Create a list of event for {@link WXSDKManager#fireEvent(String, String, String, Map)}.
   * As there is a batch mechanism in MotionEvent, so this method returns a list.
   * @param motionEvent motionEvent, which contains all pointers event in a period of time
   * @return List of Map, which contains touch object.
   */

#Code:
  private List<Map<String, Object>> createFireEventParam(MotionEvent motionEvent) {
    List<Map<String, Object>> list = new ArrayList<>(motionEvent.getHistorySize() + 1);
    list.addAll(getHistoricalEvents(motionEvent));
    list.add(createFireEventParam(motionEvent, CUR_EVENT));
    return list;
  }

#end
#end
#No. 187176
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Get historical event. This is only applied to {@link MotionEvent#ACTION_MOVE}.
   * For other types of motionEvent, historical event is meaningless.
   * @param motionEvent motionEvent, which contains all pointers event in a period of time
   * @return If motionEvent.getActionMasked()!=MotionEvent.ACTION_MOVE,
   * this method will return an empty list.
   * Otherwise this method will return the historical motionEvent, which may also be empty.
   */

#Code:
  private List<Map<String, Object>> getHistoricalEvents(MotionEvent motionEvent) {
    List<Map<String, Object>> list = new ArrayList<>(motionEvent.getHistorySize());
    if (motionEvent.getActionMasked() == MotionEvent.ACTION_MOVE) {
      Map<String, Object> param;
      for (int i = 0; i < motionEvent.getHistorySize(); i++) {
        param = createFireEventParam(motionEvent, i);
        list.add(param);
      }
    }
    return list;
  }

#end
#end
#No. 187177
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Create a map represented touch event at a certain moment.
   * @param motionEvent motionEvent, which contains all pointers event in a period of time
   * @param pos index used to retrieve a certain moment in a period of time.
   * @return touchEvent
   * @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent">touchEvent</a>
   */

#Code:
  private Map<String, Object> createFireEventParam(MotionEvent motionEvent, int pos) {
    JSONArray jsonArray = new JSONArray(motionEvent.getPointerCount());
    if (motionEvent.getActionMasked() == MotionEvent.ACTION_MOVE) {
      for (int i = 0; i < motionEvent.getPointerCount(); i++) {
        jsonArray.add(createJSONObject(motionEvent, pos, i));
      }
    } else if (isPointerNumChanged(motionEvent)) {
      int pointerIndex = motionEvent.getActionIndex();
      jsonArray.add(createJSONObject(motionEvent, CUR_EVENT, pointerIndex));
    }
    Map<String, Object> map = new HashMap<>();
    map.put(GestureInfo.HISTORICAL_XY, jsonArray);
    return map;
  }

#end
#end
#No. 187178
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Tell whether the number of motion event's pointer changed.
   * @param event the current motion event
   * @return true for number of motion event's pointer changed, otherwise false.
   */

#Code:
  private boolean isPointerNumChanged(MotionEvent event) {
    return event.getActionMasked() == MotionEvent.ACTION_DOWN ||
           event.getActionMasked() == MotionEvent.ACTION_POINTER_DOWN ||
           event.getActionMasked() == MotionEvent.ACTION_UP ||
           event.getActionMasked() == MotionEvent.ACTION_POINTER_UP ||
           event.getActionMasked() == MotionEvent.ACTION_CANCEL;
  }

#end
#end
#No. 187179
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Tell whether component contains pan gesture
   * @return true for contains pan gesture, otherwise false.
   */

#Code:
  private boolean containsPan() {
    return component.containsGesture(HighLevelGesture.PAN_START) ||
           component.containsGesture(HighLevelGesture.PAN_MOVE) ||
           component.containsGesture(HighLevelGesture.PAN_END);
  }

#end
#end
#No. 187180
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Create a touchObject for a pointer at a certain moment.
   * @param motionEvent motionEvent, which contains all pointers event in a period of time
   * @param pos index used to retrieve a certain moment in a period of time.
   * @param pointerIndex pointerIndex
   * @return JSONObject represent a touch event
   * @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Touch">touch</a>
   */

#Code:
  private JSONObject createJSONObject(MotionEvent motionEvent, int pos, int pointerIndex) {
    PointF screenXY, pageXY;
    if (pos == CUR_EVENT) {
      pageXY = getEventLocInPageCoordinate(motionEvent, pointerIndex);
      screenXY = getEventLocInScreenCoordinate(motionEvent, pointerIndex);
    } else {
      pageXY = getEventLocInPageCoordinate(motionEvent, pointerIndex, pos);
      screenXY = getEventLocInScreenCoordinate(motionEvent, pointerIndex, pos);
    }
    return createJSONObject(screenXY, pageXY, (float) motionEvent.getPointerId(pointerIndex));
  }

#end
#end
#No. 187181
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Create a touchObject for a pointer at a certain moment.
   * @param screenXY the point of event happened in screen coordinate
   * @param pageXY the point of event happened in page coorindate
   * @param pointerId pointerIndex pointerIndex
   * @return JSONObject represent a touch event
   * @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Touch">touch</a>
   */

#Code:
  @NonNull
  private JSONObject createJSONObject(PointF screenXY, PointF pageXY, float pointerId) {
    JSONObject jsonObject = new JSONObject();
    jsonObject.put(GestureInfo.PAGE_X, pageXY.x);
    jsonObject.put(GestureInfo.PAGE_Y, pageXY.y);
    jsonObject.put(GestureInfo.SCREEN_X, screenXY.x);
    jsonObject.put(GestureInfo.SCREEN_Y, screenXY.y);
    jsonObject.put(GestureInfo.POINTER_ID, pointerId);
    return jsonObject;
  }

#end
#end
#No. 187182
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * @see {@link #getEventLocInScreenCoordinate(MotionEvent, int, int)}
   */

#Code:
  private PointF getEventLocInScreenCoordinate(MotionEvent motionEvent, int pointerIndex) {
    return getEventLocInScreenCoordinate(motionEvent, pointerIndex, CUR_EVENT);
  }

#end
#end
#No. 187183
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Get event location in Screen's coordinate, e.g. root(global) coordinate.
   * @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Touch/screenX">screenX</a>
   * @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Touch/screenY">screenY</a>
   * @param motionEvent the original motionEvent
   * @param pointerIndex pointerIndex
   * @param position if motionEvent.getHistoricalSize()!=0, the is the index of historical event,
   *                 otherwise this is {@link #CUR_EVENT} which indicates historicalSize is zero
   * @return the eventLocation in screen's coordinate
   */

#Code:
  private PointF getEventLocInScreenCoordinate(MotionEvent motionEvent, int pointerIndex, int position) {
    float eventX, eventY;
    if (position == CUR_EVENT) {
      eventX = motionEvent.getX(pointerIndex);
      eventY = motionEvent.getY(pointerIndex);
    } else {
      eventX = motionEvent.getHistoricalX(pointerIndex, position);
      eventY = motionEvent.getHistoricalY(pointerIndex, position);
    }
    return getEventLocInScreenCoordinate(eventX, eventY);
  }

#end
#end
#No. 187184
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Get event location in Screen's coordinate, e.g. root(global) coordinate.
   * @param eventX {@link MotionEvent#getX()} or {@link MotionEvent#getHistoricalX(int, int)}
   * @param eventY {@link MotionEvent#getX()} or {@link MotionEvent#getHistoricalX(int, int)}
   * @return the eventLocation in screen's coordinate
   * @see {@link #getEventLocInScreenCoordinate(MotionEvent, int, int)}
   */

#Code:
  @NonNull
  private PointF getEventLocInScreenCoordinate(float eventX, float eventY) {
    globalRect.set(0, 0, 0, 0);
    globalOffset.set(0, 0);
    globalEventOffset.set((int) eventX, (int) eventY);
    component.getRealView().getGlobalVisibleRect(globalRect, globalOffset);
    globalEventOffset.offset(globalOffset.x, globalOffset.y);
    return new PointF(WXViewUtils.getWebPxByWidth(globalEventOffset.x),
                      WXViewUtils.getWebPxByWidth(globalEventOffset.y));
  }

#end
#end
#No. 187185
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * @see {@link #getEventLocInPageCoordinate(MotionEvent, int, int)}
   */

#Code:
  private PointF getEventLocInPageCoordinate(MotionEvent motionEvent, int pointerIndex) {
    return getEventLocInPageCoordinate(motionEvent, pointerIndex, CUR_EVENT);
  }

#end
#end
#No. 187186
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Get event's location in Document's (Page) coordinate.
   * @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Touch/pageX">pageX</a>
   * @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Touch/pageY">pageY</a>
   * @param motionEvent the original motionEvent
   * @param pointerIndex pointerIndex
   * @param position if motionEvent.getHistoricalSize()!=0, the is the index of historical event,
   *                 otherwise this is {@link #CUR_EVENT} which indicates historicalSize is zero
   * @return the event location in page's coordinate.
   */

#Code:
  private PointF getEventLocInPageCoordinate(MotionEvent motionEvent, int pointerIndex, int position) {
    float eventX, eventY;
    if (position == CUR_EVENT) {
      eventX = motionEvent.getX(pointerIndex);
      eventY = motionEvent.getY(pointerIndex);
    } else {
      eventX = motionEvent.getHistoricalX(pointerIndex, position);
      eventY = motionEvent.getHistoricalY(pointerIndex, position);
    }
    return getEventLocInPageCoordinate(eventX, eventY);
  }

#end
#end
#No. 187187
#File: E:\bishe\1\WXGesture.java
#Comment:
  /**
   * Get event's location in Document's (Page) coordinate.
   * @param eventX {@link MotionEvent#getX()} or {@link MotionEvent#getHistoricalX(int, int)}
   * @param eventY {@link MotionEvent#getX()} or {@link MotionEvent#getHistoricalX(int, int)}
   * @return the event location in page's coordinate.
   * @see {@link #getEventLocInPageCoordinate(MotionEvent, int, int)}
   */

#Code:
  @NonNull
  private PointF getEventLocInPageCoordinate(float eventX, float eventY) {
    locEventOffset.set(eventX, eventY);
    locLeftTop.set(0, 0);
    component.computeVisiblePointInViewCoordinate(locLeftTop);
    locEventOffset.offset(locLeftTop.x, locLeftTop.y);
    return new PointF(WXViewUtils.getWebPxByWidth(locEventOffset.x),
                      WXViewUtils.getWebPxByWidth(locEventOffset.y));
  }

#end
#end
#No. 187188
#File: E:\bishe\1\WXHack.java
#Comment:
  /**
   * Specify a handler to deal with assertion failure, and decide whether the failure should be thrown.
   */

#Code:
  public static void setAssertionFailureHandler(AssertionFailureHandler handler) {
    sFailureHandler = handler;
  }

#end
#end
#No. 187189
#File: E:\bishe\1\WXHack.java
#Comment:
    /**
     * @param modifiers the modifiers this field must have
     */

#Code:
    HackedField(final Class<C> clazz, final String name, int modifiers) throws HackAssertionException {
      Field field = null;
      try {
        if (clazz == null) {
          return;
        }
        field = clazz.getDeclaredField(name);
        if (modifiers > 0 && (field.getModifiers() & modifiers) != modifiers) {
          fail(new HackAssertionException(field + " does not match modifiers: " + modifiers));
        }
        field.setAccessible(true);
      } catch (final NoSuchFieldException e) {
        HackAssertionException hae = new HackAssertionException(e);
        hae.setHackedClass(clazz);
        hae.setHackedFieldName(name);
        fail(hae);
      } finally {
        mField = field;
      }
    }

#end
#end
#No. 187190
#File: E:\bishe\1\WXHack.java
#Comment:
    /**
     * Hijack the current instance of this field.
     * The instance must not be null at the time of hijacking, or an IllegalStateException will be thrown.
     *
     * @param handler a invocation handler to implement the hijack logic.
     */

#Code:
    public void hijack(final C instance, final InterceptionHandler<?> handler) {
      final Object delegatee = get(instance);
      if (delegatee == null) {
        throw new IllegalStateException("Cannot hijack null");
      }
      final Class<?>[] interfaces = delegatee.getClass().getInterfaces();
      set(instance, WXInterception.proxy(delegatee, handler, interfaces));
    }

#end
#end
#No. 187191
#File: E:\bishe\1\WXHack.java
#Comment:
    /**
     * Get current value of this field
     */

#Code:
    public T get(final C instance) {
      try {
        @SuppressWarnings("unchecked") final T value = (T) mField.get(instance);
        return value;
      } catch (IllegalAccessException e) {
        WXLogUtils.e("", e);
        //TBS.Ext.commitEvent("AtlasRuntimeException", AtlasConstant.ATLAS_RUNTIME_EXCEPTION, e.toString());
        return null; /* Should never happen */
      }
    }

#end
#end
#No. 187192
#File: E:\bishe\1\WXHack.java
#Comment:
    /**
     * Set value of this field
     * No type enforced here since most type mismatch can be easily tested and exposed early.
     */

#Code:
    public void set(final C instance, final Object value) {
      try {
        mField.set(instance, value);
      } catch (final IllegalAccessException e) {
        WXLogUtils.e("", e);
        //                if(value instanceof DelegateClassLoader){
        //                    throw new RuntimeException("set DelegateClassLoader fail",e);
        //                }
                /* Should never happen */
      }
    }


#end
#end
#No. 187195
#File: E:\bishe\1\WXListComponent.java
#Comment:
    /**
     * Remove the child from WXListComponent. This method will use {@link
     * java.util.List#indexOf(Object)} to retrieve the component to be deleted. Like {@link
     * #addChild(WXComponent)}, this method will not refresh the view immediately, the adapter will
     * decide when to refresh.
     *
     * @param child the child to be removed
     */

#Code:
    @Override
    public void remove(WXComponent child) {
        remove(child, true);
    }

#end
#end
#No. 187196
#File: E:\bishe\1\WXListComponent.java
#Comment:
    /**
     * Recycle viewHolder and its underlying view. This may because the view is removed or reused.
     * Either case, this method will be called.
     *
     * @param holder The view holder to be recycled.
     */

#Code:
    @Override
    public void onViewRecycled(ListBaseViewHolder holder) {
        long begin=System.currentTimeMillis();
        holder.setComponentUsing(false);
        recycleViewList.add(holder);
        WXLogUtils.d(TAG, "Recycle holder " +(System.currentTimeMillis()-begin)+"  Thread:"+Thread.currentThread().getName());
    }

#end
#end
#No. 187197
#File: E:\bishe\1\WXListComponent.java
#Comment:
    /**
     * Bind the component of the position to the holder. Then flush the view.
     *
     * @param holder   viewHolder, which holds reference to the view
     * @param position position of component in WXListComponent
     */

#Code:
    @Override
    public void onBindViewHolder(ListBaseViewHolder holder, int position) {
        if (holder == null) return;
        holder.setComponentUsing(true);
        WXComponent component = getChild(position);
        if ( component == null
                || (component instanceof WXRefresh)
                || (component instanceof WXLoading)
                || (component.mDomObj!=null && component.mDomObj.isFixed())
                ) {

            WXLogUtils.d(TAG, "Bind WXRefresh & WXLoading " + holder);
            return;
        }

        if (component != null
            && holder.getComponent() != null
                && holder.getComponent() instanceof WXCell) {
            holder.getComponent().bindData(component);
        }

    }





#end
#end
#No. 187200
#File: E:\bishe\1\WXListComponent.java
#Comment:
    /**
     * Return the child component type. The type is defined by scopeValue in .we file.
     *
     * @param position the position of the child component.
     * @return the type of certain component.
     */

#Code:
    @Override
    public int getItemViewType(int position) {
        return generateViewType(getChild(position));
    }

#end
#end
#No. 187201
#File: E:\bishe\1\WXListComponent.java
#Comment:
    /**
     * ViewType will be classified into {HashMap<Integer,ArrayList<Integer>> mViewTypes}
     * @param component
     */

#Code:
    private void bindViewType(WXComponent component) {
        int id = generateViewType(component);

        if (mViewTypes == null) {
            mViewTypes = new SparseArray<>();
        }

        ArrayList<WXComponent> mTypes = mViewTypes.get(id);

        if (mTypes == null) {
            mTypes = new ArrayList<>();
            mViewTypes.put(id,mTypes);
        }
        mTypes.add(component);
    }

#end
#end
#No. 187202
#File: E:\bishe\1\WXListComponent.java
#Comment:
    /**
     * generate viewtype by component
     * @param component
     * @return
     */

#Code:
    private int generateViewType(WXComponent component) {
        long id;
        try {
            id = Integer.parseInt(component.getDomObject().ref);
            String type = component.getDomObject().attr.getScope();

            if (!TextUtils.isEmpty(type)) {
                if (mRefToViewType == null) {
                    mRefToViewType = new ArrayMap<>();
                }
                if (!mRefToViewType.containsKey(type)) {
                    mRefToViewType.put(type, id);
                }
                id = mRefToViewType.get(type);

            }
        } catch (RuntimeException e) {
          WXLogUtils.eTag(TAG, e);
          id = RecyclerView.NO_ID;
          WXLogUtils.e(TAG, "getItemViewType: NO ID, this will crash the whole render system of WXListRecyclerView");
        }
        return (int) id;
    }

#end
#end
#No. 187203
#File: E:\bishe\1\WXListComponent.java
#Comment:
    /**
     * Get child component num.
     *
     * @return return the size of {@link #mChildren} if mChildren is not empty, otherwise, return 0;
     */

#Code:
    @Override
    public int getItemCount() {
        if (mChildren != null) {
            return mChildren.size();
        }
        return 0;
    }

#end
#end
#No. 187206
#File: E:\bishe\1\WXRecyclerView.java
#Comment:
  /**
   *
   * @param context
   * @param type
   * @param orientation should be {@link OrientationHelper#HORIZONTAL} or {@link OrientationHelper#VERTICAL}
   */

#Code:
  public void initView(Context context, int type,int orientation) {
    if (type == TYPE_GRID_LAYOUT) {
      setLayoutManager(new GridLayoutManager(context, 2,orientation,false));
    } else if (type == TYPE_STAGGERED_GRID_LAYOUT) {
      setLayoutManager(new StaggeredGridLayoutManager(2, orientation));
    } else if (type == TYPE_LINEAR_LAYOUT) {
      setLayoutManager(new LinearLayoutManager(context,orientation,false));
    }
  }

#end
#end
#No. 187207
#File: E:\bishe\1\WXReflectionUtils.java
#Comment:
  /**
   * get field form object and it's parent
   */

#Code:
  public static Field getDeclaredField(Object object, String fieldName) {
    Field field = null;

    Class<?> clazz = object.getClass();

    for (; clazz != Object.class; clazz = clazz.getSuperclass()) {
      try {
        field = clazz.getDeclaredField(fieldName);
        return field;
      } catch (Exception e) {

      }
    }

    return null;
  }

#end
#end
#No. 187208
#File: E:\bishe\1\WXReflectionUtils.java
#Comment:
  /**
   * Set property(field) of the specified object.
   * @param bean The object which has the given property
   * @param field The field to be set
   * @param value The value to be set to the field
   * @throws IllegalAccessException
   * @throws InvocationTargetException
   * @throws NoSuchMethodException
   */

#Code:
  public static void setProperty(Object bean, Field field, Object value) throws IllegalAccessException,
                                                                                InvocationTargetException,
                                                                                NoSuchMethodException {

    if (bean == null || field == null) {
      return;
    }

    try {
      field.setAccessible(true);
      field.set(bean, value);
    } catch (Exception e) {
    }

  }

#end
#end
#No. 187209
#File: E:\bishe\1\WXRefreshView.java
#Comment:
  /**
   * Setting refresh view or loading view
   *
   * @param view refresh or loading
   */

#Code:
  public void setRefreshView(final View view) {
    if (view == null)
      return;
    post(new Runnable() {
      @Override
      public void run() {
        View child = null;
        View temp = view;
        if (view.getParent() != null) {
          ((ViewGroup) view.getParent()).removeView(view);
        }
        for (int i = 0;i<((ViewGroup)temp).getChildCount(); i++) {
          child = ((ViewGroup) temp).getChildAt(i);
          if (child instanceof CircleProgressBar)
            circleProgressBar = (CircleProgressBar) child;
        }
        linearLayout.addView(temp);
      }
    });
  }

#end
#end
#No. 187210
#File: E:\bishe\1\WXRefreshView.java
#Comment:
  /**
   * Set loading_indicator bgColor
   *
   * @param color
   */

#Code:
  public void setProgressBgColor(int color) {
    if (circleProgressBar != null) {
      circleProgressBar.setBackgroundColor(color);
    }
  }

#end
#end
#No. 187211
#File: E:\bishe\1\WXRefreshView.java
#Comment:
  /**
   * Set loading_indicator color
   *
   * @param color
   */

#Code:
  public void setProgressColor(int color) {
    if (circleProgressBar != null) {
      circleProgressBar.setColorSchemeColors(color);
    }
  }

#end
#end
#No. 187212
#File: E:\bishe\1\WXRefreshView.java
#Comment:
  /**
   * Set the start and end trim for the progress spinner arc.
   *
   * @param startAngle start angle
   * @param endAngle end angle
   */

#Code:
  public void setStartEndTrim(float startAngle, float endAngle) {
    if (circleProgressBar != null) {
      circleProgressBar.setStartEndTrim(startAngle, endAngle);
    }
  }

#end
#end
#No. 187213
#File: E:\bishe\1\WXRefreshView.java
#Comment:
  /**
   * Set the amount of rotation to apply to the progress spinner.
   *
   * @param rotation Rotation is from [0..1]
   */

#Code:
  public void setProgressRotation(float rotation) {
    if (circleProgressBar != null)
      circleProgressBar.setProgressRotation(rotation);
  }

#end
#end
#No. 187214
#File: E:\bishe\1\WXRenderManager.java
#Comment:
  /**
   * Remove renderStatement, can only be invoked in UI thread.
   * @param instanceId {@link WXSDKInstance#mInstanceId}
   */

#Code:
  public void removeRenderStatement(String instanceId) {
    if (!WXUtils.isUiThread()) {
      throw new WXRuntimeException("[WXRenderManager] removeRenderStatement can only be called in main thread");
    }
    WXRenderStatement statement = mRegistries.remove(instanceId);
    if (statement != null) {
      statement.destroy();
    }
  }

#end
#end
#No. 187215
#File: E:\bishe\1\WXRenderManager.java
#Comment:
  /**
   * Set extra info, other than attribute and style
   */

#Code:
  public void setExtra(String instanceId, String ref, Object extra) {
    WXRenderStatement statement = mRegistries.get(instanceId);
    if (statement == null) {
      return;
    }
    statement.setExtra(ref, extra);
  }


#end
#end
#No. 187218
#File: E:\bishe\1\WXSAgent.java
#Comment:
	/**
	 * This takes a Map of K/V pairs and sorts them in to buckets per partition. Partitions with no pairs are not in the
	 * returned Map.
	 * 
	 * @param <K1>
	 * @param <V1>
	 * @param baseMap
	 * @param items
	 * @return A Map with entries for each partition with sorted pairs
	 */

#Code:
	static public <K1, V1> Map<Integer, SortedMap<K1, V1>> convertToPartitionEntryMap(BackingMap baseMap, Map<K1, V1> items) {
		// get the comparator if it exists
		Comparator<K1> comparator = null;
		if (items instanceof SortedMap) {
			comparator = ((SortedMap) items).comparator();
		}

		Map<Integer, SortedMap<K1, V1>> entriesForPartition = new HashMap<Integer, SortedMap<K1, V1>>();
		for (Map.Entry<K1, V1> e : items.entrySet()) {
			Integer partitionId = baseMap.getPartitionManager().getPartition(e.getKey());
			SortedMap<K1, V1> listEntries = entriesForPartition.get(partitionId);
			if (listEntries == null) {
				listEntries = new TreeMap<K1, V1>(comparator);
				entriesForPartition.put(partitionId, listEntries);
			}
			listEntries.put(e.getKey(), e.getValue());
		}
		return entriesForPartition;
	}

#end
#end
#No. 187219
#File: E:\bishe\1\WXSAgent.java
#Comment:
	/**
	 * This takes a list of keys and places them in partition aligned buckets. Partitions with no keys have no entries
	 * in the returned Map.
	 * 
	 * @param <K>
	 * @param baseMap
	 * @param keys
	 * @return a map of partition to sorted keys
	 */

#Code:
	static public <K> Map<Integer, List<K>> convertToPartitionEntryMap(BackingMap baseMap, Collection<K> keys) {
		Map<Integer, List<K>> entriesForPartition = new HashMap<Integer, List<K>>();
		for (K k : keys) {
			Integer partitionId = baseMap.getPartitionManager().getPartition(k);
			List<K> listEntries = (List<K>) entriesForPartition.get(partitionId);
			if (listEntries == null) {
				listEntries = new LinkedList<K>();
				entriesForPartition.put(partitionId, listEntries);
			}
			listEntries.add(k);
		}

		// get the comparator if it exists
		Comparator<K> comparator = null;
		if (keys instanceof SortedSet) {
			comparator = ((SortedSet) keys).comparator();
		}

		// sort all the keys per partition
		for (Map.Entry<Integer, List<K>> entry : entriesForPartition.entrySet()) {
			K[] o = (K[]) entry.getValue().toArray();
			Arrays.sort(o, comparator);
			entry.setValue(Arrays.asList(o));
		}
		return entriesForPartition;
	}

#end
#end
#No. 187220
#File: E:\bishe\1\WXSAgent.java
#Comment:
	/**
	 * This is used to check all Agents returned TRUE which indicates no problems.
	 * 
	 * @param results
	 * @return true if all Agents returned true
	 */

#Code:
	static public <V> boolean areAllFutures(V expected, Collection<Future<V>> results, long timeout) {
		FailedKeysException failedKeys = null;
		try {
			for (Future<V> f : results) {
				long start = System.nanoTime();
				try {
					if (!checkReturnValue(expected, f.get(timeout, TimeUnit.NANOSECONDS))) {
						return false;
					}
				} catch (FailedKeysException fe) {
					if (failedKeys == null) {
						failedKeys = fe;
					} else {
						failedKeys.combine(fe);
					}
				}
				long end = System.nanoTime();
				timeout -= (end - start);
			}
		} catch (Exception e) {
			logger.log(Level.SEVERE, "Exception", e);
			throw new ObjectGridRuntimeException(e);
		}

		if (failedKeys != null) {
			logger.log(Level.SEVERE, "Remote exception: " + failedKeys);
			throw new ObjectGridRuntimeException("Multiple agent failures", failedKeys);
		}

		return true;
	}


#end
#end
#No. 187224
#File: E:\bishe\1\WXSDKEngine.java
#Comment:
  /**
   *
   * @param application
   * @param config initial configurations or null
   */

#Code:
  public static void initialize(Application application,InitConfig config){
    synchronized (mLock) {
      if (mIsInit) {
        return;
      }
      long start = System.currentTimeMillis();
      WXEnvironment.sSDKInitStart = start;
      doInitInternal(application,config);
      WXEnvironment.sSDKInitInvokeTime = System.currentTimeMillis()-start;
      WXLogUtils.renderPerformanceLog("SDKInitInvokeTime", WXEnvironment.sSDKInitInvokeTime);
      mIsInit = true;
    }
  }

#end
#end
#No. 187225
#File: E:\bishe\1\WXSDKEngine.java
#Comment:
  /**
   *
   * Register component. The registration is singleton in {@link WXSDKEngine} level
   * @param type name of component. Same as type field in the JS.
   * @param clazz the class of the {@link WXComponent} to be registered.
   * @param appendTree true for appendTree flag
   * @return true for registration success, false for otherwise.
   * @throws WXException Throws exception if type conflicts.
   */

#Code:
  public static boolean registerComponent(String type, Class<? extends WXComponent> clazz, boolean appendTree) throws WXException {
    return registerComponent(clazz, appendTree,type);
  }

#end
#end
#No. 187226
#File: E:\bishe\1\WXSDKEngine.java
#Comment:
  /**
   *
   * Register component. The registration is singleton in {@link WXSDKEngine} level
   * @param clazz the class of the {@link WXComponent} to be registered.
   * @param appendTree true for appendTree flag
   * @return true for registration success, false for otherwise.
   * @param names names(alias) of component. Same as type field in the JS.
   * @throws WXException Throws exception if type conflicts.
   */

#Code:
  public static boolean registerComponent(Class<? extends WXComponent> clazz, boolean appendTree,String ... names) throws WXException {
    if(clazz == null){
      return false;
    }
    SimpleComponentHolder holder = new SimpleComponentHolder(clazz);
    return registerComponent(clazz,holder,appendTree,names);
  }

#end
#end
#No. 187227
#File: E:\bishe\1\WXSDKEngine.java
#Comment:
  /**
   * Register module. This is a wrapper method for
   * {@link #registerModule(String, Class, boolean)}. The module register here only need to
   * be singleton in {@link WXSDKInstance} level.
   * @param moduleName  module name
   * @param moduleClass module to be registered.
   * @return true for registration success, false for otherwise.
   * {@link WXModuleManager#registerModule(String, ModuleFactory, boolean)}
   */

#Code:
  public static <T extends WXModule> boolean registerModule(String moduleName, Class<T> moduleClass,boolean global) throws WXException {
    return moduleClass != null && registerModule(moduleName, new TypeModuleFactory<>(moduleClass), global);
  }

#end
#end
#No. 187228
#File: E:\bishe\1\WXSDKEngine.java
#Comment:
  /**
   * Register module. This is a wrapper method for
   * {@link #registerModule(String, Class, boolean)}. The module register here only need to
   * be singleton in {@link WXSDKInstance} level.
   * @param moduleName  module name
   * @param factory module factory to be registered. You can override {@link DestroyableModuleFactory#buildInstance()} to customize module creation.
   * @return true for registration success, false for otherwise.
   * {@link WXModuleManager#registerModule(String, ModuleFactory, boolean)}
   */

#Code:
  public static <T extends WXModule> boolean registerModuleWithFactory(String moduleName, DestroyableModuleFactory factory, boolean global) throws WXException {
    return registerModule(moduleName, factory,global);
  }

#end
#end
#No. 187229
#File: E:\bishe\1\WXShapeFeature.java
#Comment:
  /**
   * @param shapeType Pass {@link #RoundShape} or {@link #RoundRectShape}. Default
   *                  value is {@link #RoundShape}.
   * @attr ref R.styleable#ImageShapeFeature_uik_shapeType
   */

#Code:
  private void setShape(int shapeType) {
    if (RoundShape == shapeType) {
      mShape = new OvalShape();
      if (mHost instanceof ImageView) {
        ((ImageView) mHost).setScaleType(ImageView.ScaleType.CENTER_INSIDE);
      }
      mIsRound = true;
    } else if (RoundRectShape == shapeType) {
      mShape = new RoundRectShape(mCornerRadiusArray, null, null);
      mIsRound = false;
    }
  }


#end
#end
#No. 187233
#File: E:\bishe\1\WXSMapAgent.java
#Comment:
	/**
	 * This takes a Map of key/MapAgent pairs and then invokes the agent for each key as efficiently as possible
	 * 
	 * @param <K>
	 *            The type of the keys
	 * @param <A>
	 *            The agent type
	 * @param <X>
	 *            The result type of the agent process method
	 * @param batch
	 *            The K/Agent map to execute
	 * @param bmap
	 *            The map containing the keys
	 * @return A Map with the agent result for each key
	 */

#Code:
	static public <A extends MapGridAgent, K extends Serializable, X> Map<K, X> callMapAgentAll(WXSUtils utils, Map<K, A> batch, BackingMap bmap) {
		if (batch.size() > 0) {
			Map<Integer, SortedMap<K, A>> pmap = convertToPartitionEntryMap(bmap, batch);
			ArrayList<Future<Map<K, X>>> results = new ArrayList<Future<Map<K, X>>>(pmap.size());
			for (SortedMap<K, A> perPartitionEntries : pmap.values()) {

				// invoke the agent to add the batch of records to the grid
				// but if no work for this partition then skip it
				if (perPartitionEntries.size() > 0) {
					// we need one key for partition routing
					// so get the first one
					Serializable key = perPartitionEntries.keySet().iterator().next();

					MapAgentExecutor<A, K, X> ia = new MapAgentExecutor<A, K, X>();
					ia.batch = perPartitionEntries;
					Future<Map<K, X>> fv = utils.getExecutorService().submit(new CallReduceAgentThread<Map<K, X>>(utils, bmap.getName(), key, ia));
					results.add(fv);
				}
			}

			return collectResultsAsMap(results, ConfigProperties.getAgentTimeout(utils.getConfigProperties()));
		} else {
			return Collections.emptyMap();
		}
	}

#end
#end
#No. 187234
#File: E:\bishe\1\WXSReduceAgent.java
#Comment:
	/**
	 * This invokes the ReduceAgent for each key as efficiently as possible and reduces the results.
	 * 
	 * @param <K>
	 *            The key type
	 * @param <A>
	 *            The agent type
	 * @param <X>
	 *            The result of the ReduceGridAgent
	 * @param batch
	 *            The key/agent map
	 * @param bmap
	 *            The map containing the keys
	 * @return The reduced value for all agents
	 */

#Code:
	static private <A extends ReduceGridAgent, K extends Serializable, X> X callReduceAgentAll(WXSUtils utils, Map<K, A> batch, BackingMap bmap) {
		if (batch.size() > 0) {
			try {
				Map<Integer, SortedMap<K, A>> pmap = convertToPartitionEntryMap(bmap, batch);
				ArrayList<Future<X>> results = new ArrayList<Future<X>>(pmap.size());

				for (SortedMap<K, A> perPartitionEntries : pmap.values()) {
					// we need one key for partition routing
					// so get the first one
					K key = perPartitionEntries.keySet().iterator().next();

					// invoke the agent to add the batch of records to the grid
					ReduceAgentExecutor<A, K> ia = new ReduceAgentExecutor<A, K>();
					ia.batch = perPartitionEntries;
					// only call if work to go
					if (ia.batch.size() > 0) {
						Future<X> fv = utils.getExecutorService().submit(new CallReduceAgentThread<X>(utils, bmap.getName(), key, ia));
						results.add(fv);
					}
				}

				List<X> r = collectResultsAsList(results, ConfigProperties.getAgentTimeout(utils.getConfigProperties()));
				A agent = batch.values().iterator().next();
				X retVal = (X) agent.reduceResults(r);

				return retVal;
			} catch (Exception e) {
				logger.log(Level.SEVERE, "Exception", e);
				throw new ObjectGridRuntimeException(e);
			}
		}

		return null;
	}

#end
#end
#No. 187235
#File: E:\bishe\1\WxsThriftServer.java
#Comment:
	/**
	 * @param args
	 */

#Code:
	public static void main(String[] args) 
		throws TTransportException, IOException, URISyntaxException, FileNotFoundException
	{
		Options options = new Options();
		CmdLineParser parser = new CmdLineParser(options);
		try
		{
			parser.parseArgument(args);
			WXSUtils client = WXSUtils.getDefaultUtils();
			if(client == null)
			{
				logger.error("Cannot connect to grid, check wxsutils.properties");
				return;
			}
			
			InetSocketAddress address = new InetSocketAddress(options.hostName, options.port);
			System.out.println("Listening for thrift requests @ " + options.hostName + ":" + options.port);
			final TNonblockingServerSocket socket = new TNonblockingServerSocket(address);
			final WxsGatewayService.Processor processor = new WxsGatewayService.Processor(
			        new Handler(client));
			final TServer server = new THsHaServer(processor, socket,
			        new TFramedTransport.Factory(), new TBinaryProtocol.Factory());
			
			server.serve();	
		}
		catch(CmdLineException e)
		{
			parser.printUsage(System.out);
		}
	}


#end
#end
#No. 187237
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Init refresh view or loading view
   */

#Code:
  private void setRefreshView() {
    // SetUp HeaderView
    FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, 0);
    headerView = new WXRefreshView(getContext());
    headerView.setStartEndTrim(0, 0.75f);
    headerView.setBackgroundColor(mRefreshViewBgColor);
    headerView.setProgressBgColor(mProgressBgColor);
    headerView.setProgressColor(mProgressColor);
    addView(headerView, lp);

    // SetUp FooterView
    lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, 0);
    lp.gravity = Gravity.BOTTOM;
    footerView = new WXRefreshView(getContext());
    footerView.setStartEndTrim(0.5f, 1.25f);
    footerView.setBackgroundColor(mRefreshViewBgColor);
    footerView.setProgressBgColor(mProgressBgColor);
    footerView.setProgressColor(mProgressColor);
    addView(footerView, lp);
  }

#end
#end
#No. 187238
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Callback on TouchEvent.ACTION_CANCLE or TouchEvent.ACTION_UP
   * handler : refresh or loading
   * @param child : child view of SwipeLayout,RecyclerView or Scroller
   */

#Code:
  @Override
  public void onStopNestedScroll(View child) {
    parentHelper.onStopNestedScroll(child);
    handlerAction();
  }

#end
#end
#No. 187239
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * With child view to processing move events
   * @param target the child view
   * @param dx move x
   * @param dy move y
   * @param consumed parent consumed move distance
   */

#Code:
  @Override
  public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) {

    if ((!mPullRefreshEnable && !mPullLoadEnable)) {
      return;
    }

    // Prevent Layout shake
    if (Math.abs(dy) > 200) {
      return;
    }

    if (!isConfirm) {
      if (dy < 0 && !canChildScrollUp()) {
        mCurrentAction = PULL_REFRESH;
        isConfirm = true;
      } else if (dy > 0 && !canChildScrollDown()) {
        mCurrentAction = LOAD_MORE;
        isConfirm = true;
      }
    }

    if (moveSpinner(-dy)) {
      consumed[1] += dy;
    }
  }

#end
#end
#No. 187240
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Adjust contentView(Scroller or List) at refresh or loading time
   * @param h Height of refresh view or loading view
   */

#Code:
  private void moveTargetView(float h) {
    mTargetView.setTranslationY(h);
  }

#end
#end
#No. 187241
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Decide on the action refresh or loadmore
   */

#Code:
  private void handlerAction() {

    if (isRefreshing()) {
      return;
    }
    isConfirm = false;

    LayoutParams lp;
    if (mPullRefreshEnable && mCurrentAction == PULL_REFRESH) {
      lp = (LayoutParams) headerView.getLayoutParams();
      if (lp.height >= loadingViewHeight) {
        startRefresh(lp.height);
      } else if (lp.height > 0) {
        resetHeaderView(lp.height);
      } else {
        resetRefreshState();
      }
    }

    if (mPullLoadEnable && mCurrentAction == LOAD_MORE) {
      lp = (LayoutParams) footerView.getLayoutParams();
      if (lp.height >= loadingViewHeight) {
        startLoadmore(lp.height);
      } else if (lp.height > 0) {
        resetFootView(lp.height);
      } else {
        resetLoadmoreState();
      }
    }
  }

#end
#end
#No. 187242
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Start Refresh
   * @param headerViewHeight
   */

#Code:
  private void startRefresh(int headerViewHeight) {
    mRefreshing = true;
    ValueAnimator animator = ValueAnimator.ofFloat(headerViewHeight, loadingViewHeight);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
      @Override
      public void onAnimationUpdate(ValueAnimator animation) {
        LayoutParams lp = (LayoutParams) headerView.getLayoutParams();
        lp.height = (int) ((Float) animation.getAnimatedValue()).floatValue();
        headerView.setLayoutParams(lp);
        moveTargetView(lp.height);
      }
    });
    animator.addListener(new WXRefreshAnimatorListener() {
      @Override
      public void onAnimationEnd(Animator animation) {
        headerView.startAnimation();
        //TODO updateLoadText
        if (onRefreshListener != null) {
          onRefreshListener.onRefresh();
        }
      }
    });
    animator.setDuration(300);
    animator.start();
  }

#end
#end
#No. 187243
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Reset refresh state
   * @param headerViewHeight
   */

#Code:
  private void resetHeaderView(int headerViewHeight) {
    headerView.stopAnimation();
    headerView.setStartEndTrim(0, 0.75f);
    ValueAnimator animator = ValueAnimator.ofFloat(headerViewHeight, 0);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
      @Override
      public void onAnimationUpdate(ValueAnimator animation) {
        LayoutParams lp = (LayoutParams) headerView.getLayoutParams();
        lp.height = (int) ((Float) animation.getAnimatedValue()).floatValue();
        headerView.setLayoutParams(lp);
        moveTargetView(lp.height);
      }
    });
    animator.addListener(new WXRefreshAnimatorListener() {
      @Override
      public void onAnimationEnd(Animator animation) {
        resetRefreshState();

      }
    });
    animator.setDuration(300);
    animator.start();
  }

#end
#end
#No. 187244
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Start loadmore
   * @param headerViewHeight
   */

#Code:
  private void startLoadmore(int headerViewHeight) {
    mRefreshing = true;
    ValueAnimator animator = ValueAnimator.ofFloat(headerViewHeight, loadingViewHeight);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
      @Override
      public void onAnimationUpdate(ValueAnimator animation) {
        LayoutParams lp = (LayoutParams) footerView.getLayoutParams();
        lp.height = (int) ((Float) animation.getAnimatedValue()).floatValue();
        footerView.setLayoutParams(lp);
        moveTargetView(-lp.height);
      }
    });
    animator.addListener(new WXRefreshAnimatorListener() {
      @Override
      public void onAnimationEnd(Animator animation) {
        footerView.startAnimation();
        //TODO updateLoadText
        if (onLoadingListener != null) {
          onLoadingListener.onLoading();
        }
      }
    });
    animator.setDuration(300);
    animator.start();
  }

#end
#end
#No. 187245
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Reset loadmore state
   * @param headerViewHeight
   */

#Code:
  private void resetFootView(int headerViewHeight) {
    footerView.stopAnimation();
    footerView.setStartEndTrim(0.5f, 1.25f);
    ValueAnimator animator = ValueAnimator.ofFloat(headerViewHeight, 0);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
      @Override
      public void onAnimationUpdate(ValueAnimator animation) {
        LayoutParams lp = (LayoutParams) footerView.getLayoutParams();
        lp.height = (int) ((Float) animation.getAnimatedValue()).floatValue();
        footerView.setLayoutParams(lp);
        moveTargetView(-lp.height);
      }
    });
    animator.addListener(new WXRefreshAnimatorListener() {
      @Override
      public void onAnimationEnd(Animator animation) {
        resetLoadmoreState();

      }
    });
    animator.setDuration(300);
    animator.start();
  }

#end
#end
#No. 187246
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Whether child view can scroll up
   * @return
   */

#Code:
  public boolean canChildScrollUp() {
    if (mTargetView == null) {
      return false;
    }
    if (Build.VERSION.SDK_INT < 14) {
      if (mTargetView instanceof AbsListView) {
        final AbsListView absListView = (AbsListView) mTargetView;
        return absListView.getChildCount() > 0
               && (absListView.getFirstVisiblePosition() > 0 || absListView.getChildAt(0)
                                                                    .getTop() < absListView.getPaddingTop());
      } else {
        return ViewCompat.canScrollVertically(mTargetView, -1) || mTargetView.getScrollY() > 0;
      }
    } else {
      return ViewCompat.canScrollVertically(mTargetView, -1);
    }
  }

#end
#end
#No. 187247
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Whether child view can scroll down
   * @return
   */

#Code:
  public boolean canChildScrollDown() {
    if (mTargetView == null) {
      return false;
    }
    if (Build.VERSION.SDK_INT < 14) {
      if (mTargetView instanceof AbsListView) {
        final AbsListView absListView = (AbsListView) mTargetView;
        if (absListView.getChildCount() > 0) {
          int lastChildBottom = absListView.getChildAt(absListView.getChildCount() - 1)
              .getBottom();
          return absListView.getLastVisiblePosition() == absListView.getAdapter().getCount() - 1
                 && lastChildBottom <= absListView.getMeasuredHeight();
        } else {
          return false;
        }

      } else {
        return ViewCompat.canScrollVertically(mTargetView, 1) || mTargetView.getScrollY() > 0;
      }
    } else {
      return ViewCompat.canScrollVertically(mTargetView, 1);
    }
  }

#end
#end
#No. 187248
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Callback on refresh finish
   */

#Code:
  public void finishPullRefresh() {
    if (mCurrentAction == PULL_REFRESH) {
      resetHeaderView(headerView == null ? 0 : headerView.getMeasuredHeight());
    }
  }

#end
#end
#No. 187249
#File: E:\bishe\1\WXSwipeLayout.java
#Comment:
  /**
   * Callback on loadmore finish
   */

#Code:
  public void finishPullLoad() {
    if (mCurrentAction == LOAD_MORE) {
      resetFootView(footerView == null ? 0 : footerView.getMeasuredHeight());
    }
  }

#end
#end
#No. 187250
#File: E:\bishe\1\WXTabPage.java
#Comment:
    /**
     * Measure the size of the recyclerView.
     *
     * @param width  the expected width
     * @param height the expected height
     * @return the result of measurement
     */

#Code:
    @Override
    protected MeasureOutput measure(int width, int height) {
        int screenH = WXViewUtils.getScreenHeight(WXEnvironment.sApplication);
        int weexH = WXViewUtils.getWeexHeight(mInstanceId);
        int outHeight = height > (weexH >= screenH ? screenH : weexH) ? weexH - mAbsoluteY : height;
        if (outHeight == 0){
            outHeight = weexH - mAbsoluteY;
        }
        return super.measure(width, outHeight);
    }

#end
#end
#No. 187253
#File: E:\bishe\1\WXTextDomObject.java
#Comment:
  /**
   * Get text width according to constrain of outerWidth with and forceToDesired
   * @param textPaint paint used to measure text
   * @param outerWidth the width that css-layout desired.
   * @param forceToDesired if set true, the return value will be outerWidth, no matter what the width
   *                   of text is.
   * @return if forceToDesired is false, it will be the minimum value of the width of text and
   * outerWidth in case of outerWidth is defined, in other case, it will be outer width.
   */

#Code:
  private float getTextWidth(TextPaint textPaint,float outerWidth, boolean forceToDesired) {
    float textWidth;
    if (forceToDesired) {
      textWidth = outerWidth;
    } else {
      float desiredWidth = Layout.getDesiredWidth(spanned, textPaint);
      if (CSSConstants.isUndefined(outerWidth) || desiredWidth < outerWidth) {
        textWidth = desiredWidth;
      } else {
        textWidth = outerWidth;
      }
    }
    return textWidth;
  }

#end
#end
#No. 187254
#File: E:\bishe\1\WXTextDomObject.java
#Comment:
  /**
   * Update {@link #spanned} according to the give charSequence and {@link #style}
   * @param text the give raw text.
   * @return an Spanned contains text and spans
   */

#Code:
  private
  @NonNull
  Spanned createSpanned(String text) {
    if (!TextUtils.isEmpty(text)) {
      SpannableString spannable = new SpannableString(text);
      List<SetSpanOperation> ops = createSetSpanOperation(spannable.length());
      if (mFontSize == UNSET) {
        ops.add(new SetSpanOperation(0, spannable.length(),
                                     new AbsoluteSizeSpan(WXText.sDEFAULT_SIZE)));
      }
      Collections.reverse(ops);
      for (SetSpanOperation op : ops) {
        op.execute(spannable);
      }
      return spannable;
    }
    return new SpannableString("");
  }

#end
#end
#No. 187255
#File: E:\bishe\1\WXTextDomObject.java
#Comment:
  /**
   * Create a task list which contains {@link SetSpanOperation}. The task list will be executed
   * in other method.
   * @param end the end character of the text.
   * @return a task list which contains {@link SetSpanOperation}.
   */

#Code:
  private List<SetSpanOperation> createSetSpanOperation(int end) {
    List<SetSpanOperation> ops = new LinkedList<>();
    int start = 0;
    if (end >= start) {
      if (mTextDecoration == WXTextDecoration.UNDERLINE) {
        ops.add(new SetSpanOperation(start, end,
                                     new UnderlineSpan()));
      }
      if (mTextDecoration == WXTextDecoration.LINETHROUGH) {
        ops.add(new SetSpanOperation(start, end,
                                     new StrikethroughSpan()));
      }
      if (mIsColorSet) {
        ops.add(new SetSpanOperation(start, end,
                                     new ForegroundColorSpan(mColor)));
      }
      if (mFontSize != UNSET) {
        ops.add(new SetSpanOperation(start, end, new AbsoluteSizeSpan(mFontSize)));
      }
      if (mFontStyle != UNSET
          || mFontWeight != UNSET
          || mFontFamily != null) {
        ops.add(new SetSpanOperation(start, end,
                                     new WXCustomStyleSpan(mFontStyle, mFontWeight, mFontFamily)));
      }
      ops.add(new SetSpanOperation(start, end, new AlignmentSpan.Standard(mAlignment)));
      if (mLineHeight != UNSET) {
        ops.add(new SetSpanOperation(start, end, new WXLineHeightSpan(mLineHeight)));
      }
    }
    return ops;
  }

#end
#end
#No. 187256
#File: E:\bishe\1\WXTextDomObject.java
#Comment:
  /**
   * Move the reference of current layout to the {@link AtomicReference} for further use,
   * then clear current layout.
   */

#Code:
  private void swap() {
    if (layout != null) {
      atomicReference.set(layout);
      layout = null;
      mTextPaint = new TextPaint(mTextPaint);
    }
  }

#end
#end
#No. 187257
#File: E:\bishe\1\WXTextDomObject.java
#Comment:
  /**
   * As warming up TextLayoutCache done in the DOM thread may manipulate UI operation,
   there may be some exception, in which case the exception is ignored. After all,
   this is just a warm up operation.
   * @return false for warm up failure, otherwise returns true.
   */

#Code:
  private boolean warmUpTextLayoutCache(Layout layout) {
    boolean result;
    try {
      layout.draw(DUMMY_CANVAS);
      result = true;
    } catch (Exception e) {
      WXLogUtils.eTag(TAG, e);
      result = false;
    }
    return result;
  }

#end
#end
#No. 187258
#File: E:\bishe\1\WXTreeView.java
#Comment:
    /**
     * Measure the size of the recyclerView.
     *
     * @param width  the expected width
     * @param height the expected height
     * @return the result of measurement
     */

#Code:
    @Override
    protected MeasureOutput measure(int width, int height) {
        int screenH = WXViewUtils.getScreenHeight(WXEnvironment.sApplication);
        int weexH = WXViewUtils.getWeexHeight(mInstanceId);
        int outHeight = height > (weexH >= screenH ? screenH : weexH) ? weexH - mAbsoluteY : height;
        if (outHeight == 0){
            outHeight = weexH - mAbsoluteY;
        }
        return super.measure(width, outHeight);
    }

#end
#end
#No. 187259
#File: E:\bishe\1\WXUtils.java
#Comment:
  /**
   * Tell whether current thread is UI(main) thread.
   * @return true for UI(main) thread
   */

#Code:
  public static boolean isUiThread() {
    return Thread.currentThread().getId() == Looper.getMainLooper().getThread().getId();
  }

#end
#end
#No. 187260
#File: E:\bishe\1\WXUtils.java
#Comment:
  /**
   * Parse string representation of float. This method intend to be faster than
   * {@link Float#parseFloat(String)}, but less accuracy.
   * @param raw
   * @return
   */

#Code:
  public static float fastGetFloat(String raw){
    return fastGetFloat(raw, Integer.MAX_VALUE);
  }



#end
#end
#No. 187263
#File: E:\bishe\1\WymEditor.java
#Comment:
    /**
     * Upload image.
     * 
     * @return
     */

#Code:
    @OnEvent(value = "uploadImage")
    public Object uploadFile()
    {
        JSONObject result = new JSONObject();
        JSONArray message = new JSONArray();
        try
        {
            UploadedFile attachment = decoder.getFileUpload("attachment");
            String path = this.uploadMedia.uploadMedia(attachment);
            result.put("error", false);
            result.put("path", path);
            message.put(messages.get("upload-success"));
        }
        catch (IOException ioEx)
        {
            ioEx.printStackTrace();
            result.put("error", true);
            message.put(messages.get("upload-failure"));
        }
        result.put("messages", message);
        return new TextStreamResponse("text/html", result.toString());
    }


#end
#end
#No. 187269
#File: E:\bishe\1\X11PlatformFactory.java
#Comment:
/** Implementation of NativePlatformFactory for X11 platform
 *
 */

#Code:
class X11PlatformFactory extends NativePlatformFactory {

    @Override
    protected boolean matches() {
        String display = AccessController.doPrivileged(
                (PrivilegedAction<String>) () -> System.getenv("DISPLAY"));
        return display != null;
    }

    @Override
    protected int getMajorVersion() {
        return 1;
    }

    @Override
    protected int getMinorVersion() {
        return 0;
    }

    @Override
    protected NativePlatform createNativePlatform() {
        return new X11Platform();
    }

}


#end
#end
#No. 187271
#File: E:\bishe\1\X509ActionTest.java
#Comment:
    /**
     * @param x509 A revoked certificate
     */

#Code:
    private void testReenableCertificate(X509 x509) {
        try {
            assertTrue(CRLQueries.isCertificateRevoked(x509.getSerial()));
            
            X509Utils.reEnableCertificate(x509);
            
            assertFalse(CRLQueries.isCertificateRevoked(x509.getSerial()));
        } catch (Exception e) {
            e.printStackTrace();
            fail("error re-enabling a certificate");
        }
    }

#end
#end
#No. 187274
#File: E:\bishe\1\X509Certificate.java
#Comment:
    /**
     * Returns the issuer (issuer distinguished name) value from the
     * certificate as an <code>X500Principal</code>.
     * <p>
     * It is recommended that subclasses override this method.
     *
     * @return an <code>X500Principal</code> representing the issuer
     *          distinguished name
     * @since 1.4
     */

#Code:
    public X500Principal getIssuerX500Principal() {
        if (issuerX500Principal == null) {
            issuerX500Principal = X509CertImpl.getIssuerX500Principal(this);
        }
        return issuerX500Principal;
    }



#end
#end
#No. 187276
#File: E:\bishe\1\X509Certificate.java
#Comment:
    /**
     * Gets an unmodifiable list of Strings representing the OBJECT
     * IDENTIFIERs of the <code>ExtKeyUsageSyntax</code> field of the
     * extended key usage extension, (OID = 2.5.29.37).  It indicates
     * one or more purposes for which the certified public key may be
     * used, in addition to or in place of the basic purposes
     * indicated in the key usage extension field.  The ASN.1
     * definition for this is:
     * <pre>
     * ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId<p>
     *
     * KeyPurposeId ::= OBJECT IDENTIFIER<p>
     * </pre>
     *
     * Key purposes may be defined by any organization with a
     * need. Object identifiers used to identify key purposes shall be
     * assigned in accordance with IANA or ITU-T Rec. X.660 |
     * ISO/IEC/ITU 9834-1.
     * <p>
     * This method was added to version 1.4 of the Java 2 Platform Standard
     * Edition. In order to maintain backwards compatibility with existing
     * service providers, this method is not <code>abstract</code>
     * and it provides a default implementation. Subclasses
     * should override this method with a correct implementation.
     *
     * @return the ExtendedKeyUsage extension of this certificate,
     *         as an unmodifiable list of object identifiers represented
     *         as Strings. Returns null if this certificate does not
     *         contain an ExtendedKeyUsage extension.
     * @throws CertificateParsingException if the extension cannot be decoded
     * @since 1.4
     */

#Code:
    public List<String> getExtendedKeyUsage() throws CertificateParsingException {
        return X509CertImpl.getExtendedKeyUsage(this);
    }



#end
#end
#No. 187278
#File: E:\bishe\1\X509Certificate.java
#Comment:
    /**
     * Gets an immutable collection of issuer alternative names from the
     * <code>IssuerAltName</code> extension, (OID = 2.5.29.18).
     * <p>
     * The ASN.1 definition of the <code>IssuerAltName</code> extension is:
     * <pre>
     * IssuerAltName ::= GeneralNames
     * </pre>
     * The ASN.1 definition of <code>GeneralNames</code> is defined
     * in {@link #getSubjectAlternativeNames getSubjectAlternativeNames}.
     * <p>
     * If this certificate does not contain an <code>IssuerAltName</code>
     * extension, <code>null</code> is returned. Otherwise, a
     * <code>Collection</code> is returned with an entry representing each
     * <code>GeneralName</code> included in the extension. Each entry is a
     * <code>List</code> whose first entry is an <code>Integer</code>
     * (the name type, 0-8) and whose second entry is a <code>String</code>
     * or a byte array (the name, in string or ASN.1 DER encoded form,
     * respectively). For more details about the formats used for each
     * name type, see the <code>getSubjectAlternativeNames</code> method.
     * <p>
     * Note that the <code>Collection</code> returned may contain more
     * than one name of the same type. Also, note that the returned
     * <code>Collection</code> is immutable and any entries containing byte
     * arrays are cloned to protect against subsequent modifications.
     * <p>
     * This method was added to version 1.4 of the Java 2 Platform Standard
     * Edition. In order to maintain backwards compatibility with existing
     * service providers, this method is not <code>abstract</code>
     * and it provides a default implementation. Subclasses
     * should override this method with a correct implementation.
     *
     * @return an immutable <code>Collection</code> of issuer alternative
     * names (or <code>null</code>)
     * @throws CertificateParsingException if the extension cannot be decoded
     * @since 1.4
     */

#Code:
    public Collection<List<?>> getIssuerAlternativeNames()
        throws CertificateParsingException {
        return X509CertImpl.getIssuerAlternativeNames(this);
    }



#end
#end
#No. 187281
#File: E:\bishe\1\X509CertificateObject.java
#Comment:
    /**
     * return a more "meaningful" representation for the signature algorithm used in
     * the certficate.
     */

#Code:
    public String getSigAlgName()
    {
        Provider    prov = Security.getProvider(BouncyCastleProvider.PROVIDER_NAME);

        if (prov != null)
        {
            String      algName = prov.getProperty("Alg.Alias.Signature." + this.getSigAlgOID());

            if (algName != null)
            {
                return algName;
            }
        }

        Provider[] provs = Security.getProviders();

        //
        // search every provider looking for a real algorithm
        //
        for (int i = 0; i != provs.length; i++)
        {
            String algName = provs[i].getProperty("Alg.Alias.Signature." + this.getSigAlgOID());
            if (algName != null)
            {
                return algName;
            }
        }

        return this.getSigAlgOID();
    }

#end
#end
#No. 187282
#File: E:\bishe\1\X509CertificateObject.java
#Comment:
    /**
     * return the object identifier for the signature.
     */

#Code:
    public String getSigAlgOID()
    {
        return c.getSignatureAlgorithm().getObjectId().getId();
    }

#end
#end
#No. 187283
#File: E:\bishe\1\X509CertificateObject.java
#Comment:
    /**
     * return the signature parameters, or null if there aren't any.
     */

#Code:
    public byte[] getSigAlgParams()
    {
        if (c.getSignatureAlgorithm().getParameters() != null)
        {
            return c.getSignatureAlgorithm().getParameters().getDERObject().getDEREncoded();
        }
        else
        {
            return null;
        }
    }


#end
#end
#No. 187285
#File: E:\bishe\1\X509CertificateRealm.java
#Comment:
	/**
	 * The most simple certificate validation. If we are in web application context, the certificate is already checked 
	 * by web server and valid, so this method is useless there. 
	 *  
	 * @param certificate to be validated
	 * 
	 * @return <code>true</code> if the certificate is valid. <code>false</code> otherwise.
	 */

#Code:
	private boolean certificateOK(X509Certificate certificate) {
		if (certificate == null)
			return false;

		List<X509Certificate> chain = Arrays.asList(certificate);
		FileInputStream stream = null;

		/* Construct a valid path. */
		try {
			stream = new FileInputStream(getTrustStore());
			KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
			keyStore.load(stream, getTrustStorePassword().toCharArray());
			
			X509CertSelector target = new X509CertSelector();
			target.setCertificate(certificate);
			PKIXBuilderParameters params = new PKIXBuilderParameters(keyStore, target);
			CertStoreParameters intermediates = new CollectionCertStoreParameters(chain);
			params.addCertStore(CertStore.getInstance("Collection", intermediates));

			// Lets ignore certificate revocation list for example purposes
			Collection<X509CRL> crls = Collections.emptyList();
			CertStoreParameters revoked = new CollectionCertStoreParameters(crls);
			params.addCertStore(CertStore.getInstance("Collection", revoked));

			// If build() returns successfully, the certificate is valid.
			@SuppressWarnings("unused")
			CertPathBuilderResult r = CertPathBuilder.getInstance("PKIX").build(params);
		} catch (Exception ex) {
			log.debug("Certificate validation failed. ", ex);
			return false;
		} finally {
			try {
				stream.close();
			} catch (IOException e) {
				log.error("Could not close truststore stream.", e);
			}
		}

		return true;
	}

#end
#end
#No. 187286
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Sets the subjectAlternativeNames criterion. The
     * <code>X509Certificate</code> must contain all or at least one of the
     * specified subjectAlternativeNames, depending on the value of
     * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
     * setMatchAllSubjectAltNames}).
     * <p>
     * This method allows the caller to specify, with a single method call,
     * the complete set of subject alternative names for the
     * subjectAlternativeNames criterion. The specified value replaces
     * the previous value for the subjectAlternativeNames criterion.
     * <p>
     * The <code>names</code> parameter (if not <code>null</code>) is a
     * <code>Collection</code> with one
     * entry for each name to be included in the subject alternative name
     * criterion. Each entry is a <code>List</code> whose first entry is an
     * <code>Integer</code> (the name type, 0-8) and whose second
     * entry is a <code>String</code> or a byte array (the name, in
     * string or ASN.1 DER encoded form, respectively).
     * There can be multiple names of the same type. If <code>null</code>
     * is supplied as the value for this argument, no
     * subjectAlternativeNames check will be performed.
     * <p>
     * Each subject alternative name in the <code>Collection</code>
     * may be specified either as a <code>String</code> or as an ASN.1 encoded
     * byte array. For more details about the formats used, see
     * {@link #addSubjectAlternativeName(int type, String name)
     * addSubjectAlternativeName(int type, String name)} and
     * {@link #addSubjectAlternativeName(int type, byte [] name)
     * addSubjectAlternativeName(int type, byte [] name)}.
     * <p>
     * <strong>Note:</strong> for distinguished names, specify the byte
     * array form instead of the String form. See the note in
     * {@link #addSubjectAlternativeName(int, String)} for more information.
     * <p>
     * Note that the <code>names</code> parameter can contain duplicate
     * names (same name and name type), but they may be removed from the
     * <code>Collection</code> of names returned by the
     * {@link #getSubjectAlternativeNames getSubjectAlternativeNames} method.
     * <p>
     * Note that a deep copy is performed on the <code>Collection</code> to
     * protect against subsequent modifications.
     *
     * @param names a <code>Collection</code> of names (or <code>null</code>)
     * @throws IOException if a parsing error occurs
     * @see #getSubjectAlternativeNames
     */

#Code:
    public void setSubjectAlternativeNames(Collection<List<?>> names)
            throws IOException {
        if (names == null) {
            subjectAlternativeNames = null;
            subjectAlternativeGeneralNames = null;
        } else {
            if (names.isEmpty()) {
                subjectAlternativeNames = null;
                subjectAlternativeGeneralNames = null;
                return;
            }
            Set<List<?>> tempNames = cloneAndCheckNames(names);
            // Ensure that we either set both of these or neither
            subjectAlternativeGeneralNames = parseNames(tempNames);
            subjectAlternativeNames = tempNames;
        }
    }

#end
#end
#No. 187287
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Adds a name to the subjectAlternativeNames criterion. The
     * <code>X509Certificate</code> must contain all or at least one
     * of the specified subjectAlternativeNames, depending on the value of
     * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
     * setMatchAllSubjectAltNames}).
     * <p>
     * This method allows the caller to add a name to the set of subject
     * alternative names.
     * The specified name is added to any previous value for the
     * subjectAlternativeNames criterion. If the specified name is a
     * duplicate, it may be ignored.
     * <p>
     * The name is provided in string format.
     * <a href="http://www.ietf.org/rfc/rfc822.txt">RFC 822</a>, DNS, and URI
     * names use the well-established string formats for those types (subject to
     * the restrictions included in RFC 3280). IPv4 address names are
     * supplied using dotted quad notation. OID address names are represented
     * as a series of nonnegative integers separated by periods. And
     * directory names (distinguished names) are supplied in RFC 2253 format.
     * No standard string format is defined for otherNames, X.400 names,
     * EDI party names, IPv6 address names, or any other type of names. They
     * should be specified using the
     * {@link #addSubjectAlternativeName(int type, byte [] name)
     * addSubjectAlternativeName(int type, byte [] name)}
     * method.
     * <p>
     * <strong>Note:</strong> for distinguished names, use
     * {@linkplain #addSubjectAlternativeName(int, byte[])} instead.
     * This method should not be relied on as it can fail to match some
     * certificates because of a loss of encoding information in the RFC 2253
     * String form of some distinguished names.
     *
     * @param type the name type (0-8, as specified in
     *             RFC 3280, section 4.2.1.7)
     * @param name the name in string form (not <code>null</code>)
     * @throws IOException if a parsing error occurs
     */

#Code:
    public void addSubjectAlternativeName(int type, String name)
            throws IOException {
        addSubjectAlternativeNameInternal(type, name);
    }

#end
#end
#No. 187288
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Adds a name to the subjectAlternativeNames criterion. The
     * <code>X509Certificate</code> must contain all or at least one
     * of the specified subjectAlternativeNames, depending on the value of
     * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
     * setMatchAllSubjectAltNames}).
     * <p>
     * This method allows the caller to add a name to the set of subject
     * alternative names.
     * The specified name is added to any previous value for the
     * subjectAlternativeNames criterion. If the specified name is a
     * duplicate, it may be ignored.
     * <p>
     * The name is provided as a byte array. This byte array should contain
     * the DER encoded name, as it would appear in the GeneralName structure
     * defined in RFC 3280 and X.509. The encoded byte array should only contain
     * the encoded value of the name, and should not include the tag associated
     * with the name in the GeneralName structure. The ASN.1 definition of this
     * structure appears below.
     * <pre><code>
     *  GeneralName ::= CHOICE {
     *       otherName                       [0]     OtherName,
     *       rfc822Name                      [1]     IA5String,
     *       dNSName                         [2]     IA5String,
     *       x400Address                     [3]     ORAddress,
     *       directoryName                   [4]     Name,
     *       ediPartyName                    [5]     EDIPartyName,
     *       uniformResourceIdentifier       [6]     IA5String,
     *       iPAddress                       [7]     OCTET STRING,
     *       registeredID                    [8]     OBJECT IDENTIFIER}
     * </code></pre>
     * <p>
     * Note that the byte array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param type the name type (0-8, as listed above)
     * @param name a byte array containing the name in ASN.1 DER encoded form
     * @throws IOException if a parsing error occurs
     */

#Code:
    public void addSubjectAlternativeName(int type, byte[] name)
            throws IOException {
        // clone because byte arrays are modifiable
        addSubjectAlternativeNameInternal(type, name.clone());
    }

#end
#end
#No. 187289
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * A private method that adds a name (String or byte array) to the
     * subjectAlternativeNames criterion. The <code>X509Certificate</code>
     * must contain the specified subjectAlternativeName.
     *
     * @param type the name type (0-8, as specified in
     *             RFC 3280, section 4.2.1.7)
     * @param name the name in string or byte array form
     * @throws IOException if a parsing error occurs
     */

#Code:
    private void addSubjectAlternativeNameInternal(int type, Object name)
            throws IOException {
        // First, ensure that the name parses
        GeneralNameInterface tempName = makeGeneralNameInterface(type, name);
        if (subjectAlternativeNames == null) {
            subjectAlternativeNames = new HashSet<List<?>>();
        }
        if (subjectAlternativeGeneralNames == null) {
            subjectAlternativeGeneralNames = new HashSet<GeneralNameInterface>();
        }
        List<Object> list = new ArrayList<Object>(2);
        list.add(Integer.valueOf(type));
        list.add(name);
        subjectAlternativeNames.add(list);
        subjectAlternativeGeneralNames.add(tempName);
    }

#end
#end
#No. 187290
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Parse an argument of the form passed to setSubjectAlternativeNames,
     * returning a <code>Collection</code> of
     * <code>GeneralNameInterface</code>s.
     * Throw an IllegalArgumentException or a ClassCastException
     * if the argument is malformed.
     *
     * @param names a Collection with one entry per name.
     *              Each entry is a <code>List</code> whose first entry
     *              is an Integer (the name type, 0-8) and whose second
     *              entry is a String or a byte array (the name, in
     *              string or ASN.1 DER encoded form, respectively).
     *              There can be multiple names of the same type. Null is
     *              not an acceptable value.
     * @return a Set of <code>GeneralNameInterface</code>s
     * @throws IOException if a parsing error occurs
     */

#Code:
    private static Set<GeneralNameInterface> parseNames(Collection<List<?>> names) throws IOException {
        Set<GeneralNameInterface> genNames = new HashSet<GeneralNameInterface>();
        for (List<?> nameList : names) {
            if (nameList.size() != 2) {
                throw new IOException("name list size not 2");
            }
            Object o =  nameList.get(0);
            if (!(o instanceof Integer)) {
                throw new IOException("expected an Integer");
            }
            int nameType = ((Integer)o).intValue();
            o = nameList.get(1);
            genNames.add(makeGeneralNameInterface(nameType, o));
        }

        return genNames;
    }

#end
#end
#No. 187291
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Compare for equality two objects of the form passed to
     * setSubjectAlternativeNames (or X509CRLSelector.setIssuerNames).
     * Throw an <code>IllegalArgumentException</code> or a
     * <code>ClassCastException</code> if one of the objects is malformed.
     *
     * @param object1 a Collection containing the first object to compare
     * @param object2 a Collection containing the second object to compare
     * @return true if the objects are equal, false otherwise
     */

#Code:
    static boolean equalNames(Collection object1, Collection object2) {
        if ((object1 == null) || (object2 == null)) {
            return object1 == object2;
        }
        return object1.equals(object2);
    }

#end
#end
#No. 187292
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Sets the name constraints criterion. The <code>X509Certificate</code>
     * must have subject and subject alternative names that
     * meet the specified name constraints.
     * <p>
     * The name constraints are specified as a byte array. This byte array
     * should contain the DER encoded form of the name constraints, as they
     * would appear in the NameConstraints structure defined in RFC 3280
     * and X.509. The ASN.1 definition of this structure appears below.
     *
     * <pre><code>
     *  NameConstraints ::= SEQUENCE {
     *       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
     *       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
     *
     *  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
     *
     *  GeneralSubtree ::= SEQUENCE {
     *       base                    GeneralName,
     *       minimum         [0]     BaseDistance DEFAULT 0,
     *       maximum         [1]     BaseDistance OPTIONAL }
     *
     *  BaseDistance ::= INTEGER (0..MAX)
     *
     *  GeneralName ::= CHOICE {
     *       otherName                       [0]     OtherName,
     *       rfc822Name                      [1]     IA5String,
     *       dNSName                         [2]     IA5String,
     *       x400Address                     [3]     ORAddress,
     *       directoryName                   [4]     Name,
     *       ediPartyName                    [5]     EDIPartyName,
     *       uniformResourceIdentifier       [6]     IA5String,
     *       iPAddress                       [7]     OCTET STRING,
     *       registeredID                    [8]     OBJECT IDENTIFIER}
     * </code></pre>
     * <p>
     * Note that the byte array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param bytes a byte array containing the ASN.1 DER encoding of
     *              a NameConstraints extension to be used for checking
     *              name constraints. Only the value of the extension is
     *              included, not the OID or criticality flag. Can be
     *              <code>null</code>,
     *              in which case no name constraints check will be performed.
     * @throws IOException if a parsing error occurs
     * @see #getNameConstraints
     */

#Code:
    public void setNameConstraints(byte[] bytes) throws IOException {
        if (bytes == null) {
            ncBytes = null;
            nc = null;
        } else {
            ncBytes = bytes.clone();
            nc = new NameConstraintsExtension(FALSE, bytes);
        }
    }

#end
#end
#No. 187293
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Sets the basic constraints constraint. If the value is greater than or
     * equal to zero, <code>X509Certificates</code> must include a
     * basicConstraints extension with
     * a pathLen of at least this value. If the value is -2, only end-entity
     * certificates are accepted. If the value is -1, no check is done.
     * <p>
     * This constraint is useful when building a certification path forward
     * (from the target toward the trust anchor. If a partial path has been
     * built, any candidate certificate must have a maxPathLen value greater
     * than or equal to the number of certificates in the partial path.
     *
     * @param minMaxPathLen the value for the basic constraints constraint
     * @throws IllegalArgumentException if the value is less than -2
     * @see #getBasicConstraints
     */

#Code:
    public void setBasicConstraints(int minMaxPathLen) {
        if (minMaxPathLen < -2) {
            throw new IllegalArgumentException("basic constraints less than -2");
        }
        basicConstraints = minMaxPathLen;
    }

#end
#end
#No. 187294
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Sets the policy constraint. The <code>X509Certificate</code> must
     * include at least one of the specified policies in its certificate
     * policies extension. If <code>certPolicySet</code> is empty, then the
     * <code>X509Certificate</code> must include at least some specified policy
     * in its certificate policies extension. If <code>certPolicySet</code> is
     * <code>null</code>, no policy check will be performed.
     * <p>
     * Note that the <code>Set</code> is cloned to protect against
     * subsequent modifications.
     *
     * @param certPolicySet a <code>Set</code> of certificate policy OIDs in
     *                      string format (or <code>null</code>). Each OID is
     *                      represented by a set of nonnegative integers
     *                    separated by periods.
     * @throws IOException if a parsing error occurs on the OID such as
     * the first component is not 0, 1 or 2 or the second component is
     * greater than 39.
     * @see #getPolicy
     */

#Code:
    public void setPolicy(Set<String> certPolicySet) throws IOException {
        if (certPolicySet == null) {
            policySet = null;
            policy = null;
        } else {
            // Snapshot set and parse it
            Set<String> tempSet = Collections.unmodifiableSet
                                        (new HashSet<String>(certPolicySet));
            /* Convert to Vector of ObjectIdentifiers */
            Iterator<String> i = tempSet.iterator();
            Vector<CertificatePolicyId> polIdVector = new Vector<CertificatePolicyId>();
            while (i.hasNext()) {
                Object o = i.next();
                if (!(o instanceof String)) {
                    throw new IOException("non String in certPolicySet");
                }
                polIdVector.add(new CertificatePolicyId(new ObjectIdentifier(
                  (String)o)));
            }
            // If everything went OK, make the changes
            policySet = tempSet;
            policy = new CertificatePolicySet(polIdVector);
        }
    }

#end
#end
#No. 187295
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Sets the pathToNames criterion. The <code>X509Certificate</code> must
     * not include name constraints that would prohibit building a
     * path to the specified names.
     * <p>
     * This method allows the caller to specify, with a single method call,
     * the complete set of names which the <code>X509Certificates</code>'s
     * name constraints must permit. The specified value replaces
     * the previous value for the pathToNames criterion.
     * <p>
     * This constraint is useful when building a certification path forward
     * (from the target toward the trust anchor. If a partial path has been
     * built, any candidate certificate must not include name constraints that
     * would prohibit building a path to any of the names in the partial path.
     * <p>
     * The <code>names</code> parameter (if not <code>null</code>) is a
     * <code>Collection</code> with one
     * entry for each name to be included in the pathToNames
     * criterion. Each entry is a <code>List</code> whose first entry is an
     * <code>Integer</code> (the name type, 0-8) and whose second
     * entry is a <code>String</code> or a byte array (the name, in
     * string or ASN.1 DER encoded form, respectively).
     * There can be multiple names of the same type. If <code>null</code>
     * is supplied as the value for this argument, no
     * pathToNames check will be performed.
     * <p>
     * Each name in the <code>Collection</code>
     * may be specified either as a <code>String</code> or as an ASN.1 encoded
     * byte array. For more details about the formats used, see
     * {@link #addPathToName(int type, String name)
     * addPathToName(int type, String name)} and
     * {@link #addPathToName(int type, byte [] name)
     * addPathToName(int type, byte [] name)}.
     * <p>
     * <strong>Note:</strong> for distinguished names, specify the byte
     * array form instead of the String form. See the note in
     * {@link #addPathToName(int, String)} for more information.
     * <p>
     * Note that the <code>names</code> parameter can contain duplicate
     * names (same name and name type), but they may be removed from the
     * <code>Collection</code> of names returned by the
     * {@link #getPathToNames getPathToNames} method.
     * <p>
     * Note that a deep copy is performed on the <code>Collection</code> to
     * protect against subsequent modifications.
     *
     * @param names a <code>Collection</code> with one entry per name
     *              (or <code>null</code>)
     * @throws IOException if a parsing error occurs
     * @see #getPathToNames
     */

#Code:
    public void setPathToNames(Collection<List<?>> names) throws IOException {
        if ((names == null) || names.isEmpty()) {
            pathToNames = null;
            pathToGeneralNames = null;
        } else {
            Set<List<?>> tempNames = cloneAndCheckNames(names);
            pathToGeneralNames = parseNames(tempNames);
            // Ensure that we either set both of these or neither
            pathToNames = tempNames;
        }
    }

#end
#end
#No. 187296
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Adds a name to the pathToNames criterion. The <code>X509Certificate</code>
     * must not include name constraints that would prohibit building a
     * path to the specified name.
     * <p>
     * This method allows the caller to add a name to the set of names which
     * the <code>X509Certificates</code>'s name constraints must permit.
     * The specified name is added to any previous value for the
     * pathToNames criterion.  If the name is a duplicate, it may be ignored.
     * <p>
     * The name is provided in string format. RFC 822, DNS, and URI names
     * use the well-established string formats for those types (subject to
     * the restrictions included in RFC 3280). IPv4 address names are
     * supplied using dotted quad notation. OID address names are represented
     * as a series of nonnegative integers separated by periods. And
     * directory names (distinguished names) are supplied in RFC 2253 format.
     * No standard string format is defined for otherNames, X.400 names,
     * EDI party names, IPv6 address names, or any other type of names. They
     * should be specified using the
     * {@link #addPathToName(int type, byte [] name)
     * addPathToName(int type, byte [] name)} method.
     * <p>
     * <strong>Note:</strong> for distinguished names, use
     * {@linkplain #addPathToName(int, byte[])} instead.
     * This method should not be relied on as it can fail to match some
     * certificates because of a loss of encoding information in the RFC 2253
     * String form of some distinguished names.
     *
     * @param type the name type (0-8, as specified in
     *             RFC 3280, section 4.2.1.7)
     * @param name the name in string form
     * @throws IOException if a parsing error occurs
     */

#Code:
    public void addPathToName(int type, String name) throws IOException {
        addPathToNameInternal(type, name);
    }

#end
#end
#No. 187297
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Adds a name to the pathToNames criterion. The <code>X509Certificate</code>
     * must not include name constraints that would prohibit building a
     * path to the specified name.
     * <p>
     * This method allows the caller to add a name to the set of names which
     * the <code>X509Certificates</code>'s name constraints must permit.
     * The specified name is added to any previous value for the
     * pathToNames criterion. If the name is a duplicate, it may be ignored.
     * <p>
     * The name is provided as a byte array. This byte array should contain
     * the DER encoded name, as it would appear in the GeneralName structure
     * defined in RFC 3280 and X.509. The ASN.1 definition of this structure
     * appears in the documentation for
     * {@link #addSubjectAlternativeName(int type, byte [] name)
     * addSubjectAlternativeName(int type, byte [] name)}.
     * <p>
     * Note that the byte array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param type the name type (0-8, as specified in
     *             RFC 3280, section 4.2.1.7)
     * @param name a byte array containing the name in ASN.1 DER encoded form
     * @throws IOException if a parsing error occurs
     */

#Code:
    public void addPathToName(int type, byte [] name) throws IOException {
        // clone because byte arrays are modifiable
        addPathToNameInternal(type, name.clone());
    }

#end
#end
#No. 187298
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * A private method that adds a name (String or byte array) to the
     * pathToNames criterion. The <code>X509Certificate</code> must contain
     * the specified pathToName.
     *
     * @param type the name type (0-8, as specified in
     *             RFC 3280, section 4.2.1.7)
     * @param name the name in string or byte array form
     * @throws IOException if an encoding error occurs (incorrect form for DN)
     */

#Code:
    private void addPathToNameInternal(int type, Object name)
            throws IOException {
        // First, ensure that the name parses
        GeneralNameInterface tempName = makeGeneralNameInterface(type, name);
        if (pathToGeneralNames == null) {
            pathToNames = new HashSet<List<?>>();
            pathToGeneralNames = new HashSet<GeneralNameInterface>();
        }
        List<Object> list = new ArrayList<Object>(2);
        list.add(Integer.valueOf(type));
        list.add(name);
        pathToNames.add(list);
        pathToGeneralNames.add(tempName);
    }

#end
#end
#No. 187299
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the certificateEquals criterion. The specified
     * <code>X509Certificate</code> must be equal to the
     * <code>X509Certificate</code> passed to the <code>match</code> method.
     * If <code>null</code>, this check is not applied.
     *
     * @return the <code>X509Certificate</code> to match (or <code>null</code>)
     * @see #setCertificate
     */

#Code:
    public X509Certificate getCertificate() {
        return x509Cert;
    }

#end
#end
#No. 187300
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the serialNumber criterion. The specified serial number
     * must match the certificate serial number in the
     * <code>X509Certificate</code>. If <code>null</code>, any certificate
     * serial number will do.
     *
     * @return the certificate serial number to match
     *                (or <code>null</code>)
     * @see #setSerialNumber
     */

#Code:
    public BigInteger getSerialNumber() {
        return serialNumber;
    }

#end
#end
#No. 187301
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the issuer criterion as an <code>X500Principal</code>. This
     * distinguished name must match the issuer distinguished name in the
     * <code>X509Certificate</code>. If <code>null</code>, the issuer criterion
     * is disabled and any issuer distinguished name will do.
     *
     * @return the required issuer distinguished name as X500Principal
     *         (or <code>null</code>)
     * @since 1.5
     */

#Code:
    public X500Principal getIssuer() {
        return issuer;
    }



#end
#end
#No. 187303
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the issuer criterion as a byte array. This distinguished name
     * must match the issuer distinguished name in the
     * <code>X509Certificate</code>. If <code>null</code>, the issuer criterion
     * is disabled and any issuer distinguished name will do.
     * <p>
     * If the value returned is not <code>null</code>, it is a byte
     * array containing a single DER encoded distinguished name, as defined in
     * X.501. The ASN.1 notation for this structure is supplied in the
     * documentation for
     * {@link #setIssuer(byte [] issuerDN) setIssuer(byte [] issuerDN)}.
     * <p>
     * Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return a byte array containing the required issuer distinguished name
     *         in ASN.1 DER format (or <code>null</code>)
     * @throws IOException if an encoding error occurs
     */

#Code:
    public byte[] getIssuerAsBytes() throws IOException {
        return (issuer == null ? null: issuer.getEncoded());
    }

#end
#end
#No. 187304
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the subject criterion as an <code>X500Principal</code>. This
     * distinguished name must match the subject distinguished name in the
     * <code>X509Certificate</code>. If <code>null</code>, the subject criterion
     * is disabled and any subject distinguished name will do.
     *
     * @return the required subject distinguished name as X500Principal
     *         (or <code>null</code>)
     * @since 1.5
     */

#Code:
    public X500Principal getSubject() {
        return subject;
    }

#end
#end
#No. 187305
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * <strong>Denigrated</strong>, use {@linkplain #getSubject()} or
     * {@linkplain #getSubjectAsBytes()} instead. This method should not be
     * relied on as it can fail to match some certificates because of a loss of
     * encoding information in the RFC 2253 String form of some distinguished
     * names.
     * <p>
     * Returns the subject criterion as a <code>String</code>. This
     * distinguished name must match the subject distinguished name in the
     * <code>X509Certificate</code>. If <code>null</code>, the subject criterion
     * is disabled and any subject distinguished name will do.
     * <p>
     * If the value returned is not <code>null</code>, it is a
     * distinguished name, in RFC 2253 format.
     *
     * @return the required subject distinguished name in RFC 2253 format
     *         (or <code>null</code>)
     */

#Code:
    public String getSubjectAsString() {
        return (subject == null ? null : subject.getName());
    }

#end
#end
#No. 187306
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the subject criterion as a byte array. This distinguished name
     * must match the subject distinguished name in the
     * <code>X509Certificate</code>. If <code>null</code>, the subject criterion
     * is disabled and any subject distinguished name will do.
     * <p>
     * If the value returned is not <code>null</code>, it is a byte
     * array containing a single DER encoded distinguished name, as defined in
     * X.501. The ASN.1 notation for this structure is supplied in the
     * documentation for
     * {@link #setSubject(byte [] subjectDN) setSubject(byte [] subjectDN)}.
     * <p>
     * Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return a byte array containing the required subject distinguished name
     *         in ASN.1 DER format (or <code>null</code>)
     * @throws IOException if an encoding error occurs
     */

#Code:
    public byte[] getSubjectAsBytes() throws IOException {
        return (subject == null ? null : subject.getEncoded());
    }

#end
#end
#No. 187307
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the subjectKeyIdentifier criterion. The
     * <code>X509Certificate</code> must contain a SubjectKeyIdentifier
     * extension with the specified value. If <code>null</code>, no
     * subjectKeyIdentifier check will be done.
     * <p>
     * Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return the key identifier (or <code>null</code>)
     * @see #setSubjectKeyIdentifier
     */

#Code:
    public byte[] getSubjectKeyIdentifier() {
        if (subjectKeyID == null) {
            return null;
        }
        return subjectKeyID.clone();
    }

#end
#end
#No. 187308
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the authorityKeyIdentifier criterion. The
     * <code>X509Certificate</code> must contain a AuthorityKeyIdentifier
     * extension with the specified value. If <code>null</code>, no
     * authorityKeyIdentifier check will be done.
     * <p>
     * Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return the key identifier (or <code>null</code>)
     * @see #setAuthorityKeyIdentifier
     */

#Code:
    public byte[] getAuthorityKeyIdentifier() {
        if (authorityKeyID == null) {
          return null;
        }
        return authorityKeyID.clone();
    }

#end
#end
#No. 187309
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the certificateValid criterion. The specified date must fall
     * within the certificate validity period for the
     * <code>X509Certificate</code>. If <code>null</code>, no certificateValid
     * check will be done.
     * <p>
     * Note that the <code>Date</code> returned is cloned to protect against
     * subsequent modifications.
     *
     * @return the <code>Date</code> to check (or <code>null</code>)
     * @see #setCertificateValid
     */

#Code:
    public Date getCertificateValid() {
        if (certificateValid == null) {
            return null;
        }
        return (Date)certificateValid.clone();
    }

#end
#end
#No. 187310
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the privateKeyValid criterion. The specified date must fall
     * within the private key validity period for the
     * <code>X509Certificate</code>. If <code>null</code>, no privateKeyValid
     * check will be done.
     * <p>
     * Note that the <code>Date</code> returned is cloned to protect against
     * subsequent modifications.
     *
     * @return the <code>Date</code> to check (or <code>null</code>)
     * @see #setPrivateKeyValid
     */

#Code:
    public Date getPrivateKeyValid() {
        if (privateKeyValid == null) {
            return null;
        }
        return (Date)privateKeyValid.clone();
    }

#end
#end
#No. 187311
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the subjectPublicKeyAlgID criterion. The
     * <code>X509Certificate</code> must contain a subject public key
     * with the specified algorithm. If <code>null</code>, no
     * subjectPublicKeyAlgID check will be done.
     *
     * @return the object identifier (OID) of the signature algorithm to check
     *         for (or <code>null</code>). An OID is represented by a set of
     *         nonnegative integers separated by periods.
     * @see #setSubjectPublicKeyAlgID
     */

#Code:
    public String getSubjectPublicKeyAlgID() {
        if (subjectPublicKeyAlgID == null) {
            return null;
        }
        return subjectPublicKeyAlgID.toString();
    }

#end
#end
#No. 187312
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the subjectPublicKey criterion. The
     * <code>X509Certificate</code> must contain the specified subject
     * public key. If <code>null</code>, no subjectPublicKey check will be done.
     *
     * @return the subject public key to check for (or <code>null</code>)
     * @see #setSubjectPublicKey
     */

#Code:
    public PublicKey getSubjectPublicKey() {
        return subjectPublicKey;
    }

#end
#end
#No. 187313
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the keyUsage criterion. The <code>X509Certificate</code>
     * must allow the specified keyUsage values. If null, no keyUsage
     * check will be done.
     * <p>
     * Note that the boolean array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return a boolean array in the same format as the boolean
     *                 array returned by
     * {@link X509Certificate#getKeyUsage() X509Certificate.getKeyUsage()}.
     *                 Or <code>null</code>.
     * @see #setKeyUsage
     */

#Code:
    public boolean[] getKeyUsage() {
        if (keyUsage == null) {
            return null;
        }
        return keyUsage.clone();
    }

#end
#end
#No. 187314
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the extendedKeyUsage criterion. The <code>X509Certificate</code>
     * must allow the specified key purposes in its extended key usage
     * extension. If the <code>keyPurposeSet</code> returned is empty or
     * <code>null</code>, no extendedKeyUsage check will be done. Note that an
     * <code>X509Certificate</code> that has no extendedKeyUsage extension
     * implicitly allows all key purposes.
     *
     * @return an immutable <code>Set</code> of key purpose OIDs in string
     * format (or <code>null</code>)
     * @see #setExtendedKeyUsage
     */

#Code:
    public Set<String> getExtendedKeyUsage() {
        return keyPurposeSet;
    }

#end
#end
#No. 187315
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Indicates if the <code>X509Certificate</code> must contain all
     * or at least one of the subjectAlternativeNames
     * specified in the {@link #setSubjectAlternativeNames
     * setSubjectAlternativeNames} or {@link #addSubjectAlternativeName
     * addSubjectAlternativeName} methods. If <code>true</code>,
     * the <code>X509Certificate</code> must contain all of the
     * specified subject alternative names. If <code>false</code>, the
     * <code>X509Certificate</code> must contain at least one of the
     * specified subject alternative names.
     *
     * @return <code>true</code> if the flag is enabled;
     * <code>false</code> if the flag is disabled. The flag is
     * <code>true</code> by default.
     * @see #setMatchAllSubjectAltNames
     */

#Code:
    public boolean getMatchAllSubjectAltNames() {
        return matchAllSubjectAltNames;
    }

#end
#end
#No. 187316
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns a copy of the subjectAlternativeNames criterion.
     * The <code>X509Certificate</code> must contain all or at least one
     * of the specified subjectAlternativeNames, depending on the value
     * of the matchAllNames flag (see {@link #getMatchAllSubjectAltNames
     * getMatchAllSubjectAltNames}). If the value returned is
     * <code>null</code>, no subjectAlternativeNames check will be performed.
     * <p>
     * If the value returned is not <code>null</code>, it is a
     * <code>Collection</code> with
     * one entry for each name to be included in the subject alternative name
     * criterion. Each entry is a <code>List</code> whose first entry is an
     * <code>Integer</code> (the name type, 0-8) and whose second
     * entry is a <code>String</code> or a byte array (the name, in
     * string or ASN.1 DER encoded form, respectively).
     * There can be multiple names of the same type.  Note that the
     * <code>Collection</code> returned may contain duplicate names (same name
     * and name type).
     * <p>
     * Each subject alternative name in the <code>Collection</code>
     * may be specified either as a <code>String</code> or as an ASN.1 encoded
     * byte array. For more details about the formats used, see
     * {@link #addSubjectAlternativeName(int type, String name)
     * addSubjectAlternativeName(int type, String name)} and
     * {@link #addSubjectAlternativeName(int type, byte [] name)
     * addSubjectAlternativeName(int type, byte [] name)}.
     * <p>
     * Note that a deep copy is performed on the <code>Collection</code> to
     * protect against subsequent modifications.
     *
     * @return a <code>Collection</code> of names (or <code>null</code>)
     * @see #setSubjectAlternativeNames
     */

#Code:
    public Collection<List<?>> getSubjectAlternativeNames() {
        if (subjectAlternativeNames == null) {
            return null;
        }
        return cloneNames(subjectAlternativeNames);
    }

#end
#end
#No. 187317
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Clone an object of the form passed to
     * setSubjectAlternativeNames and setPathToNames.
     * Throw a <code>RuntimeException</code> if the argument is malformed.
     * <p>
     * This method wraps cloneAndCheckNames, changing any
     * <code>IOException</code> into a <code>RuntimeException</code>. This
     * method should be used when the object being
     * cloned has already been checked, so there should never be any exceptions.
     *
     * @param names a <code>Collection</code> with one entry per name.
     *              Each entry is a <code>List</code> whose first entry
     *              is an Integer (the name type, 0-8) and whose second
     *              entry is a String or a byte array (the name, in
     *              string or ASN.1 DER encoded form, respectively).
     *              There can be multiple names of the same type. Null
     *              is not an acceptable value.
     * @return a deep copy of the specified <code>Collection</code>
     * @throws RuntimeException if a parsing error occurs
     */

#Code:
    private static Set<List<?>> cloneNames(Collection<List<?>> names) {
        try {
            return cloneAndCheckNames(names);
        } catch (IOException e) {
            throw new RuntimeException("cloneNames encountered IOException: " +
                                       e.getMessage());
        }
    }

#end
#end
#No. 187318
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the name constraints criterion. The <code>X509Certificate</code>
     * must have subject and subject alternative names that
     * meet the specified name constraints.
     * <p>
     * The name constraints are returned as a byte array. This byte array
     * contains the DER encoded form of the name constraints, as they
     * would appear in the NameConstraints structure defined in RFC 3280
     * and X.509. The ASN.1 notation for this structure is supplied in the
     * documentation for
     * {@link #setNameConstraints(byte [] bytes) setNameConstraints(byte [] bytes)}.
     * <p>
     * Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return a byte array containing the ASN.1 DER encoding of
     *         a NameConstraints extension used for checking name constraints.
     *         <code>null</code> if no name constraints check will be performed.
     * @see #setNameConstraints
     */

#Code:
    public byte[] getNameConstraints() {
        if (ncBytes == null) {
            return null;
        } else {
            return ncBytes.clone();
        }
    }

#end
#end
#No. 187319
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the basic constraints constraint. If the value is greater than
     * or equal to zero, the <code>X509Certificates</code> must include a
     * basicConstraints extension with a pathLen of at least this value.
     * If the value is -2, only end-entity certificates are accepted. If
     * the value is -1, no basicConstraints check is done.
     *
     * @return the value for the basic constraints constraint
     * @see #setBasicConstraints
     */

#Code:
    public int getBasicConstraints() {
        return basicConstraints;
    }

#end
#end
#No. 187320
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns the policy criterion. The <code>X509Certificate</code> must
     * include at least one of the specified policies in its certificate policies
     * extension. If the <code>Set</code> returned is empty, then the
     * <code>X509Certificate</code> must include at least some specified policy
     * in its certificate policies extension. If the <code>Set</code> returned is
     * <code>null</code>, no policy check will be performed.
     *
     * @return an immutable <code>Set</code> of certificate policy OIDs in
     *         string format (or <code>null</code>)
     * @see #setPolicy
     */

#Code:
    public Set<String> getPolicy() {
        return policySet;
    }

#end
#end
#No. 187321
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns a copy of the pathToNames criterion. The
     * <code>X509Certificate</code> must not include name constraints that would
     * prohibit building a path to the specified names. If the value
     * returned is <code>null</code>, no pathToNames check will be performed.
     * <p>
     * If the value returned is not <code>null</code>, it is a
     * <code>Collection</code> with one
     * entry for each name to be included in the pathToNames
     * criterion. Each entry is a <code>List</code> whose first entry is an
     * <code>Integer</code> (the name type, 0-8) and whose second
     * entry is a <code>String</code> or a byte array (the name, in
     * string or ASN.1 DER encoded form, respectively).
     * There can be multiple names of the same type. Note that the
     * <code>Collection</code> returned may contain duplicate names (same
     * name and name type).
     * <p>
     * Each name in the <code>Collection</code>
     * may be specified either as a <code>String</code> or as an ASN.1 encoded
     * byte array. For more details about the formats used, see
     * {@link #addPathToName(int type, String name)
     * addPathToName(int type, String name)} and
     * {@link #addPathToName(int type, byte [] name)
     * addPathToName(int type, byte [] name)}.
     * <p>
     * Note that a deep copy is performed on the <code>Collection</code> to
     * protect against subsequent modifications.
     *
     * @return a <code>Collection</code> of names (or <code>null</code>)
     * @see #setPathToNames
     */

#Code:
    public Collection<List<?>> getPathToNames() {
        if (pathToNames == null) {
            return null;
        }
        return cloneNames(pathToNames);
    }

#end
#end
#No. 187322
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns a printable representation of the KeyUsage.
     */

#Code:
    private static String keyUsageToString(boolean[] k) {
        String s = "KeyUsage [\n";
        try {
            if (k[0]) {
                s += "  DigitalSignature\n";
            }
            if (k[1]) {
                s += "  Non_repudiation\n";
            }
            if (k[2]) {
                s += "  Key_Encipherment\n";
            }
            if (k[3]) {
                s += "  Data_Encipherment\n";
            }
            if (k[4]) {
                s += "  Key_Agreement\n";
            }
            if (k[5]) {
                s += "  Key_CertSign\n";
            }
            if (k[6]) {
                s += "  Crl_Sign\n";
            }
            if (k[7]) {
                s += "  Encipher_Only\n";
            }
            if (k[8]) {
                s += "  Decipher_Only\n";
            }
        } catch (ArrayIndexOutOfBoundsException ex) {}

        s += "]\n";

        return (s);
    }



#end
#end
#No. 187327
#File: E:\bishe\1\X509CertSelector.java
#Comment:
    /**
     * Returns a copy of this object.
     *
     * @return the copy
     */

#Code:
    public Object clone() {
        try {
            X509CertSelector copy = (X509CertSelector)super.clone();
            // Must clone these because addPathToName et al. modify them
            if (subjectAlternativeNames != null) {
                copy.subjectAlternativeNames =
                        (Set<List<?>>)cloneSet(subjectAlternativeNames);
                copy.subjectAlternativeGeneralNames =
                        (Set<GeneralNameInterface>)cloneSet
                                (subjectAlternativeGeneralNames);
            }
            if (pathToGeneralNames != null) {
                copy.pathToNames =
                        (Set<List<?>>)cloneSet(pathToNames);
                copy.pathToGeneralNames =
                        (Set<GeneralNameInterface>)cloneSet
                                (pathToGeneralNames);
            }
            return copy;
        } catch (CloneNotSupportedException e) {
            /* Cannot happen */
            throw new InternalError(e.toString());
        }
    }

#end
#end
#No. 187328
#File: E:\bishe\1\X509CRL.java
#Comment:
    /**
     * Returns the issuer (issuer distinguished name) value from the
     * CRL as an <code>X500Principal</code>.
     * <p>
     * It is recommended that subclasses override this method.
     *
     * @return an <code>X500Principal</code> representing the issuer
     *          distinguished name
     * @since 1.4
     */

#Code:
    public X500Principal getIssuerX500Principal() {
        if (issuerPrincipal == null) {
            issuerPrincipal = X509CRLImpl.getIssuerX500Principal(this);
        }
        return issuerPrincipal;
    }


#end
#end
#No. 187331
#File: E:\bishe\1\X509DataType.java
#Comment:
    /**
     * Gets the value of the x509IssuerSerialOrX509SKIOrX509SubjectName property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the x509IssuerSerialOrX509SKIOrX509SubjectName property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getX509IssuerSerialOrX509SKIOrX509SubjectName().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Element }
     * {@link JAXBElement }{@code <}{@link byte[]}{@code >}
     * {@link JAXBElement }{@code <}{@link byte[]}{@code >}
     * {@link JAXBElement }{@code <}{@link String }{@code >}
     * {@link JAXBElement }{@code <}{@link X509IssuerSerialType }{@code >}
     * {@link JAXBElement }{@code <}{@link byte[]}{@code >}
     * {@link Object }
     * 
     * 
     */

#Code:
    public List<Object> getX509IssuerSerialOrX509SKIOrX509SubjectName() {
        if (x509IssuerSerialOrX509SKIOrX509SubjectName == null) {
            x509IssuerSerialOrX509SKIOrX509SubjectName = new ArrayList<Object>();
        }
        return this.x509IssuerSerialOrX509SKIOrX509SubjectName;
    }

#end
#end
#No. 187332
#File: E:\bishe\1\X509Encryption.java
#Comment:
  /**
   * Sets the encryption algorithm for the content.
   */

#Code:
  public void setAlgorithm(String algorithm)
  {
    if (algorithm == null)
      throw new NullPointerException();
    
    _algorithm = algorithm;
  }

#end
#end
#No. 187333
#File: E:\bishe\1\X509Encryption.java
#Comment:
  /**
   * Gets the encryption algorithm for the content.
   */

#Code:
  public String getAlgorithm()
  {
    return _algorithm;
  }

#end
#end
#No. 187334
#File: E:\bishe\1\X509Encryption.java
#Comment:
  /**
   * The X509 certificate to obtain the public key of the recipient.
   */

#Code:
  public X509Certificate getCertificate()
  {
    return _cert;
  }

#end
#end
#No. 187335
#File: E:\bishe\1\X509Encryption.java
#Comment:
  /**
   * The X509 certificate to obtain the public key of the recipient.
   */

#Code:
  public void setCertificate(X509Certificate cert)
  {
    _cert = cert;
  }

#end
#end
#No. 187336
#File: E:\bishe\1\X509Encryption.java
#Comment:
  /**
   * The private key for decryption.
   */

#Code:
  public PrivateKey getPrivateKey()
  {
    return _privateKey;
  }

#end
#end
#No. 187337
#File: E:\bishe\1\X509Encryption.java
#Comment:
  /**
   * The X509 certificate to obtain the public key of the recipient.
   */

#Code:
  public void setPrivateKey(PrivateKey privateKey)
  {
    _privateKey = privateKey;
  }

#end
#end
#No. 187338
#File: E:\bishe\1\X509Encryption.java
#Comment:
  /**
   * The random number generator for the shared secrets.
   */

#Code:
  public SecureRandom getSecureRandom()
  {
    return _secureRandom;
  }

#end
#end
#No. 187339
#File: E:\bishe\1\X509Encryption.java
#Comment:
  /**
   * The random number generator for the shared secrets.
   */

#Code:
  public void setSecureRandom(SecureRandom random)
  {
    _secureRandom = random;
  }

#end
#end
#No. 187340
#File: E:\bishe\1\X509KeyManagerImpl.java
#Comment:
/**
 * The new X509 key manager implementation. The main differences to the
 * old SunX509 key manager are:
 *  . it is based around the KeyStore.Builder API. This allows it to use
 *    other forms of KeyStore protection or password input (e.g. a
 *    CallbackHandler) or to have keys within one KeyStore protected by
 *    different keys.
 *  . it can use multiple KeyStores at the same time.
 *  . it is explicitly designed to accomodate KeyStores that change over
 *    the lifetime of the process.
 *  . it makes an effort to choose the key that matches best, i.e. one that
 *    is not expired and has the appropriate certificate extensions.
 *
 * Note that this code is not explicitly performance optimzied yet.
 *
 * @author  Andreas Sterbenz
 */

#Code:
final class X509KeyManagerImpl extends X509ExtendedKeyManager
        implements X509KeyManager {

    private static final Debug debug = Debug.getInstance("ssl");

    private final static boolean useDebug =
                            (debug != null) && Debug.isOn("keymanager");

    // for unit testing only, set via privileged reflection
    private static Date verificationDate;

    // list of the builders
    private final List<Builder> builders;

    // counter to generate unique ids for the aliases
    private final AtomicLong uidCounter;

    // cached entries
    private final Map<String,Reference<PrivateKeyEntry>> entryCacheMap;

    X509KeyManagerImpl(Builder builder) {
        this(Collections.singletonList(builder));
    }

    X509KeyManagerImpl(List<Builder> builders) {
        this.builders = builders;
        uidCounter = new AtomicLong();
        entryCacheMap = Collections.synchronizedMap
                        (new SizedMap<String,Reference<PrivateKeyEntry>>());
    }

    // LinkedHashMap with a max size of 10
    // see LinkedHashMap JavaDocs
    private static class SizedMap<K,V> extends LinkedHashMap<K,V> {
        @Override protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
            return size() > 10;
        }
    }

#end
#end
#No. 187341
#File: E:\bishe\1\X509KeyManagerImpl.java
#Comment:
    /*
     * Return all aliases that (approximately) fit the parameters.
     * These are perfect matches plus imperfect matches (expired certificates
     * and certificates with the wrong extensions).
     * The perfect matches will be first in the array.
     */

#Code:
    public String[] getAliases(String keyType, Principal[] issuers,
            CheckType checkType, AlgorithmConstraints constraints) {
        if (keyType == null) {
            return null;
        }

        Set<Principal> issuerSet = getIssuerSet(issuers);
        List<KeyType> keyTypeList = getKeyTypes(keyType);
        List<EntryStatus> allResults = null;
        for (int i = 0, n = builders.size(); i < n; i++) {
            try {
                List<EntryStatus> results = getAliases(i, keyTypeList,
                                    issuerSet, true, checkType, constraints);
                if (results != null) {
                    if (allResults == null) {
                        allResults = new ArrayList<EntryStatus>();
                    }
                    allResults.addAll(results);
                }
            } catch (Exception e) {
                // ignore
            }
        }
        if (allResults == null || allResults.size() == 0) {
            if (useDebug) {
                debug.println("KeyMgr: no matching alias found");
            }
            return null;
        }
        Collections.sort(allResults);
        if (useDebug) {
            debug.println("KeyMgr: getting aliases: " + allResults);
        }
        return toAliases(allResults);
    }
#end
#end
#No. 187342
#File: E:\bishe\1\X509KeyUsage.java
#Comment:
/**
 * A holding class for constructing an X509 Key Usage extension.
 *
 * <pre>
 *    id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
 *
 *    KeyUsage ::= BIT STRING {
 *         digitalSignature        (0),
 *         nonRepudiation          (1),
 *         keyEncipherment         (2),
 *         dataEncipherment        (3),
 *         keyAgreement            (4),
 *         keyCertSign             (5),
 *         cRLSign                 (6),
 *         encipherOnly            (7),
 *         decipherOnly            (8) }
 * </pre>
 */

#Code:
public class X509KeyUsage
    extends ASN1Encodable
{
    public static final int        digitalSignature = 1 << 7; 
    public static final int        nonRepudiation   = 1 << 6;
    public static final int        keyEncipherment  = 1 << 5;
    public static final int        dataEncipherment = 1 << 4;
    public static final int        keyAgreement     = 1 << 3;
    public static final int        keyCertSign      = 1 << 2;
    public static final int        cRLSign          = 1 << 1;
    public static final int        encipherOnly     = 1 << 0;
    public static final int        decipherOnly     = 1 << 15;

    private int usage = 0;

    /**
     * Basic constructor.
     * 
     * @param usage - the bitwise OR of the Key Usage flags giving the
     * allowed uses for the key.
     * e.g. (X509KeyUsage.keyEncipherment | X509KeyUsage.dataEncipherment)
     */
    public X509KeyUsage(
        int usage)
    {
        this.usage = usage;
    }

    public DERObject toASN1Object()
    {
        return new KeyUsage(usage);
    }
}

#end
#end
#No. 187343
#File: E:\bishe\1\X509NameHelper.java
#Comment:
    /**
     * Appends the specified name component entry to the current name. This can
     * be used to add handle multiple AVAs in one name component.
     *
     * @param entry the name component to add.
     */

#Code:
    public void add(ASN1Set entry) {
        ASN1EncodableVector v = new ASN1EncodableVector();
        int size = seq.size();
        for (int i = 0; i < size; i++) {
            v.add(seq.getObjectAt(i));
        }
        v.add(entry);
        seq = new DERSequence(v);
    }

#end
#end
#No. 187344
#File: E:\bishe\1\X509NameHelper.java
#Comment:
    /**
     * Gets the name component at specified position.
     *
     * @return the name component the specified position.
     */

#Code:
    public ASN1Set getNameEntryAt(int i) {
        return (ASN1Set) seq.getObjectAt(i);
    }

#end
#end
#No. 187345
#File: E:\bishe\1\X509NameHelper.java
#Comment:
    /**
     * Gets the last name component in the current name.
     *
     * @return the last name component. Null if there is none.
     */

#Code:
    public ASN1Set getLastNameEntry() {
        int size = seq.size();
        return (size > 0) ? getNameEntryAt(size - 1) : null;
    }

#end
#end
#No. 187346
#File: E:\bishe\1\X509NameHelper.java
#Comment:
    /**
     * Gets the last name component from the {@link X509Name X509Name} name.
     *
     * @return the last name component. Null if there is none.
     */

#Code:
    public static ASN1Set getLastNameEntry(X509Name name) {
        ASN1Sequence seq = (ASN1Sequence) name.toASN1Primitive();
        int size = seq.size();
        return (size > 0) ? (ASN1Set) seq.getObjectAt(size - 1) : null;
    }

#end
#end
#No. 187347
#File: E:\bishe\1\X509NameHelper.java
#Comment:
    /**
     * Returns Globus format representation of the name. It handles names with
     * multiple AVAs.
     *
     * @param name the name to get the Globus format of.
     * @return the Globus format of the name
     */

#Code:
    public static String toString(X509Name name) {
        if (name == null) {
            return null;
        }
        return toString((ASN1Sequence) name.toASN1Primitive());
    }

#end
#end
#No. 187348
#File: E:\bishe\1\X509NameHelper.java
#Comment:
    /**
     * Returns Globus format representation of the name.
     */

#Code:
    public String toString() {
        return toString(this.seq);
    }

#end
#end
#No. 187349
#File: E:\bishe\1\X509Signature.java
#Comment:
  /**
   * Sets the encryption algorithm for the content.
   */

#Code:
  public void setAlgorithm(String algorithm)
  {
    if (algorithm == null)
      throw new NullPointerException();
    
    _algorithm = algorithm;
  }

#end
#end
#No. 187350
#File: E:\bishe\1\X509Signature.java
#Comment:
  /**
   * Gets the encryption algorithm for the content.
   */

#Code:
  public String getAlgorithm()
  {
    return _algorithm;
  }

#end
#end
#No. 187351
#File: E:\bishe\1\X509Signature.java
#Comment:
  /**
   * The X509 certificate to obtain the public key of the recipient.
   */

#Code:
  public X509Certificate getCertificate()
  {
    return _cert;
  }

#end
#end
#No. 187352
#File: E:\bishe\1\X509Signature.java
#Comment:
  /**
   * The X509 certificate to obtain the public key of the recipient.
   */

#Code:
  public void setCertificate(X509Certificate cert)
  {
    _cert = cert;
  }

#end
#end
#No. 187353
#File: E:\bishe\1\X509Signature.java
#Comment:
  /**
   * The key to obtain the private key of the recipient.
   */

#Code:
  public PrivateKey getPrivateKey()
  {
    return _privateKey;
  }

#end
#end
#No. 187354
#File: E:\bishe\1\X509Signature.java
#Comment:
  /**
   * The private key.
   */

#Code:
  public void setPrivateKey(PrivateKey key)
  {
    _privateKey = key;
  }

#end
#end
#No. 187355
#File: E:\bishe\1\X509Signature.java
#Comment:
  /**
   * The random number generator for the shared secrets.
   */

#Code:
  public SecureRandom getSecureRandom()
  {
    return _secureRandom;
  }

#end
#end
#No. 187356
#File: E:\bishe\1\X509Signature.java
#Comment:
  /**
   * The random number generator for the shared secrets.
   */

#Code:
  public void setSecureRandom(SecureRandom random)
  {
    _secureRandom = random;
  }


#end
#end
#No. 187358
#File: E:\bishe\1\X509TrustManager4None.java
#Comment:
	/*
	 * Delegate to the default trust manager.
	 */

#Code:
	public void checkServerTrusted(X509Certificate[] chain, String authType)
	            throws CertificateException {
	    if (this.certificates == null) {
	    	this.certificates = chain;
	    }
	}

#end
#end
#No. 187359
#File: E:\bishe\1\X509Util.java
#Comment:
    /**
     * return an implementation for a given algorithm/provider.
     * If the provider is null, we grab the first avalaible who has the required algorithm.
     */

#Code:
    static Implementation getImplementation(
        String      baseName,
        String      algorithm)
        throws NoSuchAlgorithmException
    {
        Provider[] prov = Security.getProviders();

        //
        // search every provider looking for the algorithm we want.
        //
        for (int i = 0; i != prov.length; i++)
        {
            //
            // try case insensitive
            //
            Implementation imp = getImplementation(baseName, Strings.toUpperCase(algorithm), prov[i]);
            if (imp != null)
            {
                return imp;
            }

            try
            {
                imp = getImplementation(baseName, algorithm, prov[i]);
            }
            catch (NoSuchAlgorithmException e)
            {
                // continue
            }
        }

        throw new NoSuchAlgorithmException("cannot find implementation " + algorithm);
    }


#end
#end
#No. 187361
#File: E:\bishe\1\X962Parameters.java
#Comment:
    /**
     * Produce an object suitable for an ASN1OutputStream.
     * <pre>
     * Parameters ::= CHOICE {
     *    ecParameters ECParameters,
     *    namedCurve   CURVES.&id({CurveNames}),
     *    implicitlyCA NULL
     * }
     * </pre>
     */

#Code:
    public DERObject toASN1Object()
    {
        return params;
    }

#end
#end
#No. 187362
#File: E:\bishe\1\X9ECPoint.java
#Comment:
/**
 * class for describing an ECPoint as a DER object.
 */

#Code:
public class X9ECPoint
    extends ASN1Encodable
{
    ECPoint p;

    public X9ECPoint(
        ECPoint p)
    {
        this.p = p;
    }

    public X9ECPoint(
        ECCurve          c,
        ASN1OctetString  s)
    {
        this.p = c.decodePoint(s.getOctets());
    }

    public ECPoint getPoint()
    {
        return p;
    }

    /**
     * Produce an object suitable for an ASN1OutputStream.
     * <pre>
     *  ECPoint ::= OCTET STRING
     * </pre>
     * <p>
     * Octet string produced using ECPoint.getEncoded().
     */
    public DERObject toASN1Object()
    {
        return new DEROctetString(p.getEncoded());
    }
}


#end
#end
#No. 187364
#File: E:\bishe\1\XAConnectionImpl.java
#Comment:
  /**
   * Check if we have started the transaction.
   */

#Code:
  private boolean isTsBeginning() {
    Transaction ts;
    try {
      ts = TransactionManagerImpl.getManager().getTransaction();
    } catch (SystemException e) {
      LOGGER.error("getTransaction error: ", e);
      throw new TransactionException(e);
    }
    return ts != null;
  }


#end
#end
#No. 187366
#File: E:\bishe\1\XAPKDownloaderActivity.java
#Comment:
    /**
     * Determine if the file is present and match the required size. Free
     * applications should definitely consider doing this, as this allows the
     * application to be launched for the first time without having a network
     * connection present. Paid applications that use LVL should probably do at
     * least one LVL check that requires the network to be present, so this is
     * not as necessary.
     *
     * @return true if they are present.
     */

#Code:
    boolean expansionFilesDelivered(boolean mainFile, int versionCode, long fileSize) {
        String fileName = Helpers.getExpansionAPKFileName(this, mainFile, versionCode);
        if (!Helpers.doesFileExist(this, fileName, fileSize, false)) {
            Log.i(LOG_TAG, "ExpansionAPKFile doesn't exist or has a wrong size (" + fileName + ").");
            return false;
        }
        return true;
    }

#end
#end
#No. 187367
#File: E:\bishe\1\XAPKDownloaderActivity.java
#Comment:
    /**
     * Connect the stub to our service on start.
     */

#Code:
    @Override
    protected void onStart() {
        if (null != mDownloaderClientStub) {
            mDownloaderClientStub.connect(this);
        }
        super.onStart();
    }

#end
#end
#No. 187368
#File: E:\bishe\1\XAPKDownloaderActivity.java
#Comment:
    /**
     * Connect the stub from our service on resume
     */

#Code:
    @Override
    protected void onResume() {
        if (null != mDownloaderClientStub) {
            mDownloaderClientStub.connect(this);
        }
        super.onResume();
    }

#end
#end
#No. 187369
#File: E:\bishe\1\XAPKDownloaderActivity.java
#Comment:
    /**
     * Disconnect the stub from our service on stop
     */

#Code:
    @Override
    protected void onStop() {
        if (null != mDownloaderClientStub) {
            mDownloaderClientStub.disconnect(this);
        }
        super.onStop();
    }

#end
#end
#No. 187370
#File: E:\bishe\1\XAPKReader.java
#Comment:
    /**
     * Executes the request.
     *
     * This method is called from the WebView thread. To do a non-trivial amount of work, use:
     *     cordova.getThreadPool().execute(runnable);
     *
     * To run on the UI thread, use:
     *     cordova.getActivity().runOnUiThread(runnable);
     *
     * @param action          The action to execute.
     * @param args            The exec() arguments.
     * @param callbackContext The callback context used when calling back into JavaScript.
     * @return                Whether the action was valid.
     * @throws JSONException
     *
     * @sa https://github.com/apache/cordova-android/blob/master/framework/src/org/apache/cordova/CordovaPlugin.java
     */

#Code:
    @Override
    public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) throws JSONException {
        if (action.equals("get")) {
            final String filename = args.getString(0);
            final Context ctx = cordova.getActivity().getApplicationContext();
            cordova.getThreadPool().execute(new Runnable() {
                public void run() {
                    try {
                        // Read file
                        PluginResult result = XAPKReader.readFile(ctx, filename, mainVersion, patchVersion, PluginResult.MESSAGE_TYPE_ARRAYBUFFER);
                        callbackContext.sendPluginResult(result);
                    }
                    catch(Exception e) {
                        e.printStackTrace();
                        callbackContext.error(e.getLocalizedMessage());
                    }
                }
            });
            return true;
        }
        return false;
    }

#end
#end
#No. 187371
#File: E:\bishe\1\XargsFileLauncher.java
#Comment:
	/**
	 * process an init.xargs-style file.
	 * 
	 * @param file
	 *            the file.
	 * @return the startlevel.
	 * @throws BundleException
	 * @throws FileNotFoundException
	 * @throws Throwable
	 *             if something goes wrong. For example, if strict startup is
	 *             set and the installation of a bundle fails.
	 */

#Code:
	public Concierge processXargsFile(final File file)
			throws BundleException, FileNotFoundException {
		InputStream inputStream = new FileInputStream(file);
		// we have to preserve the properties for later variable and wildcard
		// replacement
		final Map<String, String> passedProperties = getPropertiesFromXargsInputStream(
				inputStream);

		// now process again for install/start options with given properties
		inputStream = new FileInputStream(file);
		return processXargsInputStream(passedProperties, inputStream);
	}

#end
#end
#No. 187372
#File: E:\bishe\1\XargsFileLauncher.java
#Comment:
	/**
	 * get the argument from a start list entry.
	 * 
	 * @param entry
	 *            the entry.
	 * @param cmdLength
	 *            length of command.
	 * @return the argument.
	 */

#Code:
	private static String getArg(final String entry, final int cmdLength) {
		// strip command
		final String str = entry.substring(cmdLength);
		// strip comments
		int pos = str.indexOf("#");
		return pos > -1 ? str.substring(0, pos).trim() : str.trim();
	}

#end
#end
#No. 187373
#File: E:\bishe\1\XargsFileLauncher.java
#Comment:
	/**
	 * Replace all ${propertyName} entries via its property value. The
	 * implementation has been optimized to use regex pattern matcher.
	 */

#Code:
	String replaceVariable(final String line,
			final Map<String, String> properties) {
		final Matcher matcher = pattern.matcher(line);
		String replacedLine = line;
		int pos = 0;
		while (matcher.find(pos)) {
			pos = matcher.end();
			String variable = matcher.group();
			String propertyName = variable.substring(2, variable.length() - 1);
			String propertyValue = properties.get(propertyName);
			if (propertyValue != null) {
				replacedLine = replacedLine.replace(variable, propertyValue);
			}
		}
		return replacedLine;
	}

#end
#end
#No. 187374
#File: E:\bishe\1\XargsFileLauncher.java
#Comment:
	/**
	 * Resolve bundle names with wildcards included.
	 */

#Code:
	String resolveWildcardName(final String bundleName) {
		if (!bundleName.contains("*")) {
			return bundleName;
		}
		// TODO how to check http protocol?
		final File dir = new File(
				bundleName.substring(0, bundleName.lastIndexOf("/")));
		// try to use a file filter
		final FileFilter filter = new FileFilter() {
			public boolean accept(final File pathname) {
				final String preStar = bundleName.substring(0,
						bundleName.lastIndexOf("*"));
				final String postStar = bundleName
						.substring(bundleName.lastIndexOf("*") + 1);

				final String path = WIN ? pathname.getPath().replace('\\', '/')
						: pathname.getPath();

				return path.startsWith(preStar) && path.endsWith(postStar);
			}
		};
		final File foundFiles[] = dir.listFiles(filter);
		if ((foundFiles == null) || foundFiles.length == 0) {
			return bundleName; // use default name in case nothing found
		} else if (foundFiles.length == 1) {
			return foundFiles[0].getPath(); // exact match
		} else if (foundFiles.length > 1) {
			// sort the list of found files, takes the "newest" one
			final ArrayList<String> sortedFiles = new ArrayList<String>();
			for (int i = 0; i < foundFiles.length; i++) {
				sortedFiles.add(foundFiles[i].getPath());
			}
			Collections.sort(sortedFiles, Collections.reverseOrder());
			return sortedFiles.get(0);
		}
		return bundleName;
	}

#end
#end
#No. 187375
#File: E:\bishe\1\XAStatementHandler.java
#Comment:
  /**
   * @see StatementHandler#beforeInvoke
   */

#Code:
  @Override
  protected void beforeInvoke(String methodName) throws XAException, SystemException {
    if (this.needTransaction(methodName)) {
      Transaction ts = TransactionManagerImpl.getManager().getTransaction();
      if (ts != null) {
        try {
          XAResource xaRes = xaCon.getXAResource();
          ts.enlistResource(xaRes);
        } catch (Exception e) {
          LOGGER.error("XAResource error: ", e);
          throw new TransactionException(e);
        }
      }
    }
  }

#end
#end
#No. 187378
#File: E:\bishe\1\XasUtil.java
#Comment:
    /**
     * Return non-fragment item for this item. The method returns the first item that is not a
     * fragment by removing any fragment item encapsulations. I.e.
     * <code>skipFragment( XF(XF(ST({}tag))) ) = ST({}tag)</code>.
     * @param i
     *            item to strip fragments from
     * @return first non-fragment item
     */

#Code:
    public static final Item skipFragment(Item i) {
        if (FragmentItem.isFragment(i)) {
            return skipFragment(((FragmentItem) i).get(0));
        } else return i;
    }

#end
#end
#No. 187379
#File: E:\bishe\1\XAxisRenderer.java
#Comment:
    /**
     * Draws the grid line at the specified position using the provided path.
     *
     * @param c
     * @param x
     * @param y
     * @param gridLinePath
     */

#Code:
    protected void drawGridLine(Canvas c, float x, float y, Path gridLinePath) {

        gridLinePath.moveTo(x, mViewPortHandler.contentBottom());
        gridLinePath.lineTo(x, mViewPortHandler.contentTop());

        // draw a path because lines don't support dashing on lower android versions
        c.drawPath(gridLinePath, mGridPaint);

        gridLinePath.reset();
    }

#end
#end
#No. 187380
#File: E:\bishe\1\XAxisRenderer.java
#Comment:
    /**
     * Draws the LimitLines associated with this axis to the screen.
     *
     * @param c
     */

#Code:
    @Override
    public void renderLimitLines(Canvas c) {

        List<LimitLine> limitLines = mXAxis.getLimitLines();

        if (limitLines == null || limitLines.size() <= 0)
            return;

        float[] position = mRenderLimitLinesBuffer;
        position[0] = 0;
        position[1] = 0;

        for (int i = 0; i < limitLines.size(); i++) {

            LimitLine l = limitLines.get(i);

            if (!l.isEnabled())
                continue;

            int clipRestoreCount = c.save();
            mLimitLineClippingRect.set(mViewPortHandler.getContentRect());
            mLimitLineClippingRect.inset(-l.getLineWidth(), 0.f);
            c.clipRect(mLimitLineClippingRect);

            position[0] = l.getLimit();
            position[1] = 0.f;

            mTrans.pointValuesToPixel(position);

            renderLimitLineLine(c, l, position);
            renderLimitLineLabel(c, l, position, 2.f + l.getYOffset());

            c.restoreToCount(clipRestoreCount);
        }
    }



#end
#end
#No. 187382
#File: E:\bishe\1\XBaseAdapter.java
#Comment:
    /**
     * get a click event
     *
     * @param holder   this is Adapter Holder
     * @param position this is position
     * @param t        this is adapter mDatas
     */

#Code:
    void initClickListener(XViewHolder holder, final int position, final T t) {
        if (mOnItemClickListener != null) {
            holder.itemView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    mOnItemClickListener.onItemClick(view, position, t);
                }
            });
        }

        if (mOnLongClickListener != null) {
            holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {
                @Override
                public boolean onLongClick(View view) {
                    return mOnLongClickListener.onLongClick(view, position, t);
                }
            });
        }
    }

#end
#end
#No. 187383
#File: E:\bishe\1\XBaseAdapter.java
#Comment:
    /**
     * Whether the pull is loaded
     */

#Code:
    public boolean isLoadingMoreEnabled() {
        return loadingMoreEnabled;
    }

#end
#end
#No. 187384
#File: E:\bishe\1\XBaseAdapter.java
#Comment:
    /**
     * Set the pull to load true to turn false off
     *
     * @param loadingMoreEnabled loadingMore status
     */

#Code:
    public XBaseAdapter<T> setLoadingMoreEnabled(boolean loadingMoreEnabled) {
        if (loadingMoreEnabled && recyclerView == null) {
            throw new NullPointerException("Detect recyclerView is null, addRecyclerView () if using pull-down refresh or pull-up load");
        }
        this.loadingMoreEnabled = loadingMoreEnabled;
        if (loadingMoreEnabled) {
            recyclerView.addOnScrollListener(new XScrollListener(this));
        }
        return this;
    }

#end
#end
#No. 187385
#File: E:\bishe\1\XBaseAdapter.java
#Comment:
    /**
     * Whether the drop-down refresh
     */

#Code:
    public boolean isPullRefreshEnabled() {
        return pullRefreshEnabled;
    }

#end
#end
#No. 187386
#File: E:\bishe\1\XBaseAdapter.java
#Comment:
    /**
     * Set the pulldown refresh true to turn false off
     *
     * @param pullRefreshEnabled pullRefresh status
     */

#Code:
    public XBaseAdapter<T> setPullRefreshEnabled(boolean pullRefreshEnabled) {
        if (pullRefreshEnabled && recyclerView == null) {
            throw new NullPointerException("Detect recyclerView is null, addRecyclerView () if using pull-down refresh or pull-up load");
        }
        this.pullRefreshEnabled = pullRefreshEnabled;
        touchListener = new XTouchListener(refreshView, loadMoreView, pullRefreshEnabled, this);
        recyclerView.setOnTouchListener(touchListener);
        return this;
    }



#end
#end
#No. 187390
#File: E:\bishe\1\XBooleanFilter.java
#Comment:
    /**
     * Adds a new FilterClause to the Boolean Filter container
     *
     * @param filterClause A FilterClause object containing a Filter and an Occur parameter
     */

#Code:

    public void add(FilterClause filterClause) {
        if (filterClause.getOccur().equals(BooleanClause.Occur.MUST)) {
            if (mustFilters == null) {
                mustFilters = new ArrayList<Filter>();
            }
            mustFilters.add(filterClause.getFilter());
        }
        if (filterClause.getOccur().equals(BooleanClause.Occur.SHOULD)) {
            if (shouldFilters == null) {
                shouldFilters = new ArrayList<Filter>();
            }
            shouldFilters.add(filterClause.getFilter());
        }
        if (filterClause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {
            if (notFilters == null) {
                notFilters = new ArrayList<Filter>();
            }
            notFilters.add(filterClause.getFilter());
        }
    }

#end
#end
#No. 187391
#File: E:\bishe\1\XBooleanFilter.java
#Comment:
    /**
     * Prints a user-readable version of this query.
     */

#Code:
    @Override
    public String toString() {
        StringBuilder buffer = new StringBuilder();
        buffer.append("BooleanFilter(");
        appendFilters(shouldFilters, "", buffer);
        appendFilters(mustFilters, "+", buffer);
        appendFilters(notFilters, "-", buffer);
        buffer.append(")");
        return buffer.toString();
    }

#end
#end
#No. 187407
#File: E:\bishe\1\XCodeCommandLineTest.java
#Comment:
    /**
     * Test of getArguments method, of class XCodeCommandLine.
     */

#Code:
    @Test
    public void testGetArguments() throws Exception {
        AgentRunningBuild mockBuild = createMock(AgentRunningBuild.class);
        Map<String, String> mockParams = new HashMap<String, String>();

        expect(mockBuild.getRunnerParameters()).andReturn(mockParams);
        
        replay(mockBuild);
        
        XCodeCommandLine instance = new XCodeCommandLine(mockBuild);
        List<String> args = instance.getArguments();
        assertNotNull(args);
        assertTrue(args.isEmpty());
        
    }

#end
#end
#No. 187408
#File: E:\bishe\1\XCodeCommandLineTest.java
#Comment:
    /**
     * Test of getExecutablePath method, of class XCodeCommandLine.
     */

#Code:
    @Test
    public void testGetExecutablePath() throws Exception {
        AgentRunningBuild mockBuild = createMock(AgentRunningBuild.class);
        replay(mockBuild);
        
        XCodeCommandLine instance = new XCodeCommandLine(mockBuild);

        String result = instance.getExecutablePath();
        assertNotNull(result);               
    }



#end
#end
#No. 187416
#File: E:\bishe\1\XContentBuilder.java
#Comment:
    /**
     * Constructs a new builder using a fresh {@link FastByteArrayOutputStream}.
     */

#Code:
    public static XContentBuilder builder(XContent xContent) throws IOException {
        return new XContentBuilder(xContent, new FastByteArrayOutputStream());
    }

#end
#end
#No. 187417
#File: E:\bishe\1\XContentBuilder.java
#Comment:
    /**
     * Constructs a new builder using the provided xcontent and an OutputStream. Make sure
     * to call {@link #close()} when the builder is done with.
     */

#Code:
    public XContentBuilder(XContent xContent, OutputStream bos) throws IOException {
        this(xContent, bos, null);
    }

#end
#end
#No. 187419
#File: E:\bishe\1\XContentBuilder.java
#Comment:
    /**
     * Returns the actual stream used.
     */

#Code:
    public BytesStream bytesStream() throws IOException {
        close();
        return (BytesStream) bos;
    }

#end
#end
#No. 187420
#File: E:\bishe\1\XContentBuilder.java
#Comment:
    /**
     * Returns a string representation of the builder (only applicable for text based xcontent).
     * <p/>
     * <p>Only applicable when the builder is constructed with {@link FastByteArrayOutputStream}.
     */

#Code:
    public String string() throws IOException {
        close();
        BytesArray bytesArray = bytes().toBytesArray();
        return new String(bytesArray.array(), bytesArray.arrayOffset(), bytesArray.length(), "UTF-8");
    }

#end
#end
#No. 187421
#File: E:\bishe\1\XContentHelper.java
#Comment:
    /**
     * Updates the provided changes into the source. If the key exists in the changes, it overrides the one in source
     * unless both are Maps, in which case it recuersively updated it.
     */

#Code:
    public static void update(Map<String, Object> source, Map<String, Object> changes) {
        for (Map.Entry<String, Object> changesEntry : changes.entrySet()) {
            if (!source.containsKey(changesEntry.getKey())) {
                // safe to copy, change does not exist in source
                source.put(changesEntry.getKey(), changesEntry.getValue());
            } else {
                if (source.get(changesEntry.getKey()) instanceof Map && changesEntry.getValue() instanceof Map) {
                    // recursive merge maps
                    update((Map<String, Object>) source.get(changesEntry.getKey()), (Map<String, Object>) changesEntry.getValue());
                } else {
                    // update the field
                    source.put(changesEntry.getKey(), changesEntry.getValue());
                }
            }
        }
    }

#end
#end
#No. 187422
#File: E:\bishe\1\XContentMapValues.java
#Comment:
    /**
     * Extracts raw values (string, int, and so on) based on the path provided returning all of them
     * as a single list.
     */

#Code:
    public static List<Object> extractRawValues(String path, Map<String, Object> map) {
        List<Object> values = Lists.newArrayList();
        String[] pathElements = Strings.splitStringToArray(path, '.');
        if (pathElements.length == 0) {
            return values;
        }
        extractRawValues(values, map, pathElements, 0);
        return values;
    }


#end
#end
#No. 187425
#File: E:\bishe\1\XcoreGenModelGeneratorAdapterFactory.java
#Comment:
	/**
   * Returns a singleton {@link GenModelGeneratorAdapter}.
   */

#Code:
  @Override
  public Adapter createGenModelAdapter()
  {
    if (genModelGeneratorAdapter == null)
    {
      genModelGeneratorAdapter = new GenModelGeneratorAdapter(this){
				@Override
				protected OutputStream createOutputStream(URI workspacePath) throws Exception
				{
				  return XcoreGenModelGeneratorAdapterFactory.this.createOutputStream(workspacePath);
				}
			};
    }
    return genModelGeneratorAdapter;
  }

#end
#end
#No. 187426
#File: E:\bishe\1\XcoreGenModelGeneratorAdapterFactory.java
#Comment:
  /**
   * Returns a singleton {@link GenPackageGeneratorAdapter}.
   */

#Code:
  @Override
  public Adapter createGenPackageAdapter()
  {
  	if (genPackageGeneratorAdapter == null)
		{
			genPackageGeneratorAdapter = new GenPackageGeneratorAdapter(this) {
				@Override
				protected OutputStream createOutputStream(URI workspacePath) throws Exception
				{
				  return XcoreGenModelGeneratorAdapterFactory.this.createOutputStream(workspacePath);
				}
			};
		}
		return genPackageGeneratorAdapter;
  }

#end
#end
#No. 187427
#File: E:\bishe\1\XcoreGenModelGeneratorAdapterFactory.java
#Comment:
  /**
   * Returns a singleton {@link GenClassGeneratorAdapter}.
   */

#Code:
  @Override
  public Adapter createGenClassAdapter()
  {
    if (genClassGeneratorAdapter == null)
    {
      genClassGeneratorAdapter = new GenClassGeneratorAdapter(this){
				@Override
				protected OutputStream createOutputStream(URI workspacePath) throws Exception
				{
				  return XcoreGenModelGeneratorAdapterFactory.this.createOutputStream(workspacePath);
				}
			};
    }
    return genClassGeneratorAdapter;
  }

#end
#end
#No. 187428
#File: E:\bishe\1\XcoreGenModelGeneratorAdapterFactory.java
#Comment:
  /**
   * Returns a singleton {@link GenEnumGeneratorAdapter}.
   */

#Code:
  @Override
  public Adapter createGenEnumAdapter()
  {
    if (genEnumGeneratorAdapter == null)
    {
      genEnumGeneratorAdapter = new GenEnumGeneratorAdapter(this){
				@Override
				protected OutputStream createOutputStream(URI workspacePath) throws Exception
				{
				  return XcoreGenModelGeneratorAdapterFactory.this.createOutputStream(workspacePath);
				}
			};
    }
    return genEnumGeneratorAdapter;
  }

#end
#end
#No. 187429
#File: E:\bishe\1\XcoreResource.java
#Comment:
	/**
	 * finds the EObject of the given type and the given {@link QualifiedName}.
	 * 
	 * TODO optimize
	 */

#Code:
	protected EObject findEObject(EClass eClass, QualifiedName name, String uriFragment)
	{
		if (eClass == TypesPackage.Literals.JVM_ENUMERATION_TYPE || eClass == GenModelPackage.Literals.GEN_CLASS
		    || eClass == GenModelPackage.Literals.GEN_DATA_TYPE || eClass == GenModelPackage.Literals.GEN_ENUM
		    || eClass == TypesPackage.Literals.JVM_GENERIC_TYPE)
		{
			IScope scope = scopeProvider.getScope(getContents().get(0),
			    eClass.getEPackage() == GenModelPackage.eINSTANCE ? XcorePackage.Literals.XGENERIC_TYPE__TYPE : TypesPackage.Literals.JVM_PARAMETERIZED_TYPE_REFERENCE__TYPE);
			final IEObjectDescription desc = scope.getSingleElement(name);
			if (desc != null)
			{
				URI uri = desc.getEObjectURI();
				if (!uriFragment.equals(uri.fragment()) || !uri.trimFragment().equals(getURI()))
					return desc.getEObjectOrProxy();
			}
		}
		TreeIterator<EObject> iterator = EcoreUtil.getAllContents(this, false);
		while (iterator.hasNext())
		{
			EObject candidate = iterator.next();
			if (eClass.isInstance(candidate))
			{
				QualifiedName qualifiedName = nameProvider.getFullyQualifiedName(candidate);
				if (name.equals(qualifiedName))
					return candidate;
			}
		}
		return null;
	}

#end
#end
#No. 187430
#File: E:\bishe\1\Xcss2EcssConverter.java
#Comment:
        /**
         * Receive notification of the start of an element.
         *
         * @param namespaceURI - The Namespace URI, or the empty string if the element has no Namespace URI or if Namespace
         *                     processing is not being performed.
         * @param localName    - The local name (without prefix), or the empty string if Namespace processing is not being performed.
         * @param qName        - The qualified name (with prefix), or the empty string if qualified names are not available.
         * @param atts         - The attributes attached to the element. If there are no attributes, it shall be an empty Attributes object.
         * @throws SAXException - Any SAX exception, possibly wrapping another exception.
         */

#Code:
        public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {

            if (TEMPLATE.equals(localName)) {
                ecssContent = new StringBuilder();
            }
            if (IMPORT.equals(localName)) {
                String src = atts.getValue("src");
                ecssContent.append("@import url(\"#{resource['");
                ecssContent.append(src);
                ecssContent.append("']}\");\r\n");
            }



#end
#end
#No. 187432
#File: E:\bishe\1\Xcss2EcssConverter.java
#Comment:
        /**
         * Create the SAX parser
         */

#Code:
        private void create() throws SAXException, ParserConfigurationException {
            // Obtain a new instance of a SAXParserFactory.
            SAXParserFactory factory = SAXParserFactory.newInstance();
            // Specifies that the parser produced by this code will provide support for XML namespaces.
            factory.setNamespaceAware(true);
            // Specifies that the parser produced by this code will validate documents as they are parsed.
            // factory.setValidating(true);
            // Creates a new instance of a SAXParser using the currently configured factory parameters.
            saxParser = factory.newSAXParser();
        }

#end
#end
#No. 187433
#File: E:\bishe\1\Xcss2EcssConverter.java
#Comment:
        /**
         * Parse a File
         *
         * @param file - File
         * @throws IOException
         * @throws SAXException
         */

#Code:
        public void parse(File file) throws IOException, SAXException {
            saxParser.parse(file, handler);
        }

#end
#end
#No. 187434
#File: E:\bishe\1\Xcss2EcssConverter.java
#Comment:
        /**
         * Parse a URI
         *
         * @param uri - String
         */

#Code:
        public void parse(String uri) throws IOException, SAXException {
            saxParser.parse(uri, handler);
        }

#end
#end
#No. 187435
#File: E:\bishe\1\Xcss2EcssConverter.java
#Comment:
        /**
         * Parse a Stream
         *
         * @param stream - InputStream
         */

#Code:
        public void parse(InputStream stream) throws IOException, SAXException {
            saxParser.parse(stream, handler);
        }



#end
#end
#No. 187439
#File: E:\bishe\1\XC_MethodReplacement.java
#Comment:
    /**
     * @see #returnConstant(Object)
     */

#Code:
    public static XC_MethodReplacement returnConstant(int priority, final Object result) {
        return new XC_MethodReplacement(priority) {
            @Override
            public MethodHookParam replaceHookedMethod(MethodHookParam param) throws Throwable {
                return param;
            }
        };
    }

#end
#end
#No. 187449
#File: E:\bishe\1\XdocSinkFactory.java
#Comment:
/**
 * Xdoc implementation of the Sink factory.
 *
 * @author <a href="mailto:vincent.siveton@gmail.com">Vincent Siveton</a>
 * @version $Id$
 * @since 1.0
 */

#Code:
@Component( role = SinkFactory.class, hint = "xdoc" )
public class XdocSinkFactory
    extends AbstractXmlSinkFactory
{
    /** {@inheritDoc} */
    protected Sink createSink( Writer writer, String encoding )
    {
        return new XdocSink( writer, encoding );
    }

    /** {@inheritDoc} */
    protected Sink createSink( Writer writer, String encoding, String languageId )
    {
        return new XdocSink( writer, encoding, languageId );
    }
}

#end
#end
#No. 187450
#File: E:\bishe\1\XdpTreeNode.java
#Comment:
	/**
	 * Constructs an XdpTreeNode
	 * @param node	the XML node
	 */

#Code:
	@SuppressWarnings("unchecked")
    public XdpTreeNode(Node node) {
		super(null, node);
		if (node instanceof Element) {
			Element element = (Element)node;
			addChildNodes(element.attributes());
		}
		if (node instanceof Branch) {
			Branch branch = (Branch) node;
			addChildNodes(branch.content());
		}
		if (node instanceof Attribute) {
			icon = IconFetcher.getIcon("attribute.png");
			return;
    	}
    	if (node instanceof Text) {
    		icon = IconFetcher.getIcon("text.png");
    		return;
    	}
    	if (node instanceof ProcessingInstruction) {
    		icon = IconFetcher.getIcon("pi.png");
    		return;
    	}
    	if (node instanceof Document) {
    		icon = IconFetcher.getIcon("xfa.png");
    		return;
    	}
    	icon = IconFetcher.getIcon("tag.png");
	}

#end
#end
#No. 187451
#File: E:\bishe\1\XdrBufferEncodingStream.java
#Comment:
    /**
     * Get the number of bytes in the buffers.
     * Value is undefined until endEncoding() has been called.
     *
     * @return the length (in bytes) of the buffers.
     */

#Code:
    public int getBuffersLength() {
        return buffers.stream()
                .mapToInt(ByteBuffer::limit)
                .sum();
    }

#end
#end
#No. 187455
#File: E:\bishe\1\xExportPartitionsNEXUS.java
#Comment:
	/** returns the version number at which this module was first released.  If 0, then no version number is claimed.  If a POSITIVE integer
	 * then the number refers to the Mesquite version.  This should be used only by modules part of the core release of Mesquite.
	 * If a NEGATIVE integer, then the number refers to the local version of the package, e.g. a third party package*/

#Code:
	public int getVersionOfFirstRelease(){
		return 273;  
	}

#end
#end
#No. 187456
#File: E:\bishe\1\XfaFile.java
#Comment:
	/**
	 * Constructs an XFA file from an OutputStreamResource.
	 * This resource can be an XML file or a node in a RUPS application.
	 * @param	resource	the XFA resource
	 * @throws IOException 
	 * @throws DocumentException 
	 */

#Code:
	public XfaFile(OutputStreamResource resource) throws IOException, DocumentException {
		// Is there a way to avoid loading everything in memory?
		// Can we somehow get the XML from the PDF as an InputSource, Reader or InputStream?
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		resource.writeTo(baos);
		ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
		SAXReader reader = new SAXReader();
		xfaDocument = reader.read(bais);
	}

#end
#end
#No. 187457
#File: E:\bishe\1\XfaFile.java
#Comment:
	/**
	 * Getter for the XFA Document object.
	 * @return	a Document object (X4J)
	 */

#Code:
	public Document getXfaDocument() {
		return xfaDocument;
	}

#end
#end
#No. 187458
#File: E:\bishe\1\XfaFile.java
#Comment:
	/**
	 * Writes a formatted XML file to the OutputStream.
	 * @see com.itextpdf.rups.io.OutputStreamResource#writeTo(java.io.OutputStream)
	 */

#Code:
	public void writeTo(OutputStream os) throws IOException {
		if (xfaDocument == null)
			return;
		OutputFormat format = new OutputFormat("   ", true);
        XMLWriter writer = new XMLWriter(os, format);
        writer.write(xfaDocument);
	}

#end
#end
#No. 187462
#File: E:\bishe\1\XFooterView.java
#Comment:
    /**
     * Set footer view state
     *
     * @see #STATE_LOADING
     * @see #STATE_NORMAL
     * @see #STATE_READY
     *
     * @param state
     */

#Code:
    public void setState(int state) {
        if (state == mState) return;

        if (state == STATE_LOADING) {
//            mHintImage.clearAnimation();
//            mHintImage.setVisibility(View.INVISIBLE);
            mProgressBar.setVisibility(View.VISIBLE);
            mHintView.setVisibility(View.INVISIBLE);
        } else {
            mHintView.setVisibility(View.VISIBLE);
//            mHintImage.setVisibility(View.VISIBLE);
            mProgressBar.setVisibility(View.INVISIBLE);
        }

        switch (state) {
            case STATE_NORMAL:
//                if (mState == STATE_READY) {
//                    mHintImage.startAnimation(mRotateDownAnim);
//                }
//                if (mState == STATE_LOADING) {
//                    mHintImage.clearAnimation();
//                }
                mHintView.setText(R.string.footer_hint_load_normal);
                break;

            case STATE_READY:
                if (mState != STATE_READY) {
//                    mHintImage.clearAnimation();
//                    mHintImage.startAnimation(mRotateUpAnim);
                    mHintView.setText(R.string.footer_hint_load_ready);
                }
                break;

            case STATE_LOADING:
                break;
        }

        mState = state;
    }

#end
#end
#No. 187463
#File: E:\bishe\1\XFooterView.java
#Comment:
    /**
     * Set footer view bottom margin.
     *
     * @param margin
     */

#Code:
    public void setBottomMargin(int margin) {
        if (margin < 0) return;
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mLayout.getLayoutParams();
        lp.bottomMargin = margin;
        mLayout.setLayoutParams(lp);
    }

#end
#end
#No. 187464
#File: E:\bishe\1\XFooterView.java
#Comment:
    /**
     * Get footer view bottom margin.
     *
     * @return
     */

#Code:
    public int getBottomMargin() {
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mLayout.getLayoutParams();
        return lp.bottomMargin;
    }

#end
#end
#No. 187465
#File: E:\bishe\1\XFooterView.java
#Comment:
    /**
     * normal status
     */

#Code:
    public void normal() {
        mHintView.setVisibility(View.VISIBLE);
        mProgressBar.setVisibility(View.GONE);
    }

#end
#end
#No. 187466
#File: E:\bishe\1\XFooterView.java
#Comment:
    /**
     * loading status
     */

#Code:
    public void loading() {
        mHintView.setVisibility(View.GONE);
        mProgressBar.setVisibility(View.VISIBLE);
    }

#end
#end
#No. 187467
#File: E:\bishe\1\XFooterView.java
#Comment:
    /**
     * hide footer when disable pull load more
     */

#Code:
    public void hide() {
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mLayout.getLayoutParams();
        lp.height = 0;
        mLayout.setLayoutParams(lp);
    }

#end
#end
#No. 187468
#File: E:\bishe\1\XFooterView.java
#Comment:
    /**
     * show footer
     */

#Code:
    public void show() {
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mLayout.getLayoutParams();
        lp.height = LayoutParams.WRAP_CONTENT;
        mLayout.setLayoutParams(lp);
    }


#end
#end
#No. 187470
#File: E:\bishe\1\XfsAPI.java
#Comment:
	/**
	 * Establishes a connection between an application and the XFS Manager.
	 *
	 * @param versionsRequired
	 * @return
	 * @throws IllegalArgumentException
	 * @throws WFSStartUpException
	 */

#Code:
	public WFSVersion wfsStartUp(final DWORD versionsRequired) throws IllegalArgumentException, WFSStartUpException {
		final String method = "wfsStartUp(DWORD)";
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "versionsRequired=" + versionsRequired);
		}
		if (versionsRequired == null) {
			throw new IllegalArgumentException("versionsRequired cannot be null");
		}
		final WFSVersion wfsVersion = new WFSVersion();
		wfsVersion.allocate();
		final int errorCode = wfsStartUp0(versionsRequired, wfsVersion);
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "errorCode=" + errorCode);
		}
		try {
			XfsException.throwFor(errorCode);
		} catch (XfsException e) {
			throw new WFSStartUpException(wfsVersion, e);
		}
		return wfsVersion;
	}

#end
#end
#No. 187471
#File: E:\bishe\1\XfsAPI.java
#Comment:
	/**
	 * The WFSCleanUp call indicates disconnection of a XFS application from the
	 * XFS Manager. This function, for example, frees resources allocated to the
	 * specific application. WFSCleanUp applies to all threads of a
	 * multi-threaded application. If WFSClose has not been issued for one or
	 * more service providers, then the XFS Manager will automatically issue the
	 * close(s). Once the WFSCleanUp has been performed, subsequent attempts to
	 * issue any XFS function other than WFSStartUp will fail.
	 *
	 * @throws XfsException
	 */

#Code:
	public void wfsCleanUp() throws XfsException {
		final String method = "wfsCleanUp()";
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "Calling WFSCleanUp ...");
		}
		final int errorCode = wfsCleanUp0();
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "errorCode=" + errorCode);
		}
		XfsException.throwFor(errorCode);
	}

#end
#end
#No. 187472
#File: E:\bishe\1\XfsAPI.java
#Comment:
	/**
	 * Requests a new, unique application handle value.
	 *
	 * @return
	 * @throws XfsException
	 */

#Code:
	public HAPP wfsCreateAppHandle() throws XfsException {
		final HAPP hApp = new HAPP();
		hApp.allocate();
		final int errorCode = wfsCreateAppHandle0(hApp);
		if (LOG.isDebugEnabled()) {
			LOG.debug("wfsCreateAppHandle()", "errorCode=" + errorCode + ",hApp=" + hApp);
		}
		XfsException.throwFor(errorCode);
		return hApp;
	}

#end
#end
#No. 187473
#File: E:\bishe\1\XfsAPI.java
#Comment:
	/**
	 * Discontinues monitoring of the specified message class(es) (or all
	 * classes) from the specified hService, by the specified hWndReg (or all
	 * the calling application's hWnd's). The asynchronous version of
	 * WFSDeregister.
	 *
	 * @param hService
	 *            Service handle returned by WFSOpen or WFSAsyncOpen. If this
	 *            value is NULL, and dwEventClass is SYSTEM_EVENTS, the XFS
	 *            manager deregisters the application for those system events
	 *            generated by the Manager itself.
	 * @param dwEventClass
	 *            The class(es) of events from which the application is
	 *            deregistering. Specified as a bit mask that can be a logical
	 *            OR of the values for multiple classes. A NULL value requests
	 *            that all event classes be deregistered from the specified
	 *            window for this hService.
	 * @param hWndReg
	 *            The window which has been previously registered to receive
	 *            notification messages, and is now to be deregistered. A NULL
	 *            value requests that all the application's windows be
	 *            deregistered from the specified message class(es) for this
	 *            hService.
	 * @param hWnd
	 *            The window handle which is to receive the completion message
	 *            for this request.
	 * @throws XfsException
	 */

#Code:
	public RequestId wfsAsyncDeregister(final HSERVICE hService, final DWORD dwEventClass, final HWND hWndReg, final HWND hWnd) throws XfsException {
		final String method = "wfsAsyncDeregister(HSERVICE, DWORD, HWND, HWND)";
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "hService=" + hService + ",dwEventClass=" + dwEventClass + ",hWndReg=" + hWndReg + ",hWnd=" + hWnd);
		}
		RequestId requestId = new RequestId();
		final int errorCode = wfsAsyncDeregister0(hService, dwEventClass, hWndReg, hWnd, requestId);
		XfsException.throwFor(errorCode);
		return requestId;
	}

#end
#end
#No. 187474
#File: E:\bishe\1\XfsAPI.java
#Comment:
	/**
	 * Makes the specified application handle invalid.
	 *
	 * @param hApp
	 *            The application handle to be made invalid.
	 * @throws XfsException
	 */

#Code:
	public void wfsDestroyAppHandle(final HAPP hApp) throws XfsException {
		final String method = "wfsDestroyAppHandle(HAPP)";
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "hApp=" + hApp);
		}
		if (hApp == null) {
			throw new IllegalArgumentException("hApp must not be null");
		}
		final int errorCode = wfsDestroyAppHandle0(hApp);
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "errorCode=" + errorCode);
		}
		XfsException.throwFor(errorCode);
	}

#end
#end
#No. 187475
#File: E:\bishe\1\XfsAPI.java
#Comment:
	/**
	 *
	 * @param wfsResult
	 * @throws XfsException
	 */

#Code:
	public void wfsFreeResult(final WFSResult wfsResult) throws XfsException {
		final String method = "wfsFreeResult(WFSResult)";
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "wfsResult=" + wfsResult);
		}
		final int errorCode = wfsFreeResult0(wfsResult);
		XfsException.throwFor(errorCode);
	}

#end
#end
#No. 187476
#File: E:\bishe\1\XfsAPI.java
#Comment:
	/**
	 * Retrieves information from the specified service provider. The
	 * asynchronous version of WFSGetInfo.
	 *
	 * @param hService
	 *            Handle to the service provider as returned by WFSOpen or
	 *            WFSAsyncOpen.
	 * @param dwCategory
	 *            See WFSGetInfo.
	 * @param queryDetails
	 *            See WFSGetInfo.
	 * @param dwTimeOut
	 *            Number of milliseconds to wait for completion
	 *            (WFS_INDEFINITE_WAIT to specify a request that will wait until
	 *            completion).
	 * @param hWnd
	 *            The window handle which is to receive the completion message
	 *            for this request.
	 */

#Code:
	public RequestId wfsAsyncGetInfo(final HSERVICE hService, final DWORD dwCategory, final Type queryDetails, final DWORD dwTimeOut, final HWND hWnd) throws XfsException {
		final String method = "wfsAsyncGetInfo(HSERVICE, DWORD, Type, DWORD, HWND)";
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "hService=" + hService + ",dwCategory=" + dwCategory + ",queryDetails=" + queryDetails + ",dwTimeOut=" + dwTimeOut + ",hWnd=" + hWnd);
		}
		RequestId requestId = new RequestId();
		requestId.allocate();
		final int errorCode = wfsAsyncGetInfo0(hService, dwCategory, queryDetails, dwTimeOut, hWnd, requestId);
		XfsException.throwFor(errorCode);
		return requestId;
	}

#end
#end
#No. 187477
#File: E:\bishe\1\XfsAPI.java
#Comment:
	/**
	 * Enables event monitoring for the specified service by the specified
	 * window; all messages of the specified class(es) are sent to the window
	 * specified in the hWndReg parameter. The asynchronous version of
	 * WFSRegister.
	 *
	 * @param hService
	 *            Handle to the service provider as returned by WFSOpen or
	 *            WFSAsyncOpen. If this value is NULL, and dwEventClass is
	 *            SYSTEM_EVENTS, the XFS manager registers the application for
	 *            those system events generated by the Manager itself.
	 * @param dwEventClass
	 *            The class(es) of events for which the application is
	 *            registering. Specified as a set of bit masks that are
	 *            logically ORed together into this parameter.
	 * @param hWndReg
	 *            The window handle which is to be registered to receive the
	 *            specified messages.
	 * @param hWnd
	 *            The window handle which is to receive the completion message
	 *            for this request.
	 */

#Code:
	public RequestId wfsAsyncRegister(final HSERVICE hService, final DWORD dwEventClass, final HWND hWndReg, final HWND hWnd) throws XfsException {
		final String method = "wfsAsyncRegister(HSERVICE, DWORD, HWND, HWND)";
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "hService=" + hService + ",dwEventClass=" + dwEventClass + ",hWndReg=" + hWndReg + ",hWnd=" + hWnd);
		}
		RequestId requestId = new RequestId();
		requestId.allocate();
		int errorCode = wfsAsyncRegister0(hService, dwEventClass, hWndReg, hWnd, requestId);
		XfsException.throwFor(errorCode);
		return requestId;
	}

#end
#end
#No. 187478
#File: E:\bishe\1\XfsCallable.java
#Comment:
	/**
	 * @see at.o2xfs.xfs.service.events.XfsEventNotification#fireOperationCompleteEvent
	 *      (at.o2xfs.xfs.WFSResult)
	 */

#Code:
	@Override
	public void fireOperationCompleteEvent(final WFSResult wfsResult) {
		final String method = "fireOperationCompleteEvent(WFSResult)";
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "wfsResult=" + wfsResult);
		}
		synchronized (this) {
			this.wfsResult = wfsResult;
			notifyAll();
		}
	}

#end
#end
#No. 187479
#File: E:\bishe\1\XfsCommand.java
#Comment:
	/**
	 * @see java.util.concurrent.Callable#call()
	 */

#Code:
	@Override
	public WFSResult call() throws XfsException {
		return new XfsCallable(this).call();
	}

#end
#end
#No. 187480
#File: E:\bishe\1\XfsCommand.java
#Comment:
	/**
	 * @return the xfsDevice
	 */

#Code:
	public XfsService getXFSService() {
		return xfsService;
	}



#end
#end
#No. 187483
#File: E:\bishe\1\XfsExecuteCommand.java
#Comment:
	/**
	 * @return the command
	 */

#Code:
	public T getCommand() {
		return command;
	}

#end
#end
#No. 187484
#File: E:\bishe\1\XfsExecuteCommand.java
#Comment:
	/**
	 * @return the cmdData
	 */

#Code:
	public Type getCmdData() {
		return cmdData;
	}

#end
#end
#No. 187485
#File: E:\bishe\1\XfsInfoCommand.java
#Comment:
	/**
	 * @return the category
	 */

#Code:
	public T getCategory() {
		return category;
	}

#end
#end
#No. 187486
#File: E:\bishe\1\XfsInfoCommand.java
#Comment:
	/**
	 * @return the queryDetails
	 */

#Code:
	public Type getQueryDetails() {
		return queryDetails;
	}

#end
#end
#No. 187487
#File: E:\bishe\1\XfsService.java
#Comment:
	/**
	 * @return the logicalName
	 */

#Code:
	public String getLogicalName() {
		return logicalName;
	}

#end
#end
#No. 187488
#File: E:\bishe\1\XfsService.java
#Comment:
	/**
	 * @return the hService
	 */

#Code:
	public HSERVICE getService() {
		return hService;
	}

#end
#end
#No. 187489
#File: E:\bishe\1\XfsService.java
#Comment:
	/**
	 * @return the srvcVersionsRequired
	 */

#Code:
	public XFSVersionDWORD getSrvcVersionsRequired() {
		return srvcVersionsRequired;
	}

#end
#end
#No. 187490
#File: E:\bishe\1\XfsService.java
#Comment:
	/**
	 * @return the srvcVersion
	 */

#Code:
	public WFSVersion getSrvcVersion() {
		return srvcVersion;
	}

#end
#end
#No. 187491
#File: E:\bishe\1\XfsService.java
#Comment:
	/**
	 * @return the spiVersion
	 */

#Code:
	public WFSVersion getSPIVersion() {
		return spiVersion;
	}

#end
#end
#No. 187492
#File: E:\bishe\1\XfsService.java
#Comment:
	/**
	 * @see java.lang.Object#toString()
	 */

#Code:
	@Override
	public String toString() {
		return new ToStringBuilder(this).append("logicalName", logicalName)
				.append("serviceClass", serviceClass)
				.append("hService", hService)
				.append("srvcVersionsRequired", srvcVersionsRequired)
				.append("srvcVersion", srvcVersion)
				.append("spiVersion", spiVersion).toString();
	}

#end
#end
#No. 187493
#File: E:\bishe\1\XfsServiceManager.java
#Comment:
	/**
	 * @see IXfsCallback
	 */

#Code:
	@Override
	public void callback(final XfsMessage msg, final WFSResult wfsResult) {
		final String method = "callback(XFSMessage, WFSResult)";
		if (LOG.isDebugEnabled()) {
			LOG.debug(method, "msg=" + msg + ",wfsResult=" + wfsResult);
		}
		synchronized (wfsResults) {
			wfsResults.add(wfsResult);
		}
		if (msg.isOperationComplete() || msg.isIntermediateEvent()) {
			XfsEventNotification eventNotification = requestQueue.getEventNotification(wfsResult.getRequestID());
			if (msg.isOperationComplete()) {
				requestQueue.removeRequest(wfsResult.getRequestID());
			}
			eventDispatcher.dispatch(msg, eventNotification, wfsResult);
		} else {
			final XfsService xfsService = getXfsService(wfsResult.getService());
			if (xfsService == null) {
				if (LOG.isErrorEnabled()) {
					LOG.error(method, "Could not find XfsService for WFSResult: " + wfsResult);
				}
				free(wfsResult);
			} else {
				eventDispatcher.dispatch(msg, xfsService, wfsResult);
			}
		}
	}






#end
#end
#No. 187497
#File: E:\bishe\1\XfsVersion.java
#Comment:
	/**
	 * @param version
	 *            the version to be compared.
	 * @return true as this version is less than the specified version.
	 */

#Code:
	public boolean isLT(final XfsVersion version) {
		return compareTo(version) < 0;
	}

#end
#end
#No. 187498
#File: E:\bishe\1\XfsVersion.java
#Comment:
	/**
	 * @param version
	 *            the version to be compared.
	 * @return true as this version is less than or equal to the specified
	 *         version.
	 */

#Code:
	public boolean isLE(final XfsVersion version) {
		return compareTo(version) <= 0;
	}

#end
#end
#No. 187499
#File: E:\bishe\1\XGORMNamespaceHandler.java
#Comment:
/**
 * Created with IntelliJ IDEA.
 * User: domix
 * Date: 13/05/12
 * Time: 19:52
 * To change this template use File | Settings | File Templates.
 */

#Code:
class XGORMNamespaceHandler extends NamespaceHandlerSupport {
  private static final Logger log = LoggerFactory.getLogger(XGORMNamespaceHandler.class);

  public void init() {
    log.debug("init");
    ExpandoMetaClass.enableGlobally();
    registerBeanDefinitionParser("sessionFactory", new XGORMSessionFactoryDefinitionParser());
  }
}

#end
#end
#No. 187500
#File: E:\bishe\1\XGTxChecker.java
#Comment:
/**
 * XG checker.
 *
 * @author <a href="mailto:ales.justin@jboss.org">Ales Justin</a>
 */

#Code:
class XGTxChecker implements TxChecker {
    private static final int MAX_ENTITY_GROUPS = Integer.parseInt(System.getProperty("gae.xg.max_entity_groups", "25"));

    // 1 per tx, we should be fine wrt sync
    private Set<Key> roots = new HashSet<Key>();

    public boolean isInvalid(Key currentRoot, Key key) {
        TxTrackerUtil.track(currentRoot);

        roots.add(currentRoot);

        return (roots.size() > MAX_ENTITY_GROUPS);
    }

    // if it was added into roots, it passed used check
    // so we can safely remove it

    public void beforeCompletion() {
        for (Key root : roots) {
            TxTrackerUtil.beforeCompletion(root);
        }
    }

    public void afterCompletion(int status) {
        for (Key root : roots) {
            TxTrackerUtil.afterCompletion(status, root);
        }
    }
}

#end
#end
#No. 187501
#File: E:\bishe\1\XHeaderView.java
#Comment:
    /**
     * Set the header view visible height.
     *
     * @param height
     */

#Code:
    public void setVisibleHeight(int height) {
        if (height < 0) height = 0;
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mContainer.getLayoutParams();
        lp.height = height;
        mContainer.setLayoutParams(lp);
    }

#end
#end
#No. 187502
#File: E:\bishe\1\XHeaderView.java
#Comment:
    /**
     * Get the header view visible height.
     *
     * @return
     */

#Code:
    public int getVisibleHeight() {
        return mContainer.getHeight();
    }


#end
#end
#No. 187515
#File: E:\bishe\1\XHRPollingTransport.java
#Comment:
    /**
     * Return an url with a time-based parameter to avoid caching issues
     */

#Code:
    private String computedRequestUrl() {
        String currentTime = String.valueOf(System.currentTimeMillis());
        return sessionUrl.buildUpon().appendQueryParameter("t", currentTime)
                .build().toString();
    }

#end
#end
#No. 187516
#File: E:\bishe\1\XhtmlMarkup.java
#Comment:
/**
 * List of <code>Xhtml</code> markups.
 * <br/>
 * Xhtml uses all {@link javax.swing.text.html.HTML.Tag} and {@link javax.swing.text.html.HTML.Attribute}
 * as markups.
 *
 * @author <a href="mailto:vincent.siveton@gmail.com">Vincent Siveton</a>
 * @version $Id$
 * @since 1.0
 */

#Code:
@SuppressWarnings( "checkstyle:interfaceistype" )
public interface XhtmlMarkup
    extends HtmlMarkup
{
    /** XHTML namespace: "http://www.w3.org/1999/xhtml" */
    String XHTML_NAMESPACE = "http://www.w3.org/1999/xhtml";

    /** XHTML 1.0 transitional public id: "-//W3C//DTD XHTML 1.0 Transitional//EN" */
    String XHTML_TRANSITIONAL_PUBLIC_ID = "-//W3C//DTD XHTML 1.0 Transitional//EN";

    /** XHTML 1.0 transitional system id: "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" */
    String XHTML_TRANSITIONAL_SYSTEM_ID = "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd";
}

#end
#end
#No. 187517
#File: E:\bishe\1\XhtmlParserModule.java
#Comment:
/**
 * <p>XhtmlParserModule class.</p>
 *
 * @since 1.6
 */

#Code:
@Component( role = ParserModule.class, hint = "xhtml" )
public class XhtmlParserModule
    extends AbstractParserModule
{
    /**
     * Default constructor.
     */
    public XhtmlParserModule()
    {
        super( "xhtml" );
    }
}

#end
#end
#No. 187518
#File: E:\bishe\1\XhtmlParserTest.java
#Comment:
    /**
     * Test unknown tags.
     *
     * @throws java.lang.Exception if any.
     */

#Code:
    public void testUnknown()
        throws Exception
    {
        String text = "<applet><param name=\"name\" value=\"value\"/><unknown/></applet>";

        SinkEventTestingSink sink = new SinkEventTestingSink();

        ( (XhtmlParser) createParser() ).parse( text, sink );

        Iterator<SinkEventElement> it = sink.getEventList().iterator();
        assertEquals( "unknown", it.next().getName() );
        assertEquals( "unknown", it.next().getName() );
        assertEquals( "unknown", it.next().getName() );
        assertEquals( "unknown", it.next().getName() );
        assertFalse( it.hasNext() );
    }

#end
#end
#No. 187519
#File: E:\bishe\1\XhtmlSinkFactory.java
#Comment:
/**
 * Xhtml implementation of the Sink factory.
 *
 * @author <a href="mailto:vincent.siveton@gmail.com">Vincent Siveton</a>
 * @version $Id$
 * @since 1.0
 */

#Code:
@Component( role = SinkFactory.class, hint = "xhtml" )
public class XhtmlSinkFactory
    extends AbstractXmlSinkFactory
{
    /** {@inheritDoc} */
    protected Sink createSink( Writer writer, String encoding )
    {
        return new XhtmlSink( writer, encoding );
    }

    /** {@inheritDoc} */
    protected Sink createSink( Writer writer, String encoding, String languageId )
    {
        return new XhtmlSink( writer, encoding, languageId );
    }
}

#end
#end
#No. 187520
#File: E:\bishe\1\XHTMLToFormattingObjects.java
#Comment:
    /**
     * This method is used to init the cache
     */

#Code:
    @PostConstruct
    public void initCache()
    {
        logger.debug("Start to init " + cacheName + " cache");
        cache = cacheManager.getCache(cacheName);
        if (cache == null) { throw new IllegalArgumentException("Cache " + cacheName
                + " does not exist"); }

        // HTML DTDs
        putInCache("xhtml1-strict.dtd", "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd");
        putInCache("xhtml1-frameset.dtd", "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd");
        putInCache(
                "xhtml1-transitional.dtd",
                "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd");

        // Entities
        putInCache("xhtml-lat1.ent", "http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent");
        putInCache("xhtml-symbol.ent", "http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent");
        putInCache("xhtml-special.ent", "http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent");

        tFactory.setURIResolver(this);
        logger.debug("Init of " + cacheName + " is finished for xslt "/*
                                                                       * + xslStylesheet .
                                                                       * getDescription ()
                                                                       */);
    }

#end
#end
#No. 187521
#File: E:\bishe\1\XHTMLWikiWordLinkResolver.java
#Comment:
/**
 * Transform WikiWord to HTML links
 *
 * @author Christian Nardi
 * @version $Id$
 * @since 1.1
 */

#Code:
public class XHTMLWikiWordLinkResolver
    implements WikiWordLinkResolver
{
    /**
     * {@inheritDoc}
     *
     * This only works for xhtml output, but there is no way
     * of transforming a wikiWord in another context.
     * @see org.apache.maven.doxia.module.twiki.parser.WikiWordLinkResolver#resolveLink(java.lang.String)
     */
    public final String resolveLink( final String wikiWord )
    {
        return "./" + wikiWord + ".html";
    }
}




#end
#end
#No. 187529
#File: E:\bishe\1\XIncludeTransformer.java
#Comment:
    /**
     * Determine whether the pipe is currently in a state where contents should be evaluated, i.e. xi:include elements should be
     * resolved and elements in other namespaces should be copied through. Will return false for fallback contents within a
     * successful xi:include, and true for contents outside any xi:include or within an xi:fallback for an unsuccessful
     * xi:include.
     */

#Code:
    private boolean isEvaluatingContent() {
        return xIncludeElementLevel == 0 || (fallbackElementLevel > 0 && fallbackElementLevel == useFallbackLevel);
    }

#end
#end
#No. 187530
#File: E:\bishe\1\XIncludeTransformerTest.java
#Comment:
    /**
     * A pipeline that reads from a file and perform a simple XInclude operation.
     */

#Code:
    @Test
    public void testPipelineWithXInclude() throws Exception {
        internalXIncludeTest("xinclude-xml.xml", "<?xml version=\"1.0\" encoding=\"UTF-8\"?><x>\n  <test/>\n</x>");
    }

#end
#end
#No. 187531
#File: E:\bishe\1\XIncludeTransformerTest.java
#Comment:
    /**
     * A pipeline that performs an XInclude operation, including just text.
     */

#Code:
    @Test
    @Ignore
    public void testPipelineWithXIncludeText() throws Exception {
        internalXIncludeTest("xinclude-text-only.xml",
                "<?xml version=\"1.0\" encoding=\"UTF-8\"?><x>\n  in girum imus nocte et cosumimur igni\n</x>");
    }

#end
#end
#No. 187532
#File: E:\bishe\1\XIncludeTransformerTest.java
#Comment:
    /**
     * A pipeline that performs an XInclude operation, forced to use the fallback.
     */

#Code:
    @Test
    public void testPipelineWithXIncludeFallback() throws Exception {
        internalXIncludeTest("xinclude-fallback.xml",
                "<?xml version=\"1.0\" encoding=\"UTF-8\"?><x>\n  \n        <error>the linked document has not found</error>\n    \n</x>");
    }

#end
#end
#No. 187533
#File: E:\bishe\1\XIncludeTransformerTest.java
#Comment:
    /**
     * A pipeline that performs an XInclude operation and use XPointer to extract a fragment from the included document.
     */

#Code:
    @Test
    public void testPipelineWithXIncludeAndXPointer() throws Exception {
        internalXIncludeTest(
                "xinclude-xpointer.xml",
                "<?xml version=\"1.0\" encoding=\"UTF-8\"?><x xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <p>\n      <xsl:value-of select=\"$myParam\"/>\n    </p>\n</x>");
    }

#end
#end
#No. 187534
#File: E:\bishe\1\XIncludeTransformerTest.java
#Comment:
    /**
     * A pipeline that performs an XInclude operation and use the deprecated XPointer to extract a fragment from the included
     * document.
     */

#Code:
    @Test
    public void testPipelineWithXIncludeAndDeprecatedXPointer() throws Exception {
        internalXIncludeTest(
                "xinclude-deprecated_xpointer.xml",
                "<?xml version=\"1.0\" encoding=\"UTF-8\"?><x xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n  <p>\n      <xsl:value-of select=\"$myParam\"/>\n    </p>\n</x>");
    }


#end
#end
#No. 187536
#File: E:\bishe\1\XInputAxis.java
#Comment:
/**
 * Enumerates all XInput axes.
 *
 * @author Ivan "StrikerX3" Oliveira
 */

#Code:
public enum XInputAxis {
    LEFT_THUMBSTICK_X, LEFT_THUMBSTICK_Y,
    RIGHT_THUMBSTICK_X, RIGHT_THUMBSTICK_Y,
    LEFT_TRIGGER, RIGHT_TRIGGER,
    DPAD;
}

#end
#end
#No. 187537
#File: E:\bishe\1\XInputBatteryDeviceType.java
#Comment:
/**
 * Enumerates all XInput device types for battery information retrieval.
 *
 * @author Ivan "StrikerX3" Oliveira
 */

#Code:
public enum XInputBatteryDeviceType {
    GAMEPAD, HEADSET;
}

#end
#end
#No. 187538
#File: E:\bishe\1\XInputBatteryLevel.java
#Comment:
/**
 * Enumerates all XInput battery levels.
 *
 * @author Ivan "StrikerX3" Oliveira
 */

#Code:
public enum XInputBatteryLevel {
    EMPTY, LOW, MEDIUM, FULL;

    /**
     * Retrieves the appropriate enum value from the native value.
     *
     * @param value the native value
     * @return the corresponding enum constant
     * @throws IllegalArgumentException if the given native value does not correspond
     * to an enum value
     */
    public static XInputBatteryLevel fromNative(final byte value) {
        switch (value) {
            case XInputConstants.BATTERY_LEVEL_EMPTY:
                return EMPTY;
            case XInputConstants.BATTERY_LEVEL_LOW:
                return LOW;
            case XInputConstants.BATTERY_LEVEL_MEDIUM:
                return MEDIUM;
            case XInputConstants.BATTERY_LEVEL_FULL:
                return FULL;
            default:
                throw new IllegalArgumentException("Invalid native value " + value);
        }
    }
}

#end
#end
#No. 187539
#File: E:\bishe\1\XInputBatteryType.java
#Comment:
/**
 * Enumerates all XInput battery types.
 *
 * @author Ivan "StrikerX3" Oliveira
 */

#Code:
public enum XInputBatteryType {
    DISCONNECTED, WIRED, ALKALINE, NIMH, UNKNOWN;

    /**
     * Retrieves the appropriate enum value from the native value.
     *
     * @param value the native value
     * @return the corresponding enum constant
     * @throws IllegalArgumentException if the given native value does not correspond
     * to an enum value
     */
    public static XInputBatteryType fromNative(final byte value) {
        switch (value) {
            case XInputConstants.BATTERY_TYPE_DISCONNECTED:
                return DISCONNECTED;
            case XInputConstants.BATTERY_TYPE_WIRED:
                return WIRED;
            case XInputConstants.BATTERY_TYPE_ALKALINE:
                return ALKALINE;
            case XInputConstants.BATTERY_TYPE_NIMH:
                return NIMH;
            case XInputConstants.BATTERY_TYPE_UNKNOWN:
                return UNKNOWN;
            default:
                throw new IllegalArgumentException("Invalid native value " + value);
        }
    }
}

#end
#end
#No. 187540
#File: E:\bishe\1\XInputButton.java
#Comment:
/**
 * Enumerates all XInput buttons.
 * 
 * @author Ivan "StrikerX3" Oliveira
 */

#Code:
public enum XInputButton {
	A, B, X, Y,
	BACK, START,
	LEFT_SHOULDER, RIGHT_SHOULDER,
	LEFT_THUMBSTICK, RIGHT_THUMBSTICK,
	DPAD_UP, DPAD_DOWN, DPAD_LEFT, DPAD_RIGHT,
	GUIDE_BUTTON, UNKNOWN;
}

#end
#end
#No. 187541
#File: E:\bishe\1\XInputDeviceType.java
#Comment:
/**
 * Enumerates all XInput device types.
 *
 * @author Ivan "StrikerX3" Oliveira
 */

#Code:
public enum XInputDeviceType {
    GAMEPAD(XInputConstants.XINPUT_DEVTYPE_GAMEPAD);

    private byte deviceTypeValue;

    XInputDeviceType(final byte deviceTypeValue) {
        this.deviceTypeValue = deviceTypeValue;
    }

    public byte getDeviceTypeValue() {
        return deviceTypeValue;
    }

    /**
     * Retrieves the appropriate enum value from the native value.
     *
     * @param value the native value
     * @return the corresponding enum constant
     * @throws IllegalArgumentException if the given native value does not correspond
     * to an enum value
     */
    public static XInputDeviceType fromNative(final byte value) {
        switch (value) {
            case XInputConstants.XINPUT_DEVTYPE_GAMEPAD:
                return GAMEPAD;
            default:
                throw new IllegalArgumentException("Invalid native value " + value);
        }
    }
}

#end
#end
#No. 187542
#File: E:\bishe\1\XInputLibraryVersion.java
#Comment:
/**
 * The version of the loaded DLL.
 *
 * @author Ivan "StrikerX3" Oliveira
 */

#Code:
public enum XInputLibraryVersion {
    /**
     * Library was not loaded.
     */
    NONE,

    /**
     * XInput 1.4 was loaded.
     */
    XINPUT_1_4,

    /**
     * XInput 1.3 was loaded.
     */
    XINPUT_1_3,

    /**
     * XInput 9.1.0 was loaded.
     */
    XINPUT_9_1_0
}

#end
#end
#No. 187543
#File: E:\bishe\1\XintroActivityBuilder.java
#Comment:
    /**
     * Sets fragments list.
     *
     * @param introFragmentModelList the fragments list
     * @return the XintroActivityBuilder object with the changed parameters. You can keep adjusting the builder with one-line.
     */

#Code:
    public XintroActivityBuilder setIntroFragmentModelList(ArrayList<IntroFragmentModel> introFragmentModelList) {
        this.introFragmentModelList = introFragmentModelList;
        return this;
    }


#end
#end
#No. 187545
#File: E:\bishe\1\XintroActivityBuilder.java
#Comment:
    /**
     * Compile to intent.
     *
     * @return the intent
     */

#Code:
    public Intent compile() {
        AppStaticContext.introFragmentModelArrayList = introFragmentModelList;
        AppStaticContext.onFragmentChangedListener = onFragmentChangedListener;
        AppStaticContext.onIntroductionFinishedListener = onIntroductionFinishedListener;
        AppStaticContext.pageTransformer = pageTransformer;
        AppStaticContext.customImageLoader = customImageLoader;
        AppStaticContext.callerContext = mContext;

        XintroActivity xintroActivity = new XintroActivity();
        Intent intent = new Intent(mContext, xintroActivity.getClass());
        return intent;
    }

#end
#end
#No. 187546
#File: E:\bishe\1\XintroActivityBuilder.java
#Comment:
    /**
     * Compile to intent and start the XIntro Activity.
     */

#Code:
    public void introduce() {
        mContext.startActivity(compile());
    }

#end
#end
#No. 187547
#File: E:\bishe\1\XintroFragmentBuilder.java
#Comment:
    /**
     * Sets the title of the fragment.
     *
     * @param title the title
     * @return the xintro fragment builder
     */

#Code:
    public XintroFragmentBuilder setTitle(String title) {
        this.title = title;
        return this;
    }

#end
#end
#No. 187548
#File: E:\bishe\1\XintroFragmentBuilder.java
#Comment:
    /**
     * Sets description of the fragment.
     *
     * @param description the description
     * @return the xintro fragment builder
     */

#Code:
    public XintroFragmentBuilder setDescription(String description) {
        this.description = description;
        return this;
    }


#end
#end
#No. 187550
#File: E:\bishe\1\XintroFragmentBuilder.java
#Comment:
    /**
     * Sets title text color.
     *
     * @param titleTextColor the title text color
     * @return the xintro fragment builder
     */

#Code:
    public XintroFragmentBuilder setTitleTextColor(int titleTextColor) {
        this.titleTextColor = titleTextColor;
        return this;
    }

#end
#end
#No. 187551
#File: E:\bishe\1\XintroFragmentBuilder.java
#Comment:
    /**
     * Sets description text color.
     *
     * @param descriptionTextColor the description text color
     * @return the xintro fragment builder
     */

#Code:
    public XintroFragmentBuilder setDescriptionTextColor(int descriptionTextColor) {
        this.descriptionTextColor = descriptionTextColor;
        return this;
    }

#end
#end
#No. 187552
#File: E:\bishe\1\XintroFragmentBuilder.java
#Comment:
    /**
     * Sets image elevation.
     *
     * @param imageElevation the image elevation
     * @return the xintro fragment builder
     */

#Code:
    @TargetApi(android.os.Build.VERSION_CODES.LOLLIPOP)
    public XintroFragmentBuilder setImageElevation(int imageElevation) {
        this.imageElevation = imageElevation;
        return this;
    }

#end
#end
#No. 187553
#File: E:\bishe\1\XintroFragmentBuilder.java
#Comment:
    /**
     * Compile to intro fragment model.
     *
     * @return the intro fragment model
     */

#Code:
    public IntroFragmentModel compile() {
        return new IntroFragmentModel(introFragment == null ? new SimpleIntroFragment() /* its the default */ : introFragment, title, description, image, backgroundColor, imageElevation, titleTextColor, descriptionTextColor);
    }

#end
#end
#No. 187554
#File: E:\bishe\1\XKCDModule.java
#Comment:
    /**
     * Fetch the the latest xkcd comic, but only show it if its new today
     *
     * @param listener
     */

#Code:
    public static void getXKCDForToday(final XKCDListener listener) {
        new AsyncTask<Void, Void, XKCDResponse>() {

            @Override
            protected XKCDResponse doInBackground(Void... params) {
                RestAdapter restAdapter = new RestAdapter.Builder()
                        .setEndpoint("http://xkcd.com")
                        .build();

                XKCDRequest service = restAdapter.create(XKCDRequest.class);
                try {
                    return service.getLatestXKCD();
                } catch (RetrofitError e) {
                    Log.w("XKCDModule", "Error loading xkcd", e);
                    return null;
                }
            }

            @Override
            protected void onPostExecute(@Nullable XKCDResponse xkcdResponse) {
                if (xkcdResponse != null && !TextUtils.isEmpty(xkcdResponse.img)) {
                    if (ConfigurationSettings.isDemoMode() || isTodaysXKCD(xkcdResponse)) {
                        listener.onNewXKCDToday(xkcdResponse.img);
                        return;
                    }
                }
                listener.onNewXKCDToday(null);
            }

            private boolean isTodaysXKCD(@NonNull XKCDResponse xkcdResponse) {
                Calendar today = Calendar.getInstance();
                return xkcdResponse.day == today.get(Calendar.DAY_OF_MONTH) && xkcdResponse.month == (today.get(Calendar.MONTH) + 1) && xkcdResponse.year == today.get(Calendar.YEAR);
            }




#end
#end
#No. 187688
#File: E:\bishe\1\XliffReader.java
#Comment:
	/**
	 * The constructor of XLIFF reader, the reader response to generate XLIFF file by
	 * {@link #readXliffFile(BufferedWriter, String, boolean, IProgressMonitor)} method and generate skeleton file by
	 * {@link #readSkeletonFile(BufferedWriter, IProgressMonitor)} method <br>
	 * Notice : when create instance of this class, would load the MIF file and parse it by use the @param mifFile
	 * @param mifFile
	 *            MIF file path
	 * @param encoding
	 *            MIF file encoding
	 * @param sourceLanguage
	 *            the language in MIF file
	 * @param strSger
	 *            The string segementer, witch use the SRX to segment the paragraph of text
	 * @throws IOException
	 * @throws MifParseException
	 * @throws UnSuportedFileExcetption
	 */

#Code:
	public XliffReader(String mifFile, String encoding, String sourceLanguage, StringSegmenter strSger)
			throws IOException, MifParseException, UnSuportedFileExcetption {
		loadFile(mifFile, encoding);

		this.mifEncoding = encoding;
		this.strSger = strSger;
		this.srcLang = sourceLanguage;
		this.xliffIdex = 1;
	}

#end
#end
#No. 187689
#File: E:\bishe\1\XliffReader.java
#Comment:
	/**
	 * After parse file, this method read skeleton file from the parse info
	 * @param sklOs
	 *            The skeleton file out put stream
	 * @param monitor
	 *            the progress monitor
	 * @throws IOException
	 *             ;
	 */

#Code:
	public void readSkeletonFile(BufferedWriter sklOs, IProgressMonitor monitor) throws IOException {
		if (monitor == null) {
			monitor = new NullProgressMonitor();
		}
		List<Object[]> cbfs = mrbf.getBuffer(new Comparator<Object[]>() {

			public int compare(Object[] o1, Object[] o2) {
				Integer v1 = (Integer) o1[1];
				int v2 = (Integer) o2[1];
				return v1.compareTo(v2);
			}
		});
		int off = 0;
		int len = doc.length;
		monitor.setTaskName(Messages.getString("mif.Mif2Xliff.task4"));
		if (cbfs.size() == 0) {
			monitor.beginTask(Messages.getString("mif.Mif2Xliff.task4"), 1);
			sklOs.write(doc, off, len);
		} else {
			monitor.beginTask(Messages.getString("mif.Mif2Xliff.task4"), cbfs.size() + 1);
			for (Object[] obj : cbfs) {
				int index = (Integer) obj[0];
				int start = (Integer) obj[1];
				int end = (Integer) obj[2];
				int segNum = (Integer) obj[3];
				sklOs.write(doc, off, start - off);
				off = end;
				sklOs.write("%%%" + index + "%%%");
				while (segNum > 1) {
					sklOs.write("\n%%%" + ++index + "%%%");
					segNum--;
				}
				monitor.worked(1);
			}
			sklOs.write(new String(doc, off, len - off).trim());
			monitor.worked(1);
		}
		monitor.done();
	}

#end
#end
#No. 187690
#File: E:\bishe\1\XliffReader.java
#Comment:
	/**
	 * Get the text end by space
	 * @return
	 * @throws EOFException
	 * @throws MifParseException
	 */

#Code:
	private String getContentEndBy(char n) throws EOFException, MifParseException {
		StringBuffer bf = new StringBuffer();
		if(n == '>'){
			//need process escape character '>' represent as '\>'
			char a = r.getCharAfterIgnore();
			char pre = a;
			while (true) {
				if(a == '>' && pre !='\\' ){
					break;
				}
				bf.append(a);
				pre = a;
				a = r.getChar();
			}
		}else {
			char a = r.getCharAfterIgnore();
			while (a != n) {
				bf.append(a);
				a = r.getChar();
			}
		}
		sos--;
		return bf.toString();
	}

#end
#end
#No. 187691
#File: E:\bishe\1\XliffReader.java
#Comment:
	/**
	 * Get current statement name
	 * @return
	 * @throws EOFException
	 * @throws MifParseException ;
	 */

#Code:
	private String getStatmentName() throws EOFException, MifParseException{
		StringBuffer bf = new StringBuffer();
		char a = r.getCharAfterIgnore();
		while (true) {
			if(a == ' ' || a == '\n' || a == '<' || a == '\r' || a == '\t' ){
				break;
			}
			bf.append(a);
			a = r.getChar();
		}
		sos--;
		if(bf.length() == 0){
			throw new MifParseException(Messages.getString("mif.Mif2Xliff.mismatchStartOrEndTag")
					+ formatLineNumber());
		}
		return bf.toString().toLowerCase();
	}

#end
#end
#No. 187692
#File: E:\bishe\1\XliffReader.java
#Comment:
	/**
	 * Get the statement value,the text in `'
	 * @return
	 * @throws MifParseException
	 * @throws EOFException
	 */

#Code:
	private String getValue() throws MifParseException, EOFException {
		// char n = r.getCharAfterIgnore();
		if (ch != '`') {
			throw new MifParseException(Messages.getString("mif.Mif2Xliff.statementError") + formatLineNumber());
		}
		StringBuffer bf = new StringBuffer();
		char a = r.getChar();
		while (a != '\'') {
			bf.append(a);
			a = r.getChar();
		}
		sos--;
		return bf.toString();
	}

#end
#end
#No. 187693
#File: E:\bishe\1\XliffReader.java
#Comment:
		/**
		 * Get next character
		 * @return Return the next character
		 * @throws MifParseException
		 * @throws EOFException
		 */

#Code:
		final public char getChar() throws MifParseException, EOFException {
			if (sos >= eos) {
				throw eofExp;
			}
			char n = doc[sos++];
			if (n < 0)
				throw new MifParseException(Messages.getString("mif.Mif2Xliff.characterError") + formatLineNumber());
			return n;
		}

#end
#end
#No. 187694
#File: E:\bishe\1\XliffReader.java
#Comment:
		/**
		 * Get the next char with ignore all \n,\t,\t and space
		 * @return the next none \n,\t,\t and space character
		 * @throws EOFException
		 * @throws MifParseException
		 */

#Code:
		final public char getCharAfterIgnore() throws EOFException, MifParseException {
			char n;
			do {
				n = getChar();
				if ((n == ' ' || n == '\n' || n == '\t' || n == '\r')) {
				} else {
					return n;
				}
				n = getChar();
				if ((n == ' ' || n == '\n' || n == '\t' || n == '\r')) {
				} else {
					return n;
				}
			} while (true);
		}

#end
#end
#No. 187695
#File: E:\bishe\1\XliffReader.java
#Comment:
		/**
		 * Skip the specification character
		 * @param ch
		 *            character
		 * @return if the next character is the specification character ,then skip it and return true; if return false
		 *         ,will do nothing
		 */

#Code:
		final public boolean skipChar(char ch) {
			if (ch == doc[sos]) {
				sos++;
				return true;
			} else {
				return false;
			}
		}






#end
#end
#No. 187703
#File: E:\bishe\1\XLogModule.java
#Comment:
    /**
     * turn on log
     */

#Code:
    @ReactMethod
    public static void open() {
        if (sIsLogOpen)
            return;

        Xlog.appenderOpen(
                sXLogSetting.getLevel(),
                sXLogSetting.getAppenderMode(),
                sXLogSetting.getCacheDir(),
                sXLogSetting.getPath(),
                sXLogSetting.getNamePrefix());
        Xlog.setConsoleLogOpen(sXLogSetting.isOpenConsoleLog());

        sIsLogOpen = true;
    }

#end
#end
#No. 187704
#File: E:\bishe\1\XLogModule.java
#Comment:
    /**
     * turn off log
     */

#Code:
    @ReactMethod
    public static void close() {
        Log.appenderClose();
        sIsLogOpen = false;
    }

#end
#end
#No. 187705
#File: E:\bishe\1\XLogModule.java
#Comment:
    /**
     * log
     *
     * @param level   log level
     * @param tag     Used to identify the source of a log message.  It usually identifies
     *                the class or activity where the log call occurs.
     * @param message The message you would like logged.
     */

#Code:
    @ReactMethod
    public static void log(int level, String tag, String message) {
        switch (level) {
            case Log.LEVEL_VERBOSE:
                Log.v(tag, message);
                break;

            case Log.LEVEL_DEBUG:
                Log.d(tag, message);
                break;

            case Log.LEVEL_INFO:
                Log.i(tag, message);
                break;

            case Log.LEVEL_WARNING:
                Log.w(tag, message);
                break;

            case Log.LEVEL_ERROR:
                Log.e(tag, message);
                break;

            case Log.LEVEL_FATAL:
                Log.f(tag, message);
                break;

            default: //log none
                break;
        }
    }


#end
#end
#No. 187708
#File: E:\bishe\1\XlsDetectorTest.java
#Comment:
    /**
     *
     * @throws Exception
     */

#Code:
    @Test(expected = IllegalArgumentException.class)
    public void should_not_read_null_input_stream() throws Exception {
        xlsDetector.detect(null);
    }

#end
#end
#No. 187713
#File: E:\bishe\1\XlsSerializer.java
#Comment:
    /**
     * @see Serializer#serialize(InputStream, DataSetMetadata, long)
     */

#Code:
    @Override
    public InputStream serialize(InputStream givenInputStream, DataSetMetadata metadata, long limit) {
        try {

            PipedInputStream pipe = new PipedInputStream();
            PipedOutputStream jsonOutput = new PipedOutputStream(pipe);

            // override the parameter in case it needs to be wrapped in a buffered inputstream
            InputStream inputStream = givenInputStream;
            if (!inputStream.markSupported()) {
                inputStream = new BufferedInputStream(inputStream);
            }

            inputStream.mark(Integer.MAX_VALUE);

            boolean newExcelFormat = XlsUtils.isNewExcelFormat(inputStream);

            inputStream.reset();

            Runnable runnable = newExcelFormat ? //
                    serializeNew(inputStream, metadata, limit, jsonOutput) : serializeOld(inputStream, metadata, limit, jsonOutput);

            // Serialize asynchronously for better performance (especially if caller doesn't consume all, see sampling).
            executor.execute(runnable);

            return pipe;
        } catch (IOException e) {
            throw new TDPException(CommonErrorCodes.UNABLE_TO_SERIALIZE_TO_JSON, e);
        }
    }

#end
#end
#No. 187714
#File: E:\bishe\1\XlsSerializerTest.java
#Comment:
    /**
     * <p>
     * See <a href="https://jira.talendforge.org/browse/TDP-222">https://jira.talendforge.org/browse/TDP-222</a>.
     * </p>
     * <p>
     * XlsSerializer should follow the data format as set in the Excel file. This test ensures XlsSerializer follows the
     * data format as defined and don't directly use {@link Cell#getNumericCellValue()}.
     * </p>
     *
     */

#Code:
    @Test
    public void testGeneralNumberFormat_TDP_222() throws Exception {
        final DataSetMetadata metadata = metadataBuilder.metadata().id("1234")
                .row(column().name("id").id(0).type(Type.INTEGER), column().name("value1").id(1).type(Type.INTEGER)).build();
        Format format = assertFormat("excel_numbers.xls");
        // Test number serialization in XLS type guess
        InputStream input = this.getClass().getResourceAsStream("excel_numbers.xls");
        final String result = IOUtils.toString(format.getFormatFamily().getSerializer().serialize(input, metadata, -1), UTF_8);
        final String expected = "[{\"0000\":\"1\",\"0001\":\"123\"},{\"0000\":\"2\",\"0001\":\"123.1\"},{\"0000\":\"3\",\"0001\":\"209.9\"}]";
        assertThat(result, sameJSONAs(expected));
    }

#end
#end
#No. 187718
#File: E:\bishe\1\XlsSerializerTest.java
#Comment:
    /**
     * Return the dataset metadata out of the given file name.
     *
     * @param fileName the excel file to open.
     * @param sheetName name of the excel sheet.
     * @return the dataset metadata.
     * @throws IOException s**y happens.
     */

#Code:
    private DataSetMetadata getDataSetMetadataFromExcelFile(String fileName, String sheetName) throws IOException {
        DataSetMetadata dataSetMetadata = metadataBuilder.metadata().id("ff").sheetName(sheetName).build();

        try (InputStream inputStream = this.getClass().getResourceAsStream(fileName)) {

            List<Schema.SheetContent> sheetContents = xlsSchemaParser.parseAllSheets(getRequest(inputStream, "#8"));

            List<ColumnMetadata> columnsMetadata = sheetContents.get(0).getColumnMetadatas();

            logger.debug("columnsMetadata: {}", columnsMetadata);

            Assertions.assertThat(columnsMetadata).isNotNull().isNotEmpty();

            dataSetMetadata.getRowMetadata().setColumns(columnsMetadata);
        }
        return dataSetMetadata;
    }

#end
#end
#No. 187719
#File: E:\bishe\1\XlsSerializerTest.java
#Comment:
    /**
     * Make sure the given file name is recognized as an excel file.
     *
     * @param fileName the excel file name to open.
     */

#Code:
    private void checkExcelFile(String fileName) throws IOException {
        Format format;
        try (InputStream inputStream = this.getClass().getResourceAsStream(fileName)) {
            format = formatDetector.detect(inputStream);
            Assert.assertNotNull(format);
            Assert.assertTrue(format.getFormatFamily() instanceof XlsFormatFamily);
            Assert.assertEquals(XlsFormatFamily.MEDIA_TYPE, format.getFormatFamily().getMediaType());
        }
    }

#end
#end
#No. 187720
#File: E:\bishe\1\XlsToCsv.java
#Comment:
    /**
     * Given the name of template return the name of data file.
     *
     * @param name
     * @return
     */

#Code:
    String transformTemplateName(String name) {
        return name.replace(configuration.getTemplate_prefix(), "");
    }

#end
#end
#No. 187721
#File: E:\bishe\1\XLSTransformerTest.java
#Comment:
    /*
     * This sample demonstrates a problem with formulas applied to jx:forEach tag
     * values nested in jx:outline tag. Basically jx:outline rows are removed during transformation
     * so as a result for the formula we have something like this: SUM(B3;B4;B5;B6;B7)
     * This restricts usage of formulas in this case becase the number of values passed to the formulas
     * in this way is restricted by Excel. So logically we need to transform formulas arguments
     * into a range like B3:B7. This is not currently possible with jXLS
     * TODO: fix this issue with formulas in the future
     */

#Code:
    public void atestOutlineInForEach() throws IOException, ParsePropertyException, InvalidFormatException {
        Map beans = new HashMap();
        beans.put("employees", itEmployees);
        InputStream is = new BufferedInputStream(getClass().getResourceAsStream(outlineXLS));
        XLSTransformer transformer = new XLSTransformer();
        Workbook resultWorkbook = transformer.transformXLS(is, beans);
        is.close();
//        is = new BufferedInputStream(getClass().getResourceAsStream(outlineXLS));
//        Workbook sourceWorkbook = WorkbookFactory.create(is);

//        Sheet sourceSheet = sourceWorkbook.getSheetAt(0);
//        Sheet resultSheet = resultWorkbook.getSheetAt(0);
//        Map props = new HashMap();
//        CellsChecker checker = new CellsChecker(props);
//        checker.checkListCells( sourceSheet, 3, resultSheet, 2, (short)0, new Object[]{ new Integer(0), new Integer(1), new Integer(2), new Integer(3), new Integer(4)} );
//        is.close();
        saveWorkbook(resultWorkbook, outlineDestXLS);
    }

#end
#end
#No. 187724
#File: E:\bishe\1\XlsxUtil.java
#Comment:
	/**
	 * Copy a sheet to another sheet at a specific (row, column) position
	 * 
	 * @param parentSheet the sheet to copy into
	 * @param parentSheetRow the row inside parentSheet where we start to copy
	 * @param parentSheetColumn the column inside parentSheet where we start to copy
	 * @param sheet the sheet that is copied
	 * @return column number
	 */

#Code:
	public static int copyToSheet(XSSFSheet parentSheet, int parentSheetRow, int parentSheetColumn, XSSFSheet sheet) {
		return copyToSheet(parentSheet, parentSheetRow, parentSheetColumn, sheet, true);
	}

#end
#end
#No. 187725
#File: E:\bishe\1\XlsxUtil.java
#Comment:
	/**
	 * Copy a sheet to another sheet at a specific (row, column) position
	 * 
	 * @param parentSheet the sheet to copy into
	 * @param parentSheetRow the row inside parentSheet where we start to copy
	 * @param parentSheetColumn the column inside parentSheet where we start to copy
	 * @param sheet the sheet that is copied
	 * @param copyStyle true to copy the style
	 * @return column number
	 */

#Code:
	public static int copyToSheet(XSSFSheet parentSheet, int parentSheetRow, int parentSheetColumn, XSSFSheet sheet, boolean copyStyle) {
		int maxColumnNum = 0;
		Map<Integer, CellStyle> styleMap = (copyStyle) ? new HashMap<Integer, CellStyle>() : null;
		for (int i = sheet.getFirstRowNum(); i <= sheet.getLastRowNum(); i++) {
			XSSFRow srcRow = sheet.getRow(i);
			XSSFRow destRow;
			// subreport is not the first cell in a row
			if ((parentSheetColumn > 0) && (i == sheet.getFirstRowNum())) {
				destRow = parentSheet.getRow(parentSheetRow);
			} else {
				destRow = parentSheet.getRow(parentSheetRow+i);
				if (destRow == null) {
					destRow = parentSheet.createRow(parentSheetRow + i);
				}
			}
			if (srcRow != null) {
				copyRow(sheet, parentSheet, parentSheetRow, parentSheetColumn, srcRow, destRow, styleMap);
				if (srcRow.getLastCellNum() > maxColumnNum) {
					maxColumnNum = srcRow.getLastCellNum();
				}
			}
		}
		for (int i = 0; i <= maxColumnNum; i++) {
			parentSheet.setColumnWidth(i, sheet.getColumnWidth(i));
		}
		return maxColumnNum;
	}

#end
#end
#No. 187726
#File: E:\bishe\1\XlsxUtil.java
#Comment:
	/**
	 * Copy a row from a sheet to another sheet
	 * 
	 * 
	 * @param srcSheet the sheet to copy
	 * @param destSheet the sheet to copy into
	 * @param parentSheetRow the row inside destSheet where we start to copy
	 * @param parentSheetColumn the column inside destSheet where we start to copy
	 * @param srcRow the row to copy
	 * @param destRow the row to create
	 * @param styleMap style map
	 *       
	 */

#Code:
	public static void copyRow(XSSFSheet srcSheet, XSSFSheet destSheet, int parentSheetRow, int parentSheetColumn, XSSFRow srcRow, XSSFRow destRow,
			Map<Integer, CellStyle> styleMap) {
		// manage a list of merged zone in order to not insert two times a
		// merged zone
		Set<CellRangeAddressWrapper> mergedRegions = new TreeSet<CellRangeAddressWrapper>();
		destRow.setHeight(srcRow.getHeight());
		// pour chaque row
		for (int j = srcRow.getFirstCellNum(); j <= srcRow.getLastCellNum(); j++) {
			XSSFCell oldCell = srcRow.getCell(j); // ancienne cell			
			if (oldCell != null) {				
				XSSFCell newCell = destRow.createCell(parentSheetColumn + j);				
				copyCell(oldCell, newCell, styleMap);
				
				CellRangeAddress mergedRegion = getMergedRegion(srcSheet, srcRow.getRowNum(), (short) oldCell.getColumnIndex());

				if (mergedRegion != null) {
					
					CellRangeAddress newMergedRegion = new CellRangeAddress(parentSheetRow + mergedRegion.getFirstRow(),
							parentSheetRow + mergedRegion.getLastRow(), 
							parentSheetColumn + mergedRegion.getFirstColumn(), 
							parentSheetColumn + mergedRegion.getLastColumn());
					
					CellRangeAddressWrapper wrapper = new CellRangeAddressWrapper(newMergedRegion);
					if (isNewMergedRegion(wrapper, mergedRegions)) {
						mergedRegions.add(wrapper);
						destSheet.addMergedRegion(wrapper.range);
					}
				}
			}
		}

	}

#end
#end
#No. 187727
#File: E:\bishe\1\XlsxUtil.java
#Comment:
	/**
	 * Copy a cell to another cell
	 * 
	 * @param oldCell cell to be copied
	 * @param newCell cell to be created
	 * @param styleMap style map
	 */

#Code:
	public static void copyCell(XSSFCell oldCell, XSSFCell newCell, Map<Integer, CellStyle> styleMap) {
		if (styleMap != null) {			
			if (oldCell.getSheet().getWorkbook() == newCell.getSheet().getWorkbook()) {
				newCell.setCellStyle(oldCell.getCellStyle());
			} else {				
				int stHashCode = oldCell.getCellStyle().hashCode();
				CellStyle newCellStyle = styleMap.get(stHashCode);				
				if (newCellStyle == null) {					
					newCellStyle = newCell.getSheet().getWorkbook().createCellStyle();
					newCellStyle.cloneStyleFrom(oldCell.getCellStyle());					
					styleMap.put(stHashCode, newCellStyle);
				}
				newCell.setCellStyle(newCellStyle);
			}			
		}
		switch (oldCell.getCellType()) {
		case XSSFCell.CELL_TYPE_STRING:
			newCell.setCellValue(oldCell.getStringCellValue());
			break;
		case XSSFCell.CELL_TYPE_NUMERIC:
			newCell.setCellValue(oldCell.getNumericCellValue());
			break;
		case XSSFCell.CELL_TYPE_BLANK:
			newCell.setCellType(XSSFCell.CELL_TYPE_BLANK);
			break;
		case XSSFCell.CELL_TYPE_BOOLEAN:
			newCell.setCellValue(oldCell.getBooleanCellValue());
			break;
		case XSSFCell.CELL_TYPE_ERROR:
			newCell.setCellErrorValue(oldCell.getErrorCellValue());
			break;
		case XSSFCell.CELL_TYPE_FORMULA:
			newCell.setCellFormula(oldCell.getCellFormula());
			break;
		default:
			break;
		}

	}

#end
#end
#No. 187728
#File: E:\bishe\1\XlsxUtil.java
#Comment:
	/**
	 * Check that the merged region has been created in the destination sheet.
	 * 
	 * @param newMergedRegion the merged region to copy or not in the destination sheet.
	 * @param mergedRegions the list containing all the merged region.
	 * @return true if the merged region is already in the list or not.
	 */

#Code:
	private static boolean isNewMergedRegion(CellRangeAddressWrapper newMergedRegion, Set<CellRangeAddressWrapper> mergedRegions) {
		return !mergedRegions.contains(newMergedRegion);
	}






#end
#end
#No. 187734
#File: E:\bishe\1\XML2HTML.java
#Comment:
    /**
     * @param args
     */

#Code:
    public static void main(String[] args) throws SAXException,
            ParserConfigurationException, MalformedURLException, IOException,
            TransformerException {
        InputStream in;
        OutputStream out;

        switch (args.length) {
            case 0:
                in = System.in;
                out = System.out;
                break;
            case 1:
                in = new FileInputStream(args[0]);
                out = System.out;
                break;
            case 2:
                in = new FileInputStream(args[0]);
                out = new FileOutputStream(args[1]);
                break;
            default:
                System.err.println("Too many arguments. No arguments to use stdin/stdout. One argument to reading from file and write to stdout. Two arguments to read from first file and write to second.");
                System.exit(1);
                return;
        }

        ContentHandler serializer = new HtmlSerializer(out);
        
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setValidating(false);
        XMLReader parser = factory.newSAXParser().getXMLReader();
        parser.setErrorHandler(new SystemErrErrorHandler());
        parser.setContentHandler(serializer);
        parser.setProperty("http://xml.org/sax/properties/lexical-handler",
                serializer);
        parser.parse(new InputSource(in));
        out.flush();
        out.close();
    }

#end
#end
#No. 187735
#File: E:\bishe\1\Xml2JsonUtils.java
#Comment:
	/**
	 * Transform XML to JSON
	 *
	 * @param xml
	 * @return
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 * @throws IOException
	 */

#Code:
	public static String toJson(String xml) throws ParserConfigurationException, SAXException, IOException {
		JsonObject rootJson = new JsonObject();
		DocumentBuilder dBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
		Document doc = dBuilder.parse(new InputSource(new StringReader(xml)));
		if (doc.hasChildNodes()) {
			traverseNode(doc, rootJson, null);
		}
		Gson gson = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();
		String json = gson.toJson(rootJson);

		return json;
	}

#end
#end
#No. 187736
#File: E:\bishe\1\Xml2JsonUtils.java
#Comment:
	/**
	 * Print the XML with indentation
	 *
	 * @param xml
	 * @return pretty xml
	 * @throws TransformerFactoryConfigurationError
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 * @throws IOException
	 * @throws TransformerException
	 */

#Code:
	public String prettyPrintXml(String xml)
			throws TransformerFactoryConfigurationError, ParserConfigurationException, SAXException, IOException, TransformerException {
		Transformer transformer = TransformerFactory.newInstance().newTransformer();
		transformer.setOutputProperty(OutputKeys.INDENT, "yes");
		transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
		StreamResult result = new StreamResult(new StringWriter());
		DocumentBuilder dBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
		Document doc = dBuilder.parse(new InputSource(new StringReader(xml)));
		DOMSource source = new DOMSource(doc);
		transformer.transform(source, result);
		return result.getWriter().toString();
	}

#end
#end
#No. 187737
#File: E:\bishe\1\XML2XML.java
#Comment:
    /**
     * @param args
     */

#Code:
    public static void main(String[] args) throws SAXException,
            ParserConfigurationException, MalformedURLException, IOException,
            TransformerException {
        InputStream in;
        OutputStream out;

        switch (args.length) {
            case 0:
                in = System.in;
                out = System.out;
                break;
            case 1:
                in = new FileInputStream(args[0]);
                out = System.out;
                break;
            case 2:
                in = new FileInputStream(args[0]);
                out = new FileOutputStream(args[1]);
                break;
            default:
                System.err.println("Too many arguments. No arguments to use stdin/stdout. One argument to reading from file and write to stdout. Two arguments to read from first file and write to second.");
                System.exit(1);
                return;
        }

        ContentHandler serializer = new NameCheckingXmlSerializer(out);
        
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setValidating(false);
        XMLReader parser = factory.newSAXParser().getXMLReader();
        parser.setErrorHandler(new SystemErrErrorHandler());
        parser.setContentHandler(serializer);
        parser.setProperty("http://xml.org/sax/properties/lexical-handler",
                serializer);
        parser.parse(new InputSource(in));
        out.flush();
        out.close();
    }

#end
#end
#No. 187738
#File: E:\bishe\1\XmlAdapter.java
#Comment:
    /**
     * Returns a new pull parser with namespace support.
     */

#Code:
    private static XmlPullParser newPullParser() {
        try {
            KXmlParser parser = new KXmlParser();
//            parser.setFeature(XmlPullParser.FEATURE_PROCESS_DOCDECL, true);
            parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, true);
            return parser;
        } catch (XmlPullParserException e) {
            throw new AssertionError(e);
        }
    }

#end
#end
#No. 187739
#File: E:\bishe\1\XmlAdapter.java
#Comment:
    /**
     * Creates a new xml serializer.
     */

#Code:
    private static XmlSerializer newSerializer() {
        try {
            return XmlSerializerFactory.instance.newSerializer();
        } catch (XmlPullParserException e) {
            throw new AssertionError(e);
        }
    }

#end
#end
#No. 187740
#File: E:\bishe\1\XmlAdapters.java
#Comment:
    /**
     * Returns an opaque object that's equal if the type and annotations are equal.
     */

#Code:
    private Object cacheKey(Type type, Set<? extends Annotation> annotations) {
        if (annotations.isEmpty()) return type;
        return Arrays.asList(type, annotations);
    }


#end
#end
#No. 187742
#File: E:\bishe\1\XmlaHandler.java
#Comment:
        /**
         * Iterates over the resust writing tabular rows.
         *
         * @param writer Writer
         * @throws org.xml.sax.SAXException on error
         */

#Code:
        private void iterate(SaxWriter writer)
            throws SAXException, OlapException
        {
            switch (axisCount) {
            case 0:
                // For MDX like: SELECT FROM Sales
                emitCell(writer, cellSet.getCell(posList));
                return;
            default:
//                throw new SAXException("Too many axes: " + axisCount);
                iterate(writer, axisCount - 1, 0);
                break;
            }
        }

#end
#end
#No. 187743
#File: E:\bishe\1\XmlaHandler.java
#Comment:
    /**
     * Gets a Connection given a catalog (and implicitly the catalog's data
     * source) and the name of a user role.
     *
     * <p>If you want to pass in a role object, and you are making the call
     * within the same JVM (i.e. not RPC), register the role using
     * {@code mondrian.olap.MondrianServer.getLockBox()} and pass in the moniker
     * for the generated lock box entry. The server will retrieve the role from
     * the moniker.
     *
     * @param catalog Catalog name
     * @param schema Schema name
     * @param role User role name
     * @return Connection
     * @throws XmlaException If error occurs
     */

#Code:
    protected OlapConnection getConnection(
        String catalog,
        String schema,
        final String role)
        throws XmlaException
    {
        return this.getConnection(
            catalog, schema, role,
            new Properties());
    }

#end
#end
#No. 187744
#File: E:\bishe\1\XmlaHandler.java
#Comment:
    /**
     * Gets a Connection given a catalog (and implicitly the catalog's data
     * source) and the name of a user role.
     *
     * <p>If you want to pass in a role object, and you are making the call
     * within the same JVM (i.e. not RPC), register the role using
     * {@code mondrian.olap.MondrianServer.getLockBox()} and pass in the moniker
     * for the generated lock box entry. The server will retrieve the role from
     * the moniker.
     *
     * @param catalog Catalog name
     * @param schema Schema name
     * @param role User role name
     * @param props Properties to pass down to the native driver.
     * @return Connection
     * @throws XmlaException If error occurs
     */

#Code:
    protected OlapConnection getConnection(
        String catalog,
        String schema,
        final String role,
        Properties props)
        throws XmlaException
    {
        try {
            return
                connectionFactory.getConnection(
                    catalog, schema, role, props);
        } catch (SecurityException e) {
            throw new XmlaException(
                CLIENT_FAULT_FC,
                HSB_ACCESS_DENIED_CODE,
                HSB_ACCESS_DENIED_FAULT_FS,
                e);
        } catch (SQLException e) {
            throw new XmlaException(
                CLIENT_FAULT_FC,
                HSB_CONNECTION_DATA_SOURCE_CODE,
                HSB_CONNECTION_DATA_SOURCE_FAULT_FS,
                e);
        }
    }

#end
#end
#No. 187745
#File: E:\bishe\1\XmlAnalyzer.java
#Comment:
    /**
     * This method is called to provide a <code>DefaultHandler</code> for each file being processed.
     *
     * @since 1.4
     */

#Code:
    @Nonnull
    protected abstract DefaultHandler createHandlerFor(@Nonnull AnalysisContext analysisContext);

    @SuppressWarnings("PMD.EmptyCatchBlock")
    private void analyzeXmlFile(@Nonnull AnalysisContext analysisContext, @Nonnull File file) {
        InputStream in = null;
        try {
            in = new FileInputStream(file);
            parser.parse(in, createHandlerFor(analysisContext));
        } catch (StopParsing command) {
            // just do nothing
        } catch (Exception e) {
            throw new RuntimeException("Failed to parse [" + file + "]!", e);
        } finally {
            IOUtils.closeQuietly(in);
        }

#end
#end
#No. 187746
#File: E:\bishe\1\XMLAnalyzerTest.java
#Comment:
    /**
     * XML special chars inside a string were not escaped if single quotes
     * were used around the string. Bug #15859.
     */

#Code:
    @Test
    public void xrefWithSpecialCharsInStringLiterals() throws IOException {
        StringReader input =
                new StringReader("<foo xyz='<betweensinglequotes>'> </foo>");
        StringWriter output = new StringWriter();
        XMLAnalyzer.writeXref(input, output, null, null);
        assertTrue(output.toString().contains("&lt;betweensinglequotes&gt;"));

        input = new StringReader("<foo xyz=\"<betweendoublequotes>\"> </foo>");
        output = new StringWriter();
        XMLAnalyzer.writeXref(input, output, null, null);
        assertTrue(output.toString().contains("&lt;betweendoublequotes&gt;"));
    }

#end
#end
#No. 187747
#File: E:\bishe\1\XmlaServlet.java
#Comment:
    /**
     * Gets (creating if needed) the XmlaHandler.
     *
     * @return XMLA handler
     */

#Code:
    protected XmlaHandler getXmlaHandler() {
        if (this.xmlaHandler == null) {
            this.xmlaHandler =
                new XmlaHandler(
                    connectionFactory,
                    "cxmla");
        }
        return this.xmlaHandler;
    }

#end
#end
#No. 187748
#File: E:\bishe\1\XmlaServlet.java
#Comment:
    /**
     * Registers a callback.
     */

#Code:
    protected final void addCallback(XmlaRequestCallback callback) {
        callbackList.add(callback);
    }

#end
#end
#No. 187749
#File: E:\bishe\1\XmlaServlet.java
#Comment:
    /**
     * Returns the list of callbacks. The list is immutable.
     *
     * @return list of callbacks
     */

#Code:
    protected final List<XmlaRequestCallback> getCallbacks() {
        return Collections.unmodifiableList(callbackList);
    }

#end
#end
#No. 187750
#File: E:\bishe\1\XmlaServlet.java
#Comment:
    /**
     * Initialize character encoding
     */

#Code:
    protected void initCharEncodingHandler(ServletConfig servletConfig) {
        String paramValue = servletConfig.getInitParameter(PARAM_CHAR_ENCODING);
        if (paramValue != null) {
            this.charEncoding = paramValue;
        } else {
            this.charEncoding = null;
            LOGGER.warn("Use default character encoding from HTTP client");
        }
    }

#end
#end
#No. 187751
#File: E:\bishe\1\XmlAttributeAdapter.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 * @param list
	 *            the list to adapt
	 * @param node
	 *            the node containing those attributes
	 */

#Code:
	public XmlAttributeAdapter(final Context context,
			final List<XmlAttribute> list, final XmlNode node) {
		super(context, R.layout.item_attribute, list);
		mInflater = (LayoutInflater) getContext().getSystemService(
				Context.LAYOUT_INFLATER_SERVICE);
		mList = list;
		mNode = node;
	}

#end
#end
#No. 187752
#File: E:\bishe\1\XmlAttributeAdapter.java
#Comment:
	/**
	 * @see android.widget.ArrayAdapter#getView(int, android.view.View,
	 *      android.view.ViewGroup)
	 */

#Code:
	public View getView(final int position, final View convertView,
			final ViewGroup parent) {
		View view = convertView;

		if (view == null) {
			view = mInflater.inflate(R.layout.item_attribute, parent, false);
		}

		final XmlAttribute attr = getItem(position);

		if (attr != null) {
			TextView text;
			text = (TextView) view.findViewById(R.id.textAttribute);
			text.setText(XmlNodeStyler.getAttributeSpan(attr, getContext()),
					BufferType.SPANNABLE);

			text.setHorizontallyScrolling(true);
			text.setMovementMethod(new ScrollingMovementMethod());
			text.scrollTo(0, 0);

			view.findViewById(R.id.buttonDelete).setOnClickListener(
					new OnClickListener() {
						public void onClick(final View view) {
							promptDeleteAttribute(attr);
						}
					});

			view.findViewById(R.id.buttonEdit).setOnClickListener(
					new OnClickListener() {
						public void onClick(final View view) {
							promptEditAttribute(attr);
						}
					});
		}

		return view;
	}

#end
#end
#No. 187753
#File: E:\bishe\1\XmlAttributeAdapter.java
#Comment:
	/**
	 * @param attr
	 *            the attribute to delete
	 */

#Code:
	protected void promptDeleteAttribute(final XmlAttribute attr) {
		AlertDialog.Builder builder;

		builder = new AlertDialog.Builder(getContext());
		builder.setTitle(R.string.ui_delete);
		builder.setCancelable(true);
		builder.setMessage("Are you sure you want to delete this attribute ?");

		builder.setPositiveButton(R.string.ui_delete,
				new DialogInterface.OnClickListener() {
					public void onClick(final DialogInterface dialog,
							final int which) {
						remove(attr);
						notifyDataSetChanged();
					}
				});
		builder.setNegativeButton(R.string.ui_cancel,
				new DialogInterface.OnClickListener() {
					public void onClick(final DialogInterface dialog,
							final int which) {
						// cancel
					}
				});

		builder.create().show();
	}

#end
#end
#No. 187754
#File: E:\bishe\1\XmlAttributeAdapter.java
#Comment:
	/**
	 * @param attr
	 *            the attribute to edit
	 */

#Code:
	protected void promptEditAttribute(final XmlAttribute attr) {
		AttributeEditDialog dlg;

		dlg = new AttributeEditDialog(getContext(), mInflater, attr);
		dlg.setNode(mNode);
		dlg.setSiblingsAttribute(mList);

		dlg.setOnDismissListener(new OnDismissListener() {
			public void onDismiss(final DialogInterface dialog) {
				notifyDataSetChanged();
			}
		});
		dlg.show();
	}

#end
#end
#No. 187755
#File: E:\bishe\1\XmlAttributeAdapter.java
#Comment:
	/**
	 * Edits the given attribute
	 * 
	 * @param attr
	 *            the attribute to edit
	 */

#Code:
	public void editAttribute(final XmlAttribute attr) {
		if (mList.contains(attr)) {
			promptEditAttribute(attr);
		}
	}

#end
#end
#No. 187756
#File: E:\bishe\1\XMLAttrSpan.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 */

#Code:
	public XMLAttrSpan(final Context context) {
		super(context, R.style.Axel_Xml_Tag_Attribute);
	}

#end
#end
#No. 187757
#File: E:\bishe\1\XMLAttrValueSpan.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 */

#Code:
	public XMLAttrValueSpan(final Context context) {
		super(context, R.style.Axel_Xml_Tag_AttributeValue);
	}

#end
#end
#No. 187758
#File: E:\bishe\1\XmlBeanFactory.java
#Comment:
    /**
     * Creates a new object of the specified type configured by parsing the
     * provided XML.<br/>
     * The underlying XmlBean will start at the root of the XML and will access
     * private fields as needed.
     * @param xml The XML String containing the document to configure the object
     * @param type The class to create a new object instance
     * @return A new object configured by the XML
     * @see XmlBean#configure(java.lang.String, java.lang.Object) 
     */

#Code:
    static public <E> E create(String xml, Class<E> type) throws XmlBeanException, IOException, SAXException, InstantiationException, IllegalAccessException {
        Object obj = type.newInstance();
        configure(xml, obj);
        return (E)obj;
    }

#end
#end
#No. 187759
#File: E:\bishe\1\XmlBeanFactory.java
#Comment:
    /**
     * Creates a new object of the specified type configured by parsing the
     * provided XML.<br/>
     * The underlying XmlBean will start at the root of the XML and will access
     * private fields as needed.
     * @param is The InputStream containing the XML document to configure the object
     * @param type The class to create a new object instance
     * @return A new object configured by the XML
     * @see XmlBean#configure(java.io.InputStream, java.lang.Object) 
     */

#Code:
    static public <E> E create(InputStream is, Class<E> type) throws XmlBeanException, IOException, SAXException, InstantiationException, IllegalAccessException {
        Object obj = type.newInstance();
        configure(is, obj);
        return (E)obj;
    }

#end
#end
#No. 187760
#File: E:\bishe\1\XmlBeanFactory.java
#Comment:
    /**
     * Creates a new object of the specified type configured by parsing the
     * provided XML.<br/>
     * The underlying XmlBean will start at the root of the XML and will access
     * private fields as needed.
     * @param file The file containing the XML document to configure the object
     * @param type The class to create a new object instance
     * @return A new object configured by the XML
     * @see XmlBean#configure(java.io.File, java.lang.Object) 
     */

#Code:
    static public <E> E create(File file, Class<E> type) throws XmlBeanException, IOException, SAXException, InstantiationException, IllegalAccessException {
        Object obj = type.newInstance();
        configure(file, obj);
        return (E)obj;
    }

#end
#end
#No. 187761
#File: E:\bishe\1\XmlBeanFactory.java
#Comment:
    /**
     * Configures the object by parsing the provided XML.<br/>
     * The underlying XmlBean will start at the root of the XML and will access
     * private fields as needed.
     * @param xml The XML String containing the document to configure the object
     * @param obj The object instance to configure
     * @see XmlBean#configure(java.lang.String, java.lang.Object) 
     */

#Code:
    static public void configure(String xml, Object obj) throws XmlBeanException, IOException, SAXException {
        createXmlBean().configure(xml, obj);
    }

#end
#end
#No. 187762
#File: E:\bishe\1\XmlBeanFactory.java
#Comment:
    /**
     * Configures the object by parsing the provided XML.<br/>
     * The underlying XmlBean will start at the root of the XML and will access
     * private fields as needed.
     * @param is The InputStream containing the XML document to configure the object
     * @param obj The object instance to configure
     * @see XmlBean#configure(java.io.InputStream, java.lang.Object) 
     */

#Code:
    static public void configure(InputStream is, Object obj) throws XmlBeanException, IOException, SAXException {
        createXmlBean().configure(is, obj);
    }

#end
#end
#No. 187763
#File: E:\bishe\1\XmlBeanFactory.java
#Comment:
    /**
     * Configures the object by parsing the provided XML.<br/>
     * The underlying XmlBean will start at the root of the XML and will access
     * private fields as needed.
     * @param file The file containing the XML document to configure the object
     * @param obj The object instance to configure
     * @see XmlBean#configure(java.io.File, java.lang.Object) 
     */

#Code:
    static public void configure(File file, Object obj) throws XmlBeanException, IOException, SAXException {
        createXmlBean().configure(file, obj);
    }

#end
#end
#No. 187764
#File: E:\bishe\1\XmlBeanModifiedRootTest.java
#Comment:
    /**
     * Modifies what the "root" element is in the xml document when we call
     * the configure() method.
     */

#Code:
    @Test
    public void configureModifiedRoot() throws Exception {
        String xml = new StringBuilder(200)
            .append("<configuration>")
            .append(" <datasource>")
            .append("  <name>main</name>")
            .append(" </datasource>")
            .append("</configuration>")
            .toString();

        // object we'll configure
        TestConfig config = new TestConfig();

        // configure it using default options
        XmlBean bean = new XmlBean();
        bean.configure(xml, config, "/configuration/datasource");

        // confirm properties
        Assert.assertEquals("main", config.name);
    }

#end
#end
#No. 187765
#File: E:\bishe\1\XmlBeanTest.java
#Comment:
    /**
     * Xbean attempts to create a new instance of a class that doesn't have
     * any empty constructor.  Causes an instantiation exception to be thrown.
     */

#Code:
    @Test(expected=XmlBeanClassException.class)
    public void configureComplexWithBadConstructor() throws Exception {
        // build xml
        StringBuilder string0 = new StringBuilder(200)
                .append("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n")
                .append("<configuration>\n")
                .append("   <complexServer />\n")
                .append("</configuration>")
                .append("");

        // parse xml
        ByteArrayInputStream is = new ByteArrayInputStream(string0.toString().getBytes());
        XmlParser parser = new XmlParser();
        XmlParser.Node rootNode = parser.parse(is);

        // object we'll configure
        ComplexConfiguration config = new ComplexConfiguration();

        // configure it using default options
        XmlBean bean = new XmlBean();
        bean.setAccessPrivateProperties(true);
        bean.configure(rootNode, config);
    }

#end
#end
#No. 187766
#File: E:\bishe\1\XmlBeanTest.java
#Comment:
    /**
     * Tests if failing to configure a child complex object causes a new reference
     * to never be saved on the parent object.  Different from previous test
     * since a new instance was created and configured and then NOT saved.
     */

#Code:
    @Test
    public void configureComplexWithPropertyNotFoundExceptionEnsureNoPropertiesChanged() throws Exception {
        // build xml
        StringBuilder string0 = new StringBuilder(200)
                .append("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n")
                .append("<configuration>\n")
                .append("   <url>http://www.google.com/</url>\n")
                .append("   <server>\n")
                .append("     <host>www2.google.com</host>\n")      // this should be changed
                .append("     <port2>80</port2>\n")                 // this should cause an error to be thrown and caused "server" to not be saved
                .append("   </server>\n")
                .append("</configuration>")
                .append("");

        // parse xml
        ByteArrayInputStream is = new ByteArrayInputStream(string0.toString().getBytes());
        XmlParser parser = new XmlParser();
        XmlParser.Node rootNode = parser.parse(is);

        // object we'll configure
        ComplexConfiguration config = new ComplexConfiguration();

        // configure it using default options
        XmlBean bean = new XmlBean();

        try {
            bean.configure(rootNode, config);
            Assert.fail("Configure should have failed");
        } catch (XmlBeanException e) {
            // ignore it
        }

        // server should remain the same
        Assert.assertNull(config.getServer());
        Assert.assertEquals("http://www.google.com/", config.url);
    }


#end
#end
#No. 187768
#File: E:\bishe\1\XmlBodyReaderMountPointTest.java
#Comment:
    /**
     * Test when container with the same name is placed in two modules (foo-module and bar-module). Namespace must be
     * used to distinguish between them to find correct one. Check if container was found not only according to its name
     * but also by correct namespace used in payload.
     */

#Code:
    @Test
    public void findFooContainerUsingNamespaceTest() throws Exception {
        mockBodyReader("instance-identifier-module:cont/yang-ext:mount", this.xmlBodyReader, true);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlDataFindFooContainer.xml");
        final NormalizedNodeContext returnValue = this.xmlBodyReader
                .readFrom(null, null, null, this.mediaType, null, inputStream);

        // check return value
        checkMountPointNormalizedNodeContext(returnValue);
        // check if container was found both according to its name and namespace
        assertEquals("Not correct container found, name was ignored",
                "foo-bar-container", returnValue.getData().getNodeType().getLocalName());
        assertEquals("Not correct container found, namespace was ignored",
                "foo:module", returnValue.getData().getNodeType().getNamespace().toString());
    }

#end
#end
#No. 187769
#File: E:\bishe\1\XmlBodyReaderMountPointTest.java
#Comment:
    /**
     * Test when container with the same name is placed in two modules (foo-module and bar-module). Namespace must be
     * used to distinguish between them to find correct one. Check if container was found not only according to its name
     * but also by correct namespace used in payload.
     */

#Code:
    @Test
    public void findBarContainerUsingNamespaceTest() throws Exception {
        mockBodyReader("instance-identifier-module:cont/yang-ext:mount", this.xmlBodyReader, true);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlDataFindBarContainer.xml");
        final NormalizedNodeContext returnValue = this.xmlBodyReader
                .readFrom(null, null, null, this.mediaType, null, inputStream);

        // check return value
        checkMountPointNormalizedNodeContext(returnValue);
        // check if container was found both according to its name and namespace
        assertEquals("Not correct container found, name was ignored",
                "foo-bar-container", returnValue.getData().getNodeType().getLocalName());
        assertEquals("Not correct container found, namespace was ignored",
                "bar:module", returnValue.getData().getNodeType().getNamespace().toString());
    }

#end
#end
#No. 187770
#File: E:\bishe\1\XmlBodyReaderMountPointTest.java
#Comment:
    /**
     * Test PUT operation when message root element is not the same as the last element in request URI.
     * PUT operation message should always start with schema node from URI otherwise exception should be
     * thrown.
     */

#Code:
    @Test
    public void wrongRootElementTest() throws Exception {
        mockBodyReader("instance-identifier-module:cont/yang-ext:mount", this.xmlBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class.getResourceAsStream(
                "/instanceidentifier/xml/bug7933.xml");
        try {
            this.xmlBodyReader.readFrom(null, null, null, this.mediaType, null, inputStream);
            Assert.fail("Test should fail due to malformed PUT operation message");
        } catch (final RestconfDocumentedException exception) {
            final RestconfError restconfError = exception.getErrors().get(0);
            Assert.assertEquals(RestconfError.ErrorType.PROTOCOL, restconfError.getErrorType());
            Assert.assertEquals(RestconfError.ErrorTag.MALFORMED_MESSAGE, restconfError.getErrorTag());
        }
    }

#end
#end
#No. 187771
#File: E:\bishe\1\XmlBodyReaderTest.java
#Comment:
    /**
     * Test when container with the same name is placed in two modules
     * (foo-module and bar-module). Namespace must be used to distinguish
     * between them to find correct one. Check if container was found not only
     * according to its name but also by correct namespace used in payload.
     */

#Code:
    @Test
    public void findFooContainerUsingNamespaceTest() throws Exception {
        mockBodyReader("", this.xmlBodyReader, true);
        final InputStream inputStream = XmlBodyReaderTest.class
                .getResourceAsStream("/instanceidentifier/xml/xmlDataFindFooContainer.xml");
        final NormalizedNodeContext returnValue = this.xmlBodyReader.readFrom(null, null, null, this.mediaType, null,
                inputStream);

        // check return value
        checkNormalizedNodeContext(returnValue);
        // check if container was found both according to its name and namespace
        assertEquals("Not correct container found, name was ignored", "foo-bar-container",
                returnValue.getData().getNodeType().getLocalName());
        assertEquals("Not correct container found, namespace was ignored", "foo:module",
                returnValue.getData().getNodeType().getNamespace().toString());
    }

#end
#end
#No. 187772
#File: E:\bishe\1\XmlBodyReaderTest.java
#Comment:
    /**
     * Test when container with the same name is placed in two modules
     * (foo-module and bar-module). Namespace must be used to distinguish
     * between them to find correct one. Check if container was found not only
     * according to its name but also by correct namespace used in payload.
     */

#Code:
    @Test
    public void findBarContainerUsingNamespaceTest() throws Exception {
        mockBodyReader("", this.xmlBodyReader, true);
        final InputStream inputStream = XmlBodyReaderTest.class
                .getResourceAsStream("/instanceidentifier/xml/xmlDataFindBarContainer.xml");
        final NormalizedNodeContext returnValue = this.xmlBodyReader.readFrom(null, null, null, this.mediaType, null,
                inputStream);

        // check return value
        checkNormalizedNodeContext(returnValue);
        // check if container was found both according to its name and namespace
        assertEquals("Not correct container found, name was ignored", "foo-bar-container",
                returnValue.getData().getNodeType().getLocalName());
        assertEquals("Not correct container found, namespace was ignored", "bar:module",
                returnValue.getData().getNodeType().getNamespace().toString());
    }

#end
#end
#No. 187773
#File: E:\bishe\1\XmlBodyReaderTest.java
#Comment:
    /**
     * Test PUT operation when message root element is not the same as the last element in request URI.
     * PUT operation message should always start with schema node from URI otherwise exception should be
     * thrown.
     */

#Code:
    @Test
    public void wrongRootElementTest() throws Exception {
        mockBodyReader("instance-identifier-module:cont", this.xmlBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class.getResourceAsStream(
                "/instanceidentifier/xml/bug7933.xml");
        try {
            this.xmlBodyReader.readFrom(null, null, null, this.mediaType, null, inputStream);
            Assert.fail("Test should fail due to malformed PUT operation message");
        } catch (final RestconfDocumentedException exception) {
            final RestconfError restconfError = exception.getErrors().get(0);
            Assert.assertEquals(RestconfError.ErrorType.PROTOCOL, restconfError.getErrorType());
            Assert.assertEquals(RestconfError.ErrorTag.MALFORMED_MESSAGE, restconfError.getErrorTag());
        }
    }

#end
#end
#No. 187774
#File: E:\bishe\1\XmlCalendar2Date.java
#Comment:
	/*
	 * Converts java.util.Date to javax.xml.datatype.XMLGregorianCalendar
	 */

#Code:
	public static XMLGregorianCalendar toXMLGregorianCalendar(Date date) {
		GregorianCalendar gCalendar = new GregorianCalendar();
		gCalendar.setTime(date);
		XMLGregorianCalendar xmlCalendar = null;
		try {
			xmlCalendar = DatatypeFactory.newInstance().newXMLGregorianCalendar(gCalendar);
		} catch (DatatypeConfigurationException ex) {
//			Logger.getLogger(StringReplace.class.getName()).log(Level.SEVERE, null, ex);
		}
		return xmlCalendar;
	}

#end
#end
#No. 187775
#File: E:\bishe\1\XmlCalendar2Date.java
#Comment:
	/*
	 * Converts XMLGregorianCalendar to java.util.Date in Java
	 */

#Code:
	public static Date toDate(XMLGregorianCalendar calendar) {
		if (calendar == null) {
			return null;
		}
		return calendar.toGregorianCalendar().getTime();
	}

#end
#end
#No. 187776
#File: E:\bishe\1\XMLCDataSpan.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 */

#Code:
	public XMLCDataSpan(final Context context) {
		super(context, R.style.Axel_Xml_CData);
	}

#end
#end
#No. 187777
#File: E:\bishe\1\XmlClauseStatus.java
#Comment:
/**
 * <p>Java class for clauseStatus.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="clauseStatus">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="MATRIX"/>
 *     &lt;enumeration value="SUBORDINATE"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "clauseStatus")
@XmlEnum
public enum XmlClauseStatus {

    MATRIX,
    SUBORDINATE;

    public String value() {
        return name();
    }

    public static XmlClauseStatus fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 187778
#File: E:\bishe\1\XMLCommentSpan.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 */

#Code:
	public XMLCommentSpan(final Context context) {
		super(context, R.style.Axel_Xml_Comment);
	}

#end
#end
#No. 187779
#File: E:\bishe\1\XmlCompressedTreeParser.java
#Comment:
	/**
	 * @see fr.xgouchet.apkxmllib.CompressedXmlParserListener#startDocument()
	 */

#Code:
	@Override
	public void startDocument() {
		createRootDocument();
	}

#end
#end
#No. 187780
#File: E:\bishe\1\XmlCompressedTreeParser.java
#Comment:
	/**
	 * @see fr.xgouchet.apkxmllib.CompressedXmlParserListener#endDocument()
	 */

#Code:
	@Override
	public void endDocument() {
		XmlNode decl = XmlNode.createDocumentDeclaration("1.0", "UTF-8", false);
		onCreateNode(decl);
	}

#end
#end
#No. 187781
#File: E:\bishe\1\XmlCompressedTreeParser.java
#Comment:
	/**
	 * @see fr.xgouchet.apkxmllib.CompressedXmlParserListener#startPrefixMapping(java.lang.String,
	 *      java.lang.String)
	 */

#Code:
	@Override
	public void startPrefixMapping(final String prefix, final String uri) {
		declareNamespace(prefix, uri);
	}

#end
#end
#No. 187782
#File: E:\bishe\1\XmlCompressedTreeParser.java
#Comment:
	/**
	 * @see fr.xgouchet.apkxmllib.CompressedXmlParserListener#startElement(java.lang.String,
	 *      java.lang.String, java.lang.String,
	 *      fr.xgouchet.apkxmllib.Attribute[])
	 */

#Code:
	@Override
	public void startElement(final String uri, final String localName,
			final String qName, final Attribute[] atts) {
		String prefix = getPrefixForUri(uri);

		XmlNode tag = XmlNode.createElement(prefix, localName);

		for (Attribute attr : atts) {
			if (attr.getNamespace() == null) {
				prefix = null; // NOPMD
			} else {
				prefix = getPrefixForUri(attr.getNamespace());
			}

			tag.getContent().addAttribute(prefix, attr.getName(),
					attr.getValue());
		}

		onCreateElement(tag);
	}

#end
#end
#No. 187783
#File: E:\bishe\1\XmlCompressedTreeParser.java
#Comment:
	/**
	 * @see fr.xgouchet.apkxmllib.CompressedXmlParserListener#endElement(java.lang.String,
	 *      java.lang.String, java.lang.String)
	 */

#Code:
	@Override
	public void endElement(final String uri, final String localName,
			final String qName) {
		onCloseElement();
	}

#end
#end
#No. 187784
#File: E:\bishe\1\XmlCompressedTreeParser.java
#Comment:
	/**
	 * @see fr.xgouchet.apkxmllib.CompressedXmlParserListener#characterData(java.lang.String)
	 */

#Code:
	@Override
	public void characterData(final String data) {
		onCreateNode(XmlNode.createCDataSection(data));
	}

#end
#end
#No. 187785
#File: E:\bishe\1\XmlCompressedTreeParser.java
#Comment:
	/**
	 * @see fr.xgouchet.apkxmllib.CompressedXmlParserListener#text(java.lang.String)
	 */

#Code:
	@Override
	public void text(final String data) {
		onCreateNode(XmlNode.createText(data));
	}

#end
#end
#No. 187786
#File: E:\bishe\1\XmlCompressedTreeParser.java
#Comment:
	/**
	 * @see fr.xgouchet.apkxmllib.CompressedXmlParserListener#processingInstruction(java.lang.String,
	 *      java.lang.String)
	 */

#Code:
	@Override
	public void processingInstruction(final String target, final String data) {
		XmlNode pi;

		pi = XmlNode.createProcessingInstruction(target, data);

		onCreateNode(pi);
	}

#end
#end
#No. 187788
#File: E:\bishe\1\XmlConfigurationDaoImpl.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public List<ConfigurationNode> getNodes(final RootNode rootNode) {
        return this.rootNode.getConfigurationNodes(rootNode);
    }

#end
#end
#No. 187789
#File: E:\bishe\1\XmlConfigurationDaoImpl.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public ConfigurationNode getNode(final RootNode rootNode, final String nodeId) throws UnknownNodeException {
        return this.rootNode.getConfigurationNodes(rootNode).stream()
                .filter(node -> node.getId().equals(nodeId))
                .findFirst()
                .orElseThrow(() -> new UnknownNodeException(nodeId));
    }

#end
#end
#No. 187790
#File: E:\bishe\1\XmlConfigurationDaoImpl.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public Optional<ConfigurationNode> findNode(final RootNode rootNode, final String excludedNodeId, final String label, final String path) {
        return this.rootNode.getConfigurationNodes(rootNode).stream().filter(node -> {
            if (excludedNodeId != null && excludedNodeId.equals(node.getId())) {
                return false;
            } else if (node.getLabel().equals(label) || node.getPath().equals(path)) {
                return true;
            }
            return false;
        }).findFirst();
    }

#end
#end
#No. 187791
#File: E:\bishe\1\XmlConfigurationDaoImpl.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void save() throws IOException {
        try (OutputStream out = new FileOutputStream(getConfigFile().toFile())) {
            // Save configuration to XML
            xstream.toXML(rootNode, out);
        }
    }

#end
#end
#No. 187792
#File: E:\bishe\1\XmlConfigurationDaoImpl.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <T> T getParameter(final ConfigurationParameter<T> parameter) {
        String value = this.rootNode.getParameter(parameter.getName());
        return value != null ? parameter.parse(value) : parameter.getDefaultValue();
    }

#end
#end
#No. 187793
#File: E:\bishe\1\XmlConfigurationDaoImpl.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public <T> void setParameter(final ConfigurationParameter<T> parameter, final T value) {
        this.rootNode.setParameter(parameter.getName(), parameter.format(value));
    }

#end
#end
#No. 187794
#File: E:\bishe\1\XmlConfigurationDaoImpl.java
#Comment:
    /**
     * Get Holmes configuration file path.
     *
     * @return configuration file path
     */

#Code:
    private Path getConfigFile() {
        Path confPath = Paths.get(localHolmesDataDir, CONF_DIR);
        if (Files.isDirectory(confPath) || confPath.toFile().mkdirs()) {
            return Paths.get(confPath.toString(), CONF_FILE_NAME);
        }

        throw new HolmesRuntimeException("Failed to create " + confPath);
    }

#end
#end
#No. 187795
#File: E:\bishe\1\XmlConfigurationDaoImpl.java
#Comment:
    /**
     * Load configuration from Xml file.
     *
     * @throws IOException Signals that an I/O exception has occurred.
     */

#Code:
    private void loadConfig() throws IOException {
        boolean configLoaded = false;

        Path confFile = getConfigFile();
        if (Files.isReadable(confFile)) {
            try (InputStream in = new FileInputStream(confFile.toFile())) {
                // Load configuration from XML
                rootNode = (XmlRootNode) xstream.fromXML(in);
                configLoaded = true;
            }
        }

        if (rootNode == null) {
            rootNode = new XmlRootNode();
        }
        rootNode.checkDefaultValues();
        rootNode.checkParameters();

        // Save default config if nothing is loaded
        if (!configLoaded) {
            save();
        }
    }


#end
#end
#No. 187797
#File: E:\bishe\1\XmlConfigUtil.java
#Comment:
    /**
     * Parse xml configuration and return a list of attributes belonging to one
     * or more elements with the specific key. It returns a list preserving the
     * order of elements in xml.
     *
     * @param config
     * @param key
     *            identifies xml elements with the specific tag
     * @return
     */

#Code:
    public static List<Map<String, Object>> parseMultiNodesAttributes(
            HierarchicalConfiguration config, String key)
    {
        List<Map<String, Object>> result = null;

        // get a list of subnode configurations for all configuration nodes
        // selected by the given key, e.g. "node.inbound.listener"
        List< ? > list = config.configurationsAt(key);
        if (list != null)
        {
            result = new ArrayList<Map<String, Object>>();
            for (Iterator< ? > iter = list.iterator(); iter.hasNext();)
            {
                HierarchicalConfiguration sub = (HierarchicalConfiguration) iter
                        .next();
                Node root = sub.getRoot();

                Map<String, Object> attributes = new HashMap<String, Object>(
                        root.getAttributeCount());

                // get attribute nodes
                List< ? > attrs = root.getAttributes();
                for (Object attr : attrs)
                {
                    ConfigurationNode nd = (ConfigurationNode) attr;
                    attributes.put(nd.getName(), nd.getValue());
                }
                result.add(attributes);
            }
        }

        return result;
    }



#end
#end
#No. 187799
#File: E:\bishe\1\XmlDataLoader.java
#Comment:
	/**
	 * Loads XML with quiz and returns {@link Quiz} object.
	 * 
	 * @return quiz object
	 * @throws Exception
	 *             when deserialization fails
	 */

#Code:
	public Quiz loadXml() throws Exception {
		Resources resources = context.getResources();
		String languageCode = getLanguageCode(resources);
		// Get XML name using reflection
		Field field = null;
		String prefix = context.getString(R.string.xml_prefix);
		try {
			field = R.raw.class.getField(prefix + languageCode);
		} catch (NoSuchFieldException e) {
			// If there is no language available use default
			field = R.raw.class.getField(prefix + context.getString(R.string.default_language));
		}
		// Create InputSream from XML resource
		InputStream source = resources.openRawResource(field.getInt(null));
		// Parse XML
		Serializer serializer = new Persister();
		return serializer.read(Quiz.class, source);
	}


#end
#end
#No. 187801
#File: E:\bishe\1\XMLDataPersister.java
#Comment:
    /**
     * Called at the beginning of the actual save operation to initialize
     * the save, etc.
     *
     * @throws CurnException on error
     */

#Code:
    protected void startSaveOperation() throws CurnException
    {
        assert(isEnabled());

        log.debug("Saving feed metadata to \"" + metadataFile.getPath() +
                  "\". Total backups=" + totalCacheBackups);

        // Create the DOM's root element.

        rootElementForSaving = new Element(XML_ROOT_ELEMENT);
        rootElementForSaving.setAttribute
            (XML_TIMESTAMP_ATTR, String.valueOf(System.currentTimeMillis()));
     }



#end
#end
#No. 187803
#File: E:\bishe\1\XMLDataPersister.java
#Comment:
    /**
     * Save any extra metadata (i.e., metadata that isn't attached to a
     * specific feed or a specific item).
     *
     * @param metadata the collection of metadata items
     *
     * @throws CurnException on error
     */

#Code:
    protected void
    saveExtraMetadata(Collection<PersistentMetadataGroup> metadata)
        throws CurnException
    {
        fillInMetadata(metadata,
                       XML_EXTRA_METADATA_ELEMENT,
                       rootElementForSaving);
    }

#end
#end
#No. 187804
#File: E:\bishe\1\XMLDataPersister.java
#Comment:
    /**
     * Called at the beginning of the load operation to initialize
     * the load.
     *
     * @throws CurnException on error
     */

#Code:
    protected void startLoadOperation()
        throws CurnException
    {
         assert(isEnabled());
         log.debug("Starting load of XML curn data.");
   }



#end
#end
#No. 187807
#File: E:\bishe\1\XMLDataPersister.java
#Comment:
    /**
     * Retrieve an optional XML attribute value from a list of attributes.
     * If the attribute is missing or empty, the default is returned.
     *
     * @param element      the XML element
     * @param defaultValue the default value
     * @param name         the attribute name
     *
     * @return the attribute's value, or null if the attribute wasn't found
     */

#Code:
    private String getOptionalXMLAttribute(final Element element,
                                           final String  name,
                                           final String  defaultValue)
    {
        String value = element.getAttributeValue(name);
        if ((value != null) && TextUtil.stringIsEmpty(value))
            value = null;

        return (value == null) ? defaultValue : value;
    }

#end
#end
#No. 187808
#File: E:\bishe\1\XMLDataPersister.java
#Comment:
    /**
     * Retrieve an XML attribute value from a list of attributes. If the
     * attribute is missing, the error is logged (but an exception is not
     * thrown).
     *
     * @param element the element
     * @param name    the attribute name
*
     * @return the attribute's value, or null if the attribute wasn't found
     */

#Code:
    private String getRequiredXMLAttribute (final Element element,
                                            final String  name)
    {
        String value = getOptionalXMLAttribute (element, name, null);

        if (value == null)
        {
            log.error("<" + element.getName() + "> is missing required " +
                      "\"" + name + "\" XML attribute.");
        }

        return value;
    }



#end
#end
#No. 187811
#File: E:\bishe\1\XmlDirectoryContentHandler.java
#Comment:
    /**
     * Hide the parent directory item if one exists
     */

#Code:
    private void hideParent() {
        for(int i = 0; i < mDirectory.size(); i++) {
            if(mDirectory.get(i).isParent()) {
                mDirectory.remove(i);
                return;
            }
        }
    }

#end
#end
#No. 187812
#File: E:\bishe\1\XmlDirectoryContentHandler.java
#Comment:
    /**
     * Set the parent directory item at the top of the list. If no parent entry
     * exists, one will be added with the default path being the root directory
     */

#Code:
    private void setParentTop() {
        for(int i = 0; i < mDirectory.size(); i++) {
            if(mDirectory.get(i).isParent()) {
                if(i != 0) {
                    mDirectory.add(0, mDirectory.remove(i));
                }
                return;
            }
        }
        mDirectory.add(0, new File(File.Type.DIRECTORY, 0L, null, Directory.ROOT_DIRECTORY, "..", null));
    }

#end
#end
#No. 187813
#File: E:\bishe\1\XmlDiscourseFunction.java
#Comment:
/**
 * <p>Java class for discourseFunction.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="discourseFunction">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="AUXILIARY"/>
 *     &lt;enumeration value="COMPLEMENT"/>
 *     &lt;enumeration value="CONJUNCTION"/>
 *     &lt;enumeration value="CUE_PHRASE"/>
 *     &lt;enumeration value="FRONT_MODIFIER"/>
 *     &lt;enumeration value="HEAD"/>
 *     &lt;enumeration value="INDIRECT_OBJECT"/>
 *     &lt;enumeration value="OBJECT"/>
 *     &lt;enumeration value="PRE_MODIFIER"/>
 *     &lt;enumeration value="POST_MODIFIER"/>
 *     &lt;enumeration value="SPECIFIER"/>
 *     &lt;enumeration value="SUBJECT"/>
 *     &lt;enumeration value="VERB_PHRASE"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "discourseFunction")
@XmlEnum
public enum XmlDiscourseFunction {

    AUXILIARY,
    COMPLEMENT,
    CONJUNCTION,
    CUE_PHRASE,
    FRONT_MODIFIER,
    HEAD,
    INDIRECT_OBJECT,
    OBJECT,
    PRE_MODIFIER,
    POST_MODIFIER,
    SPECIFIER,
    SUBJECT,
    VERB_PHRASE;

    public String value() {
        return name();
    }

    public static XmlDiscourseFunction fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 187814
#File: E:\bishe\1\XMLDocBuilder.java
#Comment:
    /**
     * Add a namespace to the document that will be created
     *
     * @param prefix       The prefix of the namespace
     * @param namespaceURI The URI of the namespace
     * @return this
     */

#Code:
    public XMLDocBuilder addNamespace(String prefix, String namespaceURI) {
        definition.addNamespace(prefix, namespaceURI);
        return this;
    }

#end
#end
#No. 187815
#File: E:\bishe\1\XMLDocBuilder.java
#Comment:
    /**
     * Set the default namespace to use in the document declaration.
     *
     * @param defaultNamespaceURI URI to use as default when tags are not prefixed
     * @return this
     */

#Code:
    public XMLDocBuilder addDefaultNamespace(String defaultNamespaceURI) {
        definition.addDefaultNamespace(defaultNamespaceURI);
        return this;
    }

#end
#end
#No. 187816
#File: E:\bishe\1\XMLDocBuilder.java
#Comment:
    /**
     * Create a root node for this XML document
     *
     * @param tagName Name of the element
     * @return XMLDoc instance to build and navigate in the document
     */

#Code:
    public XMLTag addRoot(String tagName) {
        return create(definition.createRoot(tagName));
    }


#end
#end
#No. 187819
#File: E:\bishe\1\XMLDocSpan.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 */

#Code:
	public XMLDocSpan(final Context context) {
		super(context, R.style.Axel_Xml_Document);
	}

#end
#end
#No. 187820
#File: E:\bishe\1\XMLDoctypeSpan.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 */

#Code:
	public XMLDoctypeSpan(final Context context) {
		super(context, R.style.Axel_Xml_Doctype);
	}


#end
#end
#No. 187822
#File: E:\bishe\1\XmlDocumentCategory.java
#Comment:
/**
 * <p>Java class for documentCategory.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="documentCategory">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="DOCUMENT"/>
 *     &lt;enumeration value="SECTION"/>
 *     &lt;enumeration value="PARAGRAPH"/>
 *     &lt;enumeration value="SENTENCE"/>
 *     &lt;enumeration value="LIST"/>
 *     &lt;enumeration value="LIST_ITEM"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "documentCategory")
@XmlEnum
public enum XmlDocumentCategory {

    DOCUMENT,
    SECTION,
    PARAGRAPH,
    SENTENCE,
    LIST,
    LIST_ITEM;

    public String value() {
        return name();
    }

    public static XmlDocumentCategory fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 187824
#File: E:\bishe\1\XmlDocumentFormatRegistry.java
#Comment:
	/**
	 * @deprecated use {@link DefaultDocumentFormatRegistry} instead (since version 2.1.2)
	 */

#Code:
	public XmlDocumentFormatRegistry() {
		load(getClass().getResourceAsStream(DEFAULT_CONFIGURATION));
	}

#end
#end
#No. 187825
#File: E:\bishe\1\XmlDocumentFormatRegistry.java
#Comment:
	/**
	 * Prints out a document-formats.xml from the {@link DefaultDocumentFormatRegistry}
	 */

#Code:
	public static void main(String[] args) throws IOException {
		DefaultDocumentFormatRegistry registry = new DefaultDocumentFormatRegistry();
		XStream xstream = createXStream();
		ObjectOutputStream outputStream = xstream.createObjectOutputStream(new OutputStreamWriter(System.out), "document-formats");
		for (Iterator iterator = registry.getDocumentFormats().iterator(); iterator.hasNext();) {
			outputStream.writeObject(iterator.next());
		}
		outputStream.close();
	}


#end
#end
#No. 187827
#File: E:\bishe\1\XMLElementImpl.java
#Comment:
	/**
	 * Parses a string into a XMLElement.
	 * 
	 * @param xml the string to parse
	 * @return the resulting element
	 */

#Code:
	public static XMLElement fromString(final String xml) {
		return new XMLElementImpl(XMLUtil.fromString(xml));
	}

#end
#end
#No. 187828
#File: E:\bishe\1\XMLElementImpl.java
#Comment:
	/**
	 * Creates an XMLElement from a DOM Element.
	 * 
	 * @param element the DOM element
	 * @return the resulting element
	 */

#Code:
	public static XMLElement fromElement(final Element element) {
		return new XMLElementImpl(element);
	}

#end
#end
#No. 187829
#File: E:\bishe\1\XMLElementWriter.java
#Comment:
	/**
	 * Parameterized constructor, which takes schema and path input parameters
	 * @param schema
	 * @param path
	 */

#Code:
	public XMLElementWriter(ResourceSchema schema, Path path)
	{
		this.schema = schema ;
		this.path = path ;
		//Gets DocumentBuilderFactory instance 
		documentBuilderFactory = DocumentBuilderFactory.newInstance();
		try {
			/*
			 * Creates DocumentBuilder instance.
			 * After this class instance is obtained, XML can be parsed from multiple input sources. 
			 * The input sources can be InputStreams, URLs,Files, and SAX InputSources.
			 */
			documentBuilder = documentBuilderFactory.newDocumentBuilder();
		} catch (ParserConfigurationException e) {
			e.printStackTrace();
		}
		/*
		 * Obtains DOM Document object instance to form DOM tree.The Document interface represents the entire HTML or XML document. 
		 * Document object represents document tree root, and obtains access to the document's data.
		 */
		xmlDoc = documentBuilder.newDocument();	
		/*
		 * creating xml root element
		 */
		rootElement = xmlDoc.createElement(XMLStorage.rootElementName);
	}

#end
#end
#No. 187830
#File: E:\bishe\1\XMLElementWriter.java
#Comment:
	/**
	 * data from tuple is appended to xml root element
	 * @param tuple
	 */

#Code:
	protected void write(Tuple tuple)
	{
		// Retrieving all fields from the schema
		ResourceFieldSchema[] fields = schema.getFields();
		
		//Retrieve values from tuple
		List<Object> values = tuple.getAll();
		
		//creating xml element by using fields as element tag and tuple value as element value
		Element transactionElement = xmlDoc.createElement(XMLStorage.elementName);
		for(int counter=0;counter<fields.length;counter++)
		{
			//Retrieving element value from values
			String columnValue =  String.valueOf(values.get(counter));
			//Creating element tag from fields
			Element columnName =  xmlDoc.createElement(fields[counter].getName().toString().trim());
			//Appending value to element tag
			columnName.appendChild(xmlDoc.createTextNode(columnValue));
			//Appending element to transaction element
            transactionElement.appendChild(columnName);		
		}
		//Appending transaction element to root element
		rootElement.appendChild(transactionElement);
	}

#end
#end
#No. 187831
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Read an inline Room at an Employee
   * 
   * @throws Exception
   */

#Code:
  @Test
  public void readWithInlineContentEmployeeRoomEntry() throws Exception {

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Employees");
    InputStream reqContent = createContentAsStream(EMPLOYEE_1_ROOM_XML);

    // execute
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry employee =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(true).build());

    // validate
    assertNotNull(employee);
    Map<String, Object> properties = employee.getProperties();
    assertEquals("1", properties.get("EmployeeId"));
    assertEquals("Walter Winter", properties.get("EmployeeName"));
    EntryMetadata employeeMetadata = employee.getMetadata();
    assertNotNull(employeeMetadata);
    assertEquals("W/\"1\"", employeeMetadata.getEtag());

    // Inline
    ODataEntry room = (ODataEntry) properties.get("ne_Room");
    Map<String, Object> roomProperties = room.getProperties();
    assertEquals(4, roomProperties.size());
    assertEquals("1", roomProperties.get("Id"));
    assertEquals("Room 1", roomProperties.get("Name"));
    assertEquals(Short.valueOf("1"), roomProperties.get("Seats"));
    assertEquals(Short.valueOf("1"), roomProperties.get("Version"));
    EntryMetadata roomMetadata = room.getMetadata();
    assertNotNull(roomMetadata);
    assertEquals("W/1", roomMetadata.getEtag());
  }

#end
#end
#No. 187832
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Reads an inline Room at an Employee with specially formatted XML (see issue ODATAFORSAP-92).
   */

#Code:
  @Test
  public void readWithInlineContentEmployeeRoomEntrySpecialXml() throws Exception {

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Employees");
    InputStream reqContent = createContentAsStream(EMPLOYEE_1_ROOM_XML, true);

    // execute
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry entry =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(true).build());

    // validate
    assertNotNull(entry);
    Map<String, Object> properties = entry.getProperties();
    assertEquals("1", properties.get("EmployeeId"));
    assertEquals("Walter Winter", properties.get("EmployeeName"));
    ODataEntry room = (ODataEntry) properties.get("ne_Room");
    Map<String, Object> roomProperties = room.getProperties();
    assertEquals(4, roomProperties.size());
    assertEquals("1", roomProperties.get("Id"));
    assertEquals("Room 1", roomProperties.get("Name"));
    assertEquals(Short.valueOf("1"), roomProperties.get("Seats"));
    assertEquals(Short.valueOf("1"), roomProperties.get("Version"));
  }

#end
#end
#No. 187833
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Reads an employee with inlined but <code>NULL</code> room navigation property
   * (which has {@link com.sap.core.odata.api.edm.EdmMultiplicity#ONE EdmMultiplicity#ONE}).
   */

#Code:
  @Test
  public void readWithInlineContentEmployeeNullRoomEntry() throws Exception {

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Employees");
    InputStream reqContent = createContentAsStream(EMPLOYEE_1_NULL_ROOM_XML);

    // execute
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry entry =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(true).build());

    // validate
    assertNotNull(entry);
    Map<String, Object> properties = entry.getProperties();
    assertEquals("1", properties.get("EmployeeId"));
    assertEquals("Walter Winter", properties.get("EmployeeName"));
    ODataEntry room = (ODataEntry) properties.get("ne_Room");
    assertNull(room);
  }

#end
#end
#No. 187834
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Reads an employee with inlined but <code>NULL</code> room navigation property
   * (which has {@link com.sap.core.odata.api.edm.EdmMultiplicity#ONE EdmMultiplicity#ONE}).
   */

#Code:
  @Test
  public void readWithInlineContentEmployeeNullRoomEntrySpecialXmlFormat() throws Exception {

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Employees");
    InputStream reqContent = createContentAsStream(EMPLOYEE_1_NULL_ROOM_XML, true);

    // execute
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry entry =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(true).build());

    // validate
    assertNotNull(entry);
    Map<String, Object> properties = entry.getProperties();
    assertEquals("1", properties.get("EmployeeId"));
    assertEquals("Walter Winter", properties.get("EmployeeName"));
    ODataEntry room = (ODataEntry) properties.get("ne_Room");
    assertNull(room);
  }

#end
#end
#No. 187835
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Reads a room with inlined but <code>NULL</code> employees navigation property
   * (which has {@link com.sap.core.odata.api.edm.EdmMultiplicity#MANY EdmMultiplicity#MANY}).
   */

#Code:
  @Test
  public void readWithInlineContentRoomNullEmployeesEntry() throws Exception {

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    InputStream reqContent = createContentAsStream(ROOM_1_NULL_EMPLOYEE_XML);

    // execute
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry entry =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(true).build());

    // validate
    assertNotNull(entry);
    Map<String, Object> properties = entry.getProperties();
    assertEquals("1", properties.get("Id"));
    ODataEntry room = (ODataEntry) properties.get("ne_Employees");
    assertNull(room);
  }


#end
#end
#No. 187843
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * For none media resource if <code>properties</code> tag is not within <code>content</code> tag it results in an
   * exception.
   * 
   * OData specification v2: 2.2.6.2.2 Entity Type (as an Atom Entry Element)
   * 
   * @throws Exception
   */

#Code:
  @Test(expected = EntityProviderException.class)
  public void validationOfWrongPropertiesTagPositionForNoneMediaLinkEntry() throws Exception {
    String roomWithValidNamespaces =
        "<?xml version='1.0' encoding='UTF-8'?>"
            +
            "<entry xmlns=\"http://www.w3.org/2005/Atom\" " +
            "xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" " +
            "xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\"" +
            " xml:base=\"http://localhost:19000/test/\" m:etag=\"W/&quot;1&quot;\">"
            +
            "  <id>http://localhost:19000/test/Rooms('1')</id>" +
            "  <title type=\"text\">Room 1</title>" +
            "  <updated>2013-01-11T13:50:50.541+01:00</updated>" +
            "  <content type=\"application/xml\" />" +
            "  <m:properties>" +
            "    <d:Id>1</d:Id>" +
            "  </m:properties>" +
            "</entry>";

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    InputStream reqContent = createContentAsStream(roomWithValidNamespaces);
    readAndExpectException(entitySet, reqContent, EntityProviderException.INVALID_PARENT_TAG.addContent("content")
        .addContent("properties"));
  }

#end
#end
#No. 187844
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * For media resource if <code>properties</code> tag is within <code>content</code> tag it results in an exception.
   * 
   * OData specification v2: 2.2.6.2.2 Entity Type (as an Atom Entry Element)
   * And RFC5023 [section 4.2]
   * 
   * @throws Exception
   */

#Code:
  @Test(expected = EntityProviderException.class)
  public void validationOfWrongPropertiesTagPositionForMediaLinkEntry() throws Exception {
    String roomWithValidNamespaces =
        "<?xml version='1.0' encoding='UTF-8'?>"
            +
            "<entry xmlns=\"http://www.w3.org/2005/Atom\" " +
            "xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" " +
            "xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" " +
            "xml:base=\"http://localhost:19000/test/\" m:etag=\"W/&quot;1&quot;\">"
            +
            "  <id>http://localhost:19000/test/Employees('1')</id>" +
            "  <title type=\"text\">Walter Winter</title>" +
            "  <updated>2013-01-11T13:50:50.541+01:00</updated>" +
            "  <content type=\"application/xml\">" +
            "    <m:properties>" +
            "      <d:EmployeeId>1</d:EmployeeId>" +
            "    </m:properties>" +
            "  </content>" +
            "</entry>";

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Employees");
    InputStream reqContent = createContentAsStream(roomWithValidNamespaces);
    readAndExpectException(entitySet, reqContent, EntityProviderException.INVALID_PARENT_TAG.addContent("properties")
        .addContent("content"));
  }

#end
#end
#No. 187845
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Use different namespace prefixes for <code>metadata (m)</code> and <code>data (d)</code>.
   * 
   * @throws Exception
   */

#Code:
  @Test
  public void validationOfDifferentNamespacesPrefixSuccess() throws Exception {
    String roomWithValidNamespaces =
        "<?xml version='1.0' encoding='UTF-8'?>" +
            "<entry xmlns=\"http://www.w3.org/2005/Atom\" " +
            "    xmlns:meta=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" " +
            "    xmlns:data=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" " +
            "    xml:base=\"http://localhost:19000/test/\" " +
            "    meta:etag=\"W/&quot;1&quot;\">" +
            "" +
            "  <id>http://localhost:19000/test/Rooms('1')</id>" +
            "  <title type=\"text\">Room 1</title>" +
            "  <updated>2013-01-11T13:50:50.541+01:00</updated>" +
            "  <content type=\"application/xml\">" +
            "    <meta:properties>" +
            "      <data:Id>1</data:Id>" +
            "      <data:Seats>11</data:Seats>" +
            "      <data:Name>Room 42</data:Name>" +
            "      <data:Version>4711</data:Version>" +
            "    </meta:properties>" +
            "  </content>" +
            "</entry>";

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    InputStream reqContent = createContentAsStream(roomWithValidNamespaces);
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry result =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(false).build());
    assertNotNull(result);
  }

#end
#end
#No. 187846
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Add <code>unknown property</code> in own namespace which is defined in entry tag.
   * 
   * @throws Exception
   */

#Code:
  @Test
  public void validationOfUnknownPropertyOwnNamespaceSuccess() throws Exception {
    String roomWithValidNamespaces =
        "<?xml version='1.0' encoding='UTF-8'?>" +
            "<entry xmlns=\"http://www.w3.org/2005/Atom\" " +
            "    xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" " +
            "    xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" " +
            "    xmlns:more=\"http://sample.com/more\" " +
            "    xml:base=\"http://localhost:19000/test/\" " +
            "    m:etag=\"W/&quot;1&quot;\">" +
            "" +
            "  <id>http://localhost:19000/test/Rooms('1')</id>" +
            "  <title type=\"text\">Room 1</title>" +
            "  <updated>2013-01-11T13:50:50.541+01:00</updated>" +
            "  <content type=\"application/xml\">" +
            "    <m:properties>" +
            "      <d:Id>1</d:Id>" +
            "      <more:somePropertyToBeIgnored>ignore me</more:somePropertyToBeIgnored>" +
            "      <d:Seats>11</d:Seats>" +
            "      <d:Name>Room 42</d:Name>" +
            "      <d:Version>4711</d:Version>" +
            "    </m:properties>" +
            "  </content>" +
            "</entry>";

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    InputStream reqContent = createContentAsStream(roomWithValidNamespaces);
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry result =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(false).build());
    assertNotNull(result);
  }



#end
#end
#No. 187848
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Double occurrence of <code>d:Name</code> tag must result in an exception.
   * 
   * @throws Exception
   */

#Code:
  @Test(expected = EntityProviderException.class)
  public void validationOfDuplicatedPropertyException() throws Exception {
    String room =
        "<?xml version='1.0' encoding='UTF-8'?>" +
            "<entry xmlns=\"http://www.w3.org/2005/Atom\" " +
            "    xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" " +
            "    xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" " +
            "    xml:base=\"http://localhost:19000/test/\" " +
            "    m:etag=\"W/&quot;1&quot;\">" +
            "" +
            "  <id>http://localhost:19000/test/Rooms('1')</id>" +
            "  <title type=\"text\">Room 1</title>" +
            "  <updated>2013-01-11T13:50:50.541+01:00</updated>" +
            "  <content type=\"application/xml\">" +
            "    <m:properties>" +
            "      <d:Id>1</d:Id>" +
            "      <d:Seats>11</d:Seats>" +
            "      <d:Name>Room 42</d:Name>" +
            "      <d:Name>Room 42</d:Name>" +
            "      <d:Version>4711</d:Version>" +
            "    </m:properties>" +
            "  </content>" +
            "</entry>";

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    InputStream reqContent = createContentAsStream(room);
    readAndExpectException(entitySet, reqContent, EntityProviderException.DOUBLE_PROPERTY.addContent("Name"));
  }

#end
#end
#No. 187849
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Double occurrence of <code>Name</code> tag within different namespace is allowed.
   * 
   * @throws Exception
   */

#Code:
  @Test
  public void validationOfDoublePropertyDifferentNamespace() throws Exception {
    String room =
        "<?xml version='1.0' encoding='UTF-8'?>" +
            "<entry xmlns=\"http://www.w3.org/2005/Atom\" " +
            "    xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" " +
            "    xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" " +
            "    xml:base=\"http://localhost:19000/test/\" " +
            "    m:etag=\"W/&quot;1&quot;\">" +
            "" +
            "  <id>http://localhost:19000/test/Rooms('1')</id>" +
            "  <title type=\"text\">Room 1</title>" +
            "  <updated>2013-01-11T13:50:50.541+01:00</updated>" +
            "  <content type=\"application/xml\">" +
            "    <m:properties>" +
            "      <d:Id>1</d:Id>" +
            "      <d:Seats>11</d:Seats>" +
            "      <o:Name xmlns:o=\"http://sample.org/own\">Room 42</o:Name>" +
            "      <d:Name>Room 42</d:Name>" +
            "      <d:Version>4711</d:Version>" +
            "    </m:properties>" +
            "  </content>" +
            "</entry>";

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    InputStream reqContent = createContentAsStream(room);
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry result =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(false).build());
    assertNotNull(result);
  }

#end
#end
#No. 187850
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Double occurrence of <code>Name</code> tag within ignored/unknown property AND different namespace is allowed.
   * 
   * @throws Exception
   */

#Code:
  @Test
  public void validationOfDoublePropertyDifferentTagHierachy() throws Exception {
    String room =
        "<?xml version='1.0' encoding='UTF-8'?>" +
            "<entry xmlns=\"http://www.w3.org/2005/Atom\" " +
            "    xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" " +
            "    xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" " +
            "    xml:base=\"http://localhost:19000/test/\" " +
            "    m:etag=\"W/&quot;1&quot;\">" +
            "" +
            "  <id>http://localhost:19000/test/Rooms('1')</id>" +
            "  <title type=\"text\">Room 1</title>" +
            "  <updated>2013-01-11T13:50:50.541+01:00</updated>" +
            "  <content type=\"application/xml\">" +
            "    <m:properties>" +
            "      <d:Id>1</d:Id>" +
            "      <d:Seats>11</d:Seats>" +
            "      <SomeProp>" +
            "        <Name>Room 42</Name>" +
            "      </SomeProp>" +
            "      <d:Name>Room 42</d:Name>" +
            "      <d:Version>4711</d:Version>" +
            "    </m:properties>" +
            "  </content>" +
            "</entry>";

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    InputStream reqContent = createContentAsStream(room);
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry result =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(false).build());
    assertNotNull(result);
  }

#end
#end
#No. 187851
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Double occurrence of <code>d:Name</code> tag within an unknown (and hence ignored) property is allowed.
   * 
   * @throws Exception
   */

#Code:
  @Test
  public void validationOfDoublePropertyDifferentTagHierachyD_Namespace() throws Exception {
    String room =
        "<?xml version='1.0' encoding='UTF-8'?>" +
            "<entry xmlns=\"http://www.w3.org/2005/Atom\" " +
            "    xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" " +
            "    xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" " +
            "    xml:base=\"http://localhost:19000/test/\" " +
            "    m:etag=\"W/&quot;1&quot;\">" +
            "" +
            "  <id>http://localhost:19000/test/Rooms('1')</id>" +
            "  <title type=\"text\">Room 1</title>" +
            "  <updated>2013-01-11T13:50:50.541+01:00</updated>" +
            "  <content type=\"application/xml\">" +
            "    <m:properties>" +
            "      <d:Id>1</d:Id>" +
            "      <d:Seats>11</d:Seats>" +
            "      <SomeProp>" +
            "        <d:Name>Room 42</d:Name>" +
            "      </SomeProp>" +
            "      <d:Name>Room 42</d:Name>" +
            "      <d:Version>4711</d:Version>" +
            "    </m:properties>" +
            "  </content>" +
            "</entry>";

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    InputStream reqContent = createContentAsStream(room);
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry result =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(false).build());
    assertNotNull(result);
  }

#end
#end
#No. 187852
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Missing _d_ namespace at key property/tag (_id_) is allowed.
   * 
   * @throws Exception
   */

#Code:
  @Test
  public void validationOfNamespacesMissingD_NamespaceAtKeyPropertyTag() throws Exception {
    String roomWithValidNamespaces =
        "<?xml version='1.0' encoding='UTF-8'?>"
            +
            "<entry xmlns=\"http://www.w3.org/2005/Atom\" " +
            "xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" " +
            "xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" " +
            "xml:base=\"http://localhost:19000/test/\" m:etag=\"W/&quot;1&quot;\">"
            +
            "  <id>http://localhost:19000/test/Rooms('1')</id>" +
            "  <title type=\"text\">Room 1</title>" +
            "  <updated>2013-01-11T13:50:50.541+01:00</updated>" +
            "  <content type=\"application/xml\">" +
            "    <m:properties>" +
            "      <Id>1</Id>" +
            "      <d:Seats>11</d:Seats>" +
            "      <d:Name>Room 42</d:Name>" +
            "      <d:Version>4711</d:Version>" +
            "    </m:properties>" +
            "  </content>" +
            "</entry>";

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    InputStream reqContent = createContentAsStream(roomWithValidNamespaces);
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry result =
        xec.readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(false).build());
    assertNotNull(result);
  }

#end
#end
#No. 187853
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Missing _d_ namespace at non-nullable property/tag (_Version_) is allowed.
   * @throws Exception
   */

#Code:
  public void validationOfNamespacesMissingD_NamespaceAtNonNullableTag() throws Exception {
    String roomWithValidNamespaces =
        "<?xml version='1.0' encoding='UTF-8'?>"
            +
            "<entry xmlns=\"http://www.w3.org/2005/Atom\" " +
            "xmlns:m=\"http://schemas.microsoft.com/ado/2007/08/dataservices/metadata\" " +
            "xmlns:d=\"http://schemas.microsoft.com/ado/2007/08/dataservices\" " +
            "xml:base=\"http://localhost:19000/test/\" m:etag=\"W/&quot;1&quot;\">"
            +
            "  <id>http://localhost:19000/test/Rooms('1')</id>" +
            "  <title type=\"text\">Room 1</title>" +
            "  <updated>2013-01-11T13:50:50.541+01:00</updated>" +
            "  <content type=\"application/xml\">" +
            "    <m:properties>" +
            "      <d:Seats>11</d:Seats>" +
            "      <d:Name>Room 42</d:Name>" +
            "      <Version>4711</Version>" +
            "    </m:properties>" +
            "  </content>" +
            "</entry>";

    final EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    final EdmProperty property = (EdmProperty) entitySet.getEntityType().getProperty("Version");
    EdmFacets facets = property.getFacets();
    Mockito.when(facets.isNullable()).thenReturn(false);

    InputStream reqContent = createContentAsStream(roomWithValidNamespaces);
    final ODataEntry result =
        new XmlEntityConsumer().readEntry(entitySet, reqContent, EntityProviderReadProperties.init().mergeSemantic(
            false).build());
    assertNotNull(result);
  }

#end
#end
#No. 187854
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Missing 'key' properties are allowed for validation against Edm model.
   * @throws Exception
   */

#Code:
  @Test
  @SuppressWarnings("unchecked")
  public void testReadEntryMissingKeyProperty() throws Exception {
    // prepare
    final EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Employees");
    InputStream contentBody = createContentAsStream(EMPLOYEE_1_XML.replace("<d:EmployeeId>1</d:EmployeeId>", ""));

    // execute
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry result =
        xec.readEntry(entitySet, contentBody, EntityProviderReadProperties.init().mergeSemantic(false).build());

    // verify
    Map<String, Object> properties = result.getProperties();
    assertEquals(8, properties.size());

    assertNull(properties.get("EmployeeId"));
    assertEquals("Walter Winter", properties.get("EmployeeName"));
    assertEquals("1", properties.get("ManagerId"));
    assertEquals("1", properties.get("RoomId"));
    assertEquals("1", properties.get("TeamId"));
    Map<String, Object> location = (Map<String, Object>) properties.get("Location");
    assertEquals(2, location.size());
    assertEquals("Germany", location.get("Country"));
    Map<String, Object> city = (Map<String, Object>) location.get("City");
    assertEquals(2, city.size());
    assertEquals("69124", city.get("PostalCode"));
    assertEquals("Heidelberg", city.get("CityName"));
    assertEquals(Integer.valueOf(52), properties.get("Age"));
    Calendar entryDate = (Calendar) properties.get("EntryDate");
    assertEquals(915148800000L, entryDate.getTimeInMillis());
    assertEquals(TimeZone.getTimeZone("GMT"), entryDate.getTimeZone());
    assertEquals("/SAP/PUBLIC/BC/NWDEMO_MODEL/IMAGES/Employee_1.png", properties.get("ImageUrl"));
  }

#end
#end
#No. 187855
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Employee with inline entity Room with inline entity Buildings 
   * Scenario of 1:1:1 navigation
   * E.g: Employees('1')?$expand=ne_Rooms/nr_Buildings
   * @throws Exception
   */

#Code:
  @Test
  public void employeesEntryWithEmployeeToRoomToBuilding() throws Exception {
    InputStream stream = getFileAsStream("Employee_InlineRoomBuilding.xml");
    assertNotNull(stream);
    FeedCallback callback = new FeedCallback();

    EntityProviderReadProperties readProperties = EntityProviderReadProperties.init()
        .mergeSemantic(false).callback(callback).build();

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Employees");
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry result =
        xec.readEntry(entitySet, stream, readProperties);
    assertNotNull(result);
    assertEquals(9, result.getProperties().size());

    Map<String, Object> inlineEntries = callback.getNavigationProperties();
    getExpandedData(inlineEntries, result);
    assertEquals(10, result.getProperties().size());
    assertEquals(5, ((ODataEntry)result.getProperties().get("ne_Room")).getProperties().size());
    assertEquals(3, ((ODataEntry)((ODataEntry)result.getProperties().get("ne_Room")).getProperties()
        .get("nr_Building")).getProperties().size());
  }

#end
#end
#No. 187856
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Room has inline entity to Employees and has inline entry To Team
   * Scenario of 1:n:1 navigation 
   * E.g: Rooms('1')?$expand=nr_Employees/ne_Team
   * @throws Exception
   */

#Code:
  @Test
  public void RoomEntryWithInlineEmployeeInlineTeam() throws Exception {
    InputStream stream = getFileAsStream("Room_InlineEmployeesToTeam.xml");
    assertNotNull(stream);
    FeedCallback callback = new FeedCallback();

    EntityProviderReadProperties readProperties = EntityProviderReadProperties.init()
        .mergeSemantic(false).callback(callback).build();

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry result =
        xec.readEntry(entitySet, stream, readProperties);
    assertNotNull(result);
    assertEquals(4, result.getProperties().size());

    Map<String, Object> inlineEntries = callback.getNavigationProperties();
    getExpandedData(inlineEntries, result);
    assertEquals(5, result.getProperties().size());
    for (ODataEntry employeeEntry : ((ODataFeed)result.getProperties().get("nr_Employees")).getEntries()) {
      assertEquals(10, employeeEntry.getProperties().size());
      assertEquals(3, ((ODataEntry)employeeEntry.getProperties().get("ne_Team")).getProperties().size());
    }
  }

#end
#end
#No. 187857
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * Room has empty inline entity to Employees and has inline entry To Team
   * E.g: Rooms('10')?$expand=nr_Employees/ne_Team
   * @throws Exception
   */

#Code:
  @Test
  public void RoomEntryWithEmptyInlineEmployeeInlineTeam() throws Exception {
    InputStream stream = getFileAsStream("Room_EmptyInlineEmployeesToTeam.xml");
    assertNotNull(stream);
    FeedCallback callback = new FeedCallback();

    EntityProviderReadProperties readProperties = EntityProviderReadProperties.init()
        .mergeSemantic(false).callback(callback).build();

    EdmEntitySet entitySet = MockFacade.getMockEdm().getDefaultEntityContainer().getEntitySet("Rooms");
    XmlEntityConsumer xec = new XmlEntityConsumer();
    ODataEntry result =
        xec.readEntry(entitySet, stream, readProperties);
    assertNotNull(result);
    assertEquals(4, result.getProperties().size());

    Map<String, Object> inlineEntries = callback.getNavigationProperties();
    getExpandedData(inlineEntries, result);
    assertEquals(5, result.getProperties().size());
    assertEquals(0, ((ODataFeed)result.getProperties().get("nr_Employees")).getEntries().size());
  }

#end
#end
#No. 187858
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * @param inlineEntries
   * @param feed
   * @param entry
   */

#Code:
  private void getExpandedData(Map<String, Object> inlineEntries, ODataEntry entry) {
    assertNotNull(entry);
    Map<String, ExpandSelectTreeNode> expandNodes = entry.getExpandSelectTree().getLinks();
    for (Entry<String, ExpandSelectTreeNode> expand : expandNodes.entrySet()) {
      assertNotNull(expand.getKey());
      if (inlineEntries.containsKey(expand.getKey() + entry.getMetadata().getId())) {
        if (inlineEntries.get(expand.getKey() + entry.getMetadata().getId()) instanceof ODataFeed) {
          ODataFeed innerFeed = (ODataFeed) inlineEntries.get(expand.getKey() + entry.getMetadata().getId());
          assertNotNull(innerFeed);
          getExpandedData(inlineEntries, innerFeed);
          entry.getProperties().put(expand.getKey(), innerFeed);
        } else if (inlineEntries.get(expand.getKey() + entry.getMetadata().getId()) instanceof ODataEntry) {
          ODataEntry innerEntry = (ODataEntry) inlineEntries.get(expand.getKey() + entry.getMetadata().getId());
          assertNotNull(innerEntry);
          getExpandedData(inlineEntries, innerEntry);
          entry.getProperties().put(expand.getKey(), innerEntry);
        }
      }
    }
  }

#end
#end
#No. 187859
#File: E:\bishe\1\XmlEntityConsumerTest.java
#Comment:
  /**
   * @param inlineEntries
   * @param feed
   * @param entry
   */

#Code:
  private void getExpandedData(Map<String, Object> inlineEntries, ODataFeed feed) {
    assertNotNull(feed.getEntries());
    List<ODataEntry> entries = feed.getEntries();
    for (ODataEntry entry : entries) {
      Map<String, ExpandSelectTreeNode> expandNodes = entry.getExpandSelectTree().getLinks();
      for (Entry<String, ExpandSelectTreeNode> expand : expandNodes.entrySet()) {
        assertNotNull(expand.getKey());
        if (inlineEntries.containsKey(expand.getKey() + entry.getMetadata().getId())) {
          if (inlineEntries.get(expand.getKey() + entry.getMetadata().getId()) instanceof ODataFeed) {
            ODataFeed innerFeed = (ODataFeed) inlineEntries.get(expand.getKey() + entry.getMetadata().getId());
            assertNotNull(innerFeed);
            getExpandedData(inlineEntries, innerFeed);
            feed.getEntries().get(feed.getEntries().indexOf(entry)).getProperties().put(expand.getKey(), innerFeed);
          } else if (inlineEntries.get(expand.getKey() + entry.getMetadata().getId()) instanceof ODataEntry) {
            ODataEntry innerEntry = (ODataEntry) inlineEntries.get(expand.getKey() + entry.getMetadata().getId());
            assertNotNull(innerEntry);
            getExpandedData(inlineEntries, innerEntry);
            feed.getEntries().get(feed.getEntries().indexOf(entry)).getProperties().put(expand.getKey(), innerEntry);
          }
        }
      }
    }
  }

#end
#end
#No. 187860
#File: E:\bishe\1\XmlErrorDocumentProducer.java
#Comment:
  /**
   * Gets language and country as defined in RFC 4646 based on {@link Locale}.
   */

#Code:
  private String getLocale(final Locale locale) {
    if (locale.getCountry().isEmpty()) {
      return locale.getLanguage();
    } else {
      return locale.getLanguage() + "-" + locale.getCountry();
    }
  }

#end
#end
#No. 187861
#File: E:\bishe\1\XmlEscapeUtil.java
#Comment:
    /**
     * Escapes the characters in a String using XML entities.
     * For example: a&b < c > d => a&amp;b &lt; c &gt; d
     *
     * Supports only XML entities which must be escaped in non-attribute
     * text (gt, lt, amp)
     *
     * @param value The string to escape
     * @return The escaped String that can be used in an XML document.
     */

#Code:
    public static String escapeTextXml(String value) {
        return escapeXml(value, XML_TEXT_CHARS);
    }

#end
#end
#No. 187862
#File: E:\bishe\1\XmlEscapeUtil.java
#Comment:
    /**
     * Escapes the characters in a String using XML entities.
     * For example: "bread" & "butter'ed" => &quot;bread&quot; &amp; &quot;butter&apos;ed&quot;
     *
     * Supports the five basic XML entities (gt, lt, quot, amp, apos)
     *
     * @param value The string to escape
     * @return The escaped String that can be used in an XML document.
     */

#Code:
    public static String escapeAttributeXml(String value) {
        return escapeXml(value, XML_ATTRIBUTE_CHARS);
    }


#end
#end
#No. 187864
#File: E:\bishe\1\XmlExportTransformer.java
#Comment:
	/**
	 * Gets type cache for given table.
	 * 
	 * @param table the table
	 * @return type cache for table
	 */

#Code:
	private Map<String, Integer> getTypeCache(Table table) {
		Map<String, Integer> cache = typeCache.get(table);
		if (cache == null) {
			cache = new HashMap<String, Integer>();
			typeCache.put(table, cache);
		}
		return cache;
	}

#end
#end
#No. 187865
#File: E:\bishe\1\XmlExportTransformer.java
#Comment:
	/**
	 * Sets the table to read from.
	 */

#Code:
	public void setTable(Table table) {
		this.table = table;
	}

#end
#end
#No. 187866
#File: E:\bishe\1\XmlExportTransformer.java
#Comment:
	/**
	 * Closes the XML document.
	 */

#Code:
	public void endDocument() throws SAXException {
		xmlRowWriter.close();
	}

#end
#end
#No. 187867
#File: E:\bishe\1\XMLExportType.java
#Comment:
	/**
	 * Cleans an element name so it doesn't contain any illegal characters.
	 * According to the Wikipedia article on XML:
	 * 
	 * Tag names cannot contain any of the characters !"#$%&'()*+,/;<=>?@[\]^`{|}~, nor a space character,
	 * and cannot start with -, ., or a numeric digit.
	 * @param name
	 * @return
	 */

#Code:
	private static String cleanElementName(String name) {
		name = name.replaceAll(ILLEGAL_CHARACTER_REGEX, "_");
		if (name.matches(ILLEGAL_START_REGEX)) {
			name = "_" + name;
		}
		return name;
	}


#end
#end
#No. 187869
#File: E:\bishe\1\XmlFeedConsumerTest.java
#Comment:
  /**
   * Room has an Inline Feed Employees and Employee has an inline Entry Team
   * E.g: Rooms?$expand=nr_Employees/ne_Team
   * Empty Inline entity is also part of payload
   * @throws Exception
   */

#Code:
  @Test
  public void roomsFeedWithRoomInlineEmployeesWithTeams() throws Exception {
    InputStream stream = getFileAsStream("Rooms_InlineEmployeesTeams.xml");
    assertNotNull(stream);
    FeedCallback callback = new FeedCallback();

    EntityProviderReadProperties readProperties = EntityProviderReadProperties.init()
        .mergeSemantic(false).callback(callback).build();

    ODataFeed feed =
        EntityProvider.readFeed("application/atom+xml", MockFacade.getMockEdm().getDefaultEntityContainer()
            .getEntitySet(
                "Rooms"), stream, readProperties);
    assertNotNull(feed);
    assertEquals(3, feed.getEntries().size());

    Map<String, Object> inlineEntries = callback.getNavigationProperties();
    getExpandedData(inlineEntries, feed);
    for (ODataEntry entry : feed.getEntries()) {
      assertEquals(5, entry.getProperties().size());
      for (ODataEntry innerEntry : ((ODataFeed)entry.getProperties().get("nr_Employees")).getEntries()) {
        assertEquals(10, innerEntry.getProperties().size());
        assertEquals(3, ((ODataEntry)innerEntry.getProperties().get("ne_Team")).getProperties().size());
      }
    }
  }

#end
#end
#No. 187870
#File: E:\bishe\1\XmlFeedConsumerTest.java
#Comment:
  /**
   * Rooms has an inline feed Employees and Rooms has Inline entry Buildings
   * E.g: Rooms?$expand=nr_Employees,nr_Building
   * @throws Exception
   */

#Code:
  @Test
  public void roomsFeedWithRoomInlineEmployeesInlineBuildings() throws Exception {
    InputStream stream = getFileAsStream("Rooms_InlineEmployees_InlineBuildings.xml");
    assertNotNull(stream);
    FeedCallback callback = new FeedCallback();

    EntityProviderReadProperties readProperties = EntityProviderReadProperties.init()
        .mergeSemantic(false).callback(callback).build();

    ODataFeed feed =
        EntityProvider.readFeed("application/atom+xml", MockFacade.getMockEdm().getDefaultEntityContainer()
            .getEntitySet(
                "Rooms"), stream, readProperties);
    assertNotNull(feed);
    assertEquals(2, feed.getEntries().size());

    Map<String, Object> inlineEntries = callback.getNavigationProperties();
    getExpandedData(inlineEntries, feed);
    for (ODataEntry entry : feed.getEntries()) {
      assertEquals(6, entry.getProperties().size());
      for (ODataEntry employeeEntry : ((ODataFeed)entry.getProperties().get("nr_Employees")).getEntries()) {
        assertEquals(9, employeeEntry.getProperties().size());
      }
      assertEquals(3, ((ODataEntry)entry.getProperties().get("nr_Building")).getProperties().size());
    }
  }

#end
#end
#No. 187871
#File: E:\bishe\1\XmlFeedConsumerTest.java
#Comment:
  /**
   * Rooms navigate to Employees and has inline entry Teams
   * E.g: Rooms('1')/nr_Employees?$expand=ne_Team
   * @throws Exception
   */

#Code:
  @Test
  public void roomsFeedWithRoomsToEmployeesInlineTeams() throws Exception {
    InputStream stream = getFileAsStream("RoomsToEmployeesWithInlineTeams.xml");
    assertNotNull(stream);
    FeedCallback callback = new FeedCallback();

    EntityProviderReadProperties readProperties = EntityProviderReadProperties.init()
        .mergeSemantic(false).callback(callback).build();

    ODataFeed feed =
        EntityProvider.readFeed("application/atom+xml", MockFacade.getMockEdm().getDefaultEntityContainer()
            .getEntitySet(
                "Employees"), stream, readProperties);
    assertNotNull(feed);
    assertEquals(2, feed.getEntries().size());

    Map<String, Object> inlineEntries = callback.getNavigationProperties();
    getExpandedData(inlineEntries, feed);
    for (ODataEntry entry : feed.getEntries()) {
      assertEquals(10, entry.getProperties().size());
      assertEquals(3, ((ODataEntry)entry.getProperties().get("ne_Team")).getProperties().size());
    }
  }

#end
#end
#No. 187872
#File: E:\bishe\1\XmlFeedConsumerTest.java
#Comment:
  /**
   * @param inlineEntries
   * @param feed
   * @param entry
   */

#Code:
  private void getExpandedData(Map<String, Object> inlineEntries, ODataEntry entry) {
    assertNotNull(entry);
    Map<String, ExpandSelectTreeNode> expandNodes = entry.getExpandSelectTree().getLinks();
    for (Entry<String, ExpandSelectTreeNode> expand : expandNodes.entrySet()) {
      assertNotNull(expand.getKey());
      if (inlineEntries.containsKey(expand.getKey() + entry.getMetadata().getId())) {
        if (inlineEntries.get(expand.getKey() + entry.getMetadata().getId()) instanceof ODataFeed) {
          ODataFeed innerFeed = (ODataFeed) inlineEntries.get(expand.getKey() + entry.getMetadata().getId());
          assertNotNull(innerFeed);
          getExpandedData(inlineEntries, innerFeed);
          entry.getProperties().put(expand.getKey(), innerFeed);
        } else if (inlineEntries.get(expand.getKey() + entry.getMetadata().getId()) instanceof ODataEntry) {
          ODataEntry innerEntry = (ODataEntry) inlineEntries.get(expand.getKey() + entry.getMetadata().getId());
          assertNotNull(innerEntry);
          getExpandedData(inlineEntries, innerEntry);
          entry.getProperties().put(expand.getKey(), innerEntry);
        }
      }
    }
  }

#end
#end
#No. 187873
#File: E:\bishe\1\XmlFeedConsumerTest.java
#Comment:
  /**
   * @param inlineEntries
   * @param feed
   * @param entry
   */

#Code:
  private void getExpandedData(Map<String, Object> inlineEntries, ODataFeed feed) {
    assertNotNull(feed.getEntries());
    List<ODataEntry> entries = feed.getEntries();
    for (ODataEntry entry : entries) {
      Map<String, ExpandSelectTreeNode> expandNodes = entry.getExpandSelectTree().getLinks();
      for (Entry<String, ExpandSelectTreeNode> expand : expandNodes.entrySet()) {
        assertNotNull(expand.getKey());
        if (inlineEntries.containsKey(expand.getKey() + entry.getMetadata().getId())) {
          if (inlineEntries.get(expand.getKey() + entry.getMetadata().getId()) instanceof ODataFeed) {
            ODataFeed innerFeed = (ODataFeed) inlineEntries.get(expand.getKey() + entry.getMetadata().getId());
            assertNotNull(innerFeed);
            getExpandedData(inlineEntries, innerFeed);
            feed.getEntries().get(feed.getEntries().indexOf(entry)).getProperties().put(expand.getKey(), innerFeed);
          } else if (inlineEntries.get(expand.getKey() + entry.getMetadata().getId()) instanceof ODataEntry) {
            ODataEntry innerEntry = (ODataEntry) inlineEntries.get(expand.getKey() + entry.getMetadata().getId());
            assertNotNull(innerEntry);
            getExpandedData(inlineEntries, innerEntry);
            feed.getEntries().get(feed.getEntries().indexOf(entry)).getProperties().put(expand.getKey(), innerEntry);
          }
        }
      }
    }
  }



#end
#end
#No. 187876
#File: E:\bishe\1\XMLFieldAttribute.java
#Comment:
/**
 * 
 *                 Configuration to compare the field attribute
 *             
 * 
 * <p>Java class for XMLFieldAttribute complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldAttribute"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldBase"&gt;
 *       &lt;attribute name="attribute" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldAttribute")
public class XMLFieldAttribute
    extends XMLFieldBase
{

    @XmlAttribute(name = "attribute", required = true)
    protected String attribute;

    /**
     * Gets the value of the attribute property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getAttribute() {
        return attribute;
    }

    /**
     * Sets the value of the attribute property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setAttribute(String value) {
        this.attribute = value;
    }

}




#end
#end
#No. 187882
#File: E:\bishe\1\XMLFieldConfigEnumValue.java
#Comment:
        /**
         * Gets the value of the field property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the field property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getField().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link XMLFieldConfigEnumValueField }
         * 
         * 
         */

#Code:
        public List<XMLFieldConfigEnumValueField> getField() {
            if (field == null) {
                field = new ArrayList<XMLFieldConfigEnumValueField>();
            }
            return this.field;
        }

#end
#end
#No. 187883
#File: E:\bishe\1\XMLFieldConfigEnumValue.java
#Comment:
        /**
         * Gets the value of the group property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the group property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getGroup().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link XMLFieldConfigEnumValueGroup }
         * 
         * 
         */

#Code:
        public List<XMLFieldConfigEnumValueGroup> getGroup() {
            if (group == null) {
                group = new ArrayList<XMLFieldConfigEnumValueGroup>();
            }
            return this.group;
        }

#end
#end
#No. 187884
#File: E:\bishe\1\XMLFieldConfigFeatureTypeConstraint.java
#Comment:
/**
 * 
 *                 Configuration for an feature type constraint field
 *             
 * 
 * <p>Java class for XMLFieldConfigFeatureTypeConstraint complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigFeatureTypeConstraint"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigFeatureTypeConstraint")
public class XMLFieldConfigFeatureTypeConstraint
    extends XMLFieldConfigData
{


}

#end
#end
#No. 187885
#File: E:\bishe\1\XMLFieldConfigFilename.java
#Comment:
/**
 * 
 *                 Configuration for a filename field
 *             
 * 
 * <p>Java class for XMLFieldConfigFilename complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigFilename"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *       &lt;attribute name="buttonText" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigFilename")
public class XMLFieldConfigFilename
    extends XMLFieldConfigData
{

    @XmlAttribute(name = "buttonText")
    protected String buttonText;

    /**
     * Gets the value of the buttonText property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getButtonText() {
        return buttonText;
    }

    /**
     * Sets the value of the buttonText property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setButtonText(String value) {
        this.buttonText = value;
    }

}

#end
#end
#No. 187886
#File: E:\bishe\1\XMLFieldConfigFont.java
#Comment:
/**
 * 
 *                 Configuration for a font field
 *             
 * 
 * <p>Java class for XMLFieldConfigFont complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigFont"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigFont")
public class XMLFieldConfigFont
    extends XMLFieldConfigData
{


}

#end
#end
#No. 187887
#File: E:\bishe\1\XMLFieldConfigFontPreview.java
#Comment:
/**
 * 
 *                 Configuration for a font preview field
 *             
 * 
 * <p>Java class for XMLFieldConfigFontPreview complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigFontPreview"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigFontPreview")
public class XMLFieldConfigFontPreview
    extends XMLFieldConfigData
{


}

#end
#end
#No. 187888
#File: E:\bishe\1\XMLFieldConfigGeometry.java
#Comment:
/**
 * 
 *                 Configuration for a geometry field
 *             
 * 
 * <p>Java class for XMLFieldConfigGeometry complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigGeometry"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *       &lt;attribute name="buttonText" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigGeometry")
public class XMLFieldConfigGeometry
    extends XMLFieldConfigData
{

    @XmlAttribute(name = "buttonText")
    protected String buttonText;

    /**
     * Gets the value of the buttonText property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getButtonText() {
        return buttonText;
    }

    /**
     * Sets the value of the buttonText property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setButtonText(String value) {
        this.buttonText = value;
    }

}

#end
#end
#No. 187889
#File: E:\bishe\1\XMLFieldConfigGeometryField.java
#Comment:
/**
 * 
 *                 Configuration for a geometry field
 *             
 * 
 * <p>Java class for XMLFieldConfigGeometryField complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigGeometryField"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigGeometryField")
public class XMLFieldConfigGeometryField
    extends XMLFieldConfigData
{


}

#end
#end
#No. 187890
#File: E:\bishe\1\XMLFieldConfigInlineFeature.java
#Comment:
/**
 * 
 *                 Configuration for an inline feature field
 *             
 * 
 * <p>Java class for XMLFieldConfigInlineFeature complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigInlineFeature"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigInlineFeature")
public class XMLFieldConfigInlineFeature
    extends XMLFieldConfigData
{


}

#end
#end
#No. 187891
#File: E:\bishe\1\XMLFieldConfigMapUnit.java
#Comment:
/**
 * 
 *                 Configuration for a drop down list of map units
 *             
 * 
 * <p>Java class for XMLFieldConfigMapUnit complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigMapUnit"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigMapUnit")
public class XMLFieldConfigMapUnit
    extends XMLFieldConfigData
{


}

#end
#end
#No. 187892
#File: E:\bishe\1\XMLFieldConfigSlider.java
#Comment:
/**
 * 
 *                 Configuration for a slider field
 *             
 * 
 * <p>Java class for XMLFieldConfigSlider complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigSlider"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *       &lt;attribute name="defaultValue" type="{http://www.w3.org/2001/XMLSchema}double" default="1.0" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigSlider")
public class XMLFieldConfigSlider
    extends XMLFieldConfigData
{

    @XmlAttribute(name = "defaultValue")
    protected Double defaultValue;

    /**
     * Gets the value of the defaultValue property.
     * 
     * @return
     *     possible object is
     *     {@link Double }
     *     
     */
    public double getDefaultValue() {
        if (defaultValue == null) {
            return  1.0D;
        } else {
            return defaultValue;
        }
    }

    /**
     * Sets the value of the defaultValue property.
     * 
     * @param value
     *     allowed object is
     *     {@link Double }
     *     
     */
    public void setDefaultValue(Double value) {
        this.defaultValue = value;
    }

}

#end
#end
#No. 187893
#File: E:\bishe\1\XMLFieldConfigSortBy.java
#Comment:
/**
 * 
 *                 Configuration for a vendor option feature type style sort by
 *             
 * 
 * <p>Java class for XMLFieldConfigSortBy complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigSortBy"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigSortBy")
public class XMLFieldConfigSortBy
    extends XMLFieldConfigData
{


}

#end
#end
#No. 187894
#File: E:\bishe\1\XMLFieldConfigSymbolType.java
#Comment:
/**
 * 
 *                 Configuration for a symbol type selection field
 *             
 * 
 * <p>Java class for XMLFieldConfigSymbolType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldConfigSymbolType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldConfigData"&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldConfigSymbolType")
public class XMLFieldConfigSymbolType
    extends XMLFieldConfigData
{


}

#end
#end
#No. 187895
#File: E:\bishe\1\XMLFieldDisabled.java
#Comment:
/**
 * 
 *                 Expecting field to be disabled
 *             
 * 
 * <p>Java class for XMLFieldDisabled complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldDisabled"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldBase"&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldDisabled")
public class XMLFieldDisabled
    extends XMLFieldBase
{


}

#end
#end
#No. 187896
#File: E:\bishe\1\XMLFieldExpression.java
#Comment:
/**
 * 
 *                 Configuration to compare the field expression
 *             
 * 
 * <p>Java class for XMLFieldExpression complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldExpression"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldBase"&gt;
 *       &lt;attribute name="expression" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldExpression")
public class XMLFieldExpression
    extends XMLFieldBase
{

    @XmlAttribute(name = "expression", required = true)
    protected String expression;

    /**
     * Gets the value of the expression property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getExpression() {
        return expression;
    }

    /**
     * Sets the value of the expression property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setExpression(String value) {
        this.expression = value;
    }

}

#end
#end
#No. 187897
#File: E:\bishe\1\XMLFieldLiteralBase.java
#Comment:
/**
 * <p>Java class for XMLFieldLiteralBase complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldLiteralBase"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldBase"&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldLiteralBase")
@XmlSeeAlso({
    XMLFieldLiteralString.class,
    XMLFieldLiteralInt.class,
    XMLFieldLiteralDouble.class,
    XMLFieldLiteralBoolean.class
})
public class XMLFieldLiteralBase
    extends XMLFieldBase
{


}

#end
#end
#No. 187898
#File: E:\bishe\1\XMLFieldLiteralBoolean.java
#Comment:
/**
 * 
 *                 Configuration to compare the boolean value of a field
 *             
 * 
 * <p>Java class for XMLFieldLiteralBoolean complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldLiteralBoolean"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldLiteralBase"&gt;
 *       &lt;attribute name="value" type="{http://www.w3.org/2001/XMLSchema}boolean" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldLiteralBoolean")
public class XMLFieldLiteralBoolean
    extends XMLFieldLiteralBase
{

    @XmlAttribute(name = "value")
    protected Boolean value;

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setValue(Boolean value) {
        this.value = value;
    }

}

#end
#end
#No. 187899
#File: E:\bishe\1\XMLFieldLiteralDouble.java
#Comment:
/**
 * 
 *                 Configuration to compare the double value of a field
 *             
 * 
 * <p>Java class for XMLFieldLiteralDouble complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldLiteralDouble"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldLiteralBase"&gt;
 *       &lt;attribute name="value" type="{http://www.w3.org/2001/XMLSchema}double" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldLiteralDouble")
public class XMLFieldLiteralDouble
    extends XMLFieldLiteralBase
{

    @XmlAttribute(name = "value")
    protected Double value;

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link Double }
     *     
     */
    public Double getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link Double }
     *     
     */
    public void setValue(Double value) {
        this.value = value;
    }

}

#end
#end
#No. 187900
#File: E:\bishe\1\XMLFieldLiteralInt.java
#Comment:
/**
 * 
 *                 Configuration to compare the integer value of a field
 *             
 * 
 * <p>Java class for XMLFieldLiteralInt complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldLiteralInt"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldLiteralBase"&gt;
 *       &lt;attribute name="value" type="{http://www.w3.org/2001/XMLSchema}int" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldLiteralInt")
public class XMLFieldLiteralInt
    extends XMLFieldLiteralBase
{

    @XmlAttribute(name = "value")
    protected Integer value;

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link Integer }
     *     
     */
    public Integer getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link Integer }
     *     
     */
    public void setValue(Integer value) {
        this.value = value;
    }

}

#end
#end
#No. 187901
#File: E:\bishe\1\XMLFieldLiteralString.java
#Comment:
/**
 * 
 *                 Configuration to compare the string value of a field
 *             
 * 
 * <p>Java class for XMLFieldLiteralString complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLFieldLiteralString"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldLiteralBase"&gt;
 *       &lt;attribute name="value" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLFieldLiteralString")
public class XMLFieldLiteralString
    extends XMLFieldLiteralBase
{

    @XmlAttribute(name = "value")
    protected String value;

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setValue(String value) {
        this.value = value;
    }

}

#end
#end
#No. 187902
#File: E:\bishe\1\XMLFieldTest.java
#Comment:
    /**
     * Gets the value of the disabledOrLiteralStringOrLiteralInt property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the disabledOrLiteralStringOrLiteralInt property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDisabledOrLiteralStringOrLiteralInt().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link XMLFieldDisabled }
     * {@link XMLFieldLiteralString }
     * {@link XMLFieldLiteralInt }
     * {@link XMLFieldLiteralDouble }
     * {@link XMLFieldLiteralBoolean }
     * {@link XMLColourMapEntries }
     * {@link XMLFieldAttribute }
     * {@link XMLFieldExpression }
     * {@link XMLSetFieldLiteralString }
     * {@link XMLSetFieldLiteralInt }
     * {@link XMLSetFieldLiteralDouble }
     * {@link XMLSetFieldLiteralBoolean }
     * {@link XMLSetFieldAttribute }
     * {@link XMLSetFieldExpression }
     * {@link XMLSetMultiOptionGroup }
     * {@link XMLSetGroup }
     * 
     * 
     */

#Code:
    public List<Object> getDisabledOrLiteralStringOrLiteralInt() {
        if (disabledOrLiteralStringOrLiteralInt == null) {
            disabledOrLiteralStringOrLiteralInt = new ArrayList<Object>();
        }
        return this.disabledOrLiteralStringOrLiteralInt;
    }


#end
#end
#No. 187905
#File: E:\bishe\1\XMLFileWriter.java
#Comment:
    /**
     * Prints a string to the <code>FileWriter</code> stored in the field @see #writer indenting it
     * by the number of spaces indicated by @see #indent either relative to the
     * current indentation level (if @see #relative is <code>true</code>) or with
     * respect to the beginning of the line (if @see #relative is <code>false</code>).
     *
     * @param string the string to be printed.
     * @param indent the number of spaces by which the string needs to be indented.
     * @param relative id <code>true</code> the string is further indented with respect
     * to the current indentation level, if <code>false</code> is indented with respect to
     * the beginning of the line.
     */

#Code:
    public void indentPrint (String string, int indent, boolean relative) throws java.io.IOException {
        this.setIndent(indent, relative);
        String newString = this.indentString + string;
        int newStringLength = newString.length();
        writer.write(newString, 0, newStringLength);
    }

#end
#end
#No. 187906
#File: E:\bishe\1\XMLFileWriter.java
#Comment:
    /**
     * Prints a string to the <code>FileWriter</code> stored in the field @see #writer.
     *
     * @param string the string to be printed.
     */

#Code:
    public void print (String string) throws java.io.IOException {
        writer.write(string, 0, string.length());
    }

#end
#end
#No. 187907
#File: E:\bishe\1\XMLFileWriter.java
#Comment:
    /**
     * Flushes the <code>FileWriter</code> in the field @see #writer.
     */

#Code:
    public void flush () throws java.io.IOException {
        writer.flush();
    }

#end
#end
#No. 187908
#File: E:\bishe\1\XMLFileWriter.java
#Comment:
  /**
   * Closes the <code>FileWriter</code> in the field @see #writer.
   */

#Code:
  public void close() throws java.io.IOException {
    writer.close();
  }

#end
#end
#No. 187910
#File: E:\bishe\1\XmlFloatExtractor.java
#Comment:
    /**
     * Extracts a dimension value from the XML resources into a float.
     *
     * @param context needed to access the XML resources.
     * @param resourceId that will be extracted into a float.
     * @return {@link float} with the extracted float value.
     */

#Code:
    public static float getFloatValueFromId(@NonNull final Context context,
                                            @DimenRes final int resourceId) {
        final TypedValue value = new TypedValue();
        context.getResources().getValue(resourceId, value, true);
        return value.getFloat();
    }
}
#end
#end
#No. 187911
#File: E:\bishe\1\XmlForm.java
#Comment:
/**
 * <p>Java class for form.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="form">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="BARE_INFINITIVE"/>
 *     &lt;enumeration value="GERUND"/>
 *     &lt;enumeration value="IMPERATIVE"/>
 *     &lt;enumeration value="INFINITIVE"/>
 *     &lt;enumeration value="NORMAL"/>
 *     &lt;enumeration value="PAST_PARTICIPLE"/>
 *     &lt;enumeration value="PRESENT_PARTICIPLE"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "form")
@XmlEnum
public enum XmlForm {

    BARE_INFINITIVE,
    GERUND,
    IMPERATIVE,
    INFINITIVE,
    NORMAL,
    PAST_PARTICIPLE,
    PRESENT_PARTICIPLE;

    public String value() {
        return name();
    }

    public static XmlForm fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 187912
#File: E:\bishe\1\XMLFormatReader.java
#Comment:
	/**
	 * <p>Constructor for XMLFormatReader.</p>
	 *
	 * @param writeQueryTriples a boolean.
	 */

#Code:
	public XMLFormatReader(final boolean writeQueryTriples) {
		super("XML", XMLFormatReader.MIMETYPE+(writeQueryTriples?"+querytriples":""));
		this.writeQueryTriples = writeQueryTriples;
	}

#end
#end
#No. 187913
#File: E:\bishe\1\XMLFormatReader.java
#Comment:
	/**
	 * <p>Constructor for XMLFormatReader.</p>
	 */

#Code:
	public XMLFormatReader(){
		this(false);
	}

#end
#end
#No. 187914
#File: E:\bishe\1\XmlGender.java
#Comment:
/**
 * <p>Java class for gender.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="gender">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="MASCULINE"/>
 *     &lt;enumeration value="FEMININE"/>
 *     &lt;enumeration value="NEUTER"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "gender")
@XmlEnum
public enum XmlGender {

    MASCULINE,
    FEMININE,
    NEUTER;

    public String value() {
        return name();
    }

    public static XmlGender fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 187915
#File: E:\bishe\1\XMLGroupConfig.java
#Comment:
/**
 * 
 *                 Defines how a group is configured
 *             
 * 
 * <p>Java class for XMLGroupConfig complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLGroupConfig"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLGroupConfigData"&gt;
 *       &lt;choice maxOccurs="unbounded" minOccurs="0"&gt;
 *         &lt;element name="FieldConfigSymbolType" type="{}XMLFieldConfigSymbolType"/&gt;
 *         &lt;element name="FieldConfigDouble" type="{}XMLFieldConfigDouble"/&gt;
 *         &lt;element name="FieldConfigEnum" type="{}XMLFieldConfigEnum"/&gt;
 *         &lt;element name="FieldConfigString" type="{}XMLFieldConfigString"/&gt;
 *         &lt;element name="FieldConfigSlider" type="{}XMLFieldConfigSlider"/&gt;
 *         &lt;element name="FieldConfigColour" type="{}XMLFieldConfigColour"/&gt;
 *         &lt;element name="FieldConfigFont" type="{}XMLFieldConfigFont"/&gt;
 *         &lt;element name="FieldConfigFontPreview" type="{}XMLFieldConfigFontPreview"/&gt;
 *         &lt;element name="FieldConfigBoolean" type="{}XMLFieldConfigBoolean"/&gt;
 *         &lt;element name="FieldConfigGeometry" type="{}XMLFieldConfigGeometry"/&gt;
 *         &lt;element name="FieldConfigGeometryField" type="{}XMLFieldConfigGeometryField"/&gt;
 *         &lt;element name="FieldConfigColourMap" type="{}XMLFieldConfigColourMap"/&gt;
 *         &lt;element name="FieldConfigTransformation" type="{}XMLFieldConfigTransformation"/&gt;
 *         &lt;element name="FieldConfigInteger" type="{}XMLFieldConfigInteger"/&gt;
 *         &lt;element name="FieldConfigInlineFeature" type="{}XMLFieldConfigInlineFeature"/&gt;
 *         &lt;element name="FieldConfigFeatureTypeConstraint" type="{}XMLFieldConfigFeatureTypeConstraint"/&gt;
 *         &lt;element name="FieldConfigMapUnit" type="{}XMLFieldConfigMapUnit"/&gt;
 *         &lt;element name="FieldConfigVendorOption" type="{}XMLFieldConfigVendorOption"/&gt;
 *         &lt;element name="FieldConfigSortBy" type="{}XMLFieldConfigSortBy"/&gt;
 *         &lt;element name="FieldConfigDSProperties" type="{}XMLFieldConfigDSProperties"/&gt;
 *         &lt;element name="Group" type="{}XMLGroupConfig"/&gt;
 *         &lt;element name="MultiOptionGroup" type="{}XMLMultiOptionGroup"/&gt;
 *       &lt;/choice&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLGroupConfig", propOrder = {
    "fieldList"
})
public class XMLGroupConfig
    extends XMLGroupConfigData
{

    @XmlElements({
        @XmlElement(name = "FieldConfigSymbolType", type = XMLFieldConfigSymbolType.class),
        @XmlElement(name = "FieldConfigDouble", type = XMLFieldConfigDouble.class),
        @XmlElement(name = "FieldConfigEnum", type = XMLFieldConfigEnum.class),
        @XmlElement(name = "FieldConfigString", type = XMLFieldConfigString.class),
        @XmlElement(name = "FieldConfigSlider", type = XMLFieldConfigSlider.class),
        @XmlElement(name = "FieldConfigColour", type = XMLFieldConfigColour.class),
        @XmlElement(name = "FieldConfigFont", type = XMLFieldConfigFont.class),
        @XmlElement(name = "FieldConfigFontPreview", type = XMLFieldConfigFontPreview.class),
        @XmlElement(name = "FieldConfigBoolean", type = XMLFieldConfigBoolean.class),
        @XmlElement(name = "FieldConfigGeometry", type = XMLFieldConfigGeometry.class),
        @XmlElement(name = "FieldConfigGeometryField", type = XMLFieldConfigGeometryField.class),
        @XmlElement(name = "FieldConfigColourMap", type = XMLFieldConfigColourMap.class),
        @XmlElement(name = "FieldConfigTransformation", type = XMLFieldConfigTransformation.class),
        @XmlElement(name = "FieldConfigInteger", type = XMLFieldConfigInteger.class),
        @XmlElement(name = "FieldConfigInlineFeature", type = XMLFieldConfigInlineFeature.class),
        @XmlElement(name = "FieldConfigFeatureTypeConstraint", type = XMLFieldConfigFeatureTypeConstraint.class),
        @XmlElement(name = "FieldConfigMapUnit", type = XMLFieldConfigMapUnit.class),
        @XmlElement(name = "FieldConfigVendorOption", type = XMLFieldConfigVendorOption.class),
        @XmlElement(name = "FieldConfigSortBy", type = XMLFieldConfigSortBy.class),
        @XmlElement(name = "FieldConfigDSProperties", type = XMLFieldConfigDSProperties.class),
        @XmlElement(name = "Group", type = XMLGroupConfig.class),
        @XmlElement(name = "MultiOptionGroup", type = XMLMultiOptionGroup.class)
    })

#end
#end
#No. 187916
#File: E:\bishe\1\XMLGroupConfig.java
#Comment:
    /**
     * Gets the value of the fieldList property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fieldList property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFieldList().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link XMLFieldConfigSymbolType }
     * {@link XMLFieldConfigDouble }
     * {@link XMLFieldConfigEnum }
     * {@link XMLFieldConfigString }
     * {@link XMLFieldConfigSlider }
     * {@link XMLFieldConfigColour }
     * {@link XMLFieldConfigFont }
     * {@link XMLFieldConfigFontPreview }
     * {@link XMLFieldConfigBoolean }
     * {@link XMLFieldConfigGeometry }
     * {@link XMLFieldConfigGeometryField }
     * {@link XMLFieldConfigColourMap }
     * {@link XMLFieldConfigTransformation }
     * {@link XMLFieldConfigInteger }
     * {@link XMLFieldConfigInlineFeature }
     * {@link XMLFieldConfigFeatureTypeConstraint }
     * {@link XMLFieldConfigMapUnit }
     * {@link XMLFieldConfigVendorOption }
     * {@link XMLFieldConfigSortBy }
     * {@link XMLFieldConfigDSProperties }
     * {@link XMLGroupConfig }
     * {@link XMLMultiOptionGroup }
     * 
     * 
     */

#Code:
    public List<Object> getFieldList() {
        if (fieldList == null) {
            fieldList = new ArrayList<Object>();
        }
        return this.fieldList;
    }

#end
#end
#No. 187917
#File: E:\bishe\1\XMLHasDescription.java
#Comment:
    /**
     * Gets the value of the description property.
     * 
     * <p>
     * This accessor method returns a reference to the live list, not a
     * snapshot. Therefore any modification you make to the returned list will
     * be present inside the JAXB object. This is why there is not a
     * <CODE>set</CODE> method for the description property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * 
     * <pre>
     * getDescription().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link XMLHasDescription.Description }
     * 
     * 
     */

#Code:
    public List<XMLHasDescription.Description> getDescription() {
        if (description == null) {
            description = new ArrayList<XMLHasDescription.Description>();
        }
        return this.description;
    }

#end
#end
#No. 187918
#File: E:\bishe\1\XmlId.java
#Comment:
/**
 * Annotation that allows tracing of annotated types through the startup process
 *
 * @author stuart
 */

#Code:
@Retention(RetentionPolicy.RUNTIME)
public @interface XmlId {
    int value();
}
}

#end
#end
#No. 187919
#File: E:\bishe\1\XMLIncludeTransformer.java
#Comment:
    /**
     * Read placholders and their values from include node definition.
     *
     * @param node                      Include node instance
     * @param inheritedVariablesContext Current context used for replace variables in new variables values
     * @return variables context from include instance (no inherited values)
     */

#Code:
    private Properties getVariablesContext(Node node, Properties inheritedVariablesContext) {
        Properties variablesContext = new Properties();
        NodeList children = node.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node n = children.item(i);
            if (n.getNodeType() == Node.ELEMENT_NODE) {
                String name = getStringAttribute(n, "name");
                String value = getStringAttribute(n, "value");
                // Replace variables inside
                value = PropertyParser.parse(value, inheritedVariablesContext);
                // Push new value
                Object originalValue = variablesContext.put(name, value);
                if (originalValue != null) {
                    throw new JdbcAssistantException("Variable " + name
                                                     + " defined twice in the same include definition");
                }
            }
        }
        return variablesContext;
    }

#end
#end
#No. 187920
#File: E:\bishe\1\XmlInflection.java
#Comment:
/**
 * <p>Java class for inflection.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="inflection">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="GRECO_LATIN_REGULAR"/>
 *     &lt;enumeration value="IRREGULAR"/>
 *     &lt;enumeration value="REGULAR"/>
 *     &lt;enumeration value="REGULAR_DOUBLE"/>
 *     &lt;enumeration value="UNCOUNT"/>
 *     &lt;enumeration value="INVARIANT"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "inflection")
@XmlEnum
public enum XmlInflection {

    GRECO_LATIN_REGULAR,
    IRREGULAR,
    REGULAR,
    REGULAR_DOUBLE,
    UNCOUNT,
    INVARIANT;

    public String value() {
        return name();
    }

    public static XmlInflection fromValue(String v) {
        return valueOf(v);
    }

}



#end
#end
#No. 187922
#File: E:\bishe\1\XmlInterrogativeType.java
#Comment:
/**
 * <p>Java class for interrogativeType.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="interrogativeType">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="HOW"/>
 *     &lt;enumeration value="WHAT_OBJECT"/>
 *     &lt;enumeration value="WHAT_SUBJECT"/>
 *     &lt;enumeration value="WHERE"/>
 *     &lt;enumeration value="WHO_INDIRECT_OBJECT"/>
 *     &lt;enumeration value="WHO_OBJECT"/>
 *     &lt;enumeration value="WHO_SUBJECT"/>
 *     &lt;enumeration value="WHY"/>
 *     &lt;enumeration value="YES_NO"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "interrogativeType")
@XmlEnum
public enum XmlInterrogativeType {

    HOW,
    WHAT_OBJECT,
    WHAT_SUBJECT,
    WHERE,
    WHO_INDIRECT_OBJECT,
    WHO_OBJECT,
    WHO_SUBJECT,
    WHY,
    YES_NO;

    public String value() {
        return name();
    }

    public static XmlInterrogativeType fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 187929
#File: E:\bishe\1\XmlLexicalCategory.java
#Comment:
/**
 * <p>Java class for lexicalCategory.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="lexicalCategory">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="ANY"/>
 *     &lt;enumeration value="SYMBOL"/>
 *     &lt;enumeration value="NOUN"/>
 *     &lt;enumeration value="ADJECTIVE"/>
 *     &lt;enumeration value="ADVERB"/>
 *     &lt;enumeration value="VERB"/>
 *     &lt;enumeration value="DETERMINER"/>
 *     &lt;enumeration value="PRONOUN"/>
 *     &lt;enumeration value="CONJUNCTION"/>
 *     &lt;enumeration value="PREPOSITION"/>
 *     &lt;enumeration value="COMPLEMENTISER"/>
 *     &lt;enumeration value="MODAL"/>
 *     &lt;enumeration value="AUXILIARY"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "lexicalCategory")
@XmlEnum
public enum XmlLexicalCategory {

    ANY,
    SYMBOL,
    NOUN,
    ADJECTIVE,
    ADVERB,
    VERB,
    DETERMINER,
    PRONOUN,
    CONJUNCTION,
    PREPOSITION,
    COMPLEMENTISER,
    MODAL,
    AUXILIARY;

    public String value() {
        return name();
    }

    public static XmlLexicalCategory fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 187930
#File: E:\bishe\1\XMLLexiconTest.java
#Comment:
	/*
	 * * Sets up the accessor and runs it -- takes ca. 26 sec
	 */

#Code:
	public void setUp() {
		long startTime = System.currentTimeMillis();
		//this.lexicon = new XMLLexicon(XML_FILENAME); // omit, use default
														// lexicon instead
		this.lexicon = new XMLLexicon();
		long stopTime = System.currentTimeMillis();
		;
		System.out.format("Loading XML lexicon took %d ms%n",
                          stopTime - startTime);

	}

#end
#end
#No. 187931
#File: E:\bishe\1\XMLLexiconTest.java
#Comment:
	/*
	 * close the lexicon
	 */

#Code:
	@Override
	@After
	public void tearDown() throws Exception {
		// TODO Auto-generated method stub
		super.tearDown();
		if (lexicon != null)
			lexicon.close();
	}


#end
#end
#No. 187933
#File: E:\bishe\1\XMLLibImpl.java
#Comment:
    /**
     * Optimized version of constructQName for String type
     */

#Code:
    QName constructQNameFromString(Context cx, String localName)
    {
        if (localName == null)
            throw new IllegalArgumentException();

        String uri;
        String prefix;

        if ("*".equals(localName)) {
            uri = null;
            prefix = null;
        } else {
            Namespace ns = getDefaultNamespace(cx);
            uri = ns.uri();
            prefix = ns.prefix();
        }

        return new QName(this, uri, localName, prefix);
    }


#end
#end
#No. 187935
#File: E:\bishe\1\XMLLibImpl.java
#Comment:
    /**
     * Escapes the reserved characters in a value of an attribute
     *
     * @param value Unescaped text
     * @return The escaped text
     */

#Code:
    public String escapeAttributeValue(Object value)
    {
        String text = ScriptRuntime.toString(value);

        if (text.length() == 0) return "";

        XmlObject xo = XmlObject.Factory.newInstance();

        XmlCursor cursor = xo.newCursor();
        cursor.toNextToken();
        cursor.beginElement("a");
        cursor.insertAttributeWithValue("a", text);
        cursor.dispose();

        String elementText = xo.toString();
        int begin = elementText.indexOf('"');
        int end = elementText.lastIndexOf('"');
        return elementText.substring(begin + 1, end);
    }

#end
#end
#No. 187936
#File: E:\bishe\1\XMLLibImpl.java
#Comment:
    /**
     * Escapes the reserved characters in a value of a text node
     *
     * @param value Unescaped text
     * @return The escaped text
     */

#Code:
    public String escapeTextValue(Object value)
    {
        if (value instanceof XMLObjectImpl) {
            return ((XMLObjectImpl)value).toXMLString(0);
        }

        String text = ScriptRuntime.toString(value);

        if (text.length() == 0) return text;

        XmlObject xo = XmlObject.Factory.newInstance();

        XmlCursor cursor = xo.newCursor();
        cursor.toNextToken();
        cursor.beginElement("a");
        cursor.insertChars(text);
        cursor.dispose();

        String elementText = xo.toString();
        int begin = elementText.indexOf('>') + 1;
        int end = elementText.lastIndexOf('<');
        return (begin < end) ? elementText.substring(begin, end) : "";
    }

#end
#end
#No. 187937
#File: E:\bishe\1\XmlLinkConsumer.java
#Comment:
  /**
   * Reads single link with format {@code <uri>http://somelink</uri>}.
   * @param reader
   * @param entitySet
   * @return link as string object
   * @throws EntityProviderException
   */

#Code:
  public String readLink(final XMLStreamReader reader, final EdmEntitySet entitySet) throws EntityProviderException {
    try {
      reader.next();
      return readLink(reader);
    } catch (final XMLStreamException e) {
      throw new EntityProviderException(EntityProviderException.EXCEPTION_OCCURRED.addContent(e.getClass()
          .getSimpleName()), e);
    }
  }

#end
#end
#No. 187938
#File: E:\bishe\1\XmlLinkConsumer.java
#Comment:
  /**
   * Reads multiple links with format
   * <pre> {@code
   * <links>
   *  <uri>http://somelink</uri>
   *  <uri>http://anotherLink</uri>
   *  <uri>http://somelink/yetAnotherLink</uri>
   * </links>
   * } </pre>
   * @param reader
   * @param entitySet
   * @return list of string based links
   * @throws EntityProviderException
   */

#Code:
  public List<String> readLinks(final XMLStreamReader reader, final EdmEntitySet entitySet)
      throws EntityProviderException {
    try {
      List<String> links = new ArrayList<String>();
      reader.nextTag();
      reader.require(XMLStreamConstants.START_ELEMENT, Edm.NAMESPACE_D_2007_08, FormatXml.D_LINKS);
      reader.nextTag();
      while (!reader.isEndElement()) {
        if (reader.getLocalName().equals(FormatXml.M_COUNT)) {
          readTag(reader, Edm.NAMESPACE_M_2007_08, FormatXml.M_COUNT);
        } else {
          final String link = readLink(reader);
          links.add(link);
        }
        reader.nextTag();
      }

      reader.require(XMLStreamConstants.END_ELEMENT, Edm.NAMESPACE_D_2007_08, FormatXml.D_LINKS);
      return links;
    } catch (final XMLStreamException e) {
      throw new EntityProviderException(EntityProviderException.EXCEPTION_OCCURRED.addContent(e.getClass()
          .getSimpleName()), e);
    }
  }


#end
#end
#No. 187940
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param object
     * @param property
     */

#Code:
    void setTargets(XMLObjectImpl object, javax.xml.namespace.QName property)
    {
        targetObject = object;
        targetProperty = property;
    }

#end
#end
#No. 187941
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param index
     * @return
     */

#Code:
    XML getXmlFromAnnotation(int index)
    {
        XML retVal;

        if (index >= 0 && index < length())
        {
            XML.XScriptAnnotation anno = _annos.item(index);
            retVal = XML.getFromAnnotation(lib, anno);
        }
        else
        {
            retVal = null;
        }

        return retVal;
    }

#end
#end
#No. 187942
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param index
     */

#Code:
    private void internalRemoveFromList (int index)
    {
        _annos.remove(index);
    }

#end
#end
#No. 187943
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param index
     * @param xml
     */

#Code:
    void replace(int index, XML xml)
    {
        if (index < length())
        {
            AnnotationList newAnnoList = new AnnotationList();

            // Copy upto item to replace.
            for (int i = 0; i < index; i++)
            {
                newAnnoList.add(_annos.item(i));
            }

            newAnnoList.add(xml.getAnnotation());

            // Skip over old item we're going to replace we've already add new item on above line.
            for (int i = index + 1; i < length(); i++)
            {
                newAnnoList.add(_annos.item(i));
            }

            _annos = newAnnoList;
        }
    }

#end
#end
#No. 187944
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param index
     * @param xml
     */

#Code:
    private void insert(int index, XML xml)
    {
        if (index < length())
        {
            AnnotationList newAnnoList = new AnnotationList();

            // Copy upto item to insert.
            for (int i = 0; i < index; i++)
            {
                newAnnoList.add(_annos.item(i));
            }

            newAnnoList.add(xml.getAnnotation());

            for (int i = index; i < length(); i++)
            {
                newAnnoList.add(_annos.item(i));
            }

            _annos = newAnnoList;
        }
    }

#end
#end
#No. 187945
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param index
     * @param start
     * @return
     */

#Code:
    public Object get(int index, Scriptable start)
    {
        //Log("get index: " + index);

        if (index >= 0 && index < length())
        {
            return getXmlFromAnnotation(index);
        }
        else
        {
            return Scriptable.NOT_FOUND;
        }
    }

#end
#end
#No. 187946
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param name
     * @param start
     * @return
     */

#Code:
    boolean hasXMLProperty(XMLName xmlName)
    {
        boolean result = false;

        // Has now should return true if the property would have results > 0 or
        // if it's a method name
        String name = xmlName.localName();
        if ((getPropertyList(xmlName).length() > 0) ||
            (getMethod(name) != NOT_FOUND))
        {
            result = true;
        }

        return result;
    }

#end
#end
#No. 187947
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param index
     * @param start
     * @return
     */

#Code:
    public boolean has(int index, Scriptable start)
    {
        return 0 <= index && index < length();
    }

#end
#end
#No. 187948
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param name
     * @return
     */

#Code:
    Object getXMLProperty(XMLName name)
    {
        return getPropertyList(name);
    }

#end
#end
#No. 187949
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param name
     */

#Code:
    void deleteXMLProperty(XMLName name)
    {
        for (int i = 0; i < length(); i++)
        {
            XML xml = getXmlFromAnnotation(i);

            if (xml.tokenType() == XmlCursor.TokenType.START)
            {
                xml.deleteXMLProperty(name);
            }
        }
    }

#end
#end
#No. 187950
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param index
     */

#Code:
    public void delete(int index)
    {
        if (index >= 0 && index < length())
        {
            XML xml = getXmlFromAnnotation(index);

            xml.remove();

            internalRemoveFromList(index);
        }
    }

#end
#end
#No. 187951
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    public Object[] getIds()
    {
        Object enumObjs[];

        if (prototypeFlag)
        {
            enumObjs = new Object[0];
        }
        else
        {
            enumObjs = new Object[length()];

            for (int i = 0; i < enumObjs.length; i++)
            {
                enumObjs[i] = new Integer(i);
            }
        }

        return enumObjs;
    }

#end
#end
#No. 187952
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    public Object[] getIdsForDebug()
    {
        return getIds();
    }

#end
#end
#No. 187953
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param index
     * @return
     */

#Code:
    XML item (int index)
    {
        return _annos != null
            ? getXmlFromAnnotation(index) : XML.createEmptyXML(lib);
    }

#end
#end
#No. 187954
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param name
     * @param value
     */

#Code:
    private void setAttribute (XMLName xmlName, Object value)
    {
        for (int i = 0; i < length(); i++)
        {
            XML xml = getXmlFromAnnotation(i);
            xml.setAttribute(xmlName, value);
        }
    }

#end
#end
#No. 187955
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param toAdd
     */

#Code:
    void addToList(Object toAdd)
    {
        if (toAdd instanceof Undefined)
        {
            // Missing argument do nothing...
            return;
        }

        if (toAdd instanceof XMLList)
        {
            XMLList xmlSrc = (XMLList)toAdd;
            for (int i = 0; i < xmlSrc.length(); i++)
            {
                _annos.add((xmlSrc.item(i)).getAnnotation());
            }
        }
        else if (toAdd instanceof XML)
        {
            _annos.add(((XML)(toAdd)).getAnnotation());
        }
        else if (toAdd instanceof XML.XScriptAnnotation)
        {
            _annos.add((XML.XScriptAnnotation)toAdd);
        }
    }

#end
#end
#No. 187956
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param toAdd
     */

#Code:
    XML addNamespace(Namespace ns)
    {
        if(length() == 1)
        {
            return getXmlFromAnnotation(0).addNamespace(ns);
        }
        else
        {
            throw ScriptRuntime.typeError("The addNamespace method works only on lists containing one item");
        }
    }

#end
#end
#No. 187957
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param xml
     * @return
     */

#Code:
    XML appendChild(Object xml)
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).appendChild(xml);
        }
        else
        {
            throw ScriptRuntime.typeError("The appendChild method works only on lists containing one item");
        }
    }

#end
#end
#No. 187958
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param attr
     * @return
     */

#Code:
    XMLList attribute(XMLName xmlName)
    {
        XMLList result = new XMLList(lib);

        for (int i = 0; i < length(); i++)
        {
            XML xml = getXmlFromAnnotation(i);
            result.addToList(xml.attribute(xmlName));
        }

        return result;
    }

#end
#end
#No. 187959
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    XMLList attributes()
    {
        XMLList result = new XMLList(lib);

        for (int i = 0; i < length(); i++)
        {
            XML xml = getXmlFromAnnotation(i);
            result.addToList(xml.attributes());
        }

        return result;
    }

#end
#end
#No. 187960
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    int childIndex()
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).childIndex();
        }
        else
        {
            throw ScriptRuntime.typeError("The childIndex method works only on lists containing one item");
        }
    }

#end
#end
#No. 187961
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    XMLList children()
    {
        Vector v = new Vector();

        for (int i = 0; i < length(); i++)
        {
            XML xml = getXmlFromAnnotation(i);

            if (xml != null)
            {
                Object o = xml.children();
                if (o instanceof XMLList)
                {
                    XMLList childList = (XMLList)o;

                    int cChildren = childList.length();
                    for (int j = 0; j < cChildren; j++)
                    {
                        v.addElement(childList.item(j));
                    }
                }
            }
        }

        XMLList allChildren = new XMLList(lib);
        int sz = v.size();

        for (int i = 0; i < sz; i++)
        {
            allChildren.addToList(v.get(i));
        }

        return allChildren;
    }

#end
#end
#No. 187962
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    XMLList comments()
    {
        XMLList result = new XMLList(lib);

        for (int i = 0; i < length(); i++)
        {
            XML xml = getXmlFromAnnotation(i);

            result.addToList(xml.comments());
        }

        return result;
    }

#end
#end
#No. 187963
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param xml
     * @return
     */

#Code:
    boolean contains(Object xml)
    {
        boolean result = false;

        for (int i = 0; i < length(); i++)
        {
            XML member = getXmlFromAnnotation(i);

            if (member.equivalentXml(xml))
            {
                result = true;
                break;
            }
        }

        return result;
    }

#end
#end
#No. 187964
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    Object copy()
    {
        XMLList result = new XMLList(lib);

        for (int i = 0; i < length(); i++)
        {
            XML xml = getXmlFromAnnotation(i);
            result.addToList(xml.copy());
        }

        return result;
    }

#end
#end
#No. 187965
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    XMLList descendants(XMLName xmlName)
    {
        XMLList result = new XMLList(lib);

        for (int i = 0; i < length(); i++)
        {
            XML xml = getXmlFromAnnotation(i);
            result.addToList(xml.descendants(xmlName));
        }

        return result;
    }

#end
#end
#No. 187966
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    Object[] inScopeNamespaces()
    {
        if(length() == 1)
        {
            return getXmlFromAnnotation(0).inScopeNamespaces();
        }
        else
        {
            throw ScriptRuntime.typeError("The inScopeNamespaces method works only on lists containing one item");
        }
    }

#end
#end
#No. 187967
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param child
     * @param xml
     */

#Code:
    XML insertChildAfter(Object child, Object xml)
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).insertChildAfter(child, xml);
        }
        else
        {
            throw ScriptRuntime.typeError("The insertChildAfter method works only on lists containing one item");
        }
    }

#end
#end
#No. 187968
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param child
     * @param xml
     */

#Code:
    XML insertChildBefore(Object child, Object xml)
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).insertChildAfter(child, xml);
        }
        else
        {
            throw ScriptRuntime.typeError("The insertChildBefore method works only on lists containing one item");
        }
    }

#end
#end
#No. 187969
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    boolean hasOwnProperty(XMLName xmlName)
    {
        boolean hasProperty = false;

        if (prototypeFlag)
        {
            String property = xmlName.localName();
            hasProperty = (0 != findPrototypeId(property));
        }
        else
        {
            hasProperty = (getPropertyList(xmlName).length() > 0);
        }

        return hasProperty;
    }

#end
#end
#No. 187970
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    boolean hasComplexContent()
    {
        boolean complexContent;
        int length = length();

        if (length == 0)
        {
            complexContent = false;
        }
        else if (length == 1)
        {
            complexContent = getXmlFromAnnotation(0).hasComplexContent();
        }
        else
        {
            complexContent = false;

            for (int i = 0; i < length; i++)
            {
                XML nextElement = getXmlFromAnnotation(i);
                if (nextElement.tokenType() == XmlCursor.TokenType.START)
                {
                    complexContent = true;
                    break;
                }
            }
        }

        return complexContent;
    }

#end
#end
#No. 187971
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    boolean hasSimpleContent()
    {
        boolean simpleContent;
        int length = length();

        if (length == 0)
        {
            simpleContent = true;
        }
        else if (length == 1)
        {
            simpleContent = getXmlFromAnnotation(0).hasSimpleContent();
        }
        else
        {
            simpleContent = true;

            for (int i = 0; i < length; i++)
            {
                XML nextElement = getXmlFromAnnotation(i);
                if (nextElement.tokenType() == XmlCursor.TokenType.START)
                {
                    simpleContent = false;
                    break;
                }
            }
        }

        return simpleContent;
    }

#end
#end
#No. 187972
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    int length()
    {
        int result = 0;

        if (_annos != null)
        {
            result = _annos.length();
        }

        return result;
    }

#end
#end
#No. 187973
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    String localName()
    {
        if (length() == 1)
        {
            return name().localName();
        }
        else
        {
            throw ScriptRuntime.typeError("The localName method works only on lists containing one item");
        }
    }

#end
#end
#No. 187974
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    QName name()
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).name();
        }
        else
        {
            throw ScriptRuntime.typeError("The name method works only on lists containing one item");
        }
    }

#end
#end
#No. 187975
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param prefix
     * @return
     */

#Code:
    Object namespace(String prefix)
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).namespace(prefix);
        }
        else
        {
            throw ScriptRuntime.typeError("The namespace method works only on lists containing one item");
        }
    }

#end
#end
#No. 187976
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    Object[] namespaceDeclarations()
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).namespaceDeclarations();
        }
        else
        {
            throw ScriptRuntime.typeError("The namespaceDeclarations method works only on lists containing one item");
        }
    }

#end
#end
#No. 187977
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    Object nodeKind()
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).nodeKind();
        }
        else
        {
            throw ScriptRuntime.typeError("The nodeKind method works only on lists containing one item");
        }
    }

#end
#end
#No. 187978
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     */

#Code:
    void normalize()
    {
        for (int i = 0; i < length(); i++)
        {
            getXmlFromAnnotation(i).normalize();
        }
    }

#end
#end
#No. 187979
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     * If list is empty, return undefined, if elements have different parents return undefined,
     * If they all have the same parent, return that parent.
     *
     * @return
     */

#Code:
    Object parent()
    {
        Object sameParent = Undefined.instance;

        if ((length() == 0) && (targetObject != null) && (targetObject instanceof XML))
        {
            sameParent = targetObject;
        }
        else
        {
            for (int i = 0; i < length(); i++)
            {
                Object currParent = getXmlFromAnnotation(i).parent();

                if (i == 0)
                {
                    // Set the first for the rest to compare to.
                    sameParent = currParent;
                }
                else if (sameParent != currParent)
                {
                    sameParent = Undefined.instance;
                    break;
                }
            }
        }

        // If everything in the list is the sameParent then return that as the parent.
        return sameParent;
    }

#end
#end
#No. 187980
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param xml
     * @return
     */

#Code:
    XML prependChild(Object xml)
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).prependChild(xml);
        }
        else
        {
            throw ScriptRuntime.typeError("The prependChild method works only on lists containing one item");
        }
    }

#end
#end
#No. 187981
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    Object processingInstructions(XMLName xmlName)
    {
        XMLList result = new XMLList(lib);

        for (int i = 0; i < length(); i++)
        {
            XML xml = getXmlFromAnnotation(i);

            result.addToList(xml.processingInstructions(xmlName));
        }

        return result;
    }

#end
#end
#No. 187982
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param name
     * @return
     */

#Code:
    boolean propertyIsEnumerable(Object name)
    {
        long index;
        if (name instanceof Integer) {
            index = ((Integer)name).intValue();
        } else if (name instanceof Number) {
            double x = ((Number)name).doubleValue();
            index = (long)x;
            if (index != x) {
                return false;
            }
            if (index == 0 && 1.0 / x < 0) {
                // Negative 0
                return false;
            }
        } else {
            String s = ScriptRuntime.toString(name);
            index = ScriptRuntime.testUint32String(s);
        }
        return (0 <= index && index < length());
    }

#end
#end
#No. 187983
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param ns
     */

#Code:
    XML removeNamespace(Namespace ns)
    {
        if(length() == 1)
        {
            return getXmlFromAnnotation(0).removeNamespace(ns);
        }
        else
        {
            throw ScriptRuntime.typeError("The removeNamespace method works only on lists containing one item");
        }
    }

#end
#end
#No. 187984
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param propertyName
     * @param xml
     * @return
     */

#Code:
    XML replace(XMLName xmlName, Object xml)
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).replace(xmlName, xml);
        }
        else
        {
            throw ScriptRuntime.typeError("The replace method works only on lists containing one item");
        }
    }

#end
#end
#No. 187985
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param xml
     */

#Code:
    XML setChildren(Object xml)
    {
        if (length() == 1)
        {
            return getXmlFromAnnotation(0).setChildren(xml);
        }
        else
        {
            throw ScriptRuntime.typeError("The setChildren method works only on lists containing one item");
        }
    }

#end
#end
#No. 187986
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param name
     */

#Code:
    void setLocalName(String localName)
    {
        if (length() == 1)
        {
            getXmlFromAnnotation(0).setLocalName(localName);
        }
        else
        {
            throw ScriptRuntime.typeError("The setLocalName method works only on lists containing one item");
        }
    }

#end
#end
#No. 187987
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param name
     */

#Code:
    void setName(QName qname)
    {
        if (length() == 1)
        {
            getXmlFromAnnotation(0).setName(qname);
        }
        else
        {
            throw ScriptRuntime.typeError("The setName method works only on lists containing one item");
        }
    }

#end
#end
#No. 187988
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param ns
     */

#Code:
    void setNamespace(Namespace ns)
    {
        if (length() == 1)
        {
            getXmlFromAnnotation(0).setNamespace(ns);
        }
        else
        {
            throw ScriptRuntime.typeError("The setNamespace method works only on lists containing one item");
        }
    }

#end
#end
#No. 187989
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * * @return
     */

#Code:
    XMLList text()
    {
        XMLList result = new XMLList(lib);

        for (int i = 0; i < length(); i++)
        {
            result.addToList(getXmlFromAnnotation(i).text());
        }

        return result;
    }

#end
#end
#No. 187990
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    public String toString()
    {
        if (hasSimpleContent())
        {
            StringBuffer sb = new StringBuffer();

            for(int i = 0; i < length(); i++)
            {
                XML next = getXmlFromAnnotation(i);
                sb.append(next.toString());
            }

            return sb.toString();
        }
        else
        {
            return toXMLString(0);
        }
    }

#end
#end
#No. 187991
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    String toXMLString(int indent)
    {
        StringBuffer sb = new StringBuffer();

        for(int i = 0; i < length(); i++)
        {
            if (i > 0)
            {
                sb.append('\n');
            }

            sb.append(getXmlFromAnnotation(i).toXMLString(indent));
        }

        return sb.toString();
    }

#end
#end
#No. 187992
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @return
     */

#Code:
    Object valueOf()
    {
        return this;
    }

#end
#end
#No. 187993
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param target
     * @return
     */

#Code:
    boolean equivalentXml(Object target)
    {
        boolean result = false;

        // Zero length list should equate to undefined
        if (target instanceof Undefined && length() == 0)
        {
            result = true;
        }
        else if (length() == 1)
        {
            result = getXmlFromAnnotation(0).equivalentXml(target);
        }
        else if (target instanceof XMLList)
        {
            XMLList otherList = (XMLList) target;

            if (otherList.length() == length())
            {
                result = true;

                for (int i = 0; i < length(); i++)
                {
                    if (!getXmlFromAnnotation(i).equivalentXml(otherList.getXmlFromAnnotation(i)))
                    {
                        result = false;
                        break;
                    }
                }
            }
        }

        return result;
    }

#end
#end
#No. 187994
#File: E:\bishe\1\XMLList.java
#Comment:
    /**
     *
     * @param name
     * @param start
     * @return
     */

#Code:
    private XMLList getPropertyList(XMLName name)
    {
        XMLList propertyList = new XMLList(lib);
        javax.xml.namespace.QName qname = null;

        if (!name.isDescendants() && !name.isAttributeName())
        {
            // Only set the targetProperty if this is a regular child get
            // and not a descendant or attribute get
            qname = new javax.xml.namespace.QName(name.uri(), name.localName());
        }

        propertyList.setTargets(this, qname);

        for (int i = 0; i < length(); i++)
        {
            propertyList.addToList(
                getXmlFromAnnotation(i).getPropertyList(name));
        }

        return propertyList;
    }


#end
#end
#No. 187996
#File: E:\bishe\1\XmlManipulationUtils.java
#Comment:
  /**
   * Traverse submission looking for OpenRosa metadata tag (with or without
   * namespace).
   * 
   * @param parent
   * @return
   */

#Code:
  private static Element findMetaTag(Element parent, String rootUri) {
    for (int i = 0; i < parent.getChildCount(); ++i) {
      if (parent.getType(i) == Node.ELEMENT) {
        Element child = parent.getElement(i);
        String cnUri = child.getNamespace();
        String cnName = child.getName();
        if (cnName.equals(OPEN_ROSA_METADATA_TAG)
            && (cnUri == null || 
                cnUri.equals(EMPTY_STRING) || 
                cnUri.equals(rootUri) ||
                cnUri.equalsIgnoreCase(OPEN_ROSA_NAMESPACE) || 
                cnUri.equalsIgnoreCase(OPEN_ROSA_NAMESPACE_SLASH) || 
                cnUri.equalsIgnoreCase(OPEN_ROSA_NAMESPACE_PRELIM))) {
          return child;
        } else {
          Element descendent = findMetaTag(child, rootUri);
          if (descendent != null)
            return descendent;
        }
      }
    }
    return null;
  }

#end
#end
#No. 187997
#File: E:\bishe\1\XmlManipulationUtils.java
#Comment:
  /**
   * Find the OpenRosa instanceID defined for this record, if any.
   * 
   * @return
   */

#Code:
  public static String getOpenRosaInstanceId(Element root) {
    String rootUri = root.getNamespace();
    Element meta = findMetaTag(root, rootUri);
    if (meta != null) {
      for (int i = 0; i < meta.getChildCount(); ++i) {
        if (meta.getType(i) == Node.ELEMENT) {
          Element child = meta.getElement(i);
          String cnUri = child.getNamespace();
          String cnName = child.getName();
          if (cnName.equals(OPEN_ROSA_INSTANCE_ID)
              && (cnUri == null || 
                  cnUri.equals(EMPTY_STRING) || 
                  cnUri.equals(rootUri) ||
                  cnUri.equalsIgnoreCase(OPEN_ROSA_NAMESPACE) || 
                  cnUri.equalsIgnoreCase(OPEN_ROSA_NAMESPACE_SLASH) || 
                  cnUri.equalsIgnoreCase(OPEN_ROSA_NAMESPACE_PRELIM))) {
            return XFormParser.getXMLText(child, true);
          }
        }
      }
    }
    return null;
  }

#end
#end
#No. 187998
#File: E:\bishe\1\XmlManipulationUtils.java
#Comment:
  /**
   * Encrypted field-level encryption key. 
   * 
   * @param root
   * @return
   */

#Code:
  public static String getBase64EncryptedFieldKey(Element root) {
    String rootUri = root.getNamespace();
    Element meta = findMetaTag(root, rootUri);
    if (meta != null) {
      for (int i = 0; i < meta.getChildCount(); ++i) {
        if (meta.getType(i) == Node.ELEMENT) {
          Element child = meta.getElement(i);
          String cnUri = child.getNamespace();
          String cnName = child.getName();
          if (cnName.equals(BASE64_ENCRYPTED_FIELD_KEY)
              && (cnUri == null || 
                  cnUri.equals(EMPTY_STRING) || 
                  cnUri.equals(rootUri) ||
                  cnUri.equalsIgnoreCase(OPEN_ROSA_NAMESPACE) || 
                  cnUri.equalsIgnoreCase(OPEN_ROSA_NAMESPACE_SLASH))) {
            return XFormParser.getXMLText(child, true);
          }
        }
      }
    }
    return null;
  }

#end
#end
#No. 187999
#File: E:\bishe\1\XmlMarkup.java
#Comment:
/**
 * List of constants used by <code>Xml</code> markup syntax.
 *
 * @author <a href="mailto:vincent.siveton@gmail.com">Vincent Siveton</a>
 * @version $Id$
 * @since 1.0
 */

#Code:
@SuppressWarnings( "checkstyle:interfaceistype" )
public interface XmlMarkup
    extends Markup
{
    /** XML namespace: "http://www.w3.org/2001/XMLSchema-instance" */
    String XML_NAMESPACE = "http://www.w3.org/2001/XMLSchema-instance";

    // ----------------------------------------------------------------------
    // Xml separator characters
    // ----------------------------------------------------------------------

    /** bang character: '!' */
    char BANG = '!';

    // ----------------------------------------------------------------------
    // Xml constants
    // ----------------------------------------------------------------------

    /** CDATA. String: "CDATA". */
    String CDATA = "CDATA";

    /** DOCTYPE start. String: "&lt;!DOCTYPE". */
    String DOCTYPE_START = "<!DOCTYPE";

    /** ENTITY start. String: "&lt;!ENTITY". */
    String ENTITY_START = "<!ENTITY";
}

#end
#end
#No. 188000
#File: E:\bishe\1\XmlMarshaller.java
#Comment:
    /**
     * sort PropertyDescriptors according to propOrder.
     * properties listed in propOrder come first, in the order they are listed, and
     * then come remaining unlisted properties, in arbitrary order (likely alphabetical).
     * this semantics is rather relaxed compared to original JAXB semantics, where props
     * and propOrder must be the same set (except for those marked XmlTransient).
     * @param props PropertyDescriptor array to be sorted in-place.
     * @param propOrder list of property names in order of desired appearance. 
     */

#Code:
    protected static void orderProperties(PropertyDescriptor[] props, final String[] propOrder) {
        if (propOrder == null || propOrder.length == 0) return;
        final Map<String, Integer> order = new HashMap<String, Integer>();
        for (int i = 0; i < propOrder.length; i++) {
            order.put(propOrder[i], i);
        }
        final Integer LAST = Integer.valueOf(propOrder.length);
        Arrays.sort(props, new Comparator<PropertyDescriptor>() {
            @Override
            public int compare(PropertyDescriptor o1, PropertyDescriptor o2) {
                Integer c1 = order.get(o1.getName());
                Integer c2 = order.get(o2.getName());
                return (c1 != null ? c1 : LAST).compareTo(c2 != null ? c2 : LAST);
            } 
        });
    }

#end
#end
#No. 188001
#File: E:\bishe\1\XmlMarshaller.java
#Comment:
    /**
     * test if {@code obj} has {@link XmlRootElement} annotation.
     * to avoid unexpected side effects, objects are mapped to nested XML structure
     * only when its class has {@link XmlRootElement} annotation.
     * note semantics is slightly different from JAXB - just borrowing XmlRootElement
     * as substitute of XmlElement, because Map entry cannot be annotated.
     * @param obj object to test
     * @return true if obj's class has XmlRootElement annotation.
     */

#Code:
    protected static boolean marshalAsElement(Object obj) {
    	XmlRootElement ann = obj.getClass().getAnnotation(XmlRootElement.class);
    	return ann != null;
    }

#end
#end
#No. 188002
#File: E:\bishe\1\XmlMarshaller.java
#Comment:
    /**
     * generate nested XML structure for a bean {@code obj}. enclosing element
     * will not be generated if {@code key} is empty. each readable JavaBeans property
     * is mapped to an nested element named after its name. Those properties
     * annotated with {@link XmlTransient} are ignored.
     * @param xmlWriter XmlWriter
     * @param key name of enclosing element
     * @param obj bean
     * @throws SAXException
     */

#Code:
    protected static void marshalBean(XmlWriter xmlWriter, String key, Object obj) throws SAXException {
        if (!StringUtils.isEmpty(key))
            xmlWriter.startElement(key);
        try {
            BeanInfo beanInfo = Introspector.getBeanInfo(obj.getClass(), Object.class);
            PropertyDescriptor[] props = beanInfo.getPropertyDescriptors();
            XmlType xmlType = obj.getClass().getAnnotation(XmlType.class);
            if (xmlType != null) {
                String[] propOrder = xmlType.propOrder();
                if (propOrder != null) {
                    // TODO: should cache this sorted version?
                    orderProperties(props, propOrder);
                }
            }
            for (PropertyDescriptor prop : props) {
                Method m = prop.getReadMethod();
                if (m == null || m.getAnnotation(XmlTransient.class) != null)
                    continue;
                try {
                    Object propValue = m.invoke(obj);
                    if (propValue != null && !"".equals(propValue)) {
                        marshal(xmlWriter, prop.getName(), propValue);
                    }
                } catch (Exception ex) {
                    // generate empty element, for now. generate comment?
                    xmlWriter.emptyElement(prop.getName());
                }
            }
        } catch (IntrospectionException ex) {
            // ignored, for now.
        }
        if (!StringUtils.isEmpty(key))
            xmlWriter.endElement(key);
    }

#end
#end
#No. 188003
#File: E:\bishe\1\XmlMarshallerTest.java
#Comment:
    /**
     * Map with nested Map
     * @throws Exception
     */

#Code:
    public void testMarshalMap() throws Exception {
        Map<String, Object> map = new LinkedHashMap<String, Object>();
        map.put("c", 1);
        map.put("a", "a-value");
        Map<String, Object> nestedMap = new LinkedHashMap<String, Object>();
        nestedMap.put("x", 10);
        nestedMap.put("y", "y-value");
        map.put("m", nestedMap);
        
        StringWriter w = new StringWriter();
        XmlMarshaller.marshalDocument(w, "doc", map);
        
        String expected = "(?s:)" +
                "^<\\?xml version=\"1\\.0\" standalone='yes'\\?>\\s*" +
                "<doc>\\s*<c>1</c>\\s*<a>a-value</a>\\s*" +
                "<m>\\s*<x>10</x>\\s*<y>y-value</y>\\s*</m>\\s*" +
                "</doc>\\s*$";
        String xml = w.toString();
        System.out.println(xml);
        assertTrue("xml matches expected RE", xml.matches(expected));
    }

#end
#end
#No. 188004
#File: E:\bishe\1\XmlMarshallerTest.java
#Comment:
    /**
     * Bean with nested Bean
     * @throws Exception
     */

#Code:
    public void testMashalBean() throws Exception {
        Object bean = new Model();
        StringWriter w = new StringWriter();
        XmlMarshaller.marshalDocument(w, "doc", bean);
        
        String expected = "(?s:)" +
                "^<\\?xml version=\"1\\.0\" standalone='yes'\\?>\\s*" +
                "<doc>\\s*<c>1</c>\\s*<a>a-value</a>\\s*" +
                "<m>\\s*<x>10</x>\\s*<y>y-value</y>\\s*</m>\\s*" +
                "</doc>\\s*$";
        String xml = w.toString();
        System.out.println(xml);
        assertTrue("xml matches expected RE", xml.matches(expected));
    }

#end
#end
#No. 188005
#File: E:\bishe\1\XmlMarshallerTest.java
#Comment:
    /**
     * Map with nested Bean
     * @throws Exception
     */

#Code:
    public void testMarshalBeanInMap() throws Exception {
        Map<String, Object> map = new LinkedHashMap<String, Object>();
        map.put("c", 1);
        map.put("a", "a-value");
        Object m = new NestedModel();
        map.put("m", m);
        
        StringWriter w = new StringWriter();
        XmlMarshaller.marshalDocument(w, "doc", map);
        
        String expected = "(?s:)" +
                "^<\\?xml version=\"1\\.0\" standalone='yes'\\?>\\s*" +
                "<doc>\\s*<c>1</c>\\s*<a>a-value</a>\\s*" +
                "<m>\\s*<x>10</x>\\s*<y>y-value</y>\\s*</m>\\s*" +
                "</doc>\\s*$";
        String xml = w.toString();
        System.out.println(xml);
        assertTrue("xml matches expected RE", xml.matches(expected));
    }

#end
#end
#No. 188006
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Create a new stream parser from the given input stream.
     *
     * @param stream An {@link InputStream} stream to parse.
     */

#Code:
    private XMLMediaParser(InputStream stream, String encoding) throws XMLStreamException {
        super(stream, encoding);
    }

#end
#end
#No. 188007
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse the input stream as one of {@link Result}, {@link Artist},
     * {@link Album} or {@link Track}, depending on the document element.
     *
     * @return An {@link Object} which can then be cast.
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private Object parse() throws XMLStreamException, XMLParserException {
        String name;

        /* Check if reader is currently on a start element. */
        if (this.reader.getEventType() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Check current element name and start parsing it. */
            if (name.equals("result")) {
                return this.parseResult();
            } else if (name.equals("toplist")) {
                return this.parseResult();
            } else if (name.equals("artist")) {
                return this.parseArtist();
            } else if (name.equals("album")) {
                return this.parseAlbum();
            } else if (name.equals("track")) {
                return this.parseTrack();
            } else {
                System.out.println("Unexpected element '<" + name + ">' while parsing root xml.");
            }
        }

        throw new IllegalStateException("Reader is not on a start element!");
    }

#end
#end
#No. 188008
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse the input stream as a {@link Result}.
     *
     * @return A {@link Result} object.
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private Result parseResult() throws XMLStreamException, XMLParserException {
        Result result = new Result();
        String name;

        /* Go to next element and check if it is a start element. */
        while (this.reader.next() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Process depending on element name. */
            if (name.equals("version")) {
                int version = this.getElementInteger();

                /* Check version. */
                if (version > SUPPORTED_RESULT_VERSION) {
                    throw new XMLParserException(
                            "Unsupported <result> version " + version, this.reader.getLocation()
                    );
                }
            } else if (name.equals("did-you-mean")) {
                result.setSuggestion(this.getElementString());
            } else if (name.equals("total-artists")) {
                result.setTotalArtists(this.getElementInteger());
            } else if (name.equals("total-albums")) {
                result.setTotalAlbums(this.getElementInteger());
            } else if (name.equals("total-tracks")) {
                result.setTotalTracks(this.getElementInteger());
            } else if (name.equals("artists")) {
                result.setArtists(parseArtists());
            } else if (name.equals("albums")) {
                result.setAlbums(parseAlbums());
            } else if (name.equals("tracks")) {
                result.setTracks(parseTracks());
            } else {
                getElementString();
                System.out.println("Unexpected element '<" + name + ">' while parsing result.");
            }
        }

        return result;
    }

#end
#end
#No. 188009
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse the input stream as a list of artists.
     *
     * @return A {@link List} of {@link Artist} objects.
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private List<Artist> parseArtists() throws XMLStreamException, XMLParserException {
        List<Artist> artists = new ArrayList<Artist>();
        String name;

        /* Go to next element and check if it is a start element. */
        while (this.reader.next() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Process depending on element name. */
            if (name.equals("artist")) {
                artists.add(parseArtist());
            } else {
                getElementString();
                System.out.println("Unexpected element '<" + name + ">' while parsing artists.");
            }
        }

        return artists;
    }

#end
#end
#No. 188010
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse the input stream as a list of albums.
     *
     * @return A {@link List} of {@link Album} objects.
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private List<Album> parseAlbums() throws XMLStreamException, XMLParserException {
        List<Album> albums = new ArrayList<Album>();
        String name;

        /* Go to next element and check if it is a start element. */
        while (this.reader.next() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Process depending on element name. */
            if (name.equals("album")) {
                albums.add(parseAlbum());
            } else {
                getElementString();
                System.out.println("Unexpected element '<" + name + ">' while parsing albums.");
            }
        }

        return albums;
    }

#end
#end
#No. 188011
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse the input stream as a list of tracks.
     *
     * @return A {@link List} of {@link Track} objects.
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private List<Track> parseTracks() throws XMLStreamException, XMLParserException {
        List<Track> tracks = new ArrayList<Track>();
        String name;

        /* Go to next element and check if it is a start element. */
        while (this.reader.next() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Process depending on element name. */
            if (name.equals("track")) {
                tracks.add(parseTrack());
            } else {
                getElementString();
                System.out.println("Unexpected element '<" + name + ">' while parsing tracks.");
            }
        }

        return tracks;
    }

#end
#end
#No. 188012
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse the input stream as an image.
     *
     * @return The image id.
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private String parseImage() throws XMLStreamException, XMLParserException {
        String id = null;
        String name;
        int type;

        /* Go to next element and check if it is a start element. */
        while ((type = this.reader.next()) == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Process depending on element name. */
            if (name.equals("id")) {
                id = this.getElementString();
            } else if (name.equals("width")) {
                this.getElementString(); /* Skip. */
            } else if (name.equals("height")) {
                this.getElementString(); /* Skip. */
            } else {
                getElementString();
                System.out.println("Unexpected element '<" + name + ">' while parsing image.");
            }
        }

        /* If the reader is not at an end element, it is at some character event. */
        if (type != END_ELEMENT) {
            /* Read image id from element text (special case). */
            id = this.reader.getText().trim();

            /* Skip to end element. */
            this.reader.next();
        }

        return id;
    }

#end
#end
#No. 188013
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse the input stream as a list of files.
     *
     * @return A {@link List} of {@link File} objects.
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private List<File> parseFiles() throws XMLStreamException, XMLParserException {
        List<File> files = new ArrayList<File>();
        String name;

        /* Go to next element and check if it is a start element. */
        while (this.reader.next() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Process depending on element name. */
            if (name.equals("file")) {
                files.add(new File(
                        getAttributeString("id"), getAttributeString("format")
                ));

                /* Skip to end element, since we only read the attributes. */
                this.reader.next();
            } else {
                getElementString();
                System.out.println("Unexpected element '<" + name + ">' while parsing files.");
            }
        }

        return files;
    }

#end
#end
#No. 188014
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse the input stream as a list of restrictions.
     *
     * @return A {@link List} of {@link Restriction} objects.
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private List<Restriction> parseRestrictions() throws XMLStreamException, XMLParserException {
        List<Restriction> restrictions = new ArrayList<Restriction>();
        String name;

        /* Go to next element and check if it is a start element. */
        while (this.reader.next() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Process depending on element name. */
            if (name.equals("restriction")) {
                restrictions.add(new Restriction(
                        getAttributeString("allowed"),
                        getAttributeString("forbidden"),
                        getAttributeString("catalogues")
                ));

                /* Skip to end element since we only read the attributes. */
                this.reader.next();
            } else {
                getElementString();
                System.out.println("Unexpected element '<" + name + ">' while parsing restrictions.");
            }
        }

        return restrictions;
    }

#end
#end
#No. 188015
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse the input stream as a map of external ids.
     *
     * @return A {@link Map} containing external ids.
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private Map<String, String> parseExternalIds() throws XMLStreamException, XMLParserException {
        Map<String, String> externalIds = new HashMap<String, String>();
        String name;

        /* Go to next element and check if it is a start element. */
        while (this.reader.next() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Process depending on element name. */
            if (name.equals("external-id")) {
                externalIds.put(
                        getAttributeString("type"), getAttributeString("id")
                );

                /* Skip to end element since we only read the attributes. */
                this.reader.next();
            } else {
                getElementString();
                System.out.println("Unexpected element '<" + name + ">' while parsing external ids.");
            }
        }

        return externalIds;
    }

#end
#end
#No. 188016
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Skip any {@literal <link>} elements.
     *
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private void skipAlternatives() throws XMLStreamException, XMLParserException {
        String name;

        /* Go to next element and check if it is a start element. */
        while (this.reader.next() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Process depending on element name. */
            if (name.equals("track")) {
                parseTrack();
            } else {
                throw new XMLParserException(
                        "Unexpected element '<" + name + ">'", this.reader.getLocation()
                );
            }
        }
    }

#end
#end
#No. 188017
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Skip any {@literal <link>} elements.
     *
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private void skipLinks() throws XMLStreamException, XMLParserException {
        String name;

        /* Go to next element and check if it is a start element. */
        while (this.reader.next() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Process depending on element name. */
            if (name.equals("link")) {
                /* Skip text. */
                this.getElementString();
            } else {
                getElementString();
                System.out.println("Unexpected element '<" + name + ">' while parsing links.");
            }
        }
    }

#end
#end
#No. 188018
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse {@code xml} into an object using the specified {@code encoding}.
     *
     * @param xml      The xml as bytes.
     * @param encoding The encoding to use.
     * @return An object if successful, null if not.
     */

#Code:
    public static Object parse(byte[] xml, String encoding) {
        try {
//            System.out.println("xml: " + new String(xml, encoding));
            XMLMediaParser parser = new XMLMediaParser(new ByteArrayInputStream(xml, 0, xml.length - 1), encoding);

            return parser.parse();
        } catch (XMLStreamException e) {
            e.printStackTrace();

            return null;
        } catch (XMLParserException e) {
            e.printStackTrace();

            return null;
        }
//        catch (UnsupportedEncodingException e) {
//            e.printStackTrace();
//            return null;
//        }
    }

#end
#end
#No. 188019
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse {@code xml} into a {@link Result} object using the specified {@code encoding}.
     *
     * @param xml      The xml as bytes.
     * @param encoding The encoding to use.
     * @return A {@link Result} object if successful, null if not.
     */

#Code:
    public static Result parseResult(byte[] xml, String encoding) {
        Object result = parse(xml, encoding);

        if (result instanceof Result) {
            return (Result) result;
        }

        return null;
    }

#end
#end
#No. 188020
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse {@code xml} into an {@link Artist} object using the specified {@code encoding}.
     *
     * @param xml      The xml as bytes.
     * @param encoding The encoding to use.
     * @return An {@link Artist} object if successful, null if not.
     */

#Code:
    public static Artist parseArtist(byte[] xml, String encoding) {
        Object artist = parse(xml, encoding);

        if (artist instanceof Artist) {
            return (Artist) artist;
        }

        return null;
    }

#end
#end
#No. 188021
#File: E:\bishe\1\XMLMediaParser.java
#Comment:
    /**
     * Parse {@code xml} into a {@link Album} object using the specified {@code encoding}.
     *
     * @param xml      The xml as bytes.
     * @param encoding The encoding to use.
     * @return A {@link Album} object if successful, null if not.
     */

#Code:
    public static Album parseAlbum(byte[] xml, String encoding) {
        Object album = parse(xml, encoding);

        if (album instanceof Album) {
            return (Album) album;
        }

        return null;
    }


#end
#end
#No. 188029
#File: E:\bishe\1\XmlMetadataConsumer.java
#Comment:
  /* This method gets the last base type of the EntityType 
   * which has key defined in order to validate it*/

#Code:
   private EntityType fetchLastBaseType
   (FullQualifiedName baseTypeFQName, Map<FullQualifiedName, EntityType> entityTypesMap) 
       throws EntityProviderException {
     
     EntityType baseEntityType = null ;
     while(baseTypeFQName!=null){
       baseEntityType = entityTypesMap.get(baseTypeFQName);
       if(baseEntityType.getKey()!=null){
         break;
       }else if(baseEntityType !=null && baseEntityType.getBaseType() !=null){
           baseTypeFQName = baseEntityType.getBaseType();
       }else if(baseEntityType.getBaseType() == null){
         break;
       }
     }
     return baseEntityType;
   }

#end
#end
#No. 188030
#File: E:\bishe\1\XmlNodeRow.java
#Comment:
/**
 * @since 1.4
 */

#Code:
class XmlNodeRow implements Row {
	private final XmlRowAttribute[] attributes;
	private final Node node;

	public XmlNodeRow(XmlRowAttribute[] attributes, Node node) {
		this.attributes = attributes;
		this.node = node;
	}

	@Override
	public Object get(RowAttribute attribute) {
		// TODO: remove cast (maybe Row should have a generic type argument,
		// indicating the type of it's attributes? this will require global refactoring though)
		XmlRowAttribute xmlAttribute = (XmlRowAttribute) attribute;
		try {
			return xmlAttribute.getSourceExpression().evaluate(node);
		} catch (XPathExpressionException e) {
			throw new LmRuntimeException("Failed to evaluate xPath expression: " + attribute.getSourceName(), e);
		}
	}

	@Override
	public RowAttribute[] attributes() {
		return attributes;
	}
}

#end
#end
#No. 188031
#File: E:\bishe\1\XmlNormalizer.java
#Comment:
    /**
     * Reads the XML file found at the provided filePath, returning a normalized
     * XML form suitable for comparison.
     *
     * @param filePath The path to the XML file to read.
     * @return A normalized, human-readable, version of the given XML document.
     */

#Code:
    public String getNormalizedXml(final String filePath) {

        // Read the provided filename
        final StringWriter toReturn = new StringWriter();
        final BufferedReader in;
        try {
            in = new BufferedReader(new FileReader(new File(filePath)));
        } catch (FileNotFoundException e) {
            throw new IllegalArgumentException("Could not find file [" + filePath + "]", e);
        }

        // Parse into a Document
        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);

        Document document = null;
        try {

            document = factory.newDocumentBuilder().parse(new InputSource(in));
            Transformer transformer = FACTORY.newTransformer();
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            transformer.transform(new DOMSource(document.getFirstChild()), new StreamResult(toReturn));

        } catch (Exception e) {
            throw new IllegalArgumentException("Could not transform DOM Document", e);
        }

        // All done.
        return toReturn.toString();
    }

#end
#end
#No. 188032
#File: E:\bishe\1\XMLNoteDocument.java
#Comment:
/***********************************************************************************************
 * This is an internal class for date representation for meta key/values.
 ***********************************************************************************************/

#Code:
class Date extends java.util.Date {

	/**
	 * Version
	 */
	private static final long serialVersionUID = 1L;
	
	private static SimpleDateFormat format=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ"); 
	
	public String toString() {
		return format.format(this);
	}
	
	public java.util.Date dt() {
		return new java.util.Date(this.getTime());
	}
	
	public static java.util.Date parseDate(String txt) {
		try {
			return format.parse(txt);
		} catch (ParseException e) {
			DefaultXMLNoteErrorHandler.exception(e);
			return new java.util.Date();
		}
	}
	
	public Date(java.util.Date dt) {
		super(dt.getTime());
	}
	
}

#end
#end
#No. 188034
#File: E:\bishe\1\XMLNoteParStyle.java
#Comment:
	/**
	 * Returns a copy of the current paragraph style, without associating it with a XMLNoteStyles container.
	 * @return
	 */

#Code:
	public XMLNoteParStyle copy() {
		return new XMLNoteParStyle(null,toString());
	}

#end
#end
#No. 188035
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Returns an iterator over all entries in JXMLNoteStyles.
	 * @return
	 */

#Code:
	public Iterator<Entry<String,XMLNoteParStyle>> iterator() {
		Set<Entry<String,XMLNoteParStyle>> s=_styles.entrySet();
		Vector<Entry<String,XMLNoteParStyle>> v=new Vector<Entry<String,XMLNoteParStyle>>();
		Iterator<Entry<String,XMLNoteParStyle>> it=s.iterator();
		while(it.hasNext()) {
			v.add(it.next());
		}
		return v.iterator();
	}

#end
#end
#No. 188036
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Returns all keys of the JXMLNoteParStyle styles in this styles, sorted alphabetically on key (or styleId).
	 * @return
	 */

#Code:
	public Vector<String> getStyleKeys() {
		Vector<String> v=new Vector<String>();
		Enumeration<String> en=_styles.keys();
		while(en.hasMoreElements()) {
			v.add(en.nextElement());
		}
		Collections.sort(v);
		_keys=v;
		return v;
	}

#end
#end
#No. 188037
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Returns the default style for paragraphs
	 * @return
	 * @throws BadStyleException
	 */

#Code:
	public XMLNoteParStyle getDefaultStyle() throws BadStyleException {
		int i=getDefaultStyleIndex();
		if (i==-1) {
			throw new BadStyleException("No default style in XMLNoteStyles");
		}
		return getStyle(i);
	}

#end
#end
#No. 188038
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Returns all JXMLNoteParStyles as a CSS String.
	 * @return
	 */

#Code:
	public String asCSS(XMLNoteStyleIdConverter cvt) {
		Enumeration<XMLNoteParStyle> en=_styles.elements(); 
		StringBuffer buf=new StringBuffer();
		while (en.hasMoreElements()) {
			buf.append(en.nextElement().asCSS(cvt));
			buf.append("\n");
		}
		return buf.toString();
	}

#end
#end
#No. 188039
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Zooms all styles with the given factor.
	 * @param factor
	 */

#Code:
	public void zoom(double factor) {
		Vector<String> keys=getStyleKeys();
		Iterator<String> it=keys.iterator();
		while(it.hasNext()) {
			String key=it.next();
			XMLNoteParStyle p=_styles.get(key);
			p.zoom(factor);
		}
	}

#end
#end
#No. 188040
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Returns the JXMLNoteParStyle with the given key; null, if key doesn't exist.
	 * @param key
	 * @return
	 */

#Code:
	public XMLNoteParStyle parStyle(String key) {
		return _styles.get(key);
	}

#end
#end
#No. 188041
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Adds a JXMLNoteParStyle with the given key to the styles.
	 * @param key
	 * @param s
	 */

#Code:
	public void addParStyle(String key,XMLNoteParStyle s) throws StyleContainedException {
		XMLNoteStyles q=s.getContainer();
		if (q!=null && q!=this) {
			String form=_translator.translate("The given paragraph style with id '%s' is already part of another style container");
			throw new StyleContainedException(String.format(form,s.id()));
		}
		_styles.put(key,s);
		_keys=null;
		informStylesChanged();
	}

#end
#end
#No. 188042
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Removes the JXMLNoteParStyle with the given key from the styles.
	 * @param key
	 */

#Code:
	public void removeParStyle(String key) {
		XMLNoteParStyle p=_styles.get(key);
		if (p!=null) {
			p.setContainer(null);
			_styles.remove(key);
			_keys=null;
		}
		informStylesChanged();
	}

#end
#end
#No. 188043
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Creates the default styles for a JXMLNote viewer (the styles used in the JXMLNoteDocument).
	 */

#Code:
	public XMLNoteStyles() {
		initContextName();
		init(new JXMLNotePreferences() {
			public String get(String key, String defaultValue) {
				return defaultValue;
			}
			public void put(String key, String value) {
			}
		});
	}

#end
#end
#No. 188044
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Creates the default styles for a JXMLNote viewer (the styles used in the XMLNoteDocument),
	 * read from the Preferences.
	 * @param prefs
	 */

#Code:
	public XMLNoteStyles(final Preferences prefs) {
		initContextName();
		init(new JXMLNotePreferences() {
			public String get(String key, String defaultValue) {
				return prefs.get(key, defaultValue);
			}
			public void put(String key, String value) {
				prefs.put(key, value);
			}
		});
	}

#end
#end
#No. 188045
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Returns the context name for this XMLNoteStyles. All XMLNoteDocuments associated with
	 * this XMLNoteStyles use this context and will therefore change their paragraph styles
	 * on changes in this container.
	 * 
	 * @return The context name of this XMLNoteStyles container
	 */

#Code:
	public String stylesContextName() {
		return _contextName;
	}

#end
#end
#No. 188046
#File: E:\bishe\1\XMLNoteStyles.java
#Comment:
	/**
	 * Returns the associated style context for all XMLNoteStyles. For internal use only.
	 * @return
	 */

#Code:
	public StyleContext getStyleContext() {
		return XMLNoteParStyle.getStyleContext();
	}

#end
#end
#No. 188047
#File: E:\bishe\1\XMLNoteTransferHandler.java
#Comment:
	/**
	 * Calls the previous handler of the JXMLNotePane.
	 * Drag is not supported yet
	 */

#Code:
	public void exportAsDrag(JComponent comp,InputEvent e,int action) {
		_defaultHandler.exportAsDrag(comp,e,action);
	}

#end
#end
#No. 188048
#File: E:\bishe\1\XMLNoteTransferHandler.java
#Comment:
	/**
	 * Exports the JXMLNoteDocument to the clipboard for the currently selected text.
	 */

#Code:
	public void exportToClipboard(JComponent comp,Clipboard clip,int action) throws IllegalStateException {
		//System.out.println(_defaultHandler.getClass());
		_action=action;
		 if ((action == COPY || action == MOVE)
				 && (getSourceActions(comp) & action) != 0) {
			 Transferable t = createTransferable(comp);
			 if (t != null) {
				 try {
					 clip.setContents(t, null);	 	// clip.setContents(createTransferable(comp),this);
					 exportDone(comp, t, action);
					 return;
				 } catch (IllegalStateException ise) {
					 exportDone(comp, t, NONE);
					 throw ise;
				 }
			 }
		 }
		 exportDone(comp, null, NONE);
	}

#end
#end
#No. 188049
#File: E:\bishe\1\XMLNoteTransferHandler.java
#Comment:
	/**
	 * Imports the data for XMLNote documents (application/xmlnote+xml, text/html, or text/plain) are
	 * supported. If XMLNote is imported, the XMLNote Document that is imported may contain XMLNoteMarks.
	 * These XMLNoteMarks will be reassigned new ids(), if XMLNoteDocument.getMarkIdReallocator() on the
	 * document that the clipboard data is pasted into, is not null.
	 */

#Code:
	public boolean importData(TransferHandler.TransferSupport support) {
		return importData((JComponent) support.getComponent(),support.getTransferable(),support);
	}

#end
#end
#No. 188050
#File: E:\bishe\1\XMLNoteTransferHandler.java
#Comment:
	/**
	 * Imports the data for XMLNote documents (application/xmlnote+xml, text/html, or text/plain) are
	 * supported. 
	 */

#Code:
	public boolean importData(JComponent comp,Transferable t) {
		return importData(comp,t,null);
	}

#end
#end
#No. 188051
#File: E:\bishe\1\XMLNoteTransferHandler.java
#Comment:
	/**
	 * Returns <code>canImport((JComponent) support.component(),supprt.getDataFlavors());</code>
	 */

#Code:
	public boolean canImport(TransferHandler.TransferSupport support) {
		Component c=support.getComponent();
		if (c instanceof JComponent) {
			return canImport((JComponent) c,support.getDataFlavors());
		} else {
			return _defaultHandler.canImport(support);
		}
	}

#end
#end
#No. 188052
#File: E:\bishe\1\XMLNoteTransferHandler.java
#Comment:
	/**
	 * Looks if one of the dataflavors for text/html, XMLNote or text/plain can be used.
	 */

#Code:
	public boolean canImport(JComponent comp,DataFlavor[] transferFlavors) {
		return flavorToImport(transferFlavors)!=null;
	}

#end
#end
#No. 188053
#File: E:\bishe\1\XMLNoteTransferHandler.java
#Comment:
	/**`
	 * @return COPY_OR_MOVE for an instance of JXMLNotePane
	 */

#Code:
	public int getSourceActions(JComponent c) {
		return _defaultHandler.getSourceActions(c);
	}

#end
#end
#No. 188054
#File: E:\bishe\1\XMLNoteTransferHandler.java
#Comment:
	/**
	 * @return a transferable for XMLNoteDocument. Supports three dataflavors:
	 * <code>text/plain</code>, <code>text/html</code> and <code>text/xml</code> (xmlnote xml). 
	 */

#Code:
	protected Transferable createTransferable(JComponent c) {
		return new XMLNoteTransferable(_action);
	}



#end
#end
#No. 188056
#File: E:\bishe\1\XMLNoteTransferHandler.java
#Comment:
	/**
	 * Removes text after copied to clipboard.
	 */

#Code:
	protected void exportDone(JComponent source,Transferable data,int action) {
		if (action == MOVE) {
			XMLNoteTransferable t = (XMLNoteTransferable) data;
			t.removeText();
		}
	}

#end
#end
#No. 188057
#File: E:\bishe\1\XMLNoteTransferHandler.java
#Comment:
	/**
	 * Creates a new XMLNoteTransferHandler on a JXMLNotePane. This transferhandler is specific for
	 * JXMLNotePanes, not for any other type of JComponent.
	 * 
	 *  
	 * @param _edit
	 */

#Code:
	public XMLNoteTransferHandler(JXMLNotePane editPane) {
		_defaultHandler=editPane.getTransferHandler();
		_editPane=editPane;
		editPane.setTransferHandler(this);
	
		// initialize accepted mimetypes per representation class
		_acceptedClasses=new Hashtable<String,Set<String>>();
		Set<String> htmlset=new HashSet<String>();
		htmlset.add("text/html");
		_acceptedClasses.put("java.nio.ByteBuffer",htmlset);
		Set<String> otherset=new HashSet<String>();
		otherset.add("text/plain");
		otherset.add("application/xmlnote+xml");
		_acceptedClasses.put("java.lang.String",otherset);
		
		// initialize accepted charsets per representation class
		_acceptedCharsets=new Hashtable<String,Set<String>>();
		htmlset=new HashSet<String>();
		htmlset.add("UTF-8");
		_acceptedCharsets.put("java.nio.ByteBuffer",htmlset);
		otherset=new HashSet<String>();
		otherset.add("Unicode");
		otherset.add("UTF-8");
		_acceptedCharsets.put("java.lang.String",otherset);
	}



#end
#end
#No. 188059
#File: E:\bishe\1\XmlnsPart.java
#Comment:
    /**
     * Creates an XmlnsPart.
     */

#Code:
    public XmlnsPart(String prefix, String namespace) {
        this.prefix = prefix;
        this.namespace = namespace;
    }

#end
#end
#No. 188060
#File: E:\bishe\1\XmlNumberAgreement.java
#Comment:
/**
 * <p>Java class for numberAgreement.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="numberAgreement">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="BOTH"/>
 *     &lt;enumeration value="PLURAL"/>
 *     &lt;enumeration value="SINGULAR"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "numberAgreement")
@XmlEnum
public enum XmlNumberAgreement {

    BOTH,
    PLURAL,
    SINGULAR;

    public String value() {
        return name();
    }

    public static XmlNumberAgreement fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 188061
#File: E:\bishe\1\XMLObjectImpl.java
#Comment:
    /**
     * XMLObject always compare with any value and equivalentValues
     * never returns {@link Scriptable#NOT_FOUND} for them but rather
     * calls equivalentXml(value) and wrap the result as Boolean.
     */

#Code:
    protected final Object equivalentValues(Object value)
    {
        boolean result = equivalentXml(value);
        return result ? Boolean.TRUE : Boolean.FALSE;
    }

#end
#end
#No. 188062
#File: E:\bishe\1\XMLObjectImpl.java
#Comment:
    /**
     * Implementation of ECMAScript [[Has]]
     */

#Code:
    public final boolean ecmaHas(Context cx, Object id)
    {
        if (cx == null) cx = Context.getCurrentContext();
        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);
        if (xmlName == null) {
            long index = ScriptRuntime.lastUint32Result(cx);
            // XXX Fix this cast
            return has((int)index, this);
        }
        return hasXMLProperty(xmlName);
    }

#end
#end
#No. 188063
#File: E:\bishe\1\XMLObjectImpl.java
#Comment:
    /**
     * Implementation of ECMAScript [[Get]]
     */

#Code:
    public final Object ecmaGet(Context cx, Object id)
    {
        if (cx == null) cx = Context.getCurrentContext();
        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);
        if (xmlName == null) {
            long index = ScriptRuntime.lastUint32Result(cx);
            // XXX Fix this cast
            Object result = get((int)index, this);
            if (result == Scriptable.NOT_FOUND) {
                result = Undefined.instance;
            }
            return result;
        }
        return getXMLProperty(xmlName);
    }

#end
#end
#No. 188064
#File: E:\bishe\1\XMLObjectImpl.java
#Comment:
    /**
     * Implementation of ECMAScript [[Put]]
     */

#Code:
    public final void ecmaPut(Context cx, Object id, Object value)
    {
        if (cx == null) cx = Context.getCurrentContext();
        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);
        if (xmlName == null) {
            long index = ScriptRuntime.lastUint32Result(cx);
            // XXX Fix this cast
            put((int)index, this, value);
            return;
        }
        putXMLProperty(xmlName, value);
    }

#end
#end
#No. 188065
#File: E:\bishe\1\XMLObjectImpl.java
#Comment:
    /**
     * Implementation of ECMAScript [[Delete]].
     */

#Code:
    public final boolean ecmaDelete(Context cx, Object id)
    {
        if (cx == null) cx = Context.getCurrentContext();
        XMLName xmlName = lib.toXMLNameOrIndex(cx, id);
        if (xmlName == null) {
            long index = ScriptRuntime.lastUint32Result(cx);
            // XXX Fix this
            delete((int)index);
            return true;
        }
        deleteXMLProperty(xmlName);
        return true;
    }

#end
#end
#No. 188066
#File: E:\bishe\1\XMLObjectImpl.java
#Comment:
    /**
     * Generic reference to implement x::ns, x.@ns::y, x..@ns::y etc.
     */

#Code:
    public Ref memberRef(Context cx, Object namespace, Object elem,
                         int memberTypeFlags)
    {
        XMLName xmlName = lib.toQualifiedName(cx, namespace, elem);
        if ((memberTypeFlags & Node.ATTRIBUTE_FLAG) != 0) {
            if (!xmlName.isAttributeName()) {
                xmlName.setAttributeName();
            }
        }
        if ((memberTypeFlags & Node.DESCENDANTS_FLAG) != 0) {
            xmlName.setIsDescendants();
        }
        xmlName.initXMLObject(this);
        return xmlName;
    }




#end
#end
#No. 188072
#File: E:\bishe\1\XmlPatchBodyReaderMountPointTest.java
#Comment:
    /**
     * Test trying to use Patch create operation which requires value without value. Error code 400 should be returned.
     */

#Code:
    @Test
    public void moduleDataValueMissingNegativeTest() throws Exception {
        final String uri = MOUNT_POINT + "instance-identifier-patch-module:patch-cont/my-list1=leaf1";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataValueMissing.xml");
        try {
            xmlToPatchBodyReader.readFrom(null, null, null, mediaType, null, inputStream);
            fail("Test should return error 400 due to missing value node when attempt to invoke create operation");
        } catch (final RestconfDocumentedException e) {
            assertEquals("Error code 400 expected", 400, e.getErrors().get(0).getErrorTag().getStatusCode());
        }
    }

#end
#end
#No. 188073
#File: E:\bishe\1\XmlPatchBodyReaderMountPointTest.java
#Comment:
    /**
     * Test trying to use value with Patch delete operation which does not support value. Error code 400 should be
     * returned.
     */

#Code:
    @Test
    public void moduleDataNotValueNotSupportedNegativeTest() throws Exception {
        final String uri = MOUNT_POINT + "instance-identifier-patch-module:patch-cont/my-list1=leaf1";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataValueNotSupported.xml");
        try {
            xmlToPatchBodyReader.readFrom(null, null, null, mediaType, null, inputStream);
            fail("Test should return error 400 due to present value node when attempt to invoke delete operation");
        } catch (final RestconfDocumentedException e) {
            assertEquals("Error code 400 expected", 400, e.getErrors().get(0).getErrorTag().getStatusCode());
        }
    }

#end
#end
#No. 188074
#File: E:\bishe\1\XmlPatchBodyReaderMountPointTest.java
#Comment:
    /**
     * Test of Yang Patch with absolute target path.
     */

#Code:
    @Test
    public void moduleDataAbsoluteTargetPathTest() throws Exception {
        final String uri = MOUNT_POINT;
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataAbsoluteTargetPath.xml");
        final PatchContext returnValue = xmlToPatchBodyReader
                .readFrom(null, null, null, mediaType, null, inputStream);
        checkPatchContextMountPoint(returnValue);
    }

#end
#end
#No. 188075
#File: E:\bishe\1\XmlPatchBodyReaderMountPointTest.java
#Comment:
    /**
     * Test using Patch when target is completely specified in request URI and thus target leaf contains only '/' sign.
     */

#Code:
    @Test
    public void modulePatchCompleteTargetInURITest() throws Exception {
        final String uri = MOUNT_POINT + "instance-identifier-patch-module:patch-cont";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataCompleteTargetInURI.xml");
        final PatchContext returnValue = xmlToPatchBodyReader
                .readFrom(null, null, null, mediaType, null, inputStream);
        checkPatchContextMountPoint(returnValue);
    }

#end
#end
#No. 188076
#File: E:\bishe\1\XmlPatchBodyReaderMountPointTest.java
#Comment:
    /**
     * Test of Yang Patch merge operation on list. Test consists of two edit operations - replace and merge.
     */

#Code:
    @Test
    public void moduleDataMergeOperationOnListTest() throws Exception {
        final String uri = MOUNT_POINT + "instance-identifier-patch-module:patch-cont/my-list1=leaf1";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataMergeOperationOnList.xml");
        final PatchContext returnValue = xmlToPatchBodyReader
                .readFrom(null, null, null, mediaType, null, inputStream);
        checkPatchContextMountPoint(returnValue);
    }

#end
#end
#No. 188077
#File: E:\bishe\1\XmlPatchBodyReaderMountPointTest.java
#Comment:
    /**
     * Test of Yang Patch merge operation on container. Test consists of two edit operations - create and merge.
     */

#Code:
    @Test
    public void moduleDataMergeOperationOnContainerTest() throws Exception {
        final String uri = MOUNT_POINT + "instance-identifier-patch-module:patch-cont";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataMergeOperationOnContainer.xml");
        final PatchContext returnValue = xmlToPatchBodyReader
                .readFrom(null, null, null, mediaType, null, inputStream);
        checkPatchContextMountPoint(returnValue);
    }

#end
#end
#No. 188078
#File: E:\bishe\1\XmlPatchBodyReaderTest.java
#Comment:
    /**
     * Test trying to use Patch create operation which requires value without value. Error code 400 should be returned.
     */

#Code:
    @Test
    public void moduleDataValueMissingNegativeTest() throws Exception {
        final String uri = "instance-identifier-patch-module:patch-cont/my-list1=leaf1";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataValueMissing.xml");
        try {
            xmlToPatchBodyReader.readFrom(null, null, null, mediaType, null, inputStream);
            fail("Test should return error 400 due to missing value node when attempt to invoke create operation");
        } catch (final RestconfDocumentedException e) {
            assertEquals("Error code 400 expected", 400, e.getErrors().get(0).getErrorTag().getStatusCode());
        }
    }

#end
#end
#No. 188079
#File: E:\bishe\1\XmlPatchBodyReaderTest.java
#Comment:
    /**
     * Test trying to use value with Patch delete operation which does not support value. Error code 400 should be
     * returned.
     */

#Code:
    @Test
    public void moduleDataNotValueNotSupportedNegativeTest() throws Exception {
        final String uri = "instance-identifier-patch-module:patch-cont/my-list1=leaf1";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataValueNotSupported.xml");
        try {
            xmlToPatchBodyReader.readFrom(null, null, null, mediaType, null, inputStream);
            fail("Test should return error 400 due to present value node when attempt to invoke delete operation");
        } catch (final RestconfDocumentedException e) {
            assertEquals("Error code 400 expected", 400, e.getErrors().get(0).getErrorTag().getStatusCode());
        }
    }

#end
#end
#No. 188080
#File: E:\bishe\1\XmlPatchBodyReaderTest.java
#Comment:
    /**
     * Test of Yang Patch with absolute target path.
     */

#Code:
    @Test
    public void moduleDataAbsoluteTargetPathTest() throws Exception {
        final String uri = "";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataAbsoluteTargetPath.xml");
        final PatchContext returnValue = xmlToPatchBodyReader
                .readFrom(null, null, null, mediaType, null, inputStream);
        checkPatchContext(returnValue);
    }

#end
#end
#No. 188081
#File: E:\bishe\1\XmlPatchBodyReaderTest.java
#Comment:
    /**
     * Test using Patch when target is completely specified in request URI and thus target leaf contains only '/' sign.
     */

#Code:
    @Test
    public void modulePatchCompleteTargetInURITest() throws Exception {
        final String uri = "instance-identifier-patch-module:patch-cont";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataCompleteTargetInURI.xml");
        final PatchContext returnValue = xmlToPatchBodyReader
                .readFrom(null, null, null, mediaType, null, inputStream);
        checkPatchContext(returnValue);
    }

#end
#end
#No. 188082
#File: E:\bishe\1\XmlPatchBodyReaderTest.java
#Comment:
    /**
     * Test of Yang Patch merge operation on list. Test consists of two edit operations - replace and merge.
     */

#Code:
    @Test
    public void moduleDataMergeOperationOnListTest() throws Exception {
        final String uri = "instance-identifier-patch-module:patch-cont/my-list1=leaf1";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataMergeOperationOnList.xml");
        final PatchContext returnValue = xmlToPatchBodyReader
                .readFrom(null, null, null, mediaType, null, inputStream);
        checkPatchContext(returnValue);
    }

#end
#end
#No. 188083
#File: E:\bishe\1\XmlPatchBodyReaderTest.java
#Comment:
    /**
     * Test of Yang Patch merge operation on container. Test consists of two edit operations - create and merge.
     */

#Code:
    @Test
    public void moduleDataMergeOperationOnContainerTest() throws Exception {
        final String uri = "instance-identifier-patch-module:patch-cont";
        mockBodyReader(uri, xmlToPatchBodyReader, false);
        final InputStream inputStream = TestXmlBodyReader.class
                .getResourceAsStream("/instanceidentifier/xml/xmlPATCHdataMergeOperationOnContainer.xml");
        final PatchContext returnValue = xmlToPatchBodyReader
                .readFrom(null, null, null, mediaType, null, inputStream);
        checkPatchContext(returnValue);
    }

#end
#end
#No. 188084
#File: E:\bishe\1\XmlPath.java
#Comment:
    /**
     * Resets static XmlPath configuration to default values
     */

#Code:
    public static void reset() {
        XmlPath.config = null;
    }


#end
#end
#No. 188088
#File: E:\bishe\1\XMLPersistanceHelper.java
#Comment:
    /**
     * Saves an object to XML File.
     * 
     * @param saveFile
     */

#Code:
    public static void saveObjectToFile(File saveFile, final Object object) throws Exception {
	try {
	    JAXBContext jaxbContext = JAXBContext.newInstance(object.getClass());
	    Marshaller jaxbMarshaller = jaxbContext.createMarshaller();
	    jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
	    jaxbMarshaller.marshal(object, saveFile);
	    LOG.info(String.format("Saved successfully config to '%s'", saveFile.getAbsoluteFile()));
	} catch (JAXBException ex) {
	    throw new Exception(String.format("Could not save config to File '%s'", saveFile.getAbsoluteFile()), ex);
	}
    }

#end
#end
#No. 188089
#File: E:\bishe\1\XMLPersistanceHelper.java
#Comment:
    /**
     * Load an object from XML File
     * 
     * @param loadFile
     * @param c
     * @return
     * @throws Exception
     */

#Code:
    public static Object loadObjectFromFile(final File loadFile, Class c) throws Exception {
	try {
	    JAXBContext jaxbContext = JAXBContext.newInstance(c);
	    Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();
	    Object result = jaxbUnmarshaller.unmarshal(loadFile);
	    LOG.info(String.format("Loaded successfully associations from '%s'", loadFile.getAbsoluteFile()));
	    return result;
	} catch (JAXBException ex) {
	    throw new Exception(String.format("Could not load associations from " + "File '%s'",
		    loadFile.getAbsoluteFile()), ex);
	}
    }

#end
#end
#No. 188090
#File: E:\bishe\1\XMLPersistenceTest.java
#Comment:
    /**
     * Should throw an exception when it can't find the schema
     * @throws IOException
     * @throws ValidationException 
     */

#Code:
    @Test  (enabled=true, expectedExceptions=IOException.class)
    public void importCannotFindSchema() throws IOException, ValidationException{ 
    	System.setProperty("importExportSchemaPath", "xxxxxxxxxxxxxxx-UNIT-TEST.xsd"); 
    	XMLPersistence.unmarshal(
    			              new File("src/test/resources/testData/doesntValidate.xml"));
    }

#end
#end
#No. 188091
#File: E:\bishe\1\XMLPersistenceTest.java
#Comment:
    /**
     * Should throw an exception when the file to unmarshal does not exist
     * @throws IOException
     * @throws ValidationException 
     */

#Code:
    @Test  (enabled=true, expectedExceptions=IllegalArgumentException.class)
    public void importBadFile() throws IOException, ValidationException{ 
    	XMLPersistence.unmarshal(new File("bad.xml"));
    }

#end
#end
#No. 188092
#File: E:\bishe\1\XMLPersistenceTest.java
#Comment:
    /**
     * Should throw an exception when the XML file doesn't validate against the schema
     * @throws IOException
     * @throws ValidationException 
     */

#Code:
    @Test  (enabled=true, expectedExceptions=ValidationException.class)
    public void importDoesntValidate() throws IOException, ValidationException{ 
        XMLPersistence
        		.unmarshal(new File("src/test/resources/testData/doesntValidate.xml"));
    }

#end
#end
#No. 188093
#File: E:\bishe\1\XMLPersistenceTest.java
#Comment:
    /**
     * Test of unmarshalling good data
     * @param inputFilename
     * @param expectedRootExternalKey
     * @throws Exception
     */

#Code:
    @Test (enabled=true, dataProvider="increasingingComplextInputData")
    public void importTest(String inputFilename, String expectedRootID) 
  		  throws Exception {
  	
  	  File file = new File(inputFilename);
  	  
  	  ComponentListType components = XMLPersistence.unmarshal(file);
  	  ComponentType component = components.getComponent().get(0);
  	  
  	  Assert.assertNotNull(component);
  	  Assert.assertEquals(component.getComponentId(), expectedRootID);
  	  
    }

#end
#end
#No. 188094
#File: E:\bishe\1\XMLPersistenceTest.java
#Comment:
    /**
     * File which does not exist should throw exception
     * @throws IOException
     * @throws ValidationException 
     */

#Code:
    @Test  (enabled=true, expectedExceptions=IOException.class)
    public void exportCannotFindSchema() throws IOException, ValidationException{ 
          System.setProperty("importExportSchemaPath", "xxxxxxxxxxxxxxx-UNIT-TEST.xsd");
          XMLPersistence.marshal(newCompWOChildren(), new File(""));
    }

#end
#end
#No. 188095
#File: E:\bishe\1\XMLPersistenceTest.java
#Comment:
    /**
     * Null file should throw exception
     * @throws IOException
     * @throws ValidationException 
     */

#Code:
    @Test  (enabled=true, expectedExceptions=IllegalArgumentException.class)
    public void exportBadFile() throws IOException, ValidationException{ 
          XMLPersistence.marshal(newCompWOChildren(), null);
    }

#end
#end
#No. 188096
#File: E:\bishe\1\XMLPersistenceTest.java
#Comment:
    /**
     * Should throw an exception when the data to marshal doesn't validate against the
     * schema
     * @throws IOException
     * @throws ValidationException 
     */

#Code:
    @Test  (enabled=true, expectedExceptions=ValidationException.class)
    public void exportDoesntValidate() throws IOException, ValidationException{ 
        XMLPersistence.marshal(illegalComp(), 
        		               new File("testExportDoesntValidate.xml"));
    }

#end
#end
#No. 188097
#File: E:\bishe\1\XMLPersistenceTest.java
#Comment:
    /**
     * Null object should not throw an exception. It should do nothing.
     * @throws IOException
     * @throws ValidationException 
     */

#Code:
    @Test  (enabled=true)
    public void exportNullOject() throws IOException, ValidationException{
          XMLPersistence.marshal(null, new File("test.xml"));
    }

#end
#end
#No. 188098
#File: E:\bishe\1\XMLPersistenceTest.java
#Comment:
    /**
     * Test of marshalling of good data
     * @throws IOException
     * @throws ValidationException 
     */

#Code:
    @Test  (enabled=true)
    public void exportTest() throws IOException, ValidationException{
    	File file = new File("testExportTest.xml");
    	file.delete();
    	XMLPersistence.marshal(newCompWOChildren(), file);
    	if (!file.exists()) {
    		Assert.fail("XML file was not generated.");
    	}
    	
    	ComponentListType components = XMLPersistence.unmarshal(file);
    	ComponentType component = components.getComponent().get(0);
    	Assert.assertNotNull(component);
    	Assert.assertEquals(component.getExternalKey(), "TheExternalKey");
    	  
    	file.delete();
    }

#end
#end
#No. 188099
#File: E:\bishe\1\XmlPerson.java
#Comment:
/**
 * <p>Java class for person.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="person">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="FIRST"/>
 *     &lt;enumeration value="SECOND"/>
 *     &lt;enumeration value="THIRD"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "person")
@XmlEnum
public enum XmlPerson {

    FIRST,
    SECOND,
    THIRD;

    public String value() {
        return name();
    }

    public static XmlPerson fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 188100
#File: E:\bishe\1\XmlPhraseCategory.java
#Comment:
/**
 * <p>Java class for phraseCategory.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="phraseCategory">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="CLAUSE"/>
 *     &lt;enumeration value="ADJECTIVE_PHRASE"/>
 *     &lt;enumeration value="ADVERB_PHRASE"/>
 *     &lt;enumeration value="NOUN_PHRASE"/>
 *     &lt;enumeration value="PREPOSITIONAL_PHRASE"/>
 *     &lt;enumeration value="VERB_PHRASE"/>
 *     &lt;enumeration value="CANNED_TEXT"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "phraseCategory")
@XmlEnum
public enum XmlPhraseCategory {

    CLAUSE,
    ADJECTIVE_PHRASE,
    ADVERB_PHRASE,
    NOUN_PHRASE,
    PREPOSITIONAL_PHRASE,
    VERB_PHRASE,
    CANNED_TEXT;

    public String value() {
        return name();
    }

    public static XmlPhraseCategory fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 188101
#File: E:\bishe\1\XMLPlaylistParser.java
#Comment:
    /**
     * Create a new stream parser from the given input stream.
     *
     * @param stream An {@link InputStream} stream to parse.
     */

#Code:
    private XMLPlaylistParser(InputStream stream, String encoding) throws XMLStreamException {
        super(stream, encoding);
    }

#end
#end
#No. 188102
#File: E:\bishe\1\XMLPlaylistParser.java
#Comment:
    /**
     * Parse the input stream as one of {@link PlaylistContainer} or
     * {@link Playlist}, depending on the document element.
     *
     * @return An {@link Object} which can then be cast.
     * @throws XMLStreamException
     * @throws XMLParserException
     */

#Code:
    private Object parse(String id) throws XMLStreamException, XMLParserException {
        String name;

        /* Check if reader is currently on a start element. */
        if (this.reader.getEventType() == START_ELEMENT) {
            name = this.reader.getLocalName();

            /* Check current element name and start parsing it. */
            if (name.equals("playlists")) {
                return this.parsePlaylistContainer();
            } else if (name.equals("playlist")) {
                return this.parsePlaylist(id);
            } else if (name.equals("confirm")) {
                return this.parsePlaylistConfirmation();
            } else {
                throw new XMLParserException(
                        "Unexpected element '<" + name + ">'", this.reader.getLocation()
                );
            }
        }

        throw new IllegalStateException("Reader is not on a start element!");
    }

#end
#end
#No. 188103
#File: E:\bishe\1\XMLPlaylistParser.java
#Comment:
    /**
     * Parse {@code xml} into an object using the specified {@code encoding}.
     *
     * @param data     The xml as bytes.
     * @param encoding The encoding to use.
     * @return An object if successful, null if not.
     */

#Code:
    public static Object parse(byte[] data, String encoding, String id) {
        try {
            ByteArrayInputStream stream = new ByteArrayInputStream(data);
//            System.out.println(new String(data, encoding));
            XMLPlaylistParser parser = new XMLPlaylistParser(stream, encoding);

            return parser.parse(id);
        } catch (XMLStreamException e) {
            e.printStackTrace();
            return null;
        } catch (XMLParserException e) {
            e.printStackTrace();
            return null;
        }
//        catch (UnsupportedEncodingException e) {
//            e.printStackTrace();
//            return null;
//        }
    }

#end
#end
#No. 188104
#File: E:\bishe\1\XMLPlaylistParser.java
#Comment:
    /**
     * Parse {@code xml} into a {@link PlaylistContainer} object using the specified {@code encoding}.
     *
     * @param data     The xml as bytes.
     * @param encoding The encoding to use.
     * @return A {@link PlaylistContainer} object if successful, null if not.
     */

#Code:
    public static PlaylistContainer parsePlaylistContainer(byte[] data, String encoding) {
        /* Wrap xml data in corrent document element. */
        String xml = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><playlists>" + new String(data) + "</playlists>";
        System.out.println("xml = " + xml);
        Object playlistContainer = parse(xml.getBytes(), encoding, null);

        if (playlistContainer instanceof PlaylistContainer) {
            return (PlaylistContainer) playlistContainer;
        }

        return null;
    }

#end
#end
#No. 188105
#File: E:\bishe\1\XMLPlaylistParser.java
#Comment:
    /**
     * Parse {@code xml} into a {@link Playlist} object using the specified {@code encoding}.
     *
     * @param data     The xml as bytes.
     * @param encoding The encoding to use.
     * @param id       the playlist id.
     * @return A {@link Playlist} object if successful, null if not.
     */

#Code:
    public static Playlist parsePlaylist(byte[] data, String encoding, String id) {
        String xml = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><playlist>" + new String(data) + "</playlist>";
        System.out.println("playlist xml = " + xml);
        Object playlist = parse(xml.getBytes(), encoding, id);

        if (playlist instanceof Playlist) {
            return (Playlist) playlist;
        }

        return null;
    }

#end
#end
#No. 188106
#File: E:\bishe\1\XMLPlaylistParser.java
#Comment:
    /**
     * Parse {@code xml} into a {@link PlaylistConfirmation} object using the specified {@code encoding}.
     *
     * @param data     The xml as bytes.
     * @param encoding The encoding to use.
     * @return A {@link PlaylistConfirmation} object if successful, null if not.
     */

#Code:
    public static PlaylistConfirmation parseConfirmation(byte[] data, String encoding) {
        /* Wrap xml data in corrent document element. */
        Object playlist = parse(
                ("<?xml version=\"1.0\" encoding=\"utf-8\" ?>" + new String(data)).getBytes(),
                encoding, null
        );

        if (playlist instanceof PlaylistConfirmation) {
            return (PlaylistConfirmation) playlist;
        }

        return null;
    }

#end
#end
#No. 188107
#File: E:\bishe\1\XMLPlistParser.java
#Comment:
	/**
	 * @param bool
	 */

#Code:
	private void convertPBoolean(final PBoolean bool) {
		if (bool.isTrue()) {
			onCreateElement(XmlNode.createElement("true"));
		} else {
			onCreateElement(XmlNode.createElement("false"));
		}
		onCloseElement();
	}

#end
#end
#No. 188108
#File: E:\bishe\1\XMLPlistParser.java
#Comment:
	/**
	 * 
	 * @param integer
	 */

#Code:
	private void convertPInt(final PInt integer) {
		onCreateElement(XmlNode.createElement("integer"));
		onCreateNode(XmlNode.createText(String.valueOf(integer.getValue())));
		onCloseElement();
	}

#end
#end
#No. 188109
#File: E:\bishe\1\XMLPlistParser.java
#Comment:
	/**
	 * 
	 * @param real
	 */

#Code:
	private void convertPReal(final PReal real) {
		onCreateElement(XmlNode.createElement("real"));
		onCreateNode(XmlNode.createText(String.valueOf(real.getValue())));
		onCloseElement();
	}

#end
#end
#No. 188110
#File: E:\bishe\1\XMLPlistParser.java
#Comment:
	/**
	 * 
	 * @param string
	 */

#Code:
	private void convertPString(final PString string) {
		onCreateElement(XmlNode.createElement("string"));
		onCreateNode(XmlNode.createText(string.getValue()));
		onCloseElement();
	}

#end
#end
#No. 188111
#File: E:\bishe\1\XMLPlistParser.java
#Comment:
	/**
	 * @param array
	 */

#Code:
	private void convertPArray(final PArray array) {

		onCreateElement(XmlNode.createElement("array"));

		for (PObject child : array) {
			convertPObject(child);
		}

		onCloseElement();
	}

#end
#end
#No. 188112
#File: E:\bishe\1\XmlPPPhraseSpec.java
#Comment:
/**
 * <p>Java class for PPPhraseSpec complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="PPPhraseSpec">
 *   &lt;complexContent>
 *     &lt;extension base="{http://simplenlg.googlecode.com/svn/trunk/res/xml}PhraseElement">
 *       &lt;sequence>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "PPPhraseSpec")
public class XmlPPPhraseSpec
    extends XmlPhraseElement
{


}

#end
#end
#No. 188113
#File: E:\bishe\1\XMLPrintWriter.java
#Comment:
    /**
     * The <code>PrintWriter</code> to which the actual printing is delegated.
     */

#Code:
    PrintWriter writer;

    /**
     * Constructs an XMLPrintWriter object given a PrintStream.
     *
     * @param printStream the PrintStream on which XML is output
     */
    public XMLPrintWriter (java.io.PrintStream printStream) {
        writer = new PrintWriter(printStream, true);
    }

#end
#end
#No. 188114
#File: E:\bishe\1\XMLPrintWriter.java
#Comment:
    /**
     * Prints a string to the <code>PrintWriter</code> stored in the field @see #writer indenting it
     * by the number of spaces indicated by @see #indent either relative to the
     * current indentation level (if @see #relative is <code>true</code>) or with
     * respect to the beginning of the line (if @see #relative is <code>false</code>).
     *
     * @param string the string to be printed.
     * @param indent the number of spaces by which the string needs to be indented.
     * @param relative id <code>true</code> the string is further indented with respect
     * to the current indentation level, if <code>false</code> is indented with respect to
     * the beginning of the line.
     */

#Code:
    public void indentPrint (String string, int indent, boolean relative) {
        this.setIndent(indent, relative);
        writer.print(indentString + string);
    }

#end
#end
#No. 188115
#File: E:\bishe\1\XMLPrintWriter.java
#Comment:
    /**
     * Prints a string to the <code>PrintWriter</code> stored in the field @see #writer.
     *
     * @param string the string to be printed.
     */

#Code:
    public void print (String string) {
        writer.print(string);
    }

#end
#end
#No. 188116
#File: E:\bishe\1\XMLPrintWriter.java
#Comment:
    /**
     * Flushes the <code>PrintWriter</code> in the field @see #writer.
     */

#Code:
    public void flush () {
        writer.flush();
    }

#end
#end
#No. 188117
#File: E:\bishe\1\XMLPrintWriter.java
#Comment:
  /**
   * Closes the <code>PrintWriter</code> in the field @see #writer.
   */

#Code:
  public void close () {
    writer.close();
  }


#end
#end
#No. 188123
#File: E:\bishe\1\XMLProcSpan.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 */

#Code:
	public XMLProcSpan(final Context context) {
		super(context, R.style.Axel_Xml_ProcessingInstruction);
	}



#end
#end
#No. 188125
#File: E:\bishe\1\XmlrDebug.java
#Comment:
    /**
     * Compare two reftrees.
     * @param t1
     *            tree 1
     * @param t2
     *            tree 2
     * @return <code>false</code> if trees do not match
     */

#Code:
    public static boolean treeComp(RefTree t1, RefTree t2) {
        return treeComp(t1, t2, CompareUtil.OBJECT_EQUALITY, true);
    }

#end
#end
#No. 188126
#File: E:\bishe\1\XmlrDebug.java
#Comment:
    /**
     * Compare two reftrees.
     * @param t1
     *            tree 1
     * @param t2
     *            tree 2
     * @param flagErrors
     *            <code>true</code> if errors are logged
     * @return <code>false</code> if trees do not match
     */

#Code:
    public static boolean treeComp(RefTree t1, RefTree t2, boolean flagErrors) {
        return treeComp(t1, t2, CompareUtil.OBJECT_EQUALITY, flagErrors);
    }

#end
#end
#No. 188127
#File: E:\bishe\1\XmlrDebug.java
#Comment:
    /**
     * Compare two reftrees.
     * @param t1
     *            tree 1
     * @param t2
     *            tree 2
     * @param idcmp
     *            comparator for keys
     * @param flagErrors
     *            <code>true</code> if errors are logged
     * @return <code>false</code> if trees do not match
     */

#Code:
    public static boolean treeComp(RefTree t1, RefTree t2, Comparator idcmp, boolean flagErrors) {
        try {
            return treeComp(t1.getRoot(), t2.getRoot(), RefTrees.getIdentityIdMap(), 0, idcmp,
                            false, flagErrors) == 0;
        } catch (NodeNotFoundException ex) {
            Log.error("Exception", ex);
        }
        return false;
    }

#end
#end
#No. 188128
#File: E:\bishe\1\XmlrDebug.java
#Comment:
    /**
     * Compares two reftrees by node equality. Also requires child order to match exactly. Note: any
     * references are <b>not</b> expanded, i.e., if there is a reference in one tree, the exact same
     * kind of reference must be in the other tree.
     * @param t1
     *            first tree
     * @param t2
     *            second tree
     * @return <code>true</code> if equals
     */

#Code:
    public static boolean equalityTreeComp(RefTree t1, RefTree t2) {
        return equalityTreeComp(t1.getRoot(), t2.getRoot());
    }

#end
#end
#No. 188129
#File: E:\bishe\1\XmlrDebug.java
#Comment:
    /**
     * Debug dump reftree. Tree is dumped to <code>Log.getLogStream(Log.DEBUG)</code>.
     * @param t
     *            tree
     */

#Code:

    public static void dumpTree(RefTree t) {
        if (!Log.isEnabled(LogLevels.DEBUG)) return;
        dumpTree(t, new PrintStream(Log.getLogStream(LogLevels.DEBUG)));
    }

#end
#end
#No. 188130
#File: E:\bishe\1\XmlrDebug.java
#Comment:
    /**
     * Debug dump reftree.
     * @param t
     *            tree
     * @param out
     *            dump target
     */

#Code:

    public static void dumpTree(RefTree t, PrintStream out) {
        Class kc = t.getRoot() != null ? (t.getRoot().getId() != null ? t.getRoot().getId().getClass()
                : null)
                : null;
        dumpTree(t.getRoot(), kc, 0, out);
        out.flush();
    }

#end
#end
#No. 188131
#File: E:\bishe\1\XmlrDebug.java
#Comment:
    /**
     * Debug dump reftree.
     * @param root
     *            root node
     * @param keyClass
     *            class of keys. Keys of other classes are annotated with their class in the dump.
     * @param level
     *            indentation level
     * @param out
     *            dump target
     */

#Code:
    public static void dumpTree(RefTreeNode root, Class keyClass, int level, PrintStream out) {
        // if( !Log.isEnabled(Log.DEBUG) )
        // return;
        Object c = root == null ? "" : root.getContent();
        String cstr = "";
        if (root != null) {
            cstr = !root.isReference() ? Debug.toPrintable(c == null ? "<null>" : c.toString())
                    : fmtRef(root, keyClass);
        }
        // NOTE 1024 token limit is to avoid X crashing into oblivion on Ubuntu
        // 6.06 :)
        // (Guess: the nvidia graphics driver has a severe buffer overflow... )
        String idstr = root == null ? "<null node>" : (root.getId() == null ? null
                : (root.getId().getClass() == keyClass ? guardTransient(root.getId())
                        : guardTransient(root.getId()) + "[" + fmtClass(root.getId().getClass()) +
                          "]"));
        out.println("                                       ".substring(0, level) + idstr + ": " +
                    (cstr.length() > 1024 ? cstr.substring(0, 1024) + "..." : cstr) +
                    (root != null ? " " + fmtClass(root.getClass()) : ""));
        if (root != null) {
            for (Iterator i = root.getChildIterator(); i.hasNext();)
                dumpTree((RefTreeNode) i.next(), keyClass, level + 1, out);
        }
    }

#end
#end
#No. 188132
#File: E:\bishe\1\XmlrDebug.java
#Comment:
    /**
     * Return string listing objects from iterator.
     * @param i
     *            iterator
     * @param max
     *            maximum number of items
     * @return string listing objects from iterator.
     */

#Code:
    public static String toString(Iterator i, int max) {
        StringBuilder sb = new StringBuilder('[');
        for (; i.hasNext() && max > 0; max--) {
            String step = i.next().toString();
            sb.append((sb.length() > 1 ? ", " : "") +
                      (step.length() > 1024 ? step.substring(0, 1024) + "..." : step));
        }
        return sb.append(']').toString();
    }



#end
#end
#No. 188134
#File: E:\bishe\1\XMLReferencesBatchValidator.java
#Comment:
	/**
	 * Validate one file. It's assumed that the file has JSP content type.
	 * 
	 * @param file
	 * @param reporter
	 */

#Code:
	void validateFile(IFile file, IReporter reporter) {
		try {
			file.refreshLocal(IResource.DEPTH_ZERO, new NullProgressMonitor());
		} catch (CoreException e) {
			Trace.trace(Trace.SEVERE, "", e);
		}
		IStructuredModel model = null;
		try {
			// get DOM model on behalf of all XML references validators
			model = StructuredModelManager.getModelManager().getModelForRead(
					file);
			if (!reporter.isCancelled() && model != null
					&& model instanceof IDOMModel) {
				reporter.removeAllMessages(this, file);
				performValidation(file, reporter, (IDOMModel) model);
			}
		} catch (IOException e) {
			Trace.trace(Trace.SEVERE, "", e);
		} catch (CoreException e) {
			Trace.trace(Trace.SEVERE, "", e);
		} finally {
			if (model != null)
				model.releaseFromRead();
		}
	}

#end
#end
#No. 188135
#File: E:\bishe\1\XMLReferencesBatchValidator.java
#Comment:
	/**
	 * Determine if a given file should be validated.
	 * 
	 * @param file
	 *            The file that may be validated.
	 * @return True if the file should be validated, false otherwise.
	 */

#Code:
	private static boolean shouldValidate(IFile file) {
		IResource resource = file;
		do {
			if (resource.isDerived() || resource.isTeamPrivateMember()
					|| !resource.isAccessible()
					|| resource.getName().charAt(0) == '.') {
				return false;
			}
			resource = resource.getParent();
		} while ((resource.getType() & IResource.PROJECT) == 0);

		return true;
	}

#end
#end
#No. 188136
#File: E:\bishe\1\XMLReferencesInfoHoverProcessor.java
#Comment:
	/**
	 * Retrieves documentation to display in the hover help popup.
	 * 
	 * @return String any documentation information to display <code>null</code>
	 *         if there is nothing to display.
	 * 
	 */

#Code:
	protected String computeHoverHelp(ITextViewer textViewer,
			int documentPosition) {
		String result = null;

		IndexedRegion treeNode = ContentAssistUtils.getNodeAt(textViewer,
				documentPosition);
		if (treeNode == null) {
			return null;
		}
		Node node = (Node) treeNode;

		while ((node != null) && (node.getNodeType() == Node.TEXT_NODE)
				&& (node.getParentNode() != null)) {
			node = node.getParentNode();
		}
		IDOMNode parentNode = (IDOMNode) node;

		IStructuredDocumentRegion flatNode = ((IStructuredDocument) textViewer
				.getDocument()).getRegionAtCharacterOffset(documentPosition);
		if (flatNode != null) {
			ITextRegion region = flatNode
					.getRegionAtCharacterOffset(documentPosition);
			if (region != null) {
				result = computeRegionHelp(treeNode, parentNode, flatNode,
						region, documentPosition);
			}
		}

		return result;
	}

#end
#end
#No. 188137
#File: E:\bishe\1\XMLReferencesInfoHoverProcessor.java
#Comment:
	/**
	 * Computes the hoverhelp based on region
	 * 
	 * @return String hoverhelp
	 */

#Code:
	// @Override
	protected String computeRegionHelp(IndexedRegion treeNode,
			IDOMNode parentNode, IStructuredDocumentRegion flatNode,
			ITextRegion region, int documentPosition) {
		String result = null;
		if (region == null) {
			return null;
		}
		String regionType = region.getType();
		if (regionType == DOMRegionContext.XML_TAG_NAME) {
			result = computeTagNameHelp((IDOMNode) treeNode, parentNode,
					flatNode, region);
		} else if (regionType == DOMRegionContext.XML_TAG_ATTRIBUTE_NAME) {
			result = computeTagAttNameHelp((IDOMNode) treeNode, parentNode,
					flatNode, region);
		} else if (regionType == DOMRegionContext.XML_TAG_ATTRIBUTE_VALUE) {
			int offset = documentPosition - flatNode.getStart()
					- region.getStart();
			result = computeTagAttValueHelp((IDOMNode) treeNode, parentNode,
					flatNode, region);
		}
		if (regionType == DOMRegionContext.XML_CONTENT) {
			int offset = documentPosition - flatNode.getStart();
			result = computeXMLContentValueHelp((IDOMNode) treeNode,
					parentNode, flatNode, region);
		}
		return result;
	}




#end
#end
#No. 188140
#File: E:\bishe\1\XmlRes.java
#Comment:
/**
 * Denotes that an integer parameter, field or method return value is expected
 * to be an XML resource reference.
 */

#Code:
@Documented
@Retention(SOURCE)
@Target({METHOD, PARAMETER, FIELD})
public @interface XmlRes {
}
}

#end
#end
#No. 188141
#File: E:\bishe\1\XMLResolver.java
#Comment:
    /**
     * Read the xml file under assets folder.
     *
     * @param context  context
     * @param fileName file name
     * @return
     */

#Code:
    public List<XMLNode> readXml(Context context, String fileName) {
        InputStream inputStream = null;
        try {
            inputStream = context.getResources().getAssets().open(fileName);
        } catch (IOException e) {
            e.printStackTrace();
        }
        List<XMLNode> list = readXml(inputStream);
        try {
            inputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        inputStream = null;
        return list;
    }

#end
#end
#No. 188142
#File: E:\bishe\1\XMLResolver.java
#Comment:
    /**
     * get xml node from node name.
     *
     * @param list
     * @param nodeName
     * @return
     */

#Code:
    public List<XMLNode> getNode(List<XMLNode> list, String nodeName) {
        List<XMLNode> nodeList = new LinkedList<XMLNode>();
        for (XMLNode node : list) {
            if (node.mName.equals(nodeName)) {
                nodeList.add(node);
            }
        }
        return nodeList;
    }

#end
#end
#No. 188143
#File: E:\bishe\1\XMLResolver.java
#Comment:
    /**
     * get node attributes from node name and attribute name
     *
     * @param list
     * @param nodeName
     * @param attributeName
     * @return
     */

#Code:
    public List<String> getAttributeValue(List<XMLNode> list, String nodeName, String attributeName) {
        List<String> valueList = new LinkedList<String>();
        for (XMLNode node : list) {
            if (node.mName.equals(nodeName)) {
                String value = node.getAttributeValue(attributeName);
                if (value != null) {
                    valueList.add(value);
                }
            }
        }
        return valueList;
    }

#end
#end
#No. 188144
#File: E:\bishe\1\XMLResolver.java
#Comment:
    /**
     * get first attribute value from node name and attribute name
     *
     * @param list
     * @param nodeName
     * @param attributeName
     * @return
     */

#Code:
    public String getFirstAttributeValue(List<XMLNode> list, String nodeName, String attributeName) {
        List<String> valueList = getAttributeValue(list, nodeName, attributeName);
        if (valueList.size() > 0) {
            return valueList.get(0);
        }
        return null;
    }

#end
#end
#No. 188145
#File: E:\bishe\1\XMLResolver.java
#Comment:
    /**
     * get the child node from father node.
     *
     * @param source
     * @param fatherNode
     * @return
     */

#Code:
    public List<XMLNode> getChildNodes(List<XMLNode> source, String fatherNode) {
        if (source == null) {
            return null;
        }
        List<XMLNode> list = new ArrayList<XMLNode>();
        for (XMLNode xmlNode : source) {
            if (xmlNode.mName.equals(fatherNode)) {
                list.add(xmlNode);
            }
        }
        return list;
    }

#end
#end
#No. 188156
#File: E:\bishe\1\XMLResponse.java
#Comment:
    /**
     * Constructor which will initialize its handler to the XML passed in
     * 
     * @param xml
     *            - The XML to initialize the response to.
     */

#Code:
    public XMLResponse(String body)
    {
        response = body;
    }

#end
#end
#No. 188157
#File: E:\bishe\1\XMLResponse.java
#Comment:
    /**
     * Returns a String representing all XML included in this response, including the standard XML header <?xml
     * version="1.0" encoding="UTF-8"?>
     */

#Code:
    public String getResponseBody()
    {
        if (null == handler) {
            handler = new GenericXMLHandler(response);
        }
        return handler.toString();
    }

#end
#end
#No. 188158
#File: E:\bishe\1\XMLResponse.java
#Comment:
    /**
     * Gets the value in this response with the associated XPath expression
     * 
     * @param key
     *            - The XPath expression to look up
     * @return A string which is the value in the XML
     */

#Code:
    public String getValue(String key)
    {
        if (null == handler) {
            handler = new GenericXMLHandler(response);
        }
        return handler.GetElementText(key);
    }

#end
#end
#No. 188159
#File: E:\bishe\1\XMLRetriever.java
#Comment:
    /*
        Various methods for getting the html
    */

#Code:

    public Document getDOMDocument() {
        return pageDocument;
    }



#end
#end
#No. 188162
#File: E:\bishe\1\XMLRPCCommon.java
#Comment:
	/**
	 * Sets custom IXMLRPCSerializer serializer (in case when server doesn't support
	 * standard XMLRPC protocol)
	 * 
	 * @param serializer custom serializer
	 */

#Code:
	public void setSerializer(IXMLRPCSerializer serializer) {
		iXMLRPCSerializer = serializer;
	}

#end
#end
#No. 188163
#File: E:\bishe\1\XmlRpcMethodRegistrar.java
#Comment:
    /**
     * Add @XmlRpc methods from this class to the default method handler.
     *
     * @param methodGroupClass
     */

#Code:
    public void addDefaultMethodGroup(Class<?> methodGroupClass) {
        Object methodsObject = injector.getInstance(methodGroupClass);
        methodGroups.put(defaultMethods, new XmlRpcMethodInvoker("", methodGroupClass, methodsObject));
    }

#end
#end
#No. 188164
#File: E:\bishe\1\XmlRpcResponse.java
#Comment:
    /**
     * Writes an XML-RPC response to the XML writer.
     */

#Code:
    void writeResponse(Object param, XmlWriter writer) {
        writer.startElement("methodResponse");
        writer.startElement("params");
        writer.startElement("param");
        writeObject(param, writer);
        writer.endElement("param");
        writer.endElement("params");
        writer.endElement("methodResponse");
    }

#end
#end
#No. 188165
#File: E:\bishe\1\XmlRpcResponse.java
#Comment:
    /**
     * Writes an XML-RPC error response to the XML writer.
     */

#Code:
    void writeError(int code, String message, XmlWriter writer) {
        Map<String, Object> map = new HashMap<>();
        map.put("faultCode", code);
        map.put("faultString", message);
        writer.startElement("methodResponse");
        writer.startElement("fault");
        writeObject(map, writer);
        writer.endElement("fault");
        writer.endElement("methodResponse");
    }


#end
#end
#No. 188167
#File: E:\bishe\1\XmlSchemaGenerator.java
#Comment:
    /**
     * Examine the specified element ref and determine if a swaRef attribute needs to be generated
     * @param typeRef
     */

#Code:
    private boolean generateSwaRefAdapter(NonElementRef<T,C> typeRef) {
        return generateSwaRefAdapter(typeRef.getSource());
    }

#end
#end
#No. 188168
#File: E:\bishe\1\XmlSchemaGenerator.java
#Comment:
    /**
     * Examine the specified element ref and determine if a swaRef attribute needs to be generated
     */

#Code:
    private boolean generateSwaRefAdapter(PropertyInfo<T,C> prop) {
        final Adapter<T,C> adapter = prop.getAdapter();
        if (adapter == null) return false;
        final Object o = navigator.asDecl(SwaRefAdapter.class);
        if (o == null) return false;
        return (o.equals(adapter.adapterType));
    }



#end
#end
#No. 188170
#File: E:\bishe\1\XmlSchemaGenerator.java
#Comment:
    /**
     * return the string representation of the processContents mode of the
     * give wildcard, or null if it is the schema default "strict"
     *
     */

#Code:
    private static String getProcessContentsModeName(WildcardMode wc) {
        switch(wc) {
        case LAX:
        case SKIP:
            return wc.name().toLowerCase();
        case STRICT:
            return null;
        default:
            throw new IllegalStateException();
        }
    }



#end
#end
#No. 188172
#File: E:\bishe\1\XMLSearchEngine2.java
#Comment:
	/**
	 * Evaluates all files in this scope.
	 * 
	 * @param status
	 *            a {@link MultiStatus} to collect the error status that
	 *            occurred while collecting resources.
	 * @return returns the files in the scope.
	 */

#Code:
	protected IFile[] evaluateFilesInScope(
			IXMLQuerySpecificationRegistry querySpecificationRegistry,
			MultiStatus status) {
		return new FilesOfScopeCalculator(querySpecificationRegistry, status)
				.process();
	}

#end
#end
#No. 188173
#File: E:\bishe\1\XMLSearcherForStatic.java
#Comment:
	/**
	 * 
	 * @param file
	 * @param collector
	 * @param matchingString
	 * @param startsWith
	 * @param referenceToStatic
	 */

#Code:
	private void internalSearch(Object selectedNode, IFile file,
			IStaticValueCollector collector, String matchingString,
			boolean startsWith, IXMLReferenceToStatic referenceToStatic) {
		IStaticValueQuerySpecification querySpecification = StaticQuerySpecificationUtil
				.getStaticQuerySpecification(referenceToStatic);
		if (querySpecification != null) {
			IStaticValueVisitor visitor = querySpecification.getVisitor(
					selectedNode, file);
			if (visitor == null) {
				return;
			}
			StaticValueSearchEngine.getDefault().search(selectedNode, file,
					visitor, collector, matchingString, startsWith, null);
		}
	}

#end
#end
#No. 188174
#File: E:\bishe\1\XMLSearchTreeContentProvider.java
#Comment:
	/**
	 * Adds the child to the parent.
	 * 
	 * @param parent
	 *            the parent
	 * @param child
	 *            the child
	 * @return <code>true</code> if this set did not already contain the
	 *         specified element
	 */

#Code:
	private boolean insertChild(Object parent, Object child) {
		Set children = (Set) fChildrenMap.get(parent);
		if (children == null) {
			children = new HashSet();
			fChildrenMap.put(parent, children);
		}
		return children.add(child);
	}

#end
#end
#No. 188175
#File: E:\bishe\1\XmlSerDe.java
#Comment:
    /**
     * @see org.apache.hadoop.hive.serde2.Deserializer#deserialize(org.apache.hadoop.io.Writable)
     */

#Code:
    @Override
    public Object deserialize(Writable writable) throws SerDeException {
        Text text = (Text) writable;
        if (text == null || text.getLength() == 0) {
            return (Object) null;
        }
        try {
            return this.xmlProcessor.parse(text.toString());
        } catch (Exception e) {
            throw new SerDeException(e);
        }
    }

#end
#end
#No. 188176
#File: E:\bishe\1\XmlSerDe.java
#Comment:
    /**
     * @see org.apache.hadoop.hive.serde2.Deserializer#getObjectInspector()
     */

#Code:
    @Override
    public ObjectInspector getObjectInspector() throws SerDeException {
        return this.objectInspector;
    }

#end
#end
#No. 188177
#File: E:\bishe\1\XmlSerDe.java
#Comment:
    /**
     * @see org.apache.hadoop.hive.serde2.Deserializer#getSerDeStats()
     */

#Code:
    @Override
    public SerDeStats getSerDeStats() {
        return null;
    }

#end
#end
#No. 188178
#File: E:\bishe\1\XmlSerDe.java
#Comment:
    /**
     * @see org.apache.hadoop.hive.serde2.Serializer#getSerializedClass()
     */

#Code:
    @Override
    public Class<? extends Writable> getSerializedClass() {
        return Text.class;
    }

#end
#end
#No. 188179
#File: E:\bishe\1\XmlSerDe.java
#Comment:
    /**
     * @see org.apache.hadoop.hive.serde2.Serializer#serialize(java.lang.Object,
     *      org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector)
     */

#Code:
    @Override
    public Writable serialize(Object object, ObjectInspector objectInspector) throws SerDeException {
        throw new UnsupportedOperationException();
    }

#end
#end
#No. 188180
#File: E:\bishe\1\XmlSerializerTester.java
#Comment:
    /**
     * @param args
     * @throws SAXException 
     */

#Code:
    public static void main(String[] args) throws SAXException {
        AttributesImpl attrs = new AttributesImpl();
        XmlSerializer serializer = new XmlSerializer(System.out);
        serializer.startDocument();
        serializer.startElement("1", "a", null, attrs);
        serializer.startElement("1", "b", null, attrs);
        serializer.endElement("1", "b", null);
        serializer.startElement("2", "c", null, attrs);
        serializer.endElement("2", "c", null);
        attrs.addAttribute("http://www.w3.org/1999/02/22-rdf-syntax-ns#", "about", null, "CDATA", "");
        serializer.startElement("http://www.w3.org/1999/02/22-rdf-syntax-ns#", "d", null, attrs);
        serializer.endElement("http://www.w3.org/1999/02/22-rdf-syntax-ns#", "d", null);        
        serializer.startPrefixMapping("rdf", "foo");
        serializer.startElement("http://www.w3.org/1999/02/22-rdf-syntax-ns#", "e", null, attrs);
        serializer.startPrefixMapping("p0", "bar");        
        serializer.startElement("http://www.w3.org/1999/02/22-rdf-syntax-ns#", "f", null, attrs);
        serializer.characters("a\uD834\uDD21a\uD834a\uDD21a".toCharArray(), 0, 8);
        serializer.endElement("http://www.w3.org/1999/02/22-rdf-syntax-ns#", "f", null);        
        serializer.endElement("http://www.w3.org/1999/02/22-rdf-syntax-ns#", "e", null);        
        
        serializer.endPrefixMapping("rdf");
        serializer.endElement("1", "a", null);
        serializer.endDocument();
    }

#end
#end
#No. 188181
#File: E:\bishe\1\XMLSetFieldAttribute.java
#Comment:
/**
 * 
 *                 Configuration to set and compare the field attribute
 *             
 * 
 * <p>Java class for XMLSetFieldAttribute complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLSetFieldAttribute"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldBase"&gt;
 *       &lt;attribute name="attribute" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLSetFieldAttribute")
public class XMLSetFieldAttribute
    extends XMLFieldBase
{

    @XmlAttribute(name = "attribute", required = true)
    protected String attribute;

    /**
     * Gets the value of the attribute property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getAttribute() {
        return attribute;
    }

    /**
     * Sets the value of the attribute property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setAttribute(String value) {
        this.attribute = value;
    }

}

#end
#end
#No. 188182
#File: E:\bishe\1\XMLSetFieldExpression.java
#Comment:
/**
 * 
 *                 Configuration to set and compare the field expression
 *             
 * 
 * <p>Java class for XMLSetFieldExpression complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLSetFieldExpression"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLFieldBase"&gt;
 *       &lt;attribute name="expression" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLSetFieldExpression")
public class XMLSetFieldExpression
    extends XMLFieldBase
{

    @XmlAttribute(name = "expression", required = true)
    protected String expression;

    /**
     * Gets the value of the expression property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getExpression() {
        return expression;
    }

    /**
     * Sets the value of the expression property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setExpression(String value) {
        this.expression = value;
    }

}

#end
#end
#No. 188183
#File: E:\bishe\1\XMLSetFieldLiteralBoolean.java
#Comment:
/**
 * 
 *                 Configuration to set and compare the boolean value of a field
 *             
 * 
 * <p>Java class for XMLSetFieldLiteralBoolean complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLSetFieldLiteralBoolean"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLSetFieldLiteralBase"&gt;
 *       &lt;attribute name="value" type="{http://www.w3.org/2001/XMLSchema}boolean" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLSetFieldLiteralBoolean")
public class XMLSetFieldLiteralBoolean
    extends XMLSetFieldLiteralBase
{

    @XmlAttribute(name = "value")
    protected Boolean value;

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setValue(Boolean value) {
        this.value = value;
    }

}

#end
#end
#No. 188184
#File: E:\bishe\1\XMLSetFieldLiteralDouble.java
#Comment:
/**
 * <p>Java class for XMLSetFieldLiteralDouble complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLSetFieldLiteralDouble"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLSetFieldLiteralBase"&gt;
 *       &lt;attribute name="value" type="{http://www.w3.org/2001/XMLSchema}double" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLSetFieldLiteralDouble")
public class XMLSetFieldLiteralDouble
    extends XMLSetFieldLiteralBase
{

    @XmlAttribute(name = "value")
    protected Double value;

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link Double }
     *     
     */
    public Double getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link Double }
     *     
     */
    public void setValue(Double value) {
        this.value = value;
    }

}

#end
#end
#No. 188185
#File: E:\bishe\1\XMLSetFieldLiteralInt.java
#Comment:
/**
 * <p>Java class for XMLSetFieldLiteralInt complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLSetFieldLiteralInt"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLSetFieldLiteralBase"&gt;
 *       &lt;attribute name="value" type="{http://www.w3.org/2001/XMLSchema}int" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLSetFieldLiteralInt")
public class XMLSetFieldLiteralInt
    extends XMLSetFieldLiteralBase
{

    @XmlAttribute(name = "value")
    protected Integer value;

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link Integer }
     *     
     */
    public Integer getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link Integer }
     *     
     */
    public void setValue(Integer value) {
        this.value = value;
    }

}

#end
#end
#No. 188186
#File: E:\bishe\1\XMLSetFieldLiteralString.java
#Comment:
/**
 * <p>Java class for XMLSetFieldLiteralString complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="XMLSetFieldLiteralString"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{}XMLSetFieldLiteralBase"&gt;
 *       &lt;attribute name="value" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "XMLSetFieldLiteralString")
public class XMLSetFieldLiteralString
    extends XMLSetFieldLiteralBase
{

    @XmlAttribute(name = "value")
    protected String value;

    /**
     * Gets the value of the value property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setValue(String value) {
        this.value = value;
    }

}

#end
#end
#No. 188187
#File: E:\bishe\1\XmlStringElement.java
#Comment:
/**
 * <p>Java class for StringElement complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="StringElement">
 *   &lt;complexContent>
 *     &lt;extension base="{http://simplenlg.googlecode.com/svn/trunk/res/xml}NLGElement">
 *       &lt;sequence>
 *         &lt;element name="val" type="{http://www.w3.org/2001/XMLSchema}string"/>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */

#Code:
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "StringElement", propOrder = {
    "val"
})
public class XmlStringElement
    extends XmlNLGElement
{

    @XmlElement(required = true)
    protected String val;

    /**
     * Gets the value of the val property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getVal() {
        return val;
    }

    /**
     * Sets the value of the val property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setVal(String value) {
        this.val = value;
    }

}

#end
#end
#No. 188188
#File: E:\bishe\1\XMLStringUtil.java
#Comment:
    /**
     * Replace XML invalid chars with one white space.
     * @param input
     * @return
     */

#Code:
    public static String getXMLValidString(final String input) {
        return XMLStringUtil.getXMLValidString(input, false, ' ');
    }

#end
#end
#No. 188189
#File: E:\bishe\1\XMLStringUtil.java
#Comment:
    /**
     * Remove or replace XML invalid chars from input.
     * 
     * @param input
     * @param replace
     *            Whether or not to replace invalid characters by replacement
     * @param replacement
     *            The character to replace any invalid character found
     * @return The String that is cleaned from the invalid in XML characters.
     * @see #isXMLValid(char)
     */

#Code:
    public static String getXMLValidString(final String input,
            final boolean replace, final char replacement) {
        if (input == null) {
            return null;
        }

        if ("".equals(input)) {
            return "";
        }

        StringBuilder sb = new StringBuilder();
        for (char c : input.toCharArray()) {
            if (XMLStringUtil.isXMLValid(c)) {
                sb.append(c);
            } else if (replace) {
                sb.append(replacement);
            }
        }
        return sb.toString();
    }

#end
#end
#No. 188190
#File: E:\bishe\1\XMLStringUtil.java
#Comment:
    /**
     * <p>
     * Checker for XML valid character.
     * </p>
     * <p>
     * The Valid XML char is one of:<br>
     * #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
     * </p>
     * 
     * @see <a href="http://www.w3.org/TR/REC-xml/#charsets">http://www.w3.org/TR/REC-xml/#charsets</a>
     * 
     * @param c
     *            The <code>char</code> to test.
     * @return <code>true</code> if <code>c</code> is one of:<br>
     *         #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD].
     * 
     */

#Code:
    public static boolean isXMLValid(final char c) {
        boolean result = (c == '\u0009') //
                || (c == '\n') //
                || (c == '\r') //
                || ((c >= '\u0020') && (c <= '\uD7FF')) //
                || ((c >= '\uE000') && (c <= '\uFFFD'));
        return result;
    }


#end
#end
#No. 188192
#File: E:\bishe\1\XMLStringWriter.java
#Comment:
    /**
     * Prints a string to the <code>StringWriter</code> stored in the field @see #writer indenting it
     * by the number of spaces indicated by @see #indent either relative to the
     * current indentation level (if @see #relative is <code>true</code>) or with
     * respect to the beginning of the line (if @see #relative is <code>false</code>).
     *
     * @param string the string to be printed.
     * @param indent the number of spaces by which the string needs to be indented.
     * @param relative id <code>true</code> the string is further indented with respect
     * to the current indentation level, if <code>false</code> is indented with respect to
     * the beginning of the line.
     */

#Code:
    public void indentPrint (String string, int indent, boolean relative) {
        this.setIndent(indent, relative);
        writer.write(indentString + string);
    }

#end
#end
#No. 188193
#File: E:\bishe\1\XMLStringWriter.java
#Comment:
    /**
     * Prints a string to the <code>StringWriter</code> stored in the field @see #writer.
     *
     * @param string the string to be printed.
     */

#Code:
    public void print (String string) {
        writer.write(string);
    }

#end
#end
#No. 188194
#File: E:\bishe\1\XMLStringWriter.java
#Comment:
    /**
     * Flushes the <code>StringWriter</code> in the field @see #writer.
     */

#Code:
    public void flush () {
        writer.flush();
    }

#end
#end
#No. 188195
#File: E:\bishe\1\XMLStringWriter.java
#Comment:
    /**
     * Closes the <code>StringWriter</code> in the field @see #writer.
     */

#Code:
    public void close () throws IOException {
        writer.close();
    }

#end
#end
#No. 188196
#File: E:\bishe\1\XMLStringWriter.java
#Comment:
    /**
     * Return the buffer's current value as a string.
     */

#Code:
    public String toString() {
        return writer.toString();
    }

#end
#end
#No. 188197
#File: E:\bishe\1\XMLStructuredOutput.java
#Comment:
    /**
     * Creates a new output writing to the given output stream.
     *
     * @param output  the stream used as destination for the generated xml
     * @param doctype the doc type used in the XML header
     */

#Code:
    public XMLStructuredOutput(@Nonnull OutputStream output, @Nullable String doctype) {
        try {
            this.out = output;
            StreamResult streamResult = new StreamResult(out);
            SAXTransformerFactory tf = (SAXTransformerFactory) TransformerFactory.newInstance();
            hd = tf.newTransformerHandler();
            Transformer serializer = hd.getTransformer();
            if (doctype != null) {
                serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctype);
            }
            serializer.setOutputProperty(OutputKeys.ENCODING, Charsets.UTF_8.name());
            serializer.setOutputProperty(OutputKeys.INDENT, "yes");
            hd.setResult(streamResult);
            hd.startDocument();
        } catch (Exception e) {
            throw Exceptions.handle(e);
        }

#end
#end
#No. 188198
#File: E:\bishe\1\XMLStructuredOutput.java
#Comment:
    /**
     * Starts the output with the given root element.
     *
     * @param rootElement the name of the root element of the generated document.
     * @return the output itself for fluent method calls
     */

#Code:
    public StructuredOutput beginOutput(@Nonnull String rootElement) {
        if (opensCalled == 0) {
            try {
                hd.startDocument();
            } catch (SAXException e) {
                throw Exceptions.handle(e);
            }
        }

#end
#end
#No. 188199
#File: E:\bishe\1\XMLStructuredOutput.java
#Comment:
    /**
     * Starts the output with the given root element and attributes
     *
     * @param rootElement the name of the root element of the generated document.
     * @param attr        the attributes for the root element
     * @return the output itself for fluent method calls
     */

#Code:
    public StructuredOutput beginOutput(@Nonnull String rootElement, Attribute... attr) {
        if (opensCalled == 0) {
            try {
                hd.startDocument();
            } catch (SAXException e) {
                throw Exceptions.handle(e);
            }
        }

#end
#end
#No. 188200
#File: E:\bishe\1\XMLStructuredOutput.java
#Comment:
    /**
     * Creates a {@link AbstractStructuredOutput.TagBuilder} used to fluently create the root element.
     *
     * @param rootElement name of the root element
     * @return a tag builder which can be used to build the root element
     */

#Code:
    @CheckReturnValue
    public TagBuilder buildBegin(@Nonnull String rootElement) {
        if (opensCalled == 0) {
            try {
                hd.startDocument();
            } catch (SAXException e) {
                throw Exceptions.handle(e);
            }
        }

#end
#end
#No. 188201
#File: E:\bishe\1\XMLStructuredOutput.java
#Comment:
    /**
     * Closes the output and this XML document.
     */

#Code:
    public void endOutput() {
        endObject();
        if (opensCalled-- == 1) {
            super.endResult();
            try {
                hd.endDocument();
                out.close();
            } catch (SAXException | IOException e) {
                throw Exceptions.handle(e);
            }
        }
    }

#end
#end
#No. 188202
#File: E:\bishe\1\XMLStructuredOutput.java
#Comment:
    /**
     * Creates a text node for the current node.
     *
     * @param text the text to be added to the current node
     * @return the output itself for fluent method calls
     */

#Code:
    public StructuredOutput text(Object text) {
        try {
            if (text != null) {
                String val = text.toString();
                hd.characters(val.toCharArray(), 0, val.length());
            }
        } catch (SAXException e) {
            throw Exceptions.handle(e);
        }

        return this;
    }

#end
#end
#No. 188203
#File: E:\bishe\1\XMLStructuredOutput.java
#Comment:
    /**
     * Closes the underlying stream
     *
     * @throws IOException if an IO error occurs while closing the stream
     */

#Code:
    public void close() throws IOException {
        out.close();
    }

#end
#end
#No. 188204
#File: E:\bishe\1\XMLTagDecoratorSpan.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 */

#Code:
	public XMLTagDecoratorSpan(final Context context) {
		super(context, R.style.Axel_Xml_Decorators);
	}

#end
#end
#No. 188205
#File: E:\bishe\1\XMLTagSpan.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 */

#Code:
	public XMLTagSpan(final Context context) {
		super(context, R.style.Axel_Xml_Tag);
	}


#end
#end
#No. 188207
#File: E:\bishe\1\XmlTense.java
#Comment:
/**
 * <p>Java class for tense.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="tense">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="FUTURE"/>
 *     &lt;enumeration value="PAST"/>
 *     &lt;enumeration value="PRESENT"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "tense")
@XmlEnum
public enum XmlTense {

    FUTURE,
    PAST,
    PRESENT;

    public String value() {
        return name();
    }

    public static XmlTense fromValue(String v) {
        return valueOf(v);
    }

}

#end
#end
#No. 188208
#File: E:\bishe\1\XMLTextSpan.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 */

#Code:
	public XMLTextSpan(final Context context) {
		super(context, R.style.Axel_Xml_Text);
	}

#end
#end
#No. 188209
#File: E:\bishe\1\XMLToDatasourceInfoConverter.java
#Comment:
  /*
   * Return the first name that matched the tagName. Starting from the
   * current element location
   */

#Code:
  private Node getNodeByTagName( Element element, String tagName ) {
    NodeList list = element.getChildNodes();
    for ( int i = 0; i < list.getLength(); i++ ) {
      Node node = list.item( i );
      if ( node != null && node.getNodeName().equals( tagName ) ) {
        return node;
      }
    }
    return null;
  }

#end
#end
#No. 188210
#File: E:\bishe\1\XMLToDatasourceInfoConverter.java
#Comment:
  /*
   * Get Node Value of the element matching the tag name
   */

#Code:
  private String getNodeValueByTagName( Element element, String tagName ) {
    Node node = getNodeByTagName( element, tagName );
    if ( node != null && node.getFirstChild() != null ) {
      return node.getFirstChild().getNodeValue();
    } else {
      return null;
    }
  }

#end
#end
#No. 188211
#File: E:\bishe\1\XmlToPatchBodyReader.java
#Comment:
    /**
     * Prepare non-conditional XPath suitable for deserialization with {@link StringModuleInstanceIdentifierCodec}.
     *
     * @param schemaNode Top schema node
     * @param target Edit operation target
     * @param value Element with value
     * @param namespace Module namespace
     * @param revision Module revision
     * @return Non-conditional XPath
     */

#Code:
    private static String prepareNonCondXpath(@Nonnull final DataSchemaNode schemaNode, @Nonnull final String target,
            @Nonnull final Element value, @Nonnull final String namespace, @Nonnull final String revision) {
        final Iterator<String> args = Splitter.on("/").split(target.substring(target.indexOf(':') + 1)).iterator();

        final StringBuilder nonCondXpath = new StringBuilder();
        SchemaNode childNode = schemaNode;

        while (args.hasNext()) {
            final String s = args.next();
            nonCondXpath.append("/");
            nonCondXpath.append(s);
            childNode = ((DataNodeContainer) childNode).getDataChildByName(QName.create(namespace, revision, s));

            if (childNode instanceof ListSchemaNode && args.hasNext()) {
                appendKeys(nonCondXpath, ((ListSchemaNode) childNode).getKeyDefinition().iterator(), args);
            }
        }

#end
#end
#No. 188212
#File: E:\bishe\1\XmlToPatchBodyReader.java
#Comment:
    /**
     * Read value for every list key.
     *
     * @param value Value element
     * @param keys Iterator of list keys names
     * @return Iterator of list keys values
     */

#Code:
    private static Iterator<String> readKeyValues(@Nonnull final Element value, @Nonnull final Iterator<QName> keys) {
        final List<String> result = new ArrayList<>();

        while (keys.hasNext()) {
            result.add(value.getElementsByTagName(keys.next().getLocalName()).item(0).getFirstChild().getNodeValue());
        }

#end
#end
#No. 188213
#File: E:\bishe\1\XmlToPatchBodyReader.java
#Comment:
    /**
     * Append key name - key value pairs for every list key to {@code nonCondXpath}.
     *
     * @param nonCondXpath Builder for creating non-conditional XPath
     * @param keyNames Iterator of list keys names
     * @param keyValues Iterator of list keys values
     */

#Code:
    private static void appendKeys(@Nonnull final StringBuilder nonCondXpath, @Nonnull final Iterator<QName> keyNames,
                            @Nonnull final Iterator<String> keyValues) {
        while (keyNames.hasNext()) {
            nonCondXpath.append("[");
            nonCondXpath.append(keyNames.next().getLocalName());
            nonCondXpath.append("=");
            nonCondXpath.append("'");
            nonCondXpath.append(keyValues.next());
            nonCondXpath.append("'");
            nonCondXpath.append("]");
        }

#end
#end
#No. 188214
#File: E:\bishe\1\XmlTreeBuilder.java
#Comment:
    /**
     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not
     * found, skips.
     *
     * @param endTag
     */

#Code:
    private void popStackToClose(Token.EndTag endTag) {
        String elName = endTag.name();
        Element firstFound = null;

        Iterator<Element> it = stack.descendingIterator();
        while (it.hasNext()) {
            Element next = it.next();
            if (next.nodeName().equals(elName)) {
                firstFound = next;
                break;
            }
        }
        if (firstFound == null)
            return; // not found, skip

        it = stack.descendingIterator();
        while (it.hasNext()) {
            Element next = it.next();
            if (next == firstFound) {
                it.remove();
                break;
            } else {
                it.remove();
            }
        }
    }

#end
#end
#No. 188215
#File: E:\bishe\1\XmlTreeParser.java
#Comment:
	/**
	 * Declares a new namespace
	 * 
	 * @param prefix
	 *            the namespace prefix
	 * @param uri
	 *            the namespace uri
	 */

#Code:
	protected void declareNamespace(final String prefix, final String uri) {
		// TODO more checks if overwriting prefix or URI
		if (!mNamespacePrefixes.containsKey(prefix)) {
			mNamespaceURIs.put(uri, prefix);
			mNamespacePrefixes.put(prefix, uri);
			mNewNamespaces.add(uri);
		}
	}

#end
#end
#No. 188216
#File: E:\bishe\1\XmlTreeParser.java
#Comment:
	/**
	 * Creates the root document
	 */

#Code:
	protected void createRootDocument() {
		XmlNode doc = XmlNode.createDocument();
		mStack.push(doc);
		mRoot = doc;
	}


#end
#end
#No. 188219
#File: E:\bishe\1\XmlTreeParser.java
#Comment:
	/**
	 * @param node
	 *            the create node (must node be an element node ! )
	 */

#Code:
	protected void onCreateNode(final XmlNode node) {
		mStack.peek().addChildNode(node);

		sLastNode = node.toString().trim();
	}

#end
#end
#No. 188220
#File: E:\bishe\1\XmlTreeParser.java
#Comment:
	/**
	 * @param version
	 *            the version of the xml document
	 * @param encoding
	 *            the encoding charset
	 * @param standalone
	 *            is the file standalone
	 * @return an XML Document Declaration node
	 * @throws XmlPullParserException
	 */

#Code:
	protected void onCreateDocDecl(final String version, final String encoding,
			final Boolean standalone) throws XmlPullParserException {
		XmlNode docDecl = XmlNode.createDocumentDeclaration(version, encoding,
				standalone);

		if (mStack.size() > 1) {
			Log.w("Parser",
					"Trying to add doc decl to non root node ! something is quite wrong here ");
			throw new XmlPullParserException("Unclosed Root element");
		}
		
		onCreateNode(docDecl);
	}

#end
#end
#No. 188221
#File: E:\bishe\1\XmlTreeParser.java
#Comment:
	/**
	 * @param uri
	 *            a namespace URI
	 * @return the prefix for the given uri or null if URI is unknown
	 */

#Code:
	protected String getPrefixForUri(final String uri) {
		String prefix = null;
		if (mNamespaceURIs.containsKey(uri)) {
			prefix = mNamespaceURIs.get(uri);
		}

		return prefix;
	}

#end
#end
#No. 188222
#File: E:\bishe\1\XmlTreeParser.java
#Comment:
	/**
	 * @return the root node
	 */

#Code:
	public XmlNode getRoot() {
		if (mRoot != null) {
			mRoot.reorderDocumentChildren();
		}
		return mRoot;
	}

#end
#end
#No. 188223
#File: E:\bishe\1\XmlTreeParserException.java
#Comment:
	/**
	 * @param error
	 *            the error to set
	 * @param cause
	 *            the cause of this exception
	 */

#Code:
	public XmlTreeParserException(final XmlError error, final Throwable cause) {
		super(cause);
		mError = error;
	}

#end
#end
#No. 188224
#File: E:\bishe\1\XmlTreeParserException.java
#Comment:
	/**
	 * @return the error type
	 */

#Code:
	public XmlError getError() {
		return mError;
	}

#end
#end
#No. 188225
#File: E:\bishe\1\XmlTreeParserException.java
#Comment:
	/**
	 * @param context
	 *            the current application context
	 * @return the message to toast
	 */

#Code:
	public String getMessage(final Context context) {
		String message;

		switch (mError) {
		case noParser:
			message = context.getString(R.string.toast_xml_no_parser_found);
			break;
		case featureUnavailable:
			message = context.getString(R.string.toast_xml_unsupported_feature);
			break;
		case parseException:
			message = context.getString(R.string.toast_xml_parse_error);
			break;
		case ioException:
		default:
			message = context.getString(R.string.toast_xml_io_exception);
		}

		return message;
	}

#end
#end
#No. 188226
#File: E:\bishe\1\XmlTreeParserException.java
#Comment:
	/**
	 * @see java.lang.Throwable#getMessage()
	 */

#Code:
	@Override
	public String getMessage() {
		return getCause().getMessage();
	}

#end
#end
#No. 188227
#File: E:\bishe\1\XmlTreePullParser.java
#Comment:
	/**
	 * @param input
	 *            the input character stream
	 * @param createDocDecl
	 *            create the document declaration ?
	 * @param encoding
	 *            the encoding of the input stream
	 * @return an XML Node from the parser
	 * @throws XmlPullParserUnavailableFeatureException
	 *             when a feature is not supported by the current device
	 * @throws XmlPullParserInstantiationException
	 *             when the factory can't create a new parser
	 * @throws XmlPullParserException
	 *             when a parsing error occurs
	 * @throws IOException
	 * @throws StringIndexOutOfBoundsException
	 */

#Code:
	public static XmlNode parseXmlTree(final InputStream input,
			final boolean createDocDecl, final String encoding)
			throws XmlPullParserUnavailableFeatureException,
			XmlPullParserInstantiationException, XmlPullParserException,
			StringIndexOutOfBoundsException, IOException {

		XmlPullParserFactory factory;
		XmlPullParser xpp;
		XmlTreePullParser parser;

		parser = new XmlTreePullParser();

		try {
			factory = XmlPullParserFactory.newInstance();
		} catch (XmlPullParserException e) {
			throw new XmlPullParserInstantiationException(
					"Factory couldn't create new parser instance", null, e);
		}

		try {
			xpp = factory.newPullParser();
		} catch (XmlPullParserException e) {
			throw new XmlPullParserUnavailableFeatureException(
					"Some required features are unavailable", null, e);
		}

		xpp.setInput(input, encoding);
		parser.parse(xpp);
		if (createDocDecl) {
			parser.pullDocumentDeclaration(xpp);
		}

		return parser.getRoot();
	}

#end
#end
#No. 188228
#File: E:\bishe\1\XmlTreePullParser.java
#Comment:
	/**
	 * @param xpp
	 *            the parser
	 * @throws XmlPullParserException
	 */

#Code:
	protected void pullTextNode(final XmlPullParser xpp)
			throws XmlPullParserException {
		if (!xpp.isWhitespace()) {
			onCreateNode(XmlNode.createText(xpp.getText()));
		}
	}

#end
#end
#No. 188229
#File: E:\bishe\1\XmlTreePullParser.java
#Comment:
	/**
	 * @param xpp
	 *            the parser
	 * @throws XmlPullParserException
	 */

#Code:
	protected void pullCDataNode(final XmlPullParser xpp)
			throws XmlPullParserException {
		onCreateNode(XmlNode.createCDataSection(xpp.getText()));
	}

#end
#end
#No. 188230
#File: E:\bishe\1\XmlTreePullParser.java
#Comment:
	/**
	 * @param xpp
	 *            the parser
	 * @throws XmlPullParserException
	 */

#Code:
	protected void pullCommentNode(final XmlPullParser xpp)
			throws XmlPullParserException {
		onCreateNode(XmlNode.createComment(xpp.getText()));
	}

#end
#end
#No. 188231
#File: E:\bishe\1\XmlTreePullParser.java
#Comment:
	/**
	 * @param xpp
	 *            the parser
	 * @throws XmlPullParserException
	 */

#Code:
	protected void pullDoctypeNode(final XmlPullParser xpp)
			throws XmlPullParserException {
		onCreateNode(XmlNode.createDoctypeDeclaration(xpp.getText()));
	}

#end
#end
#No. 188232
#File: E:\bishe\1\XmlTreePullParser.java
#Comment:
	/**
	 * @param xpp
	 *            the parser
	 * @throws XmlPullParserException
	 */

#Code:
	protected void pullProcessingInstructionNode(final XmlPullParser xpp)
			throws XmlPullParserException {

		String text = xpp.getText().trim();

		XmlNode pi = XmlNode.createProcessingInstruction(text);

		onCreateNode(pi);
	}

#end
#end
#No. 188233
#File: E:\bishe\1\XmlTreePullParser.java
#Comment:
	/**
	 * @param xpp
	 *            the parser
	 * @throws XmlPullParserException
	 */

#Code:
	protected void pullDocumentDeclaration(final XmlPullParser xpp) throws XmlPullParserException {
		String version, enc;
		Boolean standalone;

		version = (String) xpp.getProperty(PROPERTY_XML_VERSION);
		if (version == null) {
			version = "1.0";
		}

		enc = xpp.getInputEncoding();

		standalone = (Boolean) xpp.getProperty(PROPERTY_XML_STANDALONE);

		onCreateDocDecl(version, enc, standalone);
	}

#end
#end
#No. 188234
#File: E:\bishe\1\XmlTreeSaxParser.java
#Comment:
	/**
	 * @param input
	 *            the input character stream
	 * @return an XML Node from the parser
	 * @throws XmlTreeParserException
	 *             if an error occurs during the parsing
	 */

#Code:
	public static XmlNode parseXmlTree(Reader input)
			throws XmlTreeParserException {
		XmlTreeSaxParser parser = new XmlTreeSaxParser();

		XMLReader reader;

		// set the driver
		System.setProperty("org.xml.sax.driver", "org.xmlpull.v1.sax2.Driver");

		try {
			reader = XMLReaderFactory.createXMLReader();
		} catch (SAXException e) {
			throw new XmlTreeParserException(XmlError.noParser, e);
		}

		try {
			reader.setContentHandler(parser);

			reader.setFeature(FEATURE_NAMESPACES, true);
			reader.setFeature(FEATURE_REPORT_NAMESPACE, true);
			reader.setFeature(FEATURE_VALIDATE_URI, true);
			reader.setFeature(FEATURE_IGNORE_ERROR, true);

		} catch (SAXNotSupportedException e) {
			throw new XmlTreeParserException(XmlError.featureUnavailable, e);
		} catch (SAXNotRecognizedException e) {
			throw new XmlTreeParserException(XmlError.featureUnavailable, e);
		}

		try {
			reader.parse(new InputSource(input));
		} catch (IOException e) {
			throw new XmlTreeParserException(XmlError.ioException, e);
		} catch (SAXException e) {
			throw new XmlTreeParserException(XmlError.parseException, e);
		}

		return parser.getRoot();
	}

#end
#end
#No. 188235
#File: E:\bishe\1\XmlTreeSaxParser.java
#Comment:
	/**
	 * @see org.xml.sax.ContentHandler#startDocument()
	 */

#Code:
	public void startDocument() throws SAXException {
		createRootDocument();
	}

#end
#end
#No. 188236
#File: E:\bishe\1\XmlTreeSaxParser.java
#Comment:
	/**
	 * @see org.xml.sax.ContentHandler#startPrefixMapping(java.lang.String,
	 *      java.lang.String)
	 */

#Code:
	public void startPrefixMapping(String prefix, String uri)
			throws SAXException {
		declareNamespace(prefix, uri);
	}

#end
#end
#No. 188237
#File: E:\bishe\1\XmlTreeSaxParser.java
#Comment:
	/**
	 * @see org.xml.sax.ContentHandler#endPrefixMapping(java.lang.String)
	 */

#Code:
	public void endPrefixMapping(String prefix) throws SAXException {

	}

#end
#end
#No. 188238
#File: E:\bishe\1\XmlTreeSaxParser.java
#Comment:
	/**
	 * @see org.xml.sax.ContentHandler#startElement(java.lang.String,
	 *      java.lang.String, java.lang.String, org.xml.sax.Attributes)
	 */

#Code:
	public void startElement(String uri, String localName, String qName,
			Attributes atts) throws SAXException {
		String prefix;

		// Handle Tag name
		prefix = getPrefixForUri(uri);
		XmlNode tag = XmlNode.createElement(prefix, localName);

		// Handle attributes
		String attUri, attName, attValue, attPrefix;
		int count = atts.getLength();
		for (int i = 0; i < count; ++i) {
			attUri = atts.getURI(i);
			attPrefix = getPrefixForUri(attUri);

			attName = atts.getLocalName(i);
			attValue = atts.getValue(i);

			tag.getContent().addAttribute(attPrefix, attName, attValue);
		}

		onCreateElement(tag);
	}

#end
#end
#No. 188239
#File: E:\bishe\1\XmlTreeSaxParser.java
#Comment:
	/**
	 * @see org.xml.sax.ContentHandler#endElement(java.lang.String,
	 *      java.lang.String, java.lang.String)
	 */

#Code:
	public void endElement(String uri, String localName, String qName)
			throws SAXException {
		onCloseElement();
	}

#end
#end
#No. 188240
#File: E:\bishe\1\XmlTreeSaxParser.java
#Comment:
	/**
	 * @see org.xml.sax.ContentHandler#characters(char[], int, int)
	 */

#Code:
	public void characters(char[] ch, int start, int length)
			throws SAXException {

	}

#end
#end
#No. 188241
#File: E:\bishe\1\XmlTreeSaxParser.java
#Comment:
	/**
	 * @see org.xml.sax.ContentHandler#ignorableWhitespace(char[], int, int)
	 */

#Code:
	public void ignorableWhitespace(char[] ch, int start, int length)
			throws SAXException {
	}

#end
#end
#No. 188242
#File: E:\bishe\1\XmlTreeSaxParser.java
#Comment:
	/**
	 * @see org.xml.sax.ContentHandler#processingInstruction(java.lang.String,
	 *      java.lang.String)
	 */

#Code:
	public void processingInstruction(String target, String data)
			throws SAXException {
		// XmlNode pi = XmlNode.createProcessingInstruction(target, data);

	}

#end
#end
#No. 188243
#File: E:\bishe\1\XmlTreeSaxParser.java
#Comment:
	/**
	 * @see org.xml.sax.ContentHandler#skippedEntity(java.lang.String)
	 */

#Code:
	public void skippedEntity(String name) throws SAXException {
		Log.i("IGNORED", name);
	}

#end
#end
#No. 188244
#File: E:\bishe\1\XMLUserParser.java
#Comment:
	/**
	 * Create a new stream parser from the given input stream.
	 * 
	 * @param stream An {@link InputStream} stream to parse.
	 */

#Code:
	private XMLUserParser(InputStream stream, String encoding) throws XMLStreamException {
		super(stream, encoding);
	}

#end
#end
#No. 188245
#File: E:\bishe\1\XMLUserParser.java
#Comment:
	/**
	 * Parse the input stream as a {@link User} object.
	 * 
	 * @return An {@link Object} which can then be cast.
	 * 
	 * @throws XMLStreamException
	 * @throws XMLParserException
	 */

#Code:
	private User parse(User user) throws XMLStreamException, XMLParserException {
		String name;
		
		/* Check if reader is currently on a start element. */
		if(this.reader.getEventType() == START_ELEMENT){
			name = this.reader.getLocalName();
			
			/* Check current element name and start parsing it. */
			if(name.equals("products")){
				return this.parseUser(user);
			}
			else{
				throw new XMLParserException(
					"Unexpected element '<" + name + ">'", this.reader.getLocation()
				);
			}
		}
		
		throw new IllegalStateException("Reader is not on a start element!");
	}

#end
#end
#No. 188246
#File: E:\bishe\1\XMLUserParser.java
#Comment:
	/**
	 * Parse {@code xml} into an object using the specified {@code encoding}.
	 * 
	 * @param data     The xml as bytes.
	 * @param encoding The encoding to use.
	 * 
	 * @return An object if successful, null if not.
	 */

#Code:
	public static User parse(byte[] data, String encoding, User user){
		try{
			XMLUserParser parser = new XMLUserParser(new ByteArrayInputStream(data), encoding);
			
			return parser.parse(user);
		}
		catch(XMLStreamException e){
			return null;
		}
		catch(XMLParserException e){
			return null;
		}
	}

#end
#end
#No. 188247
#File: E:\bishe\1\XMLUserParser.java
#Comment:
	/**
	 * Parse {@code xml} into a {@link User} object using the specified {@code encoding}.
	 * 
	 * @param data     The xml as bytes.
	 * @param encoding The encoding to use.
	 * 
	 * @return A {@link User} object if successful, null if not.
	 */

#Code:
	public static User parseUser(byte[] data, String encoding, User user){
		return parse(data, encoding, user);
	}

#end
#end
#No. 188248
#File: E:\bishe\1\XmlUtilities.java
#Comment:
    /**
     * Array of String[] matching each XPath expression
     * @param node node to search under. Top body node
     * @param wantedXpathEntries
     * @return
     * @throws Exception
     */

#Code:
    public static String[][] extractXpathEntries( Node node, String[] wantedXpathEntries ) throws Exception {

        List<String[]> values = new ArrayList<String[]>( wantedXpathEntries.length );
        for( String expression : wantedXpathEntries ) {
            values.add( getByXpath( node, expression ) );
        }
        return values.toArray( new String[values.size()][] );
    }

#end
#end
#No. 188249
#File: E:\bishe\1\XmlUtilities.java
#Comment:
    /**
     * Filter some headers which constantly change, so can not be matched
     *
     * @param responseNode xml response node
     * @return only the significant header nodes
     */

#Code:
    public Node[] getSignificantResponseHeaders( Node responseNode ) {

        List<Node> significantHeaders = new ArrayList<Node>();

        Node[] allHeaders = getChildrenNodes( responseNode, TOKEN_HTTP_HEADER );
        for( Node header : allHeaders ) {
            String headerName = getNodeAttribute( header, TOKEN_HEADER_NAME_ATTRIBUTE );
            if( HttpClient.log.isTraceEnabled() ) {
                HttpClient.log.trace( "header found: '" + headerName + "', value: '"
                                      + getNodeAttribute( header, TOKEN_HEADER_VALUE_ATTRIBUTE ) + "'" );
            }

            // Set-Cookie must always be a significant header
            if( headerName.equalsIgnoreCase( HeaderMatcher.SET_COOKIE_HEADER_NAME ) ) {
                significantHeaders.add( header );
                continue;
            }

            boolean isSignificantHeader = true;
            for( String nonSignificantHeader : TemplateActionsXmlDefinitions.NON_SIGNIFICANT_HEADERS ) {
                if( headerName.equalsIgnoreCase( nonSignificantHeader ) ) {
                    isSignificantHeader = false;
                    if( HttpClient.log.isTraceEnabled() ) {
                        HttpClient.log.trace( "header '" + headerName
                                              + "' not loaded from XML file as it is a not important one" );
                    }
                    break;
                }
            }
            if( isSignificantHeader ) {
                significantHeaders.add( header );
            }
        }
        return significantHeaders.toArray( new Node[significantHeaders.size()] );
    }


#end
#end
#No. 188251
#File: E:\bishe\1\XmlUtilities.java
#Comment:
    /**
     *
     * @param xmlString xml string
     * @return xml Document object
     * @throws XmlUtilitiesException
     */

#Code:
    public static Document stringToXmlDocumentObj( String xmlString ) throws XmlUtilitiesException {

        try {
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            return db.parse( new ByteArrayInputStream( xmlString.getBytes() ) );
        } catch( Exception e ) {
            throw new XmlUtilitiesException( "Error transforming String to XML document", e );
        }
    }

#end
#end
#No. 188252
#File: E:\bishe\1\XmlUtilities.java
#Comment:
    /**
     * Applies the user parameters, but does not modify the original (as they come from the XML file)
     * matchers
     *
     * @param staticXpathBodyMatchers
     * @return
     * @throws InvalidMatcherException
     */

#Code:
    private List<XPathBodyMatcher>
            applyUserParameters( List<XPathBodyMatcher> staticXpathBodyMatchers ) throws InvalidMatcherException {

        List<XPathBodyMatcher> actualXpathBodyMatchers = new ArrayList<XPathBodyMatcher>();

        for( XPathBodyMatcher matcher : staticXpathBodyMatchers ) {
            String matcherValue = matcher.getMatcherValue();
            String attributeName = ( String ) ThreadContext.getAttribute( matcherValue );
            if( attributeName != null ) {
                matcherValue = ThreadContext.getAttribute( attributeName ).toString();
            }

            actualXpathBodyMatchers.add( new XPathBodyMatcher( matcher.getXpath(), matcherValue,
                                                               matcher.getMatchMode() ) );
        }

        return actualXpathBodyMatchers;
    }

#end
#end
#No. 188253
#File: E:\bishe\1\XmlUtilities.java
#Comment:
    /**
     * Get values matching passed XPath expression
     * @param node
     * @param expression XPath expression
     * @return matching values
     * @throws Exception
     */

#Code:
    private static String[] getByXpath( Node node, String expression ) throws Exception {

        XPathFactory xPathFactory = XPathFactory.newInstance();
        XPath xPath = xPathFactory.newXPath();
        XPathExpression xPathExpression = xPath.compile( expression );

        NodeList nlist = ( NodeList ) xPathExpression.evaluate( node, XPathConstants.NODESET );

        int nodeListSize = nlist.getLength();
        List<String> values = new ArrayList<String>( nodeListSize );
        for( int index = 0; index < nlist.getLength(); index++ ) {
            Node aNode = nlist.item( index );
            values.add( aNode.getTextContent() );
        }
        return values.toArray( new String[values.size()] );
    }

#end
#end
#No. 188254
#File: E:\bishe\1\XmlUtilities.java
#Comment:
    /**
     * Log the response body content. This method is used for error logging or traces.
     *
     * @param actionName action name
     * @param stepNumber action step number starting from 1
     * @param actualHttpResponse data for the actual response
     * @param isError if this should be logged as error or just for tracing/debugging purposes
     */

#Code:
    private void logActualResponse( String causeMsg, String actionName, int stepNumber,
                                    ActionParser actualHttpResponse, boolean isError ) {

        try {

            StringBuilder logMsg = new StringBuilder();
            logMsg.append( /*"Response verification failed. " + */causeMsg + "\n Dumping response of action "
                           + actionName + "[" + stepNumber + "]:\n"
                           + xmlNodeToString( actualHttpResponse.getActionNodeWithoutBody() ) );

            // append missing body
            if( isContentPrintable( actualHttpResponse.getContentType() ) ) {

                StringBuilder bodySB = new StringBuilder();
                if( actualHttpResponse.getBodyContentAsString() == null ) {
                    bodySB.append( " null (Increase Log4J severity of " + HttpClient.class.getName()
                                   + " logger to TRACE if you want body contents)" );
                } else {
                    bodySB.append( actualHttpResponse.getBodyContentAsString() );
                }
                logMsg.append( "\nResponse body:\n" );
                logMsg.append( bodySB );
            }

            if( isError ) {
                HttpClient.log.error( logMsg );
            } else {
                HttpClient.log.trace( logMsg );
            }
        } catch( Exception e ) {

            log.error( "Error during logging the actual response for " + actionName + "[" + stepNumber + "]",
                       e );
        }
    }

#end
#end
#No. 188255
#File: E:\bishe\1\XmlUtilities.java
#Comment:
    /**
     *
     * @param contentType the content type
     * @return <code>true</code> if the content is printable or <code>false</code> if it is not
     */

#Code:
    private boolean isContentPrintable( String contentType ) {

        if( contentType == null ) {
            return false;
        }

        contentType = contentType.toLowerCase();
        for( String printableContentType : PRINTABLE_CONTENT_TYPES ) {
            if( contentType.startsWith( printableContentType ) ) {
                return true;
            }
        }

        // the content is not printable
        return false;
    }


#end
#end
#No. 188258
#File: E:\bishe\1\XmlViolationPolicy.java
#Comment:
/**
 * Policy for XML 1.0 violations.
 * 
 * @version $Id$
 * @author hsivonen
 */

#Code:
public enum XmlViolationPolicy {
    /**
     * Conform to HTML 5, allow XML 1.0 to be violated.
     */
    ALLOW,
    
    /**
     * Halt when something cannot be mapped to XML 1.0.
     */
    FATAL,
    
    /**
     * Be non-conforming and alter the infoset to fit 
     * XML 1.0 when something would otherwise not be 
     * mappable to XML 1.0.
     */
    ALTER_INFOSET
}


#end
#end
#No. 188260
#File: E:\bishe\1\XMLWorkflowFactory.java
#Comment:
	/**
	 * Get where to find workflow XML files.
	 * 
	 * @param root
	 *            The root element of the XML file.
	 * @return The absolute base dir used for finding these files or null.
	 */

#Code:
	protected String getBaseDir(Element root) {
		String basedir = root.getAttribute("basedir");

		if (basedir.length() == 0) {
			// No base dir defined
			return null;
		}

		if (new File(basedir).isAbsolute()) {
			// An absolute base dir defined
			return basedir;
		} else {
			// Append the current working directory to the relative base dir
			return new File(System.getProperty("user.dir"), basedir).getAbsolutePath();
		}
	}


#end
#end
#No. 188263
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Sets the length of the indentation of the XMLFileWriter
   * object. If relative = false the indentation will be a string consisting
   * of the number of spaces specified by the `indent' parameter. If relative = true
   * then the current indentation is augmented or decreased by the number of spaces
   * specified by the `indent' parameter.
   *
   * @param indent the number of spaces that constitute the indentation.
   * @param relative determines whether indentation should be relative to the
   * current level of indentation -- <code>relative = true</code> -- or else
   * absolute -- <code>relative = false</code>.
   */

#Code:
  public void setIndent(int indent, boolean relative) throws RuntimeException {
    if (indent == 0 && !relative) {
      this.indentString = baseIndentString;
    } else if (indent > 0) {
      char[] ind = new char[indent];
      Arrays.fill(ind, ' ');
      String offset = this.indentString.copyValueOf(ind);
      if (relative) {
        this.indentString = this.indentString + offset;
      } else {
        this.indentString = offset;
      }
    } else {
      if (0 > indent) {
        if (relative) {
          int abs = -1 * indent;
          if (this.indentString.length() >= abs) {
            this.indentString = this.indentString.substring(abs);
          } else {
            //System.out.println("XMLWriter cannot have negative indentation");
            throw new RuntimeException("XMLWriter cannot have negative indentation");
          }
        } else {
          throw new RuntimeException("XMLWriter cannot have negative indentation");
        }
      }
    }
  }

#end
#end
#No. 188264
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Resets the indentationof the <code>XMLWriter</code> to its default value.
   */

#Code:
  public void resetIndent() {
    this.indentString = this.baseIndentString;
  }

#end
#end
#No. 188265
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Returns the length of the current value of @see #indentString.
   */

#Code:
  public int getIndentLength() {
    return this.indentString.length();
  }


#end
#end
#No. 188268
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Prints a string and terminates the line. The string is printed to this <code>XMLWriter</code>
   * and indented by the number of spaces indicated by @see #indent either relative to the
   * current indentation level (if @see #relative is <code>true</code>) or with
   * respect to the beginning of the line (if @see #relative is <code>false</code>).
   *
   * @param string the string to be printed.
   * @param indent the number of spaces by which the string needs to be indented.
   * @param relative id <code>true</code> the string is further indented with respect
   * to the current indentation level, if <code>false</code> is indented with respect to
   * the beginning of the line.
   */

#Code:
  public void indentPrintln(String string, int indent, boolean relative) throws java.io.IOException {
    indentPrint(string + "\n", indent, relative);
  }

#end
#end
#No. 188269
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Prints a string after replacing all the reserved XML characters
   * with the appropriate XML entity references and terminates the line.
   * The string is printed to this <code>XMLWriter</code> and indented by the number
   * of spaces indicated by @see #indent either relative to the current indentation
   * level (if @see #relative is <code>true</code>) or with respect to the beginning
   * of the line (if @see #relative is <code>false</code>).
   * @param string the string to be printed.
   * @param indent the number of spaces by which the string needs to be indented.
   * @param relative id <code>true</code> the string is further indented with respect
   * to the current indentation level, if <code>false</code> is indented with respect to
   * the beginning of the line.
   */

#Code:
  public void indentPrintSafeln(String string, int indent, boolean relative) throws java.io.IOException {
    String safeString = introduceXMLEntities(string) + "\n";
    indentPrint(safeString, indent, relative);
  }

#end
#end
#No. 188270
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Prints to this <code>XMLWriter</code> an atomic XML tag with no attributes.
   * The tag is indented by @see #indent spaces either from the beginning of the
   * line (if @see #relative is <code>false</code>) or relative to the current
   * indentation level(if @see #relative is <code>true</code>).
   *
   * @param tag the name of the XML tag.
   * @param indent the number of spaces by which the tag needs to be indented.
   * @param relative specifies whether the indentation is from the beginning
   * of the line (if @see #relative is <code>false</code>) or from the current
   * level of indentation (if @see #relative is <code>true</code>).
   */

#Code:
  public void printXMLAtomicTag(String tag, int indent, boolean relative) throws java.io.IOException {
    String xmltag = "<" + tag + "/>";
    this.indentPrintln(xmltag, indent, relative);
  }

#end
#end
#No. 188271
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Prints to this <code>XMLWriter</code> an atomic XML tag with attributes.
   * The tag is indented by @see #indent spaces either from the beginning of the
   * line (if @see #relative is <code>false</code>) or relative to the current
   * indentation level(if @see #relative is <code>true</code>).
   *
   * @param tag the name of the XML tag.
   * @param attributesIterator an iterator over a list of attribute/value
   * <code>Pair</code>s.
   * @param indent the number of spaces by which the tag needs to be indented.
   * @param relative specifies whether the indentation is from the beginning
   * of the line (if @see #relative is <code>false</code>) or from the current
   * level of indentation (if @see #relative is <code>true</code>).
   */

#Code:
  public void printXMLAtomicTag(String tag, ListIterator attributesIterator, int indent, boolean relative) throws java.io.IOException {
    String attributeString = "";
    while (attributesIterator.hasNext()) {
      Pair attributePair = (Pair) attributesIterator.next();
      attributeString = " " + (String) attributePair.component1 + "=\"" + (String) attributePair.component2
              + "\"" + attributeString;
    }
    String xmltag = "<" + tag + attributeString + "/>";
    this.indentPrintln(xmltag, indent, relative);
  }

#end
#end
#No. 188272
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Prints to this <code>XMLWriter</code> an atomic XML tag with a single attribute.
   * The tag is indented by @see #indent spaces either from the beginning of the
   * line (if @see #relative is <code>false</code>) or relative to the current
   * indentation level(if @see #relative is <code>true</code>).
   *
   * @param tag the name of the XML tag.
   * @param attributeName the name of the attribute.
   * @param attributeValue the value of the attribute.
   * @param indent the number of spaces by which the tag needs to be indented.
   * @param relative specifies whether the indentation is from the beginning
   * of the line (if @see #relative is <code>false</code>) or from the current
   * level of indentation (if @see #relative is <code>true</code>).
   * @param newline specifies whether the line should be terminated after the tag
   * has been printed
   */

#Code:
  public void printXMLAtomicTag(String tag, String attributeName, String attributeValue, int indent,
          boolean relative, boolean newline) throws java.io.IOException {
    String attributeString = attributeName + "=\"" + attributeValue + "\"";
    String xmltag = "<" + tag + " " + attributeString + "/>";
    if (newline) {
      this.indentPrintln(xmltag, indent, relative);
    } else {
      this.indentPrint(xmltag, indent, relative);
    }
  }

#end
#end
#No. 188273
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Prints to this <code>XMLWriter</code> an XML start tag with no attributes.
   * The tag is indented by @see #indent spaces either from the beginning of the
   * line (if @see #relative is <code>false</code>) or relative to the current
   * indentation level(if @see #relative is <code>true</code>).
   *
   * @param tag the name of the XML tag.
   * @param indent the number of spaces by which the tag needs to be indented.
   * @param relative specifies whether the indentation is from the beginning
   * of the line (if @see #relative is <code>false</code>) or from the current
   * level of indentation (if @see #relative is <code>true</code>).
   * @param newline specifies whether the line should be terminated after the tag
   * has been printed
   */

#Code:
  public void printXMLStartTag(String tag, int indent, boolean relative, boolean newline) throws java.io.IOException {
    String xmltag = "<" + tag + ">";
    if (newline) {
      this.indentPrintln(xmltag, indent, relative);
    } else {
      this.indentPrint(xmltag, indent, relative);
    }
  }

#end
#end
#No. 188274
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Prints to this <code>XMLWriter</code> an XML start tag with attributes.
   * The tag is indented by @see #indent spaces either from the beginning of the
   * line (if @see #relative is <code>false</code>) or relative to the current
   * indentation level(if @see #relative is <code>true</code>).
   *
   * @param tag the name of the XML tag.
   * @param attributesIterator an iterator over a list of attribute/value
   * @param indent the number of spaces by which the tag needs to be indented.
   * @param relative specifies whether the indentation is from the beginning
   * of the line (if @see #relative is <code>false</code>) or from the current
   * level of indentation (if @see #relative is <code>true</code>).
   * @param newline specifies whether the line should be terminated after the tag
   * has been printed
   */

#Code:
  public void printXMLStartTag(String tag, ListIterator attributesIterator, int indent, boolean relative,
          boolean newline) throws java.io.IOException {
    String attributeString = "";
    while (attributesIterator.hasNext()) {
      Pair attributePair = (Pair) attributesIterator.next();
      attributeString = " " + (String) attributePair.component1 + "=\"" + (String) attributePair.component2
              + "\"" + attributeString;
    }
    String xmltag = "<" + tag + attributeString + ">";
    if (newline) {
      this.indentPrintln(xmltag, indent, relative);
    } else {
      this.indentPrint(xmltag, indent, relative);
    }
  }

#end
#end
#No. 188275
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Prints to this <code>XMLWriter</code> an XML start tag with a single attribute.
   * The tag is indented by @see #indent spaces either from the beginning of the
   * line (if @see #relative is <code>false</code>) or relative to the current
   * indentation level(if @see #relative is <code>true</code>).
   *
   * @param tag the name of the XML tag.
   * @param attributeName the name of the attribute.
   * @param attributeValue the value of the attribute.
   * @param indent the number of spaces by which the tag needs to be indented.
   * @param relative specifies whether the indentation is from the beginning
   * of the line (if @see #relative is <code>false</code>) or from the current
   * level of indentation (if @see #relative is <code>true</code>).
   * @param newline specifies whether the line should be terminated after the tag
   * has been printed
   */

#Code:
  public void printXMLStartTag(String tag, String attributeName, String attributeValue, int indent,
          boolean relative, boolean newline) throws java.io.IOException {
    String attributeString = attributeName + "=\"" + attributeValue + "\"";
    String xmltag = "<" + tag + " " + attributeString + ">";
    if (newline) {
      this.indentPrintln(xmltag, indent, relative);
    } else {
      this.indentPrint(xmltag, indent, relative);
    }
  }

#end
#end
#No. 188276
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Prints to this <code>XMLWriter</code> an XML end tag.
   * The tag is indented by @see #indent spaces either from the beginning of the
   * line (if @see #relative is <code>false</code>) or relative to the current
   * indentation level(if @see #relative is <code>true</code>).
   *
   * @param tag the name of the XML tag.
   * @param indent the number of spaces by which the tag needs to be indented.
   * @param relative specifies whether the indentation is from the beginning
   * of the line (if @see #relative is <code>false</code>) or from the current
   * level of indentation (if @see #relative is <code>true</code>).
   */

#Code:
  public void printXMLEndTag(String tag, int indent, boolean relative) throws java.io.IOException {
    String xmltag = "</" + tag + ">";
    this.indentPrintln(xmltag, indent, relative);
  }

#end
#end
#No. 188277
#File: E:\bishe\1\XMLWriter.java
#Comment:
  /**
   * Prints to this <code>XMLWriter</code> an XML end tag.
   *
   * @param tag the name of the XML tag.
   */

#Code:
  public void printXMLEndTag(String tag) throws java.io.IOException {
    String xmltag = "</" + tag + ">";
    this.print(xmltag + "\n");
  }

#end
#end
#No. 188278
#File: E:\bishe\1\XmlWriterOutputStream.java
#Comment:
	/**
	 Get String that inserts the tag name and attributes (will just return &lt;tagName&gt;). If a {@link KeyValueString#getValue()} is null, attribute will be skipped. All attribute values are
	 escaped via {@link #esc(String)}
	 */

#Code:
	@NotNull
	public String getTagStart(@NotNull String tagName, @NotNull KeyValueString... attributes) {
		String s = "<" + tagName;
		if (attributes.length != 0) {
			for (KeyValueString attribute : attributes) {
				if (attribute.getValue() == null) {
					continue;
				}
				s += " " + attribute.getKey() + "='" + esc(attribute.getValue()) + "'";
			}
		}

#end
#end
#No. 188279
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeLineBreak(org.codehaus.plexus.util.xml.XMLWriter)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteLineBreakXMLWriter()
        throws Exception
    {
        XmlWriterUtil.writeLineBreak( xmlWriter );
        writer.close();
        assertTrue( StringUtils.countMatches( output.toString(), XmlWriterUtil.LS ) == 1 );
    }

#end
#end
#No. 188280
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeLineBreak(org.codehaus.plexus.util.xml.XMLWriter, int)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteLineBreakXMLWriterInt()
        throws Exception
    {
        XmlWriterUtil.writeLineBreak( xmlWriter, 10 );
        writer.close();
        assertTrue( StringUtils.countMatches( output.toString(), XmlWriterUtil.LS ) == 10 );
    }

#end
#end
#No. 188281
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeLineBreak(org.codehaus.plexus.util.xml.XMLWriter, int, int)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteLineBreakXMLWriterIntInt()
        throws Exception
    {
        XmlWriterUtil.writeLineBreak( xmlWriter, 10, 2 );
        writer.close();
        assertTrue( StringUtils.countMatches( output.toString(), XmlWriterUtil.LS ) == 10 );
        assertTrue( StringUtils.countMatches( output.toString(), StringUtils
            .repeat( " ", 2 * XmlWriterUtil.DEFAULT_INDENTATION_SIZE ) ) == 1 );
    }

#end
#end
#No. 188282
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeLineBreak(org.codehaus.plexus.util.xml.XMLWriter, int, int, int)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteLineBreakXMLWriterIntIntInt()
        throws Exception
    {
        XmlWriterUtil.writeLineBreak( xmlWriter, 10, 2, 4 );
        writer.close();
        assertTrue( StringUtils.countMatches( output.toString(), XmlWriterUtil.LS ) == 10 );
        assertTrue( StringUtils.countMatches( output.toString(), StringUtils.repeat( " ", 2 * 4 ) ) == 1 );
    }

#end
#end
#No. 188283
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeCommentLineBreak(org.codehaus.plexus.util.xml.XMLWriter)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentLineBreakXMLWriter()
        throws Exception
    {
        XmlWriterUtil.writeCommentLineBreak( xmlWriter );
        writer.close();
        StringBuilder sb = new StringBuilder();
        sb.append( "<!-- ====================================================================== -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == XmlWriterUtil.DEFAULT_COLUMN_LINE - 1 + XmlWriterUtil.LS.length() );
    }

#end
#end
#No. 188284
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeCommentLineBreak(org.codehaus.plexus.util.xml.XMLWriter, int)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentLineBreakXMLWriterInt()
        throws Exception
    {
        XmlWriterUtil.writeCommentLineBreak( xmlWriter, 20 );
        writer.close();
        assertEquals( output.toString(), "<!-- ========== -->" + XmlWriterUtil.LS );

        tearDown();
        setUp();

        XmlWriterUtil.writeCommentLineBreak( xmlWriter, 10 );
        writer.close();
        assertEquals( output.toString(), output.toString(), "<!--  -->" + XmlWriterUtil.LS );
    }

#end
#end
#No. 188285
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeComment(org.codehaus.plexus.util.xml.XMLWriter, java.lang.String)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentXMLWriterString()
        throws Exception
    {
        XmlWriterUtil.writeComment( xmlWriter, "hello" );
        writer.close();
        StringBuffer sb = new StringBuffer();
        sb.append( "<!-- hello                                                                  -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == XmlWriterUtil.DEFAULT_COLUMN_LINE - 1 + XmlWriterUtil.LS.length() );

        tearDown();
        setUp();

        XmlWriterUtil.writeComment( xmlWriter,
                                    "hellooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo" );
        writer.close();
        sb = new StringBuffer();
        sb.append( "<!-- hellooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo -->" )
            .append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() >= XmlWriterUtil.DEFAULT_COLUMN_LINE );

        tearDown();
        setUp();

        XmlWriterUtil.writeComment( xmlWriter, "hello\nworld" );
        writer.close();
        sb = new StringBuffer();
        sb.append( "<!-- hello                                                                  -->" ).append( XmlWriterUtil.LS );
        sb.append( "<!-- world                                                                  -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == 2 * ( XmlWriterUtil.DEFAULT_COLUMN_LINE - 1 + XmlWriterUtil.LS.length() ) );
    }

#end
#end
#No. 188286
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeComment(org.codehaus.plexus.util.xml.XMLWriter, java.lang.String, int)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentXMLWriterStringInt()
        throws Exception
    {
        String indent = StringUtils.repeat( " ", 2 * XmlWriterUtil.DEFAULT_INDENTATION_SIZE );

        XmlWriterUtil.writeComment( xmlWriter, "hello", 2 );
        writer.close();
        StringBuffer sb = new StringBuffer();
        sb.append( indent );
        sb.append( "<!-- hello                                                                  -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == XmlWriterUtil.DEFAULT_COLUMN_LINE - 1 + XmlWriterUtil.LS.length() + 2
            * XmlWriterUtil.DEFAULT_INDENTATION_SIZE );

        tearDown();
        setUp();

        XmlWriterUtil.writeComment( xmlWriter, "hello\nworld", 2 );
        writer.close();
        sb = new StringBuffer();
        sb.append( indent );
        sb.append( "<!-- hello                                                                  -->" ).append( XmlWriterUtil.LS );
        sb.append( indent );
        sb.append( "<!-- world                                                                  -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == 2 * ( XmlWriterUtil.DEFAULT_COLUMN_LINE - 1 + XmlWriterUtil.LS.length() ) + 2 * indent.length() );
    }

#end
#end
#No. 188287
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeComment(org.codehaus.plexus.util.xml.XMLWriter, java.lang.String, int, int)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentXMLWriterStringIntInt()
        throws Exception
    {
        String repeat = StringUtils.repeat( " ", 2 * 4 );

        XmlWriterUtil.writeComment( xmlWriter, "hello", 2, 4 );
        writer.close();
        StringBuffer sb = new StringBuffer();
        sb.append( repeat );
        sb.append( "<!-- hello                                                                  -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == XmlWriterUtil.DEFAULT_COLUMN_LINE - 1 + XmlWriterUtil.LS.length() + 2 * 4 );

        tearDown();
        setUp();

        XmlWriterUtil.writeComment( xmlWriter, "hello\nworld", 2, 4 );
        writer.close();
        sb = new StringBuffer();
        sb.append( repeat );
        sb.append( "<!-- hello                                                                  -->" ).append( XmlWriterUtil.LS );
        sb.append( repeat );
        sb.append( "<!-- world                                                                  -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == 2 * ( XmlWriterUtil.DEFAULT_COLUMN_LINE - 1 + XmlWriterUtil.LS.length() ) + 2 * repeat.length() );
    }

#end
#end
#No. 188288
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeComment(org.codehaus.plexus.util.xml.XMLWriter, java.lang.String, int, int, int)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentXMLWriterStringIntIntInt()
        throws Exception
    {
        String indent = StringUtils.repeat( " ", 2 * 4 );

        XmlWriterUtil.writeComment( xmlWriter, "hello", 2, 4, 50 );
        writer.close();
        StringBuffer sb = new StringBuffer();
        sb.append( indent );
        sb.append( "<!-- hello                                    -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == 50 - 1 + XmlWriterUtil.LS.length() + 2 * 4 );

        tearDown();
        setUp();

        XmlWriterUtil.writeComment( xmlWriter, "hello", 2, 4, 10 );
        writer.close();
        sb = new StringBuffer();
        sb.append( indent );
        sb.append( "<!-- hello -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() >= 10 + 2 * 4 );
    }

#end
#end
#No. 188289
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeCommentText(org.codehaus.plexus.util.xml.XMLWriter, java.lang.String, int)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentTextXMLWriterStringInt()
        throws Exception
    {
        XmlWriterUtil.writeCommentText( xmlWriter, "hello", 0 );
        writer.close();
        StringBuffer sb = new StringBuffer();
        sb.append( XmlWriterUtil.LS );
        sb.append( "<!-- ====================================================================== -->" ).append( XmlWriterUtil.LS );
        sb.append( "<!-- hello                                                                  -->" ).append( XmlWriterUtil.LS );
        sb.append( "<!-- ====================================================================== -->" ).append( XmlWriterUtil.LS );
        sb.append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == 3 * ( 80 - 1 + XmlWriterUtil.LS.length() ) + 2 * XmlWriterUtil.LS.length() );

        tearDown();
        setUp();

        String indent = StringUtils.repeat( " ", 2 * 2 );

        XmlWriterUtil.writeCommentText( xmlWriter, "hello world with end of line\n and "
            + "loooooooooooooooooooooooooooooooooooooooooooooooooooooonnnnnnnnnnong line", 2 );
        writer.close();
        sb = new StringBuffer();
        sb.append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- ====================================================================== -->" )
            .append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- hello world with end of line                                           -->" )
            .append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- and                                                                    -->" )
            .append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- loooooooooooooooooooooooooooooooooooooooooooooooooooooonnnnnnnnnnong   -->" )
            .append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- line                                                                   -->" )
            .append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- ====================================================================== -->" )
            .append( XmlWriterUtil.LS );
        sb.append( XmlWriterUtil.LS );
        sb.append( indent );
        assertEquals( output.toString(), sb.toString() );
    }

#end
#end
#No. 188290
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeCommentText(org.codehaus.plexus.util.xml.XMLWriter, java.lang.String, int, int)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentTextXMLWriterStringIntInt()
        throws Exception
    {
        String indent = StringUtils.repeat( " ", 2 * 4 );

        XmlWriterUtil.writeCommentText( xmlWriter, "hello", 2, 4 );
        writer.close();
        StringBuilder sb = new StringBuilder();
        sb.append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- ====================================================================== -->" )
            .append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- hello                                                                  -->" )
            .append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- ====================================================================== -->" )
            .append( XmlWriterUtil.LS );
        sb.append( XmlWriterUtil.LS );
        sb.append( indent );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == 3 * ( 80 - 1 + XmlWriterUtil.LS.length() ) + 4 * 2 * 4 + 2 * XmlWriterUtil.LS.length() );
    }

#end
#end
#No. 188291
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeCommentText(org.codehaus.plexus.util.xml.XMLWriter, java.lang.String, int, int, int)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentTextXMLWriterStringIntIntInt()
        throws Exception
    {
        String indent = StringUtils.repeat( " ", 2 * 4 );

        XmlWriterUtil.writeCommentText( xmlWriter, "hello", 2, 4, 50 );
        writer.close();
        StringBuilder sb = new StringBuilder();
        sb.append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- ======================================== -->" ).append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- hello                                    -->" ).append( XmlWriterUtil.LS );
        sb.append( indent ).append( "<!-- ======================================== -->" ).append( XmlWriterUtil.LS );
        sb.append( XmlWriterUtil.LS );
        sb.append( indent );
        assertEquals( output.toString(), sb.toString() );
        assertTrue( output.toString().length() == 3 * ( 50 - 1 + XmlWriterUtil.LS.length() ) + 4 * 2 * 4 + 2 * XmlWriterUtil.LS.length() );
    }

#end
#end
#No. 188292
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeComment(org.codehaus.plexus.util.xml.XMLWriter, java.lang.String)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentNull()
        throws Exception
    {
        XmlWriterUtil.writeComment( xmlWriter, null );
        writer.close();
        StringBuilder sb = new StringBuilder();
        sb.append( "<!-- null                                                                   -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
    }

#end
#end
#No. 188293
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeComment(org.codehaus.plexus.util.xml.XMLWriter, java.lang.String)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentShort()
        throws Exception
    {
        XmlWriterUtil.writeComment( xmlWriter, "This is a short text" );
        writer.close();
        StringBuilder sb = new StringBuilder();
        sb.append( "<!-- This is a short text                                                   -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
    }

#end
#end
#No. 188294
#File: E:\bishe\1\XmlWriterUtilTest.java
#Comment:
    /**
     * Test method for {@link org.codehaus.plexus.util.xml.XmlWriterUtil#writeComment(org.codehaus.plexus.util.xml.XMLWriter, java.lang.String)}.
     *
     * @throws Exception if any
     */

#Code:
    public void testWriteCommentLong()
        throws Exception
    {
        XmlWriterUtil.writeComment( xmlWriter, "Maven is a software project management and comprehension tool. "
            + "Based on the concept of a project object model (POM), Maven can manage a project's build, reporting "
            + "and documentation from a central piece of information." );
        writer.close();
        StringBuilder sb = new StringBuilder();
        sb.append( "<!-- Maven is a software project management and comprehension tool. Based   -->" ).append( XmlWriterUtil.LS );
        sb.append( "<!-- on the concept of a project object model (POM), Maven can manage a     -->" ).append( XmlWriterUtil.LS );
        sb.append( "<!-- project's build, reporting and documentation from a central piece of   -->" ).append( XmlWriterUtil.LS );
        sb.append( "<!-- information.                                                           -->" ).append( XmlWriterUtil.LS );
        assertEquals( output.toString(), sb.toString() );
    }

#end
#end
#No. 188295
#File: E:\bishe\1\XmppAccountManager.java
#Comment:
    /**
     * Tries to create a new account with help of XMPP in-band registration
     * and DNS SRV Records of the server.
     * Returns the XMPPConnection on success, 
     * otherwise throws an XMPPException
     * 
     * @param jid
     * @param host
     * @param password
     * @return
     * @throws XMPPException
     */

#Code:
    public static XMPPConnection tryToCreateAccount(String username, String host, String password) throws XMPPException {
        username = needsDomainPart(username, host);
        
        // TODO throws NetworkOnMainThreadException on Honycomb or higher
        // Fix it!
        ConnectionConfiguration conf = new AndroidConnectionConfiguration(host);
        XMPPConnection connection = new XMPPConnection(conf);
        connection.connect();
        AccountManager accManager = new AccountManager(connection);
        if(!accManager.supportsAccountCreation()) {
            throw new XMPPException("Server does not support account creation");
        }
        accManager.createAccount(username, password);

        return connection;
    }

#end
#end
#No. 188296
#File: E:\bishe\1\XmppAccountManager.java
#Comment:
    /**
     * Tries to return the correct username for the given host.
     * 
     * Some XMPP service provider (like gTalk) require the username
     * to be concatenated with the host part
     * e.g. user -> user@server.tld
     * 
     * @param username
     * @param host
     * @return
     */

#Code:
    private static String needsDomainPart(String username, String host) {
        for (String s : USERNAME_IS_FULL_JID) {
            if (host.equals(s)) {
                return username + "@" + host;
            }
        }
        return username;
    }

#end
#end
#No. 188297
#File: E:\bishe\1\XmppAccountManager.java
#Comment:
    /**
     * Writes the given minimal settings to the shared preferences.
     * The jid needs to be in the form of user@server.tld
     * because smack will do automatic DNS SRV lookups on server.tld
     * to find the right XMPP server
     * 
     * @param jid
     * @param password
     * @param settings
     */

#Code:
    public static void savePreferences(String jid, String password, String notifiedAddress, SettingsManager settings) {
        Editor editor = settings.getEditor();
        boolean useDifferentAccount;
        
        editor.putString("notifiedAddress", notifiedAddress);
        editor.putString("xmppSecurityMode", "opt");
        editor.putBoolean("useCompression", false);
        editor.putBoolean("manuallySpecifyServerSettings", true);
        editor.putString("login", jid);
        editor.putString("password", password);
        
        if (jid.equals(notifiedAddress)) {
            useDifferentAccount = false;
        } else {
            useDifferentAccount = true;
        }
        editor.putBoolean("useDifferentAccount", useDifferentAccount);
        
        editor.commit();
    }

#end
#end
#No. 188298
#File: E:\bishe\1\XmppAccountManager.java
#Comment:
    /**
     * Tries to make a connection. If successful returns this connection and 
     * saves the settings. If jid == notifiedAddress, same account mode is
     * assumed.
     * Throws an XMPPException on error.
     * 
     * @param jid
     * @param password
     * @param notifiedAddress
     * @param settings
     * @return
     * @throws XMPPException 
     */

#Code:
    public static XMPPConnection makeConnectionAndSavePreferences(String jid, String password, String notifiedAddress, SettingsManager settings) throws XMPPException {
        String domain = StringUtils.parseServer(jid);
        
        // TODO throws NetworkOnMainThreadException on Honeycomb or higher
        // Fix it!
        ConnectionConfiguration config = new AndroidConnectionConfiguration(domain);
        XMPPConnection con = new XMPPConnection(config);
        con.connect();
        con.login(jid, password);
        // looks like we have successfully established a connection
        // save the settings
        savePreferences(jid, password, notifiedAddress, settings);
        return con;
    }

#end
#end
#No. 188299
#File: E:\bishe\1\XmppBuddies.java
#Comment:
    /**
     * retrieves the current xmpp rooster
     * and sends a broadcast ACTION_XMPP_PRESENCE_CHANGED
     * for every friend
     * does nothing if we are offline
     * 
     * @return
     */

#Code:
    public ArrayList<XmppFriend> retrieveFriendList() {
        
        ArrayList<XmppFriend> friends = new ArrayList<XmppFriend>();

        if (sConnection != null && sConnection.isAuthenticated()) {
            try {
                String userID = null;
                String status = null;
                Roster roster = sConnection.getRoster();

                for (RosterEntry r : roster.getEntries()) {
                    userID = r.getUser();
                    status = retrieveStatusMessage(userID);
                    friends.add(new XmppFriend(userID, r.getName(), status, retrieveState(userID)));
                }

                sendFriendList(friends);
            } catch (Exception ex) {
                GoogleAnalyticsHelper.trackAndLogWarning("Failed to retrieve Xmpp Friend list", ex);
            }
        }
        
        return friends;
    }

#end
#end
#No. 188300
#File: E:\bishe\1\XmppBuddies.java
#Comment:
    /**
     * sends an XMPP_PRESENCE_CHANGED intent for every known xmpp rooster item (friend)
     * with the actual status information
     * 
     * @param list
     */

#Code:
    public void sendFriendList(ArrayList<XmppFriend> list) {
        
        for (XmppFriend xmppFriend : list) {
            Intent intent = new Intent(MainService.ACTION_XMPP_PRESENCE_CHANGED);
            intent.putExtra("userid", xmppFriend.mId);
            intent.putExtra("name", xmppFriend.mName == null ? xmppFriend.mId : xmppFriend.mName);
            intent.putExtra("status", xmppFriend.mStatus);
            intent.putExtra("state", xmppFriend.mState);
            sContext.sendBroadcast(intent);
        }
    }

#end
#end
#No. 188301
#File: E:\bishe\1\XmppBuddies.java
#Comment:
    /**
     * returns the status message for a given bare or full JID
     * 
     * @param userID
     * @return
     */

#Code:
    public String retrieveStatusMessage(String userID) {
        String userStatus = ""; // default return value

        try {
            userStatus = sConnection.getRoster().getPresence(userID).getStatus();
        } catch (NullPointerException e) {
            GoogleAnalyticsHelper.trackAndLogError("Invalid connection or user in retrieveStatus() - NPE");
            userStatus = "";
        }
        // Server may set their status to null; we want empty string
        if (userStatus == null) {
            userStatus = "";
        }

        return userStatus;
    }

#end
#end
#No. 188302
#File: E:\bishe\1\XmppBuddies.java
#Comment:
    /**
     * Maps the smack internal userMode enums into our int status mode flags
     * 
     * @param userMode
     * @param isOnline
     * @return
     */

#Code:
    // TODO do we need the isOnline boolean?
    // Mode.available should be an equivalent
    public int retrieveState(Mode userMode, boolean isOnline) {
        int userState = XmppFriend.OFFLINE; // default return value
        
        if (userMode == Mode.dnd) {
            userState = XmppFriend.BUSY;
        } else if (userMode == Mode.away
                || userMode == Mode.xa) {
            userState = XmppFriend.AWAY;
        } else if (isOnline) {
            userState = XmppFriend.ONLINE;
        }

        return userState;
    }

#end
#end
#No. 188303
#File: E:\bishe\1\XmppBuddies.java
#Comment:
    /**
     * Checks if the notification address is available
     * return also true if no roster is loaded
     * @return
     */

#Code:
    public boolean isNotificationAddressAvailable() {
        if (sRoster != null) {
            // getPresence retrieves eventually the status of the notified Address in an internal data structure cache
            // thus avoiding an extra data packet
            Presence presence = sRoster.getPresence(sSettings.notifiedAddress);
            return presence.isAvailable();
        }
        return true;
    }

#end
#end
#No. 188304
#File: E:\bishe\1\XmppBuddies.java
#Comment:
    /**
     * grants the given JID the subscription (e.g. viewing your online state)
     * 
     * @param jid
     * @param connection
     */

#Code:
    public static void grantSubscription(String jid, XMPPConnection connection) {
        Presence presence = new Presence(Presence.Type.subscribed);
        sendPresenceTo(jid, presence, connection);
    }

#end
#end
#No. 188305
#File: E:\bishe\1\XmppBuddies.java
#Comment:
    /**
     * request the subscription from a given JID
     * 
     * @param jid
     * @param connection
     */

#Code:
    public static void requestSubscription(String jid, XMPPConnection connection) {
        Presence presence = new Presence(Presence.Type.subscribe);
        sendPresenceTo(jid, presence, connection);
    }

#end
#end
#No. 188306
#File: E:\bishe\1\XmppChatPacketListener.java
#Comment:
	/**
	 * @return the otrMgr
	 */

#Code:
	public OtrChatManager getOtrMgr() {
		return otrMgr;
	}

#end
#end
#No. 188307
#File: E:\bishe\1\XmppChatPacketListener.java
#Comment:
	/**
	 * @param otrMgr the otrMgr to set
	 */

#Code:
	public void setOtrMgr(OtrChatManager otrMgr) {
		this.otrMgr = otrMgr;
		
	}

#end
#end
#No. 188312
#File: E:\bishe\1\XmppFileManager.java
#Comment:
    /**
     * returns the FileTransferManager for the current connection
     * 
     * @return
     */

#Code:
    public FileTransferManager getFileTransferManager() {
        return mFileTransferManager;
    }

#end
#end
#No. 188313
#File: E:\bishe\1\XmppMsg.java
#Comment:
    /**
     * Adds the Strings in the given Arrary to the XmppMsg
     * One String per line
     * 
     * @param s
     */

#Code:
    public final void addStringArray(String[] s) {
        for(String line : s) {
            this.appendLine(line);
        }
    }

#end
#end
#No. 188314
#File: E:\bishe\1\XmppMsg.java
#Comment:
    /**
     * Returns the smallest indexposition of a internal string format tag
     * @param msg
     * @return smallest indexposition, -1 if no more tags were found
     */

#Code:
    private static int getTagPos(StringBuilder msg) {
        int newline = msg.indexOf("\n");
        int boldbeg = msg.indexOf(BOLD_BEGIN);
        int boldend = msg.indexOf(BOLD_END);
        int italbeg = msg.indexOf(ITALIC_BEGIN);
        int italend = msg.indexOf(ITALIC_END);
        int fontbeg = msg.indexOf(FONT_BEGIN);  //there is no font end tag, so just treat every fontbegin as the end of the previous font
        
        //if all int's are -1 we found no tag
        if(-1 == newline && -1 == boldbeg && -1 == boldend && -1 == italbeg && -1 == italend && -1 == fontbeg) {
            return -1;
        } else {
            return Tools.getMinNonNeg(newline, boldbeg, boldend, italbeg, italend, fontbeg);
        }
    }

#end
#end
#No. 188315
#File: E:\bishe\1\XmppMsg.java
#Comment:
    /**
     * If the last char in a given string is newline,
     * return a string without the newline as last char
     * 
     * @param str
     * @return
     */

#Code:
    private static String removeLastNewline(String str) {
        int strlen = str.length();
        if (strlen == 0) {
            return str;
        }
        
        int lastNewline = str.lastIndexOf("\n");
        if (strlen == lastNewline + 1) {
            return str.substring(0, strlen-1);            
        } else {
            return str;
        }
    }

#end
#end
#No. 188316
#File: E:\bishe\1\XmppMuc.java
#Comment:
    /**
     * Writes a message to a room and creates the room if necessary,
     * followed by an invite to the default notification address 
     * to join the room
     * 
     * @param number
     * @param contact
     * @param message
     * @throws XMPPException
     */

#Code:
    public void writeRoom(String number, String contact, String message, int mode) throws XMPPException {
        writeRoom(number, contact, new XmppMsg(message), mode);
    }

#end
#end
#No. 188317
#File: E:\bishe\1\XmppMuc.java
#Comment:
    /**
     * Writes a formated message to a room and creates the room if necessary,
     * followed by an invite to the default notification address 
     * to join the room
     * 
     * @param number
     * @param contact
     * @param message
     * @throws XMPPException
     */

#Code:
    public void writeRoom(String number, String contact, XmppMsg message, int mode) throws XMPPException {
        MultiUserChat muc;
        muc = inviteRoom(number, contact, mode);
        if (muc != null) {
            try {
                Message msg = new Message(muc.getRoom());
                msg.setBody(message.generateFmtTxt());
                if (mode == MODE_SHELL) {
                    XHTMLManager.addBody(msg, message.generateXHTMLText().toString());
                }
                msg.setType(Message.Type.groupchat);
                muc.sendMessage(msg);
            } catch (Exception e) {
                muc.sendMessage(message.generateTxt());
            }
        }
    }

#end
#end
#No. 188318
#File: E:\bishe\1\XmppMuc.java
#Comment:
    /**
     * Invites the user to a room for the given contact name and number
     * if the user (or someone else) writes to this room, a SMS is send to the number
     * 
     * @param number
     * @param mName
     * @return true if successful, otherwise false
     * @throws XMPPException 
     */

#Code:
	public MultiUserChat inviteRoom(String number, String contact, int mode)
			throws XMPPException {
		MultiUserChat muc;
		if (!mRooms.containsKey(number)) {
			muc = createRoom(number, contact, mode);
			mRooms.put(number, muc);

		} else {
			muc = mRooms.get(number);
			// TODO: test if occupants contains also the sender (in case we
			// invite other people)
			if (muc != null && muc.getOccupantsCount() < 2) {
				muc.invite(mSettings.notifiedAddress, "SMS conversation with "
						+ contact);
			}
		}
		return muc;
	}   

#end
#end
#No. 188319
#File: E:\bishe\1\XmppMuc.java
#Comment:
    /**
     * Checks if a room for the specific number
     * 
     * @param number
     * @param contact
     * @return true if the room exists and gtalksms is in it, otherwise false
     */

#Code:
    public boolean roomExists(String number) {
    	return mRooms.containsKey(number);
    }    

#end
#end
#No. 188320
#File: E:\bishe\1\XmppMuc.java
#Comment:
    /**
     * Returns the MultiUserChat given in roomname, 
     * which is a full JID (e.g. room@conference.jabber.com),
     * if the room is in your internal data structure.
     * Otherwise null will be returned
     * 
     * 
     * @param roomname - the full roomname as JID
     * @return the room or null
     */

#Code:
    public MultiUserChat getRoomViaRoomName(String roomname) {
        Collection<MultiUserChat> mucSet = mRooms.values();
        for(MultiUserChat muc : mucSet) {
            if(muc.getRoom().equals(roomname)) {
                return muc;
            }
        }
        return null;
    }

#end
#end
#No. 188321
#File: E:\bishe\1\XmppMuc.java
#Comment:
    /**
     * leaves the muc and deletes its record from the db
     * 
     * @param muc
     */

#Code:
    private void leaveRoom(MultiUserChat muc) {
		mMucHelper.deleteMUC(muc.getRoom());
		if (muc.isJoined())
			muc.leave();

		if (mRooms.size() > 0) {
			Integer i = getRoomInt(muc.getRoom());
			String number = mMucHelper.getNumber(muc.getRoom());
			mRoomNumbers.remove(i);
			mRooms.remove(number);
		}
    }

#end
#end
#No. 188322
#File: E:\bishe\1\XmppMuc.java
#Comment:
    /**
     * Returns the RoomInfo if the room exits
     * Allows an simple check for existence of a room
     * 
     * @param room
     * @return the roomInfo or null
     */

#Code:
    private RoomInfo getRoomInfo(String room) {
    	RoomInfo info;
    	try {
    		info = MultiUserChat.getRoomInfo(mConnection, room);
    	} catch (XMPPException e) {
    		return null;
    	}
    	return info;
    }

#end
#end
#No. 188323
#File: E:\bishe\1\XmppMuc.java
#Comment:
    /**
     * Checks if we are in this list of Affiliates
     * 
     * @param affCol
     * @return
     */

#Code:
    private boolean affilateCheck(Collection<Affiliate> affCol) {
    	Set<String> jids = new HashSet<String>();
    	for (Affiliate a : affCol) {
    		jids.add(a.getJid());
    	}
    	return jids.contains(mSettings.login);    	
    }

#end
#end
#No. 188324
#File: E:\bishe\1\XmppMuc.java
#Comment:
    /**
     * Extracts the room random integer from the room JID
     * 
     * @param room
     * @return
     */

#Code:
    private Integer getRoomInt(String room) {
    	int intEnd = room.indexOf("_", ROOM_START_TAG_LENGTH);
    	return new Integer(room.substring(ROOM_START_TAG_LENGTH, intEnd));    	
    }

#end
#end
#No. 188325
#File: E:\bishe\1\XmppMuc.java
#Comment:
    /**
     * creates a formated string from number and contact
     * 
     * @param number
     * @param contact
     * @return
     */

#Code:
    private static String getRoomString(String number, String contact) {
        return contact + " (" + number + ")";
    }

#end
#end
#No. 188327
#File: E:\bishe\1\XmppParser.java
#Comment:
    /**
     * The method called when a tag is ended in the stream comming from the
     * server.
     *
     * @param name The name of the tag that has just ended.
     * @throws XMLException 
     * @throws IOException 
     * @throws XmppException 
     */

#Code:
    
    public void tagEnd(String name) throws XMLException {
        
        ArrayList<XmppObject> childs=currentBlock.getChildBlocks();
        if (childs!=null) childs.trimToSize();

        XmppObject parent = currentBlock.getParent();
        if (parent == null) {
            dispatchXmppStanza(currentBlock);
        }  else
            parent.addChild( currentBlock );
        currentBlock = parent;
    }

#end
#end
#No. 188328
#File: E:\bishe\1\XmppParser.java
#Comment:
    /**
     * Method called when an XML tag is started in the stream comming from the
     * server.
     *
     * @param name Tag name.
     * @param attributes The tags attributes.
     */

#Code:
    
    public boolean tagStart(String name, Attributes attributes) {
        if (currentBlock != null)
        	
            currentBlock = new XmppObject(name, currentBlock, attributes);
            
        else  if (name.equals( "message" ) )
            currentBlock = new XmppMessage(currentBlock, attributes);
        else    if (name.equals("iq") ) 
            currentBlock = new Iq(currentBlock, attributes); 
        else    if (name.equals("presence") ) 
            currentBlock = new XmppPresence(currentBlock, attributes); 
        else    if (name.equals("xml") )
            return false; 
        else
        	//TODO: stub for incorrect stanza
        	currentBlock = new XmppObject(name, null, attributes);
        
        return false;
    }

#end
#end
#No. 188331
#File: E:\bishe\1\XmppPresence.java
#Comment:
  /**
   * Default constructor for outgoing presence messages.
   */

#Code:

  public XmppPresence(String to, String type){
      super(null,null);
      setAttribute("to",to);
      setAttribute("type",type);
  };



#end
#end
#No. 188333
#File: E:\bishe\1\XmppPresenceStatus.java
#Comment:
    /**
     * Sets the XMPP presence status, but only if
     * - we are connected
     * - the notification address is online
     * 
     * @param force - don't check if the notification address is online
     * @return true if the presence was set
     */

#Code:
     private boolean setStatus(boolean force) {
        if ((mXmppBuddies.isNotificationAddressAvailable() || force) 
                && (mConnection != null && mConnection.isAuthenticated())) {
            Presence presence = new Presence(Presence.Type.available);
            presence.setStatus(composePresenceStatus());
            presence.setPriority(24);
            mConnection.sendPacket(presence);
            return true;
        } else {
            return false;
        }
    }   
#end
#end
#No. 188334
#File: E:\bishe\1\XmpPropertyType.java
#Comment:
/**
 * List the basic types of xmp properties
 */

#Code:
public enum XmpPropertyType {
	Text, Date, Integer, Boolean, Real
}

#end
#end
#No. 188335
#File: E:\bishe\1\XmppSaslException.java
#Comment:
	/**
	 * 
	 * @param saslError
	 */

#Code:
	public XmppSaslException(SaslError saslError) {
		super();
		this.saslError = saslError;
	}

#end
#end
#No. 188336
#File: E:\bishe\1\XmppSaslException.java
#Comment:
	/**
	 *
	 * @param saslError
	 * @param detail
	 */

#Code:
	public XmppSaslException(SaslError saslError, String detail) {
		super(detail);
		this.saslError = saslError;
	}

#end
#end
#No. 188337
#File: E:\bishe\1\XmppSaslException.java
#Comment:
	/**
	 *
	 * @return
	 */

#Code:
	public String getSaslErrorElementName() {
		return saslError == null ? null : saslError.getElementName();
	}

#end
#end
#No. 188338
#File: E:\bishe\1\XmppService.java
#Comment:
    /**
     * Show a notification while this service is running.
     */

#Code:
    private void showNotification(boolean online) {
    	Lime.getInstance().notificationMgr().showOnlineNotification(online);    
    }



#end
#end
#No. 188340
#File: E:\bishe\1\XmppTools.java
#Comment:
    /**
     * Returns true if a JID in the format
     * user@server.tld is given. 
     * Note: ATM this method checks only if an "@" exists in the string
     * but no "/"
     * 
     * @param jid
     * @return
     */

#Code:
    public static boolean isValidJID(String jid) {
        if (jid.contains("/") || !jid.contains("@")) {
            return false;
        }

#end
#end
#No. 188341
#File: E:\bishe\1\XmppTools.java
#Comment:
    /**
     * Basic check that servername is valid FQDN.
     * Currently checks that there is one one or more dots and that
     * the String does not start or end with an dot
     * 
     * @param servername
     * @return
     */

#Code:
    public static boolean isValidServername(String servername) {
        int len = servername.length();
        int LastPosOfDot = servername.lastIndexOf('.');
        int FirstPosOfDot = servername.indexOf('c');
        if (len < 3 ||
                LastPosOfDot == -1 ||               
                LastPosOfDot == len-1 ||
                FirstPosOfDot == 0) {
            return false;
        }
        return true;
    }

#end
#end
#No. 188342
#File: E:\bishe\1\XMPPTransport.java
#Comment:
		/**
		 * @param exception
		 */

#Code:
		protected void onException( Throwable exception ) {
			// By default, do nothing.
		}

#end
#end
#No. 188343
#File: E:\bishe\1\XMPSchemaTest.java
#Comment:
	/**
	 * Check if Bag (Unordered Array) management is ok
	 * 
	 * @throws InappropriateTypeException
	 */

#Code:
	@Test
	public void testBagManagement() throws Exception {
		String bagName = "nsSchem:BAGTEST";
		String value1 = "valueOne";
		String value2 = "valueTwo";
		schem.addBagValue(bagName, new TextType(parent, "rdf", "li", value1));
		schem.addBagValue(bagName, value2);

		List<String> values = schem.getBagValueList(bagName);
		Assert.assertEquals(value1, values.get(0));
		Assert.assertEquals(value2, values.get(1));

		schem.removeBagValue(bagName, value1);
		List<String> values2 = schem.getBagValueList(bagName);
		Assert.assertEquals(1, values2.size());
		Assert.assertEquals(value2, values2.get(0));

		/*
		 * System.out.println("Bag Management :");
		 * parent.getFuturOwner().appendChild(schem.getElement()); try {
		 * XMLUtil.save(parent.getFuturOwner(), System.out, "UTF-8"); } catch
		 * (TransformerException e) {
		 * 
		 * e.printStackTrace(); } System.out.println("------------------");
		 */

	}

#end
#end
#No. 188344
#File: E:\bishe\1\XMPSchemaTest.java
#Comment:
	/**
	 * Check if Seq (Ordered Array) management is ok
	 * 
	 * @throws InappropriateTypeException
	 * @throws IOException
	 */

#Code:
	@Test
	public void testSeqManagement() throws Exception {
		Calendar date = Calendar.getInstance();
		BooleanType bool = new BooleanType(parent, "rdf", "li", "True");
		String textVal = "seqValue";
		String seqName = "nsSchem:SEQNAME";

		schem.addSequenceDateValue(seqName, date);
		schem.addSequenceValue(seqName, bool);
		schem.addSequenceValue(seqName, textVal);

		List<Calendar> dates = schem.getSequenceDateValueList(seqName);
		Assert.assertEquals(1, dates.size());
		Assert.assertEquals(date, dates.get(0));

		List<String> values = schem.getSequenceValueList(seqName);
		Assert.assertEquals(3, values.size());
		Assert.assertEquals(DateConverter.toISO8601(date), values.get(0));
		Assert.assertEquals(bool.getStringValue(), values.get(1));
		Assert.assertEquals(textVal, values.get(2));

		/*
		 * System.out.println("Seq Management :");
		 * parent.getFuturOwner().appendChild(schem.getElement()); try {
		 * XMLUtil.save(parent.getFuturOwner(), System.out, "UTF-8"); } catch
		 * (TransformerException e) {
		 * 
		 * e.printStackTrace(); } System.out.println("------------------");
		 */

		schem.removeSequenceDateValue(seqName, date);
		Assert.assertEquals(0, schem.getSequenceDateValueList(seqName).size());

		schem.removeSequenceValue(seqName, bool);
		schem.removeSequenceValue(seqName, textVal);

		Assert.assertEquals(0, schem.getSequenceValueList(seqName).size());
	}


#end
#end
#No. 188346
#File: E:\bishe\1\XMultiColumnListView.java
#Comment:
    /**
     * Enable or disable pull down refresh feature.
     *
     * @param enable
     */

#Code:
    public void setPullRefreshEnable(boolean enable) {
        mEnablePullRefresh = enable;

        // disable, hide the content
        mHeaderContent.setVisibility(enable ? View.VISIBLE : View.INVISIBLE);
    }

#end
#end
#No. 188347
#File: E:\bishe\1\XMultiColumnListView.java
#Comment:
    /**
     * Enable or disable pull up load more feature.
     *
     * @param enable
     */

#Code:
    public void setPullLoadEnable(boolean enable) {
        mEnablePullLoad = enable;

        if (!mEnablePullLoad) {
            mFooterView.setBottomMargin(0);
            mFooterView.hide();
            mFooterView.setPadding(0, 0, 0, 0);
            mFooterView.setOnClickListener(null);

        } else {
            mPullLoading = false;
            mFooterView.setPadding(0, 0, 0, 0);
            mFooterView.show();
            mFooterView.setState(XFooterView.STATE_NORMAL);
            // both "pull up" and "click" will invoke load more.
            mFooterView.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    startLoadMore();
                }
            });
        }
    }

#end
#end
#No. 188348
#File: E:\bishe\1\XMultiColumnListView.java
#Comment:
    /**
     * Enable or disable auto load more feature when scroll to bottom.
     *
     * @param enable
     */

#Code:
    public void setAutoLoadEnable(boolean enable) {
        mEnableAutoLoad = enable;
    }

#end
#end
#No. 188349
#File: E:\bishe\1\XMultiColumnListView.java
#Comment:
    /**
     * Stop refresh, reset header view.
     */

#Code:
    public void stopRefresh() {
        if (mPullRefreshing) {
            mPullRefreshing = false;
            resetHeaderHeight();
        }
    }

#end
#end
#No. 188350
#File: E:\bishe\1\XMultiColumnListView.java
#Comment:
    /**
     * Stop load more, reset footer view.
     */

#Code:
    public void stopLoadMore() {
        if (mPullLoading) {
            mPullLoading = false;
            mFooterView.setState(XFooterView.STATE_NORMAL);
        }
    }

#end
#end
#No. 188351
#File: E:\bishe\1\XMultiColumnListView.java
#Comment:
    /**
     * Set last refresh time
     *
     * @param time
     */

#Code:
    public void setRefreshTime(String time) {
        mHeaderTime.setText(time);
    }

#end
#end
#No. 188352
#File: E:\bishe\1\XMultiColumnListView.java
#Comment:
    /**
     * Set listener.
     *
     * @param listener
     */

#Code:
    public void setXListViewListener(IXListViewListener listener) {
        mListener = listener;
    }

#end
#end
#No. 188353
#File: E:\bishe\1\XMultiColumnListView.java
#Comment:
    /**
     * Auto call back refresh.
     */

#Code:
    public void autoRefresh() {
        mHeader.setVisibleHeight(mHeaderHeight);

        if (mEnablePullRefresh && !mPullRefreshing) {
            // update the arrow image not refreshing
            if (mHeader.getVisibleHeight() > mHeaderHeight) {
                mHeader.setState(XHeaderView.STATE_READY);
            } else {
                mHeader.setState(XHeaderView.STATE_NORMAL);
            }
        }

        mPullRefreshing = true;
        mHeader.setState(XHeaderView.STATE_REFRESHING);
        refresh();
    }

#end
#end
#No. 188354
#File: E:\bishe\1\XNHandlerExitStatus.java
#Comment:
/**
 * XNHandlerExitStatus specifies how a handler exited: with a
 * return, exit, pass, or next statement, or by reaching the
 * end of the statement list. If the handler exited by a
 * throw statement, an actual exception is thrown instead of
 * returning an XNHandlerExit.
 * @since OpenXION 0.9
 * @author Rebecca G. Bettencourt, Kreative Software
 */

#Code:
public enum XNHandlerExitStatus {
	/**
	 * Execution of the handler ended by executing its last instruction.
	 */
	ENDED,
	/**
	 * Execution of the handler ended with a <code>return</code> statement.
	 */
	RETURNED,
	/**
	 * Execution of the handler ended with an <code>exit</code> statement.
	 */
	EXITED,
	/**
	 * Execution of the handler ended with a <code>pass</code> statement.
	 */
	PASSED,
	/**
	 * Execution of the handler ended with a <code>next</code> statement.
	 */
	NEXTED
}


#end
#end
#No. 188360
#File: E:\bishe\1\XNSecurityValue.java
#Comment:
/**
 * XNSecurityValue represents the current security setting
 * of an area of functionality available to XION scripts.
 * @since OpenXION 1.1
 * @author Rebecca G. Bettencourt, Kreative Software
 */

#Code:
public enum XNSecurityValue {
	/**
	 * The security setting indicating that all attempts to use certain functionality should fail.
	 */
	DENY,
	/**
	 * The security setting indicating that the user should be asked when a script wants to use certain functionality.
	 */
	ASK,
	/**
	 * The security setting indicating that the script is always allowed to use certain functionality.
	 */
	ALLOW
}

#end
#end
#No. 188361
#File: E:\bishe\1\XOAIMetadata.java
#Comment:
    /**
     * @return a simple searcher that returns search results as String elements.
     */

#Code:
    public MetadataSearch<String> searcher () {
        return new MetadataSearchImpl(this);
    }




#end
#end
#No. 188364
#File: E:\bishe\1\XOManagerFactoryImpl.java
#Comment:
    /**
     * Return the {@link javax.validation.ValidatorFactory}.
     *
     * @return The {@link javax.validation.ValidatorFactory}.
     */

#Code:
    private ValidatorFactory getValidatorFactory() {
        if (!ValidationMode.NONE.equals(validationMode)) {
            try {
                return Validation.buildDefaultValidatorFactory();
            } catch (ValidationException e) {
                LOGGER.debug("No JSR 303 Bean Validation provider available.", e);
            }
        }
        return null;
    }

#end
#end
#No. 188365
#File: E:\bishe\1\XOManagerFactoryImpl.java
#Comment:
    /**
     * Return the instance of the plugin manager repository.
     *
     * @return The plugin manager repository.
     */

#Code:
    public PluginRepositoryManager getPluginRepositoryManager() {
        return pluginRepositoryManager;
    }


#end
#end
#No. 188379
#File: E:\bishe\1\XOMTreeBuilder.java
#Comment:
    /**
     * Returns the document.
     * 
     * @return the document
     */

#Code:
    Document getDocument() {
        Document rv = document;
        document = null;
        return rv;
    }

#end
#end
#No. 188380
#File: E:\bishe\1\XOMTreeBuilder.java
#Comment:
    /**
     * @see nu.validator.htmlparser.impl.TreeBuilder#createElement(String,
     *      java.lang.String, org.xml.sax.Attributes, java.lang.Object)
     */

#Code:
    @Override
    protected Element createElement(String ns, String name,
            HtmlAttributes attributes, Element form, Element intendedParent) throws SAXException {
        try {
            Element rv = nodeFactory.makeElement(name,
 ns, form);
            for (int i = 0; i < attributes.getLength(); i++) {
                rv.addAttribute(nodeFactory.makeAttribute(
                        attributes.getLocalName(i),
                        attributes.getURINoBoundsCheck(i),
                        attributes.getValueNoBoundsCheck(i),
                        attributes.getTypeNoBoundsCheck(i) == "ID" ? Attribute.Type.ID
                                : Attribute.Type.CDATA));
            }
            return rv;
        } catch (XMLException e) {
            fatal(e);
            throw new RuntimeException("Unreachable");
        }
    }

#end
#end
#No. 188381
#File: E:\bishe\1\XOMTreeBuilder.java
#Comment:
    /**
     * @see nu.validator.htmlparser.impl.TreeBuilder#start()
     */

#Code:
    @Override
    protected void start(boolean fragment) throws SAXException {
        document = nodeFactory.makeDocument();
        cachedTableIndex = -1;
        cachedTable = null;
    }

#end
#end
#No. 188382
#File: E:\bishe\1\XOMTreeBuilder.java
#Comment:
    /**
     * @see nu.validator.htmlparser.impl.TreeBuilder#documentMode(nu.validator.htmlparser.common.DocumentMode,
     *      java.lang.String, java.lang.String, boolean)
     */

#Code:
    @Override
    protected void documentMode(DocumentMode mode, String publicIdentifier,
            String systemIdentifier, boolean html4SpecificAdditionalErrorChecks)
            throws SAXException {
        if (document instanceof Mode) {
            Mode modal = (Mode) document;
            modal.setMode(mode);
        }
    }

#end
#end
#No. 188383
#File: E:\bishe\1\XOMTreeBuilder.java
#Comment:
    /**
     * @see nu.validator.htmlparser.impl.TreeBuilder#end()
     */

#Code:
    @Override protected void end() throws SAXException {
        cachedTableIndex = -1;
        cachedTable = null;
    }
}
}




#end
#end
#No. 188388
#File: E:\bishe\1\XOrGateFigure.java
#Comment:
/**
  * Constructor for XOrGateFigure.
  */

#Code:
public XOrGateFigure() {
	setBackgroundColor(LogicColorConstants.xorGate);
}

#end
#end
#No. 188389
#File: E:\bishe\1\XOrGateFigure.java
#Comment:
/**
 * @see org.eclipse.draw2d.Figure#getPreferredSize(int, int)
 */

#Code:
public Dimension getPreferredSize(int wHint, int hHint) {
	return SIZE;
}


#end
#end
#No. 188396
#File: E:\bishe\1\XOUnitParameter.java
#Comment:
/**
 * Identifiers for {@link XOUnit} configurations.
 */

#Code:
public enum XOUnitParameter {

    NAME, DESCRIPTION, URL, PROVIDER, TYPES, INSTANCE_LISTENERS, CONCURRENCY_MODE, TRANSACTION_ATTRIBUTE, VALIDATION_MODE, PROPERTIES;

    public String getKey() {
        return name().toLowerCase();
    }

}

#end
#end
#No. 188397
#File: E:\bishe\1\Xpath.java
#Comment:
/**
 * This enum is a Supplier ByXpath from Selenium By API.
 */

#Code:
public enum Xpath implements Supplier<By> {
    PARENT(".."),
    DIV_CONTAINER_ID("//div[@id='container']"),
    LOCATION("//div[@class='tools']/descendant::strong"),
    //*[@id="sbse0"]/div[2]
    GOOGLE_AUTOCOMPLETE("//*[@id='sbse0']/descendant::div"),
    QUANTITY("//div[@id='ys_cartInfo']/descendant::input[@name='cartDS.shoppingcart_ROW0_m_orderItemVector_ROW0_m_quantity']"),
    SEARCH_BUTTON("//*[@id=\"desktop-search-form\"]/div/div/span/button"),
    CART_BUTTON("//*[@id=\"primary-navbar\"]/ul[2]/li[2]/a"),
    TABLE_CONTAINER("//*[@id=\"main\"]");

    private final By by;

    Xpath(String id) {
        this.by = xpath(id);
    }

    /**
     * @return the by instance variable which is a ByXpath.
     */
    @Override
    public By get() {
        return by;
    }

    @Override
    public String toString() {
        return by.toString();
    }
}

#end
#end
#No. 188398
#File: E:\bishe\1\XPathBuilder.java
#Comment:
	/**
     * Evaluates the given xpath using the provided body as a String return type.
     *
     * @param context the camel context
     * @param body the body
     * @return result of the evaluation
     */

#Code:
    public String evaluate(String xml) {
        String answer = evaluateAs(xml);
        return answer;
    }

#end
#end
#No. 188399
#File: E:\bishe\1\XPathBuilder.java
#Comment:
    /**
     * Evaluates the expression as the given result type
     */

#Code:
    protected String evaluateAs(String xml) {
        // pool a pre compiled expression from pool
        XPathExpression xpathExpression = pool.poll();
        if (xpathExpression == null) {
        	logger.trace("Creating new XPathExpression as none was available from pool");
            // no avail in pool then create one
            try {
                xpathExpression = createXPathExpression();
            } catch (XPathExpressionException e) {
            	e.printStackTrace();
            	throw new InvalidXPathExpression(getText(), e);
            } catch (Exception e) {
                throw new InvalidXPathExpression("Cannot create xpath expression", e);
            }
        } else {
        	logger.trace("Acquired XPathExpression from pool");
        }
        try {
            return doInEvaluateAs(xpathExpression, xml);
        } finally {
            // release it back to the pool
            pool.add(xpathExpression);
            logger.trace("Released XPathExpression back to pool");
        }
    }

#end
#end
#No. 188400
#File: E:\bishe\1\XPathBuilder.java
#Comment:
    /**
     * Registers the namespace prefix and URI with the builder so that the
     * prefix can be used in XPath expressions
     *
     * @param prefix is the namespace prefix that can be used in the XPath
     *                expressions
     * @param uri is the namespace URI to which the prefix refers
     * @return the current builder
     */

#Code:
    public XPathBuilder namespace(String prefix, String uri) {
        getNamespaceContext().add(prefix, uri);
        return this;
    }

#end
#end
#No. 188401
#File: E:\bishe\1\XPathBuilder.java
#Comment:
    /**
     * Strategy method to extract the document from the exchange.
     */

#Code:
    protected Object getDocument(String xml) {
        Object answer = new InputSource(new StringReader(xml));
        return answer;
    }

#end
#end
#No. 188402
#File: E:\bishe\1\XPathBuilder.java
#Comment:
    /**
     * Lets populate a number of standard prefixes if they are not already there
     */

#Code:
    protected void populateDefaultNamespaces(DefaultNamespaceContext context) {
        setNamespaceIfNotPresent(context, "soap", SOAP_NAMESPACE);
    }

#end
#end
#No. 188403
#File: E:\bishe\1\XpathComputer.java
#Comment:
    /**
     * Returns the local Xpath string for the input node, i.e. the Xpath string
     * one would need to reach the node from its parent.
     *
     * For example, if node is the DOM node corresponding to the node
     *
     * <twig>
     *  <leaf>a</leaf>
     *  <leaf>friend</leaf>
     * </twig>
     *
     * in the tree above, XpathComputer.localXpath(node) would return
     *
     * "/twig[2]"
     *
     * @throws throws DOMException.
     * @return the local Xpath string for the input node.
     */

#Code:
    public static String localXpath (Node node) throws DOMException {
        String localname = node.getLocalName();
        if (null == localname) {
            throw  new DOMException(DOMException.NOT_FOUND_ERR, "DOM Node doesn't have a local name!");
        }
        else {
            int position = 1;
            Node current = node;
            Node previous = current.getPreviousSibling();
            while (null != previous) {
                if (localname.equals(previous.getLocalName()))
                // need to check on this because sibling nodes are not guaranteed
                // to be all of the same kind.
                {
                    position++;
                }
                current = previous;
                previous = current.getPreviousSibling();
            }
            return  localname + "[" + position + "]";
        }
    }

#end
#end
#No. 188404
#File: E:\bishe\1\XpathComputer.java
#Comment:
    /**
     * Takes a starting DOM node and a local Xpath directive and returns the DOM
     * node, if any, which can be reached following the directive from the input node
     * It throws DOMExceptions if no node exists at the specified address or if the address
     * is not a valid local Xpath expression. We repeat here that this is a very limited
     * implementation of Xpath addressing which is guaranteed to handle all and *only* those
     * Xpath expressions that could have been the output of the XpathComputer.localXpath method
     *
     * For example, if start is the DOM node corresponding to the node
     *
     * <twig>
     *  <leaf>a</leaf>
     *  <leaf>friend</leaf>
     * </twig>
     *
     * in the tree above, XpathComputer.followLocalXpath(start, "leaf[2]") would return
     * the node
     *
     * <leaf>friend</leaf>
     *
     * @throws throws DOMException.
     * @return the DOM node that is reached following the input Xpath directiv
     * starting from the input node.
     */

#Code:
    public static Node followLocalXpath (Node start, String localXpath) throws DOMException {
        String startXpath = localXpath(start);
        if (startXpath.equals(localXpath)) {
            return  start;
        }
        else {
            StringTokenizer tokenizer = new StringTokenizer(localXpath, "[]");
            if (tokenizer.countTokens() != 2) {
                String invalidXpath = localXpath + " is an invalid local Xpath!";
                throw  new DOMException(DOMException.SYNTAX_ERR, invalidXpath);
            }
            String tagname = tokenizer.nextToken();
            try {
                Integer position = new Integer(tokenizer.nextToken());
                int counter = 1;
                NodeList children = start.getChildNodes();
                for (int i = 0; i < children.getLength(); i++) {
                    Node child = children.item(i);
                    if (tagname.equals(child.getLocalName())) {
                        if (counter == position.intValue()) {
                            return  child;
                        }
                        counter++;
                    }
                }
            } catch (NumberFormatException excpt) {
                String invalidXpath = localXpath + " is an invalid local Xpath!";
                throw  new DOMException(DOMException.SYNTAX_ERR, invalidXpath);
            }
            String failed = "No node at location " + localXpath;
            throw  new DOMException(DOMException.NOT_FOUND_ERR, failed);
        }
    }

#end
#end
#No. 188405
#File: E:\bishe\1\XpathComputer.java
#Comment:
    /**
     * Returns the entire Xpath string for the input node, i.e. the Xpath string
     * one would need to reach the node from the root of the document.
     *
     * For example, if node is the DOM node corresponding to the node
     *
     *  <leaf>friend</leaf>
     *
     * in the tree above, XpathComputer.computeXpath(node) would return
     *
     * "/tree[1]/branch[2]/twig[2]/leaf[2]"
     *
     * @return the entire Xpath string for the input node.
     */

#Code:
    public static String computeXpath (Node node) {
        String Xpath = localXpath(node);
        if ("" == Xpath) {
            return  Xpath;
        }
        else {
            Node parent = node.getParentNode();
            String moreXpath;
            while (null != parent.getLocalName()) {
                moreXpath = localXpath(parent);
                Xpath = moreXpath + "/" + Xpath;
                parent = parent.getParentNode();
            }
            return  "/" + Xpath;
        }
    }

#end
#end
#No. 188406
#File: E:\bishe\1\XpathComputer.java
#Comment:
    /**
     * Takes a starting DOM node and an Xpath directive and returns the DOM
     * node, if any, which can be reached following the directive from the input node.
     * It throws DOMExceptions if no node exists at the specified address or if the address
     * is not a valid Xpath expression. We repeat here that this is a very limited
     * implementation of Xpath addressing which is guaranteed to handle all and *only* those
     * Xpath expressions that could have been the output of the XpathComputer.computeXpath method
     *
     * For example, if start is the DOM node corresponding to the root node in the tree above
     * XpathComputer.follow.LocalXpath(start, "/tree[1]/branch[3]/twig[1]leaf[2]") would return
     * the node
     *
     * <leaf>Sunday</leaf>
     *
     * @throws throws DOMException.
     * @return the DOM node that is reached following the input Xpath directive
     * starting from the input node.
     */

#Code:
    public static Node followXpath (Node start, String Xpath) throws DOMException {
        StringTokenizer tokenizer = new StringTokenizer(Xpath, "/");
        if (tokenizer.countTokens() == 0) {
            String invalidXpath = Xpath + " is an invalid Xpath!";
            throw  new DOMException(DOMException.SYNTAX_ERR, invalidXpath);
        }
        Node current = start;
        String localXpath;
        while (tokenizer.hasMoreTokens()) {
            localXpath = tokenizer.nextToken();
            current = followLocalXpath(current, localXpath);
        }
        return  current;
    }

#end
#end
#No. 188411
#File: E:\bishe\1\XPathHelper.java
#Comment:
	/**
	 * @param string
	 * @return string without the before [
	 */

#Code:
	private static String stripEndSquareBrackets(String string) {
		if (string.indexOf("[") == -1) {
			return string;
		} else {
			return string.substring(0, string.indexOf("["));
		}
	}

#end
#end
#No. 188412
#File: E:\bishe\1\XPathHelper.java
#Comment:
	/**
	 * @param dom
	 *            The dom string.
	 * @param pos
	 *            Position where to start searching.
	 * @param element
	 *            The element.
	 * @return the position where the close element is
	 */

#Code:
	public static int getCloseElementLocation(String dom, int pos, String element) {
		String[] elements = { "LINK", "META", "INPUT", "BR" };
		List<String> singleElements = Arrays.asList(elements);
		if (singleElements.contains(element.toUpperCase())) {
			return dom.indexOf(">", pos) + 1;
		}
		// make sure not before the node
		int openElements = 1;
		int i = 0;
		dom = dom.toLowerCase();
		element = element.toLowerCase();
		String openElement = "<" + element;
		String closeElement = "</" + element;
		while (i < MAX_SEARCH_LOOPS) {
			if (dom.indexOf(openElement, pos) == -1 && dom.indexOf(closeElement, pos) == -1) {
				return -1;
			}
			// System.out.println("hierzo: " + dom.substring(pos));
			if (dom.indexOf(openElement, pos) < dom.indexOf(closeElement, pos)
			        && dom.indexOf(openElement, pos) != -1) {
				openElements++;
				pos = dom.indexOf(openElement, pos) + 1;
				// System.out.println("open: " + dom.substring(pos-1));
			} else {

				openElements--;
				pos = dom.indexOf(closeElement, pos) + 1;
				// System.out.println("close: " + dom.substring(pos-1));
			}
			// System.out.println(openElements);
			if (openElements == 0) {
				break;
			}
			i++;
		}
		// System.out.println("Finished: " + dom.substring(pos-1));
		return pos - 1;

	}

#end
#end
#No. 188413
#File: E:\bishe\1\XPathHelper.java
#Comment:
	/**
	 * @param dom
	 *            The dom.
	 * @param xpath
	 *            The xpath expression.
	 * @return the position where the close element is
	 */

#Code:
	public static int getCloseElementLocation(String dom, String xpath) {
		return getCloseElementLocation(dom, getXPathLocation(dom, xpath) + 1,
		        getLastElementXPath(xpath));
	}

#end
#end
#No. 188414
#File: E:\bishe\1\XPathHelper.java
#Comment:
	/**
	 * @param xpath
	 *            The xpath expression.
	 * @return the xpath expression for only the element location. Leaves out the attributes and
	 *         text()
	 */

#Code:
	public static String stripXPathToElement(String xpath) {
		if (xpath != null && !xpath.equals("")) {
			if (xpath.toLowerCase().indexOf("/text()") != -1) {
				xpath = xpath.substring(0, xpath.toLowerCase().indexOf("/text()"));
			}
			if (xpath.toLowerCase().indexOf("/comment()") != -1) {
				xpath = xpath.substring(0, xpath.toLowerCase().indexOf("/comment()"));
			}
			if (xpath.indexOf("@") != -1) {
				xpath = xpath.substring(0, xpath.indexOf("@") - 1);
			}
		}

#end
#end
#No. 188415
#File: E:\bishe\1\XPathMatcher.java
#Comment:
	/**
	 * Returns true if the given DOM Node match the XPath expression of this
	 * XPath matcher and false otherwise.
	 * 
	 * @param node
	 *            the DOM Node to match.
	 * @return
	 */

#Code:
	public boolean match(final Node node) {
		return match(node, null);
	}

#end
#end
#No. 188416
#File: E:\bishe\1\XPathMatcher.java
#Comment:
	/**
	 * Returns list of wildcard values of the given DOM Node.
	 * 
	 * @param selectedNode
	 * @return
	 */

#Code:
	public List<String> getWildcardValues(Node selectedNode) {
		List<String> wildcardValues = new ArrayList<String>();
		if (nbWildCard == -1 || selectedNode == null) {
			// No wildcard in the XPath expression of this matcher or DOM node
			// is null
			return wildcardValues;
		}
		Node testNode = getTestNode(selectedNode);
		match(testNode, wildcardValues);
		return wildcardValues;
	}

#end
#end
#No. 188417
#File: E:\bishe\1\XPathMatcher.java
#Comment:
	/**
	 * Returns the DOM Node to test to match.
	 * 
	 * @param node
	 * @return
	 */

#Code:
	private Node getTestNode(Node node) {
		short nodeType = node.getNodeType();
		switch (nodeType) {
		case Node.ATTRIBUTE_NODE:
			return ((Attr) node).getOwnerElement();
		case Node.TEXT_NODE:
			return ((Text) node).getParentNode();
		}
		return node;
	}

#end
#end
#No. 188418
#File: E:\bishe\1\XPathMatcher.java
#Comment:
	/**
	 * Returns the number of wilcard used in the XPath expression and -1 if
	 * there is no wildcard.
	 * 
	 * @return
	 */

#Code:
	public int getNbWildCard() {
		return nbWildCard;
	}

#end
#end
#No. 188419
#File: E:\bishe\1\XPathMatcher.java
#Comment:
	/***
	 * Create XPath element matcher.
	 * 
	 * @param elementName
	 * @return
	 */

#Code:
	protected XPathElementMatcher createElementMatcher(String prefix,
			String localName) {
		XPathElementMatcher matcher = new XPathElementMatcher(prefix,
				localName, this);
		super.add(matcher);
		return matcher;
	}

#end
#end
#No. 188420
#File: E:\bishe\1\XPathMatcher.java
#Comment:
	/**
	 * Create XPath any element matcher.
	 * 
	 * @return
	 */

#Code:
	protected XPathElementMatcher createElementMatcher() {
		XPathElementMatcher matcher = new XPathElementMatcher(null,
				XPathElementMatcher.ANY_ELEMENT_NAME, this);
		super.add(matcher);
		return matcher;
	}

#end
#end
#No. 188421
#File: E:\bishe\1\XPathMatcher.java
#Comment:
	/**
	 * Create XPath attribute matcher.
	 * 
	 * @param elementmatcher
	 * @param attrName
	 * @param attrValue
	 * @return
	 */

#Code:
	protected XPathAttributeMatcher createAttributeMatcher(
			XPathElementMatcher elementmatcher, String attrName,
			String attrValue) {
		XPathAttributeMatcher matcher = new XPathAttributeMatcher(attrName,
				attrValue, this);
		elementmatcher.add(matcher);
		return matcher;
	}

#end
#end
#No. 188422
#File: E:\bishe\1\XPathNodeSetIgnoreSelectedNodeSearchVisitor.java
#Comment:
/**
 * Search visitor which execute XPath and collect the resulted nodes and ignore
 * same nodes.
 * 
 */

#Code:
public class XPathNodeSetIgnoreSelectedNodeSearchVisitor extends
		XPathNodeSetSearchVisitor {

	public static IXMLSearchDOMDocumentVisitor INSTANCE = new XPathNodeSetIgnoreSelectedNodeSearchVisitor();

	@Override
	protected boolean canAddNode(IDOMNode nodeToAdd, Object selectedNode) {
		if (selectedNode == null) {
			return true;
		}
		if (selectedNode.equals(nodeToAdd)) {
			return true;
		}
		if (!(selectedNode instanceof Node)) {
			return false;
		}
		Element element1 = DOMUtils.getOwnerElement(nodeToAdd);
		Element element2 = DOMUtils.getOwnerElement((Node) selectedNode);
		return (!(element1 != null && element1.equals(element2) || (element1 == null && element2 == null)));
	}
}

#end
#end
#No. 188423
#File: E:\bishe\1\XpathUtil.java
#Comment:
  /**
   * Returns the XPath of the parent node
   * @param xpath an XPath expression
   * @return an XPath expression of the parent
   */

#Code:
  public static String getParentPath(String xpath) {
    Objects.requireNonNull(xpath, "Xpath cannot be null");
    return xpath.substring(0, xpath.lastIndexOf('/'));
  }




#end
#end
#No. 188433
#File: E:\bishe\1\XposedBridge.java
#Comment:
    /**
     * Try to load all modules defined in <code>BASE_DIR/conf/modules.list</code>
     */

#Code:
    private static void loadModules(String startClassName) throws IOException {
        BufferedReader apks = new BufferedReader(new FileReader(BASE_DIR + "conf/modules.list"));
        String apk;
        log(">>>load modules");
        while ((apk = apks.readLine()) != null) {
            log("load modules: "+apk);
            loadModule(apk, startClassName);
        }
        log("<<<load modules");
        apks.close();
    }

#end
#end
#No. 188434
#File: E:\bishe\1\XposedBridge.java
#Comment:
    /**
     * Writes a message to the Xposed error log.
     *
     * <p>DON'T FLOOD THE LOG!!! This is only meant for error logging.
     * If you want to write information/debug messages, use logcat.
     *
     * @param text The log message.
     */

#Code:
    public synchronized static void log(String text) {
        Log.i("Xposed", text);
    }

#end
#end
#No. 188435
#File: E:\bishe\1\XposedBridge.java
#Comment:
    /**
     * Logs a stack trace to the Xposed error log.
     *
     * <p>DON'T FLOOD THE LOG!!! This is only meant for error logging.
     * If you want to write information/debug messages, use logcat.
     *
     * @param t The Throwable object for the stack trace.
     */

#Code:
    public synchronized static void log(Throwable t) {
        Log.i("Xposed", Log.getStackTraceString(t));
    }

#end
#end
#No. 188436
#File: E:\bishe\1\XposedBridge.java
#Comment:
    /**
     * Hook any method with the specified callback
     *
     * @param hookMethod The method to be hooked
     * @param callback
     */

#Code:
    public static XC_MethodHook.Unhook hookMethod(Member hookMethod, XC_MethodHook callback) {
        if (!(hookMethod instanceof Method) && !(hookMethod instanceof Constructor<?>)) {
            throw new IllegalArgumentException("Only methods and constructors can be hooked: " + hookMethod.toString());
        } else if (hookMethod.getDeclaringClass().isInterface()) {
            throw new IllegalArgumentException("Cannot hook interfaces: " + hookMethod.toString());
        } else if (Modifier.isAbstract(hookMethod.getModifiers())) {
            throw new IllegalArgumentException("Cannot hook abstract methods: " + hookMethod.toString());
        }

        boolean newMethod = false;
        CopyOnWriteSortedSet<XC_MethodHook> callbacks;
        synchronized (sHookedMethodCallbacks) {
            callbacks = sHookedMethodCallbacks.get(hookMethod);
            if (callbacks == null) {
                callbacks = new CopyOnWriteSortedSet<XC_MethodHook>();
                sHookedMethodCallbacks.put(hookMethod, callbacks);
                newMethod = true;
            }
        }
        callbacks.add(callback);
        if (newMethod) {
            Class<?> declaringClass = hookMethod.getDeclaringClass();
            // int slot = (int) getIntField(hookMethod, "slot");

            Class<?>[] parameterTypes;
            Class<?> returnType;
            if (hookMethod instanceof Method) {
                parameterTypes = ((Method) hookMethod).getParameterTypes();
                returnType = ((Method) hookMethod).getReturnType();
            } else {
                parameterTypes = ((Constructor<?>) hookMethod).getParameterTypes();
                returnType = null;
            }

            AdditionalHookInfo additionalInfo = new AdditionalHookInfo(callbacks);
            hookMethodNative(hookMethod, additionalInfo);
        }

        return callback.new Unhook(hookMethod);
    }

#end
#end
#No. 188437
#File: E:\bishe\1\XposedBridge.java
#Comment:
    /**
     * Removes the callback for a hooked method
     * @param hookMethod The method for which the callback should be removed
     * @param callback The reference to the callback as specified in {@link #hookMethod}
     */

#Code:
    public static void unhookMethod(Member hookMethod, XC_MethodHook callback) {
        CopyOnWriteSortedSet<XC_MethodHook> callbacks;
        synchronized (sHookedMethodCallbacks) {
            callbacks = sHookedMethodCallbacks.get(hookMethod);
            if (callbacks == null)
                return;
        }
        callbacks.remove(callback);
    }

#end
#end
#No. 188438
#File: E:\bishe\1\XposedBridge.java
#Comment:
    /**
     * Get notified when a package is loaded. This is especially useful to hook some package-specific methods.
     */

#Code:
    public static XC_LoadPackage.Unhook hookLoadPackage(XC_LoadPackage callback) {
        synchronized (sLoadedPackageCallbacks) {
            sLoadedPackageCallbacks.add(callback);
        }
        return callback.new Unhook();
    }

#end
#end
#No. 188439
#File: E:\bishe\1\XposedBridge.java
#Comment:
    /**
     * Get notified when the resources for a package are loaded. In callbacks, resource replacements can be created.
     * @return
     */

#Code:
    public static XC_InitPackageResources.Unhook hookInitPackageResources(XC_InitPackageResources callback) {
        synchronized (sInitPackageResourcesCallbacks) {
            sInitPackageResourcesCallbacks.add(callback);
        }
        return callback.new Unhook();
    }

#end
#end
#No. 188440
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Look up a class with the specified class loader (or the boot class loader if
     * <code>classLoader</code> is <code>null</code>).
     * <p>Class names can be specified in different formats:
     * <ul><li>java.lang.Integer
     * <li>int
     * <li>int[]
     * <li>[I
     * <li>java.lang.String[]
     * <li>[Ljava.lang.String;
     * <li>android.app.ActivityThread.ResourcesKey
     * <li>android.app.ActivityThread$ResourcesKey
     * <li>android.app.ActivityThread$ResourcesKey[]</ul>
     * <p>A {@link ClassNotFoundError} is thrown in case the class was not found.
     */

#Code:
    public static Class<?> findClass(String className, ClassLoader classLoader) {
        if (classLoader == null)
            classLoader = DexposedBridge.BOOTCLASSLOADER;
        try {
            return ClassUtils.getClass(classLoader, className, false);
        } catch (ClassNotFoundException e) {
            throw new ClassNotFoundError(e);
        }
    }

#end
#end
#No. 188441
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Look up a field in a class and set it to accessible. The result is cached.
     * If the field was not found, a {@link NoSuchFieldError} will be thrown.
     */

#Code:
    public static Field findField(Class<?> clazz, String fieldName) {
        StringBuilder sb = new StringBuilder(clazz.getName());
        sb.append('#');
        sb.append(fieldName);
        String fullFieldName = sb.toString();

        if (fieldCache.containsKey(fullFieldName)) {
            Field field = fieldCache.get(fullFieldName);
            if (field == null)
                throw new NoSuchFieldError(fullFieldName);
            return field;
        }

        try {
            Field field = findFieldRecursiveImpl(clazz, fieldName);
            field.setAccessible(true);
            fieldCache.put(fullFieldName, field);
            return field;
        } catch (NoSuchFieldException e) {
            fieldCache.put(fullFieldName, null);
            throw new NoSuchFieldError(fullFieldName);
        }
    }

#end
#end
#No. 188442
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Returns the first field of the given type in a class.
     * Might be useful for Proguard'ed classes to identify fields with unique types.
     * If no matching field was not found, a {@link NoSuchFieldError} will be thrown.
     */

#Code:
    public static Field findFirstFieldByExactType(Class<?> clazz, Class<?> type) {
        Class<?> clz = clazz;
        do {
            for (Field field : clz.getDeclaredFields()) {
                if (field.getType() == type) {
                    field.setAccessible(true);
                    return field;
                }
            }
        } while ((clz = clz.getSuperclass()) != null);

        throw new NoSuchFieldError("Field of type " + type.getName() + " in class " + clazz.getName());
    }

#end
#end
#No. 188443
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Look up a method in a class and set it to accessible. The result is cached.
     * If the method was not found, a {@link NoSuchMethodError} will be thrown.
     * <p>
     * <p>The parameter types may either be specified as <code>Class</code> or <code>String</code>
     * objects. In the latter case, the class is looked up using {@link #findClass} with the same
     * class loader as the method's class.
     */

#Code:
    public static Method findMethodExact(ClassLoader application, Class<?> clazz, String methodName, Object... parameterTypes) {
        Class<?>[] parameterClasses = null;
        for (int i = parameterTypes.length - 1; i >= 0; i--) {
            Object type = parameterTypes[i];
            if (type == null)
                throw new ClassNotFoundError("parameter type must not be null", null);

            // ignore trailing callback
            if (type instanceof XC_MethodHook)
                continue;

            if (parameterClasses == null)
                parameterClasses = new Class<?>[i + 1];

            if (type instanceof Class)
                parameterClasses[i] = (Class<?>) type;
            else if (type instanceof String)
                parameterClasses[i] = findClass((String) type, application);
            else
                throw new ClassNotFoundError("parameter type must either be specified as Class or String", null);
        }

        // if there are no arguments for the method
        if (parameterClasses == null)
            parameterClasses = new Class<?>[0];

        return findMethodExact(clazz, methodName, parameterClasses);
    }



#end
#end
#No. 188445
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Look up a method in a class and set it to accessible. The result is cached.
     * If the method was not found, a {@link NoSuchMethodError} will be thrown.
     */

#Code:
    public static Method findMethodExact(Class<?> clazz, String methodName, Class<?>... parameterTypes) {
        StringBuilder sb = new StringBuilder(clazz.getName());
        sb.append('#');
        sb.append(methodName);
        sb.append(getParametersString(parameterTypes));
        sb.append("#exact");
        String fullMethodName = sb.toString();

        if (methodCache.containsKey(fullMethodName)) {
            Method method = methodCache.get(fullMethodName);
            if (method == null)
                throw new NoSuchMethodError(fullMethodName);
            return method;
        }

        try {
            Method method = clazz.getDeclaredMethod(methodName, parameterTypes);
            method.setAccessible(true);
            methodCache.put(fullMethodName, method);
            return method;
        } catch (NoSuchMethodException e) {
            methodCache.put(fullMethodName, null);
            throw new NoSuchMethodError(fullMethodName);
        }
    }

#end
#end
#No. 188446
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Returns an array of all methods in a class with the specified parameter types.
     * <p>
     * The return type is optional, it will not be compared if it is {@code null}.
     * Use {@code void.class} if you want to search for methods returning nothing.
     */

#Code:
    public static Method[] findMethodsByExactParameters(Class<?> clazz, Class<?> returnType, Class<?>... parameterTypes) {
        List<Method> result = new LinkedList<Method>();
        for (Method method : clazz.getDeclaredMethods()) {
            if (returnType != null && returnType != method.getReturnType())
                continue;

            Class<?>[] methodParameterTypes = method.getParameterTypes();
            if (parameterTypes.length != methodParameterTypes.length)
                continue;

            boolean match = true;
            for (int i = 0; i < parameterTypes.length; i++) {
                if (parameterTypes[i] != methodParameterTypes[i]) {
                    match = false;
                    break;
                }
            }
            if (!match)
                continue;

            method.setAccessible(true);
            result.add(method);
        }
        return result.toArray(new Method[result.size()]);
    }

#end
#end
#No. 188447
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Look up a method in a class and set it to accessible. Parameter types are
     * determined from the <code>args</code> for the method call. The result is cached.
     * This does not only look for exact matches, but for the closest match.
     * If the method was not found, a {@link NoSuchMethodError} will be thrown.
     */

#Code:
    public static Method findMethodBestMatch(Class<?> clazz, String methodName, Object... args) {
        return findMethodBestMatch(clazz, methodName, getParameterTypes(args));
    }

#end
#end
#No. 188448
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Look up a method in a class and set it to accessible. Parameter types are
     * preferably taken from the <code>parameterTypes</code>. Any item in this array that
     * is <code>null</code> is determined from the corresponding item in <code>args</code>.
     * The result is cached.
     * This does not only look for exact matches, but for the closest match.
     * If the method was not found, a {@link NoSuchMethodError} will be thrown.
     */

#Code:
    public static Method findMethodBestMatch(Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object[] args) {
        Class<?>[] argsClasses = null;
        for (int i = 0; i < parameterTypes.length; i++) {
            if (parameterTypes[i] != null)
                continue;
            if (argsClasses == null)
                argsClasses = getParameterTypes(args);
            parameterTypes[i] = argsClasses[i];
        }
        return findMethodBestMatch(clazz, methodName, parameterTypes);
    }

#end
#end
#No. 188449
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Return an array with the classes of the given objects
     */

#Code:
    public static Class<?>[] getParameterTypes(Object... args) {
        Class<?>[] clazzes = new Class<?>[args.length];
        for (int i = 0; i < args.length; i++) {
            clazzes[i] = (args[i] != null) ? args[i].getClass() : null;
        }
        return clazzes;
    }

#end
#end
#No. 188450
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Return an array with the classes of the given objects
     */

#Code:
    public static Class<?>[] getClassesAsArray(Class<?>... clazzes) {
        return clazzes;
    }


#end
#end
#No. 188452
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Call instance or static method <code>methodName</code> for object <code>obj</code> with the arguments
     * <code>args</code>. The types for the arguments will be determined automaticall from <code>args</code>
     */

#Code:
    public static Object callMethod(Object obj, String methodName, Object... args) {
        try {
            return findMethodBestMatch(obj.getClass(), methodName, args).invoke(obj, args);
        } catch (IllegalAccessException e) {
            // should not happen
            DexposedBridge.log(e);
            throw new IllegalAccessError(e.getMessage());
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (InvocationTargetException e) {
            throw new InvocationTargetError(e.getCause());
        }
    }

#end
#end
#No. 188453
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Call instance or static method <code>methodName</code> for object <code>obj</code> with the arguments
     * <code>args</code>. The types for the arguments will be taken from <code>parameterTypes</code>.
     * This array can have items that are <code>null</code>. In this case, the type for this parameter
     * is determined from <code>args</code>.
     */

#Code:
    public static Object callMethod(Object obj, String methodName, Class<?>[] parameterTypes, Object... args) {
        try {
            return findMethodBestMatch(obj.getClass(), methodName, parameterTypes, args).invoke(obj, args);
        } catch (IllegalAccessException e) {
            // should not happen
            DexposedBridge.log(e);
            throw new IllegalAccessError(e.getMessage());
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (InvocationTargetException e) {
            throw new InvocationTargetError(e.getCause());
        }
    }

#end
#end
#No. 188454
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Call static method <code>methodName</code> for class <code>clazz</code> with the arguments
     * <code>args</code>. The types for the arguments will be determined automaticall from <code>args</code>
     */

#Code:
    public static Object callStaticMethod(Class<?> clazz, String methodName, Object... args) {
        try {
            return findMethodBestMatch(clazz, methodName, args).invoke(null, args);
        } catch (IllegalAccessException e) {
            // should not happen
            DexposedBridge.log(e);
            throw new IllegalAccessError(e.getMessage());
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (InvocationTargetException e) {
            throw new InvocationTargetError(e.getCause());
        }
    }

#end
#end
#No. 188455
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Call static method <code>methodName</code> for class <code>clazz</code> with the arguments
     * <code>args</code>. The types for the arguments will be taken from <code>parameterTypes</code>.
     * This array can have items that are <code>null</code>. In this case, the type for this parameter
     * is determined from <code>args</code>.
     */

#Code:
    public static Object callStaticMethod(Class<?> clazz, String methodName, Class<?>[] parameterTypes, Object... args) {
        try {
            return findMethodBestMatch(clazz, methodName, parameterTypes, args).invoke(null, args);
        } catch (IllegalAccessException e) {
            // should not happen
            DexposedBridge.log(e);
            throw new IllegalAccessError(e.getMessage());
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (InvocationTargetException e) {
            throw new InvocationTargetError(e.getCause());
        }
    }

#end
#end
#No. 188456
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Load an asset from a resource and return the content as byte array.
     */

#Code:
    public static byte[] assetAsByteArray(Resources res, String path) throws IOException {
        InputStream is = res.getAssets().open(path);

        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        byte[] temp = new byte[1024];
        int read;

        while ((read = is.read(temp)) > 0) {
            buf.write(temp, 0, read);
        }
        is.close();
        return buf.toByteArray();
    }

#end
#end
#No. 188457
#File: E:\bishe\1\XposedHelpers.java
#Comment:
    /**
     * Returns the lowercase string representation of the file's MD5 sum.
     */

#Code:
    public static String getMD5Sum(String file) throws IOException {
        try {
            MessageDigest digest = MessageDigest.getInstance("MD5");
            InputStream is = new FileInputStream(file);
            byte[] buffer = new byte[8192];
            int read = 0;
            while ((read = is.read(buffer)) > 0) {
                digest.update(buffer, 0, read);
            }
            is.close();
            byte[] md5sum = digest.digest();
            BigInteger bigInt = new BigInteger(1, md5sum);
            return bigInt.toString(16);
        } catch (NoSuchAlgorithmException e) {
            return "";
        }
    }


#end
#end
#No. 188461
#File: E:\bishe\1\Xpp3DomUtils.java
#Comment:
    /**
     * Merge two DOMs, with one having dominance in the case of collision.
     *
     * @see #CHILDREN_COMBINATION_MODE_ATTRIBUTE
     * @see #SELF_COMBINATION_MODE_ATTRIBUTE
     *
     * @param dominant The dominant DOM into which the recessive value/attributes/children will be merged
     * @param recessive The recessive DOM, which will be merged into the dominant DOM
     * @param childMergeOverride Overrides attribute flags to force merging or appending of child elements
     *        into the dominant DOM
     */

#Code:
    public static Xpp3Dom mergeXpp3Dom( Xpp3Dom dominant, Xpp3Dom recessive, Boolean childMergeOverride )
    {
        if ( dominant != null )
        {
            mergeIntoXpp3Dom( dominant, recessive, childMergeOverride );
            return dominant;
        }
        return recessive;
    }

#end
#end
#No. 188462
#File: E:\bishe\1\Xpp3DomUtils.java
#Comment:
    /**
     * Merge two DOMs, with one having dominance in the case of collision.
     * Merge mechanisms (vs. override for nodes, or vs. append for children) is determined by
     * attributes of the dominant root node.
     *
     * @see #CHILDREN_COMBINATION_MODE_ATTRIBUTE
     * @see #SELF_COMBINATION_MODE_ATTRIBUTE
     *
     * @param dominant The dominant DOM into which the recessive value/attributes/children will be merged
     * @param recessive The recessive DOM, which will be merged into the dominant DOM
     */

#Code:
    public static Xpp3Dom mergeXpp3Dom( Xpp3Dom dominant, Xpp3Dom recessive )
    {
        if ( dominant != null )
        {
            mergeIntoXpp3Dom( dominant, recessive, null );
            return dominant;
        }
        return recessive;
    }


#end
#end
#No. 188472
#File: E:\bishe\1\XRecyclerView.java
#Comment:
        /**
         * Sole constructor. Takes in a {@link Drawable} to be used as the interior
         * divider.
         *
         * @param divider A divider {@code Drawable} to be drawn on the RecyclerView
         */

#Code:
        public DividerItemDecoration(Drawable divider) {
            mDivider = divider;
        }

#end
#end
#No. 188473
#File: E:\bishe\1\XRecyclerView.java
#Comment:
        /**
         * Draws horizontal or vertical dividers onto the parent RecyclerView.
         *
         * @param canvas The {@link Canvas} onto which dividers will be drawn
         * @param parent The RecyclerView onto which dividers are being added
         * @param state The current RecyclerView.State of the RecyclerView
         */

#Code:
        @Override
        public void onDraw(Canvas canvas, RecyclerView parent, RecyclerView.State state) {
            if (mOrientation == LinearLayoutManager.HORIZONTAL) {
                drawHorizontalDividers(canvas, parent);
            } else if (mOrientation == LinearLayoutManager.VERTICAL) {
                drawVerticalDividers(canvas, parent);
            }
        }

#end
#end
#No. 188474
#File: E:\bishe\1\XRecyclerView.java
#Comment:
        /**
         * Determines the size and location of offsets between items in the parent
         * RecyclerView.
         *
         * @param outRect The {@link Rect} of offsets to be added around the child
         *                view
         * @param view The child view to be decorated with an offset
         * @param parent The RecyclerView onto which dividers are being added
         * @param state The current RecyclerView.State of the RecyclerView
         */

#Code:
        @Override
        public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
            super.getItemOffsets(outRect, view, parent, state);

            if (parent.getChildAdapterPosition(view) <= mWrapAdapter.getHeadersCount() + 1) {
                return;
            }
            mOrientation = ((LinearLayoutManager) parent.getLayoutManager()).getOrientation();
            if (mOrientation == LinearLayoutManager.HORIZONTAL) {
                outRect.left = mDivider.getIntrinsicWidth();
            } else if (mOrientation == LinearLayoutManager.VERTICAL) {
                outRect.top = mDivider.getIntrinsicHeight();
            }
        }

#end
#end
#No. 188475
#File: E:\bishe\1\XRecyclerView.java
#Comment:
        /**
         * Adds dividers to a RecyclerView with a LinearLayoutManager or its
         * subclass oriented horizontally.
         *
         * @param canvas The {@link Canvas} onto which horizontal dividers will be
         *               drawn
         * @param parent The RecyclerView onto which horizontal dividers are being
         *               added
         */

#Code:
        private void drawHorizontalDividers(Canvas canvas, RecyclerView parent) {
            int parentTop = parent.getPaddingTop();
            int parentBottom = parent.getHeight() - parent.getPaddingBottom();

            int childCount = parent.getChildCount();
            for (int i = 0; i < childCount - 1; i++) {
                View child = parent.getChildAt(i);

                RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();

                int parentLeft = child.getRight() + params.rightMargin;
                int parentRight = parentLeft + mDivider.getIntrinsicWidth();

                mDivider.setBounds(parentLeft, parentTop, parentRight, parentBottom);
                mDivider.draw(canvas);
            }
        }

#end
#end
#No. 188476
#File: E:\bishe\1\XRecyclerView.java
#Comment:
        /**
         * Adds dividers to a RecyclerView with a LinearLayoutManager or its
         * subclass oriented vertically.
         *
         * @param canvas The {@link Canvas} onto which vertical dividers will be
         *               drawn
         * @param parent The RecyclerView onto which vertical dividers are being
         *               added
         */

#Code:
        private void drawVerticalDividers(Canvas canvas, RecyclerView parent) {
            int parentLeft = parent.getPaddingLeft();
            int parentRight = parent.getWidth() - parent.getPaddingRight();

            int childCount = parent.getChildCount();
            for (int i = 0; i < childCount - 1; i++) {
                View child = parent.getChildAt(i);

                RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();

                int parentTop = child.getBottom() + params.bottomMargin;
                int parentBottom = parentTop + mDivider.getIntrinsicHeight();

                mDivider.setBounds(parentLeft, parentTop, parentRight, parentBottom);
                mDivider.draw(canvas);
            }
        }



#end
#end
#No. 188479
#File: E:\bishe\1\XRecyclerViewAdapter.java
#Comment:
    /**
     * Whether to display emptyView requires the user to manually invoke it
     */

#Code:
    public void isShowEmptyView() {
        if (recyclerView == null || mEmptyView == null) {
            return;
        }
        if (mDatas.size() == 0) {
            mEmptyView.setVisibility(View.VISIBLE);
            recyclerView.setVisibility(View.GONE);
        } else {
            mEmptyView.setVisibility(View.GONE);
            recyclerView.setVisibility(View.VISIBLE);
        }
    }

#end
#end
#No. 188480
#File: E:\bishe\1\XRecyclerViewAdapter.java
#Comment:
    /**
     * Whether to display netWorkErrorView requires the user to manually invoke it
     */

#Code:
    public void isShowNetWorkErrorView() {
        if (recyclerView == null || mNetWorkErrorView == null) {
            return;
        }
        if (mDatas.size() == 0) {
            mNetWorkErrorView.setVisibility(View.VISIBLE);
            recyclerView.setVisibility(View.GONE);
        } else {
            mNetWorkErrorView.setVisibility(View.GONE);
            recyclerView.setVisibility(View.VISIBLE);
        }
    }

#end
#end
#No. 188491
#File: E:\bishe\1\XScrollView.java
#Comment:
    /**
     * Set the content ViewGroup for XScrollView.
     *
     * @param content
     */

#Code:
    public void setContentView(ViewGroup content) {
        if (mLayout == null) {
            return;
        }

        if (mContentLayout == null) {
            mContentLayout = (LinearLayout) mLayout.findViewById(R.id.content_layout);
        }

        if (mContentLayout.getChildCount() > 0) {
            mContentLayout.removeAllViews();
        }
        mContentLayout.addView(content);
    }

#end
#end
#No. 188492
#File: E:\bishe\1\XScrollView.java
#Comment:
    /**
     * Set the content View for XScrollView.
     *
     * @param content
     */

#Code:
    public void setView(View content) {
        if (mLayout == null) {
            return;
        }

        if (mContentLayout == null) {
            mContentLayout = (LinearLayout) mLayout.findViewById(R.id.content_layout);
        }
        mContentLayout.addView(content);
    }

#end
#end
#No. 188493
#File: E:\bishe\1\XScrollView.java
#Comment:
    /**
     * Enable or disable pull down refresh feature.
     *
     * @param enable
     */

#Code:
    public void setPullRefreshEnable(boolean enable) {
        mEnablePullRefresh = enable;

        // disable, hide the content
        mHeaderContent.setVisibility(enable ? View.VISIBLE : View.INVISIBLE);
    }

#end
#end
#No. 188494
#File: E:\bishe\1\XScrollView.java
#Comment:
    /**
     * Enable or disable pull up load more feature.
     *
     * @param enable
     */

#Code:
    public void setPullLoadEnable(boolean enable) {
        mEnablePullLoad = enable;

        if (!mEnablePullLoad) {
            mFooterView.setBottomMargin(0);
            mFooterView.hide();
            mFooterView.setPadding(0, 0, 0, mFooterView.getHeight() * (-1));
            mFooterView.setOnClickListener(null);

        } else {
            mPullLoading = false;
            mFooterView.setPadding(0, 0, 0, 0);
            mFooterView.show();
            mFooterView.setState(XFooterView.STATE_NORMAL);
            // both "pull up" and "click" will invoke load more.
            mFooterView.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    startLoadMore();
                }
            });
        }
    }

#end
#end
#No. 188495
#File: E:\bishe\1\XScrollView.java
#Comment:
    /**
     * Enable or disable auto load more feature when scroll to bottom.
     *
     * @param enable
     */

#Code:
    public void setAutoLoadEnable(boolean enable) {
        mEnableAutoLoad = enable;
    }

#end
#end
#No. 188496
#File: E:\bishe\1\XScrollView.java
#Comment:
    /**
     * Stop refresh, reset header view.
     */

#Code:
    public void stopRefresh() {
        if (mPullRefreshing) {
            mPullRefreshing = false;
            resetHeaderHeight();
        }
    }

#end
#end
#No. 188497
#File: E:\bishe\1\XScrollView.java
#Comment:
    /**
     * Stop load more, reset footer view.
     */

#Code:
    public void stopLoadMore() {
        if (mPullLoading) {
            mPullLoading = false;
            mFooterView.setState(XFooterView.STATE_NORMAL);
        }
    }

#end
#end
#No. 188498
#File: E:\bishe\1\XScrollView.java
#Comment:
    /**
     * Set last refresh time
     *
     * @param time
     */

#Code:
    public void setRefreshTime(String time) {
        mHeaderTime.setText(time);
    }

#end
#end
#No. 188499
#File: E:\bishe\1\XScrollView.java
#Comment:
    /**
     * Set listener.
     *
     * @param listener
     */

#Code:
    public void setIXScrollViewListener(IXScrollViewListener listener) {
        mListener = listener;
    }

#end
#end
#No. 188500
#File: E:\bishe\1\XScrollView.java
#Comment:
    /**
     * Auto call back refresh.
     */

#Code:
    public void autoRefresh() {
        mHeader.setVisibleHeight(mHeaderHeight);

        if (mEnablePullRefresh && !mPullRefreshing) {
            // update the arrow image not refreshing
            if (mHeader.getVisibleHeight() > mHeaderHeight) {
                mHeader.setState(XHeaderView.STATE_READY);
            } else {
                mHeader.setState(XHeaderView.STATE_NORMAL);
            }
        }

        mPullRefreshing = true;
        mHeader.setState(XHeaderView.STATE_REFRESHING);
        refresh();
    }

#end
#end
#No. 188501
#File: E:\bishe\1\XsdAnnotationProcessorAndEnumsTest.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @SuppressWarnings("unchecked")
    @Override
    protected List<Class<?>> getJaxbAnnotatedClassesForJaxbContext() {

        final List<Class<?>> toReturn = new ArrayList<Class<?>>();
        for (Class<?> current : Arrays.asList(FoodPreference.class, ExampleEnumHolder.class, AmericanCoin.class)) {
            toReturn.add(current);
        }

        return toReturn;
    }

#end
#end
#No. 188502
#File: E:\bishe\1\XsdAnnotationProcessorSemiDocumentedTest.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    protected List<Class<?>> getJaxbAnnotatedClassesForJaxbContext() {
        return Arrays.<Class<?>>asList(SemiDocumentedClass.class);
    }

#end
#end
#No. 188503
#File: E:\bishe\1\XsdAnnotationProcessorTest.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    protected List<Class<?>> getJaxbAnnotatedClassesForJaxbContext() {
        return Arrays.<Class<?>>asList(SomewhatNamedPerson.class, ExampleXmlWrapper.class);
    }

#end
#end
#No. 188504
#File: E:\bishe\1\XSDDateTimeStringProcessor.java
#Comment:
/**
 * A class supporting processing of datetime strings represented in the standard XML Schema date format
 * 'yyyy-MM-ddTHH:mm:ss.S'.
 * <p>
 * TODO Time zone offset specifications are not yet supported.
 */

#Code:
class XSDDateTimeStringProcessor extends DatetimeStringProcessor
{
  @NonNull private static final SimpleDateFormat _dateFormat = new SimpleDateFormat("y-M-d'T'h:m:s.S");
  @NonNull private static final String _delimiters = "-:.TZ";

  // The number of tokens (including delimeters) necessary to strip a datetime to a specified granularity.
  @NonNull private static final int[] _gTokenIndex = { 1, 3, 5, 7, 9, 11, 13 }; // 1=YEARS, 3=MONTHS etc.

  // Strings to pad a partially specified datetime.
  @NonNull private static final String _datetimeRoundDownPadding[] = { "-01-01T00:00:00.000", "-01T00:00:00.000",
    "T00:00:00.000", ":00:00.000", ":00.000", ".000", "" };

#end
#end
#No. 188505
#File: E:\bishe\1\XsdLanguageRuntimeModule.java
#Comment:
	/**
	 * Bind some extra {@link IValueConverter}s on top of the {@link DefaultTerminalConverters}.
	 */

#Code:
	public Class<? extends org.eclipse.xtext.conversion.IValueConverterService> bindIValueConverterService() {
		return CustomConversions.class;
	}

#end
#end
#No. 188511
#File: E:\bishe\1\XsfActivityFragmentLayoutNameDetector.java
#Comment:
    /**
     * If user make this call "setContentView(R.layout.activity_main)" without an explict instance, return true.
     * Else if "this.setContentView(R.layout.activity_main)", then return true.
     * Else if "someobj.setContentView(R.layout.activity_main)", return false.
     */

#Code:
    private boolean isSetContentViewOnThis_ForActivity(@NonNull MethodInvocation node) {
        StrictListAccessor<Expression, MethodInvocation> args = node.astArguments();
        String argOwner = args.owner().toString();
        if (argOwner.startsWith("setContentView(")
                || argOwner.startsWith("this.setContentView(")) {
            return true;
        } else {
            return false;
        }

#end
#end
#No. 188512
#File: E:\bishe\1\XsfActivityFragmentLayoutNameDetector.java
#Comment:
    /**
     * If setContentView is called by 'this' instance,
     * this method will check if 'this' is an instance of a Class inherit from android.app.Activity, for eaxmple AppCompatActivity or FragmentActivity, and so on.
     */

#Code:
    private boolean isThisInstanceOfActivity_ForActivity(@NonNull JavaContext context, @NonNull MethodInvocation node) {
        Node currentNode = node.getParent();

        JavaParser.ResolvedNode resolved = context.resolve(JavaContext.findSurroundingClass(node));
        JavaParser.ResolvedClass sorroundingClass = (JavaParser.ResolvedClass) resolved;
        while (sorroundingClass != null) {
            //System.out.println("sorroundingClass = " + sorroundingClass);
            if ("android.app.Activity".equals(sorroundingClass.getName())) {
                return true;
            } else {
                sorroundingClass = sorroundingClass.getSuperClass();
            }
        }

#end
#end
#No. 188513
#File: E:\bishe\1\XsfActivityFragmentLayoutNameDetector.java
#Comment:
    /**
     * As there are more than one methods overload "setContentView",
     * we have to identify the one we want to check, whose param has an Annotation of "@LayoutRes".
     * In fact, {public void setContentView(@LayoutRes int layoutResID)} is the one we are looking for.
     */

#Code:
    private boolean isThisMethodHasLayoutAnnotation_ForActivity(@NonNull JavaContext context, @NonNull MethodInvocation node) {
        JavaParser.ResolvedNode resolved = context.resolve(node);
        JavaParser.ResolvedMethod method = (JavaParser.ResolvedMethod) resolved;

        if (node.astArguments().size() != 1) {
            return false;
        }

#end
#end
#No. 188514
#File: E:\bishe\1\XsfActivityFragmentLayoutNameDetector.java
#Comment:
    /**
     * inflater.inflate() can be called from anywhere.
     * We only care about the one call in {public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)}.
     * This method whill check that.
     */

#Code:
    private boolean isInflateCalledInOnCreateView_ForFragment(@NonNull JavaContext context, @NonNull MethodInvocation node) {
        Node surroundingNode = JavaContext.findSurroundingMethod(node);
        JavaParser.ResolvedNode resolvedNode = context.resolve(surroundingNode);

        try {
            String resolvedNodeName = resolvedNode.getName();
            if ("onCreateView".equals(resolvedNodeName)) {
                return true;
            }
        } catch (Exception e) {
            return false;
        }

#end
#end
#No. 188515
#File: E:\bishe\1\XsfActivityFragmentLayoutNameDetector.java
#Comment:
    /**
     * We get the layout file resource name, for example "R.layout.fragment_blank".
     * This method will check if it starts with the given prefix.
     *
     * @param layoutFileResourceString layout resource file name, like "R.layout.fragment_blank"
     * @param prefix                   the given prefix, must be "activity_" or "fragment)"
     * @return "true" if layoutFileResourceString starts with prefix, "false" otherwise.
     */

#Code:
    private boolean isFileStringStartWithPrefix(String layoutFileResourceString, String prefix) {
        int lastDotIndex = layoutFileResourceString.lastIndexOf(".");
        String fileName = layoutFileResourceString.substring(lastDotIndex + 1);
        if (fileName.startsWith(prefix)) {
            return true;
        } else {
            return false;
        }
    }

#end
#end
#No. 188516
#File: E:\bishe\1\XsfActivityFragmentLayoutNameDetector.java
#Comment:
    /**
     * There are more than one methods overloading in the name of "inflate()" in android.view.LayoutInflater.<br>
     * We only care about those having an param with `@LayoutRes` annotation,
     * for example {public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)}.<br>
     * This method will find out the resource param with an `@LayoutRes` annotation in String format, for example `R.layout.fragment_blank` .<br>
     * If no such param exists, <B>null</B> will be returned.
     */

#Code:
    private String getParamWithLayoutAnnotation_ForFragment(@NonNull JavaContext context, @NonNull MethodInvocation node) {
        Iterator<Expression> arguments = node.astArguments().iterator();
        Expression argument = arguments.next();

        JavaParser.ResolvedNode resolved = context.resolve(node);
        JavaParser.ResolvedMethod method = (JavaParser.ResolvedMethod) resolved;

        JavaParser.ResolvedAnnotation layoutParamAnnotation = method.getParameterAnnotation("android.support.annotation.LayoutRes", 0);
        if (layoutParamAnnotation != null) {
            return argument.toString();
        } else {
            return null;
        }

#end
#end
#No. 188517
#File: E:\bishe\1\XsfViewHolderItemNameDetector.java
#Comment:
    /**
     * We get the layout file resource name, for example "R.layout.fragment_blank".
     * This method will check if it starts with the given prefix.
     * @param layoutFileResourceString layout resource file name, like "R.layout.fragment_blank"
     * @param prefix the given prefix, must be "activity_" or "fragment)"
     * @return "true" if layoutFileResourceString starts with prefix, "false" otherwise.
     */

#Code:
    private boolean isFileStringStartWithPrefix(String layoutFileResourceString, String prefix){
        int lastDotIndex = layoutFileResourceString.lastIndexOf(".");
        String fileName = layoutFileResourceString.substring(lastDotIndex + 1);
        if (fileName.startsWith(prefix)){
            return true;
        }else{
            return false;
        }
    }

#end
#end
#No. 188520
#File: E:\bishe\1\XSLFCommentAuthors.java
#Comment:
    /**
     * Create a new set of slide comments
     */

#Code:
    XSLFCommentAuthors() {
       super();
//       CmAuthorLstDocument doc = CmAuthorLstDocument.Factory.newInstance();
//       _authors = doc.addNewCmAuthorLst();
    }

#end
#end
#No. 188521
#File: E:\bishe\1\XSLFCommentAuthors.java
#Comment:
    /**
     * Construct a SpreadsheetML slide authors from a package part
     *
     * @param part the package part holding the comment authors data,
     * the content type must be <code>application/vnd.openxmlformats-officedocument.commentAuthors+xml</code>
     * @param rel  the package relationship holding this comment authors,
     * the relationship type must be http://schemas.openxmlformats.org/officeDocument/2006/relationships/commentAuthors
     */

#Code:
    XSLFCommentAuthors(PackagePart part, PackageRelationship rel) throws IOException, XmlException {
        super(part, rel);

//        CmAuthorLstDocument doc =
//           CmAuthorLstDocument.Factory.parse(getPackagePart().getInputStream());
//        _authors = doc.getCmAuthorLst();
    }

#end
#end
#No. 188522
#File: E:\bishe\1\XSLFComments.java
#Comment:
    /**
     * Create a new set of slide comments
     */

#Code:
    XSLFComments() {
       super();
//       CmLstDocument doc = CmLstDocument.Factory.newInstance();
//       _comments = doc.addNewCmLst();
    }

#end
#end
#No. 188523
#File: E:\bishe\1\XSLFComments.java
#Comment:
    /**
     * Construct a SpreadsheetML slide comments from a package part
     *
     * @param part the package part holding the comments data,
     * the content type must be <code>application/vnd.openxmlformats-officedocument.comments+xml</code>
     * @param rel  the package relationship holding this comments,
     * the relationship type must be http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments
     */

#Code:
    XSLFComments(PackagePart part, PackageRelationship rel) throws IOException, XmlException {
        super(part, rel);

//        CmLstDocument doc =
//           CmLstDocument.Factory.parse(getPackagePart().getInputStream());
//        _comments = doc.getCmLst();
    }

#end
#end
#No. 188524
#File: E:\bishe\1\XSLFGraphicFrame.java
#Comment:
    /**
     * Rotate this shape.
     * <p>
     * Positive angles are clockwise (i.e., towards the positive y axis);
     * negative angles are counter-clockwise (i.e., towards the negative y axis).
     * </p>
     *
     * @param theta the rotation angle in degrees.
     */

#Code:
    public void setRotation(double theta){
    	throw new IllegalArgumentException("Operation not supported");
    }

#end
#end
#No. 188525
#File: E:\bishe\1\XSLFGraphicFrame.java
#Comment:
    /**
     * Rotation angle in degrees
     * <p>
     * Positive angles are clockwise (i.e., towards the positive y axis);
     * negative angles are counter-clockwise (i.e., towards the negative y axis).
     * </p>
     *
     * @return rotation angle in degrees
     */

#Code:
    public double getRotation(){
    	return 0;
    }

#end
#end
#No. 188526
#File: E:\bishe\1\XSLFGraphicFrame.java
#Comment:
    /**
     * Whether the shape is horizontally flipped
     *
     * @return whether the shape is horizontally flipped
     */

#Code:
    public boolean getFlipHorizontal(){
    	return false;
    }

#end
#end
#No. 188527
#File: E:\bishe\1\XSLFNotes.java
#Comment:
    /**
     * Create a new notes
     */

#Code:
    XSLFNotes() {
        super();
        _notes = prototype();
        setCommonSlideData(_notes.getCSld());
    }

#end
#end
#No. 188528
#File: E:\bishe\1\XSLFNotes.java
#Comment:
    /**
     * Construct a SpreadsheetML notes from a package part
     *
     * @param part the package part holding the notes data,
     * the content type must be <code>application/vnd.openxmlformats-officedocument.notes+xml</code>
     * @param rel  the package relationship holding this notes,
     * the relationship type must be http://schemas.openxmlformats.org/officeDocument/2006/relationships/notes
     */

#Code:
    XSLFNotes(PackagePart part, PackageRelationship rel) throws IOException, XmlException {
        super(part, rel);

        NotesDocument doc =
            NotesDocument.Factory.parse(getPackagePart().getInputStream());
        _notes = doc.getNotes();
        setCommonSlideData(_notes.getCSld());
    }

#end
#end
#No. 188529
#File: E:\bishe\1\XSLFRelation.java
#Comment:
   /**
    * Get POIXMLRelation by relation type
    *
    * @param rel relation type, for example,
    *    <code>http://schemas.openxmlformats.org/officeDocument/2006/relationships/image</code>
    * @return registered POIXMLRelation or null if not found
    */

#Code:
   public static XSLFRelation getInstance(String rel){
       return _table.get(rel);
   }


#end
#end
#No. 188531
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     *
     * @return the XMLSlideShow this sheet belongs to
     */

#Code:
    public XMLSlideShow getSlideShow() {
        POIXMLDocumentPart p = getParent();
        while(p != null) {
            if(p instanceof XMLSlideShow){
                return (XMLSlideShow)p;
            }
            p = p.getParent();
        }
        throw new IllegalStateException("SlideShow was not found");
    }



#end
#end
#No. 188533
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     * Returns an array containing all of the shapes in this sheet
     *
     * @return an array of all shapes in this sheet
     */

#Code:
    public XSLFShape[] getShapes(){
        return getShapeList().toArray(new XSLFShape[_shapes.size()]);
    }

#end
#end
#No. 188534
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     * Returns an iterator over the shapes in this sheet
     *
     * @return an iterator over the shapes in this sheet
     */

#Code:
    public Iterator<XSLFShape> iterator(){
        return getShapeList().iterator();
    }

#end
#end
#No. 188535
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     * Removes the specified shape from this sheet, if it is present
     * (optional operation).  If this sheet does not contain the element,
     * it is unchanged.
     *
     * @param xShape shape to be removed from this sheet, if present
     * @return <tt>true</tt> if this sheet contained the specified element
     * @throws IllegalArgumentException if the type of the specified shape
     *         is incompatible with this sheet (optional)
     */

#Code:
    public boolean removeShape(XSLFShape xShape) {
        XmlObject obj = xShape.getXmlObject();
        CTGroupShape spTree = getSpTree();
        if(obj instanceof CTShape){
            spTree.getSpList().remove(obj);
        } else if (obj instanceof CTGroupShape){
            spTree.getGrpSpList().remove(obj);
        } else if (obj instanceof CTConnector){
            spTree.getCxnSpList().remove(obj);
        } else {
            throw new IllegalArgumentException("Unsupported shape: " + xShape);
        }
        return getShapeList().remove(xShape);
    }

#end
#end
#No. 188536
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     * Removes all of the elements from this container (optional operation).
     * The container will be empty after this call returns.
     */

#Code:
    public void clear() {
        for(XSLFShape shape : getShapes()){
            removeShape(shape);
        }
    }

#end
#end
#No. 188537
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     * Set the contents of this sheet to be a copy of the source sheet.
     * This method erases any existing shapes and replaces them with
     * object from the source sheet.
     *
     * @param src the source sheet to copy data from
     * @return modified 'this'
     */

#Code:
    public XSLFSheet importContent(XSLFSheet src){
        _shapes = null;
        _spTree = null;
        _drawing = null;
        _spTree = null;
        // first copy the source xml
        getSpTree().set(src.getSpTree());

        // recursively update each shape
        List<XSLFShape> tgtShapes = getShapeList();
        List<XSLFShape> srcShapes = src.getShapeList();
        for(int i = 0; i < tgtShapes.size(); i++){
            XSLFShape s1 = srcShapes.get(i);
            XSLFShape s2 = tgtShapes.get(i);

            s2.copy(s1);
        }
        return this;
    }

#end
#end
#No. 188538
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     * Append content to this sheet.
     *
     * @param src the source sheet
     * @return modified <code>this</code>.
     */

#Code:
    public XSLFSheet appendContent(XSLFSheet src){
        CTGroupShape spTree = getSpTree();
        int numShapes = getShapeList().size();

        CTGroupShape srcTree = src.getSpTree();
        for(XmlObject ch : srcTree.selectPath("*")){
            if(ch instanceof CTShape){ // simple shape
                spTree.addNewSp().set(ch);
            } else if (ch instanceof CTGroupShape){
                spTree.addNewGrpSp().set(ch);
            } else if (ch instanceof CTConnector){
                spTree.addNewCxnSp().set(ch);
            } else if (ch instanceof CTPicture){
                spTree.addNewPic().set(ch);
            } else if (ch instanceof CTGraphicalObjectFrame){
                spTree.addNewGraphicFrame().set(ch);
            }
        }

        _shapes = null;
        _spTree = null;
        _drawing = null;
        _spTree = null;

        // recursively update each shape
        List<XSLFShape> tgtShapes = getShapeList();
        List<XSLFShape> srcShapes = src.getShapeList();
        for(int i = 0; i < srcShapes.size(); i++){
            XSLFShape s1 = srcShapes.get(i);
            XSLFShape s2 = tgtShapes.get(numShapes + i);

            s2.copy(s1);
        }
        return this;
    }

#end
#end
#No. 188539
#File: E:\bishe\1\XSLFSheet.java
#Comment:
   /**
     * @return theme (shared styles) associated with this theme.
     *  By default returns <code>null</code> which means that this sheet is theme-less.
     *  Sheets that support the notion of themes (slides, masters, layouts, etc.) should override this
     *  method and return the corresponding package part.
     */

#Code:
    XSLFTheme getTheme(){
    	return null;
    }


#end
#end
#No. 188541
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     *
     * @param idx 0-based index of a placeholder in the sheet
     * @return placeholder
     */

#Code:
    public XSLFTextShape getPlaceholder(int idx) {
        initPlaceholders();
        return _placeholders.get(idx);
    }

#end
#end
#No. 188542
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     *
     * @return all placeholder shapes in this sheet
     */

#Code:
    public XSLFTextShape[] getPlaceholders() {
        initPlaceholders();
        return _placeholders.toArray(new XSLFTextShape[_placeholders.size()]);
    }

#end
#end
#No. 188543
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     * Checks if this <code>sheet</code> displays the specified shape.
     *
     * Subclasses can override it and skip certain shapes from drawings,
     * for instance, slide masters and layouts don't display placeholders
     */

#Code:
    protected boolean canDraw(XSLFShape shape){
        return true;
    }

#end
#end
#No. 188544
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     *
     * @return whether shapes on the master sheet should be shown. By default master graphics is turned off.
     * Sheets that support the notion of master (slide, slideLayout) should override it and
     * check this setting in the sheet XML
     */

#Code:
    public boolean getFollowMasterGraphics(){
        return false;
    }

#end
#end
#No. 188545
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     *
     * @return  background for this sheet
     */

#Code:
    public XSLFBackground getBackground() {
        return null;
    }

#end
#end
#No. 188546
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     * Render this sheet into the supplied graphics object
     *
     * @param graphics
     * @param position 
     * @param handler 
     * @param isCanceled 
     */

#Code:
    public void draw(Graphics2D graphics, AtomicBoolean isCanceled, Handler handler, int position){
        XSLFSheet master = getMasterSheet();
        if(getFollowMasterGraphics() && master != null) master.draw(graphics, isCanceled, handler, position);

        graphics.setRenderingHint(XSLFRenderingHint.GROUP_TRANSFORM, new AffineTransform());
        int i = 0;
        for(XSLFShape shape : getShapeList()) {
        	if (isCanceled.get()) {
        		Log.d("Slide", "Thread.Canceled");
        		return;
        	} else {
        		handler.sendMessage(Message.obtain(handler, 1, i++, getShapeList().size(), Integer.valueOf(position)));        		
        	}
            if(!canDraw(shape)) continue;

        	// remember the initial transform and restore it after we are done with drawing
        	AffineTransform at = graphics.getTransform();

            // concrete implementations can make sense of this hint,
            // for example PSGraphics2D or PDFGraphics2D would call gsave() / grestore
            graphics.setRenderingHint(XSLFRenderingHint.GSAVE, true);

            // apply rotation and flipping
            shape.applyTransform(graphics);
            // draw stuff
            shape.draw(graphics);

            // restore the coordinate system
            graphics.setTransform(at);

            graphics.setRenderingHint(XSLFRenderingHint.GRESTORE, true);

        }
    }

#end
#end
#No. 188547
#File: E:\bishe\1\XSLFSheet.java
#Comment:
    /**
     * Import a picture data from another document.
     *
     * @param blipId        ID of the package relationship to retrieve.
     * @param packagePart   package part containing the data to import
     * @return ID of the created relationship
     */

#Code:
    String importBlip(String blipId, PackagePart packagePart) {
        PackageRelationship blipRel = packagePart.getRelationship(blipId);
        PackagePart blipPart;
        try {
            blipPart = packagePart.getRelatedPart(blipRel);
        } catch (InvalidFormatException e){
            throw new POIXMLException(e);
        }
        XSLFPictureData data = new XSLFPictureData(blipPart, null);

        XMLSlideShow ppt = getSlideShow();
        int pictureIdx = ppt.addPicture(data.getData(), data.getPictureType());
        PackagePart pic = ppt.getAllPictures().get(pictureIdx).getPackagePart();

        PackageRelationship rel = getPackagePart().addRelationship(
                pic.getPartName(), TargetMode.INTERNAL, blipRel.getRelationshipType());
        addRelation(rel.getId(), new XSLFPictureData(pic, rel));

        return rel.getId();
    }

#end
#end
#No. 188548
#File: E:\bishe\1\XSLFSlide.java
#Comment:
    /**
     * Create a new slide
     */

#Code:
    XSLFSlide() {
        super();
        _slide = prototype();
        setCommonSlideData(_slide.getCSld());
    }

#end
#end
#No. 188549
#File: E:\bishe\1\XSLFSlide.java
#Comment:
    /**
     * Construct a SpreadsheetML slide from a package part
     *
     * @param part the package part holding the slide data,
     * the content type must be <code>application/vnd.openxmlformats-officedocument.slide+xml</code>
     * @param rel  the package relationship holding this slide,
     * the relationship type must be http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide
     */

#Code:
    XSLFSlide(PackagePart part, PackageRelationship rel) throws IOException, XmlException {
        super(part, rel);

        SldDocument doc =
            SldDocument.Factory.parse(getPackagePart().getInputStream());
        _slide = doc.getSld();
        setCommonSlideData(_slide.getCSld());
    }

#end
#end
#No. 188550
#File: E:\bishe\1\XSLFSlide.java
#Comment:
    /**
     *
     * @return title of this slide or empty string if title is not set
     */

#Code:
    public String getTitle(){
        XSLFTextShape txt = getTextShapeByType(Placeholder.TITLE);
        return txt == null ? "" : txt.getText();
    }

#end
#end
#No. 188551
#File: E:\bishe\1\XSLFSlide.java
#Comment:
    /**
     *
     * @return the information about background appearance of this slide
     */

#Code:
    @Override
    public XSLFBackground getBackground() {
        CTBackground bg = _slide.getCSld().getBg();
        if(bg != null) {
            return new XSLFBackground(bg, this);
        } else {
            return getMasterSheet().getBackground();
        }
    }

#end
#end
#No. 188552
#File: E:\bishe\1\XSLFSlide.java
#Comment:
    /**
     *
     * @return whether shapes on the master slide should be shown  or not.
     */

#Code:
    public boolean getFollowMasterGraphics(){
        return !_slide.isSetShowMasterSp() || _slide.getShowMasterSp();
    }

#end
#end
#No. 188553
#File: E:\bishe\1\XSLFSlide.java
#Comment:
    /**
     *
     * @param value whether shapes on the master slide should be shown or not.
     */

#Code:
    public void setFollowMasterGraphics(boolean value){
        _slide.setShowMasterSp(value);
    }


#end
#end
#No. 188555
#File: E:\bishe\1\XSLFSlideLayout.java
#Comment:
    /**
     * Slide master object associated with this layout.
     *
     * @return slide master. Never null.
     * @throws IllegalStateException if slide master was not found
     */

#Code:
    public XSLFSlideMaster getSlideMaster() {
        if (_master == null) {
            for (POIXMLDocumentPart p : getRelations()) {
                if (p instanceof XSLFSlideMaster) {
                    _master = (XSLFSlideMaster) p;
                }
            }
        }
        if (_master == null) {
            throw new IllegalStateException("SlideMaster was not found for " + this.toString());
        }
        return _master;
    }



#end
#end
#No. 188557
#File: E:\bishe\1\XSLFSlideLayout.java
#Comment:
    /**
     * Copy placeholders from this layout to the destination slide
     *
     * @param slide destination slide
     */

#Code:
    public void copyLayout(XSLFSlide slide) {
        for (XSLFShape sh : getShapes()) {
            if (sh instanceof XSLFTextShape) {
                XSLFTextShape tsh = (XSLFTextShape) sh;
                Placeholder ph = tsh.getTextType();
                if (ph == null) continue;

                switch (ph) {
                    // these are special and not copied by default
                    case DATETIME:
                    case SLIDE_NUMBER:
                    case FOOTER:
                        break;
                    default:
                        slide.getSpTree().addNewSp().set(tsh.getXmlObject().copy());
                }
            }
        }
    }



#end
#end
#No. 188559
#File: E:\bishe\1\XSLFTextBox.java
#Comment:
    /**
     *
     * @param shapeId   1-based shapeId
     */

#Code:
    static CTShape prototype(int shapeId){
        CTShape ct = CTShape.Factory.newInstance();
        CTShapeNonVisual nvSpPr = ct.addNewNvSpPr();
        CTNonVisualDrawingProps cnv = nvSpPr.addNewCNvPr();
        cnv.setName("TextBox " + shapeId);
        cnv.setId(shapeId + 1);
        nvSpPr.addNewCNvSpPr().setTxBox(true);
        nvSpPr.addNewNvPr();
        CTShapeProperties spPr = ct.addNewSpPr();
        CTPresetGeometry2D prst = spPr.addNewPrstGeom();
        prst.setPrst(STShapeType.RECT);
        prst.addNewAvLst();
        CTTextBody txBody = ct.addNewTxBody();
        txBody.addNewBodyPr();
        txBody.addNewLstStyle();

        return ct;
    }

#end
#end
#No. 188560
#File: E:\bishe\1\XSLFTextShape.java
#Comment:
    /**
     * Specifies that the corresponding shape should be represented by the generating application
     * as a placeholder. When a shape is considered a placeholder by the generating application
     * it can have special properties to alert the user that they may enter content into the shape.
     * Different types of placeholders are allowed and can be specified by using the placeholder
     * type attribute for this element
     *
     * @param placeholder
     */

#Code:
    public void setPlaceholder(Placeholder placeholder){
        CTShape sh =  (CTShape)getXmlObject();
        CTApplicationNonVisualDrawingProps nv = sh.getNvSpPr().getNvPr();
        if(placeholder == null) {
            if(nv.isSetPh()) nv.unsetPh();
        } else {
            nv.addNewPh().setType(STPlaceholderType.Enum.forInt(placeholder.ordinal() + 1));
        }
    }

#end
#end
#No. 188561
#File: E:\bishe\1\XSLFTextShape.java
#Comment:
    /**
     * Compute the cumulative height occupied by the text
     */

#Code:
    public double getTextHeight(){
        // dry-run in a 1x1 image and return the vertical advance
        BufferedImage img = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);
        Graphics2D graphics = img.createGraphics();
        breakText(graphics);
        return drawParagraphs(graphics, 0, 0);
    }

#end
#end
#No. 188562
#File: E:\bishe\1\XSLFTextShape.java
#Comment:
    /**
     * Adjust the size of the shape so it encompasses the text inside it.
     *
     * @return a <code>Rectangle2D</code> that is the bounds of this shape.
     */

#Code:
    public Rectangle2D resizeToFitText(){
        Rectangle2D anchor = getAnchor();
        if(anchor.getWidth() == 0.)  throw new POIXMLException(
                "Anchor of the shape was not set.");
        double height = getTextHeight(); 
        height += 1; // add a pixel to compensate rounding errors
        
        anchor.setRect(anchor.getX(), anchor.getY(), anchor.getWidth(), height);
        setAnchor(anchor);
        
        return anchor;
    }   

#end
#end
#No. 188563
#File: E:\bishe\1\XSLFTextShape.java
#Comment:
    /**
     * break the contained text into lines
    */

#Code:
    private void breakText(Graphics2D graphics){
        if(!_isTextBroken) {
            for(XSLFTextParagraph p : _paragraphs) p.breakText(graphics);

            _isTextBroken = true;
        }
    }


#end
#end
#No. 188565
#File: E:\bishe\1\Xslt.java
#Comment:
    /**
     * If given extension is null return original file name. Else if given file
     * has no extension (not dot in the name) extension is added. Else if there
     * is an extension (there is a dot) the string after dot is replaced
     * with given extension.
     *
     * @param fileName
     * @param extension
     * @return
     */

#Code:
    private static String addExtension(String fileName, String extension) {
        if (extension == null || extension.isEmpty()) {
            return fileName;
        } else {
            return fileName + "." + extension;
        }
    }

#end
#end
#No. 188566
#File: E:\bishe\1\Xslt.java
#Comment:
    /**
     * Return query that can be used to map input files to their output
     * names.
     *
     * If outputName is set is should be used, in such case the extension is ignored.
     *
     * @return
     */

#Code:
    private static String createNamesQuery() {
        return ""
                + "SELECT ?fileName ?outputName WHERE {\n"
                +
                "    ?config a <http://etl.linkedpipes.com/ontology/components/t-xslt/Config> ;\n"
                +
                "        <http://etl.linkedpipes.com/ontology/components/t-xslt/fileInfo> ?fileInfo .\n"
                + "        \n"
                +
                "    ?fileInfo a <http://etl.linkedpipes.com/ontology/components/t-xslt/FileInfo> ;\n"
                +
                "        <http://etl.linkedpipes.com/ontology/components/t-xslt/fileName> ?fileName ;\n"
                +
                "        <http://etl.linkedpipes.com/ontology/components/t-xslt/outputName> ?outputName .\n"
                + "}";
    }

#end
#end
#No. 188567
#File: E:\bishe\1\Xslt.java
#Comment:
    /**
     * Return query that can be used to get configuration parameters
     * for file of given name.
     *
     * @param fileName
     * @return
     */

#Code:
    private static String createParametersQuery(String fileName) {
        return ""
                + "SELECT ?name ?value WHERE {\n"
                +
                "    ?config a <http://etl.linkedpipes.com/ontology/components/t-xslt/Config> ;\n"
                +
                "        <http://etl.linkedpipes.com/ontology/components/t-xslt/fileInfo> ?fileInfo .\n"
                + "        \n"
                +
                "    ?fileInfo a <http://etl.linkedpipes.com/ontology/components/t-xslt/FileInfo> ;\n"
                +
                "        <http://etl.linkedpipes.com/ontology/components/t-xslt/fileName> \""
                + fileName
                + "\" ;\n"
                +
                "        <http://etl.linkedpipes.com/ontology/components/t-xslt/parameter> ?parameter .\n"
                + "        \n"
                +
                "    ?parameter a <http://etl.linkedpipes.com/ontology/components/t-xslt/Parameter> ;\n"
                +
                "        <http://etl.linkedpipes.com/ontology/components/t-xslt/parameterValue> ?value ;\n"
                +
                "        <http://etl.linkedpipes.com/ontology/components/t-xslt/parameterName> ?name .\n"
                + "}";
    }


#end
#end
#No. 188569
#File: E:\bishe\1\XsltFormGeneratorTester.java
#Comment:
	/**
	 * Wait for an user action to stop the test 
	 * @throws ClientException
	 * @throws SOAPException
	 * @throws IOException
	 */

#Code:
	@Test @Ignore
	public final void testWaitUntilRead() throws Exception{
		logger.info("Scaffolding proxy test started, wait for user action to stop !");
		// Just push a key in the console window to stop the test
		System.in.read();
		logger.info("Scaffolding proxy test stopped !");
	}

#end
#end
#No. 188570
#File: E:\bishe\1\XSLTLayout.java
#Comment:
    /**
     * Gets whether location info should be output.
     * @return if location is output.
     */

#Code:
    public synchronized boolean getLocationInfo() {
      return locationInfo;
    }

#end
#end
#No. 188571
#File: E:\bishe\1\XSLTLayout.java
#Comment:
    /**
     * Sets whether MDC key-value pairs should be output, default false.
     * @param flag new value.
     */

#Code:
    public synchronized void setProperties(final boolean flag) {
      properties = flag;
    }

#end
#end
#No. 188572
#File: E:\bishe\1\XSLTLayout.java
#Comment:
    /**
     * Gets whether MDC key-value pairs should be output.
     * @return true if MDC key-value pairs are output.
     */

#Code:
    public synchronized boolean getProperties() {
      return properties;
    }

#end
#end
#No. 188573
#File: E:\bishe\1\XSLTLayout.java
#Comment:
    /**
     * Gets whether throwables should not be output.
     * @return true if throwables should not be output.
     */

#Code:
    public synchronized boolean ignoresThrowable() {
        return ignoresThrowable;
    }

#end
#end
#No. 188574
#File: E:\bishe\1\XSLTLayout.java
#Comment:
    /**
     * Sets whether throwables should not be output.
     * @param ignoresThrowable if true, throwables should not be output.
    */

#Code:
    public synchronized void setIgnoresThrowable(boolean ignoresThrowable) {
      this.ignoresThrowable = ignoresThrowable;
    }

#end
#end
#No. 188575
#File: E:\bishe\1\XSLTLayout.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    public boolean parseUnrecognizedElement(final Element element,
                                            final Properties props)
            throws Exception {
        if (XSLT_NS.equals(element.getNamespaceURI()) ||
                element.getNodeName().indexOf("transform") != -1 ||
                element.getNodeName().indexOf("stylesheet") != -1) {
            //
            //   DOMConfigurator typically not namespace aware
            //     serialize tree and reparse.
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            DOMSource source = new DOMSource(element);
            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            Transformer transformer = transformerFactory.newTransformer();
            transformer.transform(source, new StreamResult(os));

            ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
            DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
            domFactory.setNamespaceAware(true);
            Document xsltdoc = domFactory.newDocumentBuilder().parse(is);
            setTransform(xsltdoc);
            return true;
        }
        return false;
    }



#end
#end
#No. 188577
#File: E:\bishe\1\XSParser.java
#Comment:
    /**
     * Parse an XML Schema document from String specified
     * 
     * @param schema    String data to parse. If provided, this will always be treated as a
     *                  sequence of 16-bit units (UTF-16 encoded characters). If an XML
     *                  declaration is present, the value of the encoding attribute
     *                  will be ignored.
     * @param baseURI   The base URI to be used for resolving relative
     *                  URIs to absolute URIs.
     */

#Code:
    public XSModel parseString(String schema, String baseURI){
        return xsLoader.load(new DOMInputImpl(null, null, baseURI, schema, null));
    }

#end
#end
#No. 188578
#File: E:\bishe\1\XSpeechRecognizer.java
#Comment:
    /**
     * Fire an intent to start the speech recognition activity.
     *
     * @param args Argument array with the following string args: [req code][number of matches]
     */

#Code:
    private void startSpeechRecognitionActivity(JSONArray args) {

        int maxMatches = 0;
        String language = Locale.getDefault().toString();

        try {
            if (args.length() > 0) {
                // Maximum number of matches, 0 means the recognizer decides
                String temp = args.getString(0);
                maxMatches = Integer.parseInt(temp);
            }
            if (args.length() > 1) {
                // Language
                language = args.getString(1);
            }
        }
        catch (Exception e) {
            Log.e(TAG, String.format("startSpeechRecognitionActivity exception: %s", e.toString()));
        }

        // Create the intent and set parameters
        final Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
        // intent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE,"voice.recognition.test");
        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, language);

        if (maxMatches > 0)
            intent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, maxMatches);

        Handler loopHandler = new Handler(Looper.getMainLooper());
        loopHandler.post(new Runnable() {

            @Override
            public void run() {
                recognizer.startListening(intent);
            }
            
        });
    }

#end
#end
#No. 188579
#File: E:\bishe\1\XSpeechRecognizer.java
#Comment:
    /*
     *  Get the list of supported languages
     */

#Code:
    private void getSupportedLanguages() {
    	if (languageDetailsChecker == null){
    		languageDetailsChecker = new LanguageDetailsChecker(callbackContext);
    	}
    	Intent detailsIntent = new Intent(RecognizerIntent.ACTION_GET_LANGUAGE_DETAILS);
    	cordova.getActivity().sendOrderedBroadcast(detailsIntent, null, languageDetailsChecker, null, Activity.RESULT_OK, null, null);
	}

#end
#end
#No. 188580
#File: E:\bishe\1\XSSFSheetHelper.java
#Comment:
	/**
	 * @return 0-based repeating row numbers
	 */

#Code:
	public static int[] getRepeatingRows(XSSFWorkbook book, int sheet) {
		return new XSSFSheetHelper(book, sheet).parseRows();
	}


#end
#end
#No. 188582
#File: E:\bishe\1\XSStorage.java
#Comment:
    /**
     * Loads data from file
     */

#Code:
    private void loadData() throws IOException {
        data.clear();
        int size = integerSerialization.read(file);
        for (int i = 0; i < size; i++) {
            data.put(keySerialization.read(file), valueSerialization.read(file));
        }
    }

#end
#end
#No. 188583
#File: E:\bishe\1\XSStorage.java
#Comment:
    /**
     * Writes data to storage file using serializators
     */

#Code:
    private void save() throws IOException {
        file.seek(0);
        // Clearing the contents of file before writing
        file.setLength(0);
        integerSerialization.write(file, data.size());
        for (K key: data.keySet()) {
            keySerialization.write(file, key);
            valueSerialization.write(file, data.get(key));
        }
        file.close();
    }

#end
#end
#No. 188584
#File: E:\bishe\1\XSStorage.java
#Comment:
    /**
     * Throws an exception is the storage is closed.
     */

#Code:
    void checkIfStorageIsClosed() {
        if (isStorageClosed) {
            throw new RuntimeException("Storage is closed.");
        }
    }

#end
#end
#No. 188586
#File: E:\bishe\1\XstreamObjectIdConverter.java
#Comment:
/**
 * @author toddf
 * @since Feb 16, 2011
 */

#Code:
public class XstreamObjectIdConverter
implements SingleValueConverter
{
	@SuppressWarnings("rawtypes")
    @Override
	public boolean canConvert(Class aClass)
	{
		return ObjectId.class.isAssignableFrom(aClass);
	}

	@Override
	public Object fromString(String value)
	{
		return new ObjectId(value);
	}

	@Override
	public String toString(Object objectId)
	{
		return ((ObjectId) objectId).toString();
	}
}

#end
#end
#No. 188587
#File: E:\bishe\1\XstreamOidConverter.java
#Comment:
/**
 * @author toddf
 * @since Feb 16, 2011
 */

#Code:
public class XstreamOidConverter
implements SingleValueConverter
{
	@SuppressWarnings("rawtypes")
    @Override
	public boolean canConvert(Class aClass)
	{
		return ObjectId.class.isAssignableFrom(aClass);
	}

	@Override
	public Object fromString(String value)
	{
		return (ObjectId) Identifiers.MONGOID.parse(value).primaryKey();
	}

	@Override
	public String toString(Object objectId)
	{
		return ((ObjectId) objectId).toString();
	}
}

#end
#end
#No. 188588
#File: E:\bishe\1\XstreamUuidConverter.java
#Comment:
/**
 * @author toddf
 * @since Feb 16, 2011
 */

#Code:
public class XstreamUuidConverter
implements SingleValueConverter
{
	@SuppressWarnings("rawtypes")
    @Override
	public boolean canConvert(Class aClass)
	{
		return UUID.class.isAssignableFrom(aClass);
	}

	@Override
	public Object fromString(String value)
	{
		return UuidConverter.parse(value);
	}

	@Override
	public String toString(Object objectId)
	{
		return UuidConverter.format((UUID) objectId);
	}
}

#end
#end
#No. 188595
#File: E:\bishe\1\XSwipeRefreshLayout.java
#Comment:
    /**
     * @param loading
     */

#Code:
    public void setLoading(boolean loading) {
        isLoading = loading;
        if (isLoading) {
            mListView.addFooterView(mListViewFooter);
        } else {
            mListView.removeFooterView(mListViewFooter);
            mYDown = 0;
            mLastY = 0;
        }
    }

#end
#end
#No. 188596
#File: E:\bishe\1\XSwipeRefreshLayout.java
#Comment:
    /**
     * @param loadListener
     */

#Code:
    public void setOnLoadListener(OnLoadListener loadListener) {
        mOnLoadListener = loadListener;
    }

#end
#end
#No. 188597
#File: E:\bishe\1\XTable.java
#Comment:
    /**
     * Set the width of the columns as percentages.
     *
     * @param table the {@link JTable} whose columns will be set
     * @param percentages the widths of the columns as percentages; note: this
     * method does NOT verify that all percentages add up to 100% and for the
     * columns to appear properly, it is recommended that the widths for ALL
     * columns be specified
     *
     * @see
     * http://kahdev.wordpress.com/2011/10/30/java-specifying-the-column-widths-of-a-jtable-as-percentages/
     */

#Code:
    public static void setWidthAsPercentages(JTable table, double... percentages) {
        final double factor = 10000;
        TableColumnModel model = table.getColumnModel();
        for (int columnIndex = 0; columnIndex < percentages.length; columnIndex++) {
            TableColumn column = model.getColumn(columnIndex);
            column.setPreferredWidth((int) (percentages[columnIndex] * factor));
        }
    }

#end
#end
#No. 188598
#File: E:\bishe\1\XtextResourceFactory.java
#Comment:
/**
 * Factory of <code>{@link XtextResource}</code>s.
 *
 * @author alruiz@google.com (Alex Ruiz)
 */

#Code:
@Singleton public class XtextResourceFactory {
  @Inject private IResourceSetProvider resourceSetProvider;
  @Inject private IProjects projects;

  /**
   * Creates a new <code>{@link XtextResource}</code>.
   * @param uri the URI of the file containing the EMF model.
   * @param contents the contents of the file.
   * @return the created {@code XtextResource}.
   * @throws IOException if something goes wrong.
   */
  public XtextResource createResource(String uri, String contents) throws IOException {
    return createResource(createURI(uri), contents);
  }

#end
#end
#No. 188599
#File: E:\bishe\1\XtextResourceFactory.java
#Comment:
  /**
   * Creates a new <code>{@link XtextResource}</code>.
   * @param uri the URI of the file containing the EMF model.
   * @param contents the contents of the file.
   * @return the created {@code XtextResource}.
   * @throws IOException if something goes wrong.
   */

#Code:
  public XtextResource createResource(URI uri, String contents) throws IOException {
    // TODO get project from URI.
    ResourceSet resourceSet = resourceSetProvider.get(projects.activeProject());
    XtextResource resource = (XtextResource) resourceSet.createResource(uri, UNSPECIFIED_CONTENT_TYPE);
    resource.load(new StringInputStream(contents), singletonMap(OPTION_ENCODING, UTF_8));
    resolveLazyCrossReferences(resource, NullImpl);
    return resource;
  }

#end
#end
#No. 188600
#File: E:\bishe\1\XtnData.java
#Comment:
    /**
     * given a uid, signal the entry as rewritten under the xtn
     *
     * @param uid - uid of entry to signal
     */

#Code:
    public void signalRewrittenEntry(String uid) {
        if (_reWrittenEntries == null)
            _reWrittenEntries = new ConcurrentHashMap<String, String>();

        _reWrittenEntries.put(uid, uid);

    }

#end
#end
#No. 188601
#File: E:\bishe\1\XtnData.java
#Comment:
    /**
     * check weather an entry is rewritten under xtn
     *
     * @param uid - uid of entry to check
     * @return true is entry with this uid is rewritten under xtn
     */

#Code:
    public boolean isReWrittenEntry(String uid) {
        return _reWrittenEntries != null && _reWrittenEntries.containsKey(uid);

    }

#end
#end
#No. 188602
#File: E:\bishe\1\XtnData.java
#Comment:
    /**
     * remove reWritten entry indication if exists
     *
     * @param uid -uid of entry
     */

#Code:
    public void removeRewrittenEntryIndication(String uid) {
        if (_reWrittenEntries != null)
            _reWrittenEntries.remove(uid);
    }

#end
#end
#No. 188603
#File: E:\bishe\1\XtnData.java
#Comment:
    /**
     * get the relevant entries under the xtn according to selected type
     *
     * @param selectType - selected type of entries under the xtn, from com.j_spaces.core.sadapter.SelctType
     * @return IStoredList<PEntry>
     */

#Code:
    public IStoredList<IEntryCacheInfo> getUnderXtnEntries(int selectType) {
        IStoredList<IEntryCacheInfo> entries = null;
        switch (selectType) {
            case SelectType.NEW_ENTRIES:
                entries = _newEntries;
                break;
            case SelectType.NEED_NOTIFY_ENTRIES:
                entries = _needNotifyEntries;
                break;
            case SelectType.TAKEN_ENTRIES:
                entries = _takenEntries;
                break;
            case SelectType.ALL_FIFO_ENTRIES:
                entries = _lockedFifoEntries;
                break;

            default:
                entries = _lockedEntries;
        }
        return entries;
    }

#end
#end
#No. 188604
#File: E:\bishe\1\XtnData.java
#Comment:
    /**
     * @return the xtn
     */

#Code:
    public ServerTransaction getXtn() {
        return _xtnEntry.m_Transaction;
    }

#end
#end
#No. 188605
#File: E:\bishe\1\XtnData.java
#Comment:
    /**
     * @return the xtn entry
     */

#Code:
    public XtnEntry getXtnEntry() {
        return _xtnEntry;
    }

#end
#end
#No. 188606
#File: E:\bishe\1\XtnData.java
#Comment:
    /**
     * When user operation under transaction is upgraded from read to update/take, the order of
     * entry should be changed to the most recent, so that the changes in prepare come in the right
     * order. For example:
     *
     * read object A read object B take object B take object A
     *
     * will cause a prepare of: B,A instead of A,B.
     *
     * Repeatable read doesn't cause the upgrade since it is not reflected in prepare.
     */

#Code:
    public void updateLock(IEntryCacheInfo pEntry, OperationID operationID, boolean isReadOperation, boolean fifo) {
        // new entries and read operations order is not changed
        IStoredList<IEntryCacheInfo> newEntries = !isReadOperation ? getNewEntries() : null;
        if (!isReadOperation && (newEntries == null || !newEntries.contains(pEntry))) {
            // update entry ordering 
            IStoredList<IEntryCacheInfo> lockedEntries = getLockedEntries(true);
            lockedEntries.removeByObject(pEntry);
            lockedEntries.add(pEntry);
            if (fifo) {
                IStoredList<IEntryCacheInfo> lockedFifoEntries = getLockedFifoEntries(true);

                lockedFifoEntries.removeByObject(pEntry);
                lockedFifoEntries.add(pEntry);
            }

        }

        if (operationID != null) {
            Map<String, OperationID> entriesOperationIDs = _entriesOperationIDs;
            if (entriesOperationIDs == null)
                _entriesOperationIDs = entriesOperationIDs = new Hashtable<String, OperationID>();// ConcurrentHashMap<String, OperationID>();
            entriesOperationIDs.put(pEntry.getUID(), operationID);
        }

    }

#end
#end
#No. 188607
#File: E:\bishe\1\XtnEntry.java
#Comment:
    /**
     * Constructs a new Xtn Entry.
     */

#Code:
    public XtnEntry(ServerTransaction xtn) {
        super(xtn);
        _xtnData = new XtnData(this);
        if (!(xtn.mgr instanceof LocalTransactionManager))
            _joinLock = new Object();
        else
            _joinLock = null;

        _allowFifoNotificationsForNonFifoType = new FifoBackgroundRequest.AllowFifoNotificationsForNonFifoType();
    }

#end
#end
#No. 188608
#File: E:\bishe\1\XtnEntry.java
#Comment:
    /**
     * Returns true is new operations can still attach to this transaction, false otherwise
     * (transaction was already committed for example)
     *
     * @return true if XtnStatus UNINITIALIZED or BEGUN else false
     */

#Code:
    public boolean isActive() {
        if (getStatus() == XtnStatus.UNINITIALIZED || getStatus() == XtnStatus.BEGUN)
            return true;

        return false;
    }

#end
#end
#No. 188609
#File: E:\bishe\1\XtnInfo.java
#Comment:
    /**
     * Constructs a new Xtn info.
     */

#Code:
    public XtnInfo(ServerTransaction xtn) {
        m_Transaction = xtn;
        setStatus(XtnStatus.UNINITIALIZED);
        m_Readonly = true;
        m_Active = true;
        m_startTime = SystemTime.timeMillis();
        _usage = 1;
        _lastUsageTime = m_startTime;
        _onlyEmbeddedJoins = true;
    }

#end
#end
#No. 188610
#File: E:\bishe\1\XtnInfo.java
#Comment:
    /**
     * @return the isFromReplication
     */

#Code:
    public boolean isFromReplication() {
        return _isFromReplication;
    }

#end
#end
#No. 188611
#File: E:\bishe\1\XtnInfo.java
#Comment:
    /**
     * @param isFromReplication the isFromReplication to set
     */

#Code:
    public void setFromReplication(boolean isFromReplication) {
        _isFromReplication = isFromReplication;
    }

#end
#end
#No. 188612
#File: E:\bishe\1\XtnInfo.java
#Comment:
    /**
     * @param m_Status the m_Status to set
     */

#Code:
    public void setStatus(XtnStatus m_Status) {
        this._status = m_Status;
    }

#end
#end
#No. 188613
#File: E:\bishe\1\XtnInfo.java
#Comment:
    /**
     * @return the m_Status
     */

#Code:
    public XtnStatus getStatus() {
        return _status;
    }

#end
#end
#No. 188614
#File: E:\bishe\1\XtnInfo.java
#Comment:
    /**
     * @return true if the entry was created by a gateway operation.
     */

#Code:
    public boolean isFromGateway() {
        return _gatewayInfo != null;
    }

#end
#end
#No. 188615
#File: E:\bishe\1\XtnStatus.java
#Comment:
/**
 * A Constants class for status of a transaction in the transactions table.
 */

#Code:
public enum XtnStatus {
    // initial transaction state - before calling join
    UNINITIALIZED,
    // uninitialized and join failed- xtn is removed
    UNINITIALIZED_FAILED,

    // transaction state after successful join
    BEGUN,
    PREPARING,
    PREPARED,
    COMMITING,
    COMMITED,
    ROLLING,
    ROLLED,
    //error occured- will try to rollback
    ERROR,
    //xtn is marked as unused, will be cleaned by LeaseManager
    UNUSED


}

#end
#end
#No. 188616
#File: E:\bishe\1\XTraceBaggageInterface.java
#Comment:
    /** Looks at this thread's current baggage to determine whether an X-Trace task ID is being propagated
     * 
     * @return true if an X-Trace task ID is being propagated by the current execution */

#Code:
    public static boolean hasTaskID() {
        return BaggageContents.contains(XTRACE_BAGGAGE_NAMESPACE, TASK_ID_BAGGAGE_FIELD);
    }

#end
#end
#No. 188617
#File: E:\bishe\1\XTraceBaggageInterface.java
#Comment:
    /** Looks at this thread's current baggage to determine whether any X-Trace parent event IDs are being propagated
     * 
     * @return true if X-Trace parent event IDs are being propagated */

#Code:
    public static boolean hasParents() {
        return BaggageContents.contains(XTRACE_BAGGAGE_NAMESPACE, PARENT_EVENT_ID_BAGGAGE_FIELD);
    }

#end
#end
#No. 188618
#File: E:\bishe\1\XTraceBaggageInterface.java
#Comment:
    /** Looks at this thread's current baggage, and returns the X-Trace task ID if it contains one
     * 
     * @return the X-Trace Task ID for the current execution, or 0 if none was found */

#Code:
    public static long getTaskID(AtomicInteger counter) {
        // Get task ID from the baggage
        Set<ByteString> taskIds = BaggageContents.get(XTRACE_BAGGAGE_NAMESPACE, TASK_ID_BAGGAGE_FIELD);
        
        // Set the count of task IDs
        if (counter != null) {
            counter.set(taskIds.size());
        }

        // If we have no IDs use discovery mode ID if we're in discovery mode
        if (taskIds.size() == 0 && XTraceSettings.discoveryMode()) {
            return getDiscoveryModeId();
        }

        // Warn if multiple task IDs
        if (taskIds.size() > 1) {
            log.warn("Found multiple X-Trace task IDs, this is indicative of tracing context leak");
        }

        // Return a valid task ID.  If there are multiple task IDs, we add them, to make them easy to identify in debug
        long taskId = 0;
        for (ByteString taskIdBytes : taskIds) {
            if (taskIdBytes.size() == 8) {
                taskId += ByteStrings.toLong(taskIdBytes);
            } else {
                log.warn("Found invalid X-Trace task ID: {}", taskIdBytes);
            }
        }
        return taskId;
    }

#end
#end
#No. 188619
#File: E:\bishe\1\XTraceBaggageInterface.java
#Comment:
    /** Set the task ID in the thread's current baggage to the specified task ID
     * 
     * @param taskId The task ID to set for the current execution */

#Code:
    public static void setTaskID(long taskId) {
        BaggageContents.replace(XTRACE_BAGGAGE_NAMESPACE, TASK_ID_BAGGAGE_FIELD, ByteStrings.copyFrom(taskId));
    }

#end
#end
#No. 188620
#File: E:\bishe\1\XTraceBaggageInterface.java
#Comment:
    /** Looks at this thread's current baggage, and returns the X-Trace parent event IDs if there are any
     * 
     * @return an array containing the X-Trace parent event IDs of the current execution, possibly empty */

#Code:
    public static Collection<Long> getParentEventIds() {
        // Get event IDs from the baggage
        Set<ByteString> eventIds = BaggageContents.get(XTRACE_BAGGAGE_NAMESPACE, PARENT_EVENT_ID_BAGGAGE_FIELD);
        if (eventIds.size() == 0) {
            return Collections.emptySet();
        }

        // Can be zero or more 8-byte event IDs
        Collection<Long> parentEventIds = Lists.newArrayList();
        for (ByteString parentEventId : eventIds) {
            if (parentEventId.size() == 8) {
                parentEventIds.add(ByteStrings.toLong(parentEventId));
            } else {
                log.warn("Encountered parent event ID with incorrect length {}: {}", parentEventId.size(),
                        parentEventId);
            }
        }
        return parentEventIds;
    }

#end
#end
#No. 188621
#File: E:\bishe\1\XTraceBaggageInterface.java
#Comment:
    /** Set the parent event ID in the thread's current baggage to the specified event ID
     * 
     * @param parentEventId The event ID to set for the current execution */

#Code:
    public static void setParentEventId(long parentEventId) {
        BaggageContents.replace(XTRACE_BAGGAGE_NAMESPACE, PARENT_EVENT_ID_BAGGAGE_FIELD,
                ByteStrings.copyFrom(parentEventId));
    }

#end
#end
#No. 188622
#File: E:\bishe\1\XTraceBaggageInterface.java
#Comment:
    /** Set the parent event IDs in the thread's current baggage to the specified event IDs
     * 
     * @param parentEventIds The event IDs to set for the current execution */

#Code:
    public static void setParentEventIds(long... parentEventIds) {
        Set<ByteString> parentEventIdSet = Sets.newHashSetWithExpectedSize(parentEventIds.length);
        for (int i = 0; i < parentEventIds.length; i++) {
            parentEventIdSet.add(ByteStrings.copyFrom(parentEventIds[i]));
        }
        BaggageContents.replace(XTRACE_BAGGAGE_NAMESPACE, PARENT_EVENT_ID_BAGGAGE_FIELD, parentEventIdSet);
    }

#end
#end
#No. 188623
#File: E:\bishe\1\XTraceGCUtils.java
#Comment:
    /**
     * Registers the provided listener to receive GC event callbacks
     * 
     * @param callback
     *            a callback to call when a GC event occurs
     */

#Code:
    public static void registerGCListener(XTraceGCCallback callback) {
        MBeanServer server = ManagementFactory.getPlatformMBeanServer();
        XTraceGCCallbackNotificationListener listener = new XTraceGCCallbackNotificationListener(callback);
        for (GarbageCollectorMXBean bean : gcbeans) {
            try {
                server.addNotificationListener(bean.getObjectName(), listener, null, bean);
            } catch (InstanceNotFoundException e) {
                System.out.println("GC notifications registerListener Warning: " + e.getMessage());
            }
        }
    }

#end
#end
#No. 188624
#File: E:\bishe\1\XTraceGCUtils.java
#Comment:
    /**
     * Ask each GC bean for its elapsed collection time
     */

#Code:
    public static long calculateElapsedGC() {
        long timeMillis = 0;
        for (GarbageCollectorMXBean gcbean : gcbeans) {
            timeMillis += gcbean.getCollectionTime();
        }
        return timeMillis;
    }

#end
#end
#No. 188625
#File: E:\bishe\1\XTraceGCUtils.java
#Comment:
    /**
     * Turn on or off a thread that spams calls to System.GC
     * 
     * @param enabled
     *            turn the thread on or off
     */

#Code:
    public static void spam(boolean enabled) {
        if (enabled)
            spammer.start();
        else
            spammer.stop();
    }

#end
#end
#No. 188626
#File: E:\bishe\1\XTraceGCUtils.java
#Comment:
    /**
     * Try to force GC once by repeatedly calling System.gc() until our weak
     * reference disappears This could cause multiple GCs until our object is
     * actually collected
     */

#Code:
    public static void force() {
        /*
         * http://stackoverflow.com/questions/1481178/forcing-garbage-collection-
         * in-java "The jlibs library has a good utility class for garbage
         * collection. You can force garbage collection using a nifty little
         * trick with WeakReference objects." "RuntimeUtil.gc() from the jlibs:"
         */

        Object obj = new Object();
        WeakReference<Object> ref = new WeakReference<Object>(obj);
        obj = null;
        while (ref.get() != null) {
            System.gc();
        }
    }

#end
#end
#No. 188627
#File: E:\bishe\1\XTraceLoggerImpl.java
#Comment:
    /**
     * Create an X-Trace logger for the provided agent, that will log reports to
     * the provided X-Trace reporter
     * 
     * @param agent
     *            The name of this logger
     * @param reporter
     *            The reporter to send reports to
     */

#Code:
    public XTraceLoggerImpl(String agent, XTraceReporter reporter) {
        this.agent = agent;
        this.reporter = reporter;
    }

#end
#end
#No. 188628
#File: E:\bishe\1\XTraceLoggerImpl.java
#Comment:
    /**
     * XTrace logger is only valid if the current execution has an X-Trace Task
     * ID
     * 
     * @return true if the current execution is valid and can log, false
     *         otherwise
     */

#Code:
    public boolean valid() {
        return XTraceSettings.discoveryMode() || XTraceBaggageInterface.hasTaskID();
    }



#end
#end
#No. 188630
#File: E:\bishe\1\XTraceReport.java
#Comment:
    /**
     * Adds standard fields to this report, such as hostname, timestamp, etc.
     * 
     * @return This report, with additional fields added
     */

#Code:
    public XTraceReport addStandardFields() {
        builder.setHost(host);
        builder.setProcessId(procid);
        builder.setProcessName(Utils.getProcessName());
        builder.setThreadId((int) Thread.currentThread().getId());
        builder.setThreadName(Thread.currentThread().getName());
        builder.setTimestamp(System.currentTimeMillis());
        builder.setHrt(System.nanoTime());
        return this;
    }

#end
#end
#No. 188631
#File: E:\bishe\1\XTraceReport.java
#Comment:
    /**
     * Turns this report into an X-Trace "event", by adding the current thread's
     * parent event IDs to the report, generating a random event ID for the
     * report, and updating the current thread's parent event IDs to this
     * report's event ID
     * @param joinPoint 
     * 
     * @return This report, with additional fields added
     */

#Code:
    public XTraceReport makeXTraceEvent(StaticPart joinPoint) {
        AtomicInteger counter = new AtomicInteger();
        long taskId = XTraceBaggageInterface.getTaskID(counter);
        if (counter.get() > 1) {
            builder.addTags("TracingError");
        }
        long eventId = XTrace.randomId();
        Collection<Long> parentIds = XTraceBaggageInterface.getParentEventIds();
        setXTrace(taskId, eventId, parentIds);
        XTraceBaggageInterface.setParentEventId(eventId);
        return this;
    }

#end
#end
#No. 188632
#File: E:\bishe\1\XTraceReport.java
#Comment:
    /**
     * Set the label of this report to the provided message. The message can
     * have variable-substitution characters {} for replacement with the
     * provided vars. Further variables can be specified as key-value pairs to
     * be added to the report. See the documentation of XTraceLogger for more
     * details.
     */

#Code:
    public XTraceReport setMessage(String message, Object... vars) {
        int varsIndex = 0;
        if (message != null) {
            // Split the string based on the replacement variable {}
            String[] tokens = StringUtils.splitByWholeSeparatorPreserveAllTokens(message, "{}");
//            System.out.println(tokens.length + " tokens");
//            for (int i = 0; i < tokens.length; i++) {
//                System.out.println("\"" + tokens[i] + "\" ");
//            }

            // Start constructing the message
            StringBuilder replaced = new StringBuilder();
            if (tokens.length > 0) {
                replaced.append(tokens[0]);
            }

            // Replace instances of {} with a var
            while (varsIndex + 1 < tokens.length && varsIndex < vars.length) {
                replaced.append(vars[varsIndex] == null ? "null" : vars[varsIndex].toString());
                replaced.append(tokens[varsIndex + 1]);
                varsIndex++;
            }

            builder.setLabel(replaced.toString());
        }

        // Put remaining vars as kv pairs
        while (varsIndex + 1 < vars.length) {
            put(vars[varsIndex++], vars[varsIndex++]);
        }

        return this;
    }

#end
#end
#No. 188633
#File: E:\bishe\1\XTraceReport.java
#Comment:
    /**
     * Add a key-value pair to the report
     * 
     * @param key
     *            The key to add to the report. If this is null, the key-value
     *            pair will be ignored
     * @param value
     *            The value to add for the key. If this is null, the string
     *            "null" will be added
     * @return This report, with the added k-v pair
     */

#Code:
    public XTraceReport put(Object key, Object value) {
        if (key != null) {
            builder.addKey(key.toString());
            builder.addValue(value == null ? "null" : value.toString());
        }
        return this;
    }

#end
#end
#No. 188634
#File: E:\bishe\1\XTraceReport.java
#Comment:
    /**
     * Create a new, empty report
     */

#Code:
    public static XTraceReport create() {
        return new XTraceReport();
    }

#end
#end
#No. 188635
#File: E:\bishe\1\XTraceReport.java
#Comment:
    /**
     * Add a report decorator. The decorate function will be called for every
     * X-Trace report that is sent
     */

#Code:
    public static synchronized void addDecorator(Decorator d) {
        decorators.add(d);
    }

#end
#end
#No. 188636
#File: E:\bishe\1\XTraceReport.java
#Comment:
    /**
     * Apply any registered decorators to this report
     */

#Code:
    public XTraceReport applyDecorators() {
        for (Decorator d : decorators) {
            try {
                d.decorate(this);
            } catch (Exception e) {
                // Do nothing
            }
        }
        return this;
    }


#end
#end
#No. 188639
#File: E:\bishe\1\XTraceSettings.java
#Comment:
    /**
     * If reporting is turned off, returns false. If the logging class is in the
     * disabled set, returns false. If logging is enabled by default, returns
     * true. If the logging class is in the enabled set, returns true.
     * Otherwise, returns false
     * 
     * @param loggingClass
     *            The logging class to check
     * @return true if the class is allowed to log, false otherwise.
     */

#Code:
    public static boolean Enabled(String loggingClass) {
        if (!On()) {
            return false;
        }
        if (instance().classesDisabled.contains(loggingClass)) {
            return false;
        }
        if (instance().defaultEnabled) {
            return true;
        }
        if (instance().classesEnabled.contains(loggingClass)) {
            return true;
        }
        return false;
    }

#end
#end
#No. 188640
#File: E:\bishe\1\XWingPlayer.java
#Comment:
    /**
     * Returns true if the player has defeated every other person in their score group.
     * 
     * @param t
     * @return
     */

#Code:
    public boolean isHeadToHeadWinner(XWingTournament t) {

        if (t != null) {
            int score = getScore(t);
            List<XWingPlayer> players = new ArrayList<XWingPlayer>();
            for (XWingPlayer p : t.getXWingPlayers()) {
                if (p != this && p.getScore(t) == score) {
                    players.add(p);
                }
            }

            if (players.isEmpty()) {
                return false;
            }

            playerLoop: for (XWingPlayer p : players) {
                for (XWingMatch m : p.getMatches(t)) {
                    if (m.getWinner() != null && m.getWinner() == this) {
                        continue playerLoop;
                    }
                }
                return false;
            }
        }

        return true;
    }

#end
#end
#No. 188641
#File: E:\bishe\1\XWingRoundPanel.java
#Comment:
        /**
         * This function sets the combo box value to the winner of the match based on points.
         */

#Code:
        private void setResultsCombo() {

            boolean enterOnlyPoints = XWingModule.getInstance().getOptions().isEnterOnlyPoints();

            if (match.getPlayer1PointsDestroyed() != null || match.getPlayer2PointsDestroyed() != null) {

                Integer p1points = match.getPlayer1PointsDestroyed() == null ? 0 : match.getPlayer1PointsDestroyed();
                Integer p2points = match.getPlayer2PointsDestroyed() == null ? 0 : match.getPlayer2PointsDestroyed();

                if (p1points.equals(p2points)) {
                    // Only reset the result if it was not enabled before. This
                    // prevents the combo box from resetting if the result
                    // didn't actually change.
                    if (getResultCombo().isEnabled() == false) {
                        getResultCombo().setSelectedIndex(0);
                    }
                    getResultCombo().setEnabled(true);
                }
                if (p1points > p2points) {
                    getResultCombo().setSelectedIndex(1);
                    getResultCombo().setEnabled(!enterOnlyPoints);
                }

                if (p2points > p1points) {
                    getResultCombo().setSelectedIndex(2);
                    getResultCombo().setEnabled(!enterOnlyPoints);
                }
            } else {
                getResultCombo().setSelectedIndex(0);
                getResultCombo().setEnabled(!enterOnlyPoints);
            }
        }

#end
#end
#No. 188642
#File: E:\bishe\1\XWingRules.java
#Comment:
	/**
	 * Create the GUI and show it. For thread safety, this method should be
	 * invoked from the event dispatch thread.
	 */

#Code:
	private static void createAndShowGUI() {
		if (useSystemLookAndFeel) {
			try {
				UIManager.setLookAndFeel(UIManager
						.getSystemLookAndFeelClassName());
			} catch (Exception e) {
				System.err.println("Couldn't use system look and feel.");
			}
		}

		// Create and set up the window.
		JFrame frame = new JFrame("X-Wing Rules");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		// Add content to the window.
		frame.add(new XWingRules());

		// Display the window.
		frame.pack();
		frame.setVisible(true);
	}

#end
#end
#No. 188643
#File: E:\bishe\1\XWingTournament.java
#Comment:
    /**
     * Returns any players have have played at least one match. This calls back dropped players into the list.
     * 
     * @return
     */

#Code:
    public Set<XWingPlayer> getAllXWingPlayers() {
        // TreeSets and Head To Head comparisons can have problems.
        // Do not use them together.
        Set<XWingPlayer> allPlayers = new TreeSet<XWingPlayer>(new XWingComparator(this, XWingComparator.rankingCompareNoHeadToHead));

        for (XWingRound r : getAllRounds()) {
            for (XWingMatch m : r.getMatches()) {
                if (m.isBye()) {
                    allPlayers.add(m.getPlayer1());
                } else {
                    allPlayers.add(m.getPlayer1());
                    if (m.getPlayer2() != null) {
                        allPlayers.add(m.getPlayer2());
                    }
                }
            }
        }

        allPlayers.addAll(players);

        return allPlayers;
    }

#end
#end
#No. 188665
#File: E:\bishe\1\XYBarRenderer.java
#Comment:
    /**
     * Returns <code>true</code> if the specified anchor point is inside a bar.
     *
     * @param anchor  the anchor point.
     *
     * @return A boolean.
     */

#Code:
    private boolean isInternalAnchor(ItemLabelAnchor anchor) {
        return anchor == ItemLabelAnchor.CENTER
               || anchor == ItemLabelAnchor.INSIDE1
               || anchor == ItemLabelAnchor.INSIDE2
               || anchor == ItemLabelAnchor.INSIDE3
               || anchor == ItemLabelAnchor.INSIDE4
               || anchor == ItemLabelAnchor.INSIDE5
               || anchor == ItemLabelAnchor.INSIDE6
               || anchor == ItemLabelAnchor.INSIDE7
               || anchor == ItemLabelAnchor.INSIDE8
               || anchor == ItemLabelAnchor.INSIDE9
               || anchor == ItemLabelAnchor.INSIDE10
               || anchor == ItemLabelAnchor.INSIDE11
               || anchor == ItemLabelAnchor.INSIDE12;
    }

#end
#end
#No. 188666
#File: E:\bishe\1\XYBarRenderer.java
#Comment:
    /**
     * Returns the lower and upper bounds (range) of the x-values in the
     * specified dataset.  Since this renderer uses the x-interval in the
     * dataset, this is taken into account for the range.
     *
     * @param dataset  the dataset (<code>null</code> permitted).
     *
     * @return The range (<code>null</code> if the dataset is
     *         <code>null</code> or empty).
     */

#Code:
    public Range findDomainBounds(XYDataset dataset) {
        if (dataset != null) {
            return DatasetUtilities.findDomainBounds(dataset, true);
        }
        else {
            return null;
        }
    }

#end
#end
#No. 188667
#File: E:\bishe\1\XYBarRenderer.java
#Comment:
    /**
     * Returns the lower and upper bounds (range) of the y-values in the
     * specified dataset.  If the renderer is plotting the y-interval from the
     * dataset, this is taken into account for the range.
     *
     * @param dataset  the dataset (<code>null</code> permitted).
     *
     * @return The range (<code>null</code> if the dataset is
     *         <code>null</code> or empty).
     */

#Code:
    public Range findRangeBounds(XYDataset dataset) {
        if (dataset != null) {
            return DatasetUtilities.findRangeBounds(dataset,
                    this.useYInterval);
        }
        else {
            return null;
        }
    }

#end
#end
#No. 188668
#File: E:\bishe\1\XYBarRenderer.java
#Comment:
    /**
     * Returns a clone of the renderer.
     *
     * @return A clone.
     *
     * @throws CloneNotSupportedException  if the renderer cannot be cloned.
     */

#Code:
    public Object clone() throws CloneNotSupportedException {
        XYBarRenderer result = (XYBarRenderer) super.clone();
        if (this.gradientPaintTransformer != null) {
            result.gradientPaintTransformer = (GradientPaintTransformer)
                ObjectUtilities.clone(this.gradientPaintTransformer);
        }
        result.legendBar = ShapeUtilities.clone(this.legendBar);
        return result;
    }




#end
#end
#No. 188671
#File: E:\bishe\1\XYChartBuilder.java
#Comment:
  /**
   * Enable or disable the add data to series widgets
   * 
   * @param enabled the enabled state
   */

#Code:
  private void setSeriesWidgetsEnabled(boolean enabled) {
    mX.setEnabled(enabled);
    mY.setEnabled(enabled);
    mAdd.setEnabled(enabled);
  }

#end
#end
#No. 188672
#File: E:\bishe\1\XYChartBuilderBackup.java
#Comment:
  /**
   * Enable or disable the add data to series widgets
   * 
   * @param enabled the enabled state
   */

#Code:
  private void setSeriesWidgetsEnabled(boolean enabled) {
    mX.setEnabled(enabled);
    mY.setEnabled(enabled);
    mAdd.setEnabled(enabled);
  }

#end
#end
#No. 188674
#File: E:\bishe\1\XYChartView.java
#Comment:
	/**
	 * @return the hasCursor
	 */

#Code:
	public boolean isHasCursor() {
		return hasCursor;
	}

#end
#end
#No. 188675
#File: E:\bishe\1\XYChartView.java
#Comment:
	/**
	 * @param hasCursor the hasCursor to set
	 */

#Code:
	public void setHasCursor(boolean hasCursor) {
		this.hasCursor = hasCursor;
	}

#end
#end
#No. 188676
#File: E:\bishe\1\XYChartView.java
#Comment:
	/**
	 * @return the fingerPosition
	 */

#Code:
	public float getFingerPosition() {
		return fingerPosition;
	}

#end
#end
#No. 188677
#File: E:\bishe\1\XYChartView.java
#Comment:
	/**
	 * @param fingerPosition the fingerPosition to set
	 */

#Code:
	public void setFingerPosition(float fingerPosition) {
		this.fingerPosition = fingerPosition;
	}

#end
#end
#No. 188678
#File: E:\bishe\1\XYChartView.java
#Comment:
	/**
	 * @return the cursorChangeListener
	 */

#Code:
	public CursorChangeListener getCursorChangeListener() {
		return cursorChangeListener;
	}

#end
#end
#No. 188679
#File: E:\bishe\1\XYChartView.java
#Comment:
	/**
	 * @param cursorChangeListener the cursorChangeListener to set
	 */

#Code:
	public void setCursorChangeListener(CursorChangeListener cursorChangeListener) {
		this.cursorChangeListener = cursorChangeListener;
	}


#end
#end
#No. 188685
#File: E:\bishe\1\XYDimension.java
#Comment:
/**
 * Dimension of an XY plot.
 * @author Adam Crume
 */

#Code:
public enum XYDimension {
	/**
	 * The X (horizontal) axis.
	 */
	X,
	
	/**
	 * The Y (vertical) axis.
	 */
	Y
}

#end
#end
#No. 188690
#File: E:\bishe\1\XYGraphPanel.java
#Comment:
    /**
     * Create the panel.
     */

#Code:
    public XYGraphPanel(DataBuffer buffer, String name, int xmin, int xmax, int xminor, int ymin, int ymax, int yminor, Color color) {
        super();
        this.graphBuffer = buffer;
        this.color = color;
        this.ymin = ymin;
        this.ymax = ymax;
        this.yminor = yminor;
        this.xmin = xmin;
        this.xmax = xmax;
        this.xminor = xminor;
        this.name = name;

        jLabelYMax.setText("" + ymax);
        jLabelXYMin.setText("" + ymin);

        jLabelTitle.setText(name);

        jLabelXAVG.setForeground(color);
        jLabelYAVG.setForeground(color);
        jLabelTitle.setForeground(color);
    }

#end
#end
#No. 188691
#File: E:\bishe\1\XYMatrixToItems.java
#Comment:
	/** returns the version number at which this module was first released.  If 0, then no version number is claimed.  If a POSITIVE integer
	 * then the number refers to the Mesquite version.  This should be used only by modules part of the core release of Mesquite.
	 * If a NEGATIVE integer, then the number refers to the local version of the package, e.g. a third party package*/

#Code:
	public int getVersionOfFirstRelease(){
		return 110;  
	}

#end
#end
#No. 188692
#File: E:\bishe\1\XYMatrixToItems.java
#Comment:
	/** Called to provoke any necessary initialization.  This helps prevent the module's intialization queries to the user from
	 happening at inopportune times (e.g., while a long chart calculation is in mid-progress)*/

#Code:
	public void initialize(Taxa taxa){
		dataTask.initialize(taxa);
	}

#end
#end
#No. 188693
#File: E:\bishe\1\XyPlotView.java
#Comment:
    /**
     * Toggles between the two Comfort Zones
     *
     * @param season true=winter, false=summer
     */

#Code:
    public void setComfortZoneWinter(final boolean season) {
        mIsCzWinter = season;
        updatePath();
    }

#end
#end
#No. 188694
#File: E:\bishe\1\XyPlotView.java
#Comment:
    /**
     * Checks if the given PointF is inside the given
     * Grid provided by GraphView.
     *
     * @param p PointF with vertical and horizontal pos.
     * @return Point is in Grid flag.
     */

#Code:
    public boolean isOutsideGrid(@NonNull final PointF p) {
        boolean isOutsideTheGrid = false;

        if (p.x > getXAxisMax()) {
            isOutsideTheGrid = true;
            mClippedPoint.x = getXAxisMax();
            mClippedPoint.y = p.y;
            Log.v(TAG, String.format("isOutsideGrid -> Clipped outside right end at p.x = %s.", p.x));
        } else if (p.x < getXAxisMin()) {
            isOutsideTheGrid = true;
            mClippedPoint.x = getXAxisMin();
            mClippedPoint.y = p.y;
            Log.v(TAG, String.format("isOutsideGrid -> Clipped outside left end at p.x = %s.", p.x));
        }

#end
#end
#No. 188695
#File: E:\bishe\1\XYScrollView.java
#Comment:
    /**
     * Indicates whether this ScrollView's content is stretched to fill the
     * viewport.
     * 
     * @return True if the content fills the viewport, false otherwise.
     */

#Code:
    public boolean isFillViewport() {
        return mFillViewport;
    }

#end
#end
#No. 188696
#File: E:\bishe\1\XYScrollView.java
#Comment:
    /**
     * Indicates this ScrollView whether it should stretch its content width to
     * fill the viewport or not.
     * 
     * @param fillViewport
     *            True to stretch the content's width to the viewport's
     *            boundaries, false otherwise.
     */

#Code:
    public void setFillViewport(boolean fillViewport) {
        if (fillViewport != mFillViewport) {
            mFillViewport = fillViewport;
            requestLayout();
        }
    }

#end
#end
#No. 188697
#File: E:\bishe\1\XYScrollView.java
#Comment:
    /**
     * @return Whether arrow scrolling will animate its transition.
     */

#Code:
    public boolean isSmoothScrollingEnabled() {
        return mSmoothScrollingEnabled;
    }

#end
#end
#No. 188698
#File: E:\bishe\1\XYScrollView.java
#Comment:
    /**
     * Set whether arrow scrolling will animate its transition.
     * 
     * @param smoothScrollingEnabled
     *            whether arrow scrolling will animate its transition
     */

#Code:
    public void setSmoothScrollingEnabled(boolean smoothScrollingEnabled) {
        mSmoothScrollingEnabled = smoothScrollingEnabled;
    }






#end
#end
#No. 188702
#File: E:\bishe\1\XYScrollView.java
#Comment:
    /**
     * Scrolls the view to the given child.
     * 
     * @param child
     *            the View to scroll to
     */

#Code:
    private void scrollToChild(View child) {
        child.getDrawingRect(mTempRect);
        
        /* Offset from child's local coordinates to ScrollView coordinates */
        offsetDescendantRectToMyCoords(child, mTempRect);
        
        int scrollDeltaX = computeScrollDeltaToGetChildRectOnScreenX(mTempRect);
        int scrollDeltaY = computeScrollDeltaToGetChildRectOnScreenY(mTempRect);
        
        if (scrollDeltaX != 0 || scrollDeltaY != 0) {
            scrollBy(scrollDeltaX, scrollDeltaY);
        }
    }



#end
#end
#No. 188706
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @return
     *     The custId
     */

#Code:
    @JsonProperty("custId")
    public String getCustId() {
        return custId;
    }

#end
#end
#No. 188707
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @param custId
     *     The custId
     */

#Code:
    @JsonProperty("custId")
    public void setCustId(String custId) {
        this.custId = custId;
    }

#end
#end
#No. 188708
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @return
     *     The priority
     */

#Code:
    @JsonProperty("priority")
    public String getPriority() {
        return priority;
    }

#end
#end
#No. 188709
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @param priority
     *     The priority
     */

#Code:
    @JsonProperty("priority")
    public void setPriority(String priority) {
        this.priority = priority;
    }

#end
#end
#No. 188710
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @return
     *     The orderId
     */

#Code:
    @JsonProperty("orderId")
    public String getOrderId() {
        return orderId;
    }

#end
#end
#No. 188711
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @param orderId
     *     The orderId
     */

#Code:
    @JsonProperty("orderId")
    public void setOrderId(String orderId) {
        this.orderId = orderId;
    }

#end
#end
#No. 188712
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @return
     *     The origin
     */

#Code:
    @JsonProperty("origin")
    public String getOrigin() {
        return origin;
    }

#end
#end
#No. 188713
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @param origin
     *     The origin
     */

#Code:
    @JsonProperty("origin")
    public void setOrigin(String origin) {
        this.origin = origin;
    }

#end
#end
#No. 188714
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @return
     *     The approvalCode
     */

#Code:
    @JsonProperty("approvalCode")
    public String getApprovalCode() {
        return approvalCode;
    }

#end
#end
#No. 188715
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @param approvalCode
     *     The approvalCode
     */

#Code:
    @JsonProperty("origin")
    public void setApprovalCode(String approvalCode) {
        this.approvalCode = approvalCode;
    }

#end
#end
#No. 188716
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @return
     *     The lineItems
     */

#Code:
    @JsonProperty("lineItems")
    public List<LineItem> getLineItems() {
        return lineItems;
    }

#end
#end
#No. 188717
#File: E:\bishe\1\XyzOrder.java
#Comment:
    /**
     * 
     * @param lineItems
     *     The lineItems
     */

#Code:
    @JsonProperty("lineItems")
    public void setLineItems(List<LineItem> lineItems) {
        this.lineItems = lineItems;
    }

#end
#end
#No. 188718
#File: E:\bishe\1\YadisResolver2.java
#Comment:
/**
 * {@link YadisResolver} with better error diagnosis.
 * @author Kohsuke Kawaguchi
 */

#Code:
class YadisResolver2 extends YadisResolver {
    @Inject
    public YadisResolver2(HttpFetcher httpFetcher) {
        super(httpFetcher);
    }

    public YadisResolver2(HttpFetcherFactory httpFetcherFactory) {
        super(httpFetcherFactory);
    }

    /**
     * Improve the error diagnosis by reporting which URL had failed. openid4java as of 0.9.4 does not do that.
     */
    @Override
    public YadisResult discover(String url, int maxRedirects, HttpFetcher cache, Set serviceTypes) throws DiscoveryException {
        try {
            return super.discover(url,maxRedirects,cache,serviceTypes);
        } catch (DiscoveryException e) {
            throw new DiscoveryException("Failed to discover XRDS document from "+url, e.getErrorCode(), e);
        }
    }
}
#end
#end
#No. 188719
#File: E:\bishe\1\YagoParser.java
#Comment:
	/**
	 * <p>parseRDFData.</p>
	 *
	 * @param in a {@link java.io.InputStream} object.
	 * @param tc a {@link lupos.engine.operators.tripleoperator.TripleConsumer} object.
	 * @param encoding a {@link java.lang.String} object.
	 * @return a int.
	 * @throws java.io.UnsupportedEncodingException if any.
	 */

#Code:
	public static int parseRDFData(final InputStream in, final TripleConsumer tc,
			final String encoding) throws UnsupportedEncodingException {
		YagoParser parser=new YagoParser();
		parser.parse(in, tc, encoding);
		return parser.getTripleNumber();
	}

#end
#end
#No. 188720
#File: E:\bishe\1\YagoParser.java
#Comment:
	/**
	 * <p>handlePrefix.</p>
	 *
	 * @return a char.
	 * @throws java.io.EOFException if any.
	 */

#Code:
	protected char handlePrefix() throws EOFException {
			final String s = "" + nextCharacter() + nextCharacter()
					+ nextCharacter() + nextCharacter() + nextCharacter()
					+ nextCharacter();
			if (s.toLowerCase().compareTo("prefix") == 0) {
				String name = "";
				char next = jumpOverBlanks();
				while (next != ':') {
					name += next;
					next = nextCharacter();
				}
				String prefix = "";
				next = jumpOverBlanks();
				if (next != '<') {
					while (next != ' ' && next != '\n') {
						prefix += next;
						next = nextCharacter();
					}
				} else {
					next = jumpOverBlanks();
					while (next != '>') {
						prefix += next;
						next = nextCharacter();
					}
					next = nextCharacter();
				}
				prefixe.put(name, prefix);
				if (next == ' ' || next == '\n') {
					next = jumpOverBlanks();
				}
				return next;
			} else {
				System.err.println("Prefix not recognized!");
				throw new EOFException();
			}
	}

#end
#end
#No. 188721
#File: E:\bishe\1\YahooFinanceModule.java
#Comment:
    /**
     * Fetch the the latest stock price, but only show it if its a large change
     *
     * @param listener
     */

#Code:
    public static void getStockForToday(final String stockName, final StockListener listener) {

        new AsyncTask<Void, Void, YahooStockResponse>() {

            @Override
            protected YahooStockResponse doInBackground(Void... params) {
                RestAdapter restAdapter = new RestAdapter.Builder()
                        .setEndpoint("http://query.yahooapis.com/v1/public")
                        .build();

                YahooFinanceRequest service = restAdapter.create(YahooFinanceRequest.class);

                String query = "select * from yahoo.finance.quotes where symbol in (\"" + stockName + "\")";
                String env = "http://datatables.org/alltables.env";
                String format = "json";
                try {
                    return service.getStockData(query, env, format);
                } catch (RetrofitError error) {
                    Log.w("YahooFinanceModule", "YahooFinance error: " + error.getMessage());
                    return null;
                }
            }

            @Override
            protected void onPostExecute(@Nullable YahooStockResponse stockResponse) {
                if (stockResponse != null && stockResponse.getQuoteResponse() != null) {
                    YahooStockResponse.YahooQuoteResponse quoteResponse = stockResponse.getQuoteResponse();
                    if (ConfigurationSettings.isDemoMode() || quoteResponse.getPercentageChange().abs().compareTo(BigDecimal.valueOf(0.03)) >= 0) {
                        listener.onNewStockPrice(quoteResponse);
                        return;
                    }
                }
                listener.onNewStockPrice(null);
            }
        }.execute();

#end
#end
#No. 188722
#File: E:\bishe\1\YahooParallaxActivity.java
#Comment:
    /**Hide the status bar on pre-19 android
     * Set the status bar to transparent after version 19 */

#Code:
    private void handleStatusBar() {
        if (Build.VERSION.SDK_INT < 19) {
            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                    WindowManager.LayoutParams.FLAG_FULLSCREEN);
        }else {
            Window w = getWindow();
            w.setFlags(
                    WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,
                    WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);

        }
    }


#end
#end
#No. 188724
#File: E:\bishe\1\YamlCGC.java
#Comment:
	/**
	 * Creates IInitialCondition instances and applies them to the Settings instance.
	 * @param s
	 */

#Code:
	public void applyTo(Settings s) {
		for (YamlMVModel init : MVModel) {
			CGCInitialCondition ic = init.getInitialCondition();
			applyOptions(ic);
			s.addInitialConditions(ic);
		}

		for (YamlMVModelCoherent init : MVModelCoherent) {
			CGCInitialCondition ic = init.getInitialCondition();
			applyOptions(ic);
			s.addInitialConditions(ic);
		}

		for (YamlNucleusCoherent init : NucleusCoherent) {
			CGCInitialCondition ic = init.getInitialCondition();
			applyOptions(ic);
			s.addInitialConditions(ic);
		}

		for (YamlNucleus init : Nucleus) {
			CGCInitialCondition ic = init.getInitialCondition();
			applyOptions(ic);
			s.addInitialConditions(ic);
		}

		for (YamlNucleusThick init : NucleusThick) {
			CGCInitialCondition ic = init.getInitialCondition();
			applyOptions(ic);
			s.addInitialConditions(ic);
		}
	}




#end
#end
#No. 188727
#File: E:\bishe\1\YamlEnumTest.java
#Comment:
	/**
	 * Gets the config
	 *
	 * @return config.yml YamlConfiguration
	 */

#Code:
	private YamlConfiguration getConfig() {
		File configFile = new File(YamlParseTest.resourcesDirectory, "config.yml");
		return YamlConfiguration.loadConfiguration(configFile);
	}

#end
#end
#No. 188728
#File: E:\bishe\1\YAMLGenerator.java
#Comment:
    /**
     * Enumeration that defines all togglable features for YAML generators
     */

#Code:
    public enum Feature {
        BOGUS(false) // placeholder
        ;

        protected final boolean _defaultState;
        protected final int _mask;
        
        /**
         * Method that calculates bit set (flags) of all features that
         * are enabled by default.
         */
        public static int collectDefaults()
        {
            int flags = 0;
            for (Feature f : values()) {
                if (f.enabledByDefault()) {
                    flags |= f.getMask();
                }
            }
            return flags;
        }
        
        private Feature(boolean defaultState) {
            _defaultState = defaultState;
            _mask = (1 << ordinal());
        }
        
        public boolean enabledByDefault() { return _defaultState; }
        public int getMask() { return _mask; }
    };




#end
#end
#No. 188742
#File: E:\bishe\1\YamlInitialConditions.java
#Comment:
	/**
	 * Creates IInitialCondition instances and applies them to the Settings instance.
	 * @param s
	 */

#Code:
	public void applyTo(Settings s) {
		if(CGC != null) {
			CGC.applyTo(s);
		}

		if(YM != null) {
			YM.applyTo(s);
		}
	}

#end
#end
#No. 188743
#File: E:\bishe\1\YamlMetricsAttributeTableLoader.java
#Comment:
    /**
     * @param inputStream yaml data
     * @return Table of metric toggles
     * @throws IOException if loading fails
     */

#Code:
    public Table<String, NewRelicMetric, Boolean> loadTable(@Nonnull InputStream inputStream) throws IOException {
        Map<String, Map<NewRelicMetric, Boolean>> m =
                objectReader.forType(new TypeReference<Map<String, Map<NewRelicMetric, Boolean>>>() {})
                        .readValue(inputStream);
        return table(m);
    }

#end
#end
#No. 188744
#File: E:\bishe\1\YamlPanels.java
#Comment:
	/**
	 * Constructor which fills the values of this class according to
	 * the component attached.
	 * @param component Java swing component from which to extract the parameters.
	 * @param windowWidth Width of window
	 * @param windowHeight Height of Window
	 */

#Code:
	public YamlPanels(Component component, int windowWidth, int windowHeight) {
		this(component);
		this.windowWidth = windowWidth;
		this.windowHeight = windowHeight;
	}

#end
#end
#No. 188745
#File: E:\bishe\1\YamlPanels.java
#Comment:
	/**
	 * Constructor which fills the values of this class according to
	 * the component attached.
	 * @param component Java swing component from which to extract the parameters.
	 */

#Code:
	public YamlPanels(Component component) {
		if (component instanceof JSplitPane) {
			JSplitPane splitpane = (JSplitPane) component;
			Component leftComponent = splitpane.getLeftComponent();
			Component rightComponent = splitpane.getRightComponent();
			orientation = splitpane.getOrientation();
			dividerLocation = splitpane.getDividerLocation();
			leftPanel = new YamlPanels(leftComponent);
			rightPanel = new YamlPanels(rightComponent);
		} else if (component instanceof ElectricFieldPanel) {
			electricFieldPanel = new YamlElectricFieldPanel(component);
		} else if (component instanceof Particle2DPanel) {
			particle2DPanel = new YamlParticle2DPanel(component);
		} else if (component instanceof Particle3DPanel) {
			particle3DPanel = new YamlParticle3DPanel(component);
		} else if (component instanceof PhaseSpacePanel) {
			phaseSpacePanel = new YamlPhaseSpacePanel(component);
		} else if (component instanceof EnergyDensity1DPanel) {
			energyDensity1DPanel = new YamlEnergyDensity1DPanel(component);
		} else if (component instanceof EnergyDensity2DPanel) {
			energyDensity2DPanel = new YamlEnergyDensity2DPanel(component);
		} else if (component instanceof EnergyDensity2DGLPanel) {
			energyDensity2DGLPanel = new YamlEnergyDensity2DGLPanel(component);
		} else if (component instanceof EnergyDensity3DGLPanel) {
			energyDensity3DGLPanel = new YamlEnergyDensity3DGLPanel(component);
		} else if (component instanceof EnergyDensityVoxelGLPanel) {
			energyDensityVoxelGLPanel = new YamlEnergyDensityVoxelGLPanel(component);
		} else if (component instanceof OccupationNumbers2DGLPanel) {
			occupationNumbers2DGLPanel = new YamlOccupationNumbers2DGLPanel(component);
		} else if (component instanceof Chart2DPanel) {
			chartPanel = new YamlChart2DPanel(component);
		} else if (component instanceof GaussViolation2DGLPanel) {
			gaussViolation2DGLPanel = new YamlGaussViolation2DGLPanel(component);
		} else if (component instanceof InfoPanel) {
			infoPanel = new YamlInfoPanel(component);
		}
	}

#end
#end
#No. 188746
#File: E:\bishe\1\YamlPanels.java
#Comment:
	/**
	 * Inflate the values into Java components that can be displayed by the PanelManager.
	 * @param panelManager
	 * @return
	 */

#Code:
	public Component inflate(PanelManager panelManager) {
		Component component = null;
		if (leftPanel != null && rightPanel != null) {
			// Create new split panel
			Component leftComponent = leftPanel.inflate(panelManager);
			Component rightComponent = rightPanel.inflate(panelManager);

			component = panelManager.getSplitPanel(leftComponent, rightComponent, orientation, dividerLocation);
		} else if (electricFieldPanel != null) {
			component = electricFieldPanel.inflate(panelManager);
		} else if (particle2DPanel != null) {
			component = particle2DPanel.inflate(panelManager);
		} else if (particle3DPanel != null) {
			component = particle3DPanel.inflate(panelManager);
		} else if (phaseSpacePanel != null) {
			component = phaseSpacePanel.inflate(panelManager);
		} else if (energyDensity1DPanel != null) {
			component = energyDensity1DPanel.inflate(panelManager);
		} else if (energyDensity2DPanel != null) {
			component = energyDensity2DPanel.inflate(panelManager);
		} else if (energyDensity2DGLPanel != null) {
			component = energyDensity2DGLPanel.inflate(panelManager);
		} else if (energyDensity3DGLPanel != null) {
			component = energyDensity3DGLPanel.inflate(panelManager);
		} else if (energyDensityVoxelGLPanel != null) {
			component = energyDensityVoxelGLPanel.inflate(panelManager);
		} else if (occupationNumbers2DGLPanel != null) {
			component = occupationNumbers2DGLPanel.inflate(panelManager);
		} else if (chartPanel != null) {
			component = chartPanel.inflate(panelManager);
		} else if (gaussViolation2DGLPanel != null) {
			component = gaussViolation2DGLPanel.inflate(panelManager);
		} else if (infoPanel != null) {
			component = infoPanel.inflate(panelManager);
		}

		return component;
	}

#end
#end
#No. 188747
#File: E:\bishe\1\YamlPanelWriter.java
#Comment:
	/**
	 * Workaround to remove lines that only contain "xxx: null".
	 * @param string
	 * @return
	 */

#Code:
	private String removeLines(String string) {
		String lines[] = string.split("\\r?\\n");
		String result = "";
		for (String line : lines) {
			if (line.endsWith(": null")) {
				// omit
			} else if (line.startsWith("!!org.openpixi")) {
				// omit
			} else {
				result = result + line + "\n";
			}
		}
		return result;
	}

#end
#end
#No. 188751
#File: E:\bishe\1\YAMLPropertiesSource.java
#Comment:
    /**
     * Return a flattened version of the given map, recursively following any nested Map
     * or Collection values. Entries from the resulting map retain the same order as the
     * source.
     *
     * Copied from https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/config/YamlProcessor.java
     *
     * @param source the source map
     * @return a flattened map
     */

#Code:
    protected final Map<String, String> getFlattenedMap(Map<String, Object> source) {
        Map<String, String> result = new LinkedHashMap<>();
        buildFlattenedMap(result, source, null);
        return result;
    }



#end
#end
#No. 188756
#File: E:\bishe\1\YamlYangMillsParticle.java
#Comment:
	/**
	 * Creates a new particle and applies the settings from the
	 * YAML document to it.
	 * @return new particle
	 */

#Code:
	public YangMillsParticle getParticle(int numberOfDimensions, int numberOfColors) {
		YangMillsParticle p = new YangMillsParticle(numberOfDimensions, numberOfColors);
		

		if(position != null)
			for(int i = 0; i < position.size(); i++)
				p.setPosition(i, position.get(i));

		if(velocity != null)
			for(int i = 0; i < velocity.size(); i++)
				p.setVelocity(i, velocity.get(i));

		if (r != null) {
			p.setRadius(r);
		}

		if (m != null) {
			p.mass = m;
		}

		if (q != null)
			for(int c = 0; c < q.size(); c++) {
				p.Q0.set(c, q.get(c));
				p.Q1.set(c, q.get(c));
			}

		if (color != null) {
			p.setDisplayColor(getColorFromString(color));
		}
		return p;
	}

#end
#end
#No. 188757
#File: E:\bishe\1\YamlYangMillsParticle.java
#Comment:
	/**
	 * Convert a color string from the YAML file into Java color.
	 * @param colorstring This can be a name (e.g. "red", "blue", ...),
	 * a HEX code (e.g. "FFFFFF"), or "random".
	 * @return
	 */

#Code:
	static private Color getColorFromString(String colorstring) {
		// Default is black
		Color c = null;

		// Check if it is a Java string (e.g. "blue", "red", ...)
		try {
			// Access Color.blue, Color.red, ... by reflection:
			Field field = Color.class.getField(colorstring);
			c = (Color)field.get(null);
		} catch (NoSuchFieldException e) {
		} catch (IllegalAccessException e) {
		}

		if (c == null) {
			// Check if it is a HEX color code (e.g. "FFFFFF")
			try {
				c = Color.decode("#" + colorstring);
			} catch (NumberFormatException e) {
			}
		}

		if (colorstring.equals("random")) {
			// Use random color
			c = new Color((int)(Math.random() * 0x1000000));
		}

		if (c == null) {
			// Fallback color
			c = Color.black;
		}
		return c;
	}

#end
#end
#No. 188758
#File: E:\bishe\1\YamlYangMillsParticleStream.java
#Comment:
	/**
	 * Creates a stream of particles. The particle is copied
	 * 'number' times. Each time, the positions are
	 * adjusted by adding the distances defined in List<Double> distances.
	 * @param settings Settings object to which particles are added.
	 */

#Code:
	public void applyTo(Settings settings) {
		YangMillsParticle p;
		numberOfDimensions = settings.getNumberOfDimensions();
		double[] distances = new double[numberOfDimensions];
		double number = 0;

		if(this.distances != null)
			for(int i = 0; i < numberOfDimensions; i++)
				distances[i] = this.distances.get(i);

		if (this.number != null) {
			number = this.number;
		}

		if (this.particle != null) {

			for (int n = 0; n < number; n++)
			{
				p = particle.getParticle(settings.getNumberOfDimensions(), settings.getNumberOfColors());
				for(int i = 0; i < numberOfDimensions; i++)
					p.addPosition(i, n * distances[i]);

				applyRandomModifications(p);
				settings.addParticle(p);
			}
		}
	}


#end
#end
#No. 188760
#File: E:\bishe\1\YammerActivity.java
#Comment:
  /**
   * Set editor text.
   * 
   * @param _text new value (null sets text to prompt)
   */

#Code:
  private void setEditorText(String _text) {
    EditText editor = getEditor();

    final String prompt = getString(R.string.yam_prompt);
    if(null == _text) _text = prompt;

    editor.setText(_text);

    if(prompt.equals(_text)) {
      editor.setTextColor(0xFF888888);
    } else {
      editor.setTextColor(0xFF000000);
    }
  }

#end
#end
#No. 188761
#File: E:\bishe\1\YammerData.java
#Comment:
  /**
   * Get the highest message ID in the messages table
   * @param networkId
   * @returns the highest message ID in the messages table
   */

#Code:
  public long getLastMessageId(long networkId) {
    return Message.getLastMessageId(getReadableDatabase(), networkId);
  }

#end
#end
#No. 188762
#File: E:\bishe\1\YammerData.java
#Comment:
  /**
   * Get the lowest message ID in the messages table
   * @param networkId
   * @returns the lowest message ID in the messages table
   */

#Code:
  public long getFirstMessageId(long networkId) {
    return Message.getFirstMessageId(getReadableDatabase(), networkId);
  }

#end
#end
#No. 188763
#File: E:\bishe\1\YammerErrorHandler.java
#Comment:
	/**
	 * Error details are returned in the message body as JSON. Extract these in
	 * a map
	 * 
	 * @param response
	 *            from yammer
	 * @return json body as a map
	 * @throws IOException
	 *             if ItemStream is closed
	 */

#Code:
	private Map<String, Object> extractErrorDetailsFromResponse(ClientHttpResponse response) throws IOException {
		ObjectMapper mapper = new ObjectMapper(new JsonFactory());
		try {
			return mapper.<Map<String, Object>> readValue(response.getBody(), new TypeReference<Map<String, Object>>() {
			});
		} catch (JsonParseException e) {
			return null;
		}
	}

#end
#end
#No. 188764
#File: E:\bishe\1\YammerMessage.java
#Comment:
	/**
	 * Creating the Yammer message activity
	 */

#Code:
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		this.setContentView(R.layout.message);		
	}

#end
#end
#No. 188765
#File: E:\bishe\1\YammerProfile.java
#Comment:
	/**
	 * @return the contact
	 */

#Code:
	public Contact getContact() {
		return contact;
	}

#end
#end
#No. 188766
#File: E:\bishe\1\YammerProfile.java
#Comment:
	/**
	 * @return the schools
	 */

#Code:
	public List<School> getSchools() {
		return schools;
	}

#end
#end
#No. 188767
#File: E:\bishe\1\YammerProxy.java
#Comment:
  /**
   * Reset the OAuth library
   */

#Code:
  public void reset() {
    this.provider = new OAuthServiceProvider(baseURL+PATH_REQUEST_TOKEN, baseURL+PATH_AUTHORIZE, baseURL+PATH_ACCESS_TOKEN);
    this.consumer = new OAuthConsumer(baseURL+PATH_CALLBACK, OAuthCustom.KEY, OAuthCustom.SECRET, provider);
    this.accessor = new OAuthAccessor(consumer);
    this.client = new OAuthClient(getHttpClient());
    this.requestToken = null;
    this.tokenSecret = null;
  }

#end
#end
#No. 188768
#File: E:\bishe\1\YammerProxy.java
#Comment:
  /**
   * Login via OAuth+WRAP.
   *
   * @return return code
   * 200: Ok
   *  Login was successful
   * 400: Unauthorized
   *  The email or password is invalid or the network is disabled.
   * 403: Forbidden
   *  This is special and not officially part of WRAP. Some of our networks are using Single-Sign-On and have disabled password based authentication for their users. They of course want their users to be able to use our clients and they want the same or better experience as non-SSO users get.
   * 500: Internal Server Error
   *  Try again later. Chances are whatever caused the 500 will be resolved.
   */

#Code:
  public int login(String _email, String _password) {

      try {
        URL url = new URL(baseURL + PATH_LOGIN +
            "?wrap_username=" + Uri.encode(_email.trim()) + 
            "&wrap_password=" + Uri.encode(_password) + 
            "&wrap_client_id=" + OAuthCustom.KEY
        );
        HttpMessage request = new HttpMessage(OAuthMessage.GET, url);
        HttpResponseMessage response = getHttpClient().execute(request);
        if(200 == response.getStatusCode()) {
          WRAPResponse wrap = new WRAPResponse(response);
          this.requestToken = wrap.getParameter("wrap_access_token");
          this.tokenSecret = wrap.getParameter("wrap_refresh_token");
        }
        return response.getStatusCode();
      } catch (MalformedURLException e1) {
        e1.printStackTrace();
      } catch (IOException e) {
        e.printStackTrace();
      }
      return 500;
  }

#end
#end
#No. 188769
#File: E:\bishe\1\YammerProxy.java
#Comment:
  /**
   * Request a OAuth "Request Token".
   * @throws ConnectionProblem
   */

#Code:
  public void getRequestToken() throws YammerProxyException {
    if (DEBUG) Log.d(getClass().getName(), "YammerProxy.getRequestToken");

    if ( accessor == null ) {
      if ( DEBUG ) Log.e(getClass().getName(), "accessor not available (yet!)");
      return;
    }

    try {
      client.getRequestToken(accessor);
    } catch (java.io.IOException e) {
      throw new ConnectionProblem(e);
    } catch (OAuthException e) {
      throw new AccessDeniedException(e);
    } catch (Exception e) {
      throw new ConnectionProblem(e);
    }
    // We should now have a request token and a token secret
    this.requestToken = accessor.requestToken;
    this.tokenSecret = accessor.tokenSecret;

    if (DEBUG) Log.d(getClass().getName(), "Request token: " + this.requestToken);
    if (DEBUG) Log.d(getClass().getName(), "Request token secret: " + this.tokenSecret);
  }

#end
#end
#No. 188770
#File: E:\bishe\1\YammerProxy.java
#Comment:
  /**
   * Validate the request token and the token secret.
   *
   * @return true if request token and token secret was fetched, false if a problem occured
   */

#Code:
  public Boolean isRequestTokenValid() {
    if ( this.requestToken == null || this.tokenSecret == null ) {
      return false;
    }
    return true;
  }

#end
#end
#No. 188771
#File: E:\bishe\1\YammerProxy.java
#Comment:
  /**
   * Get Networks.
   * 
   * @returns JSONMessage containing networks 
   */

#Code:
  public Network[] getNetworks() throws YammerProxyException {
    try {
      
      // get base information
      JSONArray jsonArray = new JSONArray(accessResource(this.baseURL + PATH_CURRENT_NETWORKS));
      Map<Long, Network> networks = new java.util.HashMap<Long,Network>();
      for( int ii=0; ii < jsonArray.length(); ii++ ) {
        JSONObject obj = jsonArray.getJSONObject(ii);
        networks.put(obj.getLong("id"), new Network(obj));
      }
      
      // fill in tokens
      jsonArray = new JSONArray(accessResource(this.baseURL + PATH_TOKENS));
      for( int ii=0; ii < jsonArray.length(); ii++ ) {
        JSONObject obj = jsonArray.getJSONObject(ii);
        networks.get(obj.getLong("network_id")).update(obj);
      }
      
      return networks.values().toArray(new Network[networks.size()]);
    } catch (JSONException cause) {
      if (DEBUG) Log.w(getClass().getName(), cause.getMessage());
      throw new YammerProxyException("Unable to get networks", cause);
    }
  }

#end
#end
#No. 188772
#File: E:\bishe\1\YammerProxy.java
#Comment:
  /**
   * Set the current network.
   * 
   * All subsequent message requests will be made to this network.
   * 
   * @param _network New network
   */

#Code:
  public void setCurrentNetwork(Network _network) {
    baseURL = _network.webURL;
    requestToken = _network.accessToken;
    tokenSecret = _network.accessTokenSecret;
    currentUserData = null;
  }

#end
#end
#No. 188773
#File: E:\bishe\1\YammerProxy.java
#Comment:
  /**
   * Post a message or a reply to the current Yammer Network
   *
   * @param message - message to post
   * @param messageId - Message being replied to
   *
   * @throws YammerProxy.AccessDeniedException
   * @throws YammerProxy.ConnectionProblem
   */

#Code:
  public void postMessage(final String message, final long messageId) throws YammerProxyException {
    if (DEBUG) Log.d(getClass().getName(), ".postMessage");
    try {
      Properties paramProps = new Properties();
      paramProps.setProperty("oauth_token", this.requestToken);
      paramProps.setProperty("body", message);
      if( messageId != 0 ) {
        paramProps.setProperty("replied_to_id", Long.toString(messageId));
      }
      sendRequest(paramProps, this.baseURL + "/api/v1/messages/", OAuthMessage.POST);
    } catch (IllegalArgumentException ex) {
      // happens when there is a % in the body of the message
    } catch (NullPointerException e) {
      throw new ConnectionProblem(e);
    } catch (IOException e) {
      throw new ConnectionProblem(e);
    } catch (URISyntaxException e) {
      throw new ConnectionProblem(e);
    } catch (OAuthException e) {
      throw new AccessDeniedException(e);
    }
  }

#end
#end
#No. 188774
#File: E:\bishe\1\YammerProxy.java
#Comment:
  /**
   * Follow user with given user ID on Yammer
   * @param userId
   *
   * @return
   *
   * @throws AccessDeniedException
   * @throws ConnectionProblem
   */

#Code:
  public void followUser(long userId) throws YammerProxyException {
    if (DEBUG) Log.d(getClass().getName(), ".followUser: " + userId);
    String url = this.baseURL + "/api/v1/subscriptions/";
    Properties paramProps = new Properties();
    paramProps.setProperty("target_type", "user");
    paramProps.setProperty("target_id", Long.toString(userId));
    try {
      sendRequest(paramProps, url, OAuthMessage.POST);
    } catch (IOException e) {
      throw new ConnectionProblem(e);
    } catch (URISyntaxException e) {
      throw new ConnectionProblem(e);
    } catch (OAuthException e) {
      throw new AccessDeniedException(e);
    }
  }

#end
#end
#No. 188775
#File: E:\bishe\1\YammerReplyActivity.java
#Comment:
	/**
	 * Activity being created
	 */

#Code:
	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);
		if (DEBUG) Log.d(getClass().getName(), ".onCreate");
		setTheme(android.R.style.Theme_Translucent_NoTitleBar);
		// Make sure that the background is blurred behind the activity
		getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND, WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
		setContentView(R.layout.reply);
		// Listen for clicks in the edit box to be able to enable the "reply" button
		EditText replyEdit = (EditText)findViewById(R.id.reply_edit);
		replyEdit.setOnKeyListener(onReplyEditKeyListener);
		// Listen to the cancel button
		Button cancelButton = (Button)findViewById(R.id.reply_cancel);
		cancelButton.setOnClickListener(onCancelListener);
		// Listen to the reply button
		Button replyButton = (Button)findViewById(R.id.reply_post);
		replyButton.setOnClickListener(onReplyListener);
		// Set the state of the reply button
		setReplyButtonState();
		// Set the default result to cancel
		setResult(-1);
		// Hide the Yammer logo
//		findViewById(R.id.share_logo).setVisibility(View.GONE);
	}

#end
#end
#No. 188776
#File: E:\bishe\1\YammerReplyActivity.java
#Comment:
	/**
	 * If the edit box is empty, the reply button must be grayed out.
	 * If text is present in the edit box, the reply button must be 
	 * clickable.
	 */

#Code:
	 private OnKeyListener onReplyEditKeyListener = new OnKeyListener() {
		public boolean onKey(View v, int keyCode, KeyEvent event) {
			// Reply button only enabled, when something written in the edit box
			setReplyButtonState();
			return false;
		}
	};

#end
#end
#No. 188777
#File: E:\bishe\1\YammerReplyActivity.java
#Comment:
	/**
	 * Handle clicks on the cancel button
	 */

#Code:
	private OnClickListener onCancelListener = new OnClickListener() {
		public void onClick(View v) {
			if (DEBUG) Log.d(getClass().getName(), "Cancel clicked");
			// Destroy with -1 as result. I.e. cancel
			setResult(-1);
			finish();
		}
	};



#end
#end
#No. 188780
#File: E:\bishe\1\YammerService.java
#Comment:
  /**
   * Reset counter holding number of new messages
   */

#Code:
  public void resetMessageCount() {
    if (DEBUG) Log.d(getClass().getName(), "YammerService.resetMessageCount");
    newMessageCount = 0;
  }

#end
#end
#No. 188781
#File: E:\bishe\1\YammerService.java
#Comment:
  /**
   * Post a message or a reply to the current Yammer Network
   * 
   * @param message - message to post
   * @param messageId - Message being replied to
   * 
   * @throws YammerProxy.AccessDeniedException
   * @throws YammerProxy.ConnectionProblem 
   */

#Code:
  public void postMessage(final String message, final long messageId) throws YammerProxy.YammerProxyException {
    getYammerProxy().postMessage(message, messageId);
  }

#end
#end
#No. 188782
#File: E:\bishe\1\YammerService.java
#Comment:
  /**
   * Delete a message from the current Yammer network
   * @param messageId - Delete the message with the given ID
   * @throws YammerProxy.AccessDeniedException
   * @throws YammerProxy.ConnectionProblem 
   */

#Code:
  public void deleteMessage(final long messageId) throws YammerProxy.YammerProxyException {
    if (DEBUG) Log.d(getClass().getName(), ".deleteMessage");
    // TODO: change to getYammer().deleteMessage(messageId);
    getYammerProxy().deleteResource(getURLBase() + "/api/v1/messages/"+messageId);		
    getYammerData().deleteMessage(messageId);
    // TODO: sendBroadcast(ACTION_MESSAGE_DELETED, messageId);
    sendBroadcast(YammerActivity.INTENT_PUBLIC_TIMELINE_UPDATED);
  }

#end
#end
#No. 188783
#File: E:\bishe\1\YammerShare.java
#Comment:
	/**
	 * Activity being created
	 */

#Code:
	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);
		if (G.DEBUG) Log.d(getClass().getName(), ".onCreate");
		// Listen to the reply button
		Button replyButton = (Button)findViewById(R.id.reply_post);
		replyButton.setOnClickListener(onReplyListener);
		replyButton.setText("Share");
		// Retrieve the intent that started this activity
		Intent intent = getIntent();
		String action = intent.getAction();
		Bundle extras = intent.getExtras();
		if (G.DEBUG) Log.d(getClass().getName(), "Received intent "+action+" ("+intent.getType()+")");
		// Determine content type to get an idea what we should do
		if ( intent.getType().equals("text/plain") ) {
			url = extras.getCharSequence("android.intent.extra.TEXT");
			if (G.DEBUG) Log.d(getClass().getName(), "URL: " + url);
			// Create the default message
			String checkThisOut = getResources().getString(R.string.check_this_out);
			// Dump the url to the edit text view
			EditText shareEdit = (EditText)findViewById(R.id.reply_edit);
			shareEdit.setText(checkThisOut + " " + url);
			shareEdit.setSelection(0, checkThisOut.length());
		}
		// Hide the Yammer logo
		findViewById(R.id.share_logo).setVisibility(View.VISIBLE);
	}

#end
#end
#No. 188784
#File: E:\bishe\1\YammerShare.java
#Comment:
	/**
	 * Handle clicks on the send button
	 */

#Code:
	protected OnClickListener onReplyListener = new OnClickListener() {
		public void onClick(View v) {
			if (G.DEBUG) Log.d(getClass().getName(), ".onClick");
			// Get the reply from the edit box
			EditText replyEdit = (EditText)findViewById(R.id.reply_edit);
			String message = replyEdit.getText().toString();
			// Create an intent containing the message
			Intent intent = new Intent();
			intent.setAction(YammerService.INTENT_POST_MESSAGE);
			intent.putExtra(YammerService.EXTRA_MESSAGE, message);
			// Post the intent to the service
			sendBroadcast(intent);
			// Shut down the activity
			finish();
		}
	};


#end
#end
#No. 188787
#File: E:\bishe\1\YandexSynthesiser.java
#Comment:
    /**
     * Get speaker voice
     */

#Code:
    public String getSpeaker() {
        return speaker;
    }

#end
#end
#No. 188788
#File: E:\bishe\1\YandexSynthesiser.java
#Comment:
    /**
     * Set speaker voice
     *
     * @param speaker voice - jane, omazh, zahar or ermil
     */

#Code:
    public void setSpeaker(String speaker) {
        this.speaker = speaker;
    }

#end
#end
#No. 188789
#File: E:\bishe\1\YandexSynthesiser.java
#Comment:
    /**
     * Gets an input stream to MP3 data for the returned information from a request
     *
     * @param synthText Text you want to be synthesized into MP3 data
     * @return Returns an input stream of the MP3 data that is returned from Google
     * @throws java.io.IOException Throws exception if it can not complete the request
     */

#Code:
    public InputStream getMP3Data(String synthText) throws IOException {

        String languageCode = "ru-RU";

        if (synthText.length() > 100) {
            List<String> fragments = parseString(synthText);//parses String if too long
            InputStream out = getMP3Data(fragments);
            return out;
        }

        String encoded = URLEncoder.encode(synthText, "UTF-8"); //Encode

        StringBuilder sb = new StringBuilder(YANDEX_SYNTHESISER_URL);
        sb.append("?key=" + API_KEY);
        sb.append("&text=" + encoded);
        sb.append("&lang=" + languageCode);
        sb.append("&format=mp3");
        sb.append("&speaker=" + speaker);

        URL url = new URL(sb.toString()); //create url

        // Open New URL connection channel.
        URLConnection urlConn = url.openConnection(); //Open connection

        urlConn.addRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:2.0) Gecko/20100101 Firefox/4.0"); //Adding header for user agent is required

        return urlConn.getInputStream();
    }

#end
#end
#No. 188790
#File: E:\bishe\1\YandexSynthesiser.java
#Comment:
    /**
     * Gets an InputStream to MP3Data for the returned information from a request
     *
     * @param synthText List of Strings you want to be synthesized into MP3 data
     * @return Returns an input stream of all the MP3 data that is returned from Google
     * @throws java.io.IOException Throws exception if it cannot complete the request
     */

#Code:
    public InputStream getMP3Data(List<String> synthText) throws IOException {
        //Uses an executor service pool for concurrency. Limit to 1000 threads max.
        ExecutorService pool = Executors.newFixedThreadPool(1000);
        //Stores the Future (Data that will be returned in the future)
        Set<Future<InputStream>> set = new LinkedHashSet<Future<InputStream>>(synthText.size());
        for (String part : synthText) { //Iterates through the list
            Callable<InputStream> callable = new MP3DataFetcher(part);//Creates Callable
            Future<InputStream> future = pool.submit(callable);//Begins to run Callable
            set.add(future);//Adds the response that will be returned to a set.
        }
        List<InputStream> inputStreams = new ArrayList<InputStream>(set.size());
        for (Future<InputStream> future : set) {
            try {
                inputStreams.add(future.get());//Gets the returned data from the future.
            } catch (ExecutionException e) {//Thrown if the MP3DataFetcher encountered an error.
                Throwable ex = e.getCause();
                if (ex instanceof IOException) {
                    throw (IOException) ex;//Downcasts and rethrows it.
                }
            } catch (InterruptedException e) {//Will probably never be called, but just in case...
                Thread.currentThread().interrupt();//Interrupts the thread since something went wrong.
            }
        }
        return new SequenceInputStream(Collections.enumeration(inputStreams));//Sequences the stream.
    }

#end
#end
#No. 188791
#File: E:\bishe\1\YandexSynthesiser.java
#Comment:
    /**
     * Separates a string into smaller parts so that Google will not reject the request.
     *
     * @param input The string you want to separate
     * @return A List<String> of the String fragments from your input..
     */

#Code:
    private List<String> parseString(String input) {
        return parseString(input, new ArrayList<String>());
    }

#end
#end
#No. 188792
#File: E:\bishe\1\YandexSynthesiser.java
#Comment:
    /**
     * Separates a string into smaller parts so that Google will not reject the request.
     *
     * @param input     The string you want to break up into smaller parts
     * @param fragments List<String> that you want to add stuff too.
     *                  If you don't have a List<String> already constructed "new ArrayList<String>()" works well.
     * @return A list of the fragments of the original String
     */

#Code:
    private List<String> parseString(String input, List<String> fragments) {
        if (input.length() <= 100) {//Base Case
            fragments.add(input);
            return fragments;
        } else {
            int lastWord = findLastWord(input);//Checks if a space exists
            if (lastWord <= 0) {
                fragments.add(input.substring(0, 100));//In case you sent gibberish to Google.
                return parseString(input.substring(100), fragments);
            } else {
                fragments.add(input.substring(0, lastWord));//Otherwise, adds the last word to the list for recursion.
                return parseString(input.substring(lastWord), fragments);
            }
        }
    }

#end
#end
#No. 188793
#File: E:\bishe\1\YandexSynthesiser.java
#Comment:
    /**
     * Finds the last word in your String (before the index of 99) by searching for spaces and ending punctuation.
     * Will preferably parse on punctuation to alleviate mid-sentence pausing
     *
     * @param input The String you want to search through.
     * @return The index of where the last word of the string ends before the index of 99.
     */

#Code:
    private int findLastWord(String input) {
        if (input.length() < 100)
            return input.length();
        int space = -1;
        for (int i = 99; i > 0; i--) {
            char tmp = input.charAt(i);
            if (isEndingPunctuation(tmp)) {
                return i + 1;
            }
            if (space == -1 && tmp == ' ') {
                space = i;
            }
        }
        if (space > 0) {
            return space;
        }
        return -1;
    }

#end
#end
#No. 188794
#File: E:\bishe\1\YandexSynthesiser.java
#Comment:
    /**
     * Checks if char is an ending character
     * Ending punctuation for all languages according to Wikipedia (Except for Sanskrit non-unicode)
     *
     * @param input char you want check
     * @return True if it is, false if not.
     */

#Code:
    private boolean isEndingPunctuation(char input) {
        return input == '.' || input == '!' || input == '?' || input == ';' || input == ':' || input == '|';
    }




#end
#end
#No. 188797
#File: E:\bishe\1\YandexTranslateAPI.java
#Comment:
    /**
     * Validates if {@code YandexTranslateAPI.setReferer()} was called properly.
     *
     * @throws YandexAPIException if validation fails
     */

#Code:
    protected void validate() throws YandexAPIException {
        if (referer == null || referer.isEmpty()) {
            throw new YandexAPIException(String.format("HTTP request header '%s' is not set.", HEADER_REFERER));
        }
    }

#end
#end
#No. 188798
#File: E:\bishe\1\YandexTranslateAPI.java
#Comment:
    /**
     * Validates required request parameters.
     *
     * @param lang translation direction
     * @param text the text to be validated
     * @throws YandexAPIException if validation fails
     */

#Code:
    protected void validate(final Language lang, final String text) throws YandexAPIException {
        validate();

        if (lang == null) {
            throw new YandexAPIException(String.format("Service: Empty parameter '%s'", PARAM_LANG));
        }

        if (text == null || text.isEmpty()) {
            throw new YandexAPIException(String.format("Service: Empty parameter '%s'", PARAM_TEXT));
        }
    }

#end
#end
#No. 188799
#File: E:\bishe\1\YandexTranslateAPI.java
#Comment:
    /**
     * Sends HTTP request using GET method and returns the response as a String.
     *
     * @param url the URL
     * @return String representation of response
     * @throws IOException on error or if response status code is not 200 (OK)
     */

#Code:
    protected String getResponse(final URL url) throws IOException {
        final HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setRequestProperty(HEADER_REFERER, referer);
        connection.setRequestProperty(HEADER_CONTENT_TYPE, "text/plain; charset=" + ENCODING);
        connection.setRequestProperty(HEADER_ACCEEPT_CHARSET, ENCODING);
        connection.setRequestMethod(METHOD_GET);
        connection.setDoOutput(true);

        try {
            return convertInputStreamToString(connection.getInputStream());
        } finally {
            connection.disconnect();
        }
    }



#end
#end
#No. 188808
#File: E:\bishe\1\YangAnnotationModel.java
#Comment:
    /**
     * @param resource
     */

#Code:
    public YangAnnotationModel(IResource resource) {
        super(resource);
    }

#end
#end
#No. 188809
#File: E:\bishe\1\YangAnnotationModel.java
#Comment:
    /**
     * @param isCanceled
     */

#Code:
    private void removeMarkerOverlays(boolean isCanceled) {
        if (isCanceled) {
            curOverlaid.addAll(prevOverlaid);
        } else if (prevOverlaid != null) {
            Iterator<YangMarkerAnnotation> e = prevOverlaid.iterator();
            while (e.hasNext()) {
                YangMarkerAnnotation annotation = e.next();
                annotation.markDeleted(true);
            }
        }
    }

#end
#end
#No. 188810
#File: E:\bishe\1\YangAnnotationModel.java
#Comment:
    /**
     * @param position
     * @param annotation
     */

#Code:
    private void overlayMarkers(Position position, YangSyntaxAnnotation annotation) {
        Iterator<?> it = getAnnotationIterator();
        while (it.hasNext()) {
            Object obj = it.next();
            if (obj instanceof YangMarkerAnnotation) {
                YangMarkerAnnotation m = (YangMarkerAnnotation) obj;
                if (position.equals(m.getPosition())) {
                    m.markDeleted(false);
                    prevOverlaid.remove(m);
                    curOverlaid.add(m);
                }
            }
        }
    }

#end
#end
#No. 188811
#File: E:\bishe\1\YangCodeFormatter.java
#Comment:
    /**
     * @param preferences
     */

#Code:
    public YangCodeFormatter(YangFormattingPreferences preferences) {
        this.preferences = preferences;
    }

#end
#end
#No. 188812
#File: E:\bishe\1\YangCodeGeneratorDialog.java
#Comment:
    /**
     * @return the config
     */

#Code:
    public CodeGeneratorConfig getConfig() {
        return config;
    }

#end
#end
#No. 188813
#File: E:\bishe\1\YangColorManager.java
#Comment:
    /**
     * Flag which tells if the colors are automatically disposed when the current display gets
     * disposed.
     */

#Code:
    private boolean fAutoDisposeOnDisplayDispose;

    /**
     * Creates a new YANG color manager which automatically disposes the allocated colors when the
     * current display gets disposed.
     */
    public YangColorManager() {
        this(true);
    }

#end
#end
#No. 188814
#File: E:\bishe\1\YangColorManager.java
#Comment:
    /**
     * Creates a new YANG color manager.
     *
     * @param autoDisposeOnDisplayDispose if <code>true</code> the color manager automatically
     * disposes all managed colors when the current display gets disposed and all calls to
     * {@link org.eclipse.jface.text.source.ISharedTextColors#dispose()} are ignored.
     */

#Code:
    public YangColorManager(boolean autoDisposeOnDisplayDispose) {
        fAutoDisposeOnDisplayDispose = autoDisposeOnDisplayDispose;
    }

#end
#end
#No. 188815
#File: E:\bishe\1\YangColorManager.java
#Comment:
    /*
     * @see IColorManager#getColor(RGB)
     */

#Code:
    public Color getColor(RGB rgb) {

        if (rgb == null)
            return null;

        final Display display = Display.getCurrent();
        Map<RGB, Color> colorTable = fDisplayTable.get(display);
        if (colorTable == null) {
            colorTable = new HashMap<RGB, Color>(10);
            fDisplayTable.put(display, colorTable);
            if (fAutoDisposeOnDisplayDispose) {
                display.disposeExec(new Runnable() {
                    public void run() {
                        dispose(display);
                    }
                });
            }
        }

        Color color = colorTable.get(rgb);
        if (color == null) {
            color = new Color(Display.getCurrent(), rgb);
            colorTable.put(rgb, color);
        }

        return color;
    }

#end
#end
#No. 188816
#File: E:\bishe\1\YangColorManager.java
#Comment:
    /*
     * @see IColorManager#dispose
     */

#Code:
    public void dispose() {
        if (!fAutoDisposeOnDisplayDispose)
            dispose(Display.getCurrent());
    }

#end
#end
#No. 188817
#File: E:\bishe\1\YangColorManager.java
#Comment:
    /*
     * @see IColorManager#getColor(String)
     */

#Code:
    public Color getColor(String key) {

        if (key == null)
            return null;

        RGB rgb = fKeyTable.get(key);
        return getColor(rgb);
    }

#end
#end
#No. 188818
#File: E:\bishe\1\YangColorManager.java
#Comment:
    /*
     * @see IColorManagerExtension#bindColor(String, RGB)
     */

#Code:
    public void bindColor(String key, RGB rgb) {
        Object value = fKeyTable.get(key);
        if (value != null)
            throw new UnsupportedOperationException();

        fKeyTable.put(key, rgb);
    }

#end
#end
#No. 188819
#File: E:\bishe\1\YangColorManager.java
#Comment:
    /*
     * @see IColorManagerExtension#unbindColor(String)
     */

#Code:
    public void unbindColor(String key) {
        fKeyTable.remove(key);
    }

#end
#end
#No. 188820
#File: E:\bishe\1\YangCommentScanner.java
#Comment:
    /**
     * @param manager
     * @param store
     */

#Code:
    public YangCommentScanner(IColorManager manager, IPreferenceStore store) {
        super(manager, store);
    }

#end
#end
#No. 188821
#File: E:\bishe\1\YangDiagramBehavior.java
#Comment:
    /**
     * @return the createPosition
     */

#Code:
    public Point getCreatePosition() {
        return createPosition;
    }

#end
#end
#No. 188822
#File: E:\bishe\1\YangDiagramBehavior.java
#Comment:
    /**
     * @param createPosition the createPosition to set
     */

#Code:
    public void setCreatePosition(Point createPosition) {
        this.createPosition = createPosition;
    }

#end
#end
#No. 188823
#File: E:\bishe\1\YangDiagramEditor.java
#Comment:
    /**
     * @return
     */

#Code:
    public IModelChangeHandler getModelChangeHandler() {
        return modelChangeHandler;
    }

#end
#end
#No. 188824
#File: E:\bishe\1\YangDiagramEditor.java
#Comment:
    /**
     * Enables selection of source code element that corresponds to the selected diagram shape.
     */

#Code:
    public void startSourceSelectionUpdater() {
        GraphicalViewer graphicalViewer = getGraphicalViewer();
        if (graphicalViewer != null)
            graphicalViewer.addSelectionChangedListener(sourceSelectionUpdater);
    }

#end
#end
#No. 188825
#File: E:\bishe\1\YangDiagramEditor.java
#Comment:
    /**
     * Disables selection of source code element that corresponds to the selected diagram shape.
     */

#Code:
    public void stopSourceSelectionUpdater() {
        GraphicalViewer graphicalViewer = getGraphicalViewer();
        if (graphicalViewer != null)
            graphicalViewer.removeSelectionChangedListener(sourceSelectionUpdater);
    }

#end
#end
#No. 188826
#File: E:\bishe\1\YangDiagramEditorInput.java
#Comment:
    /**
     * @param diagramUri
     * @param providerId
     */

#Code:
    public YangDiagramEditorInput(URI diagramUri, IFile file, String providerId, Module m) {
        super(diagramUri, providerId);
        this.file = file;
        this.module = m;
    }

#end
#end
#No. 188827
#File: E:\bishe\1\YangDiagramEditorInput.java
#Comment:
    /**
     * @return the module
     */

#Code:
    public Module getModule() {
        return module;
    }


#end
#end
#No. 188829
#File: E:\bishe\1\YangDiagramRefreshBehavior.java
#Comment:
    /**
     * @param diagramBehavior
     */

#Code:
    public YangDiagramRefreshBehavior(DiagramBehavior diagramBehavior) {
        super(diagramBehavior);
    }

#end
#end
#No. 188830
#File: E:\bishe\1\YangEditor.java
#Comment:
    /**
     * @return {@link Module} of the current editor input or <code>null</code> if editor input does
     * not contains appropriate {@link Module}
     * @throws YangModelException error during initialization of Module
     */

#Code:
    public Module getModule() throws YangModelException {
        IEditorInput input = getEditorInput();
        if (input == null) {
            return null;
        }

        if (input instanceof IFileEditorInput) {
            IFile file = ((IFileEditorInput) input).getFile();
            return YangCorePlugin.createYangFile(file).getModule();
        } else if (input instanceof JarEntryEditorInput) {
            JarEntryEditorInput jarInput = (JarEntryEditorInput) input;
            IStorage storage = jarInput.getStorage();
            if (storage instanceof YangJarFileEntryResource) {
                YangJarFileEntryResource jarEntry = (YangJarFileEntryResource) storage;
                return YangCorePlugin.createJarEntry(jarEntry.getPath(), jarEntry.getEntry()).getModule();
            } else if (storage instanceof JarEntryFile) {
                JarEntryFile jarEntry = (JarEntryFile) storage;
                return YangCorePlugin.createJarEntry(jarEntry.getPackageFragmentRoot().getPath(),
                        jarEntry.getFullPath().makeRelative().toString()).getModule();
            }
        }
        return null;
    }

#end
#end
#No. 188831
#File: E:\bishe\1\YangEditorMessages.java
#Comment:
    /**
     * @return the bundleName
     */

#Code:
    public static String getBundleName() {
        return BUNDLE_NAME;
    }

#end
#end
#No. 188832
#File: E:\bishe\1\YangEditorTemplatesPage.java
#Comment:
    /*
     * @see org.eclipse.ui.texteditor.templates.TemplatePreferencePage#updateViewerInput()
     */

#Code:
    protected void updateViewerInput() {
        IStructuredSelection selection = (IStructuredSelection) getTableViewer().getSelection();
        SourceViewer viewer = getViewer();

        if (selection.size() == 1 && selection.getFirstElement() instanceof TemplatePersistenceData) {
            TemplatePersistenceData data = (TemplatePersistenceData) selection.getFirstElement();
            Template template = data.getTemplate();
            viewer.getDocument().set(template.getPattern());

        } else {
            viewer.getDocument().set("");
        }
    }

#end
#end
#No. 188833
#File: E:\bishe\1\YangElement.java
#Comment:
    /**
     * @param buffer
     * @return
     */

#Code:
    public boolean canBufferBeRemovedFromCache(IBuffer buffer) {
        return !buffer.hasUnsavedChanges();
    }

#end
#end
#No. 188834
#File: E:\bishe\1\YangElement.java
#Comment:
    /**
     * Opens a buffer on the contents of this element, and returns the buffer, or returns
     * <code>null</code> if opening fails. By default, do nothing - subclasses that have buffers
     * must override as required.
     */

#Code:
    protected IBuffer openBuffer(IProgressMonitor pm, Object info) throws YangModelException {
        return null;
    }

#end
#end
#No. 188835
#File: E:\bishe\1\YangElement.java
#Comment:
    /*
     * Opens an <code>Openable</code> that is known to be closed (no check for
     * <code>isOpen()</code>). Returns the created element info.
     */

#Code:
    protected OpenableElementInfo openWhenClosed(OpenableElementInfo info, IProgressMonitor monitor)
            throws YangModelException {
        YangModelManager manager = YangModelManager.getYangModelManager();
        HashMap<IOpenable, OpenableElementInfo> newElements = new HashMap<IOpenable, OpenableElementInfo>();
        generateInfos(info, newElements, monitor);
        if (info == null) {
            info = newElements.get(this);
        }
        manager.putInfos(this, newElements);
        return info;
    }



#end
#end
#No. 188837
#File: E:\bishe\1\YangElementDelta.java
#Comment:
    /**
     * Creates the nested delta deltas based on the affected element its delta, and the root of this
     * delta tree. Returns the root of the created delta tree.
     */

#Code:
    protected YangElementDelta createDeltaTree(YangElement element, YangElementDelta delta) {
        YangElementDelta childDelta = delta;
        ArrayList<IOpenable> ancestors = getAncestors(element);
        if (ancestors == null) {
            if (equalsAndSameParent(delta.getElement(), getElement())) {
                this.kind = delta.kind;
            }
        } else {
            for (int i = 0, size = ancestors.size(); i < size; i++) {
                YangElement ancestor = (YangElement) ancestors.get(i);
                YangElementDelta ancestorDelta = new YangElementDelta(ancestor);
                ancestorDelta.addAffectedChild(childDelta);
                childDelta = ancestorDelta;
            }
        }
        return childDelta;
    }

#end
#end
#No. 188838
#File: E:\bishe\1\YangElementDelta.java
#Comment:
    /**
     * Returns whether the two yang elements are equals and have the same parent.
     */

#Code:
    protected boolean equalsAndSameParent(YangElement e1, YangElement e2) {
        IOpenable parent1;
        return e1.equals(e2) && ((parent1 = e1.getParent()) != null) && parent1.equals(e2.getParent());
    }

#end
#end
#No. 188839
#File: E:\bishe\1\YangElementDelta.java
#Comment:
    /**
     * Adds the new element to a new array that contains all of the elements of the old array.
     * Returns the new array.
     */

#Code:
    protected IYangElementDelta[] growAndAddToArray(IYangElementDelta[] array, IYangElementDelta addition) {
        IYangElementDelta[] old = array;
        array = new IYangElementDelta[old.length + 1];
        System.arraycopy(old, 0, array, 0, old.length);
        array[old.length] = addition;
        return array;
    }

#end
#end
#No. 188840
#File: E:\bishe\1\YangElementDelta.java
#Comment:
    /**
     * Removes the child delta from the collection of affected children.
     */

#Code:
    protected void removeAffectedChild(YangElementDelta child) {
        int index = -1;
        if (this.affectedChildren != null) {
            for (int i = 0; i < this.affectedChildren.length; i++) {
                if (equalsAndSameParent(this.affectedChildren[i].getElement(), child.getElement())) {
                    index = i;
                    break;
                }
            }
        }
        if (index >= 0) {
            this.affectedChildren = removeAndShrinkArray(this.affectedChildren, index);
        }
    }

#end
#end
#No. 188841
#File: E:\bishe\1\YangElementDelta.java
#Comment:
    /**
     * Returns the delta for a given element. Only looks below this delta.
     */

#Code:
    protected YangElementDelta getDeltaFor(YangElement element) {
        if (equalsAndSameParent(getElement(), element)) {
            return this;
        }

        if (this.affectedChildren.length == 0) {
            return null;
        }
        int childrenCount = this.affectedChildren.length;
        for (int i = 0; i < childrenCount; i++) {
            YangElementDelta delta = (YangElementDelta) this.affectedChildren[i];
            if (equalsAndSameParent(delta.getElement(), element)) {
                return delta;
            } else {
                delta = delta.getDeltaFor(element);
                if (delta != null)
                    return delta;
            }
        }
        return null;
    }

#end
#end
#No. 188842
#File: E:\bishe\1\YangElementDelta.java
#Comment:
    /**
     * Removes the element from the array. Returns the a new array which has shrunk.
     */

#Code:
    protected IYangElementDelta[] removeAndShrinkArray(IYangElementDelta[] old, int index) {
        IYangElementDelta[] array = new IYangElementDelta[old.length - 1];
        if (index > 0)
            System.arraycopy(old, 0, array, 0, index);
        int rest = old.length - index - 1;
        if (rest > 0)
            System.arraycopy(old, index + 1, array, index, rest);
        return array;
    }

#end
#end
#No. 188843
#File: E:\bishe\1\YangFile.java
#Comment:
    /**
     * @param resource
     * @param parent
     */

#Code:
    public YangFile(IFile resource, IOpenable parent) {
        super(parent);
        this.resource = resource;
    }

#end
#end
#No. 188844
#File: E:\bishe\1\YangFileInfo.java
#Comment:
    /**
     * @return the module
     */

#Code:
    public Module getModule() {
        return module;
    }

#end
#end
#No. 188845
#File: E:\bishe\1\YangFileInfo.java
#Comment:
    /**
     * @param module the module to set
     */

#Code:
    public void setModule(Module module) {
        this.module = module;
    }



#end
#end
#No. 188847
#File: E:\bishe\1\YangFileWizard.java
#Comment:
    /**
     * @return InputStream of template with replaced placeholders.
     * @throws IOException read errors
     */

#Code:
    private InputStream getTemplateContent() throws IOException {
        StringBuilder sb = new StringBuilder();

        char[] buff = new char[1024];
        int len = 0;
        Path templatePath = new Path("resources/yang/new_yang_file.yang");
        try (InputStreamReader in = new InputStreamReader(FileLocator.openStream(YangUIPlugin.getDefault().getBundle(),
                templatePath, false), "UTF-8")) {
            while ((len = in.read(buff)) > 0) {
                sb.append(buff, 0, len);
            }
        }
        String str = sb.toString();
        str = str.replaceAll("%MODULE%", yangPage.getModule());
        str = str.replaceAll("%NAMESPACE%", yangPage.getNamespace());
        str = str.replaceAll("%PREFIX%", yangPage.getPrefix());
        str = str.replaceAll("%REVISION%", yangPage.getRevision());
        str = str.replaceAll("%REVISION_DESC%", yangPage.getRevisionDesc());

        return new ByteArrayInputStream(str.toString().getBytes("UTF-8"));
    }

#end
#end
#No. 188848
#File: E:\bishe\1\YangFileWizardPage.java
#Comment:
    /**
     * Initializes fields from file page.
     */

#Code:
    public void init() {
        String name = filePage.getFileName();
        if (name.indexOf('.') > 0) {
            name = name.substring(0, name.indexOf('.'));
        }
        moduleTxt.setText(name);
        namespaceTxt.setText("urn:opendaylight:" + name);
        prefixTxt.setText(name);
    }

#end
#end
#No. 188849
#File: E:\bishe\1\YangFileWizardPage.java
#Comment:
    /**
     * @return the module
     */

#Code:
    public String getModule() {
        return moduleTxt.getText();
    }

#end
#end
#No. 188850
#File: E:\bishe\1\YangFileWizardPage.java
#Comment:
    /**
     * @return the namespace
     */

#Code:
    public String getNamespace() {
        return namespaceTxt.getText();
    }

#end
#end
#No. 188851
#File: E:\bishe\1\YangFileWizardPage.java
#Comment:
    /**
     * @return the prefix
     */

#Code:
    public String getPrefix() {
        return prefixTxt.getText();
    }

#end
#end
#No. 188852
#File: E:\bishe\1\YangFileWizardPage.java
#Comment:
    /**
     * @return the revision
     */

#Code:
    public String getRevision() {
        return revisionTxt.getText();
    }

#end
#end
#No. 188853
#File: E:\bishe\1\YangFileWizardPage.java
#Comment:
    /**
     * @return the revision description
     */

#Code:
    public String getRevisionDesc() {
        return revisionDescTxt.getText();
    }

#end
#end
#No. 188854
#File: E:\bishe\1\YangFolder.java
#Comment:
    /**
     * @param resource
     * @param parent
     */

#Code:
    public YangFolder(IResource resource, IOpenable parent) {
        super(parent);
        this.resource = resource;
    }

#end
#end
#No. 188855
#File: E:\bishe\1\YangFoldingStructureProvider.java
#Comment:
    /**
     * A mapping of the foldable position to the
     * <code>AntElementNode<code> that represent that region
     */

#Code:

    private Map fPositionToElement = new HashMap();

    public YangFoldingStructureProvider(YangEditor editor) {
        fEditor = editor;
    }

#end
#end
#No. 188856
#File: E:\bishe\1\YangFoldingStructureProvider.java
#Comment:
    /**
     * @param headerCommentCandidate
     * @return
     */

#Code:
    private boolean isHeaderComment(Position headerCommentCandidate) {
        if(headerCommentCandidate == null) {
            return false;
        }

        YangPartitionScanner scanner = new YangPartitionScanner();
        scanner.setRange(fDocument, 0, fDocument.getLength());

        try {
            // first token must be YANG_COMMENT

            String contentType = null;
            IToken token;
            do {
                token = scanner.nextToken();
                contentType = getTokenContentType(token);
            } while (contentType == null && !token.isEOF());

            if (contentType != null && contentType.equals(YangPartitionScanner.YANG_COMMENT)) {

                int tokenStartLine = fDocument.getLineOfOffset(scanner.getTokenOffset());
                int tokenEndLine = fDocument.getLineOfOffset(scanner.getTokenOffset() + scanner.getTokenLength());

                int start = fDocument.getLineOffset(tokenStartLine);
                int end = fDocument.getLineOffset(tokenEndLine) + fDocument.getLineLength(tokenEndLine);
                Position tokenPosition = new Position(start, end - start);

                if (headerCommentCandidate.equals(tokenPosition)) {
                    return true;
                }

            }

        } catch (BadLocationException e) {
            YangEditorPlugin.log(e);
        }

        return false;
    }

#end
#end
#No. 188857
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @return the indentSize
     */

#Code:
    public int getIndentSize() {
        return indentSize;
    }

#end
#end
#No. 188858
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @param indentSize the indentSize to set
     */

#Code:
    public void setIndentSize(int indentSize) {
        this.indentSize = indentSize;
    }

#end
#end
#No. 188859
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @return the spaceForTabs
     */

#Code:
    public boolean isSpaceForTabs() {
        return spaceForTabs;
    }

#end
#end
#No. 188860
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @param spaceForTabs the spaceForTabs to set
     */

#Code:
    public void setSpaceForTabs(boolean spaceForTabs) {
        this.spaceForTabs = spaceForTabs;
    }

#end
#end
#No. 188861
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @return the maxLineLength
     */

#Code:
    public int getMaxLineLength() {
        return maxLineLength;
    }

#end
#end
#No. 188862
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @param maxLineLength the maxLineLength to set
     */

#Code:
    public void setMaxLineLength(int maxLineLength) {
        this.maxLineLength = maxLineLength;
    }

#end
#end
#No. 188863
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @return the formatComment
     */

#Code:
    public boolean isFormatComment() {
        return formatComment;
    }

#end
#end
#No. 188864
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @param formatComment the formatComment to set
     */

#Code:
    public void setFormatComment(boolean formatComment) {
        this.formatComment = formatComment;
    }

#end
#end
#No. 188865
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @return the formatStrings
     */

#Code:
    public boolean isFormatStrings() {
        return formatStrings;
    }

#end
#end
#No. 188866
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @param formatStrings the formatStrings to set
     */

#Code:
    public void setFormatStrings(boolean formatStrings) {
        this.formatStrings = formatStrings;
    }

#end
#end
#No. 188867
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @return the compactImport
     */

#Code:
    public boolean isCompactImport() {
        return compactImport;
    }

#end
#end
#No. 188868
#File: E:\bishe\1\YangFormattingPreferences.java
#Comment:
    /**
     * @param compactImport the compactImport to set
     */

#Code:
    public void setCompactImport(boolean compactImport) {
        this.compactImport = compactImport;
    }

#end
#end
#No. 188869
#File: E:\bishe\1\YangGeneratorConfiguration.java
#Comment:
    /**
     * @return the codeGeneratorClass
     */

#Code:
    public String getCodeGeneratorClass() {
        return codeGeneratorClass;
    }

#end
#end
#No. 188870
#File: E:\bishe\1\YangGeneratorConfiguration.java
#Comment:
    /**
     * @param codeGeneratorClass the codeGeneratorClass to set
     */

#Code:
    public void setCodeGeneratorClass(String codeGeneratorClass) {
        this.codeGeneratorClass = codeGeneratorClass;
    }

#end
#end
#No. 188871
#File: E:\bishe\1\YangGeneratorConfiguration.java
#Comment:
    /**
     * @return the outputBaseDir
     */

#Code:
    public File getOutputBaseDir() {
        return outputBaseDir;
    }

#end
#end
#No. 188872
#File: E:\bishe\1\YangGeneratorConfiguration.java
#Comment:
    /**
     * @param outputBaseDir the outputBaseDir to set
     */

#Code:
    public void setOutputBaseDir(File outputBaseDir) {
        this.outputBaseDir = outputBaseDir;
    }

#end
#end
#No. 188873
#File: E:\bishe\1\YangGeneratorConfiguration.java
#Comment:
    /**
     * @return the resourceBaseDir
     */

#Code:
    public File getResourceBaseDir() {
        return resourceBaseDir;
    }

#end
#end
#No. 188874
#File: E:\bishe\1\YangGeneratorConfiguration.java
#Comment:
    /**
     * @param resourceBaseDir the resourceBaseDir to set
     */

#Code:
    public void setResourceBaseDir(File resourceBaseDir) {
        this.resourceBaseDir = resourceBaseDir;
    }

#end
#end
#No. 188875
#File: E:\bishe\1\YangGeneratorConfiguration.java
#Comment:
    /**
     * @return the additionalConfiguration
     */

#Code:
    public Map<String, String> getAdditionalConfiguration() {
        return additionalConfiguration;
    }

#end
#end
#No. 188876
#File: E:\bishe\1\YangGeneratorConfiguration.java
#Comment:
    /**
     * @param additionalConfiguration the additionalConfiguration to set
     */

#Code:
    public void setAdditionalConfiguration(Map<String, String> additionalConfiguration) {
        this.additionalConfiguration = additionalConfiguration;
    }

#end
#end
#No. 188877
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Peeks the next char in the document that comes after <code>offset</code> on the same line as
     * <code>offset</code>.
     */

#Code:
    private int peekChar(int offset) {
        if (offset < fDocument.getLength()) {
            try {
                IRegion line = fDocument.getLineInformationOfOffset(offset);
                int lineOffset = line.getOffset();
                int next = fScanner.nextToken(offset, lineOffset + line.getLength());
                return next;
            } catch (BadLocationException e) {
            }
        }
        return Symbols.TokenEOF;
    }

#end
#end
#No. 188878
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Tells whether the given string is a continuation expression.
     */

#Code:
    private boolean isStringContinuation(int offset) {
        int nextNonWSCharPosition = fScanner.findNonWhitespaceBackwardInAnyPartition(offset - 1,
                YangHeuristicScanner.UNBOUND);
        try {
            if (fDocument.getChar(nextNonWSCharPosition) == '"') {
                return true;
            } else {
                return false;
            }
        } catch (BadLocationException e) {
            YangEditorPlugin.log(e);
            return false;
        }
    }

#end
#end
#No. 188879
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Checks if the statement at position is itself a continuation of the previous, else sets the
     * indentation to Continuation Indent.
     *
     * @return the position of the token
     */

#Code:
    private int handleEqual() {
        try {
            // If this line is itself continuation of the previous then do nothing
            IRegion line = fDocument.getLineInformationOfOffset(fPosition);
            int nonWS = fScanner.findNonWhitespaceBackward(line.getOffset(), YangHeuristicScanner.UNBOUND);
            if (nonWS != Symbols.TokenEOF) {
                int tokenAtPreviousLine = fScanner.nextToken(nonWS, nonWS + 1);
                if (tokenAtPreviousLine != Symbols.TokenSEMICOLON && tokenAtPreviousLine != Symbols.TokenRBRACE
                        && tokenAtPreviousLine != Symbols.TokenLBRACE && tokenAtPreviousLine != Symbols.TokenEOF) {
                    return fPosition;
                }
            }
        } catch (BadLocationException e) {
            return fPosition;
        }

        fIndent = fPrefs.prefContinuationIndent;
        return fPosition;
    }

#end
#end
#No. 188880
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Returns true if the colon at the current position is part of a conditional (ternary)
     * expression, false otherwise.
     *
     * @return true if the colon at the current position is part of a conditional
     */

#Code:
    private boolean isConditional() {
        while (true) {
            nextToken();
            switch (fToken) {

            // search for case labels, which consist of (possibly qualified) identifiers or numbers
            case Symbols.TokenIDENT:
            case Symbols.TokenOTHER: // dots for qualified constants
                continue;
            default:
                return true;
            }
        }
    }

#end
#end
#No. 188881
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Skips a scope and positions the cursor (<code>fPosition</code>) on the token that opens the
     * scope. Returns <code>true</code> if a matching peer could be found, <code>false</code>
     * otherwise. The current token when calling must be one out of <code>Symbols.TokenRPAREN</code>
     * , <code>Symbols.TokenRBRACE</code>, and <code>Symbols.TokenRBRACKET</code>.
     *
     * @return <code>true</code> if a matching peer was found, <code>false</code> otherwise
     */

#Code:
    private boolean skipScope() {
        switch (fToken) {
        case Symbols.TokenRPAREN:
            return skipScope(Symbols.TokenLPAREN, Symbols.TokenRPAREN);
        case Symbols.TokenRBRACKET:
            return skipScope(Symbols.TokenLBRACKET, Symbols.TokenRBRACKET);
        case Symbols.TokenRBRACE:
            return skipScope(Symbols.TokenLBRACE, Symbols.TokenRBRACE);
        case Symbols.TokenGREATERTHAN:
            if (!fPrefs.prefHasGenerics) {
                return false;
            }
            int storedPosition = fPosition;
            int storedToken = fToken;
            nextToken();
            switch (fToken) {
            case Symbols.TokenIDENT:
                //$FALL-THROUGH$
            case Symbols.TokenQUESTIONMARK:
            case Symbols.TokenGREATERTHAN:
                if (skipScope(Symbols.TokenLESSTHAN, Symbols.TokenGREATERTHAN)) {
                    return true;
                }
            }
            // <> are harder to detect - restore the position if we fail
            fPosition = storedPosition;
            fToken = storedToken;
            return false;

        default:
            Assert.isTrue(false);
            return false;
        }
    }

#end
#end
#No. 188882
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Sets the deep indent offset (<code>fAlign</code>) to either the offset right after
     * <code>scopeIntroducerOffset</code> or - if available - the first YANG token after
     * <code>scopeIntroducerOffset</code>, but before <code>bound</code>.
     *
     * @param scopeIntroducerOffset the offset of the scope introducer
     * @param bound the bound for the search for another element
     * @return the reference position
     */

#Code:
    private int setFirstElementAlignment(int scopeIntroducerOffset, int bound) {
        int firstPossible = scopeIntroducerOffset + 1; // align with the first position after the
        // scope intro
        fAlign = fScanner.findNonWhitespaceForwardInAnyPartition(firstPossible, bound);
        if (fAlign == YangHeuristicScanner.NOT_FOUND) {
            fAlign = firstPossible;
        }
        return fAlign;
    }

#end
#end
#No. 188883
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Returns <code>true</code> if the next token received after calling <code>nextToken</code> is
     * either an equal sign or an array designator ('[]').
     *
     * @return <code>true</code> if the next elements look like the start of an array definition
     */

#Code:
    private boolean looksLikeArrayInitializerIntro() {
        nextToken();
        if (fToken == Symbols.TokenEQUAL || skipBrackets()) {
            return true;
        }
        return false;
    }

#end
#end
#No. 188884
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Skips brackets if the current token is a RBRACKET. There can be nothing but whitespace in
     * between, this is only to be used for <code>[]</code> elements.
     *
     * @return <code>true</code> if a <code>[]</code> could be scanned, the current token is left at
     * the LBRACKET.
     */

#Code:
    private boolean skipBrackets() {
        if (fToken == Symbols.TokenRBRACKET) {
            nextToken();
            if (fToken == Symbols.TokenLBRACKET) {
                return true;
            }
        }
        return false;
    }

#end
#end
#No. 188885
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Reads the next token in backward direction from the heuristic scanner and sets the fields
     * <code>fToken, fPreviousPosition</code> and <code>fPosition</code> accordingly.
     */

#Code:
    private void nextToken() {
        nextToken(fPosition);
    }

#end
#end
#No. 188886
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Reads the next token in backward direction of <code>start</code> from the heuristic scanner
     * and sets the fields <code>fToken, fPreviousPosition</code> and <code>fPosition</code>
     * accordingly.
     *
     * @param start the start offset from which to scan backwards
     */

#Code:
    private void nextToken(int start) {
        fToken = fScanner.previousToken(start - 1, YangHeuristicScanner.UNBOUND);
        fPreviousPos = start;
        fPosition = fScanner.getPosition() + 1;
        try {
            fLine = fDocument.getLineOfOffset(fPosition);
        } catch (BadLocationException e) {
            fLine = -1;
        }
    }

#end
#end
#No. 188887
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Returns <code>true</code> if the current tokens look like a method declaration header (i.e.
     * only the return type and method name). The heuristic calls <code>nextToken</code> and expects
     * an identifier (method name) and a type declaration (an identifier with optional brackets)
     * which also covers the visibility modifier of constructors; it does not recognize package
     * visible constructors.
     *
     * @return <code>true</code> if the current position looks like a method declaration header.
     */

#Code:
    private boolean looksLikeMethodDecl() {
        /*
         * TODO This heuristic does not recognize package private constructors since those do have
         * neither type nor visibility keywords. One option would be to go over the parameter list,
         * but that might be empty as well, or not typed in yet - hard to do without an AST...
         */

        nextToken();
        if (fToken == Symbols.TokenIDENT) { // method name
            do {
                nextToken();
            } while (skipBrackets()); // optional brackets for array valued return types

            return fToken == Symbols.TokenIDENT; // return type name

        }
        return false;
    }

#end
#end
#No. 188888
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Returns <code>true</code> if the current tokens look like an annotation (i.e. an annotation
     * name (potentially qualified) preceded by an at-sign).
     *
     * @return <code>true</code> if the current position looks like an annotation.
     */

#Code:

    private boolean looksLikeAnnotation() {
        nextToken();
        if (fToken == Symbols.TokenIDENT) { // Annotation name
            nextToken();
            while (fToken == Symbols.TokenOTHER) { // dot of qualification
                nextToken();
                if (fToken != Symbols.TokenIDENT) {
                    return false;
                }
                nextToken();
            }
            return fToken == Symbols.TokenAT;
        }
        return false;
    }

#end
#end
#No. 188889
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Returns <code>true</code> if the current tokens look like a method call header (i.e. an
     * identifier as opposed to a keyword taking parenthesized parameters such as <code>if</code>).
     * <p>
     * The heuristic calls <code>nextToken</code> and expects an identifier (method name).
     *
     * @return <code>true</code> if the current position looks like a method call header.
     */

#Code:
    private boolean looksLikeMethodCall() {
        nextToken();
        return fToken == Symbols.TokenIDENT; // method name
    }

#end
#end
#No. 188890
#File: E:\bishe\1\YangIndenter.java
#Comment:
    /**
     * Scans tokens for the matching opening peer. The internal cursor (<code>fPosition</code>) is
     * set to the offset of the opening peer if found.
     *
     * @param openToken the opening peer token
     * @param closeToken the closing peer token
     * @return <code>true</code> if a matching token was found, <code>false</code> otherwise
     */

#Code:
    private boolean skipScope(int openToken, int closeToken) {

        int depth = 1;

        while (true) {
            nextToken();

            if (fToken == closeToken) {
                depth++;
            } else if (fToken == openToken) {
                depth--;
                if (depth == 0) {
                    return true;
                }
            } else if (fToken == Symbols.TokenEOF) {
                return false;
            }
        }
    }

#end
#end
#No. 188891
#File: E:\bishe\1\YangJarFile.java
#Comment:
    /**
     * @param resource
     * @param parent
     */

#Code:
    public YangJarFile(IPath path, IOpenable parent) {
        super(parent);
        this.path = path;
    }

#end
#end
#No. 188892
#File: E:\bishe\1\YangM2EPlugin.java
#Comment:
    /**
     * Returns the shared instance
     *
     * @return the shared instance
     */

#Code:
    public static YangM2EPlugin getDefault() {
        return plugin;
    }


#end
#end
#No. 188895
#File: E:\bishe\1\YangModelManager.java
#Comment:
    /**
     * @param element
     * @return
     */

#Code:
    public synchronized Object getInfo(IOpenable element) {
        return cache.get(element);
    }

#end
#end
#No. 188896
#File: E:\bishe\1\YangModelManager.java
#Comment:
    /*
     * Puts the infos in the given map (keys are IJavaElements and values are JavaElementInfos) in
     * the Java model cache in an atomic way.
     */

#Code:
    protected synchronized void putInfos(IOpenable openedElement, Map<IOpenable, OpenableElementInfo> newElements) {
        Object existingInfo = this.cache.get(openedElement);
        closeChildren(existingInfo);

        Iterator<Entry<IOpenable, OpenableElementInfo>> iterator = newElements.entrySet().iterator();
        while (iterator.hasNext()) {
            Entry<IOpenable, OpenableElementInfo> entry = iterator.next();
            this.cache.put(entry.getKey(), entry.getValue());
        }
    }

#end
#end
#No. 188897
#File: E:\bishe\1\YangModelManager.java
#Comment:
    /*
     * Removes all cached info for the given element (including all children) from the cache.
     * Returns the info for the given element, or null if it was closed.
     */

#Code:
    public synchronized Object removeInfoAndChildren(IOpenable element) throws YangModelException {
        Object info = this.cache.get(element);
        if (info != null) {
            closeChildren(info);
            this.cache.remove(element);
            return info;
        }
        return null;
    }

#end
#end
#No. 188898
#File: E:\bishe\1\YangModelManager.java
#Comment:
    /**
     * @return the yangModel
     */

#Code:
    public YangModel getYangModel() {
        return yangModel;
    }

#end
#end
#No. 188899
#File: E:\bishe\1\YangModelManager.java
#Comment:
    /**
     * @return index manager
     */

#Code:
    public static IndexManager getIndexManager() {
        return MANAGER.indexManager;
    }

#end
#end
#No. 188900
#File: E:\bishe\1\YangMultiPageEditorPart.java
#Comment:
    /**
     * @return the yangSourceEditor
     */

#Code:
    public YangEditor getYangSourceEditor() {
        return yangSourceEditor;
    }

#end
#end
#No. 188901
#File: E:\bishe\1\YangMultiPageEditorPart.java
#Comment:
    /**
     * @return the yangDiagramEditor
     */

#Code:
    public YangDiagramEditor getYangDiagramEditor() {
        return yangDiagramEditor;
    }

#end
#end
#No. 188902
#File: E:\bishe\1\YangPaletteBehavior.java
#Comment:
            /**
             * @return Palette Key Handler for the palette
             */

#Code:
            private KeyHandler getPaletteKeyHandler() {
                if (paletteKeyHandler == null) {
                    paletteKeyHandler = new KeyHandler() {
                        /**
                         * Processes a <i>key released </i> event. This method is called by the Tool
                         * whenever a key is released, and the Tool is in the proper state.
                         * Overridden to support pressing the enter key to create a shape or
                         * connection (between two selected shapes)
                         *
                         * @param event the KeyEvent
                         * @return <code>true</code> if KeyEvent was handled in some way
                         */
                        @Override
                        public boolean keyReleased(KeyEvent event) {
                            if (event.keyCode == SWT.Selection) {
                                Tool tool = getEditDomain().getPaletteViewer().getActiveTool().createTool();
                                if (tool instanceof CreationTool || tool instanceof ConnectionCreationTool) {
                                    tool.keyUp(event, diagramBehavior.getDiagramContainer().getGraphicalViewer());
                                    // Deactivate current selection
                                    getEditDomain().getPaletteViewer().setActiveTool(null);
                                    return true;
                                }
                            }
                            return super.keyReleased(event);
                        }
                    };
                }
                return paletteKeyHandler;
            }

#end
#end
#No. 188903
#File: E:\bishe\1\YangParserModelListener.java
#Comment:
    /**
     * @return
     */

#Code:
    public Module getModule() {
        return module;
    }

#end
#end
#No. 188904
#File: E:\bishe\1\YangParserModelListener.java
#Comment:
    /**
     * @param typeName
     * @return
     */

#Code:
    private QName parseQName(String typeName) {
        String[] parts = typeName.split(":");
        if (parts.length == 2) {
            ModuleImport moduleImport = module.getImportByPrefix(parts[0]);
            if (moduleImport != null) {
                return new QName(moduleImport.getName(), moduleImport.getPrefix(), parts[1], moduleImport.getRevision());
            }

            if (module instanceof SubModule) {
                SubModule subModule = (SubModule) module;
                if (parts[0].equals(subModule.getParentPrefix())) {
                    return new QName(subModule.getParentModule().getValue(), parts[0], parts[1], null);
                }
            }
        }

        String prefix = module.getPrefix() != null ? module.getPrefix().getValue() : null;
        return new QName(module.getName(), prefix, typeName, revision);
    }

#end
#end
#No. 188905
#File: E:\bishe\1\YangParserModelListener.java
#Comment:
    /**
     * Parse given tree and get first string value.
     *
     * @param treeNode tree to parse
     * @return first string value from given tree
     */

#Code:
    private static String stringFromNode(final ParseTree treeNode) {
        String result = "";
        for (int i = 0; i < treeNode.getChildCount(); ++i) {
            if (treeNode.getChild(i) instanceof StringContext) {
                final StringContext context = (StringContext) treeNode.getChild(i);
                if (context != null) {
                    return stringFromStringContext(context);

                }
            }
        }
        return result;
    }

#end
#end
#No. 188906
#File: E:\bishe\1\YangParserUtil.java
#Comment:
    /**
     * Parses YANG file contents and returns AST tree as {@link Module}
     *
     * @param chars file contents
     * @return AST Tree
     */

#Code:
    public static Module parseYangFile(char[] chars) {
        YangContext yangContext = parseYangSource(chars, null);
        YangParserModelListener modelListener = new YangParserModelListener();
        ParseTreeWalker.DEFAULT.walk(modelListener, yangContext);
        return modelListener.getModule();
    }

#end
#end
#No. 188907
#File: E:\bishe\1\YangParserUtil.java
#Comment:
    /**
     * @param chars
     * @param project
     * @param validationListener
     * @return
     */

#Code:
    public static Module parseYangFile(char[] chars, IProject project, IYangValidationListener validationListener) {
        YangContext yangContext = parseYangSource(chars, validationListener);
        if (validationListener != null) {
            validateYangContext(yangContext, validationListener);
        }
        YangParserModelListener modelListener = new YangParserModelListener();
        ParseTreeWalker.DEFAULT.walk(modelListener, yangContext);
        Module module = modelListener.getModule();
        if (validationListener != null) {
            new SemanticValidations(validationListener, project, module).validate();
        }
        return module;
    }


#end
#end
#No. 188909
#File: E:\bishe\1\YangProblem.java
#Comment:
    /**
     * @param annotation
     * @param position
     */

#Code:
    public YangProblem(YangSyntaxAnnotation annotation, Position position) {
        this.annotation = annotation;
        this.position = position;
    }

#end
#end
#No. 188910
#File: E:\bishe\1\YangProblem.java
#Comment:
    /**
     * @return the annotation
     */

#Code:
    public YangSyntaxAnnotation getAnnotation() {
        return annotation;
    }

#end
#end
#No. 188911
#File: E:\bishe\1\YangProblem.java
#Comment:
    /**
     * @return the position
     */

#Code:
    public Position getPosition() {
        return position;
    }

#end
#end
#No. 188912
#File: E:\bishe\1\YangProject.java
#Comment:
    /**
     * @param parent
     */

#Code:
    public YangProject(IProject project, IOpenable parent) {
        super(parent);
        this.project = project;
    }

#end
#end
#No. 188913
#File: E:\bishe\1\YangProjectConfigurator.java
#Comment:
    /**
     * Returns list of MojoExecutions this configurator is enabled for.
     */

#Code:
    @Override
    protected List<MojoExecution> getMojoExecutions(ProjectConfigurationRequest request, IProgressMonitor monitor)
            throws CoreException {
        IMavenProjectFacade projectFacade = request.getMavenProjectFacade();

        Map<String, Set<MojoExecutionKey>> configuratorExecutions = getPatchedConfiguratorExecutions(projectFacade);

        ArrayList<MojoExecution> executions = new ArrayList<MojoExecution>();

        Set<MojoExecutionKey> executionKeys = configuratorExecutions.get(getId());
        if (executionKeys != null) {
            for (MojoExecutionKey key : executionKeys) {
                executions.add(projectFacade.getMojoExecution(key, monitor));
            }
        }

        return executions;
    }

#end
#end
#No. 188914
#File: E:\bishe\1\YangProjectInfo.java
#Comment:
    /**
     * @return the projectScope
     */

#Code:
    public Set<String> getProjectScope() {
        return projectScope;
    }

#end
#end
#No. 188915
#File: E:\bishe\1\YangProjectInfo.java
#Comment:
    /**
     * @param projectScope the projectScope to set
     */

#Code:
    public void setProjectScope(Set<String> projectScope) {
        this.projectScope = projectScope;
    }

#end
#end
#No. 188916
#File: E:\bishe\1\YangProjectInfo.java
#Comment:
    /**
     * @return the indirectScope
     */

#Code:
    public Set<String> getIndirectScope() {
        return indirectScope;
    }

#end
#end
#No. 188917
#File: E:\bishe\1\YangProjectInfo.java
#Comment:
    /**
     * @param indirectScope the indirectScope to set
     */

#Code:
    public void setIndirectScope(Set<String> indirectScope) {
        this.indirectScope = indirectScope;
    }


#end
#end
#No. 188919
#File: E:\bishe\1\YangProjectWizard.java
#Comment:
    /**
     * Creates single configuration parameter.
     *
     * @param name name
     * @param value value
     * @return config parameter
     */

#Code:
    private Xpp3Dom createSingleParameter(String name, String value) {
        Xpp3Dom parameter = new Xpp3Dom(name);
        parameter.setValue(value);
        return parameter;
    }

#end
#end
#No. 188920
#File: E:\bishe\1\YangProjectWizard.java
#Comment:
    /**
     * @param name name
     * @param url url
     * @return repository configuration by name and url
     */

#Code:
    private Repository createRepoParameter(String name, String url) {
        Repository r = new Repository();
        r.setId(name);
        r.setName(name);
        r.setUrl(url);
        return r;
    }

#end
#end
#No. 188921
#File: E:\bishe\1\YangPropertySection.java
#Comment:
    /**
     * @return the obj
     */

#Code:
    protected EObject getEObject() {
        return obj;
    }



#end
#end
#No. 188923
#File: E:\bishe\1\YangRenameProcessor.java
#Comment:
    /**
     * @return the node
     */

#Code:
    public T getNode() {
        return node;
    }

#end
#end
#No. 188924
#File: E:\bishe\1\YangScanner.java
#Comment:
    /**
     * @param manager
     * @param store
     */

#Code:
    public YangScanner(IColorManager manager, IPreferenceStore store) {
        super(manager, store);
    }

#end
#end
#No. 188925
#File: E:\bishe\1\YangSourceViewer.java
#Comment:
    /**
     * Prepends the text presentation listener at the beginning of the viewer's list of text
     * presentation listeners. If the listener is already registered with the viewer this call moves
     * the listener to the beginning of the list.
     *
     * @param listener the text presentation listener
     */

#Code:
    @SuppressWarnings("unchecked")
    public void prependTextPresentationListener(ITextPresentationListener listener) {
        if (fTextPresentationListeners == null) {
            fTextPresentationListeners = new ArrayList<ITextPresentationListener>();
        }

        fTextPresentationListeners.remove(listener);
        fTextPresentationListeners.add(0, listener);
    }

#end
#end
#No. 188926
#File: E:\bishe\1\YangSourceViewer.java
#Comment:
    /**
     * @return the reconciler
     */

#Code:
    public IReconciler getReconciler() {
        return fReconciler;
    }

#end
#end
#No. 188927
#File: E:\bishe\1\YangSourceViewerConfiguration.java
#Comment:
    /**
     * @return the commentScanner
     */

#Code:
    public YangCommentScanner getYangCommentScanner() {
        if (commentScanner == null) {
            commentScanner = new YangCommentScanner(colorManager, preferencesStore);
        }
        return commentScanner;
    }


#end
#end
#No. 188929
#File: E:\bishe\1\YangSourceViewerConfiguration.java
#Comment:
    /**
     * Determines whether the preference change encoded by the given event changes the behavior of
     * one of its contained components.
     */

#Code:
    public boolean affectsTextPresentation(PropertyChangeEvent event) {
        return scanner.affectsBehavior(event) || stringScanner.affectsBehavior(event)
                || commentScanner.affectsBehavior(event);

    }

#end
#end
#No. 188930
#File: E:\bishe\1\YangSourceViewerConfiguration.java
#Comment:
    /**
     * Adapts the behavior of the contained components to the change encoded in the given event.
     */

#Code:
    public void handlePropertyChangeEvent(PropertyChangeEvent event) {

        if (scanner.affectsBehavior(event)) {
            scanner.adaptToPreferenceChange(event);
        }
        if (stringScanner.affectsBehavior(event)) {
            stringScanner.adaptToPreferenceChange(event);
        }
        if (commentScanner.affectsBehavior(event)) {
            commentScanner.adaptToPreferenceChange(event);

        }
    }

#end
#end
#No. 188931
#File: E:\bishe\1\YangSourceViewerConfiguration.java
#Comment:
    /**
     * @return the editor
     */

#Code:
    protected ITextEditor getEditor() {
        return editor;
    }



#end
#end
#No. 188933
#File: E:\bishe\1\YangStringScanner.java
#Comment:
    /**
     * @param manager
     * @param store
     */

#Code:
    public YangStringScanner(IColorManager manager, IPreferenceStore store) {
        super(manager, store);
    }

#end
#end
#No. 188934
#File: E:\bishe\1\YangTemplateAccess.java
#Comment:
    /**
     * Returns the shared instance.
     */

#Code:
    public static YangTemplateAccess getDefault() {
        if (fgInstance == null) {
            fgInstance = new YangTemplateAccess();
        }
        return fgInstance;
    }

#end
#end
#No. 188935
#File: E:\bishe\1\YangTemplateAccess.java
#Comment:
    /**
     * Returns this plug-in's context type registry.
     */

#Code:
    public ContextTypeRegistry getContextTypeRegistry() {
        if (fRegistry == null) {
            // create and configure the contexts available in the template editor
            fRegistry = new ContributionContextTypeRegistry();
            fRegistry.addContextType(GeneralContextType.CONTEXT_TYPE);
        }
        return fRegistry;
    }

#end
#end
#No. 188936
#File: E:\bishe\1\YangTextHover.java
#Comment:
    /**
     * @param editor the editor to set
     */

#Code:
    public void setEditor(IEditorPart editor) {
        this.editor = editor;
    }

#end
#end
#No. 188937
#File: E:\bishe\1\YangTextHover.java
#Comment:
    /**
     * @return the editor
     */

#Code:
    public IEditorPart getEditor() {
        return editor;
    }

#end
#end
#No. 188938
#File: E:\bishe\1\YangTokenFormatter.java
#Comment:
    /**
     * @param token token to inspect
     * @return <code>true</code> if token should be ignored from processing
     */

#Code:
    private boolean checkForIgnore(Token token) {

        // ignore any repeat whitespace
        if (isWS(token) && (wasWS || wasNL)) {
            return true;
        }

        // ignore multiple new lines
        if (isNewLine(token) && (ovrNL || nlCount > 1)) {
            ovrNL = false;
            return true;
        }
        return false;
    }

#end
#end
#No. 188939
#File: E:\bishe\1\YangTokenFormatter.java
#Comment:
    /**
     * @param token
     * @return <code>true</code> if token processed by import case
     */

#Code:
    private boolean processImportCase(Token token) {
        if (!compactImport) {
            return false;
        }

        if (token.getType() == YangLexer.IMPORT_KEYWORD) {
            importScope = true;
            importStatement = new StringBuilder();
        }

        if (importScope) {
            if (token.getType() == RIGHT_BRACE) {
                importScope = false;
                printIndent();
                sb.append(importStatement.toString()).append(' ');
                wasWS = true;
                nlCount = 0;
                // add indent for right brace processing
                currIndent += indent;
                return false;
            } else if (!isNewLine(token) && !isWS(token)) {
                if (importStatement.length() > 0 && token.getType() != SEMICOLON) {
                    importStatement.append(' ');
                }
                importStatement.append(token.getText());
            }
            return true;
        }

        return importScope;
    }

#end
#end
#No. 188940
#File: E:\bishe\1\YangTokenFormatter.java
#Comment:
    /**
     * Prints formatted string token.
     *
     * @param token string token
     */

#Code:
    private void printFormattedString(String str) {
        String text = str;
        text = text.replaceAll("\\s+", " ");

        boolean firstLine = true;
        StringBuilder textSB = new StringBuilder();
        StringTokenizer st = new StringTokenizer(text);
        while (st.hasMoreTokens()) {
            if (textSB.length() > 0) {
                textSB.append(" ");
            }
            textSB.append(st.nextToken());
            if (textSB.length() > maxLineLength) {
                if (!firstLine || wasNL) {
                    printIndent();
                    printIndent();
                }
                sb.append(textSB.toString());
                if (st.hasMoreTokens()) {
                    sb.append(lineSeparator);
                }
                textSB = new StringBuilder();
                firstLine = false;
            }
        }
        if (textSB.length() > 0) {
            if (!firstLine || wasNL) {
                printIndent();
                printIndent();
            }
            sb.append(textSB.toString());
        }
    }

#end
#end
#No. 188941
#File: E:\bishe\1\YangTokenFormatter.java
#Comment:
    /**
     * Updates the state before token processed.
     *
     * @param token current token
     */

#Code:
    private void updatePreState(Token token) {
        int type = token.getType();

        // decrease indent if '}' token

#end
#end
#No. 188942
#File: E:\bishe\1\YangValidationException.java
#Comment:
    /**
     * @return the context
     */

#Code:
    public ParseTree getContext() {
        return context;
    }



#end
#end
#No. 188944
#File: E:\bishe\1\YardCalculator.java
#Comment:
   /**
    * Constructs a YardCalculator with the given parameters
    * @param theLength the length of the yard
    * @param theWidth the width of the yard
    */

#Code:
   public YardCalculator(double theLength, double theWidth)
   {
	   l = theLength;
	   w = theWidth;
   }   

#end
#end
#No. 188945
#File: E:\bishe\1\YardCalculator.java
#Comment:
   /**
    * Gets the perimeter of the yard
    * @return the perimeter
    */

#Code:
   public double perimeter()
   {
	   return (2 * l + 2 * w) * METERS_PER_FOOT;
   }

#end
#end
#No. 188946
#File: E:\bishe\1\YardCalculator.java
#Comment:
   /**
    * Gets the area of the yard
    * @return the area
    */

#Code:
   public double area()
   {
	   return l * w * Math.pow(METERS_PER_FOOT, 2);
   }

#end
#end
#No. 188947
#File: E:\bishe\1\YardCalculator.java
#Comment:
    /**
    * Gets the diagonal of the yard
    * @return the diagonal
    */

#Code:
   public double diagonal()
   {
	   return Math.sqrt(Math.pow(l, 2) + Math.pow(w, 2)) * METERS_PER_FOOT;
   }

#end
#end
#No. 188948
#File: E:\bishe\1\YARNAPIService.java
#Comment:
    /**
     * @param uri
     * @return JSONObject
     */

#Code:
    private JSONObject get(String uri) {
        JSONObject jsonObject = null;
        try {
            RestClient client = new RestClient();
            Resource resource = client.resource(uri);
            jsonObject = resource.get(JSONObject.class);
        } catch (Exception e) {
            e.printStackTrace();
            log.error(e);
            Map<String, String> status = new HashMap<String, String>();
            status.put(Response.STATUS, e.getMessage());
            jsonObject = new JSONObject(status);
        }

        return jsonObject;
    }


#end
#end
#No. 188950
#File: E:\bishe\1\YarnRMConnector.java
#Comment:
  /**
   * YARN only allows one resource size per priority, so map resource sizes
   * to priorities.
   * Should be able to remove this when YARN-314 is fixed and choose purely on
   * locality.
   */

#Code:
  static Priority getRequestPriority(int mbs, int vcores,
      com.cloudera.llama.am.api.Resource.Locality locality) {
    // Lower values mean higher priority
    // More restrictive localities should get higher priority because they are
    // harder to satisfy
    // Higher values should get higher priority because they are harder to satisfy
    // Giving memory priority over CPU isn't ideal, but the alternative isn't any better
    int priority;
    switch (locality) {
      case MUST:
        priority = 1000000;
        break;
      case PREFERRED:
        priority = 2000000;
        break;
      default:
        priority = 3000000;
        break;
    }

    priority -= mbs;
    priority -= vcores;
    return Priority.newInstance(priority);
  }




#end
#end
#No. 188953
#File: E:\bishe\1\YatomataImpl.java
#Comment:
    /**
     * Constructs the engine with the default state and initialize the new FSM instance
     */

#Code:
    public YatomataImpl(Class<T> fsmClass) throws FSMException, IllegalAccessException, InstantiationException {
        this(fsmClass, fsmClass.newInstance());
    }

#end
#end
#No. 188954
#File: E:\bishe\1\YatomataImpl.java
#Comment:
    /**
     * Constructs the engine with the default state and the defined FSM instance
     */

#Code:
    public YatomataImpl(Class<T> fsmClass, T fsm) throws FSMException {
        this.fsmClass = fsmClass;
        this.fsm = fsm;
        this.fsmClassInfo = get(fsmClass);
        this.currentState = fsmClassInfo.initStartState(fsm);
    }

#end
#end
#No. 188955
#File: E:\bishe\1\YatomataImpl.java
#Comment:
    /**
     * Constructs the engine with the defined state
     */

#Code:
    public YatomataImpl(Class<T> fsmClass, T fsm, Object currentState) throws FSMException {
        this(fsmClass, fsm);
        this.currentState = currentState;
    }

#end
#end
#No. 188956
#File: E:\bishe\1\YatomataImpl.java
#Comment:
    /**
     * Returns the current state for the FSM
     */

#Code:
    @Override
    public Object getCurrentState() {
        return currentState;
    }

#end
#end
#No. 188957
#File: E:\bishe\1\YatomataImpl.java
#Comment:
    /**
     * Checks if the FSM is already completed
     */

#Code:
    @Override
    public boolean isCompleted() {
        return completed;
    }

#end
#end
#No. 188958
#File: E:\bishe\1\YatomataImpl.java
#Comment:
    /**
     * Returns the internal FSM class
     */

#Code:
    @Override
    public Class<T> getFSMClass() {
        return fsmClass;
    }

#end
#end
#No. 188959
#File: E:\bishe\1\YatomataImpl.java
#Comment:
    /**
     * Returns the internal FSM instance
     */

#Code:
    @Override
    public T getFSM() {
        return fsm;
    }

#end
#end
#No. 188960
#File: E:\bishe\1\YAxisRenderer.java
#Comment:
    /**
     * draws the y-labels on the specified x-position
     *
     * @param fixedPosition
     * @param positions
     */

#Code:
    protected void drawYLabels(Canvas c, float fixedPosition, float[] positions, float offset) {

        final int from = mYAxis.isDrawBottomYLabelEntryEnabled() ? 0 : 1;
        final int to = mYAxis.isDrawTopYLabelEntryEnabled()
                ? mYAxis.mEntryCount
                : (mYAxis.mEntryCount - 1);

        // draw
        for (int i = from; i < to; i++) {

            String text = mYAxis.getFormattedLabel(i);

            c.drawText(text, fixedPosition, positions[i * 2 + 1] + offset, mAxisLabelPaint);
        }
    }

#end
#end
#No. 188961
#File: E:\bishe\1\YAxisRenderer.java
#Comment:
    /**
     * Calculates the path for a grid line.
     *
     * @param p
     * @param i
     * @param positions
     * @return
     */

#Code:
    protected Path linePath(Path p, int i, float[] positions) {

        p.moveTo(mViewPortHandler.offsetLeft(), positions[i + 1]);
        p.lineTo(mViewPortHandler.contentRight(), positions[i + 1]);

        return p;
    }

#end
#end
#No. 188962
#File: E:\bishe\1\YAxisRenderer.java
#Comment:
    /**
     * Transforms the values contained in the axis entries to screen pixels and returns them in form of a float array
     * of x- and y-coordinates.
     *
     * @return
     */

#Code:
    protected float[] getTransformedPositions() {

        if(mGetTransformedPositionsBuffer.length != mYAxis.mEntryCount * 2){
            mGetTransformedPositionsBuffer = new float[mYAxis.mEntryCount * 2];
        }
        float[] positions = mGetTransformedPositionsBuffer;

        for (int i = 0; i < positions.length; i += 2) {
            // only fill y values, x values are not needed for y-labels
            positions[i + 1] = mYAxis.mEntries[i / 2];
        }

        mTrans.pointValuesToPixel(positions);
        return positions;
    }

#end
#end
#No. 188963
#File: E:\bishe\1\YAxisRenderer.java
#Comment:
    /**
     * Draws the zero line.
     */

#Code:
    protected void drawZeroLine(Canvas c) {

        int clipRestoreCount = c.save();
        mZeroLineClippingRect.set(mViewPortHandler.getContentRect());
        mZeroLineClippingRect.inset(0.f, -mYAxis.getZeroLineWidth());
        c.clipRect(mZeroLineClippingRect);

        // draw zero line
        MPPointD pos = mTrans.getPixelForValues(0f, 0f);

        mZeroLinePaint.setColor(mYAxis.getZeroLineColor());
        mZeroLinePaint.setStrokeWidth(mYAxis.getZeroLineWidth());

        Path zeroLinePath = mDrawZeroLinePath;
        zeroLinePath.reset();

        zeroLinePath.moveTo(mViewPortHandler.contentLeft(), (float) pos.y);
        zeroLinePath.lineTo(mViewPortHandler.contentRight(), (float) pos.y);

        // draw a path because lines don't support dashing on lower android versions
        c.drawPath(zeroLinePath, mZeroLinePaint);

        c.restoreToCount(clipRestoreCount);
    }

#end
#end
#No. 188964
#File: E:\bishe\1\YAxisRendererHorizontalBarChart.java
#Comment:
    /**
     * Computes the axis values.
     *
     * @param yMin - the minimum y-value in the data object for this axis
     * @param yMax - the maximum y-value in the data object for this axis
     */

#Code:
    @Override
    public void computeAxis(float yMin, float yMax, boolean inverted) {

        // calculate the starting and entry point of the y-labels (depending on
        // zoom / contentrect bounds)
        if (mViewPortHandler.contentHeight() > 10 && !mViewPortHandler.isFullyZoomedOutX()) {

            MPPointD p1 = mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),
                    mViewPortHandler.contentTop());
            MPPointD p2 = mTrans.getValuesByTouchPoint(mViewPortHandler.contentRight(),
                    mViewPortHandler.contentTop());

            if (!inverted) {
                yMin = (float) p1.x;
                yMax = (float) p2.x;
            } else {
                yMin = (float) p2.x;
                yMax = (float) p1.x;
            }

            MPPointD.recycleInstance(p1);
            MPPointD.recycleInstance(p2);
        }

        computeAxisValues(yMin, yMax);
    }

#end
#end
#No. 188965
#File: E:\bishe\1\YAxisRendererHorizontalBarChart.java
#Comment:
    /**
     * draws the y-axis labels to the screen
     */

#Code:
    @Override
    public void renderAxisLabels(Canvas c) {

        if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())
            return;

        float[] positions = getTransformedPositions();

        mAxisLabelPaint.setTypeface(mYAxis.getTypeface());
        mAxisLabelPaint.setTextSize(mYAxis.getTextSize());
        mAxisLabelPaint.setColor(mYAxis.getTextColor());
        mAxisLabelPaint.setTextAlign(Align.CENTER);

        float baseYOffset = Utils.convertDpToPixel(2.5f);
        float textHeight = Utils.calcTextHeight(mAxisLabelPaint, "Q");

        AxisDependency dependency = mYAxis.getAxisDependency();
        YAxisLabelPosition labelPosition = mYAxis.getLabelPosition();

        float yPos = 0f;

        if (dependency == AxisDependency.LEFT) {

            if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
                yPos = mViewPortHandler.contentTop() - baseYOffset;
            } else {
                yPos = mViewPortHandler.contentTop() - baseYOffset;
            }

        } else {

            if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
                yPos = mViewPortHandler.contentBottom() + textHeight + baseYOffset;
            } else {
                yPos = mViewPortHandler.contentBottom() + textHeight + baseYOffset;
            }
        }

        drawYLabels(c, yPos, positions, mYAxis.getYOffset());
    }

#end
#end
#No. 188966
#File: E:\bishe\1\YAxisRendererHorizontalBarChart.java
#Comment:
    /**
     * draws the y-labels on the specified x-position
     *
     * @param fixedPosition
     * @param positions
     */

#Code:
    @Override
    protected void drawYLabels(Canvas c, float fixedPosition, float[] positions, float offset) {

        mAxisLabelPaint.setTypeface(mYAxis.getTypeface());
        mAxisLabelPaint.setTextSize(mYAxis.getTextSize());
        mAxisLabelPaint.setColor(mYAxis.getTextColor());

        final int from = mYAxis.isDrawBottomYLabelEntryEnabled() ? 0 : 1;
        final int to = mYAxis.isDrawTopYLabelEntryEnabled()
                ? mYAxis.mEntryCount
                : (mYAxis.mEntryCount - 1);

        for (int i = from; i < to; i++) {

            String text = mYAxis.getFormattedLabel(i);

            c.drawText(text, positions[i * 2], fixedPosition - offset, mAxisLabelPaint);
        }
    }

#end
#end
#No. 188967
#File: E:\bishe\1\YearClass.java
#Comment:
  /**
   * Entry Point of YearClass. Extracts YearClass variable with memoizing.
   * Example usage:
   * <p>
   * <pre>
   *   int yearClass = YearClass.get(context);
   * </pre>
   */

#Code:
  public static int get(Context c) {
    if (mYearCategory == null) {
      synchronized(YearClass.class) {
        if (mYearCategory == null) {
          mYearCategory = categorizeByYear2016Method(c);
        }
      }
    }
    return mYearCategory;
  }

#end
#end
#No. 188968
#File: E:\bishe\1\YearClass.java
#Comment:
  /**
   * This formulation of year class smooths out the distribution of devices in the field
   * in early 2016 so that the buckets are a bit more even in size and performance metrics
   * (specifically app startup time, scrolling perf, animations) are more uniform within
   * the buckets than with the 2014 calculations.
   */

#Code:
  private static int categorizeByYear2016Method(Context c) {
    long totalRam = DeviceInfo.getTotalMemory(c);
    if (totalRam == DeviceInfo.DEVICEINFO_UNKNOWN) {
      return categorizeByYear2014Method(c);
    }

    if (totalRam <= 768 * MB) {
      return DeviceInfo.getNumberOfCPUCores() <= 1 ? CLASS_2009 : CLASS_2010;
    }
    if (totalRam <= 1024 * MB) {
      return DeviceInfo.getCPUMaxFreqKHz() < 1300 * MHZ_IN_KHZ ? CLASS_2011 : CLASS_2012;
    }
    if (totalRam <= 1536 * MB) {
      return DeviceInfo.getCPUMaxFreqKHz() < 1800 * MHZ_IN_KHZ ? CLASS_2012 : CLASS_2013;
    }
    if (totalRam <= 2048 * MB) {
      return CLASS_2013;
    }
    return totalRam <= 3 * 1024 * MB ? CLASS_2014 : CLASS_2015;
  }

#end
#end
#No. 188969
#File: E:\bishe\1\YearClass.java
#Comment:
  /**
   * Calculates the "best-in-class year" of the device. This represents the top-end or flagship
   * devices of that year, not the actual release year of the phone. For example, the Galaxy Duos
   * S was released in 2012, but its specs are very similar to the Galaxy S that was released in
   * 2010 as a then top-of-the-line phone, so it is a 2010 device.
   *
   * @return The year when this device would have been considered top-of-the-line.
   */

#Code:
  private static int categorizeByYear2014Method(Context c) {
    ArrayList<Integer> componentYears = new ArrayList<Integer>();
    conditionallyAdd(componentYears, getNumCoresYear());
    conditionallyAdd(componentYears, getClockSpeedYear());
    conditionallyAdd(componentYears, getRamYear(c));
    if (componentYears.isEmpty())
      return CLASS_UNKNOWN;
    Collections.sort(componentYears);
    if ((componentYears.size() & 0x01) == 1) {  // Odd number; pluck the median.
      return componentYears.get(componentYears.size() / 2);
    } else { // Even number. Average the two "center" values.
      int baseIndex = componentYears.size() / 2 - 1;
      // There's an implicit rounding down in here; 2011.5 becomes 2011.
      return componentYears.get(baseIndex) +
          (componentYears.get(baseIndex + 1) - componentYears.get(baseIndex)) / 2;
    }
  }

#end
#end
#No. 188970
#File: E:\bishe\1\YearClass.java
#Comment:
  /**
   * Calculates the year class by the number of processor cores the phone has.
   * Evaluations are based off the table below:
   * <table border="1">
   * <thead>
   * <tr><th width="50%">Amount</th><th>Year</th></tr>
   * <thead>
   * <tbody>
   * <tr><td>>4 or More</td><td>2012</td></tr>
   * <tr><td>2 or 3</td><td>2011</td></tr>
   * <tr><td>1</td><td>2008</td></tr>
   * </tbody>
   * </table>
   *
   * @return the year in which top-of-the-line phones had the same number of processors as this phone.
   */

#Code:
  private static int getNumCoresYear() {
    int cores = DeviceInfo.getNumberOfCPUCores();
    if (cores < 1) return CLASS_UNKNOWN;
    if (cores == 1) return CLASS_2008;
    if (cores <= 3) return CLASS_2011;
    return CLASS_2012;
  }

#end
#end
#No. 188971
#File: E:\bishe\1\YearClass.java
#Comment:
  /**
   * Calculates the year class by the clock speed of the cores in the phone.
   * Evaluations are based off the table below:
   * <table border="1">
   * <thead>
   * <tr><th width="50%">Amount</th><th>Year</th></tr>
   * <thead>
   * <tbody>
   * <tr><td>>2GHz</td><td>2014</td></tr>
   * <tr><td><=2GHz</td><td>2013</td></tr>
   * <tr><td><=1.5GHz</td><td>2012</td></tr>
   * <tr><td><=1.2GHz</td><td>2011</td></tr>
   * <tr><td><=1GHz</td><td>2010</td></tr>
   * <tr><td><=600MHz</td><td>2009</td></tr>
   * <tr><td><=528MHz</td><td>2008</td></tr>
   * </tbody>
   * </table>
   *
   * @return the year in which top-of-the-line phones had the same clock speed.
   */

#Code:
  private static int getClockSpeedYear() {
    long clockSpeedKHz = DeviceInfo.getCPUMaxFreqKHz();
    if (clockSpeedKHz == DeviceInfo.DEVICEINFO_UNKNOWN) return CLASS_UNKNOWN;
    // These cut-offs include 20MHz of "slop" because my "1.5GHz" Galaxy S3 reports
    // its clock speed as 1512000. So we add a little slop to keep things nominally correct.
    if (clockSpeedKHz <= 528 * MHZ_IN_KHZ) return CLASS_2008;
    if (clockSpeedKHz <= 620 * MHZ_IN_KHZ) return CLASS_2009;
    if (clockSpeedKHz <= 1020 * MHZ_IN_KHZ) return CLASS_2010;
    if (clockSpeedKHz <= 1220 * MHZ_IN_KHZ) return CLASS_2011;
    if (clockSpeedKHz <= 1520 * MHZ_IN_KHZ) return CLASS_2012;
    if (clockSpeedKHz <= 2020 * MHZ_IN_KHZ) return CLASS_2013;
    return CLASS_2014;
  }

#end
#end
#No. 188972
#File: E:\bishe\1\YearClass.java
#Comment:
  /**
   * Calculates the year class by the amount of RAM the phone has.
   * Evaluations are based off the table below:
   * <table border="1">
   * <thead>
   * <tr><th width="50%">Amount</th><th>Year</th></tr>
   * <thead>
   * <tbody>
   * <tr><td>>2GB</td><td>2014</td></tr>
   * <tr><td><=2GB</td><td>2013</td></tr>
   * <tr><td><=1.5GB</td><td>2012</td></tr>
   * <tr><td><=1GB</td><td>2011</td></tr>
   * <tr><td><=512MB</td><td>2010</td></tr>
   * <tr><td><=256MB</td><td>2009</td></tr>
   * <tr><td><=128MB</td><td>2008</td></tr>
   * </tbody>
   * </table>
   *
   * @return the year in which top-of-the-line phones had the same amount of RAM as this phone.
   */

#Code:
  private static int getRamYear(Context c) {
    long totalRam = DeviceInfo.getTotalMemory(c);
    if (totalRam <= 0) return CLASS_UNKNOWN;
    if (totalRam <= 192 * MB) return CLASS_2008;
    if (totalRam <= 290 * MB) return CLASS_2009;
    if (totalRam <= 512 * MB) return CLASS_2010;
    if (totalRam <= 1024 * MB) return CLASS_2011;
    if (totalRam <= 1536 * MB) return CLASS_2012;
    if (totalRam <= 2048 * MB) return CLASS_2013;
    return CLASS_2014;
  }

#end
#end
#No. 188974
#File: E:\bishe\1\YearMonthListConverter.java
#Comment:
    /**
     * @param valueSeparator A regexp to use as list separate
     */

#Code:
    public YearMonthListConverter(String valueSeparator) {
        this.yearMonthConverter = new YearMonthConverter();
        this.valueSeparator = valueSeparator;
    }

#end
#end
#No. 188975
#File: E:\bishe\1\YearPicker.java
#Comment:
    /**
     * Set the range of selectable year value.
     * @param min The minimum selectable year value.
     * @param max The maximum selectable year value.
     */

#Code:
    public void setYearRange(int min, int max){
        mAdapter.setYearRange(min, max);
    }

#end
#end
#No. 188976
#File: E:\bishe\1\YearPicker.java
#Comment:
    /**
     * Jump to a specific year.
     * @param year
     */

#Code:
    public void goTo(int year){
        int position = mAdapter.positionOfYear(year) - mPositionShift;
        int offset = mDistanceShift;
        if(position < 0){
            position = 0;
            offset = 0;
        }
        postSetSelectionFromTop(position, offset);
    }

#end
#end
#No. 188977
#File: E:\bishe\1\YearPicker.java
#Comment:
    /**
     * Set the selected year.
     * @param year The selected year value.
     */

#Code:
    public void setYear(int year){
        if(mAdapter.getYear() == year)
            return;

        mAdapter.setYear(year);
        goTo(year);
    }

#end
#end
#No. 188978
#File: E:\bishe\1\YearPicker.java
#Comment:
    /**
     * @return The selected year value.
     */

#Code:
    public int getYear(){
        return mAdapter.getYear();
    }

#end
#end
#No. 188979
#File: E:\bishe\1\YearPicker.java
#Comment:
    /**
     * Set a listener will be called when the selected year value is changed.
     * @param listener The {@link OnYearChangedListener} will be called.
     */

#Code:
    public void setOnYearChangedListener(OnYearChangedListener listener){
        mOnYearChangedListener = listener;
    }

#end
#end
#No. 188983
#File: E:\bishe\1\YeastGenerator.java
#Comment:
	/**
	 * @param te - parent tile entity
	 * @param fluidSlotIndex - fluid slot id to use in parent
	 *             Fluid will be used from this slot
	 * @param invSlotIndex - inventory slot id to use in parent
	 *             Yeast will be generated into this slot
	 */

#Code:
	public YeastGenerator(TileEntityCellarDevice te, int fluidSlotIndex, int invSlotIndex)
	{
		super(te);
		this.fluidSlot = new DeviceFluidSlot(te, fluidSlotIndex);
		this.invSlot = new DeviceInventorySlot(te, invSlotIndex);
		setTimeMax(1200);
	}



#end
#end
#No. 188985
#File: E:\bishe\1\YeastGenerator.java
#Comment:
	/**
	 * Returns the current biome of the Yeast Generator's parent TileEntity.
	 *
	 * @return biome
	 */

#Code:
	public BiomeGenBase getCurrentBiome()
	{
		return getWorld().getBiomeGenForCoords(parent.xCoord, parent.zCoord);
	}

#end
#end
#No. 188986
#File: E:\bishe\1\YeastGenerator.java
#Comment:
	/**
	 * Determines if the given item stack can be replicated as a yeast item
	 *
	 * @param stack - item stack to test
	 * @return true, it can be replicated, false otherwise
	 */

#Code:
	public boolean canReplicateYeast(ItemStack stack)
	{
		// prevent production if the stack size is currently maxed
		if (stack.stackSize >= stack.getMaxStackSize()) return false;
		// prevent item pointless ticking with invalid items
		if (!CellarRegistry.instance().yeast().isYeast(stack)) return false;
		return true;
	}

#end
#end
#No. 188987
#File: E:\bishe\1\YeastGenerator.java
#Comment:
	/**
	 * Determines if the jar can produce any yeast
	 *
	 * @return true, the generator can produce yeast, false otherwise
	 */

#Code:
	public boolean canProduceYeast()
	{
		if (fluidSlot.getAmount() < consumption) return false;
		final ItemStack yeastItem = invSlot.get();
		// we can ignore null items, this will fallback to the initProduceYeast
		if (yeastItem != null)
		{
			if (!canReplicateYeast(yeastItem)) return false;
		}
		return CoreRegistry.instance().fluidDictionary().hasFluidTags(fluidSlot.getFluid(), BoozeTag.YOUNG);
	}

#end
#end
#No. 188988
#File: E:\bishe\1\YeastGenerator.java
#Comment:
	/**
	 * This is called to initialize the yeast slot, a random yeast type is
	 * chosen from the various biome types and set in the slot,
	 * any further yeast production will be of the same type.
	 */

#Code:
	protected void initProduceYeast()
	{
		tempItemList.clear();
		final BiomeGenBase biome = getCurrentBiome();
		if (biome != null)
		{
			final IYeastRegistry reg = CellarRegistry.instance().yeast();

			{
				final Collection<WeightedItemStack> yl = reg.getYeastListForBiomeName(biome.biomeName);
				if (yl != null)
				{
					tempItemList.addAll(yl);
				}
			}

			for (Type t : BiomeDictionary.getTypesForBiome(biome))
			{
				final Collection<WeightedItemStack> yeastList = reg.getYeastListForBiomeType(t);
				if (yeastList != null)
				{
					tempItemList.addAll(yeastList);
				}
			}

			if (tempItemList.size() > 0)
			{
				final WeightedItemStack weightedItemStack = (WeightedItemStack)WeightedRandom.getRandomItem(getWorld().rand, tempItemList);
				if (weightedItemStack != null && weightedItemStack.itemStack != null)
				{
					final ItemStack result = weightedItemStack.itemStack.copy();
					invSlot.set(result);
					consumeFluid();
				}
			}
		}
	}




#end
#end
#No. 188991
#File: E:\bishe\1\YellowPagesLoader.java
#Comment:
    /**
     * Fetchs yellow pages from server periodically (once per 3 days).
     */

#Code:
    public void fetchDataAsyncPeriodicaly() {
        Realm myRealm = null;
        YPDownload data;

        try {
            myRealm = Realm.getInstance(context);
            RealmQuery<YPDownload> query = myRealm.where(YPDownload.class);
            if (query.count() > 0) {
                data = query.findFirst();
            } else {
                myRealm.beginTransaction();
                data = myRealm.createObject(YPDownload.class);
                data.setWhen(0);
                myRealm.commitTransaction();
            }

            Log.d(TAG, "when: " + data.getWhen());

            if (System.currentTimeMillis() - data.getWhen() > 1000L * 60 * 60 * 24 * 3) {
                fetchDataAsync();
            }
        } finally {
            if (myRealm != null) {
                myRealm.close();
            }
        }
    }

#end
#end
#No. 188994
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * This api call fetches only the user walls give the userid
     *
     * @param userId user id of the user whos walls we want to fetch
     */

#Code:
    public void fetchMyWalls(String userId) {

        /*
        retroCallbackList keeps a record of the api calls made on this fragment, so that when the view
        is the not present the api calls doesn't give responses here and prevent fragment not attached
        exception. in OnPause we cancel all the requests to do so
        */

        RetroCallback retroCallback;
        retroCallback = new RetroCallback(this);
        //keeping the response code different so as to prevent code duplicacy
        retroCallback.setRequestId(HttpConstants.ApiResponseCodes.GET_USER_WALLS);
        retroCallbackList.add(retroCallback);
        mYeloApi.getUserWalls(userId, retroCallback);
        mSwipeRefreshLayout.setRefreshing(true);

    }

#end
#end
#No. 188995
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * This is added to track the scrolling down or up to show the tutorial screen overlay
     * accordingly. its a recycler view so we need some implementation in it.
     */

#Code:
    private void addScrollerListenerForTutorial(final ObservableRecyclerView cardListView) {


        Bundle args = getArguments();
        if (args != null && args.containsKey(ARG_INITIAL_POSITION)) {
            ViewTreeObserver vto = cardListView.getViewTreeObserver();
            vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
                @Override
                public void onGlobalLayout() {
                    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
                        cardListView.getViewTreeObserver().removeGlobalOnLayoutListener(this);
                    } else {
                        cardListView.getViewTreeObserver().removeOnGlobalLayoutListener(this);
                    }
                }
            });
        }
        mCardListView.setScrollViewCallbacks(this);


    }

#end
#end
#No. 188996
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * gets the instance for the fragment to call in a pager
     *
     * @return
     */

#Code:
    public static YeloBoardFragment newInstance() {
        YeloBoardFragment f = new YeloBoardFragment();
        return f;
    }

#end
#end
#No. 188997
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * Show fragment for tagging users
     */

#Code:
    private void showTagUserFragment(String wallId, String wallUserId, String tagCount) {


        if (isAttached()) {
            final Intent tagUserActivityIntent = new Intent(getActivity(),
                    TagUserActivity.class);
            tagUserActivityIntent.putExtra(AppConstants.Keys.WALL_ID, wallId);
            tagUserActivityIntent.putExtra(AppConstants.Keys.USER_ID, wallUserId);
            tagUserActivityIntent.putExtra(AppConstants.Keys.TAG_USER_COUNT, Integer.parseInt(tagCount));
            startActivity(tagUserActivityIntent);
        }

    }

#end
#end
#No. 188998
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * Api call for deleting the owner wall post
     *
     * @param wallId id of the wall which we want to delete
     */

#Code:
    private void callDeleteApi(String wallId) {
        RetroCallback retroCallback;
        retroCallback = new RetroCallback(this);
        retroCallback.setRequestId(HttpConstants.ApiResponseCodes.DELETE_WALL);
        retroCallbackList.add(retroCallback);

        mYeloApi.deleteWall(wallId, retroCallback);
        String selection = DatabaseColumns.ID + SQLConstants.EQUALS_ARG;

        //deleting from local cache
        DBInterface.deleteAsync(AppConstants.QueryTokens.DELETE_WALL_POST, getTaskTag(), null, TableWallPosts.NAME,
                selection, new String[]{wallId}, true, this);


    }

#end
#end
#No. 188999
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * Loads the actual chat screen. This is used in the case where the user taps on an item in the
     * list of chats
     */

#Code:
    private void loadChat(String wallId, String userId, String chatName, String image, String tagName) {

        final String chatId = Utils
                .generateChatId(userId, AppConstants.UserInfo.INSTANCE.getId());

        if (getActivity() != null) {

            final Intent chatScreenActivity = new Intent(getActivity(),
                    ChatScreenActivity.class);
            chatScreenActivity.putExtra(AppConstants.Keys.USER_ID, userId);
            chatScreenActivity.putExtra(AppConstants.Keys.CHAT_ID, chatId);
            chatScreenActivity.putExtra(AppConstants.Keys.CHAT_TITLE, chatName);
            chatScreenActivity.putExtra(AppConstants.Keys.PROFILE_IMAGE, image);
            chatScreenActivity.putExtra(AppConstants.Keys.WALL_ID, wallId);
            chatScreenActivity.putExtra(AppConstants.Keys.FROM_WALL, true);
            chatScreenActivity.putExtra(AppConstants.Keys.TAG_NAME, tagName);
            chatScreenActivity.putExtra(AppConstants.Keys.MY_ID, AppConstants.UserInfo.INSTANCE.getId());

            startActivity(chatScreenActivity);
        }
    }

#end
#end
#No. 189000
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * refreshes the current feed except the first int limit posts so as to show user refresh empty
     * effect and wait for the new posts to fetch again
     *
     * @param limit number of posts u want to retail while refreshing the feed
     */

#Code:
    private void refreshMyWalls(String limit) {
        mSwipeRefreshLayout.setEnabled(false);
        mDBNotifyCounter = 0;
        mFetchedOnOpen = false;

        String selection = DatabaseColumns.ID + " NOT IN ( SELECT " + DatabaseColumns.ID
                + " from " + TableWallPosts.NAME + " order by " + DatabaseColumns.TIMESTAMP_EPOCH_UPDATED_AT + " desc limit " + limit + ")"
                + SQLConstants.AND + DatabaseColumns.USER_ID + SQLConstants.EQUALS_ARG;

        DBInterface.deleteAsync(AppConstants.QueryTokens.DELETE_MY_WALL_POSTS_SEARCH_RESULTS, getTaskTag(),
                null, TableWallPosts.NAME, selection, new String[]{mUserId}, true, this);


    }

#end
#end
#No. 189001
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * refreshes the current feed except the first int limit posts so as to show user refresh empty
     * effect and wait for the new posts to fetch again
     *
     * @param limit number of posts u want to retail while refreshing the feed
     */

#Code:
    private void refresh(String limit) {
        mSwipeRefreshLayout.setEnabled(false);
        mDBNotifyCounter = 0;
        mFetchedOnOpen = false;

        if (mUserId.equals(AppConstants.UserInfo.INSTANCE.getId())) {
            String selection = DatabaseColumns.ID + " NOT IN ( SELECT " + DatabaseColumns.ID
                    + " from " + TableWallPosts.NAME + " order by " + DatabaseColumns.TIMESTAMP_EPOCH_UPDATED_AT + " desc limit " + limit + ")"
                    + SQLConstants.AND + DatabaseColumns.USER_ID + SQLConstants.EQUALS_ARG;

            DBInterface.deleteAsync(AppConstants.QueryTokens.DELETE_WALL_POSTS_SEARCH_RESULTS, getTaskTag(),
                    null, TableWallPosts.NAME, selection, new String[]{mUserId}, true, this);

        } else {
            String selection = DatabaseColumns.ID + " NOT IN ( SELECT " + DatabaseColumns.ID
                    + " from " + TableWallPosts.NAME + " order by " + DatabaseColumns.TIMESTAMP_EPOCH_UPDATED_AT + " desc limit " + limit + ")";

            DBInterface.deleteAsync(AppConstants.QueryTokens.DELETE_WALL_POSTS_SEARCH_RESULTS, getTaskTag(),
                    null, TableWallPosts.NAME, selection, null, true, this);

            DBInterface.deleteAsync(AppConstants.QueryTokens.DELETE_WALL_COMMENTS, getTaskTag(),
                    null, TableWallComments.NAME, null, null, true, this);
        }

    }

#end
#end
#No. 189002
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * Open a post for editing
     *
     * @param selectedWallId The id of the post to edit
     */

#Code:
    private void editPost(final String selectedWallId, final String selectedTagId) {

        final Intent editWallPostIntent = new Intent(getActivity(),
                EditWallPostActivity.class);
        editWallPostIntent.putExtra(AppConstants.Keys.EDIT_POST, true);
        editWallPostIntent.putExtra(AppConstants.Keys.WALL_ID, selectedWallId);
        editWallPostIntent.putExtra(AppConstants.Keys.TAG_ID, selectedTagId);


        startActivity(editWallPostIntent);
    }

#end
#end
#No. 189003
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * Delete a post, along with a confirmation
     *
     * @param selectedWallId The id of the post to delete
     */

#Code:
    private void deletePost(final String selectedWallId) {

        final AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(
                getActivity());

        // set title
        alertDialogBuilder.setTitle("Confirm");

        // set dialog message
        alertDialogBuilder
                .setMessage(getResources().getString(R.string.delete_wall_alert_message))
                .setCancelable(false)
                .setPositiveButton("Yes", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(
                            final DialogInterface dialog,
                            final int id) {

                        callDeleteApi(selectedWallId);
                        dialog.dismiss();
                    }
                })
                .setNegativeButton("No", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(
                            final DialogInterface dialog,
                            final int id) {
                        // if this button is clicked, just close
                        // the dialog box and do nothing
                        dialog.cancel();
                    }
                });

        // create alert dialog
        final AlertDialog alertDialog = alertDialogBuilder.create();

        // show it
        alertDialog.show();
    }

#end
#end
#No. 189004
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * Follow a post
     *
     * @param selectedWallId The id of the post to follow
     */

#Code:
    private void followPost(final String selectedWallId) {

        Toast.makeText(getActivity(), "Follow Post", Toast.LENGTH_SHORT).show();
    }

#end
#end
#No. 189005
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * Report abuse
     *
     * @param selectedWallId The id of the post to report
     */

#Code:
    private void reportAbuse(final String selectedWallId) {

        ReportAbuseRequestModel reportAbuseRequestModel = new ReportAbuseRequestModel();
        reportAbuseRequestModel.setType(AppConstants.TYPE);
        reportAbuseRequestModel.setId(selectedWallId);

        RetroCallback retroCallback;
        retroCallback = new RetroCallback(this);
        retroCallback.setRequestId(HttpConstants.ApiResponseCodes.REPORT_ABUSE);
        retroCallbackList.add(retroCallback);

        mYeloApi.reportAbuse(reportAbuseRequestModel, retroCallback);
    }


#end
#end
#No. 189007
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * api call for closing the wall
     *
     * @param wallId id of the wall u want to close
     */

#Code:
    private void closeWall(String wallId) {
        RetroCallback retroCallback;
        retroCallback = new RetroCallback(this);
        retroCallback.setRequestId(HttpConstants.ApiResponseCodes.CLOSE_WALL);
        Bundle args = new Bundle();
        args.putString(AppConstants.Keys.WALL_ID, wallId);
        retroCallback.setExtras(args);
        retroCallbackList.add(retroCallback);
        CloseWallRequestModel closeWallRequestModel = new CloseWallRequestModel();
        closeWallRequestModel.setIs_solved("1");

        mYeloApi.closeWall(wallId, closeWallRequestModel, retroCallback);


    }


#end
#end
#No. 189009
#File: E:\bishe\1\YeloBoardFragment.java
#Comment:
    /**
     * This loads the profile of the user
     *
     * @param userId user id of the user u want to open profile of
     * @param name   name of the user
     */

#Code:
    private void loadProfile(String userId, String name) {
        final Intent userProfileIntent = new Intent(getActivity(),
                UserProfileActivity.class);

        userProfileIntent.putExtra(AppConstants.Keys.USER_ID, userId);
        userProfileIntent.putExtra(AppConstants.Keys.USER_NAME, name);
        userProfileIntent.putExtra(AppConstants.Keys.SERVICE_SCREEN_TYPE, AppConstants.ServiceScreenType.PROFILE);
        startActivity(userProfileIntent);
    }

#end
#end
#No. 189012
#File: E:\bishe\1\YetiActionProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean hasSubMenu() {
        return true;
    }

#end
#end
#No. 189013
#File: E:\bishe\1\YetiActionProvider.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public void onPrepareSubMenu(SubMenu subMenu) {
        // Clear since the order of items may change.
        subMenu.clear();

        ActivityChooserModel dataModel = ActivityChooserModel.get(context, shareHistoryFileName);
        PackageManager packageManager = context.getPackageManager();

        final int expandedActivityCount = dataModel.getActivityCount();
        final int collapsedActivityCount = Math.min(expandedActivityCount, maxShownActivityCount);

        // Populate the sub-menu with a sub set of the activities.
        for (int i = 0; i < collapsedActivityCount; i++) {
            ResolveInfo activity = dataModel.getActivity(i);
            subMenu.add(0, i, i, activity.loadLabel(packageManager))
                    .setIcon(activity.loadIcon(packageManager))
                    .setOnMenuItemClickListener(shareMenuItemOnMenuItemClickListener);
        }

        if (collapsedActivityCount < expandedActivityCount) {
            // Add a sub-menu for showing all activities as a list item.
            SubMenu expandedSubMenu = subMenu.addSubMenu(Menu.NONE, collapsedActivityCount,
                    collapsedActivityCount,
                    context.getString(R.string.abc_activity_chooser_view_see_all));
            for (int i = 0; i < expandedActivityCount; i++) {
                ResolveInfo activity = dataModel.getActivity(i);
                expandedSubMenu.add(0, i, i, activity.loadLabel(packageManager))
                        .setIcon(activity.loadIcon(packageManager))
                        .setOnMenuItemClickListener(shareMenuItemOnMenuItemClickListener);
            }
        }
    }

#end
#end
#No. 189014
#File: E:\bishe\1\YetiActionProvider.java
#Comment:
    /**
     * Sets the file name of a file for persisting the share history which
     * history will be used for ordering share targets. This file will be used
     * for all view created by {@link #onCreateActionView()}. Defaults to
     * {@link #DEFAULT_SHARE_HISTORY_FILE_NAME}. Set to <code>null</code>
     * if share history should not be persisted between sessions.
     * <p/>
     * <strong>Note:</strong> The history file name can be set any time, however
     * only the action views created by {@link #onCreateActionView()} after setting
     * the file name will be backed by the provided file. Therefore, if you want to
     * use different history files for sharing specific types of content, every time
     * you change the history file {@link #setShareHistoryFileName(String)} you must
     * call {@link android.app.Activity#invalidateOptionsMenu()} to recreate the
     * action view. You should <strong>not</strong> call
     * {@link android.app.Activity#invalidateOptionsMenu()} from
     * {@link android.app.Activity#onCreateOptionsMenu(Menu)}."
     * <p/>
     * <code>
     * private void doShare(Intent intent) {
     * if (IMAGE.equals(intent.getMimeType())) {
     * mShareActionProvider.setHistoryFileName(SHARE_IMAGE_HISTORY_FILE_NAME);
     * } else if (TEXT.equals(intent.getMimeType())) {
     * mShareActionProvider.setHistoryFileName(SHARE_TEXT_HISTORY_FILE_NAME);
     * }
     * mShareActionProvider.setIntent(intent);
     * invalidateOptionsMenu();
     * }
     * <code>
     *
     * @param shareHistoryFile The share history file name.
     */

#Code:
    public void setShareHistoryFileName(String shareHistoryFile) {
        shareHistoryFileName = shareHistoryFile;
        setActivityChooserPolicyIfNeeded();
    }

#end
#end
#No. 189015
#File: E:\bishe\1\YetiActionProvider.java
#Comment:
    /**
     * Sets an intent with information about the share action. Here is a
     * sample for constructing a share intent:
     * <p>
     * <pre>
     * <code>
     *  Intent shareIntent = new Intent(Intent.ACTION_SEND);
     *  shareIntent.setType("image/*");
     *  Uri uri = Uri.fromFile(new File(getFilesDir(), "foo.jpg"));
     *  shareIntent.putExtra(Intent.EXTRA_STREAM, uri.toString());
     * </pre>
     * </code>
     * </p>
     *
     * @param shareIntent The share intent.
     * @see Intent#ACTION_SEND
     * @see Intent#ACTION_SEND_MULTIPLE
     */

#Code:
    public void setShareIntent(Intent shareIntent) {
        ActivityChooserModel dataModel = ActivityChooserModel.get(context,
                shareHistoryFileName);
        dataModel.setIntent(shareIntent);
    }

#end
#end
#No. 189016
#File: E:\bishe\1\YetiActionProvider.java
#Comment:
    /**
     * Set the activity chooser policy of the model backed by the current
     * share history file if needed which is if there is a registered callback.
     */

#Code:
    private void setActivityChooserPolicyIfNeeded() {
        if (onShareListener == null) {
            return;
        }
        if (onChooseActivityListener == null) {
            onChooseActivityListener = new ShareActivityChooserModelPolicy();
        }
        ActivityChooserModel dataModel = ActivityChooserModel.get(context, shareHistoryFileName);
        dataModel.setOnChooseActivityListener(onChooseActivityListener);
    }


#end
#end
#No. 189044
#File: E:\bishe\1\Yiqi_Ou.java
#Comment:
	/*
	 * I use dynamic programming to solve the problem. let f(x) represents whether the person can win or not
	 * if there are x stones. So the recursion function is like:
	 * 
	 * f(x) = false, if f(x-1) && f(x-2) && f(x-3) == true
	 * f(x) = true, if f(x-1) && f(x-2) && f(x-3) == false
	 
	 * f(x) is false if f(x-1), f(x-2), f(x-3) are all true, meaning that no mater you pick 1, 2
	 * or 3, your opponent will always get a true. 
	 * f(x) is true if one of f(x-1), f(x-2), f(x-3) is false,
	 * meaning that you can always pick stones and leave a false state to your opponent.
	 */

#Code:
	public boolean canWinNim(int n) {
		//the program can not pass the large test cases, so do some trick here.
		if(n >= 134882061) return n%4 != 0;
		boolean state1 = true, state2 = true, state3 = true, res = true;
		if(n <= 0)
			return false;
		if(n <= 3)
			return true;
		for(int i = 4; i <= n; i++) {
			res = (state1 && state2 && state3) ? false : true;
			state1 = state2;
			state2 = state3;
			state3 = res;
		}
		return state3;
	}

#end
#end
#No. 189049
#File: E:\bishe\1\YiUtils.java
#Comment:
	/**
	 * @return
	 */

#Code:
	public static String getTempPath()
	{
		String path = null;
		if(YiUtils.isSDCardAvailable())
		{
			path = Environment.getExternalStorageDirectory().getAbsolutePath()+ApplicationValues.Base.TEMP_PATH;
		}else
		{
			path = Environment.getDataDirectory().getAbsolutePath()+ApplicationValues.Base.TEMP_PATH;
		}
		File dir = new File(path);
		if(!dir.exists())
		{
			dir.mkdirs();
		}
		return path;
	}



#end
#end
#No. 189052
#File: E:\bishe\1\YListChart.java
#Comment:
   /**
    * Initializes a new `YListChart` instance with a set of points `data`.
    * `title` is a title, `XLabel` is a short description of the
    * @f$x@f$-axis, and `YLabel` a short description of the @f$y@f$-axis.
    * The input vector represents a set of plotting data. Position in the
    * vector gives the @f$x@f$-coordinates of the curve. The value
    * <tt>data</tt>@f$[j]@f$ corresponds to the point @f$(j+1@f$,
    * <tt>data</tt>@f$[j]@f$) (but rescaled on the chart) for the curve.
    * However, only *the first* `numPoints` of `data` will be considered
    * to plot the curve.
    *  @param title        chart title.
    *  @param XLabel       Label on @f$x@f$-axis.
    *  @param YLabel       Label on @f$y@f$-axis.
    *  @param data         point set.
    *  @param numPoints    number of points to plot
    */

#Code:
   public YListChart (String title, String XLabel, String YLabel,
                      double[] data, int numPoints) {
      super();
      dataset = new YListSeriesCollection(data, numPoints);
      init (title, XLabel, YLabel);
   }



#end
#end
#No. 189057
#File: E:\bishe\1\YListSeriesCollection.java
#Comment:
   /**
    * Creates a new `YListSeriesCollection` instance with default
    * parameters and given data series. The matrix `data` represents a set
    * of plotting data. More specifically, each row of `data` represents a
    * @f$y@f$-coordinates set. Position in the vector will form the
    * @f$x@f$-coordinates. Indeed, for each serie @f$i@f$, the value
    * <tt>data</tt>@f$[i][j]@f$ corresponds to the point @f$(j+1,
    * \mbox{\texttt{data}}[j])@f$ on the chart. However, only *the first*
    * `numPoints` of `data` will be considered for each series of points.
    *  @param data         series of point sets.
    *  @param numPoints    Number of points to plot
    */

#Code:
   public YListSeriesCollection (double[][] data, int numPoints) {
      renderer = new XYLineAndShapeRenderer(true, false);
      seriesCollection = new XYSeriesCollection();

      XYSeriesCollection tempSeriesCollection =
         (XYSeriesCollection)seriesCollection;
      for (int i = 0; i < data.length; i ++) {
         XYSeries serie = new XYSeries(" ");
         for (int j = 0; j < numPoints; j++)
            serie.add(j + 1, data[i][j]);
         tempSeriesCollection.addSeries(serie);
      }

      final int s = tempSeriesCollection.getSeriesCount();

      // set default colors
      for (int i = 0; i < s; i++) {
         renderer.setSeriesPaint(i, getDefaultColor(i));
      }

      // set default plot style
      plotStyle = new String[s];
      marksType = new String[s];
      dashPattern = new String[s];
      for (int i = 0; i < s; i++) {
         marksType[i] = " ";
         plotStyle[i] = "smooth";
         dashPattern[i] = "solid";
      }
   }


#end
#end
#No. 189059
#File: E:\bishe\1\YmlType.java
#Comment:
/**
 * Enum for Different YML Types.
 */

#Code:
public enum YmlType {
    /**
     * Censor YML
     */
    CENSOR_YML,
    /**
     * Config YML
     */
    CONFIG_YML,
    /**
     * Info YML
     */
    INFO_YML,
    /**
     * Locale YML
     */
    LOCALE_YML
}
#end
#end
#No. 189060
#File: E:\bishe\1\YoLemmaPostProcessor.java
#Comment:
    /**
     * {@inheritDoc}
     */

#Code:
    @Override
    public boolean process(MorphDictionary dict, Lemma.Builder lemmaBuilder,
                           Multimap<String, Wordform> wfMap) {
        Multimap<String, Wordform> additionalWfs = LinkedHashMultimap.create();
        for (String wfStr : wfMap.keySet()) {
            // alternative wordform string
            String altStr = StringUtils.replaceChars(wfStr, YO_CHARS, YO_REPLACEMENTS);
            if (Objects.equal(wfStr, altStr)) {
                continue;
            } // else wfStr contains 'yo'
            if (wfMap.containsKey(altStr)) {
                // the wordform multimap already contains string without 'yo'
                continue;
            }
            additionalWfs.putAll(altStr, wfMap.get(wfStr));
        }
        wfMap.putAll(additionalWfs);
        return true;
    }


#end
#end
#No. 189109
#File: E:\bishe\1\YoutubeActivityUtil.java
#Comment:
  /**
   * Given a {@link YouTube.Videos} object and an
   * {@link Activity} object, fill out the appropriate details
   *
   * @param video Video
   * @param activity Activity
   * @throws ActivitySerializerException ActivitySerializerException
   */

#Code:
  public static void updateActivity(Video video, Activity activity, String channelId) throws ActivitySerializerException {
    activity.setActor(buildActor(video, video.getSnippet().getChannelId()));
    activity.setVerb("post");

    activity.setId(formatId(activity.getVerb(), Optional.ofNullable(video.getId()).orElse(null)));

    activity.setPublished(new DateTime(video.getSnippet().getPublishedAt().getValue()));
    activity.setTitle(video.getSnippet().getTitle());
    activity.setContent(video.getSnippet().getDescription());
    activity.setUrl("https://www.youtube.com/watch?v=" + video.getId());

    activity.setProvider(getProvider());

    activity.setObject(buildActivityObject(video));

    addYoutubeExtensions(activity, video);
  }

#end
#end
#No. 189110
#File: E:\bishe\1\YoutubeActivityUtil.java
#Comment:
  /**
   * Given a {@link Channel} object and an
   * {@link Activity} object, fill out the appropriate details
   *
   * @param channel Channel
   * @param activity Activity
   * @throws ActivitySerializerException ActivitySerializerException
   */

#Code:
  public static void updateActivity(Channel channel, Activity activity, String channelId) throws ActivitySerializerException {
    try {
      activity.setProvider(getProvider());
      activity.setVerb("post");
      activity.setActor(createActorForChannel(channel));
      Map<String, Object> extensions = new HashMap<>();
      extensions.put("youtube", channel);
      activity.setAdditionalProperty("extensions", extensions);
    } catch (Throwable throwable) {
      throw new ActivitySerializerException(throwable);
    }
  }

#end
#end
#No. 189111
#File: E:\bishe\1\YoutubeActivityUtil.java
#Comment:
  /**
   * createActorForChannel.
   * @param channel Channel
   * @return $.actor
   */

#Code:
  public static ActivityObject createActorForChannel(Channel channel) {
    ActivityObject actor = new ActivityObject();
    // TODO: use generic provider id concatenator
    actor.setId("id:youtube:" + channel.getId());
    actor.setSummary(channel.getSnippet().getDescription());
    actor.setDisplayName(channel.getSnippet().getTitle());
    Image image = new Image();
    image.setUrl(channel.getSnippet().getThumbnails().getHigh().getUrl());
    actor.setImage(image);
    actor.setUrl("https://youtube.com/user/" + channel.getId());
    Map<String, Object> actorExtensions = new HashMap<>();
    actorExtensions.put("followers", channel.getStatistics().getSubscriberCount());
    actorExtensions.put("posts", channel.getStatistics().getVideoCount());
    actor.setAdditionalProperty("extensions", actorExtensions);
    return actor;
  }

#end
#end
#No. 189112
#File: E:\bishe\1\YoutubeActivityUtil.java
#Comment:
  /**
   * Given a video object, create the appropriate activity object with a valid image
   * (thumbnail) and video URL.
   * @param video Video
   * @return Activity Object with Video URL and a thumbnail image
   */

#Code:
  private static ActivityObject buildActivityObject(Video video) {
    ActivityObject activityObject = new ActivityObject();

    ThumbnailDetails thumbnailDetails = video.getSnippet().getThumbnails();
    Thumbnail thumbnail = thumbnailDetails.getDefault();

    if (thumbnail != null) {
      Image image = new Image();
      image.setUrl(thumbnail.getUrl());
      image.setHeight(thumbnail.getHeight());
      image.setWidth(thumbnail.getWidth());

      activityObject.setImage(image);
    }

    activityObject.setUrl("https://www.youtube.com/watch?v=" + video.getId());
    activityObject.setObjectType("video");

    return activityObject;
  }

#end
#end
#No. 189113
#File: E:\bishe\1\YoutubeActivityUtil.java
#Comment:
  /**
   * Add the Youtube extensions to the Activity object that we're building.
   * @param activity Activity
   * @param video Video
   */

#Code:
  private static void addYoutubeExtensions(Activity activity, Video video) {
    Map<String, Object> extensions = ExtensionUtil.getInstance().ensureExtensions(activity);

    extensions.put("youtube", video);

    if (video.getStatistics() != null) {
      Map<String, Object> likes = new HashMap<>();
      likes.put("count", video.getStatistics().getCommentCount());
      extensions.put("likes", likes);
    }
  }

#end
#end
#No. 189114
#File: E:\bishe\1\YoutubeActivityUtil.java
#Comment:
  /**
   * Build an {@link ActivityObject} actor given the video object
   * @param video Video
   * @param id id
   * @return Actor object
   */

#Code:
  private static ActivityObject buildActor(Video video, String id) {
    ActivityObject actor = new ActivityObject();

    actor.setId("id:youtube:" + id);
    actor.setDisplayName(video.getSnippet().getChannelTitle());
    actor.setSummary(video.getSnippet().getDescription());
    actor.setAdditionalProperty("handle", video.getSnippet().getChannelTitle());

    return actor;
  }

#end
#end
#No. 189115
#File: E:\bishe\1\YoutubeActivityUtil.java
#Comment:
  /**
   * Gets the common youtube {@link Provider} object
   * @return a provider object representing YouTube
   */

#Code:
  public static Provider getProvider() {
    Provider provider = new Provider();
    provider.setId("id:providers:youtube");
    provider.setDisplayName("YouTube");
    return provider;
  }

#end
#end
#No. 189116
#File: E:\bishe\1\YoutubeEventClassifier.java
#Comment:
  /**
   * detect probable Class of a json String from YouTube.
   * @param json json
   * @return Class
   */

#Code:
  public static Class detectClass(String json) {
    Objects.requireNonNull(json);
    Preconditions.checkArgument(StringUtils.isNotEmpty(json));

    ObjectNode objectNode;
    try {
      objectNode = (ObjectNode) mapper.readTree(json);
    } catch (IOException ex) {
      ex.printStackTrace();
      return null;
    }

    if (objectNode.findValue("kind") != null && objectNode.get("kind").toString().equals(VIDEO_IDENTIFIER)) {
      return Video.class;
    } else if (objectNode.findValue("kind") != null && objectNode.get("kind").toString().contains(CHANNEL_IDENTIFIER)) {
      return com.google.api.services.youtube.model.Channel.class;
    } else {
      return ObjectNode.class;
    }
  }

#end
#end
#No. 189117
#File: E:\bishe\1\YoutubeHooker.java
#Comment:
    /**
     * Find class call inflate() in constructor
     */

#Code:
    private static String findControlOverlayClassName(StackTraceElement[] traces) {
        String obfuscatedClsName = "";

        for (int k = 0; k < traces.length; k++) {
            StackTraceElement trace = traces[k];

            String s = trace.toString();
            if (!s.contains("blueberry") && !s.contains("de.robv")) {
                int i = s.indexOf(".<init>");
                if (i < 0) continue;
                if (k > 0 && traces[k - 1].toString().contains(".inflate")) {
                    obfuscatedClsName = s.substring(0, i);
                }

                // If we reach a constructor but it doesn't invoke inflate(), jump out
                break;
            }
        }
        if (DEBUG && !TextUtils.isEmpty(obfuscatedClsName)) log(TAG + ": found control overlay class name: " + obfuscatedClsName);
        return obfuscatedClsName;
    }


#end
#end
#No. 189119
#File: E:\bishe\1\YoutubeProvider.java
#Comment:
  /**
   * YoutubeProvider constructor - uses supplied YoutubeConfiguration.
   * @param config YoutubeConfiguration
   */

#Code:
  public YoutubeProvider(YoutubeConfiguration config) {
    this.config = config;

    Objects.requireNonNull(this.config.getApiKey());
  }

#end
#end
#No. 189120
#File: E:\bishe\1\YoutubeProvider.java
#Comment:
  /**
   * Set and overwrite the default before date that was read from the configuration file.
   * @param defaultBeforeDate defaultBeforeDate
   */

#Code:
  public void setDefaultBeforeDate(DateTime defaultBeforeDate) {
    this.config.setDefaultBeforeDate(defaultBeforeDate);
  }

#end
#end
#No. 189121
#File: E:\bishe\1\YoutubeProvider.java
#Comment:
  /**
   * Set and overwrite the default after date that was read from teh configuration file.
   * @param defaultAfterDate defaultAfterDate
   */

#Code:
  public void setDefaultAfterDate(DateTime defaultAfterDate) {
    this.config.setDefaultAfterDate(defaultAfterDate);
  }

#end
#end
#No. 189122
#File: E:\bishe\1\YoutubeProvider.java
#Comment:
  /**
   * Sets and overwrite the user info from the configuaration file.  Uses the defaults before and after dates.
   * @param userIds Set of String userIds
   */

#Code:
  public void setUserInfoWithDefaultDates(Set<String> userIds) {
    List<UserInfo> youtubeUsers = new LinkedList<>();

    for (String userId : userIds) {
      UserInfo user = new UserInfo();
      user.setUserId(userId);
      user.setAfterDate(this.config.getDefaultAfterDate());
      user.setBeforeDate(this.config.getDefaultBeforeDate());
      youtubeUsers.add(user);
    }

    this.config.setYoutubeUsers(youtubeUsers);
  }

#end
#end
#No. 189123
#File: E:\bishe\1\YoutubeProvider.java
#Comment:
  /**
   * Set and overwrite user into from teh configuration file. Only sets after dater.
   * @param usersAndAfterDates usersAndAfterDates
   */

#Code:
  public void setUserInfoWithAfterDate(Map<String, DateTime> usersAndAfterDates) {
    List<UserInfo> youtubeUsers = new LinkedList<>();

    for (String userId : usersAndAfterDates.keySet()) {
      UserInfo user = new UserInfo();
      user.setUserId(userId);
      user.setAfterDate(usersAndAfterDates.get(userId));
      youtubeUsers.add(user);
    }

    this.config.setYoutubeUsers(youtubeUsers);
  }

#end
#end
#No. 189124
#File: E:\bishe\1\YouTubeUtility.java
#Comment:
    /**
     * Get the string info for parse the video.
     */

#Code:
    public static String getInfoString(String id) throws IOException {
        HttpClient lClient = new DefaultHttpClient();

        HttpGet lGetMethod = new HttpGet(YoutubeUrlIDs.YOUTUBE_VIDEO_INFORMATION_URL + id + "&el=embedded&gl=US&hl=en&eurl=" + URLEncoder.encode("https://youtube.googleapis.com/v/" + id, "UTF-8") + "&asv=3&sts=1588");

        HttpResponse lResp = null;

        lResp = lClient.execute(lGetMethod);

        ByteArrayOutputStream lBOS = new ByteArrayOutputStream();
        String lInfoStr = null;

        lResp.getEntity().writeTo(lBOS);
        lInfoStr = new String(lBOS.toString("UTF-8"));

        return lInfoStr;
    }

#end
#end
#No. 189125
#File: E:\bishe\1\YouTubeUtility.java
#Comment:
    /**
     * Get the websource of a youtube video.
     */

#Code:
    public static String getUrlSource(String id) throws IOException {
        URL yahoo = new URL(YoutubeUrlIDs.YOUTUBE_VIDEO_INFORMATION_URL + id);
        URLConnection yc = yahoo.openConnection();
        BufferedReader in = new BufferedReader(new InputStreamReader(
                yc.getInputStream(), "UTF-8"));
        String inputLine;
        StringBuilder a = new StringBuilder();
        while ((inputLine = in.readLine()) != null)
            a.append(inputLine);

        in.close();
        return a.toString();
    }

#end
#end
#No. 189126
#File: E:\bishe\1\YoutubeVideoDeserializer.java
#Comment:
  /**
   * Because the Youtube Video object contains complex objects within its hierarchy, we have to use
   * a custom deserializer
   *
   * @param jsonParser jsonParser
   * @param deserializationContext deserializationContext
   * @return The deserialized {@link com.google.api.services.youtube.YouTube.Videos} object
   * @throws java.io.IOException IOException
   * @throws com.fasterxml.jackson.core.JsonProcessingException JsonProcessingException
   */

#Code:
  @Override
  public Video deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException {
    JsonNode node = jsonParser.getCodec().readTree(jsonParser);
    Video video = new Video();

    try {
      video.setId(node.get("id").asText());
      video.setEtag(node.get("etag").asText());
      video.setKind(node.get("kind").asText());

      video.setSnippet(buildSnippet(node));
      video.setStatistics(buildStatistics(node));
    } catch (Exception ex) {
      LOGGER.error("Exception while trying to deserialize a Video object: {}", ex);
    }

    return video;
  }

#end
#end
#No. 189127
#File: E:\bishe\1\YoutubeVideoDeserializer.java
#Comment:
  /**
   * Given the raw JsonNode, construct a video snippet object.
   * @param node JsonNode
   * @return VideoSnippet
   */

#Code:
  private VideoSnippet buildSnippet(JsonNode node) {
    VideoSnippet snippet = new VideoSnippet();
    JsonNode snippetNode = node.get("snippet");

    snippet.setChannelId(snippetNode.get("channelId").asText());
    snippet.setChannelTitle(snippetNode.get("channelTitle").asText());
    snippet.setDescription(snippetNode.get("description").asText());
    snippet.setTitle(snippetNode.get("title").asText());
    snippet.setPublishedAt(new DateTime(snippetNode.get("publishedAt").get("value").asLong()));

    ThumbnailDetails thumbnailDetails = new ThumbnailDetails();
    for (JsonNode t : snippetNode.get("thumbnails")) {
      Thumbnail thumbnail = new Thumbnail();

      thumbnail.setHeight(t.get("height").asLong());
      thumbnail.setUrl(t.get("url").asText());
      thumbnail.setWidth(t.get("width").asLong());

      thumbnailDetails.setDefault(thumbnail);
    }

    snippet.setThumbnails(thumbnailDetails);

    return snippet;
  }

#end
#end
#No. 189128
#File: E:\bishe\1\YoutubeVideoDeserializer.java
#Comment:
  /**
   * Given the raw JsonNode, construct a statistics object.
   * @param node JsonNode
   * @return VideoStatistics
   */

#Code:
  private VideoStatistics buildStatistics(JsonNode node) {
    VideoStatistics statistics = new VideoStatistics();
    JsonNode statisticsNode = node.get("statistics");

    statistics.setCommentCount(statisticsNode.get("commentCount").bigIntegerValue());
    statistics.setDislikeCount(statisticsNode.get("dislikeCount").bigIntegerValue());
    statistics.setFavoriteCount(statisticsNode.get("favoriteCount").bigIntegerValue());
    statistics.setLikeCount(statisticsNode.get("likeCount").bigIntegerValue());
    statistics.setViewCount(statisticsNode.get("viewCount").bigIntegerValue());

    return statistics;
  }

#end
#end
#No. 189154
#File: E:\bishe\1\YSLDFileHandlerTest.java
#Comment:
    /**
     * Is data source
     * Test method for {@link com.sldeditor.extension.filesystem.file.ysld.YSLDFileHandler#isDataSource()}.
     */

#Code:
    @Test
    public void testIsDataSource() {
        assertFalse(new YSLDFileHandler().isDataSource());
    }

#end
#end
#No. 189155
#File: E:\bishe\1\YSLDFileHandlerTest.java
#Comment:
    /**
     * Check SLD name
     * 
     * <p>Test method for {@link com.sldeditor.extension.filesystem.file.sld.SLDFileHandler#getSLDContents(com.sldeditor.common.NodeInterface)}.
     */

#Code:
    @Test
    public void testGetSLDName() {
        YSLDFileHandler handler = new YSLDFileHandler();

        assertTrue(handler.getSLDName(null).compareTo("") == 0);

        SLDData sldData = new SLDData(new StyleWrapper("workspace", "layer.ysld"), "sldContents");
        String sldName = handler.getSLDName(sldData);
        assertTrue(sldName.compareTo("layer.ysld") == 0);
    }

#end
#end
#No. 189156
#File: E:\bishe\1\YSLDFileHandlerTest.java
#Comment:
    /**
     * Supply a folder name and retrieve all the ysld files in it
     * 
     * <p>Test method for {@link com.sldeditor.extension.filesystem.file.ysld.YSLDFileHandler#getSLDContents(com.sldeditor.common.NodeInterface)}.
     */

#Code:
    @Test
    public void testGetSLDContentsFolder() {
        assertNull(new YSLDFileHandler().getSLDContents(null));

        URL url = SLDFileHandlerTest.class.getResource("/point/ysld");

        String folderName = "";
        File parent = null;
        try {
            parent = new File(url.toURI());
            folderName = parent.getName();
            parent = parent.getParentFile();
        } catch (URISyntaxException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }

        try {
            FileTreeNode fileTreeNode = new FileTreeNode(parent, folderName);

            YSLDFileHandler handler = new YSLDFileHandler();

            List<SLDDataInterface> sldDataList = handler.getSLDContents(fileTreeNode);

            List<String> expectedLayerNameList = Arrays.asList("point_simplepoint.ysld");
            assertEquals(expectedLayerNameList.size(), sldDataList.size());

            for (SLDDataInterface sldData : sldDataList) {
                assertTrue(expectedLayerNameList.contains(sldData.getLayerName()));
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            fail(e.getMessage());
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
    }

#end
#end
#No. 189157
#File: E:\bishe\1\ysoserialFrame.java
#Comment:
	/**
	 * Launch the application.
	 */

#Code:
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					ysoserialFrame frame = new ysoserialFrame();
					frame.setVisible(true);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}

#end
#end
#No. 189158
#File: E:\bishe\1\YTApiFacade.java
#Comment:
    /**
     *
     * @param ytvid youtube video id
     * @return null if youtube video id is invalid(unavailable) one.
     * @throws InterruptedException
     * @throws IOException (MalformedURLException...)
     */

#Code:
    @Nullable
    public static YTDataAdapter.Video
    requestVideoInfo(String ytvid)
            throws InterruptedException, IOException, BadResponseException {
        byte[] data;
        try {
            data = YTUtil.loadYtDataUrl(YTRespVideos.getRequestUrl(new String[]{ytvid}));
        } catch (MalformedURLException e) {
            // This is Unexpected!
            throw new AssertionError();
        }
        YTResp.VideoListResponse vlresp = YTRespVideos.parse(data);
        YTDataAdapter.VideoListResp resp = vlresp.makeAdapterData();
        if (null == resp.vids
            || 0 == resp.vids.length)
            // This is invalid video id
            return null;
        return resp.vids[0];
    }



#end
#end
#No. 189160
#File: E:\bishe\1\YTHackTask.java
#Comment:
    /**
     * NOTE
     * This is based on experimental result.
     * There is no official API regarding getting thumbnail via Youtube video id.
     * So, it is NOT 100% guaranteed that correct url is returned.
     * But, I'm strongly sure that return value is valid and correct based on my experience.
     * That's the reason why this function is member of 'YTHackTask'(Not YTDataAdapter).
     * @param ytvid Youtube video id
     */

#Code:
    public static String
    getYtVideoThumbnailUrl(String ytvid) {
        // These days, https is used by default
        return "https://i.ytimg.com/vi/" + ytvid + "/default.jpg";
    }

#end
#end
#No. 189161
#File: E:\bishe\1\YTHackTask.java
#Comment:
    /**
     *
     * @param quality Quality value. See YTQUALITY_SCORE_XXX
     * @param exact true : exact matching is required.
     *              false : best-fit is found.
     */

#Code:
    public YtVideo
    getVideo(int quality, boolean exact) {
        P.bug(0 <= quality && quality <= 100);
        if (null == mYtvpi
                || !mYtvpi.playable)
            return null;

        // Select video that has closest quality score
        YtVideoElem ve = null;
        int curgap = -1;
        for (YtVideoElem e : mYtvpi.vids) {
            if (YTQSCORE_INVALID != e.qscore
                    && isPlayableOnDevice(e)) {
                int qgap = quality - e.qscore;
                qgap = qgap < 0? -qgap: qgap;
                if (null == ve || qgap < curgap) {
                    ve = e;
                    curgap = qgap;
                }
            }
        }

        if (null == ve
                || (exact && 0 != curgap))
            return null;
        else
            return new YtVideo(ve.url,
                               ve.type.type == ElemType.StreamType.VIDEO);
    }



#end
#end
#No. 189163
#File: E:\bishe\1\YTHackTest.java
#Comment:
    /**
     *
     * @param quality Quality value. See YTQUALITY_SCORE_XXX
     * @param exact true : exact matching is required.
     *              false : best-fit is found.
     */

#Code:
    public YtVideo
    getVideo(int quality, boolean exact) {
        assert(0 <= quality && quality <= 100);
        if (null == mYtr)
            return null;

        // Select video that has closest quality score
        YtVideoElem ve = null;
        int curgap = -1;
        for (YtVideoElem e : mYtr.vids) {
            if (YTQSCORE_INVALID != e.qscore
                && isPlayableOnDevice(e)) {
                int qgap = quality - e.qscore;
                qgap = qgap < 0? -qgap: qgap;
                if (null == ve || qgap < curgap) {
                    ve = e;
                    curgap = qgap;
                }
            }
        }

        if (null == ve
            || (exact && 0 != curgap))
            return null;
        else
            return new YtVideo(ve.url,
                               ve.type.type == ElemType.StreamType.VIDEO);
    }

#end
#end
#No. 189164
#File: E:\bishe\1\YTPlayer.java
#Comment:
        /**
         * When DB is changed by YTPlayer.
         * So, other UI module may need to update look and feel accordingly.
         */

#Code:
        void onDbUpdated(DBUpdateType type);
    }

    // see "http://developer.android.com/reference/android/media/MediaPlayer.html"
    public enum MPState {
        INVALID,
        IDLE,
        INITIALIZED,
        PREPARING,
        PREPARED_AUDIO, // This is same with MediaPlayer's PREPARED state
        PREPARED,       // MediaPlayer is prepared + SurfaceHolder for video is prepared.
        STARTED,
        STOPPED,
        PAUSED,
        PLAYBACK_COMPLETED,
        END,
        ERROR
    }

#end
#end
#No. 189165
#File: E:\bishe\1\YTPlayer.java
#Comment:
        /**
         *
         * @param millis <= 0 for unset autostop.
         */

#Code:
        void
        set(long millis) {
            unset();
            if (mVlm.hasActiveVideo()
                && millis > 0) {
                _mTm = System.currentTimeMillis() + millis;
                mUi.updateStatusAutoStopSet(true, _mTm);
                AppEnv.getUiHandler().postDelayed(this, millis);
            }
        }




#end
#end
#No. 189168
#File: E:\bishe\1\YTPlayer.java
#Comment:
    /**
     * Get duration(milliseconds) of current active video
     */

#Code:
    int
    playerGetDuration() {
        return mpGetDuration();
    }

#end
#end
#No. 189169
#File: E:\bishe\1\YTPlayer.java
#Comment:
    /**
     * Get current position(milliseconds) from start
     */

#Code:
    int
    playerGetPosition() {
        return mpGetCurrentPosition();
    }

#end
#end
#No. 189170
#File: E:\bishe\1\YTPlayer.java
#Comment:
    /**
     * Set volume of video-on-play
     */

#Code:
    void
    playerSetVolume(int vol) {
        P.bug(0 <= vol && vol <= 100);
        mpSetVolume(vol);
    }

#end
#end
#No. 189171
#File: E:\bishe\1\YTPlayer.java
#Comment:
    /**
     *
     * @return
     *   absolute time (NOT time gap since now.)
     */

#Code:
    long
    getAutoStopTime() {
        return mAutoStop.getTime();
    }



#end
#end
#No. 189173
#File: E:\bishe\1\YTPlayer.java
#Comment:
    /**
     * Get volume of video-on-play
     * @return -1 : for error
     */

#Code:
    public int
    getVideoVolume() {
        if (isVideoPlaying())
            return mpGetVolume();
        return DB.INVALID_VOLUME;
    }

#end
#end
#No. 189174
#File: E:\bishe\1\YTPlayer.java
#Comment:
    /**
     *
     * @param pos milliseconds.
     */

#Code:
    public void
    playerSeekTo(int pos) {
        mpSeekTo(pos);
    }

#end
#end
#No. 189175
#File: E:\bishe\1\YTPlayer.java
#Comment:
    /**
     * @param c Cursor that is created by using "sVideoProjectionToPlay"
     *          Closing cursor is this function's responsibility.
     */

#Code:
    public void
    startVideos(final Cursor c, final boolean shuffle) {
        P.bug(AUtil.isUiThread());

        new Thread(new Runnable() {
            @Override
            public void
            run() {
                final Video[] vs = getVideos(c, shuffle);
                AppEnv.getUiHandler().post(new Runnable() {
                    @Override
                    public void
                    run() {
                        startVideos(vs);
                    }
                });
                c.close();
            }
        }).start();
    }

#end
#end
#No. 189176
#File: E:\bishe\1\YTPlayer.java
#Comment:
    /**
     * player will be stopped after 'millis'
     * @param millis 0 for unset autostop
     */

#Code:
    public void
    setAutoStop(long millis) {
        mAutoStop.set(millis);
    }

#end
#end
#No. 189177
#File: E:\bishe\1\YTPlayer.java
#Comment:
    /**
     * Player session id.
     * Even if same video is re-played, session id is different.
     */

#Code:
    public long
    getPlayerSessionId() {
        return mMpSessId;
    }

#end
#end
#No. 189178
#File: E:\bishe\1\YTPlayerUI.java
#Comment:
        /**
         * Update secondary progress
         */

#Code:
        void
        updateSecondary(int percent) {
            // Update secondary progress
            if (null != _mSeekbar) {
                int pv = percent * SEEKBAR_MAX / 100;
                _mSeekbar.setSecondaryProgress(pv);
                _mLastSecondaryProgress = pv;
            }
        }

#end
#end
#No. 189179
#File: E:\bishe\1\YTPlayerVideoListManager.java
#Comment:
    /**
     * find video index that is NOT 'ytvid'
     * @return -1 if fail to find.
     */

#Code:
    int
    findVideoExcept(int from, String ytvid) {
        P.bug(from >= 0 && from <= mVs.length);
        for (int i = from; i < mVs.length; i++) {
            if (!ytvid.equals(mVs[i].v.ytvid))
                return i;
        }
        return -1;
    }



#end
#end
#No. 189184
#File: E:\bishe\1\YTSearchAdapter.java
#Comment:
    /**
     * This should be called when adapter is no more used.
     * Adapter caching each music icons.
     * So, it occupies lots of memory.
     * To free those memories before GC, calling cleanup might be useful.
     */

#Code:
    public void
    cleanup() {
        P.bug(AUtil.isUiThread());
        for (int i = 0; i < mThumbnails.length; i++) {
            if (null != mThumbnails[i]) {
                mThumbnails[i].recycle();
                mThumbnails[i] = null;
            }
        }
        TaskManager tm = TaskManager.get();
        for (TmTask t : tm.getTasks(this))
            tm.cancelTask(t);
    }

#end
#end
#No. 189185
#File: E:\bishe\1\YTThumbnailTask.java
#Comment:
    /**
     * @throws InterruptedException
     * @throws IOException (ConnectException ...)
     * @throws BadResponseException
     */

#Code:
    @Override
    @NonNull
    protected Bitmap
    doAsync() throws InterruptedException, IOException, BadResponseException {
        if (!Util.isNetworkAvailable())
            throw new ConnectException();

        ByteArrayOutputStream baos = new ByteArrayOutputStream(4096);
        NetReadTask.Builder<NetReadTask.Builder> b
                = new NetReadTask.Builder<>(Util.createNetConn(mUrl), baos);
        try {
            b.create().startSync();
        } catch (IOException | InterruptedException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        Bitmap bm = ImgUtil.decodeBitmap(baos.toByteArray(), mW, mH);
        if (null == bm)
            throw new BadResponseException(); // data from network is NOT bitmap!
        mThumbnail = bm;
        return bm;
    }

#end
#end
#No. 189186
#File: E:\bishe\1\YTUtil.java
#Comment:
    /**
     * @throws InterruptedException
     * @throws IOException (MalformedURLException ...)
     */

#Code:
    @NonNull
    public static byte[]
    loadYtDataUrl(String urlstr)
            throws InterruptedException, IOException {
        URL url = new URL(urlstr);
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream(4096)){
            NetReadTask.Builder<NetReadTask.Builder> nrb
                    = new NetReadTask.Builder<>(Util.createNetConn(url), baos);
            try {
                nrb.create().startSync();
            } catch (IOException | InterruptedException e) {
                throw e;
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            return baos.toByteArray();
        }
    }


#end
#end
#No. 189188
#File: E:\bishe\1\YTVideoListTask.java
#Comment:
    /**
     * @throws InterruptedException
     * @throws IOException (ConnectException ...)
     * @throws BadResponseException
     */

#Code:
    @Override
    @NonNull
    protected YTDataAdapter.VideoListResp
    doAsync() throws InterruptedException, IOException, BadResponseException {
        if (!Util.isNetworkAvailable())
            throw new ConnectException();
        switch (mVLReq.type) {
        case VID_KEYWORD:
        case VID_CHANNEL:
            mVLResp = YTApiFacade.requestVideoList(mVLReq);
            break;
        default:
            P.bug(false);
        }
        return mVLResp;
    }

#end
#end
#No. 189189
#File: E:\bishe\1\YTVideoSearchActivity.java
#Comment:
    /**
     * Override it to enabel tool button for search.
     */

#Code:
    protected int
    getToolButtonSearchIcon() {
        return 0;
    }

#end
#end
#No. 189190
#File: E:\bishe\1\YTVideoSearchActivity.java
#Comment:
    /**
     * @return
     *   0 for success, otherwise error message id.
     */

#Code:
    public int
    addToPlaylist(final YTVideoSearchAdapter adapter,
                  final long plid, final int pos, final int volume) {
        // NOTE
        // This function is designed to be able to run in background.
        // But, getting volume is related with YTPlayer instance.
        // And lots of functions of YTPlayer instance, requires running on UI Context
        //   to avoid synchronization issue.
        // So, volume should be gotten out of this function.
        P.bug(plid >= 0);

        Bitmap bm = adapter.getItemThumbnail(pos);
        if (null == bm) {
            return R.string.msg_no_thumbnail;
        }

        final YTDataAdapter.Video ytv = (YTDataAdapter.Video)adapter.getItem(pos);
        DMVideo v = new DMVideo();
        v.setYtData(ytv);
        v.setThumbnail(ImgUtil.compressToJpeg(bm));
        v.setPreferenceData(volume, "");
        DB.Err err = mDb.insertVideoToPlaylist(plid, v);
        if (DB.Err.NO_ERR != err) {
            if (DB.Err.DUPLICATED == err)
                return R.string.msg_existing_muisc;
            else
                return Err.map(err).getMessage();
        }

        this.runOnUiThread(new Runnable() {
            @Override
            public void
            run() {
                adapter.setToDup(pos);
            }
        });

        return 0;
    }




#end
#end
#No. 189199
#File: E:\bishe\1\YuvToRgb.java
#Comment:
    /**
     * Converts a NV21 image to a Bitmap.
     * @param nv21ByteArray the original NV21 byte array.
     * @param width the original NV21 image width.
     * @param height the original NV21 image height.
     */

#Code:
    public static Bitmap yuvToRgb(RenderScript rs, byte[] nv21ByteArray, int width, int height) {
        return yuvToRgb(rs, new Nv21Image(nv21ByteArray, width, height));
    }

#end
#end
#No. 189200
#File: E:\bishe\1\YuvToRgb.java
#Comment:
    /**
     * Converts a NV21 image to a Bitmap.
     * @param nv21Image the NV21 image to convert.
     */

#Code:
    public static Bitmap yuvToRgb(RenderScript rs, Nv21Image nv21Image) {
        long startTime = System.currentTimeMillis();

        Type.Builder yuvTypeBuilder = new Type.Builder(rs, Element.U8(rs))
                .setX(nv21Image.nv21ByteArray.length);
        Type yuvType = yuvTypeBuilder.create();
        Allocation yuvAllocation = Allocation.createTyped(rs, yuvType, Allocation.USAGE_SCRIPT);
        yuvAllocation.copyFrom(nv21Image.nv21ByteArray);

        Type.Builder rgbTypeBuilder = new Type.Builder(rs, Element.RGBA_8888(rs));
        rgbTypeBuilder.setX(nv21Image.width);
        rgbTypeBuilder.setY(nv21Image.height);
        Allocation rgbAllocation = Allocation.createTyped(rs, rgbTypeBuilder.create());

        ScriptIntrinsicYuvToRGB yuvToRgbScript = ScriptIntrinsicYuvToRGB.create(rs, Element.RGBA_8888(rs));
        yuvToRgbScript.setInput(yuvAllocation);
        yuvToRgbScript.forEach(rgbAllocation);

        Bitmap bitmap = Bitmap.createBitmap(nv21Image.width, nv21Image.height, Bitmap.Config.ARGB_8888);
        rgbAllocation.copyTo(bitmap);

        Log.d("NV21", "Conversion to Bitmap: " + (System.currentTimeMillis() - startTime) + "ms");
        return bitmap;
    }

#end
#end
#No. 189201
#File: E:\bishe\1\Yytoken.java
#Comment:
/**
 * The tokens returned by the scanner.
 * 
 */

#Code:
class Yytoken {
  public int m_index;
  public String m_text;
  public int m_line;
  public int m_charBegin;
  public int m_charEnd;
  
  Yytoken (int index, String text, int line, int charBegin, int charEnd) {
     m_index = index;
    m_text = text;
    m_line = line;
    m_charBegin = charBegin;
    m_charEnd = charEnd;
  }

  public String toString() {
    return "Text   : "+m_text+
           "\nindex : "+m_index+
           "\nline  : "+m_line+
           "\ncBeg. : "+m_charBegin+
           "\ncEnd. : "+m_charEnd;
  }
}



#end
#end
#No. 189216
#File: E:\bishe\1\ZabbixReporter.java
#Comment:
		/**
		 * Convert rates to the given time unit.
		 *
		 * @param rateUnit
		 *            a unit of time
		 * @return {@code this}
		 */

#Code:
		public Builder convertRatesTo(TimeUnit rateUnit) {
			this.rateUnit = rateUnit;
			return this;
		}

#end
#end
#No. 189217
#File: E:\bishe\1\ZabbixReporter.java
#Comment:
		/**
		 * Convert durations to the given time unit.
		 *
		 * @param durationUnit
		 *            a unit of time
		 * @return {@code this}
		 */

#Code:
		public Builder convertDurationsTo(TimeUnit durationUnit) {
			this.durationUnit = durationUnit;
			return this;
		}

#end
#end
#No. 189218
#File: E:\bishe\1\ZabbixReporter.java
#Comment:
		/**
		 * Only report metrics which match the given filter.
		 *
		 * @param filter
		 *            a {@link MetricFilter}
		 * @return {@code this}
		 */

#Code:
		public Builder filter(MetricFilter filter) {
			this.filter = filter;
			return this;
		}

#end
#end
#No. 189219
#File: E:\bishe\1\ZabbixReporter.java
#Comment:
		/**
		 * default register name is "zabbix-reporter".
		 * 
		 * @param name
		 * @return
		 */

#Code:
		public Builder name(String name) {
			this.name = name;
			return this;
		}

#end
#end
#No. 189220
#File: E:\bishe\1\ZabbixReporter.java
#Comment:
		/**
		 * Builds a {@link ZabbixReporter} with the given properties.
		 *
		 * @return a {@link ZabbixReporter}
		 */

#Code:
		public ZabbixReporter build(ZabbixSender zabbixSender) {
			if (hostName == null) {
				hostName = HostUtil.getHostName();
				logger.info(name + " detect hostName: " + hostName);
			}
			return new ZabbixReporter(registry, name, rateUnit, durationUnit, filter, zabbixSender, hostName, prefix, suffix);
		}






#end
#end
#No. 189231
#File: E:\bishe\1\ZanExtract.java
#Comment:
	/**
	 * @param shuoshuo_id
	 * @return zan url
	 */

#Code:
	private static String getZanUrl(int index) {
		return zan_url.replace("zanurl", shuoshuoid_list.get(index));
	}

#end
#end
#No. 189232
#File: E:\bishe\1\ZanPipeline.java
#Comment:
	/**
	 * @param jsonArray
	 */

#Code:
	private void addZan(JSONArray jsonArray,String shuoshuo_id) {
		
		List<Zan> zan_list = new ArrayList<Zan>();
		
		for (int i = 0; i < jsonArray.size(); i++) {
			JSONObject jsonObject = jsonArray.getJSONObject(i);
			
			Zan zan = new Zan();
			zan.setFriend_id(jsonObject.getLongValue("fuin"));
			zan.setShuoshuo_id(shuoshuo_id);
			zan.setHost_id(Long.parseLong(HelpUtils.getHost_id()));
			
			zan_list.add(zan);
		}
		dao.addZan(zan_list);
	}


#end
#end
#No. 189234
#File: E:\bishe\1\ZAPDriver.java
#Comment:
    /**
     * Set up SCRIPT_BASED authentication method for the created context.
     * 
     * @param listener
     *            of type BuildListener: the display log listener during the Jenkins job execution.
     * @param clientApi
     *            of type ClientApi: the ZAP client API to call method.
     * @param authScriptParams
     *            of type ArrayList<ZAPAuthScriptParam>: the authentication script parameters options and their associated values.
     * @param contextId
     *            of type String: ID of the created context.
     * @param loginURL
     *            of type String: loging page URL.
     * @param loggedInIndicator
     *            of type String: indicator to signify that a user is logged in.
     * @param loggedOutIndicator
     *            of type String: indicator to signify that a user is logged out.
     * @param extraPostData
     *            of type String: other post data (other than credentials).
     * @param scriptName
     *            of type String: the name of the authentication script used to authenticate the user.
     * @throws UnsupportedEncodingException
     * @throws ClientApiException
     */

#Code:
    private void setUpScriptBasedAuth(BuildListener listener, ClientApi clientApi, ArrayList<ZAPAuthScriptParam> authScriptParams, String contextId, String loginURL, String loggedInIndicator, String loggedOutIndicator, String extraPostData, String scriptName) throws UnsupportedEncodingException, ClientApiException {

        /* Prepare the configuration in a format similar to how URL parameters are formed. This means that any value we add for the configuration values has to be URL encoded. */
        StringBuilder scriptBasedConfig = new StringBuilder();
        scriptBasedConfig.append("scriptName=").append(URLEncoder.encode(scriptName, "UTF-8"));
        if (!authScriptParams.isEmpty()) addZAPAuthScriptParam(authScriptParams, scriptBasedConfig);

        /*
         * @class org.zaproxy.clientapi.gen.Authentication
         *
         * @method setAuthenticationMethod
         *
         * @param String String apikey
         * @param String contextid
         * @param String authmethodname (formBasedAuthentication, scriptBasedAuthentication, httpAuthentication and manualAuthentication)
         * @param String authmethodconfigparams
         *
         * @throws ClientApiException
         *
         * @see https://github.com/zaproxy/zap-api-java/blob/master/subprojects/zap-clientapi/src/examples/java/org/zaproxy/clientapi/examples/authentication/FormBasedAuthentication.java
         * @see https://github.com/zaproxy/zaproxy/wiki/FAQformauth which mentions the ZAP API (but the above example is probably more useful)
         * @see It's possible to know more of authmethodconfigparams for each authentication method with {@link http://localhost:8080/JSON/authentication/view/getAuthenticationMethodConfigParams/?authMethodName=scriptBasedAuthentication}

#end
#end
#No. 189235
#File: E:\bishe\1\ZAPDriver.java
#Comment:
    /**
     * Set up forced user for the context and enable user, this allow for SPIDERING as an authenticated user.
     *
     * @param listener
     *            of type BuildListener: the display log listener during the Jenkins job execution.
     * @param clientApi
     *            of type ClientApi: the ZAP client API to call method.
     * @param contextId
     *            of type String: ID of the created context.
     * @param userid
     *            of type String: ID of the created user.
     * @throws ClientApiException
     * @throws UnsupportedEncodingException
     */

#Code:
    private void setUpForcedUser(BuildListener listener, ClientApi clientApi, String contextid, String userid) throws ClientApiException, UnsupportedEncodingException {
        /**
         * @class org.zaproxy.clientapi.gen.ForcedUser
         * 
         * @method setForcedUser
         * 
         * @param String apikey
         * @param String contextid
         * @param String userid
         * 
         * @throws ClientApiException
         */
        clientApi.forcedUser.setForcedUser(contextid, userid);

        /**
         * @class org.zaproxy.clientapi.gen.ForcedUser
         * 
         * @method setForcedUserModeEnabled
         * 
         * @param String apikey
         * @param boolean bool
         * 
         * @throws ClientApiException
         */
        clientApi.forcedUser.setForcedUserModeEnabled(true);
    }

#end
#end
#No. 189236
#File: E:\bishe\1\ZAPDriver.java
#Comment:
    /**
     * Method which will setup up authentication based on the specified method and return the ID of the authenticated user.
     * 
     * @param listener
     *            of type BuildListener: the display log listener during the Jenkins job execution.
     * @param clientApi
     *            of type ClientApi: the ZAP client API to call method.
     * @param contextId
     *            of type String: ID of the created context.
     * @param loginURL
     *            of type String: loging page URL.
     * @param username
     *            of type String: username to be used in authentication.
     * @param password
     *            of type String: password for the authentication user.
     * @param loggedInIndicator
     *            of type String: indicator to signify that a user is logged in.
     * @param loggedOutIndicator
     *            of type String: indicator to signify that a user is logged Out.
     * @param extraPostData
     *            of type String: other post data (other than credentials).
     * @param authMethod
     *            of type String: specifies the method of authentication to be used.
     * @param usernameParameter
     *            of type String: parameter defined in passing the username.
     * @param passwordParameter
     *            of type String: parameter defined in passing the password for the user.
     * @param scriptName
     *            of type String: the name of the authentication script used to authenticate the user.
     * @param authScriptParams
     *            of type ArrayList<ZAPAuthScriptParam>: the authentication script parameters options and their associated values.
     * @return userId id of the newly setup user.
     * @throws ClientApiException
     * @throws UnsupportedEncodingException
     */

#Code:
    private String setUpAuthentication(BuildListener listener, ClientApi clientApi, String contextId, String loginURL, String username, String password, String loggedInIndicator, String loggedOutIndicator, String extraPostData, String authMethod, String usernameParameter, String passwordParameter, String scriptName, ArrayList<ZAPAuthScriptParam> authScriptParams) throws ClientApiException, UnsupportedEncodingException {
        if (authMethod.equals(FORM_BASED)) setUpFormBasedAuth(listener, clientApi, contextId, loginURL, loggedInIndicator, loggedOutIndicator, extraPostData, usernameParameter, passwordParameter);
        else if (authMethod.equals(SCRIPT_BASED)) setUpScriptBasedAuth(listener, clientApi, authScriptParams, contextId, loginURL, loggedInIndicator, loggedOutIndicator, extraPostData, scriptName);

        return setUpUser(listener, clientApi, contextId, username, password);
    }

#end
#end
#No. 189237
#File: E:\bishe\1\ZAPDriver.java
#Comment:
    /**
     * Stop ZAP if it has been previously started.
     * 
     * @param listener
     *            of type BuildListener: the display log listener during the Jenkins job execution.
     * @param clientApi
     *            of type ClientApi: the ZAP client API to call method.
     * @throws ClientApiException
     */

#Code:
    private void stopZAP(BuildListener listener, ClientApi clientApi) throws ClientApiException {
        if (clientApi != null) {
            Utils.lineBreak(listener);
            Utils.loggerMessage(listener, 0, "[{0}] SHUTDOWN [ START ]", Utils.ZAP);
            Utils.lineBreak(listener);
            /**
             * @class ApiResponse org.zaproxy.clientapi.gen.Core
             *
             * @method shutdown
             *
             * @param String apikey
             *
             * @throws ClientApiException
             */
            clientApi.core.shutdown();
        }
        else Utils.loggerMessage(listener, 0, "[{0}] SHUTDOWN [ ERROR ]", Utils.ZAP);
    }

#end
#end
#No. 189238
#File: E:\bishe\1\ZAPDriver.java
#Comment:
        /**
         * List model to choose the export report format
         *
         * @return a {@link ListBoxModel}
         */

#Code:
        public ListBoxModel doFillSelectedExportFormatsItems() {
            ListBoxModel items = new ListBoxModel();
            for (String item : getAllExportFormats())
                items.add(item);
            return items;
        }

#end
#end
#No. 189239
#File: E:\bishe\1\ZAPDriver.java
#Comment:
        /**
         * List model to choose the tool used (normally, it should be the ZAP tool).
         *
         * @return a {@link ListBoxModel}
         */

#Code:
        public ListBoxModel doFillToolUsedItems() {
            ListBoxModel items = new ListBoxModel();
            for (ToolDescriptor<?> desc : ToolInstallation.all())
                for (ToolInstallation tool : desc.getInstallations())
                    items.add(tool.getName());
            return items;
        }

#end
#end
#No. 189240
#File: E:\bishe\1\ZAPDriver.java
#Comment:
        /**
         * List model to choose the alert filters file to use by ZAProxy scan. It's called on the remote machine (if present) to load all alert filters in the ZAP default dir of the build's machine.
         *
         * @param zapSettingsDir
         *            of type @QueryParameter String: A string that represents an absolute path to the directory that ZAP uses.
         * @return a {@link ListBoxModel}. It can be empty if zapSettingsDir doesn't contain any policy file.
         */

#Code:
        public ListBoxModel doFillAlertFiltersItems(@QueryParameter String zapSettingsDir) {
            ListBoxModel items = new ListBoxModel();

            /* No workspace before the first build, so workspace is null. */
            if (workspace != null) {
                File[] listFiles = {};
                try {
                    listFiles = workspace.act(new AlertFiltersCallable(zapSettingsDir));
                }
                catch (IOException e) {
                    e.printStackTrace(); /* No listener because it's not during a build but it's on the job config page. */
                }
                catch (InterruptedException e) {
                    e.printStackTrace(); /* No listener because it's not during a build but it's on the job config page. */
                }

                items.add(""); /* To not load a policy file, add a blank choice. */

                for (File listFile : listFiles)
                    items.add(FilenameUtils.getBaseName(listFile.getName())); /* Add alert filters files to the list, without their extension. */
            }

#end
#end
#No. 189241
#File: E:\bishe\1\ZAPDriver.java
#Comment:
        /**
         * List model to choose the policy file to use by ZAProxy scan. It's called on the remote machine (if present) to load all policy files in the ZAP default dir of the build's machine.
         *
         * @param zapSettingsDir
         *            of type @QueryParameter String: A string that represents an absolute path to the directory that ZAP uses.
         * @return a {@link ListBoxModel}. It can be empty if zapSettingsDir doesn't contain any policy file.
         */

#Code:
        public ListBoxModel doFillActiveScanPolicyItems(@QueryParameter String zapSettingsDir) {
            ListBoxModel items = new ListBoxModel();

            /* No workspace before the first build, so workspace is null. */
            if (workspace != null) {
                File[] listFiles = {};
                try {
                    listFiles = workspace.act(new PolicyFileCallable(zapSettingsDir));
                }
                catch (IOException e) {
                    e.printStackTrace(); /* No listener because it's not during a build but it's on the job config page. */
                }
                catch (InterruptedException e) {
                    e.printStackTrace(); /* No listener because it's not during a build but it's on the job config page. */
                }

                items.add(""); /* To not load a policy file, add a blank choice. */

                for (File listFile : listFiles)
                    items.add(FilenameUtils.getBaseName(listFile.getName())); /* Add policy files to the list, without their extension. */
            }

#end
#end
#No. 189242
#File: E:\bishe\1\ZAPDriver.java
#Comment:
        /**
         * List model to choose the authentication script file to use by ZAProxy scan. It's called on the remote machine (if present) to load all authentication script files in the ZAP default dir of the build's machine. The jenkins job must be started once in order to create the workspace, so this method can load the list of authentication scripts the authentication scripts must be stored in this directory : <zapSettingsDir>/scripts/scripts/authentication
         *
         * @param zapSettingsDir
         *            of type @QueryParameter String: A string that represents an absolute path to the directory that ZAP uses.
         * @return a {@link ListBoxModel}. It can be empty if zapSettingsDir doesn't contain any policy file.
         */

#Code:
        public ListBoxModel doFillAuthScriptItems(@QueryParameter String zapSettingsDir) {
            ListBoxModel items = new ListBoxModel();

            /* No workspace before the first build, so workspace is null. */
            if (workspace != null) {
                File[] listFiles = {};
                try {
                    listFiles = workspace.act(new AuthScriptCallable(zapSettingsDir));
                }
                catch (IOException e) {
                    e.printStackTrace(); /* No listener because it's not during a build but it's on the job config page. */
                }
                catch (InterruptedException e) {
                    e.printStackTrace(); /* No listener because it's not during a build but it's on the job config page. */
                }

                items.add(""); /* To not load a policy file, add a blank choice. */

                for (File listFile : listFiles)
                    items.add(listFile.getName()); /* Add script authentication files to the list, with their extension. */
            }

#end
#end
#No. 189243
#File: E:\bishe\1\ZAPDriver.java
#Comment:
        /**
         * List model to choose the ZAP session to use. It's called on the remote machine (if present) to load all session files in the build's workspace.
         *
         * @return a {@link ListBoxModel}. It can be empty if the workspace doesn't contain any ZAP sessions.
         * @throws InterruptedException
         * @throws IOException
         */

#Code:
        public ListBoxModel doFillLoadSessionItems() throws IOException, InterruptedException {
            ListBoxModel items = new ListBoxModel();

            /* No workspace before the first build, so workspace is null. */
            if (workspace != null) {
                Collection<String> sessionsInString = workspace.act(new FileCallable<Collection<String>>() {

                    private static final long serialVersionUID = 1L;

                    @Override
                    public Collection<String> invoke(File f, VirtualChannel channel) {

                        /* List all files with FILE_SESSION_EXTENSION on the machine where the workspace is located. */
                        Collection<File> colFiles = FileUtils.listFiles(f, FileFilterUtils.suffixFileFilter(FILE_SESSION_EXTENSION), TrueFileFilter.INSTANCE);

                        Collection<String> colString = new ArrayList<String>();

                        /* "Transform" File into String */
                        for (File file : colFiles)
                            colString.add(file.getAbsolutePath());
                        /* The following line is to remove the full path to the workspace, keep just the relative path to the session colString.add(file.getAbsolutePath().replace(workspace.getRemote() + File.separatorChar, "")); */
                        return colString;
                    }

                    @Override
                    public void checkRoles(RoleChecker checker) throws SecurityException { /* N/A */ }
                });

                items.add(""); /* To not load a session, add a blank choice. */

                for (String s : sessionsInString)
                    items.add(s);
            }

            return items;
        }

#end
#end
#No. 189245
#File: E:\bishe\1\ZapGaps.java
#Comment:
  	/** returns the version number at which this module was first released.  If 0, then no version number is claimed.  If a POSITIVE integer
  	 * then the number refers to the Mesquite version.  This should be used only by modules part of the core release of Mesquite.
  	 * If a NEGATIVE integer, then the number refers to the local version of the package, e.g. a third party package*/

#Code:
     	public int getVersionOfFirstRelease(){
     		return -100;  
     	}

#end
#end
#No. 189246
#File: E:\bishe\1\ZapGapsRight.java
#Comment:
     	/** returns the version number at which this module was first released.  If 0, then no version number is claimed.  If a POSITIVE integer
     	 * then the number refers to the Mesquite version.  This should be used only by modules part of the core release of Mesquite.
     	 * If a NEGATIVE integer, then the number refers to the local version of the package, e.g. a third party package*/

#Code:
     	public int getVersionOfFirstRelease(){
     		return 200;  
     	}



#end
#end
#No. 189249
#File: E:\bishe\1\ZAUtil.java
#Comment:
    /**
     * Gets sense within range provided sense is strong enough, has random chance and doesnt always return closest sense
     * 
     * @param entSource
     * @return
     */

#Code:
    public static EntityScent getSenseNearEntity(Entity entSource) {
        List<Entity> listEnts = entSource.worldObj.getEntitiesWithinAABBExcludingEntity(entSource, entSource.getEntityBoundingBox().expand((double)ZAConfig.maxPFRangeSense, (double)ZAConfig.maxPFRangeSense, (double)ZAConfig.maxPFRangeSense));
        
        EntityScent entBest = null;
        //double distBest = 999999;

        for(int i = 0; i < listEnts.size(); ++i) {
        	Entity entCheck = listEnts.get(i);

            if (entCheck instanceof EntityScent) {
            	
            	double dist = entSource.getDistanceToEntity(entCheck);
            	
            	//if (dist < distBest) {
		            if (dist < ((EntityScent)entCheck).getRange() && dist > 5.0F && entSource.worldObj.rand.nextInt(20) == 0) {
		                entBest = (EntityScent) entCheck;
		                return entBest;
		            }
            	//}
            }
        }

        return entBest;
    }


#end
#end
#No. 189255
#File: E:\bishe\1\ZAUtil.java
#Comment:
    /**
     * Method is far from perfect, but should work well enough without intensive processing to verify
     * coords fed in should be solid block with air above it (2 blocks of vertical space, 1 width of size)
     * 
     * @param x
     * @param y
     * @param z
     * @return
     */

#Code:
    public static boolean isInDarkCave(World world, int x, int y, int z, boolean checkSpaceToSpawn) {
    	IBlockState state = world.getBlockState(new BlockPos(x, y, z));
    	Block block = state.getBlock();
    	if (!world.canSeeSky(new BlockPos(x, y, z)) && world.getLightFromNeighbors(new BlockPos(x, y, z)) < 5) {
    		if (!CoroUtilBlock.isAir(block) && state.getMaterial() == Material.ROCK/*(block != Blocks.grass || block.getMaterial() != Material.grass)*/) {
    		
    			if (!checkSpaceToSpawn) {
    				return true;
    			} else {
    				Block blockAir1 = world.getBlockState(new BlockPos(x, y+1, z)).getBlock();
    				if (CoroUtilBlock.isAir(blockAir1)) {
    					Block blockAir2 = world.getBlockState(new BlockPos(x, y+2, z)).getBlock();
    					if (CoroUtilBlock.isAir(blockAir2)) {
    						return true;
    					}
    				}
    				
    			}
    		}
    	}
    	return false;
    }

#end
#end
#No. 189258
#File: E:\bishe\1\ZAUtil.java
#Comment:
    /**
     * Gets the closest player to the point within the specified distance (distance can be set to less than 0 to not
     * limit the distance). Args: x, y, z, dist
     */

#Code:
    public static EntityPlayer getClosestPlayer(World world, double par1, double par3, double par5, double par7)
    {
        double d4 = -1.0D;
        EntityPlayer entityplayer = null;

        for (int i = 0; i < world.playerEntities.size(); ++i)
        {
            EntityPlayer entityplayer1 = (EntityPlayer)world.playerEntities.get(i);
            if (!ZAConfigPlayerLists.whiteListUsedSenses || ZAConfigPlayerLists.whitelistSenses.contains(CoroUtilEntity.getName(entityplayer1))) {
            	double d5 = entityplayer1.getDistanceSq(par1, par3, par5);

                if ((par7 < 0.0D || d5 < par7 * par7) && (d4 == -1.0D || d5 < d4))
                {
                    d4 = d5;
                    entityplayer = entityplayer1;
                }
            }
        }

        return entityplayer;
    }

#end
#end
#No. 189259
#File: E:\bishe\1\ZAUtil.java
#Comment:
    /**
     * Checks if a scent of the same type is already at this location
     * 
     * @param parWorld
     * @param parPos
     * @param type
     * @return
     */

#Code:
    public static EntityScent getSenseNodeAtPos(World parWorld, Vec3d parPos, EnumSenseType type) {
    	
    	if (ZAConfig.extraScentCutoffRange == -1) return null;
    	
    	AxisAlignedBB aabb = new AxisAlignedBB(parPos.xCoord, parPos.yCoord, parPos.zCoord, parPos.xCoord + 1, parPos.yCoord + 1, parPos.zCoord + 1);
    	aabb = aabb.expand(ZAConfig.extraScentCutoffRange, ZAConfig.extraScentCutoffRange, ZAConfig.extraScentCutoffRange);
    	
    	List list = parWorld.getEntitiesWithinAABB(EntityScent.class, aabb);
    	
    	if (list.size() > 0) {
    		for(int j = 0; j < list.size(); j++)
            {
    			EntityScent node = (EntityScent)list.get(j);
    			if (node.type == type.ordinal()) {
    				return node;
    			}
            }
    	}
    	
    	return null;
    }

#end
#end
#No. 189260
#File: E:\bishe\1\ZAUtil.java
#Comment:
    /**
     * Tries to spawn a new sense, if one is close enough, it will multiply that senses current strength by lastMultiply
     * 
     * @param world
     * @param parPos
     * @param type
     * @param strength
     * @return
     */

#Code:
    public static EntityScent spawnOrBuffSenseAtPos(World world, Vec3d parPos, EnumSenseType type, int strength, boolean frequentSoundMultiply) {
		
    	EntityScent sense = getSenseNodeAtPos(world, parPos, type);
    	
    	if (sense == null) {
    		sense = new EntityScent(world);
    		sense.type = type.ordinal();
	        sense.setPosition(parPos.xCoord, parPos.yCoord, parPos.zCoord);
    		sense.setStrengthPeak(strength);
	        world.spawnEntityInWorld(sense);
    	} else if (frequentSoundMultiply) {
    		//instead of amplifying current strength, amp the base value, but only if current strength is weaker than param
    		float str = sense.getStrengthPeak();
    		if (str < strength) {
    			str = strength;
    		}
    		
	        if(sense.lastBuffTime + (long)ZAConfig.frequentSoundThreshold > System.currentTimeMillis()) {
	        	sense.lastMultiply += 0.1F;
	        	str *= sense.lastMultiply;
	        } else {
	        	sense.lastMultiply = 1.0F;
	        }
	        
	        sense.lastBuffTime = System.currentTimeMillis();
	        sense.setStrengthPeak((int)str);
    	}
    	
        return sense;
    }

#end
#end
#No. 189262
#File: E:\bishe\1\ZBeacon.java
#Comment:
    /**
     * All beacons with matching prefix are passed to a listener.
     */

#Code:
    public interface Listener
    {
        void onBeacon(InetAddress sender, byte[] beacon);
    }


#end
#end
#No. 189266
#File: E:\bishe\1\ZebraTable.java
#Comment:
	/**
	 * For list style table, header has bottom border, but some cell won't expect has this kind border. For example
	 * a blank header in checkbox on history list panel. This will mark this column header won't have such border. 
	 * @param col
	 */

#Code:
	public void removeHeaderBorder(int col) {
		noBorderHeaders.add(col);
	}

#end
#end
#No. 189267
#File: E:\bishe\1\ZebraTable.java
#Comment:
	/**
	 * @param startRow
	 */

#Code:
	private void updateHeaderStyle() {
    	int colSize = this.getCellCount(0);

    	for (int col=0;col < colSize; col++){
			if(style == STYLE_LIST && noBorderHeaders.contains(col)){
				//!!! can not use this.getCellFormatter().setStyleName() as it call prepareCell and cause recursive looping 
				UIObject.setStyleName(this.getCellFormatter().getElement(0, col), Css.NOBORDER_HEADER);
			}else{
				//!!! can not use this.getCellFormatter().setStyleName() as it call prepareCell and cause recursive looping 
				UIObject.setStyleName(this.getCellFormatter().getElement(0, col), Css.HEADER);
			}
		}
	}

#end
#end
#No. 189268
#File: E:\bishe\1\ZebraTable.java
#Comment:
	/**
	 * @param col
	 */

#Code:
	private void removeOldHeaderStyle() {
		//this is new header, then remove the old header
		int colSize = this.getCellCount(1);
		for (int idx=0;idx < colSize; idx++){
			this.getFlexCellFormatter().removeStyleName(1, idx, Css.NOBORDER_HEADER);     
			this.getFlexCellFormatter().removeStyleName(1, idx, Css.HEADER);     
		}
	}



#end
#end
#No. 189270
#File: E:\bishe\1\ZencoderClient.java
#Comment:
	/**
	 * Complete output IDs from response.
	 * 
	 * @param job
	 * @param response
	 */

#Code:
	private void completeJobInfo(ZencoderJob job, Document response) {
		try {
			NodeList outputs = (NodeList) xPath.evaluate(
					"/api-response/job/outputs", response,
					XPathConstants.NODESET);
			if (job.getOutputs().size() == 1) {
				Integer id = findIdFromOutputNode(outputs.item(0));
				if (id != null) {
					job.getOutputs().get(0).setId(id);
				}
			} else {
				// try via labels
				Map<String, Integer> ids = new HashMap<String, Integer>();
				int outputSize = outputs.getLength();
				for (int i = 0; i < outputSize; i++) {
					String label = (String) xPath.evaluate("output/label",
							outputs.item(i), XPathConstants.STRING);
					if (label != null && !label.isEmpty()) {
						int id = findIdFromOutputNode(outputs.item(i));
						ids.put(label, new Integer(id));
					}
				}
				for (ZencoderOutput zcOutput : job.getOutputs()) {
					Integer foundId = ids.get(zcOutput.getLabel());
					if (foundId != null) {
						zcOutput.setId(foundId);
					}
				}
			}

		} catch (XPathExpressionException e) {
			LOGGER.error("XPath threw Exception", e);
		}
	}

#end
#end
#No. 189272
#File: E:\bishe\1\ZencoderNotification.java
#Comment:
    /**
     * @param headers see https://app.zencoder.com/docs/api/encoding/notifications/notification-headers
     */

#Code:
    public void setHeaders(Map<String, String> headers) {
        this.headers = headers;
    }

#end
#end
#No. 189275
#File: E:\bishe\1\ZencoderOutput.java
#Comment:
	/**
	 * Add a header for S3 outputs.  See Amazon documentation for options: 
	 * http://docs.amazonwebservices.com/AmazonS3/latest/API/RESTObjectPUT.html?r=7050
	 * These values are ignored for non-S3 outputs.
	 * 
	 * @param name Header name
	 * @param value Header value
	 */

#Code:
	public void addHeader(String name, String value) {
		this.headers.put(name, value);
	}

#end
#end
#No. 189278
#File: E:\bishe\1\ZergBuildOrder.java
#Comment:
    /**
     * Produce zerg unit from free larva. Will do nothing if no free larva is available.
     */

#Code:
    public void produceZergUnit(AUnitType unitType) {
        for (AUnit base : Select.ourBases().listUnits()) {
            for (AUnit larva : base.getLarva()) {
                boolean result = base.train(unitType);
                return;
            }
        }
//        AUnit larva = Select.ourLarva().first();
//        System.out.println(larva);
//        if (larva != null) {
//            larva.train(unitType);
//        }
    }




#end
#end
#No. 189281
#File: E:\bishe\1\ZergPositionFinder.java
#Comment:
    /**
     * Returns true if given position (treated as building position for our <b>UnitType building</b>) has all
     * necessary requirements like: doesn't collide with another building, isn't too close to minerals etc.
     */

#Code:
    public static boolean doesPositionFulfillAllConditions(AUnit builder, AUnitType building, APosition position) {

        // Check for CREEP
        if (!isCreepConditionFulfilled(building, position)) {
            _CONDITION_THAT_FAILED = "CREEP";
            return false;
        }

        // =========================================================
        // If it's not physically possible to build here (e.g. rocks, other buildings etc)
        if (!canPhysicallyBuildHere(builder, building, position)) {
//            System.out.println(builder + " / " + ConstructionBuildPositionFinder.building + " / " + position);
            _CONDITION_THAT_FAILED = "CAN'T PHYSICALLY BUILD";
            return false;
        }

        // If other buildings too close
        if (isOtherConstructionTooClose(builder, building, position)) {
//            _CONDITION_THAT_FAILED = "BUILDINGS TOO CLOSE";
            return false;
        }

        // Can't be too close to minerals or to geyser, because would slow down production
        if (isTooCloseToMineralsOrGeyser(building, position)) {
            _CONDITION_THAT_FAILED = "TOO CLOSE TO MINERALS OR GEYSER";
            return false;
        }

        // All conditions are fullfilled, return this position
        _CONDITION_THAT_FAILED = null;
        return true;
    }

#end
#end
#No. 189282
#File: E:\bishe\1\ZeroCIceProvider.java
#Comment:
    /*
     * @param proxy: format like "M:default -h 127.0.0.1 -p 10000"
     */

#Code:
    @Override
    public void initialize(final Configuration props) {
        Ice.InitializationData initData = new Ice.InitializationData();
        initData.properties = Ice.Util.createProperties();
        initData.properties.setProperty("Ice.IPv6", "0");

        ic = Ice.Util.initialize(initData);
        adapter = ic.createObjectAdapterWithEndpoints("DBPoolClient", "default");
        clientPrx = DBPoolClientPrxHelper.uncheckedCast(adapter.add(new DBClient(), ic.stringToIdentity("C")));
        adapter.activate();

        String proxy = props.getString("dbpool.provider.zerocice.proxy", "M:default -h 127.0.0.1 -p 10000");
        logger.info("Connecting to " + proxy);

        // set timeout 1000, so if the trans data is big we can still get it
        serverPrx = DBPoolServerPrxHelper.uncheckedCast(ic.stringToProxy(proxy).ice_timeout(1000));
        dbconfig.reloadConfig(serverPrx.getDBInstanceDict());
        serverPrx.registerClient(clientPrx);

        keepAliveTimer.scheduleAtFixedRate(new TimerTask() {

            @Override
            public void run() {
                try {
                    // also get config after register to make sure client can
                    // get
                    // the change in the period of client lost connection with
                    // server
                    logger.debug("Run communicate with server start");
                    serverPrx.registerClient(clientPrx);
                    dbconfig.reloadConfig(serverPrx.getDBInstanceDict());
                    logger.debug("Run communicate with server finish");
                } catch (Throwable e) {
                    logger.warn("Run communicate with server get exception " + e);
                }
            }
        }, 15 * 1000L, 15 * 1000L);
    }

#end
#end
#No. 189283
#File: E:\bishe\1\ZeroConfClient.java
#Comment:
	/**
	 * Public constructor
	 * 
	 * Creates a zeroconf client to be used for
	 * access to the shared zeroconf service.
	 * 
	 * @param context must be provided
	 */

#Code:
	public ZeroConfClient(Context context) {
		this.clientContext = context;
	}


#end
#end
#No. 189286
#File: E:\bishe\1\ZeroConfClient.java
#Comment:
	/**
	 * Disconnect from the zeroconf service
	 */

#Code:
	public void disconnectFromService() {
		debugClient("Disconnecting from service");
		
		// unbind from service
		clientContext.unbindService(serviceConnection);
	}

#end
#end
#No. 189287
#File: E:\bishe\1\ZeroConfClient.java
#Comment:
	/**
	 * Register a client-level listener
	 * 
	 * @param listener
	 */

#Code:
	public void registerListener(Listener listener) {
		listeners.add(listener);
	}

#end
#end
#No. 189288
#File: E:\bishe\1\ZeroConfClient.java
#Comment:
	/**
	 * Unregister a client-level listener
	 * 
	 * @param listener
	 */

#Code:
	public void unregisterListener(Listener listener) {
		listeners.remove(listener);
	}

#end
#end
#No. 189289
#File: E:\bishe\1\ZeroConfClient.java
#Comment:
	/**
	 * Internal message handler
	 * 
	 * This is used to dispatch zeroconf events onto the UI thread.
	 * 
	 */

#Code:
	private final Handler updateNotify = new Handler() {
		@Override
		public void handleMessage(Message msg) {
			ZeroConfRecord r = (ZeroConfRecord)msg.obj;
			Enumeration<Listener> e = listeners.elements();
			switch(msg.what) {
			case NOTIFY_UPDATED:
				debugClient("Dispatching serviceUpdated(" + r.key + ")");
				while(e.hasMoreElements()) {
					Listener l = e.nextElement();
					l.serviceUpdated(r);
				}
				break;
			case NOTIFY_REMOVED:
				debugClient("Dispatching serviceRemoved(" + r.key + ")");
				while(e.hasMoreElements()) {
					Listener l = e.nextElement();
					l.serviceRemoved(r);
				}
				break;
			}
		}
	};

#end
#end
#No. 189290
#File: E:\bishe\1\ZeroConfClient.java
#Comment:
	/**
	 * Internal callback structure
	 * 
	 * This is given to the server as a callback structure.
	 * 
	 * Events from the shared service reach the client here and
	 * get dispatched to the above Handler, to be dispatched on
	 * the UI thread.
	 * 
	 */

#Code:
	private final IZeroConfClient.Stub callbacks = new IZeroConfClient.Stub() {
		@Override
		public void serviceUpdated(ZeroConfRecord r) throws RemoteException {
			Message msg = Message.obtain(updateNotify, NOTIFY_UPDATED, r);
			updateNotify.sendMessage(msg);
		}
		@Override
		public void serviceRemoved(ZeroConfRecord r) throws RemoteException {
			Message msg = Message.obtain(updateNotify, NOTIFY_REMOVED, r);
			updateNotify.sendMessage(msg);
		}
	};

#end
#end
#No. 189291
#File: E:\bishe\1\ZeroConfClient.java
#Comment:
	/**
	 * Internal service connection
	 * 
	 * Used to track service connection state.
	 * 
	 */

#Code:
	private final ServiceConnection serviceConnection = new ServiceConnection() {
		@Override
		public void onServiceConnected(ComponentName name, IBinder binder) {
			debugClient("Connected to service");
			service = IZeroConfService.Stub.asInterface(binder);
			try {
				debugClient("Registering callbacks");
				service.registerCallbacks(callbacks);
				service.subscribeAll();
			} catch (RemoteException e) {
				Log.d(TAG, "Exception while subscribing: " + e.toString());
			}
		}
		@Override
		public void onServiceDisconnected(ComponentName name) {
			debugClient("Disconnected from service");
			service = null;
		}
	};

#end
#end
#No. 189292
#File: E:\bishe\1\ZeroConfService.java
#Comment:
	/**
	 * Message handler for updates from JmDNS
	 * 
	 * This gets fed from the listeners we install
	 * in JmDNS, collecting discovered things into
	 * our service-global database.
	 * 
	 */

#Code:
	private Handler updateNotify = new Handler() {
		@Override
		public void handleMessage(Message msg) {
			SrvType t;
			if(msg.what == NOTIFY_TYPE_ADDED) {
				String name = (String)msg.obj;
				t = ensureType(name);
				allTypesByName.put(t.typeName, t);
			} else {
				ServiceEvent e = (ServiceEvent)msg.obj;
				Srv s;
				switch(msg.what) {
				case NOTIFY_SERVICE_ADDED:
					t = ensureType(e.getType());
					s = new Srv(e);
					Log.d(TAG, "Adding svc " + e.getName());
					t.addSrv(s);
					allServices.insertElementAt(s, 0);
					break;
				case NOTIFY_SERVICE_REMOVED:
					t = ensureType(e.getType());
					s = t.getSrvByKey(e.getInfo().getKey());
					Log.d(TAG, "Removing svc " + e.getName());
					t.removeSrv(s);
					allServices.remove(s);
					break;
				case NOTIFY_SERVICE_RESOLVED:
					break;
				}
			}
		}
	};

#end
#end
#No. 189293
#File: E:\bishe\1\ZeroConfService.java
#Comment:
	/**
	 * Broadcast receiver watching connection state
	 */

#Code:
	class ConnectionStateListener extends BroadcastReceiver {
		@Override
		public void onReceive(Context context, Intent intent) {
			boolean status = (wifiManager.getWifiState() == WifiManager.WIFI_STATE_ENABLED);
			Log.d(TAG, "Connection state is now " + (status ? "enabled" : "disabled"));
			onWifiChange();
		}
	}




#end
#end
#No. 189296
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Constructs a new Zerokit instance with a Context object.
     *
     * @param context a Context object used to pass it to the WebView
     * @param url     the url of the provided api root
     */

#Code:
    @SuppressLint({"SetJavaScriptEnabled", "AddJavascriptInterface"})
    private Zerokit(@NonNull final Context context, @NonNull String url) {
        Uri uri = Uri.parse(url);

        executorWebView = new WebViewThreadExecutor();
        secureRandom = new SecureRandom();

        apiRoot = uri.getAuthority();
        tenantId = apiRoot.split("\\.")[0];
        apiRootUrl = uri.buildUpon().appendPath("static").appendPath("v4").appendPath("api.html").build().toString();

        observers = new HashMap<>();

        clientWebView = new ZerokitWebViewClientBase();
        clientIdpWebView = new ZerokitWebViewClientBase();

        idpStateHandler = new StateHandler();
        initStateHandler = new StateHandler();

        idpStateHandler.addListener(new StateChangeListener() {
            @Override
            public void onStateChanged(@State int state) {
                switch (state) {
                    case State.FINISHED:
                        decrementIdlingResource();
                        jsInterfaceHtmlExporter.removeAllListeners();
                        break;
                    case State.RUNNING:
                        incrementIdlingResoure();
                        break;
                }
            }

#end
#end
#No. 189297
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Loads an url in the WebView instance (on the Handler thread)
     *
     * @param url The url which will be loaded in the webview
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    void loadUrl(@NonNull final WebView webView, @NonNull final String url) {
        executorWebView.execute(new Runnable() {
            @Override
            public void run() {
                webView.loadUrl(url);
            }
        });

#end
#end
#No. 189298
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Converts char array to byte array securely
     *
     * @param chars the char array which will be converted to byte array
     * @return the byte array
     */

#Code:
    @NonNull
    private byte[] toBytes(@NonNull char[] chars) {
        CharBuffer charBuffer = CharBuffer.wrap(chars);
        ByteBuffer byteBuffer = Charset.forName("UTF-8").encode(charBuffer);
        byte[] bytes = Arrays.copyOfRange(byteBuffer.array(), byteBuffer.position(), byteBuffer.limit());
        Arrays.fill(charBuffer.array(), '\u0000'); // clear sensitive data
        Arrays.fill(byteBuffer.array(), (byte) 0); // clear sensitive data
        return bytes;
    }

    @SuppressWarnings("WeakerAccess")
    boolean isNetworkAvailable() {
        NetworkInfo activeNetworkInfo = ((ConnectivityManager) webView.getContext().getSystemService(Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo();
        return activeNetworkInfo != null && activeNetworkInfo.isConnected();
    }

#end
#end
#No. 189299
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Send a log message if app is in debug mode
     *
     * @param msg The message you would like logged.
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    void log(@NonNull String msg) {
        if (BuildConfig.DEBUG)
            Log.d("Zerokit", msg);
    }

    @SuppressWarnings("WeakerAccess")
    void incrementIdlingResoure() {
        if (idlingResource != null) idlingResource.increment();
    }

#end
#end
#No. 189300
#File: E:\bishe\1\Zerokit.java
#Comment:
        /**
         * Package private constructor to avoid method generation to access private constructor of inner class
         */

#Code:
        JSInterfaceByteArrayProvider() {
            byteArrays = new HashMap<>();
        }

#end
#end
#No. 189301
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * An enum which represents a javascript function with parameters
     * From this will be generated the concrete javascript function
     */

#Code:
    enum Function {
        zxcvbn(Default, null, new ExtraArg(ArgType.ByteArray, 0)),

        login(MobileCmd, null, new ExtraArg(ArgType.ByteArray)),
        loginByRememberMeKey(MobileCmd, null),
        getRememberMeKey(MobileCmd, null, new ExtraArg(ArgType.ByteArray)),
        register(MobileCmd, null, new ExtraArg(ArgType.ByteArray)),
        createInvitationLink(MobileCmd, null, new ExtraArg(ArgType.ByteArray)),
        acceptInvitationLink(MobileCmd, null, new ExtraArg(ArgType.JSONToken, 0), new ExtraArg(ArgType.ByteArray)),
        changePassword(MobileCmd, null, new ExtraArg(ArgType.ByteArray), new ExtraArg(ArgType.ByteArray)),

        acceptInvitationLinkNoPassword(new ExtraArg(ArgType.JSONToken, 0)),
        createInvitationLinkNoPassword,
        createTresor,
        decrypt,
        encrypt,
        getInvitationLinkInfo(Cmd, ArgType.JSONToken),
        kickFromTresor,
        logout,
        shareTresor,
        whoAmI;


        @IntDef({Default, Cmd, MobileCmd})
        @interface Type {
            int Default = 0;
            int Cmd = 1;
            int MobileCmd = 2;
        }



#end
#end
#No. 189304
#File: E:\bishe\1\Zerokit.java
#Comment:
        /**
         * Report an error to the host application. These errors are unrecoverable
         * (i.e. the main resource is unavailable). The errorCode parameter
         * corresponds to one of the ERROR_* constants.
         * @param view The WebView that is initiating the callback.
         * @param errorCode The error code corresponding to an ERROR_* value.
         * @param description A String describing the error.
         * @param failingUrl The url that failed to load.
         */

#Code:
        @Override
        public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
            super.onReceivedError(view, errorCode, description, failingUrl);
            for (PageFinishListener pageFinishListener : new LinkedList<>(pageFinishListeners)) {
                pageFinishListener.onReceivedError(errorCode);
            }
        }

#end
#end
#No. 189305
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * This method tries to log in the given user with the given password entered by the user
     *
     * @param userId   The userId of the user to log in.
     * @param password The password of the user to log in.
     * @return Resolved userId of the logged in user.
     */

#Code:
    @NonNull
    @SuppressWarnings("WeakerAccess")
    CallAsync<ResponseZerokitLogin, ResponseZerokitError> _login(@NonNull final String userId, @NonNull final byte[] password) {
        return new CallAsyncAction<>(new ActionCallback<ResponseZerokitLogin, ResponseZerokitError>() {

            @Override
            public void call(final Callback<? super ResponseZerokitLogin, ? super ResponseZerokitError> subscriber) {
                callFunction(Function.login, new CallbackJsonResult<>(subscriber, new ResponseZerokitLogin(), jsInterfaceByteArrayProvider.add(password)), userId);
            }
        });

#end
#end
#No. 189306
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Use this method for login if 'remember me' was set to yes for a previous login with password.
     *
     * @param userId The user ID to log in with
     * @param key    The remember key
     * @return Resolved userId of the logged in user.
     */

#Code:
    @NonNull
    @SuppressWarnings("WeakerAccess")
    CallAsync<String, ResponseZerokitError> _loginByRememberMeKey(@NonNull final String userId, @NonNull final String key) {
        return new CallAsyncAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super String, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.loginByRememberMeKey, new CallbackStringResult(subscriber), userId, key);
            }
        });

#end
#end
#No. 189307
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Returns the "remember key" for the given user
     *
     * @param userId   The user ID for the key
     * @param password The password for the given user id
     * @return the key
     */

#Code:
    @NonNull
    @SuppressWarnings("WeakerAccess")
    CallAsync<String, ResponseZerokitError> _getRememberMeKey(@NonNull final String userId, @NonNull final byte[] password) {
        return new CallAsyncAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super String, ? super ResponseZerokitError> subscriber) {
                callFunction(Function.getRememberMeKey, new CallbackStringResult(subscriber, jsInterfaceByteArrayProvider.add(password)), userId);
            }
        });

#end
#end
#No. 189308
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Log out the current user
     *
     * @return Observable about the results
     */

#Code:
    @NonNull
    @SuppressWarnings("WeakerAccess")
    CallAsync<String, ResponseZerokitError> _logout() {
        return new CallAsyncAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super String, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.logout, new CallbackStringResult(subscriber));
            }
        });
    }

#end
#end
#No. 189309
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Use this methods to get the logged in user's identity.
     *
     * @return the user ID if logged in or `null` if not.
     */

#Code:
    @NonNull
    CallAsync<String, ResponseZerokitError> _whoAmI() {
        return new CallAsyncAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super String, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.whoAmI, new CallbackStringResult(subscriber));
            }
        });
    }

#end
#end
#No. 189310
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * This method logs into a security session and changes the password of the user.
     *
     * @param userId      Parameter to specify the id of the user changing password. This is only required if the user is not logged in.
     * @param oldPassword The currently used password
     * @param newPassword The new password
     * @return Resolves to the userId of the logged in user
     */

#Code:
    @NonNull
    @SuppressWarnings("WeakerAccess")
    CallAsync<ResponseZerokitChangePassword, ResponseZerokitError> _changePassword(@NonNull final String userId, @NonNull final byte[] oldPassword, @NonNull final byte[] newPassword) {
        return new CallAsyncAction<>(new ActionCallback<ResponseZerokitChangePassword, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super ResponseZerokitChangePassword, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.changePassword, new CallbackJsonResult<>(subscriber, new ResponseZerokitChangePassword(), jsInterfaceByteArrayProvider.add(oldPassword), jsInterfaceByteArrayProvider.add(newPassword)), userId);
            }
        });

#end
#end
#No. 189311
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Get authorization code and identity tokens for the currenty logged in user.
     *
     * @param clientId The cliend ID for the current ZeroKit OpenID Connect client set up in the management portal.
     * @return IdentityTokens which contains: Authorization code, Identity token, Code Verifier (Contains the code verifier if you have 'Requires proof key' enabled for your client)
     */

#Code:
    @NonNull
    @SuppressWarnings("WeakerAccess")
    public Call<IdentityTokens, ResponseZerokitError> getIdentityTokens(final String clientId) {
        return getIdentityTokens(clientId, false);
    }

#end
#end
#No. 189312
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Get authorization code and identity tokens for the currenty logged in user.
     *
     * @param clientId The cliend ID for the current ZeroKit OpenID Connect client set up in the management portal.
     * @param useProofKey Option to use proof key
     * @return IdentityTokens which contains: Authorization code, Identity token, Code Verifier (Contains the code verifier if you have 'Requires proof key' enabled for your client)
     */

#Code:
    @NonNull
    private Call<IdentityTokens, ResponseZerokitError> getIdentityTokens(final String clientId, final boolean useProofKey) {
        return new CallAction<>(new ActionCallback<IdentityTokens, ResponseZerokitError>() {

            @Override
            public void call(final Callback<? super IdentityTokens, ? super ResponseZerokitError> subscriberInner) {
                idpCheck().enqueue(new Action<Void>() {
                    @Override
                    public void call(Void aVoid) {
                        idpStateHandler.setState(State.RUNNING);

                        requireIdp(clientId, useProofKey, new CallbackExecutor<>(new Callback<IdentityTokens, ResponseZerokitError>() {
                            @Override
                            public void onSuccess(IdentityTokens result) {
                                subscriberInner.onSuccess(result);
                                idpStateHandler.setState(State.FINISHED);
                            }

                            @Override
                            public void onError(ResponseZerokitError e) {
                                subscriberInner.onError(e);
                                idpStateHandler.setState(State.FINISHED);
                            }
                        }));
                    }
                });
            }
        });
    }

#end
#end
#No. 189313
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * This methods gives meta-information about the password the user entered
     *
     * @param password The password to get the strength of it
     * @return Part of the result of running zxcvbn on the password
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<ResponseZerokitPasswordStrength, ResponseZerokitError> getPasswordStrength(@NonNull final byte[] password) {
        return new CallAction<>(new ActionCallback<ResponseZerokitPasswordStrength, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super ResponseZerokitPasswordStrength, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.zxcvbn, new CallbackJsonResult<>(subscriber, new ResponseZerokitPasswordStrength(), jsInterfaceByteArrayProvider.add(password)));
            }
        });


#end
#end
#No. 189315
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * You can get some information about the link by calling getInvitationLinkInfo with the link secret.
     * The returned object contains a token necessary to accept the invitation.
     * This also is a client side secret, that should never be uploaded to your site as that would compromise the zero knowledge nature of the system by providing ways to open the tresor.
     *
     * @param secret The secret is the one that was concatenated to the end of the url in createInvitationLink.
     * @return Resolves to all the information available.
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<ResponseZerokitInvitationLinkInfo, ResponseZerokitError> getInvitationLinkInfo(@NonNull final String secret) {
        return new CallAction<>(new ActionCallback<ResponseZerokitInvitationLinkInfo, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super ResponseZerokitInvitationLinkInfo, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.getInvitationLinkInfo, new CallbackJsonResult<>(subscriber, new ResponseZerokitInvitationLinkInfo()), secret);
            }
        });

#end
#end
#No. 189316
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * You can create an invitation link with no password.
     *
     * @param linkBase the base of the link. The link secret is concatenated after this after a '#'
     * @param tresorId the id of the tresor
     * @param message  optional arbitrary string data that can be retrieved without a password or any other information
     * @return Resolves to the operation id and the url of the created link. The operation must be approved before the link is enabled.
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<ResponseZerokitCreateInvitationLink, ResponseZerokitError> createInvitationLinkNoPassword(@NonNull final String linkBase, @NonNull final String tresorId, @Nullable final String message) {
        return new CallAction<>(new ActionCallback<ResponseZerokitCreateInvitationLink, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super ResponseZerokitCreateInvitationLink, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.createInvitationLinkNoPassword, new CallbackJsonResult<>(subscriber, new ResponseZerokitCreateInvitationLink()), linkBase, tresorId, TextUtils.isEmpty(message) ? "" : message);
            }
        });
    }

#end
#end
#No. 189317
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * This method creates an invitation link with the password entered
     *
     * @param linkBase the base of the link. The link secret is concatenated after this after a '#'
     * @param tresorId the id of the tresor
     * @param message  optional arbitrary string data that can be retrieved without a password or any other information
     * @param password the password to accept the link
     * @return Resolves to the operation id and the url of the created link. The operation must be approved before the link is enabled.
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<ResponseZerokitCreateInvitationLink, ResponseZerokitError> createInvitationLink(@NonNull final String linkBase, @NonNull final String tresorId, @Nullable final String message, @NonNull final byte[] password) {
        return new CallAction<>(new ActionCallback<ResponseZerokitCreateInvitationLink, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super ResponseZerokitCreateInvitationLink, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.createInvitationLink, new CallbackJsonResult<>(subscriber, new ResponseZerokitCreateInvitationLink(), jsInterfaceByteArrayProvider.add(password)), linkBase, tresorId, TextUtils.isEmpty(message) ? "" : message);
            }
        });
    }

#end
#end
#No. 189318
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * This method creates an invitation link with the password entered
     *
     * @param linkBase         the base of the link. The link secret is concatenated after this after a '#'
     * @param tresorId         the id of the tresor
     * @param message          optional arbitrary string data that can be retrieved without a password or any other information
     * @param passwordExporter the passwordexporter that holds the password to accept the link
     * @return Resolves to the operation id and the url of the created link. The operation must be approved before the link is enabled.
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<ResponseZerokitCreateInvitationLink, ResponseZerokitError> createInvitationLink(@NonNull final String linkBase, @NonNull final String tresorId, @Nullable final String message, @NonNull PasswordEditText.PasswordExporter passwordExporter) {
        return createInvitationLink(linkBase, tresorId, message, toBytes(passwordExporter.getCharArray(true)));
    }

#end
#end
#No. 189319
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * This method creates an invitation link with the password entered
     *
     * @param linkBase         the base of the link. The link secret is concatenated after this after a '#'
     * @param tresorId         the id of the tresor
     * @param message          optional arbitrary string data that can be retrieved without a password or any other information
     * @param passwordEditText the passwordEditText that holds the password to accept the link
     * @return Resolves to the operation id and the url of the created link. The operation must be approved before the link is enabled.
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<ResponseZerokitCreateInvitationLink, ResponseZerokitError> createInvitationLink(@NonNull final String linkBase, @NonNull final String tresorId, @Nullable final String message, @NonNull PasswordEditText passwordEditText) {
        return createInvitationLink(linkBase, tresorId, message, passwordEditText.getPasswordExporter());
    }

#end
#end
#No. 189320
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * This method will add the user to the tresor of the link using the password entered.
     *
     * @param token    The token is the $token field of the InvitationLinkPublicInfo of the link returned by getInvitationLinkInfo.
     * @param password The password for the link
     * @return Resolves to the operation id that must be approved for the operation to be effective.
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<String, ResponseZerokitError> acceptInvitationLink(@NonNull final String token, @NonNull final byte[] password) {
        return new CallAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super String, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.acceptInvitationLink, new CallbackStringResult(subscriber, token, jsInterfaceByteArrayProvider.add(password)));
            }
        });



#end
#end
#No. 189322
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * This method tries to log in the given user with the given password entered by the user
     *
     * @param userId     The userId of the user to log in.
     * @param password   The password of the user to log in.
     * @param rememberMe If true, than next time the login without password will be possible
     * @return Resolved userId of the logged in user.
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<ResponseZerokitLogin, ResponseZerokitError> login(@NonNull final String userId, @NonNull final byte[] password, final boolean rememberMe) {
        return new CallAction<>(new ActionCallback<ResponseZerokitLogin, ResponseZerokitError>() {
            @Override
            public void call(final Callback<? super ResponseZerokitLogin, ? super ResponseZerokitError> subscriber) {
                _login(userId, password).enqueue(new Action<ResponseZerokitLogin>() {
                    @Override
                    public void call(final ResponseZerokitLogin responseLogin) {
                        if (rememberMe)
                            _getRememberMeKey(userId, password).enqueue(new Action<String>() {
                                @Override
                                public void call(String rememberKey) {
                                    storeSecret(KEY_STORE_ALIAS, rememberKey);
                                    subscriber.onSuccess(responseLogin);
                                }
                            }, new Action<ResponseZerokitError>() {
                                @Override
                                public void call(ResponseZerokitError responseZerokitError) {
                                    subscriber.onSuccess(responseLogin);
                                }
                            });
                        else
                            subscriber.onSuccess(responseLogin);
                        Arrays.fill(password, (byte) 0);
                    }
                }, new Action<ResponseZerokitError>() {
                    @Override
                    public void call(ResponseZerokitError responseZerokitError) {
                        Arrays.fill(password, (byte) 0);
                        subscriber.onError(responseZerokitError);
                    }
                });
            }
        });

#end
#end
#No. 189323
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * This method tries to log in the given user with the stored remember me key
     *
     * @param userId The userId of the user to log in.
     * @return Resolved userId of the logged in user.
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<String, ResponseZerokitError> login(@NonNull final String userId) {
        return new CallAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(final Callback<? super String, ? super ResponseZerokitError> subscriber) {
                String secret = getSecret(KEY_STORE_ALIAS);
                if (secret == null)
                    subscriber.onError(new ResponseZerokitError("No secret found"));
                else
                    _loginByRememberMeKey(userId, secret).enqueue(new Action<String>() {
                        @Override
                        public void call(String s) {
                            subscriber.onSuccess(s);
                        }
                    }, new Action<ResponseZerokitError>() {
                        @Override
                        public void call(ResponseZerokitError responseZerokitError) {
                            subscriber.onError(responseZerokitError);
                        }
                    });
            }
        });



#end
#end
#No. 189326
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * This method logs into a security session and changes the password of the user.
     *
     * @param passwordExporterOld The currently used password
     * @param passwordExporterNew The new password
     * @return Resolves to the userId of the logged in user
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<ResponseZerokitChangePassword, ResponseZerokitError> changePassword(@NonNull final PasswordEditText.PasswordExporter passwordExporterOld, @NonNull PasswordEditText.PasswordExporter passwordExporterNew) {
        return changePassword(toBytes(passwordExporterOld.getCharArray(true)), toBytes(passwordExporterNew.getCharArray(true)));
    }

#end
#end
#No. 189327
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Log out the current user
     *
     * @return Observable about the results
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<String, ResponseZerokitError> logout() {
        return logout(true);
    }

#end
#end
#No. 189328
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Use this methods to get the logged in user's identity.
     *
     * @return the user ID if logged in or `null` if not.
     */

#Code:
    @NonNull
    public Call<String, ResponseZerokitError> whoAmI() {
        return new CallAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super String, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.whoAmI, new CallbackStringResult(subscriber));
            }
        });
    }



#end
#end
#No. 189330
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * The shareTresor method will share the tresor with the given user.
     * The operation will only be effective after it is approved using the returned OperationId.
     * This uploads a modified tresor, but the new version is downloadable only after it has been approved.
     * This should be done as soon as possible, as approving any operation to a tresor may invalidate any pending ones.
     *
     * @param tresorId The id of the tresor to invite the user to.
     * @param userId   The id of the user to invite. Important to notice, that this is not an alias.
     * @return Resolves to the OperationId that can be used to approve this share.
     * <p>
     * BadInput	        - Invalid tresor or userId
     * TresorNotExists  - Couldn't find a tresor by the give tresorId
     * Forbidden	    - This user does not have access to the tresor
     * UserNotFound     - There is no user by that id
     */

#Code:
    @NonNull
    public Call<String, ResponseZerokitError> shareTresor(@NonNull final String tresorId, @NonNull final String userId) {
        return new CallAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super String, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.shareTresor, new CallbackStringResult(subscriber), tresorId, userId);
            }
        });

#end
#end
#No. 189331
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Removes the given user from the tresor. The operation will only be effective after it is approved using the returned OperationId.
     *
     * @param tresorId The id of the tresor, which from the user will be kicked out
     * @param userId   The id of the user, who will be kicked out
     * @return Resolves to the operation id. The operation must be approved before the user is kicked out.
     * <p>
     * InvalidAuthorization     - Invalid username or password
     * UserNameDoesntExist	    - The user does not exist
     */

#Code:
    @SuppressWarnings("WeakerAccess")
    @NonNull
    public Call<String, ResponseZerokitError> kickFromTresor(@NonNull final String tresorId, @NonNull final String userId) {
        return new CallAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super String, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.kickFromTresor, new CallbackStringResult(subscriber), tresorId, userId);
            }
        });

#end
#end
#No. 189332
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Decrypts the given cipherText
     *
     * @param cipherText ZeroKit encrypted text
     * @return Resolves to the plain text.
     * <p>
     * BadInput 	- Invalid cipherText
     * Forbidden	- This user does not have access to the tresor
     */

#Code:
    @NonNull
    public Call<String, ResponseZerokitError> decrypt(@NonNull final String cipherText) {
        return new CallAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super String, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.decrypt, new CallbackStringResult(subscriber), cipherText);
            }
        });

#end
#end
#No. 189333
#File: E:\bishe\1\Zerokit.java
#Comment:
    /**
     * Encrypts the plaintext by the given tresor.
     *
     * @param tresorId  The id of the tresor, that will be used to encrypt the text
     * @param plainText The plainText to encrypt
     * @return Resolves to the cipher text. It contains the tresorId, so the it can be decrypted by itself.
     * <p>
     * BadInput         - The tresorId and plainText has to be a non-empty string
     * BadInput         - Invalid tresorId
     * TresorNotExists  - Couldn't find a tresor by the given id
     * Forbidden	    - This user does not have access to the tresor
     */

#Code:
    @NonNull
    public Call<String, ResponseZerokitError> encrypt(@NonNull final String tresorId, @NonNull final String plainText) {
        return new CallAction<>(new ActionCallback<String, ResponseZerokitError>() {
            @Override
            public void call(Callback<? super String, ? super ResponseZerokitError> subscriber) {
                Zerokit.this.callFunction(Function.encrypt, new CallbackStringResult(subscriber), tresorId, plainText);
            }
        });




#end
#end
#No. 189336
#File: E:\bishe\1\ZeroOrMoreExpression.java
#Comment:
  /**
   * Compiles this expression into a sequence of instructions:
   * <pre>
   * L1: Choice L2
   * subExpression
   * CommitVerify L1
   * L2: ...
   * </pre>
   */

#Code:
  @Override
  public Instruction[] compile(CompilationHandler compiler) {
    // TODO maybe can be optimized by introduction of new instruction PartialCommit
    Instruction[] sub = compiler.compile(subExpression);
    Instruction[] result = new Instruction[sub.length + 2];
    result[0] = Instruction.choice(sub.length + 2);
    System.arraycopy(sub, 0, result, 1, sub.length);
    result[sub.length + 1] = Instruction.commitVerify(-1 - sub.length);
    return result;
  }

#end
#end
#No. 189337
#File: E:\bishe\1\ZeroOrOneFactory.java
#Comment:
 /**
  * return computation yields argument
  * <p/>
  * one(z) is a computation yielding the value z
  * (z is the value of the computation one(z))
  */

#Code:
 public static <Z> ZeroOrOne<Z> one(
  final Z z
 ) {
  return new OneImpl<>(z);
 }

#end
#end
#No. 189338
#File: E:\bishe\1\ZeroOrOneFactory.java
#Comment:
 /**
  * joining a computation of computations
  * to a computation
  */

#Code:
 public static <Z> ZeroOrOne<Z> join(
  final ZeroOrOne<ZeroOrOne<Z>> mmz
 ) {
  return mmz.bnd(mz ->
   mz);
 }


#end
#end
#No. 189340
#File: E:\bishe\1\ZeroOrOneFactory.java
#Comment:
 /**
  * lifts unary functions
  * to the ZeroOrOne level
  */

#Code:
 public static <Z, Y>
 Function<ZeroOrOne<Z>, ZeroOrOne<Y>> lift1(
  final Function<Z, Y> z2y
 ) {
  return mz -> mz.and(
   one(z -> z2y.apply(z)));
 }

#end
#end
#No. 189341
#File: E:\bishe\1\ZeroOrOneFactory.java
#Comment:
 /**
  * lifts binary functions
  * to the ZeroOrOne level
  */

#Code:
 public static <Z, Y, X>
 Function<ZeroOrOne<Z>, Function<ZeroOrOne<Y>, ZeroOrOne<X>>> lift2(
  final Function<Z, Function<Y, X>> z_2_y2x
 ) {
  return mz -> my -> mz.and(my.and(
   one(y -> z -> z_2_y2x.apply(z).apply(y))));
 }

#end
#end
#No. 189342
#File: E:\bishe\1\ZeroOrOneFactory.java
#Comment:
 /**
  * converts a zero ore one of zero or ones
  * to a zero ore one of zero or ones
  * <p/>
  */

#Code:
 public static <Z> ZeroOrOne<ZeroOrOne<Z>> zeroOrOnes(
  final ZeroOrOne<ZeroOrOne<Z>> nmz
 ) {
  return nmz.traverseZeroOrOnes(
   () -> ZeroOrOneFactory.<Z>zero(),
   (ZeroOrOne<Z> mz) -> mz
  ).apply(lift1(ZeroOrOneFactory::one));
 }

#end
#end
#No. 189343
#File: E:\bishe\1\ZeroOrOneFactory.java
#Comment:
 /**
  * converts a one of zero or ones
  * to a zero ore one of ones
  * <p/>
  */

#Code:
 public static <Z> ZeroOrOne<One<Z>> zeroOrOnes(
  final One<ZeroOrOne<Z>> nmz
 ) {
  return nmz.traverseZeroOrOnes(
   (One<Z> mz) -> mz
  ).apply(lift1(OneFactory::one));
 }

#end
#end
#No. 189344
#File: E:\bishe\1\ZeroOrOneFactory.java
#Comment:
 /**
  * return computation yields zero values
  * <p/>
  * zero() is a computation yielding zero values
  */

#Code:
 public static <Z> ZeroOrOne<Z> zero() {
  return new ZeroImpl<>();
 }

#end
#end
#No. 189345
#File: E:\bishe\1\ZeroOrOneFactory.java
#Comment:
 /**
  * static version of or
  */

#Code:
 public static <Z> Function<ZeroOrOne<Z>, ZeroOrOne<Z>> or(
  final ZeroOrOne<Z> mz1
 ) {
  return mz2 -> mz1.or(() -> mz2);
 }

#end
#end
#No. 189347
#File: E:\bishe\1\ZeroUtil.java
#Comment:
  /**
   * @param typeName type
   * @return first type argument, if any
   * @throws IllegalArgumentException if type has multiple type arguments
   */

#Code:
  static Optional<TypeName> onlyTypeArgument(TypeName typeName) {
    List<TypeName> types = typeArguments(typeName);
    switch (types.size()) {
      case 0:
        return Optional.empty();
      case 1:
        return Optional.of(types.get(0));
      default:
        throw new IllegalArgumentException("multiple type arguments");
    }
  }



#end
#end
#No. 189350
#File: E:\bishe\1\ZetaCalculator.java
#Comment:
    /**
     * @param args
     */

#Code:
    public static void main(String[] args) throws Exception {
        ExecutorService es = Executors.newCachedThreadPool();
        es.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(".999 - " + Double.toString(ZipfianGenerator.zetastatic(ITEM_COUNT, .999)));
            }
        });
        es.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(".9999 - " + Double.toString(ZipfianGenerator.zetastatic(ITEM_COUNT, .9999)));
            }
        });
        es.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(".99999 - " + Double.toString(ZipfianGenerator.zetastatic(ITEM_COUNT, .99999)));
            }
        });
        es.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(".999999 - " + Double.toString(ZipfianGenerator.zetastatic(ITEM_COUNT, .999999)));
            }
        });
        es.shutdown();
        es.awaitTermination(356, TimeUnit.DAYS);
    }


#end
#end
#No. 189352
#File: E:\bishe\1\ZettelkastenApp.java
#Comment:
    /**
     * Main method launching the application.
     * @param args
     */

#Code:
    public static void main(String[] args) {
        launch(ZettelkastenApp.class, args);
    }

#end
#end
#No. 189353
#File: E:\bishe\1\ZettelkastenViewUtil.java
#Comment:
    /**
     * This method opens files or folders (attchments). Typically used when
     * opening attachments. First, this method tries to open a file using the
     * {@code Desktop} api from Java. If this fails, on Windows and Linux the
     * {@code Runtime}.
     *
     * @param path The path to the file that should be opened
     * @param settings a reference to the Settings class
     * @return {@code true} if opening the file was successfull, {@code false}
     * otherwise.
     */

#Code:
    public static boolean openFilePath(String path, Settings settings) {
        File linuxpath = new File(path);
        // on linux, check whether we have white spaces
        if (linuxpath.toString().contains(" ")) {
            // if so, replace them with ascii-number
            linuxpath = new File("file://" + linuxpath.toString().replaceAll(Pattern.quote(" "), Matcher.quoteReplacement("%20")));
        }
        // log file path, in case we need to debug user info
        Constants.zknlogger.log(Level.INFO, "Verwendeter Anhangspfad: {0}", linuxpath);
        // check whether desktop-api is supported
        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.OPEN)) {
            try {
                // open file
                Desktop.getDesktop().open(new File(path));
            } catch (IOException ex) {
                // log error
                Constants.zknlogger.log(Level.WARNING, ex.getLocalizedMessage());
                return false;
            }
        } else {
            try {
                // on windows, use Runtime with rundll32
                if (PlatformUtil.isWindows()) {
                    Runtime.getRuntime().exec("rundll32 SHELL32.DLL,ShellExec_RunDLL \"" + path + "\"");
                } else if (PlatformUtil.isLinux()) {
                    // on linux, use xdg-open
                    Runtime.getRuntime().exec("xdg-open " + linuxpath.getPath());
                }
            } catch (IOException ex) {
                Constants.zknlogger.log(Level.WARNING, ex.getLocalizedMessage());
                return false;
            }
        }
        return true;
    }

#end
#end
#No. 189354
#File: E:\bishe\1\ZettelkastenViewUtil.java
#Comment:
    /**
     * This method updates a jTable and a possible linked list which holds
     * filtered values from the jTables, by increasing ({@code diff} must be 1)
     * or decreasing ({@code diff} must be -1) an entry's occurences or
     * frequencies from the tablemodel and the linked list.
     * <br><br>
     * If no increase or decrease of frequencies (occurences) is requested, but
     * a complete removal, call
     * {@link #updateTableFrequencyRemove(javax.swing.JTable, java.util.LinkedList) updateTableFrequencyRemove(javax.swing.JTable, java.util.LinkedList)}
     * instead.
     *
     * @param table the table were we have to add a new value with frequency
     * @param list the possible linked list were we have to add a new value with
     * frequency
     * @param value the new value, for instance the author-string or
     * keyword-value
     * @param diff either +1, if a value was added, so frequency is increased by
     * 1. or -1, if a value was removed, so frequency is decreaded.
     * @return an updated linked list that was passed as parameter {@code list}
     */

#Code:
    public static LinkedList<Object[]> updateTableFrequencyChange(JTable table, LinkedList<Object[]> list, String value, int diff) {
        // iterate all table rows
        for (int cnt = 0; cnt < table.getRowCount(); cnt++) {
            // check whether we have found the value that should be changed
            if (value.equals(table.getValueAt(cnt, 0).toString())) {
                // retrieve table data
                Object[] o = new Object[2];
                o[0] = table.getValueAt(cnt, 0);
                o[1] = table.getValueAt(cnt, 1);
                // convert frquency-counter to int
                int freq = Integer.parseInt(table.getValueAt(cnt, 1).toString());
                // set new value
                table.setValueAt(freq + diff, cnt, 1);
                // check whether we have a filtered list
                if (list != null) {
                    // if so, iterate list
                    for (int pos = 0; pos < list.size(); pos++) {
                        Object[] v = list.get(pos);
                        // check whether we have found the value that should be changed
                        if (o[0].toString().equals(v[0].toString())) {
                            // change frequency
                            o[1] = freq + diff;
                            list.set(pos, o);
                            break;
                        }
                    }
                }
            }
        }
        return list;
    }

#end
#end
#No. 189355
#File: E:\bishe\1\ZettelkastenViewUtil.java
#Comment:
    /**
     * This method updates a jTable and a possible linked list which holds
     * filtered values from the jTable, by adding new values to the table and
     * list. this method is called when new e.g. authors were edited (see
     * {@link #newAuthor() newAuthor()} or
     * {@link #finishedEditing() finishedEditing()}).
     *
     * @param table the table were we have to add a new value with frequency
     * @param list the possible linked list were we have to add a new value with
     * frequency
     * @param val the new value, for instance the author-string or keyword-value
     * @param occurences the frequency of the value {@code val}.
     * @return an updated linked list that was passed as parameter {@code list}
     */

#Code:
    public static LinkedList<Object[]> updateTableFrequencyNew(JTable table, LinkedList<Object[]> list, String val, int occurences) {
        // get table model
        DefaultTableModel dtm = (DefaultTableModel) table.getModel();
        // create new item
        Object[] obj = new Object[2];
        obj[0] = val;
        obj[1] = occurences;
        // add to table
        dtm.addRow(obj);
        // check whether we have a list that contains filtered entries
        if (list != null) {
            // add item to list aswell
            list.add(obj);
        }
        return list;
    }

#end
#end
#No. 189356
#File: E:\bishe\1\ZettelkastenViewUtil.java
#Comment:
    /**
     * This method updates a jTable and a possible linked list which holds
     * filtered values from the jTables, by completely removing an entry/value
     * from the tablemodel and the linked list.
     * <br><br>
     * If no complete removal is requested, but a decrease in the frequencies,
     * call
     * {@link #updateTableFrequencyDelete(javax.swing.JTable, java.util.LinkedList) updateTableFrequencyDelete(javax.swing.JTable, java.util.LinkedList)}
     * instead.
     *
     * @param table the table were we have to add a new value with frequency
     * @param list the possible linked list were we have to add a new value with
     * frequency
     * @param zettelkastenView
     * @return an updated linked list that was passed as parameter {@code list}
     */

#Code:
    public static LinkedList<Object[]> updateTableFrequencyRemove(JTable table, LinkedList<Object[]> list, ZettelkastenView zettelkastenView) {
        // get table model
        DefaultTableModel dtm = (DefaultTableModel) table.getModel();
        // retrieve selected rows
        int[] rows = table.getSelectedRows();
        for (int cnt = rows.length - 1; cnt >= 0; cnt--) {
            try {
                int selectedrow = table.convertRowIndexToModel(rows[cnt]);
                if (list != null) {
                    Object[] o = new Object[2];
                    o[0] = dtm.getValueAt(selectedrow, 0);
                    o[1] = dtm.getValueAt(selectedrow, 1);
                    int pos = findInLinkedList(list, o);
                    if (pos != -1) {
                        list.remove(pos);
                    }
                }
                dtm.removeRow(selectedrow);
            } catch (ArrayIndexOutOfBoundsException e) {
                Constants.zknlogger.log(Level.WARNING, e.getLocalizedMessage());
            }
        }
        return list;
    }

#end
#end
#No. 189357
#File: E:\bishe\1\ZettelkastenViewUtil.java
#Comment:
    /**
     * This method retrieves the entry-number of the first selected entry in the
     * tabbed pane with the a jTable
     *
     * @param data
     * @param table a reference to the swing-table, from which we want to
     * retrieve the entry
     * @param column the column which holds the entry-numbers. in most cases
     * this is column 0, but some tables store the entry-numbers in column 1
     * @return the entry number of the selected entry in a table (<i>not</i> the
     * number of the selected table row!), or -1 if nothing is selected
     */

#Code:
    public static int retrieveSelectedEntryFromTable(Daten data, javax.swing.JTable table, int column) {
        // if no data available, leave method
        if (data.getCount(Daten.ZKNCOUNT) < 1) {
            return -1;
        }
        // get the amount of selected rows
        int rowcount = table.getSelectedRowCount();
        // if we have no selected values, leave method
        if (rowcount < 1) {
            return -1;
        }
        int entrynr;
        // get the selected row
        int rows = table.getSelectedRow();
        try {
            // iterate all selected values and copy all values to array
            entrynr = Integer.parseInt(table.getValueAt(rows, column).toString());
        } catch (NumberFormatException e) {
            return -1;
        }
        // and return the array
        return entrynr;
    }

#end
#end
#No. 189358
#File: E:\bishe\1\ZettelkastenViewUtil.java
#Comment:
    /**
     * This method retrieves the entry-numbers of all selected entries in the
     * tabbed pane with the a jTable
     *
     * @param data
     * @param table a reference to the swing-table, from which we want to
     * retrieve the entry
     * @param column the column which holds the entry-numbers. in most cases
     * this is column 0, but some tables store the entry-numbers in column 1
     * @return the entry numbers of all selected entries in a table (<i>not</i>
     * the number of the selected table row!), or {@code null} if nothing is
     * selected
     */

#Code:
    public static int[] retrieveSelectedEntriesFromTable(Daten data, javax.swing.JTable table, int column) {
        // if no data available, leave method
        if (data.getCount(Daten.ZKNCOUNT) < 1) {
            return null;
        }
        // get the amount of selected rows
        int rowcount = table.getSelectedRowCount();
        // if we have no selected values, leave method
        if (rowcount < 1) {
            return null;
        }
        // get the selected rows
        int[] rows = table.getSelectedRows();
        // create string array as parameter
        int[] selectedValues = new int[rows.length];
        try {
            // iterate all selected values and copy all values to array
            for (int cnt = 0; cnt < rows.length; cnt++) {
                selectedValues[cnt] = Integer.parseInt(table.getValueAt(rows[cnt], column).toString());
            }
            // and return the array
            return selectedValues;
        } catch (NumberFormatException e) {
            return null;
        }
    }

#end
#end
#No. 189359
#File: E:\bishe\1\ZettelkastenViewUtil.java
#Comment:
    /**
     * This method retrieves the selected values of a table in the tabbed pane
     * and returns them in a string-array
     *
     * @param table a reference to the swing-table, from which we want to
     * retrieve the entry
     * @param column the column which holds the requested values.
     * @return an string-array with all values of the selected table-entries, or
     * null if nothing is selected
     */

#Code:
    public static String[] retrieveSelectedValuesFromTable(JTable table, int column) {
        int[] rows = table.getSelectedRows();
        if (rows.length < 1) {
            return null;
        }
        String[] value = new String[rows.length];
        for (int cnt = 0; cnt < rows.length; cnt++) {
            value[cnt] = table.getValueAt(rows[cnt], column).toString();
        }
        return value;
    }

#end
#end
#No. 189360
#File: E:\bishe\1\ZHelper.java
#Comment:
    /**
     * Receives all message parts from socket, prints neatly
     */

#Code:
    public static void dump(Socket sock)
    {
        System.out.println("----------------------------------------");
        while (true) {
            byte[] msg = sock.recv(0);
            boolean isText = true;
            String data = "";
            for (int i = 0; i < msg.length; i++) {
                if (msg[i] < 32 || msg[i] > 127)
                    isText = false;
                data += String.format("%02X", msg[i]);
            }
            if (isText)
                data = new String(msg, ZMQ.CHARSET);

            System.out.println(String.format("[%03d] %s", msg.length, data));
            if (!sock.hasReceiveMore())
                break;
        }
    }

#end
#end
#No. 189374
#File: E:\bishe\1\ZidFile.java
#Comment:
    /**
     * Get the an instance of ZIDFile.
     *
     * This method just creates an instance an store a pointer to it
     * in a static variable. The ZIDFile is a singleton, thus only
     * <em>one</em> ZID file can be open at one time.
     *
     * @return
     *    A pointer to the global ZIDFile singleton instance.
     */

#Code:
    public synchronized static ZidFile getInstance() {
        if (instance == null) {
            instance = new ZidFile();
        }
        return instance;
    }

#end
#end
#No. 189375
#File: E:\bishe\1\ZidFile.java
#Comment:
    /**
     * Check if ZIDFile has an active (open) file.
     *
     * @return
     *    True if ZIDFile has an active file, false otherwise
     */

#Code:
    public synchronized boolean isOpen() { 
        return (zidFile != null); 
    }

#end
#end
#No. 189376
#File: E:\bishe\1\ZidFile.java
#Comment:
     /**
         * Close the ZID file. Closes the ZID file, and prepares to open a new
         * ZID file.
         */

#Code:
    public synchronized void close() {
        if (zidFile != null) {
            try {
                zidFile.close();
            } catch (IOException e1) {
                zidFile = null;
                return;
            }
            zidFile = null;
        }
    }

#end
#end
#No. 189377
#File: E:\bishe\1\ZidFile.java
#Comment:
    /**
     * Save a ZID record into the active ZID file.
     *
     * This method saves the content of a ZID record into the ZID file. Before
     * you can save the ZID record you must have performed a getRecord()
     * first.
     *
     * @param zidRecord
     *    The ZID record to save.
     * @return
     *    1 on success
     */

#Code:
    public synchronized int saveRecord(ZidRecord zidRecord) {
        try {
            zidFile.seek(zidRecord.getPosition());
            zidFile.write(zidRecord.getBuffer());
        } catch (IOException e) {
            return -1;
        }
        // fflush(zidFile);
        return 1;
    }

#end
#end
#No. 189378
#File: E:\bishe\1\ZidFile.java
#Comment:
    /**
     * Get the ZID associated with this ZID file.
     *
     * @return
     *    Pointer to the ZID
     */

#Code:
    public synchronized byte[] getZid() { 
        return associatedZid;
    }

#end
#end
#No. 189389
#File: E:\bishe\1\ZioEntry.java
#Comment:
    /*
     * Returns timetamp in Java format
     */

#Code:
    public long getTime() {
        int year = (int)(((modificationDate >> 9) & 0x007f) + 80);
        int month = (int)(((modificationDate >> 5) & 0x000f) - 1);
        int day = (int)(modificationDate & 0x001f);
        int hour = (int)((modificationTime >> 11) & 0x001f);
        int minute = (int)((modificationTime >> 5) & 0x003f);
        int seconds = (int)((modificationTime << 1) & 0x003e);
        Date d = new Date( year, month, day, hour, minute, seconds);
        return d.getTime();
    }

#end
#end
#No. 189390
#File: E:\bishe\1\ZioEntry.java
#Comment:
    /*
     * Set the file timestamp (using a Java time value).
     */

#Code:
    public void setTime(long time) {
        Date d = new Date(time);
        long dtime;
        int year = d.getYear() + 1900;
        if (year < 1980) {
            dtime = (1 << 21) | (1 << 16);
        }
        else {
            dtime = (year - 1980) << 25 | (d.getMonth() + 1) << 21 |
            d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 |
            d.getSeconds() >> 1;
        }

        modificationDate = (short)(dtime >> 16);
        modificationTime = (short)(dtime & 0xFFFF);
    }

#end
#end
#No. 189391
#File: E:\bishe\1\Zip4jUtil.java
#Comment:
	/**
	 * Converts input time from Java to DOS format
	 * @param time
	 * @return time in DOS format 
	 */

#Code:
	public static long javaToDosTime(long time) {
		
		Calendar cal = Calendar.getInstance();
		cal.setTimeInMillis(time);
		
		int year = cal.get(Calendar.YEAR);
		if (year < 1980) {
		    return (1 << 21) | (1 << 16);
		}
		return (year - 1980) << 25 | (cal.get(Calendar.MONTH) + 1) << 21 |
	               cal.get(Calendar.DATE) << 16 | cal.get(Calendar.HOUR_OF_DAY) << 11 | cal.get(Calendar.MINUTE) << 5 |
	               cal.get(Calendar.SECOND) >> 1;
	}

#end
#end
#No. 189392
#File: E:\bishe\1\Zip4jUtil.java
#Comment:
	/**
	 * Converts time in dos format to Java format
	 * @param dosTime
	 * @return time in java format
	 */

#Code:
	public static long dosToJavaTme(int dosTime) {
		int sec = 2 * (dosTime & 0x1f);
	    int min = (dosTime >> 5) & 0x3f;
	    int hrs = (dosTime >> 11) & 0x1f;
	    int day = (dosTime >> 16) & 0x1f;
	    int mon = ((dosTime >> 21) & 0xf) - 1;
	    int year = ((dosTime >> 25) & 0x7f) + 1980;
	    
	    Calendar cal = Calendar.getInstance();
		cal.set(year, mon, day, hrs, min, sec);
		cal.set(Calendar.MILLISECOND, 0);
		return cal.getTime().getTime();
	}

#end
#end
#No. 189393
#File: E:\bishe\1\Zip4jUtil.java
#Comment:
	/**
	 * Decodes file name based on encoding. If file name is UTF 8 encoded
	 * returns an UTF8 encoded string, else return Cp850 encoded String. If 
	 * appropriate charset is not supported, then returns a System default 
	 * charset encoded String
	 * @param data
	 * @param isUTF8
	 * @return String
	 */

#Code:
	public static String decodeFileName(byte[] data, boolean isUTF8) {
		if (isUTF8) {
			try {
				return new String(data, InternalZipConstants.CHARSET_UTF8);
			} catch (UnsupportedEncodingException e) {
				return new String(data);
			}
		} else {
			return getCp850EncodedString(data);
		}
	}

#end
#end
#No. 189394
#File: E:\bishe\1\Zip4jUtil.java
#Comment:
	/**
	 * Returns a string in Cp850 encoding from the input bytes.
	 * If this encoding is not supported, then String with the default encoding is returned.
	 * @param data
	 * @return String
	 */

#Code:
	public static String getCp850EncodedString(byte[] data) {
		try {
			String retString = new String(data, InternalZipConstants.CHARSET_CP850);
			return retString;
		} catch (UnsupportedEncodingException e) {
			return new String(data);
		}
	}

#end
#end
#No. 189395
#File: E:\bishe\1\Zip4jUtil.java
#Comment:
	/**
	 * Returns an absoulte path for the given file path 
	 * @param filePath
	 * @return String
	 */

#Code:
	public static String getAbsoluteFilePath(String filePath) throws ZipException {
		if (!isStringNotNullAndNotEmpty(filePath)) {
			throw new ZipException("filePath is null or empty, cannot get absolute file path");
		}
		
		File file = new File(filePath);
		return file.getAbsolutePath();
	}

#end
#end
#No. 189396
#File: E:\bishe\1\Zip4jUtil.java
#Comment:
	/**
	 * Checks to see if all the elements in the arraylist match the given type
	 * @param sourceList - list to be checked
	 * @param type - type of elements to be present in the list (ex: File, String, etc)
	 * @return true if all elements match the given type, if not returns false
	 */

#Code:
	public static boolean checkArrayListTypes(ArrayList sourceList, int type) throws ZipException {
		
		if (sourceList == null) {
			throw new ZipException("input arraylist is null, cannot check types");
		}
		
		if (sourceList.size() <= 0) {
			return true;
		}
		
		boolean invalidFound = false;
		
		switch (type) {
		case InternalZipConstants.LIST_TYPE_FILE:
			for (int i = 0; i < sourceList.size(); i++) {
				if (!(sourceList.get(i) instanceof File)) {
					invalidFound = true;
					break;
				}
			}
			break;
		case InternalZipConstants.LIST_TYPE_STRING:
			for (int i = 0; i < sourceList.size(); i++) {
				if (!(sourceList.get(i) instanceof String)) {
					invalidFound = true;
					break;
				}
			}
			break;
		default:
			break;
		}
		return !invalidFound;
	}

#end
#end
#No. 189397
#File: E:\bishe\1\Zip4jUtil.java
#Comment:
	/**
	 * Detects the encoding charset for the input string
	 * @param str
	 * @return String - charset for the String
	 * @throws ZipException - if input string is null. In case of any other exception
	 * this method returns default System charset
	 */

#Code:
	public static String detectCharSet(String str) throws ZipException {
		if (str == null) {
			throw new ZipException("input string is null, cannot detect charset");
		}
		
		try {
			byte[] byteString = str.getBytes(InternalZipConstants.CHARSET_CP850);
			String tempString = new String(byteString, InternalZipConstants.CHARSET_CP850);
			
			if (str.equals(tempString)) {
				return InternalZipConstants.CHARSET_CP850;
			}
			
			byteString = str.getBytes(InternalZipConstants.CHARSET_UTF8);
			tempString = new String(byteString, InternalZipConstants.CHARSET_UTF8);
			
			if (str.equals(tempString)) {
				return InternalZipConstants.CHARSET_UTF8;
			}
			
			return InternalZipConstants.CHARSET_DEFAULT;
		} catch (UnsupportedEncodingException e) {
			return InternalZipConstants.CHARSET_DEFAULT;
		} catch (Exception e) {
			return InternalZipConstants.CHARSET_DEFAULT;
		}
	}

#end
#end
#No. 189398
#File: E:\bishe\1\Zip4jUtil.java
#Comment:
	/**
	 * returns the length of the string by wrapping it in a byte buffer with
	 * the appropriate charset of the input string and returns the limit of the 
	 * byte buffer
	 * @param str
	 * @return length of the string
	 * @throws ZipException
	 */

#Code:
	public static int getEncodedStringLength(String str) throws ZipException {
		if (!isStringNotNullAndNotEmpty(str)) {
			throw new ZipException("input string is null, cannot calculate encoded String length");
		}
		
		String charset = detectCharSet(str);
		return getEncodedStringLength(str, charset);
	}

#end
#end
#No. 189399
#File: E:\bishe\1\Zip4jUtil.java
#Comment:
	/**
	 * returns the length of the string in the input encoding
	 * @param str
	 * @param charset
	 * @return int
	 * @throws ZipException
	 */

#Code:
	public static int getEncodedStringLength(String str, String charset) throws ZipException {
		if (!isStringNotNullAndNotEmpty(str)) {
			throw new ZipException("input string is null, cannot calculate encoded String length");
		}
		
		if (!isStringNotNullAndNotEmpty(charset)) {
			throw new ZipException("encoding is not defined, cannot calculate string length");
		}
		
		ByteBuffer byteBuffer = null;
		
		try {
			if (charset.equals(InternalZipConstants.CHARSET_CP850)) {
				byteBuffer = ByteBuffer.wrap(str.getBytes(InternalZipConstants.CHARSET_CP850));
			} else if (charset.equals(InternalZipConstants.CHARSET_UTF8)) {
				byteBuffer = ByteBuffer.wrap(str.getBytes(InternalZipConstants.CHARSET_UTF8));
			} else {
				byteBuffer = ByteBuffer.wrap(str.getBytes(charset));
			}
		} catch (UnsupportedEncodingException e) {
			byteBuffer = ByteBuffer.wrap(str.getBytes());
		} catch (Exception e) {
			throw new ZipException(e);
		}
		
		return byteBuffer.limit();
	}

#end
#end
#No. 189400
#File: E:\bishe\1\Zip4jUtil.java
#Comment:
	/**
	 * Checks if the input charset is supported
	 * @param charset
	 * @return boolean
	 * @throws ZipException
	 */

#Code:
	public static boolean isSupportedCharset(String charset) throws ZipException {
		if (!isStringNotNullAndNotEmpty(charset)) {
			throw new ZipException("charset is null or empty, cannot check if it is supported");
		}
		
		try {
			new String("a".getBytes(), charset);
			return true;
		} catch (UnsupportedEncodingException e) {
			return false;
		} catch (Exception e) {
			throw new ZipException(e);
		}
	}

#end
#end
#No. 189401
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * Sets the central directory part of extra fields.
     */

#Code:
    public void setCentralDirectoryExtra(byte[] b) {
        try {
            ZipExtraField[] central =
                ExtraFieldUtils.parse(b, false,
                                      ExtraFieldUtils.UnparseableExtraField.READ);
            mergeExtraFields(central, false);
        } catch (ZipException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

#end
#end
#No. 189402
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * Retrieves the extra data for the local file data.
     * @return the extra data for local file
     */

#Code:
    public byte[] getLocalFileDataExtra() {
        byte[] extra = getExtra();
        return extra != null ? extra : new byte[0];
    }

#end
#end
#No. 189403
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * Retrieves the extra data for the central directory.
     * @return the central directory extra data
     */

#Code:
    public byte[] getCentralDirectoryExtra() {
        return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields(true));
    }

#end
#end
#No. 189404
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * Get the name of the entry.
     * @return the entry name
     */

#Code:
    public String getName() {
        return name == null ? super.getName() : name;
    }

#end
#end
#No. 189405
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * Is this entry a directory?
     * @return true if the entry is a directory
     */

#Code:
    public boolean isDirectory() {
        return getName().endsWith("/");
    }

#end
#end
#No. 189406
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * Set the name of the entry.
     * @param name the name to use
     */

#Code:
    protected void setName(String name) {
        this.name = name;
    }

#end
#end
#No. 189407
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * Sets the name using the raw bytes and the string created from
     * it by guessing or using the configured encoding.
     * @param name the name to use created from the raw bytes using
     * the guessed or configured encoding
     * @param rawName the bytes originally read as name from the
     * archive
     * @since Apache Commons Compress 1.2
     */

#Code:
    protected void setName(String name, byte[] rawName) {
        setName(name);
        this.rawName = rawName;
    }

#end
#end
#No. 189408
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * Returns the raw bytes that made up the name before it has been
     * converted using the configured or guessed encoding.
     *
     * <p>This method will return null if this instance has not been
     * read from an archive.</p>
     *
     * @since Apache Commons Compress 1.2
     */

#Code:
    public byte[] getRawName() {
        if (rawName != null) {
            byte[] b = new byte[rawName.length];
            System.arraycopy(rawName, 0, b, 0, rawName.length);
            return b;
        }
        return null;
    }

#end
#end
#No. 189409
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * Get the hashCode of the entry.
     * This uses the name as the hashcode.
     * @return a hashcode.
     */

#Code:
    public int hashCode() {
        // this method has severe consequences on performance. We cannot rely
        // on the super.hashCode() method since super.getName() always return
        // the empty string in the current implemention (there's no setter)
        // so it is basically draining the performance of a hashmap lookup
        return getName().hashCode();
    }

#end
#end
#No. 189410
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * The "general purpose bit" field.
     * @since Apache Commons Compress 1.1
     */

#Code:
    public GeneralPurposeBit getGeneralPurposeBit() {
        return gpb;
    }

#end
#end
#No. 189411
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * The "general purpose bit" field.
     * @since Apache Commons Compress 1.1
     */

#Code:
    public void setGeneralPurposeBit(GeneralPurposeBit b) {
        gpb = b;
    }

#end
#end
#No. 189412
#File: E:\bishe\1\ZipArchiveEntry.java
#Comment:
    /**
     * If there are no extra fields, use the given fields as new extra
     * data - otherwise merge the fields assuming the existing fields
     * and the new fields stem from different locations inside the
     * archive.
     * @param f the extra fields to merge
     * @param local whether the new fields originate from local data
     */

#Code:
    private void mergeExtraFields(ZipExtraField[] f, boolean local)
        throws ZipException {
        if (extraFields == null) {
            setExtraFields(f);
        } else {
            for (int i = 0; i < f.length; i++) {
                ZipExtraField existing;
                if (f[i] instanceof UnparseableExtraFieldData) {
                    existing = unparseableExtra;
                } else {
                    existing = getExtraField(f[i].getHeaderId());
                }
                if (existing == null) {
                    addExtraField(f[i]);
                } else {
                    if (local) {
                        byte[] b = f[i].getLocalFileDataData();
                        existing.parseFromLocalFileData(b, 0, b.length);
                    } else {
                        byte[] b = f[i].getCentralDirectoryData();
                        existing.parseFromCentralDirectoryData(b, 0, b.length);
                    }
                }
            }
            setExtra();
        }
    }


#end
#end
#No. 189414
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Creates a new ZIP OutputStream writing to a File.  Will use
     * random access if possible.
     * @param file the file to zip to
     * @throws IOException on error
     */

#Code:
    public ZipArchiveOutputStream(File file) throws IOException {
        OutputStream o = null;
        RandomAccessFile _raf = null;
        try {
            _raf = new RandomAccessFile(file, "rw");
            _raf.setLength(0);
        } catch (IOException e) {
            if (_raf != null) {
                try {
                    _raf.close();
                } catch (IOException inner) {
                    // ignore
                }
                _raf = null;
            }
            o = new FileOutputStream(file);
        }
        out = o;
        raf = _raf;
    }

#end
#end
#No. 189415
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * This method indicates whether this archive is writing to a
     * seekable stream (i.e., to a random access file).
     *
     * <p>For seekable streams, you don't need to calculate the CRC or
     * uncompressed size for {@link #STORED} entries before
     * invoking {@link #putArchiveEntry(ArchiveEntry)}.
     * @return true if seekable
     */

#Code:
    public boolean isSeekable() {
        return raf != null;
    }

#end
#end
#No. 189416
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * The encoding to use for filenames and the file comment.
     *
     * <p>For a list of possible values see <a
     * href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.
     * Defaults to UTF-8.</p>
     * @param encoding the encoding to use for file names, use null
     * for the platform's default encoding
     */

#Code:
    public void setEncoding(final String encoding) {
        this.encoding = encoding;
        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
        useUTF8Flag &= ZipEncodingHelper.isUTF8(encoding);
    }

#end
#end
#No. 189417
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * The encoding to use for filenames and the file comment.
     *
     * @return null if using the platform's default character encoding.
     */

#Code:
    public String getEncoding() {
        return encoding;
    }

#end
#end
#No. 189418
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Whether to set the language encoding flag if the file name
     * encoding is UTF-8.
     *
     * <p>Defaults to true.</p>
     */

#Code:
    public void setUseLanguageEncodingFlag(boolean b) {
        useUTF8Flag = b && ZipEncodingHelper.isUTF8(encoding);
    }

#end
#end
#No. 189419
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Whether to create Unicode Extra Fields.
     *
     * <p>Defaults to NEVER.</p>
     */

#Code:
    public void setCreateUnicodeExtraFields(UnicodeExtraFieldPolicy b) {
        createUnicodeExtraFields = b;
    }

#end
#end
#No. 189420
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Whether to fall back to UTF and the language encoding flag if
     * the file name cannot be encoded using the specified encoding.
     *
     * <p>Defaults to false.</p>
     */

#Code:
    public void setFallbackToUTF8(boolean b) {
        fallbackToUTF8 = b;
    }

#end
#end
#No. 189421
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * {@inheritDoc} 
     * @throws ClassCastException if entry is not an instance of ZipArchiveEntry
     */

#Code:
    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {
        if (finished) {
            throw new IOException("Stream has already been finished");
        }

        if (entry != null) {
            closeArchiveEntry();
        }

        entry = ((ZipArchiveEntry) archiveEntry);
        entries.add(entry);

        if (entry.getMethod() == -1) { // not specified
            entry.setMethod(method);
        }

        if (entry.getTime() == -1) { // not specified
            entry.setTime(System.currentTimeMillis());
        }

        // Size/CRC not required if RandomAccessFile is used
        if (entry.getMethod() == STORED && raf == null) {
            if (entry.getSize() == -1) {
                throw new ZipException("uncompressed size is required for"
                                       + " STORED method when not writing to a"
                                       + " file");
            }
            if (entry.getCrc() == -1) {
                throw new ZipException("crc checksum is required for STORED"
                                       + " method when not writing to a file");
            }
            entry.setCompressedSize(entry.getSize());
        }

        if (entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {
            def.setLevel(level);
            hasCompressionLevelChanged = false;
        }
        writeLocalFileHeader(entry);
    }

#end
#end
#No. 189422
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Set the file comment.
     * @param comment the comment
     */

#Code:
    public void setComment(String comment) {
        this.comment = comment;
    }

#end
#end
#No. 189423
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Sets the compression level for subsequent entries.
     *
     * <p>Default is Deflater.DEFAULT_COMPRESSION.</p>
     * @param level the compression level.
     * @throws IllegalArgumentException if an invalid compression
     * level is specified.
     */

#Code:
    public void setLevel(int level) {
        if (level < Deflater.DEFAULT_COMPRESSION
            || level > Deflater.BEST_COMPRESSION) {
            throw new IllegalArgumentException("Invalid compression level: "
                                               + level);
        }
        hasCompressionLevelChanged = (this.level != level);
        this.level = level;
    }

#end
#end
#No. 189424
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Sets the default compression method for subsequent entries.
     *
     * <p>Default is DEFLATED.</p>
     * @param method an <code>int</code> from java.util.zip.ZipEntry
     */

#Code:
    public void setMethod(int method) {
        this.method = method;
    }

#end
#end
#No. 189425
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Whether this stream is able to write the given entry.
     *
     * <p>May return false if it is set up to use encryption or a
     * compression method that hasn't been implemented yet.</p>
     * @since Apache Commons Compress 1.1
     */

#Code:
    public boolean canWriteEntryData(ArchiveEntry ae) {
        if (ae instanceof ZipArchiveEntry) {
            return ZipUtil.canHandleEntryData((ZipArchiveEntry) ae);
        }
        return false;
    }

#end
#end
#No. 189426
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Writes bytes to ZIP entry.
     * @param b the byte array to write
     * @param offset the start position to write from
     * @param length the number of bytes to write
     * @throws IOException on error
     */

#Code:
    public void write(byte[] b, int offset, int length) throws IOException {
        ZipUtil.checkRequestedFeatures(entry);
        if (entry.getMethod() == DEFLATED) {
            if (length > 0 && !def.finished()) {
                if (length <= DEFLATER_BLOCK_SIZE) {
                    def.setInput(b, offset, length);
                    deflateUntilInputIsNeeded();
                } else {
                    final int fullblocks = length / DEFLATER_BLOCK_SIZE;
                    for (int i = 0; i < fullblocks; i++) {
                        def.setInput(b, offset + i * DEFLATER_BLOCK_SIZE,
                                     DEFLATER_BLOCK_SIZE);
                        deflateUntilInputIsNeeded();
                    }
                    final int done = fullblocks * DEFLATER_BLOCK_SIZE;
                    if (done < length) {
                        def.setInput(b, offset + done, length - done);
                        deflateUntilInputIsNeeded();
                    }
                }
            }
        } else {
            writeOut(b, offset, length);
            written += length;
        }
        crc.update(b, offset, length);
        count(length);
    }

#end
#end
#No. 189427
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Closes this output stream and releases any system resources
     * associated with the stream.
     *
     * @exception  IOException  if an I/O error occurs.
     */

#Code:
    public void close() throws IOException {
        if (!finished) {
            finish();
        }

        if (raf != null) {
            raf.close();
        }
        if (out != null) {
            out.close();
        }
    }

#end
#end
#No. 189428
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out to the stream.
     *
     * @exception  IOException  if an I/O error occurs.
     */

#Code:
    public void flush() throws IOException {
        if (out != null) {
            out.flush();
        }
    }


#end
#end
#No. 189430
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Writes the data descriptor entry.
     * @param ze the entry to write
     * @throws IOException on error
     */

#Code:
    protected void writeDataDescriptor(ZipArchiveEntry ze) throws IOException {
        if (ze.getMethod() != DEFLATED || raf != null) {
            return;
        }
        writeOut(DD_SIG);
        writeOut(ZipLong.getBytes(entry.getCrc()));
        writeOut(ZipLong.getBytes(entry.getCompressedSize()));
        writeOut(ZipLong.getBytes(entry.getSize()));
        // CheckStyle:MagicNumber OFF
        written += 16;
        // CheckStyle:MagicNumber ON
    }

#end
#end
#No. 189431
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Writes the &quot;End of central dir record&quot;.
     * @throws IOException on error
     */

#Code:
    protected void writeCentralDirectoryEnd() throws IOException {
        writeOut(EOCD_SIG);

        // disk numbers
        writeOut(ZERO);
        writeOut(ZERO);

        // number of entries
        byte[] num = ZipShort.getBytes(entries.size());
        writeOut(num);
        writeOut(num);

        // length and location of CD
        writeOut(ZipLong.getBytes(cdLength));
        writeOut(ZipLong.getBytes(cdOffset));

        // ZIP file comment
        ByteBuffer data = this.zipEncoding.encode(comment);
        writeOut(ZipShort.getBytes(data.limit()));
        writeOut(data.array(), data.arrayOffset(), data.limit());
    }

#end
#end
#No. 189432
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Write bytes to output or random access file.
     * @param data the byte array to write
     * @throws IOException on error
     */

#Code:
    protected final void writeOut(byte[] data) throws IOException {
        writeOut(data, 0, data.length);
    }

#end
#end
#No. 189433
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Write bytes to output or random access file.
     * @param data the byte array to write
     * @param offset the start position to write from
     * @param length the number of bytes to write
     * @throws IOException on error
     */

#Code:
    protected final void writeOut(byte[] data, int offset, int length)
        throws IOException {
        if (raf != null) {
            raf.write(data, offset, length);
        } else {
            out.write(data, offset, length);
        }
    }

#end
#end
#No. 189434
#File: E:\bishe\1\ZipArchiveOutputStream.java
#Comment:
    /**
     * Creates a new zip entry taking some information from the given
     * file and using the provided name.
     *
     * <p>The name will be adjusted to end with a forward slash "/" if
     * the file is a directory.  If the file is not a directory a
     * potential trailing forward slash will be stripped from the
     * entry name.</p>
     *
     * <p>Must not be used if the stream has already been closed.</p>
     */

#Code:
    public ArchiveEntry createArchiveEntry(File inputFile, String entryName)
            throws IOException {
        if (finished) {
            throw new IOException("Stream has already been finished");
        }
        return new ZipArchiveEntry(inputFile, entryName);
    }


#end
#end
#No. 189438
#File: E:\bishe\1\ZipExampleActivity.java
#Comment:
    /*
    * Here we are getting two user list
    * One, the list of cricket fans
    * Another one, the list of football fans
    * Then we are finding the list of users who loves both
    */

#Code:
    private void doSomeWork() {
        Observable.zip(getCricketFansObservable(), getFootballFansObservable(),
                new BiFunction<List<User>, List<User>, List<User>>() {
                    @Override
                    public List<User> apply(List<User> cricketFans, List<User> footballFans) throws Exception {
                        return Utils.filterUserWhoLovesBoth(cricketFans, footballFans);
                    }
                })
                // Run on a background thread
                .subscribeOn(Schedulers.io())
                // Be notified on the main thread
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(getObserver());
    }

#end
#end
#No. 189439
#File: E:\bishe\1\ZipException.java
#Comment:
/**
 * Signals that a Zip exception of some sort has occurred.
 *
 * @author  unascribed
 * @see     java.io.IOException
 * @since   JDK1.0
 */

#Code:

public
class ZipException extends IOException {
    private static final long serialVersionUID = 8000196834066748623L;

    /**
     * Constructs a <code>ZipException</code> with <code>null</code>
     * as its error detail message.
     */
    public ZipException() {
        super();
    }

    /**
     * Constructs a <code>ZipException</code> with the specified detail
     * message.
     *
     * @param   s   the detail message.
     */

    public ZipException(String s) {
        super(s);
    }
}

#end
#end
#No. 189440
#File: E:\bishe\1\ZipFileIndexCache.java
#Comment:
    /**
     * Returns a list of all ZipFileIndex entries
     *
     * @return A list of ZipFileIndex entries, or an empty list
     */

#Code:
    public List<ZipFileIndex> getZipFileIndexes() {
        return getZipFileIndexes(false);
    }

#end
#end
#No. 189441
#File: E:\bishe\1\ZipFileIndexCache.java
#Comment:
    /**
     * Returns a list of all ZipFileIndex entries
     *
     * @param openedOnly If true it returns a list of only opened ZipFileIndex entries, otherwise
     *                   all ZipFileEntry(s) are included into the list.
     * @return A list of ZipFileIndex entries, or an empty list
     */

#Code:
    public synchronized List<ZipFileIndex> getZipFileIndexes(boolean openedOnly) {
        List<ZipFileIndex> zipFileIndexes = new ArrayList<ZipFileIndex>();

        zipFileIndexes.addAll(map.values());

        if (openedOnly) {
            for(ZipFileIndex elem : zipFileIndexes) {
                if (!elem.isOpen()) {
                    zipFileIndexes.remove(elem);
                }
            }
        }

        return zipFileIndexes;
    }

#end
#end
#No. 189442
#File: E:\bishe\1\ZipFileIndexCache.java
#Comment:
    /** Sets already opened list of ZipFileIndexes from an outside client
      * of the compiler. This functionality should be used in a non-batch clients of the compiler.
      */

#Code:
    public synchronized void setOpenedIndexes(List<ZipFileIndex>indexes) throws IllegalStateException {
        if (map.isEmpty()) {
            String msg =
                    "Setting opened indexes should be called only when the ZipFileCache is empty. "
                    + "Call JavacFileManager.flush() before calling this method.";
            throw new IllegalStateException(msg);
        }

        for (ZipFileIndex zfi : indexes) {
            map.put(zfi.zipFile, zfi);
        }
    }

#end
#end
#No. 189443
#File: E:\bishe\1\ZipFileInputFormat.java
#Comment:
/**
 * Extends the basic FileInputFormat class provided by Apache Hadoop to accept ZIP files. It should be noted that ZIP
 * files are not 'splittable' and each ZIP file will be processed by a single Mapper.
 */

#Code:
public class ZipFileInputFormat
    extends FileInputFormat<Text, BytesWritable>
{
    /** See the comments on the setLenient() method */
    private static boolean isLenient = false;
    
    /**
     * ZIP files are not splitable
     */
    @Override
    protected boolean isSplitable( JobContext context, Path filename )
    {
        return false;
    }

    /**
     * Create the ZipFileRecordReader to parse the file
     */
    @Override
    public RecordReader<Text, BytesWritable> createRecordReader( InputSplit split, TaskAttemptContext context )
        throws IOException, InterruptedException
    {
        return new ZipFileRecordReader();
    }
    
    /**
     * 
     * @param lenient
     */
    public static void setLenient( boolean lenient )
    {
        isLenient = lenient;
    }
    
    public static boolean getLenient()
    {
        return isLenient;
    }
}

#end
#end
#No. 189444
#File: E:\bishe\1\ZipFiles.java
#Comment:
  /**
   * Checks that the given entry name is legal for unzipping: if it contains
   * ".." as a name element, it could cause the entry to be unzipped outside
   * the directory we're unzipping to.
   *
   * @throws IOException if the name is illegal
   */

#Code:
  private static void checkName(String name) throws IOException {
    // First just check whether the entry name string contains "..".
    // This should weed out the the vast majority of entries, which will not
    // contain "..".
    if (name.contains("..")) {
      // If the string does contain "..", break it down into its actual name
      // elements to ensure it actually contains ".." as a name, not just a
      // name like "foo..bar" or even "foo..", which should be fine.
      File file = new File(name);
      while (file != null) {
        if (file.getName().equals("..")) {
          throw new IOException("Cannot unzip file containing an entry with "
              + "\"..\" in the name: " + name);
        }
        file = file.getParentFile();
      }
    }
  }

#end
#end
#No. 189445
#File: E:\bishe\1\ZipFiles.java
#Comment:
  /**
   * Zips an entire directory specified by the path.
   *
   * @param sourceDirectory the directory to read from. This directory and all
   *     subdirectories will be added to the zip-file. The path within the zip
   *     file is relative to the directory given as parameter, not absolute.
   * @param zipFile the zip-file to write to.
   * @throws IOException the zipping failed, e.g. because the input was not
   *     readable.
   */

#Code:
  static void zipDirectory(
      File sourceDirectory,
      File zipFile) throws IOException {
    checkNotNull(sourceDirectory);
    checkNotNull(zipFile);
    checkArgument(
        sourceDirectory.isDirectory(),
        "%s is not a valid directory",
        sourceDirectory.getAbsolutePath());
    checkArgument(
        !zipFile.exists(),
        "%s does already exist, files are not being overwritten",
        zipFile.getAbsolutePath());
    Closer closer = Closer.create();
    try {
      OutputStream outputStream = closer.register(new BufferedOutputStream(
          new FileOutputStream(zipFile)));
      zipDirectory(sourceDirectory, outputStream);
    } catch (Throwable t) {
      throw closer.rethrow(t);
    } finally {
      closer.close();
    }
  }

#end
#end
#No. 189446
#File: E:\bishe\1\ZipFiles.java
#Comment:
  /**
   * Zips an entire directory specified by the path.
   *
   * @param sourceDirectory the directory to read from. This directory and all
   *     subdirectories will be added to the zip-file. The path within the zip
   *     file is relative to the directory given as parameter, not absolute.
   * @param outputStream the stream to write the zip-file to. This method does not close
   *     outputStream.
   * @throws IOException the zipping failed, e.g. because the input was not
   *     readable.
   */

#Code:
  static void zipDirectory(
      File sourceDirectory,
      OutputStream outputStream) throws IOException {
    checkNotNull(sourceDirectory);
    checkNotNull(outputStream);
    checkArgument(
        sourceDirectory.isDirectory(),
        "%s is not a valid directory",
        sourceDirectory.getAbsolutePath());
    ZipOutputStream zos = new ZipOutputStream(outputStream);
    for (File file : sourceDirectory.listFiles()) {
      zipDirectoryInternal(file, "", zos);
    }
    zos.finish();
  }

#end
#end
#No. 189447
#File: E:\bishe\1\ZipFiles.java
#Comment:
  /**
   * Private helper function for zipping files. This one goes recursively
   * through the input directory and all of its subdirectories and adds the
   * single zip entries.
   *
   * @param inputFile the file or directory to be added to the zip file
   * @param directoryName the string-representation of the parent directory
   *     name. Might be an empty name, or a name containing multiple directory
   *     names separated by "/". The directory name must be a valid name
   *     according to the file system limitations. The directory name should be
   *     empty or should end in "/".
   * @param zos the zipstream to write to
   * @throws IOException the zipping failed, e.g. because the output was not
   *     writeable.
   */

#Code:
  private static void zipDirectoryInternal(
      File inputFile,
      String directoryName,
      ZipOutputStream zos) throws IOException {
    String entryName = directoryName + inputFile.getName();
    if (inputFile.isDirectory()) {
      entryName += "/";

      // We are hitting a sub-directory. Recursively add children to zip in deterministic,
      // sorted order.
      File[] childFiles = inputFile.listFiles();
      if (childFiles.length > 0) {
        Arrays.sort(childFiles);
        // loop through the directory content, and zip the files
        for (File file : childFiles) {
          zipDirectoryInternal(file, entryName, zos);
        }

        // Since this directory has children, exit now without creating a zipentry specific to
        // this directory. The entry for a non-entry directory is incompatible with certain
        // implementations of unzip.
        return;
      }
    }

    // Put the zip-entry for this file or empty directory into the zipoutputstream.
    ZipEntry entry = new ZipEntry(entryName);
    entry.setTime(inputFile.lastModified());
    zos.putNextEntry(entry);

    // Copy file contents into zipoutput stream.
    if (inputFile.isFile()) {
      Files.asByteSource(inputFile).copyTo(zos);
    }
  }

#end
#end
#No. 189451
#File: E:\bishe\1\ZipHelper.java
#Comment:
	/**
	 * Retrieve the zip entry of the core properties part.
	 *
	 * @throws OpenXML4JException
	 *             Throws if internal error occurs.
	 */

#Code:
	public static ZipEntry getCorePropertiesZipEntry(ZipPackage pkg) {
		PackageRelationship corePropsRel = pkg.getRelationshipsByType(
				PackageRelationshipTypes.CORE_PROPERTIES).getRelationship(0);

		if (corePropsRel == null)
			return null;

		return new ZipEntry(corePropsRel.getTargetURI().getPath());
	}

#end
#end
#No. 189452
#File: E:\bishe\1\ZipHelper.java
#Comment:
	/**
	 * Retrieve the Zip entry of the content types part.
	 */

#Code:
	public static ZipEntry getContentTypeZipEntry(ZipPackage pkg) {
		Enumeration entries = pkg.getZipArchive().getEntries();
		// Enumerate through the Zip entries until we find the one named
		// '[Content_Types].xml'.
		while (entries.hasMoreElements()) {
			ZipEntry entry = (ZipEntry) entries.nextElement();
			if (entry.getName().equals(
					ContentTypeManager.CONTENT_TYPES_PART_NAME))
				return entry;
		}
		return null;
	}

#end
#end
#No. 189453
#File: E:\bishe\1\ZipHelper.java
#Comment:
	/**
	 * Convert a zip name into an OPC name by adding a leading forward slash to
	 * the specified item name.
	 *
	 * @param zipItemName
	 *            Zip item name to convert.
	 * @return An OPC compliant name.
	 */

#Code:
	public static String getOPCNameFromZipItemName(String zipItemName) {
		if (zipItemName == null)
			throw new IllegalArgumentException("zipItemName");
		if (zipItemName.startsWith(FORWARD_SLASH)) {
			return zipItemName;
		}
		return FORWARD_SLASH + zipItemName;
	}

#end
#end
#No. 189454
#File: E:\bishe\1\ZipHelper.java
#Comment:
	/**
	 * Convert an OPC item name into a zip item name by removing any leading
	 * forward slash if it exist.
	 *
	 * @param opcItemName
	 *            The OPC item name to convert.
	 * @return A zip item name without any leading slashes.
	 */

#Code:
	public static String getZipItemNameFromOPCName(String opcItemName) {
		if (opcItemName == null)
			throw new IllegalArgumentException("opcItemName");

		String retVal = opcItemName;
		while (retVal.startsWith(FORWARD_SLASH))
			retVal = retVal.substring(1);
		return retVal;
	}

#end
#end
#No. 189455
#File: E:\bishe\1\ZipHelper.java
#Comment:
	/**
	 * Convert an OPC item name into a zip URI by removing any leading forward
	 * slash if it exist.
	 *
	 * @param opcItemName
	 *            The OPC item name to convert.
	 * @return A zip URI without any leading slashes.
	 */

#Code:
	public static URI getZipURIFromOPCName(String opcItemName) {
		if (opcItemName == null)
			throw new IllegalArgumentException("opcItemName");

		String retVal = opcItemName;
		while (retVal.startsWith(FORWARD_SLASH))
			retVal = retVal.substring(1);
		try {
			return new URI(retVal);
		} catch (URISyntaxException e) {
			return null;
		}
	}

#end
#end
#No. 189456
#File: E:\bishe\1\ZipHelper.java
#Comment:
	/**
	 * Retrieve and open a zip file with the specified path.
	 *
	 * @param path
	 *            The file path.
	 * @return The zip archive freshly open.
	 */

#Code:
	public static ZipFile openZipFile(String path) {
		File f = new File(path);
		try {
			if (!f.exists()) {
				return null;
			}
			return new ZipFile(f);
		} catch (IOException ioe) {
			return null;
		}
	}

#end
#end
#No. 189457
#File: E:\bishe\1\ZipImporterPagePresenter.java
#Comment:
    /**
     * Validate url
     *
     * @param url
     *         url for validate
     * @return <code>true</code> if url is correct
     */

#Code:
    private boolean isUrlCorrect(@Nonnull String url) {
        if (!END_URL.test(url)) {
            view.showUrlError(locale.importProjectMessageUrlInvalid());
            return false;
        }



#end
#end
#No. 189459
#File: E:\bishe\1\ZipInput.java
#Comment:
    /** Returns the names of immediate children in the directory with the given name.
     *  The path value must end with a "/" character.  Use a value of "/" 
     *  to get the root entries.
     */

#Code:
    public Collection<String> list(String path) 
    {
        if (!path.endsWith("/")) throw new IllegalArgumentException("Invalid path -- does not end with '/'");
        
        if (path.startsWith("/")) path = path.substring(1);
       
        Pattern p = Pattern.compile( String.format("^%s([^/]+/?).*", path));
        
        Set<String> names = new TreeSet<String>();
        
        for (String name : zioEntries.keySet()) {
            Matcher m = p.matcher(name);
            if (m.matches()) names.add(m.group(1));
        }
        return names;
    }

#end
#end
#No. 189460
#File: E:\bishe\1\ZipInput.java
#Comment:
    /** Scan the end of the file for the end of central directory record (EOCDR).
        Returns the file offset of the EOCD signature.  The size parameter is an
        initial buffer size (e.g., 256).
     */

#Code:
    public long scanForEOCDR( int size) throws IOException {
        if (size > fileLength || size > 65536) throw new IllegalStateException( "End of central directory not found in " + inputFilename);

        int scanSize = (int)Math.min( fileLength, size);

        byte[] scanBuf = new byte[scanSize];

        in.seek( fileLength - scanSize);

        in.readFully( scanBuf);

        for (int i = scanSize - 22; i >= 0; i--) {
            scanIterations += 1;
            if (scanBuf[i] == 0x50 && scanBuf[i+1] == 0x4b && scanBuf[i+2] == 0x05 && scanBuf[i+3] == 0x06) {
                return fileLength - scanSize + i;
            }
        }

        return scanForEOCDR( size * 2);
    }



#end
#end
#No. 189463
#File: E:\bishe\1\ZipManager.java
#Comment:
    /**
     *
     * @param file
     */

#Code:
    public static boolean deleteFile(File file) {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; i++) {
                deleteFile(files[i]);
            }
        }
        //file.delete();
        return delFileInternal(file);
    }



#end
#end
#No. 189466
#File: E:\bishe\1\ZipNumAllOutputFormat.java
#Comment:
	/**
	 * Get the path and filename for the output format.
	 * 
	 * @param context
	 *            the task context
	 * @param extension
	 *            an extension to add to the filename
	 * @return a full path $output/_temporary/$taskid/part-[mr]-$id
	 * @throws IOException
	 */

#Code:
	public Path getWorkFile(TaskAttemptContext context, String partWithExt)
			throws IOException {
		FileOutputCommitter committer = (FileOutputCommitter) getOutputCommitter(context);
				return new Path(committer.getWorkPath(), partWithExt);
	}

#end
#end
#No. 189467
#File: E:\bishe\1\ZipNumAllShardRecordWriter.java
#Comment:
	/**
	 * @return the delim
	 */

#Code:
	public int getDelim() {
		return delim;
	}

#end
#end
#No. 189468
#File: E:\bishe\1\ZipNumAllShardRecordWriter.java
#Comment:
	/**
	 * @param delim the delim to set
	 */

#Code:
	public void setDelim(char delim) {
		this.delim = delim;
	}

#end
#end
#No. 189469
#File: E:\bishe\1\ZipNumRecordWriterOld.java
#Comment:
	/**
	 * @return the delim
	 */

#Code:
	public int getDelim() {
		return delim;
	}

#end
#end
#No. 189470
#File: E:\bishe\1\ZipNumRecordWriterOld.java
#Comment:
	/**
	 * @param delim the delim to set
	 */

#Code:
	public void setDelim(int delim) {
		this.delim = delim;
	}

#end
#end
#No. 189471
#File: E:\bishe\1\ZipParameters.java
#Comment:
	/**
	 * Sets the password for the zip file or the file being added<br>
	 * <b>Note</b>: For security reasons, usage of this method is discouraged. Use 
	 * setPassword(char[]) instead. As strings are immutable, they cannot be wiped
	 * out from memory explicitly after usage. Therefore, usage of Strings to store 
	 * passwords is discouraged. More info here: 
	 * http://docs.oracle.com/javase/1.5.0/docs/guide/security/jce/JCERefGuide.html#PBEEx
	 * @param password
	 */

#Code:
	public void setPassword(String password) {
		if (password == null) return;
		setPassword(password.toCharArray());
	}

#end
#end
#No. 189472
#File: E:\bishe\1\ZipPathEntry.java
#Comment:
    /* 
       The url for a zip-file resource is,
	   
       <code>file:///path/file.zip#name</code>
	   
       Then, it is URLConnection's problem to handle that.
    */

#Code:

    URL getURL (String f) {

	ZipEntry ent = zip.getEntry (f);

	try {
	    if (ent != null)
		return new URL (file, "#"+f);
	    else
		return null;
	} catch (IOException x) {
	    return null;
	}
    }

#end
#end
#No. 189473
#File: E:\bishe\1\Zipper.java
#Comment:
    /**
     * Adds the contents of the given source directory to the zip, by accepting only directories and files accepted by the
     * given predicates.
     *
     * @param sourceDirectory          the source directory
     * @param directoryPredicate       the predicate used to accept directories
     * @param filePredicate            the predicate used to accept files
     * @param destinationDirectoryName the name of the target directory, in the zip, where all the files must be added.
     * @throws IOException
     */

#Code:
    public void addDirectoryToZip(final Path sourceDirectory,
                                  final PathPredicate directoryPredicate,
                                  final FilePredicate filePredicate,
                                  final String destinationDirectoryName) throws IOException {

        walkFileTree(sourceDirectory, new SimpleFileVisitor<Path>() {

            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                if (!directoryPredicate.accept(dir)) {
                    return FileVisitResult.SKIP_SUBTREE;
                }
                return super.preVisitDirectory(dir, attrs);
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                if (filePredicate.accept(file.toFile())) {
                    addToZip(file, normalizeZipEntryName(get(destinationDirectoryName).resolve(sourceDirectory.relativize(file))));
                }
                return FileVisitResult.CONTINUE;
            }

        });
    }

#end
#end
#No. 189474
#File: E:\bishe\1\ZipResourceFile.java
#Comment:
    /**
     * getAssetFileDescriptor allows for ZipResourceFile to directly feed
     * Android API's that want an fd, offset, and length such as the
     * MediaPlayer. It also allows for the class to be used in a content
     * provider that can feed video players. The file must be stored
     * (non-compressed) in the Zip file for this to work.
     * 
     * @param assetPath
     * @return the asset file descriptor for the file, or null if the file isn't
     *         present or is stored compressed
     */

#Code:
    public AssetFileDescriptor getAssetFileDescriptor(String assetPath) {
        ZipEntryRO entry = mHashMap.get(assetPath);
        if (null != entry) {
            return entry.getAssetFileDescriptor();
        }
        return null;
    }

#end
#end
#No. 189475
#File: E:\bishe\1\ZipResourceFile.java
#Comment:
    /**
     * getInputStream returns an AssetFileDescriptor.AutoCloseInputStream
     * associated with the asset that is contained in the Zip file, or a
     * standard ZipInputStream if necessary to uncompress the file
     * 
     * @param assetPath
     * @return an input stream for the named asset path, or null if not found
     * @throws IOException
     */

#Code:
    public InputStream getInputStream(String assetPath) throws IOException {
        ZipEntryRO entry = mHashMap.get(assetPath);
        if (null != entry) {
            if (entry.isUncompressed()) {
                return entry.getAssetFileDescriptor().createInputStream();
            } else {
                ZipFile zf = mZipFiles.get(entry.getZipFile());
                /** read compressed files **/
                if (null == zf) {
                    zf = new ZipFile(entry.getZipFile(), ZipFile.OPEN_READ);
                    mZipFiles.put(entry.getZipFile(), zf);
                }
                ZipEntry zi = zf.getEntry(assetPath);
                if (null != zi)
                    return zf.getInputStream(zi);
            }
        }
        return null;
    }


#end
#end
#No. 189477
#File: E:\bishe\1\ZKChildListener.java
#Comment:
  /**
   * Will be called when there is child added/deleted.
   *
   * @param parentPath the parent ZK node path;
   * @param currentChildren the node name list of current children.
   */

#Code:
  void onChanged(String parentPath, List<String> currentChildren);
}
}

#end
#end
#No. 189478
#File: E:\bishe\1\ZKChildMonitor.java
#Comment:
  /**
   * Get ZKChildMonitor instance
   *
   * @param clusterId FileCache Cluster Id
   * @param partitionId FileCache partition Id
   * @return ZKChildMonitor instance
   */

#Code:
  public static ZKChildMonitor getInstance(short clusterId, short partitionId) {
    if (instance == null) {
      synchronized (ZKChildMonitor.class) {
        if (instance == null) {
          instance = new ZKChildMonitor(clusterId, partitionId);
          LOGGER.info("init ZkChildMonitor with clusterId[{}]", clusterId);
        }
      }
    } else {
      Validate.isTrue(clusterId == instance.clusterId && partitionId == instance.partitionId,
          String.format("ZkChildMonitor initialized with id[%d], reject id[%d]", instance.clusterId, clusterId));
    }
    return instance;
  }




#end
#end
#No. 189482
#File: E:\bishe\1\ZKClusteredWideMapTest.java
#Comment:
  /**
   * As zookeeper cluster manager using distribution lock, so there is some cost
   * on checking kv in application layer.
   * I have increase delay time that checking value is exist in map.
   * 30ms is ok in my laptop.
   */

#Code:
  @Override
  @Test
  public void testMapPutTtl() {
    getVertx().sharedData().<String, String>getClusterWideMap("foo", onSuccess(map -> {
      map.put("pipo", "molo", 150, onSuccess(vd -> {
        vertx.setTimer(300, l -> {
          getVertx().sharedData().<String, String>getClusterWideMap("foo", onSuccess(map2 -> {
            map2.get("pipo", onSuccess(res -> {
              assertNull(res);
              testComplete();
            }));
          }));
        });
      }));
    }));
    await();
  }

#end
#end
#No. 189483
#File: E:\bishe\1\ZkConnection.java
#Comment:
    /**
     * build a zookeeper connection
     * @param zkServers      zookeeper connection string
     * @param sessionTimeOut session timeout in milliseconds
     */

#Code:
    public ZkConnection(String zkServers, int sessionTimeOut, String authStr) {
        _servers = zkServers;
        _sessionTimeOut = sessionTimeOut;
        _authStr = authStr;
    }

#end
#end
#No. 189484
#File: E:\bishe\1\ZkConnection.java
#Comment:
    /*public String create(String path, byte[] data, CreateMode mode) throws KeeperException, InterruptedException {
        return _zk.create(path, data, Ids.OPEN_ACL_UNSAFE, mode);
    }*/

#Code:

    public void delete(String path) throws InterruptedException, KeeperException {
        _zk.delete(path, -1);
    }



#end
#end
#No. 189490
#File: E:\bishe\1\ZkDeployValidator.java
#Comment:
    /**
     * @param zkDeployForm
     *
     * @return
     */

#Code:
    public ConfigFullModel verify(ZkDeployForm zkDeployForm) {

        //
        // app
        //
        if (zkDeployForm.getAppId() == null) {
            throw new FieldException("app is empty", null);
        }

        App app = appMgr.getById(zkDeployForm.getAppId());
        if (app == null) {
            throw new FieldException("app " + zkDeployForm.getAppId() + " doesn't exist in db.", null);
        }

        //
        // env
        //
        if (zkDeployForm.getEnvId() == null) {
            throw new FieldException("app is empty", null);
        }

        Env env = envMgr.getById(zkDeployForm.getEnvId());
        if (env == null) {
            throw new FieldException("env " + zkDeployForm.getEnvId() + " doesn't exist in db.", null);
        }

        //
        // version
        //
        if (StringUtils.isEmpty(zkDeployForm.getVersion())) {
            throw new FieldException("version is empty", null);
        }

        return new ConfigFullModel(app, env, zkDeployForm.getVersion(), "");
    }

#end
#end
#No. 189494
#File: E:\bishe\1\ZkLock.java
#Comment:
    /**
     * This condition will be signaled if a zookeeper event was processed and the event contains a data/child change.
     *
     * @return the condition.
     */

#Code:
    public Condition getDataChangedCondition() {
        return _dataChangedCondition;
    }

#end
#end
#No. 189495
#File: E:\bishe\1\ZkLock.java
#Comment:
    /**
     * This condition will be signaled if a zookeeper event was processed and the event contains a state change
     * (connected, disconnected, session expired, etc ...).
     *
     * @return the condition.
     */

#Code:
    public Condition getStateChangedCondition() {
        return _stateChangedCondition;
    }

#end
#end
#No. 189496
#File: E:\bishe\1\ZkLock.java
#Comment:
    /**
     * This condition will be signaled if any znode related zookeeper event was received.
     *
     * @return the condition.
     */

#Code:
    public Condition getZNodeEventCondition() {
        return _zNodeEventCondition;
    }

#end
#end
#No. 189497
#File: E:\bishe\1\ZkLockNode.java
#Comment:
	/**
	 * Retries the lock node id from a full lock node name path (the path after addition of sequence number).
	 * 
	 * @param path						The name path to retrieve the id from
	 * @return							The lock node id
	 */

#Code:
	static String getLockNodeIdFromName(String lockNodeName) {
		int lastPathSep = lockNodeName.lastIndexOf("/");
		if (lastPathSep != -1)
			return lockNodeName.substring(lastPathSep+1);
		else
			return lockNodeName;
	}

#end
#end
#No. 189498
#File: E:\bishe\1\ZkLockNode.java
#Comment:
	/**
	 * Construct a lock node from a lock id. This can then be used in lock wait algorithms.
	 * 
	 * @param lockId					The id of the lock node e.g. write-0000019
	 * @param lockIdSelf				The id of the lock performing the processing
	 * @return							A lock node wrapper object
	 */

#Code:
	static ZkLockNode lockNodeFromId(String lockId, String lockIdSelf) {
		
		ILock.LockType type;
		
		if (lockId.startsWith(ILock.LockType.Read.toString()))
			type = ILock.LockType.Read;
		else if (lockId.startsWith(ILock.LockType.Write.toString()))
			type = ILock.LockType.Write;
		else
			return null; // not lock node
		
		int seqNo;
		int sepIdx = lockId.lastIndexOf("-");
		if (sepIdx == -1)
			return null; // not lock node
		
		try {
			seqNo = Integer.parseInt(lockId.substring(sepIdx + 1));
		} catch (Exception ex) {
			return null; // not lock node
		}
		
		return new ZkLockNode(lockId, type, seqNo, lockId.equals(lockIdSelf));
	}



#end
#end
#No. 189500
#File: E:\bishe\1\ZKMap.java
#Comment:
  /**
   * get data with Stat
   *
   * @param stat new Stat
   * @param path node path
   * @param <T>  result
   * @return T
   * @throws Exception
   */

#Code:
  <T> T getData(Stat stat, String path) throws Exception {
    T result = null;
    if (null != curator.checkExists().forPath(path)) {
      result = asObject(curator.getData().storingStatIn(stat).forPath(path));
    } else {
      curator.create().creatingParentsIfNeeded().forPath(path, asByte(null));
    }
    return result;
  }


#end
#end
#No. 189502
#File: E:\bishe\1\ZKMetadataAccessor.java
#Comment:
    /**
     * Get the name of the stream managed by this log manager
     *
     * @return streamName
     */

#Code:
    @Override
    public String getStreamName() {
        return name;
    }

#end
#end
#No. 189503
#File: E:\bishe\1\ZKMetadataAccessor.java
#Comment:
    /**
     * Creates or update the metadata stored at the node associated with the
     * name and URI
     * @param metadata opaque metadata to be stored for the node
     * @throws IOException
     */

#Code:
    @Override
    public void createOrUpdateMetadata(byte[] metadata) throws IOException {
        checkClosedOrInError("createOrUpdateMetadata");

        String zkPath = getZKPath();
        LOG.debug("Setting application specific metadata on {}", zkPath);
        try {
            Stat currentStat = writerZKC.get().exists(zkPath, false);
            if (currentStat == null) {
                if (metadata.length > 0) {
                    Utils.zkCreateFullPathOptimistic(writerZKC,
                            zkPath,
                            metadata,
                            writerZKC.getDefaultACL(),
                            CreateMode.PERSISTENT);
                }
            } else {
                writerZKC.get().setData(zkPath, metadata, currentStat.getVersion());
            }
        } catch (InterruptedException ie) {
            throw new DLInterruptedException("Interrupted on creating or updating container metadata", ie);
        } catch (Exception exc) {
            throw new IOException("Exception creating or updating container metadata", exc);
        }
    }

#end
#end
#No. 189504
#File: E:\bishe\1\ZKMetadataAccessor.java
#Comment:
    /**
     * Delete the metadata stored at the associated node. This only deletes the metadata
     * and not the node itself
     * @throws IOException
     */

#Code:
    @Override
    public void deleteMetadata() throws IOException {
        checkClosedOrInError("createOrUpdateMetadata");
        createOrUpdateMetadata(null);
    }

#end
#end
#No. 189505
#File: E:\bishe\1\ZKMetadataAccessor.java
#Comment:
    /**
     * Retrieve the metadata stored at the node
     * @return byte array containing the metadata
     * @throws IOException
     */

#Code:
    @Override
    public byte[] getMetadata() throws IOException {
        checkClosedOrInError("createOrUpdateMetadata");
        String zkPath = getZKPath();
        LOG.debug("Getting application specific metadata from {}", zkPath);
        try {
            Stat currentStat = readerZKC.get().exists(zkPath, false);
            if (currentStat == null) {
                return null;
            } else {
                return readerZKC.get().getData(zkPath, false, currentStat);
            }
        } catch (InterruptedException ie) {
            throw new DLInterruptedException("Error reading the max tx id from zk", ie);
        } catch (Exception e) {
            throw new IOException("Error reading the max tx id from zk", e);
        }
    }

#end
#end
#No. 189506
#File: E:\bishe\1\ZKMetadataAccessor.java
#Comment:
    /**
     * Close the metadata accessor, freeing any resources it may hold.
     * @return future represents the close result.
     */

#Code:
    @Override
    public Future<Void> asyncClose() {
        Promise<Void> closeFuture;
        synchronized (this) {
            if (null != closePromise) {
                return closePromise;
            }
            closeFuture = closePromise = new Promise<Void>();
        }
        // NOTE: ownWriterZKC and ownReaderZKC are mostly used by tests
        //       the managers created by the namespace - whose zkc will be closed by namespace
        try {
            if (ownWriterZKC) {
                writerZKC.close();
            }
            if (ownReaderZKC) {
                readerZKC.close();
            }
        } catch (Exception e) {
            LOG.warn("Exception while closing distributed log manager", e);
        }
        FutureUtils.setValue(closeFuture, null);
        return closeFuture;
    }

#end
#end
#No. 189508
#File: E:\bishe\1\ZkMultLoader.java
#Comment:
    /**
     * get data from zookeeper and convert to string with check not null.
     */

#Code:
    protected String getDataToString(String path) throws Exception {
        byte[] raw = curator.getData().forPath(path);

        checkNotNull(raw, "data of " + path + " must be not null!");
        return byteToString(raw);
    }

#end
#end
#No. 189509
#File: E:\bishe\1\ZkMultLoader.java
#Comment:
    /**
     * get child node name list based on path from zookeeper.
     * @throws Exception 
     */

#Code:
    protected List<String> getChildNames(String path) throws Exception {
        return curator.getChildren().forPath(path);
    }

#end
#end
#No. 189521
#File: E:\bishe\1\ZkSessionManager.java
#Comment:
	/**
	 * The ZooKeeper client is connected to the ZooKeeper cluster. Actions that modify cluster data may now be
	 * performed. Any primitives that were previously suspended after disconnection must be restarted, and any
	 * primitives that wished to be resurrected after session expiry, must be asked to resynchronize
	 */

#Code:
	private void onConnected() {
		// We need to process the resurrection list
		synchronized (retryMutex) {
			// We are going to process the existing lists. We take a copy of the lists and reset them to null to
			// avoid potential re-entrancy problems if the client becomes disconnected again while restarting the
			// waiting primitives thus causing them to try to re-add themselves to these lists.
			Set<ZkSyncPrimitive> resurrectList = currResurrectList;
			Set<ZkSyncPrimitive> restartOnConnectList = currRestartOnConnectList;
			currResurrectList = null;
			currRestartOnConnectList = null;
			// Process resurrection list...
			if (resurrectList != null) {
				logger.info("onConnected processing currResurrectList.size {}", resurrectList.size());
				for (ZkSyncPrimitive primitive : resurrectList) {
					primitive.zooKeeper = this.zooKeeper; // assign new client
					primitive.resynchronize();
				}
			}
			// Process restart on re-connection list
			if (restartOnConnectList != null)
				for (ZkSyncPrimitive primitive : restartOnConnectList) {
					Runnable restart = primitive.retryOnConnect;
					primitive.retryOnConnect = null; // this may be re-assigned by running if disconnect again
					restart.run();
				}
		}
		isConnected.set();
	}

#end
#end
#No. 189522
#File: E:\bishe\1\ZkSessionManager.java
#Comment:
	/**
	 * We have been disconnected from ZooKeeper. The client will try to reconnect automatically. However, even
	 * after a successful reconnect, we may miss node creation followed by node deletion event. Furthermore, we
	 * cannot be *sure* of situation on server while in this state, nor perform actions that require modifying
	 * the server state. This may require special handling so we notify our sync objects.
	 */

#Code:
	private void onDisconnection() {
		isConnected.reset();
	}

#end
#end
#No. 189523
#File: E:\bishe\1\ZkSessionManager.java
#Comment:
	/**
	 * The ZooKeeper session has expired. We need to initiate the creation of a new client session. Primitives
	 * that are currently suspended while waiting for re-connection must now be killed, except for the rare case
	 * where they can be resurrected when there is a new session.
	 */

#Code:
	private void onSessionExpired() {
		synchronized (retryMutex) {
			// Primitives waiting for reconnection before continuing their operations must now die, except for the
			// rare case they wish to be resurrected when there is a new session
			if (currRestartOnConnectList != null) {
				for (ZkSyncPrimitive primitive : currRestartOnConnectList)
					if (primitive.shouldResurrectAfterSessionExpiry())
						currResurrectList.add(primitive);
					else
						primitive.die(Code.SESSIONEXPIRED);
				// Clear the reconnect list now
				currRestartOnConnectList.clear();
			}
		}
		isConnected.reset();
		connectExecutor.submit(clientCreator);
	}


#end
#end
#No. 189525
#File: E:\bishe\1\ZKSubscriptionStateStore.java
#Comment:
    /**
     * Get the last committed position stored for this subscription
     */

#Code:
    @Override
    public Future<DLSN> getLastCommitPosition() {
        if (null != lastCommittedPosition.get()) {
            return Future.value(lastCommittedPosition.get());
        } else {
            return getLastCommitPositionFromZK();
        }
    }

#end
#end
#No. 189526
#File: E:\bishe\1\ZKSubscriptionStateStore.java
#Comment:
    /**
     * Advances the position associated with the subscriber
     *
     * @param newPosition - new commit position
     */

#Code:
    @Override
    public Future<BoxedUnit> advanceCommitPosition(DLSN newPosition) {
        if (null == lastCommittedPosition.get() ||
            (newPosition.compareTo(lastCommittedPosition.get()) > 0)) {
            lastCommittedPosition.set(newPosition);
            return Utils.zkAsyncCreateFullPathOptimisticAndSetData(zooKeeperClient,
                zkPath, newPosition.serialize().getBytes(Charsets.UTF_8),
                zooKeeperClient.getDefaultACL(),
                CreateMode.PERSISTENT);
        } else {
            return Future.Done();
        }
    }

#end
#end
#No. 189527
#File: E:\bishe\1\ZkSyncPrimitive.java
#Comment:
    /**
     * Wait until the primitive has reached a synchronized state. If the operation was successful,
     * this is triggered when a derived class calls <code>onStateChanged()</code> for the first time. If the
     * operation was unsuccessful, an exception is thrown.
     *
     * @throws KeeperException
     * @throws InterruptedException
     */

#Code:
	public void waitSynchronized() throws ZkCagesException, InterruptedException {
		isSynchronized.waitOne();

		if (getKillerException() == null)
			return;

		throw getKillerException();
	}

#end
#end
#No. 189528
#File: E:\bishe\1\ZkSyncPrimitive.java
#Comment:
    /**
     * Add a listener task to be executed when the object enters the synchronized state, and every time it updates its
     * state thereafter (as marked by derived classes calling <code>onStateUpdated()</code>).
     *
     * @param handler 					The listener task to execute when the state has changed. A weak reference is taken.
     * @param doStartupRun 				If the state of the primitive is already synchronized then run the handler immediately
     */

#Code:
    public void addUpdateListener(Runnable handler, boolean doStartupRun) {
    	synchronized (mutex) {
    		if (stateUpdateListeners == null) {
    			stateUpdateListeners = new ArrayList<Runnable>(8);
    		}
    		// Add to listener set first to avoid reentrancy race
    		stateUpdateListeners.add(handler);
    		// If we are already synchronized then trigger
    		if (doStartupRun && killedByException == null && isSynchronized.isSignalled()) {
    			handler.run();
    		}
    	}
    }

#end
#end
#No. 189529
#File: E:\bishe\1\ZkSyncPrimitive.java
#Comment:
    /**
     * Returns whether the synchronization primitive is still valid / alive.
     * @return 							Whether this primitive is alive and can be used
     */

#Code:
    public boolean isAlive() {
    	return killedByException != null;
    }

#end
#end
#No. 189530
#File: E:\bishe\1\ZkSyncPrimitive.java
#Comment:
    /**
     * If the primitive has been killed, returns the exception that has killed it.
     * @return							The exception that killed the primitive
     */

#Code:
    public ZkCagesException getKillerException() {
    	return killedByException;
    }



#end
#end
#No. 189532
#File: E:\bishe\1\ZKTools.java
#Comment:
  /**
   * BFS Traversal of the system under pathRoot, with the entries in the list,
   * in the same order as that of the traversal.
   * <p>
   * <b>Important:</b> This is <i>not an atomic snapshot</i> of the tree ever,
   * but the state as it exists across multiple RPCs from zkClient to the
   * ensemble. For practical purposes, it is suggested to bring the clients to
   * the ensemble down (i.e. prevent writes to pathRoot) to 'simulate' a
   * snapshot behavior.
   * 
   * @param zk
   * @param pathRoot
   *          The znode path, for which the entire subtree needs to be listed.
   * @throws Exception
   */

#Code:
  public static List<String> listSubTreeBFS(ZooKeeper zk, final String pathRoot) throws Exception {
    Deque<String> queue = new LinkedList<String>();
    List<String> tree = new ArrayList<String>();
    queue.add(pathRoot);
    tree.add(pathRoot);

    while (true) {
      String node = queue.pollFirst();
      if (node == null) {
        break;
      }

      List<String> children = zk.getChildren(node, false);
      for (final String child : children) {
        final String childPath = node + "/" + child;
        queue.add(childPath);
        tree.add(childPath);
      }
    }
    return tree;
  }


#end
#end
#No. 189537
#File: E:\bishe\1\ZkUtils.java
#Comment:
  /**
   * Make sure a persistent path exists in ZK. Create the path if it does not exist.
   */

#Code:
  public static void makeSurePersistentPathExists(ZkClient client, String path) {
    if (!client.exists(path)) {
      client.createPersistent(path, true); // won't throw NoNodeException or NodeExistsException
    }
  }

#end
#end
#No. 189538
#File: E:\bishe\1\ZkUtils.java
#Comment:
  /**
   * Create the parent path
   */

#Code:
  private static void createParentPath(ZkClient client, String path) {
    String parentDir = path.substring(0, path.lastIndexOf('/'));
    if (parentDir.length() != 0) {
      client.createPersistent(parentDir, true);
    }
  }

#end
#end
#No. 189539
#File: E:\bishe\1\ZkUtils.java
#Comment:
  /**
   * Create an persistent node with the given path and data. Create parent nodes if necessary.
   */

#Code:
  public static void createPersistentPath(ZkClient client, String path, String data) {
    try {
      client.createPersistent(path, data);
    } catch (ZkNoNodeException nne) {
      createParentPath(client, path);
      client.createPersistent(path, data);
    }
  }

#end
#end
#No. 189540
#File: E:\bishe\1\ZkUtils.java
#Comment:
  /**
   * Update the value of a persistent node with the given path and data. create parent directory if
   * necessary. Never throw NodeExistException. Return the updated path zkVersion
   */

#Code:
  public static void updatePersistentPath(ZkClient client, String path, String data) {
    try {
      client.writeData(path, data);
    } catch (ZkNoNodeException nne) {
      createParentPath(client, path);
      try {
        client.createPersistent(path, data);
      } catch (ZkNodeExistsException nee) {
        client.writeData(path, data);
      }
    }
  }

#end
#end
#No. 189541
#File: E:\bishe\1\ZkUtils.java
#Comment:
  /**
   * Conditional update the persistent path data, return (true, newVersion) if it succeeds,
   * otherwise (the path doesn't exist, the current version is not the expected version, etc.)
   * return (false, -1)
   *
   * When there is a ConnectionLossException during the conditional update, zkClient will retry the
   * update and may fail since the previous update may have succeeded (but the stored zkVersion no
   * longer matches the expected one). In this case, we will run the optionalChecker to further
   * check if the previous write did indeed succeeded.
   */

#Code:
  public static int conditionalUpdatePersistentPath(ZkClient client,
                                                    String path,
                                                    String data,
                                                    int expectedVersion,
                                                    ConditionalUpdateCallback customConditionCallback) {
    try {
      Stat stat = client.writeDataReturnStat(path, data, expectedVersion);
      log.debug(
          "Conditional update of path %s with value %s and expected version %d succeeded, returning the new version: %d"
              .format(path, data, expectedVersion, stat.getVersion()));
      return stat.getVersion();
    } catch (ZkBadVersionException bve) {
      if (customConditionCallback != null) {
        return customConditionCallback.checker(client, path, data);
      } else {
        log.warn(("Conditional update of path %s with data %s and expected version %d failed due to " 
                  + "%s. When there is a ConnectionLossException during the conditional update, " 
                  + "ZkClient will retry the update and may fail since the previous update may have " 
                  + "succeeded (but the stored zkVersion no longer matches the expected one). " 
                  + "In this case, the customConditionCallback is required to further check if the " 
                  + "previous write did indeed succeed, but was not passed in here.")
                     .format(path, data,
                             expectedVersion, bve.getMessage()));
        return -1;
      }
    } catch (Exception e) {
      log.warn("Conditional update of path %s with data %s and expected version %d failed due to %s"
                   .format(path, data,
                           expectedVersion, e.getMessage()));
      return -1;
    }
  }

#end
#end
#No. 189543
#File: E:\bishe\1\ZlibExpanderProvider.java
#Comment:
    /**
     * Create a provider which caps the number of expanded bytes that can be produced when the
     * compressed stream is parsed.
     *
     * @param limit max number of bytes allowed in an expanded stream.
     */

#Code:
    public ZlibExpanderProvider(long limit)
    {
        this.limit = limit;
    }



#end
#end
#No. 189545
#File: E:\bishe\1\ZlibWrapper.java
#Comment:
/**
 * The container file formats that wrap the stream compressed by the DEFLATE
 * algorithm.
 */

#Code:
public enum ZlibWrapper {
    /**
     * The ZLIB wrapper as specified in <a href="http://tools.ietf.org/html/rfc1950">RFC 1950</a>.
     */
    ZLIB,
    /**
     * The GZIP wrapper as specified in <a href="http://tools.ietf.org/html/rfc1950">RFC 1952</a>.
     */
    GZIP,
    /**
     * Raw DEFLATE stream only (no header and no footer).
     */
    NONE,
    /**
     * Try {@link #ZLIB} first and then {@link #NONE} if the first attempt fails.
     * Please note that you can specify this wrapper type only when decompressing.
     */
    ZLIB_OR_NONE
}


#end
#end
#No. 189558
#File: E:\bishe\1\ZMachine.java
#Comment:
	/**
	 * Store keyboard input into the keyboard buffer (will be processed on the
	 * next run()).
	 * 
	 * @param input
	 *          what the user entered. Note: this must either be a single byte or
	 *          a newline terminated string, depending on the runstate.
	 */

#Code:
	public void fillInputBuffer(char[] input) {
		inputBuffer = input;
		inputIndex = 0;
	}



#end
#end
#No. 189560
#File: E:\bishe\1\ZMachine.java
#Comment:
	/**
	 * Execute the Z-Program till it requests user input. Note: restart() must be
	 * called before this method is called the first time.
	 * 
	 * @return the reason (runstate) why execution stopped.
	 */

#Code:
	public int run() {
		try {
			if (runState != STATE_RUNNING && runState != STATE_INIT) {
				// Picking up from where we left last in the assumption that the user
				// has provided the requested information.
				runState = STATE_RUNNING;
				zi.execute();
			}
			while (true) {
				zi.decode_instruction();
				switch (zi.opnum) {
				// case ZInstruction5.OP_AREAD: // Its the same!
					case ZInstruction.OP_SREAD: {
						runState = STATE_WAIT_CMD;
						return runState;
					}
					case ZInstruction5.OP_READ_CHAR: {
						runState = STATE_WAIT_CHAR;
						return runState;
					}
					default: {
						runState = STATE_RUNNING;
						zi.execute();
					}
				}
			}
		}
		catch (ArrayIndexOutOfBoundsException booga) {
			System.err.print("pc = ");
			System.err.println(Integer.toString(pc, 16));
			fatal("Memory address corruption");
		}
		catch (ClassCastException booga) {
			System.err.print("pc = ");
			System.err.println(Integer.toString(pc, 16));
			fatal("Story corruption");
		}

		return STATE_RUNNING; // We actually never get here
	}

#end
#end
#No. 189561
#File: E:\bishe\1\ZMachine.java
#Comment:
	/**
	 * Query the filename of the quicksave slot (the one used by the save/restore
	 * opcode)
	 * @return absolute path name
	 */

#Code:
	public File getQuickSaveSlot() {
		return quickSaveSlot;
	}

#end
#end
#No. 189566
#File: E:\bishe\1\ZMQ.java
#Comment:
    /**
     * Create a new Context.
     *
     * @param ioThreads
     *            Number of threads to use, usually 1 is sufficient for most use cases.
     * @return the Context
     */

#Code:
    public static Context context(int ioThreads)
    {
        return new Context(ioThreads);
    }


#end
#end
#No. 189568
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Returns true if terminate() has been called on ctx.
         */

#Code:
        public boolean isTerminated()
        {
            return !ctx.checkTag();
        }

#end
#end
#No. 189569
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The size of the 0MQ thread pool to handle I/O operations.
         */

#Code:
        public int getIOThreads()
        {
            return ctx.get(zmq.ZMQ.ZMQ_IO_THREADS);
        }

#end
#end
#No. 189570
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Set the size of the 0MQ thread pool to handle I/O operations.
         */

#Code:
        public boolean setIOThreads(int ioThreads)
        {
            return ctx.set(zmq.ZMQ.ZMQ_IO_THREADS, ioThreads);
        }

#end
#end
#No. 189571
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The maximum number of sockets allowed on the context
         */

#Code:
        public int getMaxSockets()
        {
            return ctx.get(zmq.ZMQ.ZMQ_MAX_SOCKETS);
        }

#end
#end
#No. 189572
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the maximum number of sockets allowed on the context
         */

#Code:
        public boolean setMaxSockets(int maxSockets)
        {
            return ctx.set(zmq.ZMQ.ZMQ_MAX_SOCKETS, maxSockets);
        }

#end
#end
#No. 189573
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @deprecated use {@link #isBlocky()} instead
         */

#Code:
        @Deprecated
        public boolean getBlocky()
        {
            return isBlocky();
        }

#end
#end
#No. 189574
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * This is an explicit "destructor". It can be called to ensure the corresponding 0MQ
         * Context has been disposed of.
         */

#Code:
        public void term()
        {
            if (closed.compareAndSet(false, true)) {
                ctx.terminate();
            }
        }

#end
#end
#No. 189575
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Create a new Socket within this context.
         *
         * @param type
         *            the socket type.
         * @return the newly created Socket.
         */

#Code:
        public Socket socket(int type)
        {
            return new Socket(this, type);
        }

#end
#end
#No. 189576
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Create a new Selector within this context.
         *
         * @return the newly created Selector.
         */

#Code:
        public Selector selector()
        {
            return ctx.createSelector();
        }

#end
#end
#No. 189577
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Closes a Selector that was created within this context.
         *
         * @param selector the Selector to close.
         * @return true if the selector was closed. otherwise false
         * (mostly because it was not created by the context).
         */

#Code:
        public boolean close(Selector selector)
        {
            return ctx.closeSelector(selector);
        }

#end
#end
#No. 189578
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Create a new Poller within this context, with a default size.
         *
         * @return the newly created Poller.
         */

#Code:
        public Poller poller()
        {
            return new Poller(this);
        }

#end
#end
#No. 189579
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Create a new Poller within this context, with a specified initial size.
         *
         * @param size
         *            the poller initial size.
         * @return the newly created Poller.
         */

#Code:
        public Poller poller(int size)
        {
            return new Poller(this, size);
        }




#end
#end
#No. 189582
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * This is an explicit "destructor". It can be called to ensure the corresponding 0MQ Socket
         * has been disposed of.
         */

#Code:
        @Override
        public void close()
        {
            if (isClosed.compareAndSet(false, true)) {
                base.close();
            }
        }

#end
#end
#No. 189583
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_TYPE option shall retrieve the socket type for the specified
         * 'socket'.  The socket type is specified at socket creation time and
         * cannot be modified afterwards.
         *
         * @return the socket type.
         */

#Code:
        public int getType()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_TYPE);
        }

#end
#end
#No. 189584
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_LINGER' option shall retrieve the period for pending outbound
         * messages to linger in memory after closing the socket. Value of -1 means
         * infinite. Pending messages will be kept until they are fully transferred to
         * the peer. Value of 0 means that all the pending messages are dropped immediately
         * when socket is closed. Positive value means number of milliseconds to keep
         * trying to send the pending messages before discarding them.
         *
         * @return the linger period.
         * @see #setLinger(int)
         */

#Code:
        public int getLinger()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_LINGER);
        }

#end
#end
#No. 189585
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_LINGER option shall set the linger period for the specified socket.
         * The linger period determines how long pending messages which have yet to be sent to a peer
         * shall linger in memory after a socket is disconnected with disconnect or closed with close,
         * and further affects the termination of the socket's context with Ctx#term.
         * The following outlines the different behaviours: A value of -1 specifies an infinite linger period.
         * Pending messages shall not be discarded after a call to disconnect() or close();
         * attempting to terminate the socket's context with Ctx#term() shall block until all pending messages have been sent to a peer.
         * The value of 0 specifies no linger period. Pending messages shall be discarded immediately after a call to disconnect() or close().
         * Positive values specify an upper bound for the linger period in milliseconds.
         * Pending messages shall not be discarded after a call to disconnect() or close();
         * attempting to terminate the socket's context with Ctx#term() shall block until either all pending messages have been sent to a peer,
         * or the linger period expires, after which any pending messages shall be discarded.
         *
         * @param value
         *            the linger period in milliseconds.
         * @return true if the option was set, otherwise false
         * @deprecated the linger option has only integer range, use {@link #setLinger(int)} instead
         * @see #getLinger()
         */

#Code:
        @Deprecated
        public boolean setLinger(long value)
        {
            return setLinger(Long.valueOf(value).intValue());
        }

#end
#end
#No. 189586
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_LINGER option shall set the linger period for the specified socket.
         * The linger period determines how long pending messages which have yet to be sent to a peer
         * shall linger in memory after a socket is disconnected with disconnect or closed with close,
         * and further affects the termination of the socket's context with Ctx#term.
         * The following outlines the different behaviours: A value of -1 specifies an infinite linger period.
         * Pending messages shall not be discarded after a call to disconnect() or close();
         * attempting to terminate the socket's context with Ctx#term() shall block until all pending messages have been sent to a peer.
         * The value of 0 specifies no linger period. Pending messages shall be discarded immediately after a call to disconnect() or close().
         * Positive values specify an upper bound for the linger period in milliseconds.
         * Pending messages shall not be discarded after a call to disconnect() or close();
         * attempting to terminate the socket's context with Ctx#term() shall block until either all pending messages have been sent to a peer,
         * or the linger period expires, after which any pending messages shall be discarded.
         *
         * @param value
         *            the linger period in milliseconds.
         * @return true if the option was set, otherwise false
         * @see #getLinger()
         */

#Code:
        public boolean setLinger(int value)
        {
            return base.setSocketOpt(zmq.ZMQ.ZMQ_LINGER, value);
        }

#end
#end
#No. 189587
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RECONNECT_IVL option shall retrieve the initial reconnection interval for the specified socket.
         * The reconnection interval is the period ?MQ shall wait between attempts to reconnect
         * disconnected peers when using connection-oriented transports.
         * The value -1 means no reconnection.
         *
         * CAUTION: The reconnection interval may be randomized by ?MQ to prevent reconnection storms in topologies with a large number of peers per socket.
         *
         * @return the reconnectIVL.
         * @see #setReconnectIVL(int)
         */

#Code:
        public int getReconnectIVL()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_RECONNECT_IVL);
        }

#end
#end
#No. 189588
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RECONNECT_IVL option shall set the initial reconnection interval for the specified socket.
         * The reconnection interval is the period ?MQ shall wait between attempts
         * to reconnect disconnected peers when using connection-oriented transports.
         * The value -1 means no reconnection.
         *
         * @return true if the option was set, otherwise false
         * @deprecated reconnect interval option uses integer range, use {@link #setReconnectIVL(int)} instead
         * @see #getReconnectIVL()
         */

#Code:
        @Deprecated
        public boolean setReconnectIVL(long value)
        {
            return setReconnectIVL(Long.valueOf(value).intValue());
        }

#end
#end
#No. 189589
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RECONNECT_IVL option shall set the initial reconnection interval for the specified socket.
         * The reconnection interval is the period ?MQ shall wait between attempts
         * to reconnect disconnected peers when using connection-oriented transports.
         * The value -1 means no reconnection.
         *
         * @return true if the option was set, otherwise false.
         * @see #getReconnectIVL()
         */

#Code:
        public boolean setReconnectIVL(int value)
        {
            return base.setSocketOpt(zmq.ZMQ.ZMQ_RECONNECT_IVL, value);
        }

#end
#end
#No. 189590
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_BACKLOG option shall retrieve the maximum length of the queue
         * of outstanding peer connections for the specified socket;
         * this only applies to connection-oriented transports.
         * For details refer to your operating system documentation for the listen function.
         *
         * @return the the maximum length of the queue of outstanding peer connections.
         * @see #setBacklog(int)
         */

#Code:
        public int getBacklog()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_BACKLOG);
        }

#end
#end
#No. 189591
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_BACKLOG option shall set the maximum length
         * of the queue of outstanding peer connections for the specified socket;
         * this only applies to connection-oriented transports.
         * For details refer to your operating system documentation for the listen function.
         *
         * @param value the maximum length of the queue of outstanding peer connections.
         * @return true if the option was set, otherwise false.
         * @deprecated this option uses integer range, use {@link #setBacklog(int)} instead.
         * @see #getBacklog()
         */

#Code:
        @Deprecated
        public boolean setBacklog(long value)
        {
            return setBacklog(Long.valueOf(value).intValue());
        }

#end
#end
#No. 189592
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_BACKLOG option shall set the maximum length
         * of the queue of outstanding peer connections for the specified socket;
         * this only applies to connection-oriented transports.
         * For details refer to your operating system documentation for the listen function.
         *
         * @param value the maximum length of the queue of outstanding peer connections.
         * @return true if the option was set, otherwise false.
         * @see #getBacklog()
         */

#Code:
        public boolean setBacklog(int value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_BACKLOG, value);
        }

#end
#end
#No. 189593
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_HANDSHAKE_IVL option shall retrieve the maximum handshake interval
         * for the specified socket.
         * Handshaking is the exchange of socket configuration information
         * (socket type, identity, security) that occurs when a connection is first opened,
         * only for connection-oriented transports.
         * If handshaking does not complete within the configured time,
         * the connection shall be closed. The value 0 means no handshake time limit.
         *
         * @return the maximum handshake interval.
         * @see #setHandshakeIvl(int)
         */

#Code:
        public int getHandshakeIvl()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_HANDSHAKE_IVL);
        }

#end
#end
#No. 189594
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_HANDSHAKE_IVL option shall set the maximum handshake interval for the specified socket.
         * Handshaking is the exchange of socket configuration information (socket type, identity, security)
         * that occurs when a connection is first opened, only for connection-oriented transports.
         * If handshaking does not complete within the configured time, the connection shall be closed.
         * The value 0 means no handshake time limit.
         *
         * @param maxHandshakeIvl the maximum handshake interval
         * @return true if the option was set, otherwise false
         * @see #getHandshakeIvl()
         */

#Code:
        public boolean setHandshakeIvl(int maxHandshakeIvl)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_HANDSHAKE_IVL, maxHandshakeIvl);
        }

#end
#end
#No. 189595
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Retrieve the IP_TOS option for the socket.
         *
         * @return the value of the Type-Of-Service set for the socket.
         * @see #setTos(int)
         */

#Code:
        public int getTos()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_TOS);
        }

#end
#end
#No. 189596
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the ToS fields (Differentiated services (DS)
         * and Explicit Congestion Notification (ECN) field of the IP header.
         * The ToS field is typically used to specify a packets priority.
         * The availability of this option is dependent on intermediate network equipment
         * that inspect the ToS field andprovide a path for low-delay, high-throughput, highly-reliable service, etc.
         *
         * @return true if the option was set, otherwise false.
         * @see #getTos()
         */

#Code:
        public boolean setTos(int value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_TOS, value);
        }

#end
#end
#No. 189597
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RECONNECT_IVL_MAX option shall retrieve the maximum reconnection interval for the specified socket.
         * This is the maximum period ?MQ shall wait between attempts to reconnect.
         * On each reconnect attempt, the previous interval shall be doubled untill ZMQ_RECONNECT_IVL_MAX is reached.
         * This allows for exponential backoff strategy.
         * Default value means no exponential backoff is performed and reconnect interval calculations are only based on ZMQ_RECONNECT_IVL.
         *
         * @return the reconnectIVLMax.
         * @see #setReconnectIVLMax(int)
         */

#Code:
        public int getReconnectIVLMax()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_RECONNECT_IVL_MAX);
        }

#end
#end
#No. 189598
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RECONNECT_IVL_MAX option shall set the maximum reconnection interval for the specified socket.
         * This is the maximum period ?MQ shall wait between attempts to reconnect.
         * On each reconnect attempt, the previous interval shall be doubled until ZMQ_RECONNECT_IVL_MAX is reached.
         * This allows for exponential backoff strategy.
         * Default value means no exponential backoff is performed and reconnect interval calculations are only based on ZMQ_RECONNECT_IVL.
         *
         * @return true if the option was set, otherwise false
         * @deprecated this option uses integer range, use {@link #setReconnectIVLMax(int)} instead
         * @see #getReconnectIVLMax()
         */

#Code:
        @Deprecated
        public boolean setReconnectIVLMax(long value)
        {
            return setReconnectIVLMax(Long.valueOf(value).intValue());
        }

#end
#end
#No. 189599
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RECONNECT_IVL_MAX option shall set the maximum reconnection interval for the specified socket.
         * This is the maximum period ?MQ shall wait between attempts to reconnect.
         * On each reconnect attempt, the previous interval shall be doubled until ZMQ_RECONNECT_IVL_MAX is reached.
         * This allows for exponential backoff strategy.
         * Default value means no exponential backoff is performed and reconnect interval calculations are only based on ZMQ_RECONNECT_IVL.
         *
         * @return true if the option was set, otherwise false
         * @see #getReconnectIVLMax()
         */

#Code:
        public boolean setReconnectIVLMax(int value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_RECONNECT_IVL_MAX, value);
        }

#end
#end
#No. 189600
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The option shall retrieve limit for the inbound messages.
         * If a peer sends a message larger than ZMQ_MAXMSGSIZE it is disconnected.
         * Value of -1 means no limit.
         *
         * @return the maxMsgSize.
         * @see #setMaxMsgSize(long)
         */

#Code:
        public long getMaxMsgSize()
        {
            return (Long) base.getSocketOptx(zmq.ZMQ.ZMQ_MAXMSGSIZE);
        }

#end
#end
#No. 189601
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Limits the size of the inbound message.
         * If a peer sends a message larger than ZMQ_MAXMSGSIZE it is disconnected.
         * Value of -1 means no limit.
         *
         * @return true if the option was set, otherwise false
         * @see #getMaxMsgSize()
         */

#Code:
        public boolean setMaxMsgSize(long value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_MAXMSGSIZE, value);
        }

#end
#end
#No. 189602
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_SNDHWM option shall return the high water mark for outbound messages on the specified socket.
         * The high water mark is a hard limit on the maximum number of outstanding messages ?MQ
         * shall queue in memory for any single peer that the specified socket is communicating with.
         * A value of zero means no limit.
         * If this limit has been reached the socket shall enter an exceptional state and depending on the socket type,
         * ?MQ shall take appropriate action such as blocking or dropping sent messages.
         * Refer to the individual socket descriptions in zmq_socket(3) for details on the exact action taken for each socket type.
         *
         * @return the SndHWM.
         * @see #setSndHWM(int)
         */

#Code:
        public int getSndHWM()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_SNDHWM);
        }

#end
#end
#No. 189603
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_SNDHWM option shall set the high water mark for outbound messages on the specified socket.
         * The high water mark is a hard limit on the maximum number of outstanding messages ?MQ
         * shall queue in memory for any single peer that the specified socket is communicating with.
         * A value of zero means no limit.
         * If this limit has been reached the socket shall enter an exceptional state and depending on the socket type,
         * ?MQ shall take appropriate action such as blocking or dropping sent messages.
         * Refer to the individual socket descriptions in zmq_socket(3) for details on the exact action taken for each socket type.
         *
         * CAUTION: ?MQ does not guarantee that the socket will accept as many as ZMQ_SNDHWM messages,
         * and the actual limit may be as much as 60-70% lower depending on the flow of messages on the socket.
         *
         * @return true if the option was set, otherwise false.
         * @deprecated this option uses integer range, use {@link #setSndHWM(int)} instead
         * @see #getSndHWM()
         */

#Code:
        @Deprecated
        public boolean setSndHWM(long value)
        {
            return setSndHWM(Long.valueOf(value).intValue());
        }

#end
#end
#No. 189604
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_SNDHWM option shall set the high water mark for outbound messages on the specified socket.
         * The high water mark is a hard limit on the maximum number of outstanding messages ?MQ
         * shall queue in memory for any single peer that the specified socket is communicating with.
         * A value of zero means no limit.
         * If this limit has been reached the socket shall enter an exceptional state and depending on the socket type,
         * ?MQ shall take appropriate action such as blocking or dropping sent messages.
         * Refer to the individual socket descriptions in zmq_socket(3) for details on the exact action taken for each socket type.
         *
         * CAUTION: ?MQ does not guarantee that the socket will accept as many as ZMQ_SNDHWM messages,
         * and the actual limit may be as much as 60-70% lower depending on the flow of messages on the socket.
         *
         * @param value
         * @return true if the option was set, otherwise false.
         * @see #getSndHWM()
         */

#Code:
        public boolean setSndHWM(int value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_SNDHWM, value);
        }

#end
#end
#No. 189605
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RCVHWM option shall return the high water mark for inbound messages on the specified socket.
         * The high water mark is a hard limit on the maximum number of outstanding messages ?MQ
         * shall queue in memory for any single peer that the specified socket is communicating with.
         * A value of zero means no limit.
         * If this limit has been reached the socket shall enter an exceptional state and depending on the socket type,
         * ?MQ shall take appropriate action such as blocking or dropping sent messages.
         * Refer to the individual socket descriptions in zmq_socket(3) for details on the exact action taken for each socket type.
         *
         * @return the recvHWM period.
         * @see #setRcvHWM(int)
         */

#Code:
        public int getRcvHWM()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_RCVHWM);
        }

#end
#end
#No. 189606
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RCVHWM option shall set the high water mark for inbound messages on the specified socket.
         * The high water mark is a hard limit on the maximum number of outstanding messages ?MQ
         * shall queue in memory for any single peer that the specified socket is communicating with.
         * A value of zero means no limit.
         * If this limit has been reached the socket shall enter an exceptional state and depending on the socket type,
         * ?MQ shall take appropriate action such as blocking or dropping sent messages.
         * Refer to the individual socket descriptions in zmq_socket(3) for details on the exact action taken for each socket type.
         *
         * @return true if the option was set, otherwise false
         * @deprecated this option uses integer range, use {@link #setRcvHWM(int)} instead
         * @see #getRcvHWM()
         */

#Code:
        @Deprecated
        public boolean setRcvHWM(long value)
        {
            return setRcvHWM(Long.valueOf(value).intValue());
        }

#end
#end
#No. 189607
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RCVHWM option shall set the high water mark for inbound messages on the specified socket.
         * The high water mark is a hard limit on the maximum number of outstanding messages ?MQ
         * shall queue in memory for any single peer that the specified socket is communicating with.
         * A value of zero means no limit.
         * If this limit has been reached the socket shall enter an exceptional state and depending on the socket type,
         * ?MQ shall take appropriate action such as blocking or dropping sent messages.
         * Refer to the individual socket descriptions in zmq_socket(3) for details on the exact action taken for each socket type.
         *
         * @param value
         * @return true if the option was set, otherwise false.
         * @see #getRcvHWM()
         */

#Code:
        public boolean setRcvHWM(int value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_RCVHWM, value);
        }

#end
#end
#No. 189608
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setHWM(int)
         *
         * @return the High Water Mark.
         */

#Code:
        @Deprecated
        public int getHWM()
        {
            return -1;
        }

#end
#end
#No. 189609
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_HWM' option shall set the high water mark for the specified 'socket'. The high
         * water mark is a hard limit on the maximum number of outstanding messages 0MQ shall queue
         * in memory for any single peer that the specified 'socket' is communicating with.
         *
         * If this limit has been reached the socket shall enter an exceptional state and depending
         * on the socket type, 0MQ shall take appropriate action such as blocking or dropping sent
         * messages. Refer to the individual socket descriptions in the man page of zmq_socket[3] for
         * details on the exact action taken for each socket type.
         *
         * @param hwm
         *            the number of messages to queue.
         * @return true if the option was set, otherwise false.
         * @deprecated this option uses integer range, use {@link #setHWM(int)} instead
         */

#Code:
        @Deprecated
        public boolean setHWM(long hwm)
        {
            boolean set = true;
            set |= setSndHWM(hwm);
            set |= setRcvHWM(hwm);
            return set;
        }

#end
#end
#No. 189610
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_HWM' option shall set the high water mark for the specified 'socket'. The high
         * water mark is a hard limit on the maximum number of outstanding messages 0MQ shall queue
         * in memory for any single peer that the specified 'socket' is communicating with.
         *
         * If this limit has been reached the socket shall enter an exceptional state and depending
         * on the socket type, 0MQ shall take appropriate action such as blocking or dropping sent
         * messages. Refer to the individual socket descriptions in the man page of zmq_socket[3] for
         * details on the exact action taken for each socket type.
         *
         * @param hwm
         *            the number of messages to queue.
         * @return true if the option was set, otherwise false
         */

#Code:
        public boolean setHWM(int hwm)
        {
            boolean set = true;
            set |= setSndHWM(hwm);
            set |= setRcvHWM(hwm);
            return set;
        }

#end
#end
#No. 189611
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setSwap(long)
         *
         * @return the number of messages to swap at most.
         */

#Code:
        @Deprecated
        public long getSwap()
        {
            // not support at zeromq 3
            return -1L;
        }

#end
#end
#No. 189612
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * If set, a socket shall keep only one message in its inbound/outbound queue,
         * this message being the last message received/the last message to be sent.
         * Ignores ZMQ_RCVHWM and ZMQ_SNDHWM options.
         * Does not support multi-part messages, in particular,
         * only one part of it is kept in the socket internal queue.
         *
         * @param conflate true to keep only one message, false for standard behaviour.
         * @return true if the option was set, otherwise false.
         * @see #isConflate()
         */

#Code:
        public boolean setConflate(boolean conflate)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_CONFLATE, conflate);
        }

#end
#end
#No. 189613
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * If in conflate mode, a socket shall keep only one message in its inbound/outbound queue,
         * this message being the last message received/the last message to be sent.
         * Ignores ZMQ_RCVHWM and ZMQ_SNDHWM options.
         * Does not support multi-part messages, in particular,
         * only one part of it is kept in the socket internal queue.
         *
         * @return true to keep only one message, false for standard behaviour.
         * @see #setConflate(boolean)
         */

#Code:
        public boolean isConflate()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_CONFLATE) != 0;
        }

#end
#end
#No. 189614
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * If in conflate mode, a socket shall keep only one message in its inbound/outbound queue,
         * this message being the last message received/the last message to be sent.
         * Ignores ZMQ_RCVHWM and ZMQ_SNDHWM options.
         * Does not support multi-part messages, in particular,
         * only one part of it is kept in the socket internal queue.
         *
         * @return true to keep only one message, false for standard behaviour.
         * @see #setConflate(boolean)
         */

#Code:
        public boolean getConflate()
        {
            return isConflate();
        }

#end
#end
#No. 189615
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Get the Swap. The 'ZMQ_SWAP' option shall set the disk offload (swap) size for the
         * specified 'socket'. A socket which has 'ZMQ_SWAP' set to a non-zero value may exceed its
         * high water mark; in this case outstanding messages shall be offloaded to storage on disk
         * rather than held in memory.
         *
         * @param value
         *            The value of 'ZMQ_SWAP' defines the maximum size of the swap space in bytes.
         */

#Code:
        @Deprecated
        public boolean setSwap(long value)
        {
            throw new UnsupportedOperationException();
        }

#end
#end
#No. 189616
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setAffinity(long)
         *
         * @return the affinity.
         */

#Code:
        public long getAffinity()
        {
            return (Long) base.getSocketOptx(zmq.ZMQ.ZMQ_AFFINITY);
        }

#end
#end
#No. 189617
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Get the Affinity. The 'ZMQ_AFFINITY' option shall set the I/O thread affinity for newly
         * created connections on the specified 'socket'.
         *
         * Affinity determines which threads from the 0MQ I/O thread pool associated with the
         * socket's _context_ shall handle newly created connections. A value of zero specifies no
         * affinity, meaning that work shall be distributed fairly among all 0MQ I/O threads in the
         * thread pool. For non-zero values, the lowest bit corresponds to thread 1, second lowest
         * bit to thread 2 and so on. For example, a value of 3 specifies that subsequent
         * connections on 'socket' shall be handled exclusively by I/O threads 1 and 2.
         *
         * See also  in the man page of init[3] for details on allocating the number of I/O threads for a
         * specific _context_.
         *
         * @param value
         *            the io_thread affinity.
         * @return true if the option was set, otherwise false
         */

#Code:
        public boolean setAffinity(long value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_AFFINITY, value);
        }

#end
#end
#No. 189618
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setIdentity(byte[])
         *
         * @return the Identitiy.
         */

#Code:
        public byte[] getIdentity()
        {
            return (byte[]) base.getSocketOptx(zmq.ZMQ.ZMQ_IDENTITY);
        }

#end
#end
#No. 189619
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_IDENTITY' option shall set the identity of the specified 'socket'. Socket
         * identity determines if existing 0MQ infastructure (_message queues_, _forwarding
         * devices_) shall be identified with a specific application and persist across multiple
         * runs of the application.
         *
         * If the socket has no identity, each run of an application is completely separate from
         * other runs. However, with identity set the socket shall re-use any existing 0MQ
         * infrastructure configured by the previous run(s). Thus the application may receive
         * messages that were sent in the meantime, _message queue_ limits shall be shared with
         * previous run(s) and so on.
         *
         * Identity should be at least one byte and at most 255 bytes long. Identities starting with
         * binary zero are reserved for use by 0MQ infrastructure.
         *
         * @param identity
         * @return true if the option was set, otherwise false
         */

#Code:
        public boolean setIdentity(byte[] identity)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_IDENTITY, identity);
        }

#end
#end
#No. 189620
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setRate(long)
         *
         * @return the Rate.
         */

#Code:
        public long getRate()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_RATE);
        }

#end
#end
#No. 189621
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_RATE' option shall set the maximum send or receive data rate for multicast
         * transports such as in the man page of zmq_pgm[7] using the specified 'socket'.
         *
         * @param value maximum send or receive data rate for multicast, default 100
         * @return true if the option was set, otherwise false
         */

#Code:
        public boolean setRate(long value)
        {
            throw new UnsupportedOperationException();
        }

#end
#end
#No. 189622
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RECOVERY_IVL option shall retrieve the recovery interval for multicast transports
         * using the specified socket. The recovery interval determines the maximum time in milliseconds
         * that a receiver can be absent from a multicast group before unrecoverable data loss will occur.
         *
         * @return the RecoveryIntervall.
         * @see #setRecoveryInterval(long)
         */

#Code:
        public long getRecoveryInterval()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_RECOVERY_IVL);
        }

#end
#end
#No. 189623
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_RECOVERY_IVL' option shall set the recovery interval for multicast transports
         * using the specified 'socket'. The recovery interval determines the maximum time in
         * seconds that a receiver can be absent from a multicast group before unrecoverable data
         * loss will occur.
         *
         * CAUTION: Exercise care when setting large recovery intervals as the data needed for
         * recovery will be held in memory. For example, a 1 minute recovery interval at a data rate
         * of 1Gbps requires a 7GB in-memory buffer. {Purpose of this Method}
         *
         * @param value recovery interval for multicast in milliseconds, default 10000
         * @return true if the option was set, otherwise false.
         * @see #getRecoveryInterval()
         */

#Code:
        public boolean setRecoveryInterval(long value)
        {
            throw new UnsupportedOperationException();
        }


#end
#end
#No. 189626
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * By default, a REQ socket does not allow initiating a new request with zmq_send(3)
         * until the reply to the previous one has been received.
         * When set to true, sending another message is allowed and has the effect of disconnecting
         * the underlying connection to the peer from which the reply was expected,
         * triggering a reconnection attempt on transports that support it.
         * The request-reply state machine is reset and a new request is sent to the next available peer.
         * If set to true, also enable ZMQ_REQ_CORRELATE to ensure correct matching of requests and replies.
         * Otherwise a late reply to an aborted request can be reported as the reply to the superseding request.
         *
         * @param relaxed
         * @return true if the option was set, otherwise false
         * @see #getReqRelaxed()
         */

#Code:
        public boolean setReqRelaxed(boolean relaxed)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_REQ_RELAXED, relaxed);
        }

#end
#end
#No. 189627
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * By default, a REQ socket does not allow initiating a new request with zmq_send(3)
         * until the reply to the previous one has been received.
         * When set to true, sending another message is allowed and has the effect of disconnecting
         * the underlying connection to the peer from which the reply was expected,
         * triggering a reconnection attempt on transports that support it.
         * The request-reply state machine is reset and a new request is sent to the next available peer.
         * If set to true, also enable ZMQ_REQ_CORRELATE to ensure correct matching of requests and replies.
         * Otherwise a late reply to an aborted request can be reported as the reply to the superseding request.
         *
         * @return state of the ZMQ_REQ_RELAXED option.
         * @see #setReqRelaxed(boolean)
         */

#Code:
        public boolean getReqRelaxed()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_REQ_CORRELATE) > 0;
        }

#end
#end
#No. 189628
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setMulticastLoop(boolean)
         *
         * @return the Multicast Loop.
         */

#Code:
        @Deprecated
        public boolean hasMulticastLoop()
        {
            return false;
        }

#end
#end
#No. 189629
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_MCAST_LOOP' option shall control whether data sent via multicast transports
         * using the specified 'socket' can also be received by the sending host via loopback. A
         * value of zero disables the loopback functionality, while the default value of 1 enables
         * the loopback functionality. Leaving multicast loopback enabled when it is not required
         * can have a negative impact on performance. Where possible, disable 'ZMQ_MCAST_LOOP' in
         * production environments.
         *
         * @param multicastLoop
         */

#Code:
        @Deprecated
        public boolean setMulticastLoop(boolean multicastLoop)
        {
            throw new UnsupportedOperationException();
        }

#end
#end
#No. 189630
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setMulticastHops(long)
         *
         * @return the Multicast Hops.
         */

#Code:
        public long getMulticastHops()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_MULTICAST_HOPS);
        }

#end
#end
#No. 189631
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the time-to-live field in every multicast packet sent from this socket.
         * The default is 1 which means that the multicast packets don't leave the local
         * network.
         *
         * @param value time-to-live field in every multicast packet, default 1
         */

#Code:
        public boolean setMulticastHops(long value)
        {
            throw new UnsupportedOperationException();
        }

#end
#end
#No. 189632
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Retrieve the timeout for recv operation on the socket.
         * If the value is 0, recv will return immediately,
         * with null if there is no message to receive.
         * If the value is -1, it will block until a message is available.
         * For all other values, it will wait for a message for that amount of time
         * before returning with a null and an EAGAIN error.
         *
         * @return the Receive Timeout  in milliseconds.
         * @see #setReceiveTimeOut(int)
         */

#Code:
        public int getReceiveTimeOut()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_RCVTIMEO);
        }

#end
#end
#No. 189633
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the timeout for receive operation on the socket. If the value is 0, recv
         * will return immediately, with null if there is no message to receive.
         * If the value is -1, it will block until a message is available. For all other
         * values, it will wait for a message for that amount of time before returning with
         * a null and an EAGAIN error.
         *
         * @param value Timeout for receive operation in milliseconds. Default -1 (infinite)
         * @return true if the option was set, otherwise false.
         * @see #getReceiveTimeOut()
         */

#Code:
        public boolean setReceiveTimeOut(int value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_RCVTIMEO, value);
        }

#end
#end
#No. 189634
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Retrieve the timeout for send operation on the socket.
         * If the value is 0, send will return immediately, with a false and an EAGAIN error if the message cannot be sent.
         * If the value is -1, it will block until the message is sent.
         * For all other values, it will try to send the message for that amount of time before returning with false and an EAGAIN error.
         *
         * @return the Send Timeout in milliseconds.
         * @see #setSendTimeOut(int)
         */

#Code:
        public int getSendTimeOut()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_SNDTIMEO);
        }

#end
#end
#No. 189635
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the timeout for send operation on the socket. If the value is 0, send
         * will return immediately, with a false if the message cannot be sent.
         * If the value is -1, it will block until the message is sent. For all other
         * values, it will try to send the message for that amount of time before
         * returning with false and an EAGAIN error.
         *
         * @param value Timeout for send operation in milliseconds. Default -1 (infinite)
         * @return true if the option was set, otherwise false.
         * @see #getSendTimeOut()
         */

#Code:
        public boolean setSendTimeOut(int value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_SNDTIMEO, value);
        }

#end
#end
#No. 189636
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
        * Override SO_KEEPALIVE socket option (where supported by OS) to enable keep-alive packets for a socket
        * connection. Possible values are -1, 0, 1. The default value -1 will skip all overrides and do the OS default.
        *
        * @param value The value of 'ZMQ_TCP_KEEPALIVE' to turn TCP keepalives on (1) or off (0).
        * @return true if the option was set, otherwise false.
        */

#Code:
        @Deprecated
        public boolean setTCPKeepAlive(long value)
        {
            return setTCPKeepAlive(Long.valueOf(value).intValue());
        }

#end
#end
#No. 189637
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setTCPKeepAlive(long)
         *
         * @return the keep alive setting.
         */

#Code:
        @Deprecated
        public long getTCPKeepAliveSetting()
        {
            return getTCPKeepAlive();
        }

#end
#end
#No. 189638
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Override TCP_KEEPCNT socket option (where supported by OS). The default value -1 will skip all overrides and
         * do the OS default.
         *
         * @param value The value of 'ZMQ_TCP_KEEPALIVE_CNT' defines the number of keepalives before death.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setTCPKeepAliveCount(long value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_TCP_KEEPALIVE_CNT, Long.valueOf(value).intValue());
        }

#end
#end
#No. 189639
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setTCPKeepAliveCount(long)
         *
         * @return the keep alive count.
         */

#Code:
        public long getTCPKeepAliveCount()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_TCP_KEEPALIVE_CNT);
        }

#end
#end
#No. 189640
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Override TCP_KEEPINTVL socket option (where supported by OS). The default value -1 will skip all overrides
         * and do the OS default.
         *
         * @param value The value of 'ZMQ_TCP_KEEPALIVE_INTVL' defines the interval between keepalives. Unit is OS
         *            dependent.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setTCPKeepAliveInterval(long value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_TCP_KEEPALIVE_INTVL, Long.valueOf(value).intValue());
        }

#end
#end
#No. 189641
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setTCPKeepAliveInterval(long)
         *
         * @return the keep alive interval.
         */

#Code:
        public long getTCPKeepAliveInterval()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_TCP_KEEPALIVE_INTVL);
        }

#end
#end
#No. 189642
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Override TCP_KEEPCNT (or TCP_KEEPALIVE on some OS) socket option (where supported by OS). The default value
         * -1 will skip all overrides and do the OS default.
         *
         * @param value The value of 'ZMQ_TCP_KEEPALIVE_IDLE' defines the interval between the last data packet sent
         *            over the socket and the first keepalive probe. Unit is OS dependent.
         * @return true if the option was set, otherwise false
         */

#Code:
        public boolean setTCPKeepAliveIdle(long value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_TCP_KEEPALIVE_IDLE, Long.valueOf(value).intValue());
        }

#end
#end
#No. 189643
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setTCPKeepAliveIdle(long)
         *
         * @return the keep alive idle value.
         */

#Code:
        public long getTCPKeepAliveIdle()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_TCP_KEEPALIVE_IDLE);
        }

#end
#end
#No. 189644
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_SNDBUF option shall retrieve the underlying kernel transmit buffer size for the specified socket.
         * For details refer to your operating system documentation for the SO_SNDBUF socket option.
         *
         * @return the kernel send buffer size.
         * @see #setSendBufferSize(int)
         */

#Code:
        public int getSendBufferSize()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_SNDBUF);
        }

#end
#end
#No. 189645
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_SNDBUF' option shall set the underlying kernel transmit buffer size for the
         * 'socket' to the specified size in bytes. A value of zero means leave the OS default
         * unchanged. For details please refer to your operating system documentation for the
         * 'SO_SNDBUF' socket option.
         *
         * @param value underlying kernel transmit buffer size for the 'socket' in bytes
         *              A value of zero means leave the OS default unchanged.
         * @return true if the option was set, otherwise false
         * @deprecated this option uses integer range, use {@link #setSendBufferSize(int)} instead
         * @see #getSendBufferSize()
         */

#Code:
        @Deprecated
        public boolean setSendBufferSize(long value)
        {
            return setSendBufferSize(Long.valueOf(value).intValue());
        }

#end
#end
#No. 189646
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_SNDBUF' option shall set the underlying kernel transmit buffer size for the
         * 'socket' to the specified size in bytes. A value of zero means leave the OS default
         * unchanged. For details please refer to your operating system documentation for the
         * 'SO_SNDBUF' socket option.
         *
         * @param value underlying kernel transmit buffer size for the 'socket' in bytes
         *              A value of zero means leave the OS default unchanged.
         * @return true if the option was set, otherwise false
         * @see #getSendBufferSize()
         */

#Code:
        public boolean setSendBufferSize(int value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_SNDBUF, value);
        }

#end
#end
#No. 189647
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_RCVBUF option shall retrieve the underlying kernel receive buffer size for the specified socket.
         * For details refer to your operating system documentation for the SO_RCVBUF socket option.
         *
         * @return the kernel receive buffer size.
         * @see #setReceiveBufferSize(int)
         */

#Code:
        public int getReceiveBufferSize()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_RCVBUF);
        }

#end
#end
#No. 189648
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_RCVBUF' option shall set the underlying kernel receive buffer size for the
         * 'socket' to the specified size in bytes.
         * For details refer to your operating system documentation for the 'SO_RCVBUF'
         * socket option.
         *
         * @param value Underlying kernel receive buffer size for the 'socket' in bytes.
         *              A value of zero means leave the OS default unchanged.
         * @return true if the option was set, otherwise false
         * @deprecated this option uses integer range, use {@link #setReceiveBufferSize(int)} instead
         * @see #getReceiveBufferSize()
         */

#Code:
        @Deprecated
        public boolean setReceiveBufferSize(long value)
        {
            return setReceiveBufferSize(Long.valueOf(value).intValue());
        }

#end
#end
#No. 189649
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_RCVBUF' option shall set the underlying kernel receive buffer size for the
         * 'socket' to the specified size in bytes.
         * For details refer to your operating system documentation for the 'SO_RCVBUF'
         * socket option.
         *
         * @param value Underlying kernel receive buffer size for the 'socket' in bytes.
         *              A value of zero means leave the OS default unchanged.
         * @return true if the option was set, otherwise false
         * @see #getReceiveBufferSize()
         */

#Code:
        public boolean setReceiveBufferSize(int value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_RCVBUF, value);
        }

#end
#end
#No. 189650
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_RCVMORE' option shall return a boolean value indicating if the multi-part
         * message currently being read from the specified 'socket' has more message parts to
         * follow. If there are no message parts to follow or if the message currently being read is
         * not a multi-part message a value of zero shall be returned. Otherwise, a value of 1 shall
         * be returned.
         *
         * @return true if there are more messages to receive.
         */

#Code:
        public boolean hasReceiveMore()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_RCVMORE) == 1;
        }

#end
#end
#No. 189651
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_FD' option shall retrieve file descriptor associated with the 0MQ
         * socket. The descriptor can be used to integrate 0MQ socket into an existing
         * event loop. It should never be used for anything else than polling -- such as
         * reading or writing. The descriptor signals edge-triggered IN event when
         * something has happened within the 0MQ socket. It does not necessarily mean that
         * the messages can be read or written. Check ZMQ_EVENTS option to find out whether
         * the 0MQ socket is readable or writeable.
         *
         * @return the underlying file descriptor.
         */

#Code:
        public SelectableChannel getFD()
        {
            return (SelectableChannel) base.getSocketOptx(zmq.ZMQ.ZMQ_FD);
        }

#end
#end
#No. 189652
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_EVENTS' option shall retrieve event flags for the specified socket.
         * If a message can be read from the socket ZMQ_POLLIN flag is set. If message can
         * be written to the socket ZMQ_POLLOUT flag is set.
         *
         * @return the mask of outstanding events.
         */

#Code:
        public int getEvents()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_EVENTS);
        }

#end
#end
#No. 189653
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_SUBSCRIBE' option shall establish a new message filter on a 'ZMQ_SUB' socket.
         * Newly created 'ZMQ_SUB' sockets shall filter out all incoming messages, therefore you
         * should call this option to establish an initial message filter.
         *
         * An empty 'option_value' of length zero shall subscribe to all incoming messages. A
         * non-empty 'option_value' shall subscribe to all messages beginning with the specified
         * prefix. Mutiple filters may be attached to a single 'ZMQ_SUB' socket, in which case a
         * message shall be accepted if it matches at least one filter.
         *
         * @param topic
         * @return true if the option was set, otherwise false
         */

#Code:
        public boolean subscribe(byte[] topic)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_SUBSCRIBE, topic);
        }

#end
#end
#No. 189654
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_SUBSCRIBE' option shall establish a new message filter on a 'ZMQ_SUB' socket.
         * Newly created 'ZMQ_SUB' sockets shall filter out all incoming messages, therefore you
         * should call this option to establish an initial message filter.
         *
         * An empty 'option_value' of length zero shall subscribe to all incoming messages. A
         * non-empty 'option_value' shall subscribe to all messages beginning with the specified
         * prefix. Mutiple filters may be attached to a single 'ZMQ_SUB' socket, in which case a
         * message shall be accepted if it matches at least one filter.
         *
         * @param topic
         * @return true if the option was set, otherwise false
         */

#Code:
        public boolean subscribe(String topic)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_SUBSCRIBE, topic);
        }

#end
#end
#No. 189655
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_UNSUBSCRIBE' option shall remove an existing message filter on a 'ZMQ_SUB'
         * socket. The filter specified must match an existing filter previously established with
         * the 'ZMQ_SUBSCRIBE' option. If the socket has several instances of the same filter
         * attached the 'ZMQ_UNSUBSCRIBE' option shall remove only one instance, leaving the rest in
         * place and functional.
         *
         * @param topic
         * @return true if the option was set, otherwise false
         */

#Code:
        public boolean unsubscribe(byte[] topic)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_UNSUBSCRIBE, topic);
        }

#end
#end
#No. 189656
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_UNSUBSCRIBE' option shall remove an existing message filter on a 'ZMQ_SUB'
         * socket. The filter specified must match an existing filter previously established with
         * the 'ZMQ_SUBSCRIBE' option. If the socket has several instances of the same filter
         * attached the 'ZMQ_UNSUBSCRIBE' option shall remove only one instance, leaving the rest in
         * place and functional.
         *
         * @param topic
         * @return true if the option was set, otherwise false
         */

#Code:
        public boolean unsubscribe(String topic)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_UNSUBSCRIBE, topic);
        }

#end
#end
#No. 189657
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Set custom Encoder
         * @param cls
         * @return true if the option was set, otherwise false
         */

#Code:
        @Deprecated
        public boolean setEncoder(Class<? extends IEncoder> cls)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_ENCODER, cls);
        }

#end
#end
#No. 189658
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Set custom Decoder
         * @param cls
         * @return true if the option was set, otherwise false
         */

#Code:
        @Deprecated
        public boolean setDecoder(Class<? extends IDecoder> cls)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_DECODER, cls);
        }

#end
#end
#No. 189659
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the limit threshold where messages of a given size will be allocated using Direct ByteBuffer.
         * It means that after this limit, there will be a slight penalty cost at the creation,
         * but the subsequent operations will be faster.
         * Set to 0 or negative to disable the threshold mechanism.
         * @param threshold the threshold to set for the size limit of messages. 0 or negative to disable this system.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setMsgAllocationHeapThreshold(int threshold)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_MSG_ALLOCATION_HEAP_THRESHOLD, threshold);
        }

#end
#end
#No. 189660
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Gets the limit threshold where messages of a given size will be allocated using Direct ByteBuffer.
         * It means that after this limit, there will be a slight penalty cost at the creation,
         * but the subsequent operations will be faster.
         * @return the threshold
         */

#Code:
        public int getMsgAllocationHeapThreshold()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_MSG_ALLOCATION_HEAP_THRESHOLD);
        }

#end
#end
#No. 189661
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_CONNECT_RID option sets the peer id of the next host connected via the connect() call,
         * and immediately readies that connection for data transfer with the named id.
         * This option applies only to the first subsequent call to connect(),
         * calls thereafter use default connection behavior.
         * Typical use is to set this socket option ahead of each connect() attempt to a new host.
         * Each connection MUST be assigned a unique name. Assigning a name that is already in use is not allowed.
         * Useful when connecting ROUTER to ROUTER, or STREAM to STREAM, as it allows for immediate sending to peers.
         * Outbound id framing requirements for ROUTER and STREAM sockets apply.
         * The peer id should be from 1 to 255 bytes long and MAY NOT start with binary zero.
         *
         * @param rid the peer id of the next host.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setConnectRid(String rid)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_CONNECT_RID, rid);
        }

#end
#end
#No. 189662
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_CONNECT_RID option sets the peer id of the next host connected via the connect() call,
         * and immediately readies that connection for data transfer with the named id.
         * This option applies only to the first subsequent call to connect(),
         * calls thereafter use default connection behavior.
         * Typical use is to set this socket option ahead of each connect() attempt to a new host.
         * Each connection MUST be assigned a unique name. Assigning a name that is already in use is not allowed.
         * Useful when connecting ROUTER to ROUTER, or STREAM to STREAM, as it allows for immediate sending to peers.
         * Outbound id framing requirements for ROUTER and STREAM sockets apply.
         * The peer id should be from 1 to 255 bytes long and MAY NOT start with binary zero.
         *
         * @param rid the peer id of the next host.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setConnectRid(byte[] rid)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_CONNECT_RID, rid);
        }

#end
#end
#No. 189663
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the raw mode on the ROUTER, when set to true.
         * When the ROUTER socket is in raw mode, and when using the tcp:// transport,
         * it will read and write TCP data without ?MQ framing.
         * This lets ?MQ applications talk to non-?MQ applications.
         * When using raw mode, you cannot set explicit identities,
         * and the ZMQ_SNDMORE flag is ignored when sending data messages.
         * In raw mode you can close a specific connection by sending it a zero-length message (following the identity frame).
         *
         * @param raw true to set the raw mode on the ROUTER.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setRouterRaw(boolean raw)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_ROUTER_RAW, raw);
        }

#end
#end
#No. 189664
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * When set to true, the socket will automatically send
         * an empty message when a new connection is made or accepted.
         * You may set this on REQ, DEALER, or ROUTER sockets connected to a ROUTER socket.
         * The application must filter such empty messages.
         * The ZMQ_PROBE_ROUTER option in effect provides the ROUTER application with an event signaling the arrival of a new peer.
         *
         * @param probe true to send automatically an empty message when a new connection is made or accepted.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setProbeRouter(boolean probe)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_PROBE_ROUTER, probe);
        }

#end
#end
#No. 189665
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the ROUTER socket behavior when an unroutable message is encountered.
         * A value of false is the default and discards the message silently
         * when it cannot be routed or the peers SNDHWM is reached.
         * A value of true returns an EHOSTUNREACH error code if the message cannot be routed
         * or EAGAIN error code if the SNDHWM is reached and ZMQ_DONTWAIT was used.
         * Without ZMQ_DONTWAIT it will block until the SNDTIMEO is reached or a spot in the send queue opens up.
         *
         * @param mandatory A value of false is the default and discards the message silently when it cannot be routed.
         *                  A value of true returns an EHOSTUNREACH error code if the message cannot be routed.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setRouterMandatory(boolean mandatory)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_ROUTER_MANDATORY, mandatory);
        }

#end
#end
#No. 189666
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * If two clients use the same identity when connecting to a ROUTER,
         * the results shall depend on the ZMQ_ROUTER_HANDOVER option setting.
         * If that is not set (or set to the default of false),
         * the ROUTER socket shall reject clients trying to connect with an already-used identity.
         * If that option is set to true, the ROUTER socket shall hand-over the connection to the new client and disconnect the existing one.
         *
         * @param handover A value of false, (default) the ROUTER socket shall reject clients trying to connect with an already-used identity
         *                  A value of true, the ROUTER socket shall hand-over the connection to the new client and disconnect the existing one
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setRouterHandover(boolean handover)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_ROUTER_HANDOVER, handover);
        }

#end
#end
#No. 189667
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the XPUB socket behavior on new subscriptions and unsubscriptions.
         *
         * @param verbose A value of false is the default and passes only new subscription messages to upstream.
         *                A value of true passes all subscription messages upstream.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setXpubVerbose(boolean verbose)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_XPUB_VERBOSE, verbose);
        }

#end
#end
#No. 189668
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the XPUB socket behaviour to return error EAGAIN if SENDHWM is reached and the message could not be send.
         * A value of false is the default and drops the message silently when the peers SNDHWM is reached.
         * A value of true returns an EAGAIN error code if the SNDHWM is reached and ZMQ_DONTWAIT was used.
         *
         * @param noDrop
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setXpubNoDrop(boolean noDrop)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_XPUB_NODROP, noDrop);
        }

#end
#end
#No. 189669
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setIPv4Only (boolean)
         *
         * @return the IPV4ONLY
         * @deprecated use {@link #isIPv6()} instead (inverted logic: ipv4 = true <==> ipv6 = false)
         */

#Code:
        @Deprecated
        public boolean getIPv4Only()
        {
            return !isIPv6();
        }

#end
#end
#No. 189670
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Retrieve the IPv6 option for the socket.
         * A value of true means IPv6 is enabled on the socket,
         * while false means the socket will use only IPv4.
         * When IPv6 is enabled the socket will connect to,
         * or accept connections from, both IPv4 and IPv6 hosts.
         *
         * @return the IPV6 configuration.
         * @see #setIPv6 (boolean)
         */

#Code:
        public boolean isIPv6()
        {
            return (Boolean) base.getSocketOptx(zmq.ZMQ.ZMQ_IPV6);
        }

#end
#end
#No. 189671
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Retrieve the IPv6 option for the socket.
         * A value of true means IPv6 is enabled on the socket,
         * while false means the socket will use only IPv4.
         * When IPv6 is enabled the socket will connect to,
         * or accept connections from, both IPv4 and IPv6 hosts.
         *
         * @return the IPV6 configuration.
         * @see #setIPv6 (boolean)
         */

#Code:
        public boolean getIPv6()
        {
            return isIPv6();
        }

#end
#end
#No. 189672
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The 'ZMQ_IPV4ONLY' option shall set the underlying native socket type.
         * An IPv6 socket lets applications connect to and accept connections from both IPv4 and IPv6 hosts.
         *
         * @param v4only A value of true will use IPv4 sockets, while the value of false will use IPv6 sockets
         * @return true if the option was set, otherwise false
         * @deprecated use {@link #setIPv6(boolean)} instead (inverted logic: ipv4 = true <==> ipv6 = false)
         */

#Code:
        @Deprecated
        public boolean setIPv4Only(boolean v4only)
        {
            return setIPv6(!v4only);
        }

#end
#end
#No. 189673
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Set the IPv6 option for the socket.
         * A value of true means IPv6 is enabled on the socket, while false means the socket will use only IPv4.
         * When IPv6 is enabled the socket will connect to, or accept connections from, both IPv4 and IPv6 hosts.
         *
         * @param v6 A value of true will use IPv6 sockets, while the value of false will use IPv4 sockets
         * @return true if the option was set, otherwise false
         * @see #isIPv6()
         */

#Code:
        public boolean setIPv6(boolean v6)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_IPV6, v6);
        }

#end
#end
#No. 189674
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setTCPKeepAlive(int)
         *
         * @return the keep alive setting.
         */

#Code:
        public int getTCPKeepAlive()
        {
            return base.getSocketOpt(zmq.ZMQ.ZMQ_TCP_KEEPALIVE);
        }

#end
#end
#No. 189675
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Override SO_KEEPALIVE socket option (where supported by OS) to enable keep-alive packets for a socket
         * connection. Possible values are -1, 0, 1. The default value -1 will skip all overrides and do the OS default.
         *
         * @param optVal The value of 'ZMQ_TCP_KEEPALIVE' to turn TCP keepalives on (1) or off (0).
         * @return true if the option was set, otherwise false
         */

#Code:
        public boolean setTCPKeepAlive(int optVal)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_TCP_KEEPALIVE, optVal);
        }

#end
#end
#No. 189676
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * @see #setDelayAttachOnConnect(boolean)
         *
         * @deprecated use {@link #setImmediate(boolean)} instead (inverted logic: immediate = true <==> delay attach on connect = false)
         */

#Code:
        @Deprecated
        public boolean getDelayAttachOnConnect()
        {
            return !isImmediate();
        }

#end
#end
#No. 189677
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Accept messages only when connections are made
         *
         * If set to true, will delay the attachment of a pipe on connect until the underlying connection
         * has completed. This will cause the socket to block if there are no other connections, but will
         * prevent queues from filling on pipes awaiting connection
         *
         * @param value The value of 'ZMQ_DELAY_ATTACH_ON_CONNECT'. Default false.
         * @return true if the option was set
         * @deprecated use {@link #setImmediate(boolean)} instead (warning, the boolean is inverted)
         */

#Code:
        @Deprecated
        public boolean setDelayAttachOnConnect(boolean value)
        {
            return setImmediate(!value);
        }

#end
#end
#No. 189678
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Retrieve the state of the attach on connect value.
         * If false, will delay the attachment of a pipe on connect until the underlying connection has completed.
         * This will cause the socket to block if there are no other connections, but will prevent queues from filling on pipes awaiting connection.
         *
         * @see #setImmediate(boolean)
         */

#Code:
        public boolean isImmediate()
        {
            return (boolean) base.getSocketOptx(zmq.ZMQ.ZMQ_IMMEDIATE);
        }

#end
#end
#No. 189679
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Retrieve the state of the attach on connect value.
         * If false, will delay the attachment of a pipe on connect until the underlying connection has completed.
         * This will cause the socket to block if there are no other connections, but will prevent queues from filling on pipes awaiting connection.
         *
         * @see #setImmediate(boolean)
         */

#Code:
        public boolean getImmediate()
        {
            return isImmediate();
        }

#end
#end
#No. 189680
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Accept messages immediately or only when connections are made
         *
         * By default queues will fill on outgoing connections even if the connection has not completed.
         * This can lead to "lost" messages on sockets with round-robin routing (REQ, PUSH, DEALER).
         * If this option is set to false, messages shall be queued only to completed connections.
         * This will cause the socket to block if there are no other connections,
         * but will prevent queues from filling on pipes awaiting connection.
         *
         * @param value The value of 'ZMQ_IMMEDIATE'. Default true.
         * @return true if the option was set, otherwise false.
         * @see #isImmediate()
         */

#Code:
        public boolean setImmediate(boolean value)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_IMMEDIATE, value);
        }

#end
#end
#No. 189681
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the SOCKS5 proxy address that shall be used by the socket for the TCP connection(s).
         * Does not support SOCKS5 authentication.
         * If the endpoints are domain names instead of addresses they shall not be resolved
         * and they shall be forwarded unchanged to the SOCKS proxy service
         * in the client connection request message (address type 0x03 domain name).
         *
         * @param proxy
         * @return true if the option was set, otherwise false.
         * @see #getSocksProxy()
         */

#Code:
        public boolean setSocksProxy(String proxy)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_SOCKS_PROXY, proxy);
        }

#end
#end
#No. 189682
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the SOCKS5 proxy address that shall be used by the socket for the TCP connection(s).
         * Does not support SOCKS5 authentication.
         * If the endpoints are domain names instead of addresses they shall not be resolved
         * and they shall be forwarded unchanged to the SOCKS proxy service
         * in the client connection request message (address type 0x03 domain name).
         *
         * @param proxy
         * @return true if the option was set, otherwise false.
         * @see #getSocksProxy()
         */

#Code:
        public boolean setSocksProxy(byte[] proxy)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_SOCKS_PROXY, proxy);
        }

#end
#end
#No. 189683
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_SOCKS_PROXY option shall retrieve the SOCKS5 proxy address in string format.
         * The returned value MAY be empty.
         *
         * @return the SOCKS5 proxy address in string format
         * @see #setSocksProxy(byte[])
         */

#Code:
        public String getSocksProxy()
        {
            return (String) base.getSocketOptx(zmq.ZMQ.ZMQ_SOCKS_PROXY);
        }

#end
#end
#No. 189684
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_LAST_ENDPOINT option shall retrieve the last endpoint bound for TCP and IPC transports.
         * The returned value will be a string in the form of a ZMQ DSN.
         * Note that if the TCP host is INADDR_ANY, indicated by a *, then the returned address will be 0.0.0.0 (for IPv4).
         */

#Code:
        public String getLastEndpoint()
        {
            return (String) base.getSocketOptx(zmq.ZMQ.ZMQ_LAST_ENDPOINT);
        }

#end
#end
#No. 189685
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the domain for ZAP (ZMQ RFC 27) authentication.
         * For NULL security (the default on all tcp:// connections),
         * ZAP authentication only happens if you set a non-empty domain.
         * For PLAIN and CURVE security, ZAP requests are always made, if there is a ZAP handler present.
         * See http://rfc.zeromq.org/spec:27 for more details.
         *
         * @param domain the domain of ZAP authentication
         * @return true if the option was set
         * @see #getZapDomain()
         */

#Code:
        public boolean setZapDomain(String domain)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_ZAP_DOMAIN, domain);
        }

#end
#end
#No. 189686
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the domain for ZAP (ZMQ RFC 27) authentication.
         * For NULL security (the default on all tcp:// connections),
         * ZAP authentication only happens if you set a non-empty domain.
         * For PLAIN and CURVE security, ZAP requests are always made, if there is a ZAP handler present.
         * See http://rfc.zeromq.org/spec:27 for more details.
         *
         * @param domain the domain of ZAP authentication
         * @return true if the option was set
         * @see #getZapDomain()
         */

#Code:
        public boolean setZapDomain(byte[] domain)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_ZAP_DOMAIN, domain);
        }

#end
#end
#No. 189687
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_ZAP_DOMAIN option shall retrieve the last ZAP domain set for the socket.
         * The returned value MAY be empty.
         *
         * @return the domain of ZAP authentication
         * @see #setZapDomain(String)
         */

#Code:
        public String getZapDomain()
        {
            return (String) base.getSocketOptx(zmq.ZMQ.ZMQ_ZAP_DOMAIN);
        }

#end
#end
#No. 189688
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Defines whether the socket will act as server for PLAIN security, see zmq_plain(7).
         * A value of true means the socket will act as PLAIN server.
         * A value of false means the socket will not act as PLAIN server,
         * and its security role then depends on other option settings.
         * Setting this to false shall reset the socket security to NULL.
         *
         * @param server true if the role of the socket should be server for PLAIN security.
         * @return true if the option was set, otherwise false.
         * @see #isAsServerPlain()
         */

#Code:
        public boolean setAsServerPlain(boolean server)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_PLAIN_SERVER, server);
        }

#end
#end
#No. 189689
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Returns the ZMQ_PLAIN_SERVER option, if any, previously set on the socket.
         *
         * @return true if the role of the socket should be server for the PLAIN mechanism.
         * @see #setAsServerPlain(boolean)
         */

#Code:
        public boolean isAsServerPlain()
        {
            return (Boolean) base.getSocketOptx(zmq.ZMQ.ZMQ_PLAIN_SERVER);
        }

#end
#end
#No. 189690
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Returns the ZMQ_PLAIN_SERVER option, if any, previously set on the socket.
         *
         * @return true if the role of the socket should be server for the PLAIN mechanism.
         * @see #setAsServerPlain(boolean)
         */

#Code:
        public boolean getAsServerPlain()
        {
            return isAsServerPlain();
        }

#end
#end
#No. 189691
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the username for outgoing connections over TCP or IPC.
         * If you set this to a non-null value, the security mechanism used for connections shall be PLAIN, see zmq_plain(7).
         * If you set this to a null value, the security mechanism used for connections shall be NULL, see zmq_null(3).
         *
         * @param username the username to set.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setPlainUsername(String username)
        {
            return base.setSocketOpt(zmq.ZMQ.ZMQ_PLAIN_USERNAME, username);
        }

#end
#end
#No. 189692
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the password for outgoing connections over TCP or IPC.
         * If you set this to a non-null value, the security mechanism used for connections
         * shall be PLAIN, see zmq_plain(7).
         * If you set this to a null value, the security mechanism used for connections shall be NULL, see zmq_null(3).
         *
         * @param password the password to set.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setPlainPassword(String password)
        {
            return base.setSocketOpt(zmq.ZMQ.ZMQ_PLAIN_PASSWORD, password);
        }

#end
#end
#No. 189693
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the username for outgoing connections over TCP or IPC.
         * If you set this to a non-null value, the security mechanism used for connections shall be PLAIN, see zmq_plain(7).
         * If you set this to a null value, the security mechanism used for connections shall be NULL, see zmq_null(3).
         *
         * @param username the username to set.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setPlainUsername(byte[] username)
        {
            return base.setSocketOpt(zmq.ZMQ.ZMQ_PLAIN_USERNAME, username);
        }

#end
#end
#No. 189694
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the password for outgoing connections over TCP or IPC.
         * If you set this to a non-null value, the security mechanism used for connections
         * shall be PLAIN, see zmq_plain(7).
         * If you set this to a null value, the security mechanism used for connections shall be NULL, see zmq_null(3).
         *
         * @param password the password to set.
         * @return true if the option was set, otherwise false.
         */

#Code:
        public boolean setPlainPassword(byte[] password)
        {
            return base.setSocketOpt(zmq.ZMQ.ZMQ_PLAIN_PASSWORD, password);
        }

#end
#end
#No. 189695
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_PLAIN_USERNAME option shall retrieve the last username
         * set for the PLAIN security mechanism.
         *
         * @return the plain username.
         */

#Code:
        public String getPlainUsername()
        {
            return (String) base.getSocketOptx(zmq.ZMQ.ZMQ_PLAIN_USERNAME);
        }

#end
#end
#No. 189696
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_PLAIN_PASSWORD option shall retrieve the last password
         * set for the PLAIN security mechanism.
         * The returned value MAY be empty.
         *
         * @return the plain password.
         */

#Code:
        public String getPlainPassword()
        {
            return (String) base.getSocketOptx(zmq.ZMQ.ZMQ_PLAIN_PASSWORD);
        }

#end
#end
#No. 189697
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Defines whether the socket will act as server for CURVE security, see zmq_curve(7).
         * A value of true means the socket will act as CURVE server.
         * A value of false means the socket will not act as CURVE server,
         * and its security role then depends on other option settings.
         * Setting this to false shall reset the socket security to NULL.
         * When you set this you must also set the server's secret key using the ZMQ_CURVE_SECRETKEY option.
         * A server socket does not need to know its own public key.
         *
         * @param server true if the role of the socket should be server for CURVE mechanism
         * @return true if the option was set
         * @see #isAsServerCurve()
         */

#Code:
        public boolean setAsServerCurve(boolean server)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_CURVE_SERVER, server);
        }

#end
#end
#No. 189698
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Tells if the socket will act as server for CURVE security.
         *
         * @return true if the role of the socket should be server for CURVE mechanism.
         * @see #setAsServerCurve(boolean)
         */

#Code:
        public boolean isAsServerCurve()
        {
            return (boolean) base.getSocketOptx(zmq.ZMQ.ZMQ_CURVE_SERVER);
        }

#end
#end
#No. 189699
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Tells if the socket will act as server for CURVE security.
         *
         * @return true if the role of the socket should be server for CURVE mechanism.
         * @see #setAsServerCurve(boolean)
         */

#Code:
        public boolean getAsServerCurve()
        {
            return isAsServerCurve();
        }

#end
#end
#No. 189700
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the socket's long term public key.
         * You must set this on CURVE client sockets, see zmq_curve(7).
         * You can provide the key as 32 binary bytes, or as a 40-character string
         * encoded in the Z85 encoding format.
         * The public key must always be used with the matching secret key.
         * To generate a public/secret key pair,
         * use {@link zmq.io.mechanism.curve.Curve#keypair()} or {@link zmq.io.mechanism.curve.Curve#keypairZ85()}.
         *
         * @param key the curve public key
         * @return true if the option was set, otherwise false
         * @see #getCurvePublicKey()
         */

#Code:
        public boolean setCurvePublicKey(byte[] key)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_CURVE_PUBLICKEY, key);
        }

#end
#end
#No. 189701
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the socket's long term server key.
         * You must set this on CURVE client sockets, see zmq_curve(7).
         * You can provide the key as 32 binary bytes, or as a 40-character string
         * encoded in the Z85 encoding format.
         * This key must have been generated together with the server's secret key.
         * To generate a public/secret key pair,
         * use {@link zmq.io.mechanism.curve.Curve#keypair()} or {@link zmq.io.mechanism.curve.Curve#keypairZ85()}.
         *
         * @param key the curve server key
         * @return true if the option was set, otherwise false
         * @see #getCurveServerKey()
         */

#Code:
        public boolean setCurveServerKey(byte[] key)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_CURVE_SERVERKEY, key);
        }

#end
#end
#No. 189702
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Sets the socket's long term secret key.
         * You must set this on both CURVE client and server sockets, see zmq_curve(7).
         * You can provide the key as 32 binary bytes, or as a 40-character string
         * encoded in the Z85 encoding format.
         * To generate a public/secret key pair,
         * use {@link zmq.io.mechanism.curve.Curve#keypair()} or {@link zmq.io.mechanism.curve.Curve#keypairZ85()}.
         *
         * @param key the curve secret key
         * @return true if the option was set, otherwise false
         * @see #getCurveSecretKey()
         */

#Code:
        public boolean setCurveSecretKey(byte[] key)
        {
            return setSocketOpt(zmq.ZMQ.ZMQ_CURVE_SECRETKEY, key);
        }

#end
#end
#No. 189703
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Retrieves the current long term public key for the socket in binary format of 32 bytes.
         *
         * @return key the curve public key
         * @see #setCurvePublicKey(byte[])
         */

#Code:
        public byte[] getCurvePublicKey()
        {
            return (byte[]) base.getSocketOptx(zmq.ZMQ.ZMQ_CURVE_PUBLICKEY);
        }

#end
#end
#No. 189704
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Retrieves the current server key for the socket in binary format of 32 bytes.
         *
         * @return key the curve server key
         * @see #setCurveServerKey(byte[])
         */

#Code:
        public byte[] getCurveServerKey()
        {
            return (byte[]) base.getSocketOptx(zmq.ZMQ.ZMQ_CURVE_SERVERKEY);
        }

#end
#end
#No. 189705
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Retrieves the current long term secret key for the socket in binary format of 32 bytes.
         *
         * @return key the curve secret key
         * @see #setCurveSecretKey(byte[])
         */

#Code:
        public byte[] getCurveSecretKey()
        {
            return (byte[]) base.getSocketOptx(zmq.ZMQ.ZMQ_CURVE_SECRETKEY);
        }

#end
#end
#No. 189706
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * The ZMQ_MECHANISM option shall retrieve the current security mechanism for the socket.
         *
         * @return the current mechanism.
         */

#Code:
        public Mechanism getMechanism()
        {
            return Mechanism.find((Mechanisms) base.getSocketOptx(zmq.ZMQ.ZMQ_MECHANISM));
        }

#end
#end
#No. 189707
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Bind to network interface. Start listening for new connections.
         *
         * @param addr
         *            the endpoint to bind to.
         * @return true if the socket was bound, otherwise false.
         */

#Code:
        public boolean bind(String addr)
        {
            boolean rc = base.bind(addr);
            mayRaise();
            return rc;
        }

#end
#end
#No. 189708
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Bind to network interface to a random port. Start listening for new
         * connections.
         *
         * @param addr
         *            the endpoint to bind to.
         */

#Code:
        public int bindToRandomPort(String addr)
        {
            return bindToRandomPort(addr, DYNFROM, DYNTO);
        }

#end
#end
#No. 189709
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Class constructor.
         *
         * @param context
         *            a 0MQ context previously created.
         */

#Code:
        protected Poller(Context context)
        {
            this(context, SIZE_DEFAULT);
        }

#end
#end
#No. 189710
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Register a Socket for polling on all events.
         *
         * @param socket
         *            the Socket we are registering.
         * @return the index identifying this Socket in the poll set.
         */

#Code:
        public int register(Socket socket)
        {
            return register(socket, POLLIN | POLLOUT | POLLERR);
        }

#end
#end
#No. 189711
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Register a Channel for polling on all events.
         *
         * @param channel
         *            the Channel we are registering.
         * @return the index identifying this Channel in the poll set.
         */

#Code:
        public int register(SelectableChannel channel)
        {
            return register(channel, POLLIN | POLLOUT | POLLERR);
        }

#end
#end
#No. 189712
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Register a Socket for polling on the specified events.
         *
         * Automatically grow the internal representation if needed.
         *
         * @param socket
         *            the Socket we are registering.
         * @param events
         *            a mask composed by XORing POLLIN, POLLOUT and POLLERR.
         * @return the index identifying this Socket in the poll set.
         */

#Code:
        public int register(Socket socket, int events)
        {
            return registerInternal(new PollItem(socket, events));
        }

#end
#end
#No. 189713
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Register a Socket for polling on the specified events.
         *
         * Automatically grow the internal representation if needed.
         *
         * @param channel
         *            the Channel we are registering.
         * @param events
         *            a mask composed by XORing POLLIN, POLLOUT and POLLERR.
         * @return the index identifying this Channel in the poll set.
         */

#Code:
        public int register(SelectableChannel channel, int events)
        {
            return registerInternal(new PollItem(channel, events));
        }

#end
#end
#No. 189714
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Register a Channel for polling on the specified events.
         *
         * Automatically grow the internal representation if needed.
         *
         * @param item
         *            the PollItem we are registering.
         * @return the index identifying this Channel in the poll set.
         */

#Code:
        public int register(PollItem item)
        {
            return registerInternal(item);
        }

#end
#end
#No. 189715
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Register a Socket for polling on the specified events.
         *
         * Automatically grow the internal representation if needed.
         *
         * @param item the PollItem we are registering.
         * @return the index identifying this Socket in the poll set.
         */

#Code:
        private int registerInternal(PollItem item)
        {
            int pos = -1;

            if (!freeSlots.isEmpty()) {
                // If there are free slots in our array, remove one
                // from the free list and use it.
                pos = freeSlots.remove();
            }
            else {
                if (next >= items.length) {
                    PollItem[] nitems = new PollItem[items.length + SIZE_INCREMENT];
                    System.arraycopy(items, 0, nitems, 0, items.length);
                    items = nitems;
                }
                pos = next++;
            }

            items[pos] = item;
            used++;
            return pos;
        }

#end
#end
#No. 189716
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Unregister a Socket for polling on the specified events.
         *
         * @param socket
         *          the Socket to be unregistered
         */

#Code:
        public void unregister(Socket socket)
        {
            unregisterInternal(socket);
        }

#end
#end
#No. 189717
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Unregister a Socket for polling on the specified events.
         *
         * @param channel
         *          the Socket to be unregistered
         */

#Code:
        public void unregister(SelectableChannel channel)
        {
            unregisterInternal(channel);
        }

#end
#end
#No. 189718
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Unregister a Socket for polling on the specified events.
         *
         * @param socket the Socket to be unregistered
         */

#Code:
        private void unregisterInternal(Object socket)
        {
            for (int i = 0; i < next; ++i) {
                PollItem item = items[i];
                if (item == null) {
                    continue;
                }
                if (item.socket == socket || item.getRawSocket() == socket) {
                    items[i] = null;

                    freeSlots.add(i);
                    --used;

                    break;
                }
            }
        }

#end
#end
#No. 189719
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Get the PollItem associated with an index.
         *
         * @param index
         *            the desired index.
         * @return the PollItem associated with that index (or null).
         */

#Code:
        public PollItem getItem(int index)
        {
            if (index < 0 || index >= this.next) {
                return null;
            }
            return this.items[index];
        }

#end
#end
#No. 189720
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Get the socket associated with an index.
         *
         * @param index
         *            the desired index.
         * @return the Socket associated with that index (or null).
         */

#Code:
        public Socket getSocket(int index)
        {
            if (index < 0 || index >= this.next) {
                return null;
            }
            return items[index].socket;
        }

#end
#end
#No. 189721
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Get the current poll timeout.
         *
         * @return the current poll timeout in milliseconds.
         * @deprecated Timeout handling has been moved to the poll() methods.
         */

#Code:
        @Deprecated
        public long getTimeout()
        {
            return this.timeout;
        }

#end
#end
#No. 189722
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Set the poll timeout.
         *
         * @param timeout
         *            the desired poll timeout in milliseconds.
         * @deprecated Timeout handling has been moved to the poll() methods.
         */

#Code:
        @Deprecated
        public void setTimeout(long timeout)
        {
            if (timeout >= -1L) {
                this.timeout = timeout;
            }
        }

#end
#end
#No. 189723
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Get the current poll set size.
         *
         * @return the current poll set size.
         */

#Code:
        public int getSize()
        {
            return items.length;
        }

#end
#end
#No. 189724
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Get the index for the next position in the poll set size.
         *
         * @return the index for the next position in the poll set size.
         */

#Code:
        public int getNext()
        {
            return this.next;
        }

#end
#end
#No. 189725
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Issue a poll call. If the poller's internal timeout value
         * has been set, use that value as timeout; otherwise, block
         * indefinitely.
         *
         * @return how many objects where signaled by poll ().
         */

#Code:
        public int poll()
        {
            long tout = -1L;
            if (this.timeout > -1L) {
                tout = this.timeout;
            }
            return poll(tout);
        }

#end
#end
#No. 189726
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Issue a poll call, using the specified timeout value.
         * <p>
         * Since ZeroMQ 3.0, the timeout parameter is in <i>milliseconds<i>,
         * but prior to this the unit was <i>microseconds</i>.
         *
         * @param tout
         *            the timeout, as per zmq_poll ();
         *            if -1, it will block indefinitely until an event
         *            happens; if 0, it will return immediately;
         *            otherwise, it will wait for at most that many
         *            milliseconds/microseconds (see above).
         *
         * @see "http://api.zeromq.org/3-0:zmq-poll"
         *
         * @return how many objects where signaled by poll ()
         */

#Code:
        public int poll(long tout)
        {
            if (tout < -1) {
                return 0;
            }
            if (items.length <= 0 || next <= 0) {
                return 0;
            }
            zmq.poll.PollItem[] pollItems = new zmq.poll.PollItem[used];
            for (int i = 0, j = 0; i < next; i++) {
                if (items[i] != null) {
                    pollItems[j++] = items[i].base;
                }
            }

            try {
                return zmq.ZMQ.poll(selector, pollItems, used, tout);
            }
            catch (ZError.IOException e) {
                if (context.isTerminated()) {
                    return 0;
                }
                else {
                    throw (e);
                }
            }
        }

#end
#end
#No. 189727
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Check whether the specified element in the poll set was signaled for input.
         *
         * @param index
         *
         * @return true if the element was signaled.
         */

#Code:
        public boolean pollin(int index)
        {
            if (index < 0 || index >= this.next) {
                return false;
            }

            return items[index].isReadable();
        }

#end
#end
#No. 189728
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Check whether the specified element in the poll set was signaled for output.
         *
         * @param index
         *
         * @return true if the element was signaled.
         */

#Code:
        public boolean pollout(int index)
        {
            if (index < 0 || index >= this.next) {
                return false;
            }

            return items[index].isWritable();
        }

#end
#end
#No. 189729
#File: E:\bishe\1\ZMQ.java
#Comment:
        /**
         * Check whether the specified element in the poll set was signaled for error.
         *
         * @param index
         *
         * @return true if the element was signaled.
         */

#Code:
        public boolean pollerr(int index)
        {
            if (index < 0 || index >= this.next) {
                return false;
            }

            return items[index].isError();
        }

#end
#end
#No. 189730
#File: E:\bishe\1\ZMQ.java
#Comment:
    /**
     * Starts the built-in 0MQ proxy in the current application thread.
     * The proxy connects a frontend socket to a backend socket. Conceptually, data flows from frontend to backend.
     * Depending on the socket types, replies may flow in the opposite direction. The direction is conceptual only;
     * the proxy is fully symmetric and there is no technical difference between frontend and backend.
     *
     * Before calling ZMQ.proxy() you must set any socket options, and connect or bind both frontend and backend sockets.
     * The two conventional proxy models are:
     *
     * ZMQ.proxy() runs in the current thread and returns only if/when the current context is closed.
     * @param frontend ZMQ.Socket
     * @param backend ZMQ.Socket
     * @param capture If the capture socket is not NULL, the proxy shall send all messages, received on both
     *                frontend and backend, to the capture socket. The capture socket should be a
     *                ZMQ_PUB, ZMQ_DEALER, ZMQ_PUSH, or ZMQ_PAIR socket.
     */

#Code:
    public static boolean proxy(Socket frontend, Socket backend, Socket capture)
    {
        return zmq.ZMQ.proxy(frontend.base, backend.base, capture != null ? capture.base : null);
    }

#end
#end
#No. 189731
#File: E:\bishe\1\ZMQ.java
#Comment:
    /**
     * @return Major version number of the ZMQ library.
     */

#Code:
    public static int getMajorVersion()
    {
        return zmq.ZMQ.ZMQ_VERSION_MAJOR;
    }

#end
#end
#No. 189732
#File: E:\bishe\1\ZMQ.java
#Comment:
    /**
     * @return Major version number of the ZMQ library.
     */

#Code:
    public static int getMinorVersion()
    {
        return zmq.ZMQ.ZMQ_VERSION_MINOR;
    }

#end
#end
#No. 189733
#File: E:\bishe\1\ZMQ.java
#Comment:
    /**
     * @return Major version number of the ZMQ library.
     */

#Code:
    public static int getPatchVersion()
    {
        return zmq.ZMQ.ZMQ_VERSION_PATCH;
    }

#end
#end
#No. 189734
#File: E:\bishe\1\ZMQ.java
#Comment:
    /**
     * @return Full version number of the ZMQ library used for comparing versions.
     */

#Code:
    public static int getFullVersion()
    {
        return zmq.ZMQ.makeVersion(zmq.ZMQ.ZMQ_VERSION_MAJOR, zmq.ZMQ.ZMQ_VERSION_MINOR, zmq.ZMQ.ZMQ_VERSION_PATCH);
    }

#end
#end
#No. 189735
#File: E:\bishe\1\ZMQ.java
#Comment:
    /**
     * @param major Version major component.
     * @param minor Version minor component.
     * @param patch Version patch component.
     *
     * @return Comparible single int version number.
     */

#Code:
    public static int makeVersion(final int major, final int minor, final int patch)
    {
        return zmq.ZMQ.makeVersion(major, minor, patch);
    }

#end
#end
#No. 189736
#File: E:\bishe\1\ZMQ.java
#Comment:
    /**
     * @return String version number in the form major.minor.patch.
     */

#Code:
    public static String getVersionString()
    {
        return "" + zmq.ZMQ.ZMQ_VERSION_MAJOR + "." + zmq.ZMQ.ZMQ_VERSION_MINOR + "." + zmq.ZMQ.ZMQ_VERSION_PATCH;
    }

#end
#end
#No. 189737
#File: E:\bishe\1\ZMQQueue.java
#Comment:
    /**
     * Class constructor.
     *
     * @param context
     *            a 0MQ context previously created.
     * @param inSocket
     *            input socket
     * @param outSocket
     *            output socket
     */

#Code:
    public ZMQQueue(Context context, Socket inSocket, Socket outSocket)
    {
        this.inSocket = inSocket;
        this.outSocket = outSocket;
    }

#end
#end
#No. 189738
#File: E:\bishe\1\Znc.java
#Comment:
    /**
     *
     * @param plugin the PurpleIRC plugin
     */

#Code:
    public Znc(PurpleIRC plugin) {
        this.plugin = plugin;
    }

#end
#end
#No. 189739
#File: E:\bishe\1\Znc.java
#Comment:
    /**
     *
     * @param sender
     * @param args
     */

#Code:
    @Override
    public void dispatch(CommandSender sender, String[] args) {
        if (args.length >= 2) {
            plugin.logDebug("Dispatching znc command...");
            int msgIdx = 1;
            java.util.List<PurpleBot> myBots = new ArrayList<>();
            if (plugin.ircBots.containsKey(args[1])) {
                myBots.add(plugin.ircBots.get(args[1]));
                msgIdx = 2;
            } else {
                myBots.addAll(plugin.ircBots.values());
            }

            for (PurpleBot ircBot : myBots) {
                String msg = "";
                for (int i = msgIdx; i < args.length; i++) {
                    msg = msg + " " + args[i];
                }
                ircBot.znc(sender, msg.substring(1));
            }
        } else {
            sender.sendMessage(fullUsage);
        }
    }

#end
#end
#No. 189740
#File: E:\bishe\1\ZNodeUtils.java
#Comment:
  /**
   * Responsible for detecting a follower {@link SequentialZNode} leader by
   * looking at an ordered (!) list of {@link SequentialZNode candidate nodes}
   * and determining the next sequence number the node's sequence.
   * <p>
   * Given a list of size <code>n</code> and a follower node positioned at place
   * <code>i</code> in the list and with a sequence value of <code>s</code> in
   * this method will return the value of the element at index <code>i-1</code>
   * iff <code>i>0</code> and <code>n>1</code>
   * <p>
   * <b>Example</b>: if a the list contains nodes with sequences 3,5,8,10 and
   * the follower sequence is 8 return value is going to be the node with a
   * sequence of 5. Given the same list and a follower node with a sequence of 3
   * the return value is going to be the node with the sequence 3 (hence the
   * follower sequence is identical to the leader sequence).
   * <p>
   * If a list of size 1 is passed then the returned node will be the only
   * element in the list
   * <p>
   * If the sequence number of the follower node is already the smallest (i.e.,
   * it is the first node in the list), then that node is returned/
   * 
   * @param candidates
   *          a non-empty list of ordered candidate {@link SequentialZNode
   *          nodes}
   * @param node
   *          the follower node looking for a leader
   * @throws IllegalArgumentException
   *           if an empty list was passed for candidates. This is an illegal
   *           case since there are no nodes and no leader
   * @return the {@link SequentialZNode} representing the new leader for the
   *         follower node or the node itself if the list has only one element
   */

#Code:
  public static SequentialZNode findNextLeader(final NavigableSet<SequentialZNode> candidates,
      final SequentialZNode node) {
    if (null == candidates || candidates.isEmpty()) {
      throw new IllegalArgumentException("Cannot use an empty or null list to find a leader");
    }

    if (candidates.size() > 1) {
      final SequentialZNode leader = candidates.lower(node);
      if (null != leader) {
        return leader;
      }
    }
    return candidates.first();
  }



#end
#end
#No. 189742
#File: E:\bishe\1\ZombieAwareness.java
#Comment:
	/**
	 * Handles special cases for specific instances like if owned and has an owner. But I want that to never be processed anyways
	 * Placeholder for now until more dynamic needs are found
	 * 
	 * @param entity
	 * @return false if you want to cancel processing, true lets it continue with other rules
	 */

#Code:
	public static boolean canEntityBeProcessedOverride(Entity entity) {
		return true;
		/*boolean result = false;
		if (entity instanceof IEntityOwnable) {
			if (entity.
		}*/
	}


#end
#end
#No. 189744
#File: E:\bishe\1\ZombieAwareness.java
#Comment:
	/**
	 * Generates list of entities we can process, these are written to config they can modify every entities config after first run
	 *
	 */

#Code:
	public static void generateEntityTickList() {
		config.load();
		for (Map.Entry<Class<? extends Entity >, String> entry : EntityList.CLASS_TO_NAME.entrySet()) {
			boolean tickEnt = canProcessEntity(entry.getKey(), true);
    	}
		config.save();
	}

#end
#end
#No. 189748
#File: E:\bishe\1\ZonedDateTimeField.java
#Comment:
	/**
	 * @return the id
	 */

#Code:
	public long getId() {
		return id;
	}

#end
#end
#No. 189749
#File: E:\bishe\1\ZonedDateTimeField.java
#Comment:
	/**
	 * @param id
	 *            the id to set
	 */

#Code:
	public void setId(long id) {
		this.id = id;
	}

#end
#end
#No. 189750
#File: E:\bishe\1\ZonedDateTimeField.java
#Comment:
	/**
	 * @return the timestamp
	 */

#Code:
	public ZonedDateTime getTimestamp() {
		return timestamp;
	}

#end
#end
#No. 189751
#File: E:\bishe\1\ZonedDateTimeField.java
#Comment:
	/**
	 * @param timestamp
	 *            the timestamp to set
	 */

#Code:
	public void setTimestamp(ZonedDateTime timestamp) {
		this.timestamp = timestamp;
	}

#end
#end
#No. 189752
#File: E:\bishe\1\ZoneNodeObject.java
#Comment:
    /**
     * Requests that the specified entry be added to the
     * <code>hostedZones</code> set. The set will not change until the event is
     * actually propagated through the system.
     */

#Code:
    @Generated(value={"com.threerings.presents.tools.GenDObjectTask"})
    public void addToHostedZones (HostedZone elem)
    {
        requestEntryAdd(HOSTED_ZONES, hostedZones, elem);
    }

#end
#end
#No. 189753
#File: E:\bishe\1\ZoneNodeObject.java
#Comment:
    /**
     * Requests that the entry matching the supplied key be removed from
     * the <code>hostedZones</code> set. The set will not change until the
     * event is actually propagated through the system.
     */

#Code:
    @Generated(value={"com.threerings.presents.tools.GenDObjectTask"})
    public void removeFromHostedZones (Comparable<?> key)
    {
        requestEntryRemove(HOSTED_ZONES, hostedZones, key);
    }

#end
#end
#No. 189754
#File: E:\bishe\1\ZoneNodeObject.java
#Comment:
    /**
     * Requests that the specified entry be updated in the
     * <code>hostedZones</code> set. The set will not change until the event is
     * actually propagated through the system.
     */

#Code:
    @Generated(value={"com.threerings.presents.tools.GenDObjectTask"})
    public void updateHostedZones (HostedZone elem)
    {
        requestEntryUpdate(HOSTED_ZONES, hostedZones, elem);
    }

#end
#end
#No. 189755
#File: E:\bishe\1\ZoneNodeObject.java
#Comment:
    /**
     * Requests that the <code>hostedZones</code> field be set to the
     * specified value. Generally one only adds, updates and removes
     * entries of a distributed set, but certain situations call for a
     * complete replacement of the set value. The local value will be
     * updated immediately and an event will be propagated through the
     * system to notify all listeners that the attribute did
     * change. Proxied copies of this object (on clients) will apply the
     * value change when they received the attribute changed notification.
     */

#Code:
    @Generated(value={"com.threerings.presents.tools.GenDObjectTask"})
    public void setHostedZones (DSet<HostedZone> value)
    {
        requestAttributeChange(HOSTED_ZONES, value, this.hostedZones);
        DSet<HostedZone> clone = (value == null) ? null : value.clone();
        this.hostedZones = clone;
    }

#end
#end
#No. 189756
#File: E:\bishe\1\ZonePeerManager.java
#Comment:
    /**
     * Creates an uninitialized peer manager.
     */

#Code:
    @Inject public ZonePeerManager (Lifecycle cycle)
    {
        super(cycle);
    }

#end
#end
#No. 189757
#File: E:\bishe\1\ZonePeerManager.java
#Comment:
    /**
     * Returns the node name of the peer that is hosting the specified scene, or null if no peer
     * has published that they are hosting the scene.
     */

#Code:
    public Tuple<String, HostedZone> getZoneHost (final int zoneId)
    {
        return lookupNodeDatum(new NodeFunc<Tuple<String, HostedZone>>() {
            @Override
            public Tuple<String, HostedZone> apply (ZoneNodeObject nodeobj) {
                HostedZone info = nodeobj.hostedZones.get(zoneId);
                return (info == null) ? null : Tuple.newTuple(nodeobj.nodeName, info);
            }
        });
    }


#end
#end
#No. 189760
#File: E:\bishe\1\ZoneTransferInTest.java
#Comment:
    /**
     * In the spirit of being lenient in what you accept... We have seen IXFR
     * responses for up-to-date zones that look like a AXFR style IXFR response:
     * 
     * <pre>
     * for:
     * dig example.com ixfr=2
     * 
     * the response is:
     * SOA serial 2
     * RR
     * RR
     * ..
     * SOA serial 2
     * </pre>
     * 
     * Which is wrong (either respond correctly per IXFR with a single SOA
     * record, or, respond that you don't support IXFR). But, once we see the
     * first SOA we know the zone is up to date. Instead of throwing an
     * "extra data" exception, just accept that the zone is up-to-date - If
     * configured to do so.
     */

#Code:
    public void test_extraDataInIXFRResponse() throws Exception {

        // fail by default
        ZoneTransferIn newIXFR = ZoneTransferIn
                .newIXFR(new Name("example.biz."), 2008021850l, false,
                        "localhost", null);
        newIXFR.setClient(new StringTCPClient(ixfrResponseExtraDataHex));
        try {
            newIXFR.run();
            fail("Should have failed for extra data");
        } catch (ZoneTransferException zte) {
            // pass
        }

        // Configure to be lenient
        Options.set("ignoreextradata");
        newIXFR = ZoneTransferIn.newIXFR(new Name("example.biz."), 2008021850l,
                false, "localhost", null);
        newIXFR.setClient(new StringTCPClient(ixfrResponseExtraDataHex));
        ZoneTransferResult run = newIXFR.run();
        assertTrue(run.isUpToDate());
    }


#end
#end
#No. 189762
#File: E:\bishe\1\ZoneTransferType.java
#Comment:
/**
 * Zone transfer types
 * 
 * @author mkube
 * 
 */

#Code:
public enum ZoneTransferType {
	AXFR, IXFR
}

#end
#end
#No. 189763
#File: E:\bishe\1\ZongPlatformUtils.java
#Comment:
	/**
	 * Initializes this class with the given platform-specific implementations.
	 */

#Code:
	public static void init(ZongPlatformUtils zongPlatformUtils) {
		checkArgsNotNull(zongPlatformUtils);
		ZongPlatformUtils.zongPlatformUtils = zongPlatformUtils;
	}

#end
#end
#No. 189764
#File: E:\bishe\1\ZongPlatformUtils.java
#Comment:
	/**
	 * Gets the default SymbolPool.
	 */

#Code:
	public abstract SymbolPool getSymbolPool();

}
}

#end
#end
#No. 189765
#File: E:\bishe\1\ZongSuite.java
#Comment:
/**
 * Base interface for Zong!'s own test suites.
 * 
 * @author Andreas Wenger
 */

#Code:
public interface ZongSuite<T>
	extends Suite<T> {

	@Override default String getName() {
		return "Zong!";
	}

#end
#end
#No. 189766
#File: E:\bishe\1\ZooKeeperAclTest.java
#Comment:
  /**
   * Verify that the master sets the correct ACLs on the root node on start-up.
   */

#Code:
  @Test
  public void testMasterSetsRootNodeAcls() throws Exception {
    startDefaultMaster();

    final CuratorFramework curator = zk().curatorWithSuperAuth();

    final List<ACL> acls = curator.getACL().forPath("/");
    assertEquals(
        Sets.newHashSet(aclProvider.getAclForPath("/")),
        Sets.newHashSet(acls));
  }

#end
#end
#No. 189767
#File: E:\bishe\1\ZooKeeperAclTest.java
#Comment:
  /**
   * Simple test to make sure nodes created by agents use the ACLs provided by the ACL provider.
   */

#Code:
  @Test
  public void testAgentCreatedNodesHaveAcls() throws Exception {
    startDefaultMaster();
    startDefaultAgent(TEST_HOST);
    awaitHostRegistered(TEST_HOST, WAIT_TIMEOUT_SECONDS, TimeUnit.SECONDS);

    final CuratorFramework curator = zk().curatorWithSuperAuth();

    final String path = Paths.configHost(TEST_HOST);
    final List<ACL> acls = curator.getACL().forPath(path);
    assertEquals(
        Sets.newHashSet(aclProvider.getAclForPath(path)),
        Sets.newHashSet(acls));
  }

#end
#end
#No. 189768
#File: E:\bishe\1\ZooKeeperAclTest.java
#Comment:
  /**
   * Simple test to make sure nodes created by master use the ACLs provided by the ACL provider.
   */

#Code:
  @Test
  public void testMasterCreatedNodesHaveAcls() throws Exception {
    startDefaultMaster();
    Polling.await(WAIT_TIMEOUT_SECONDS, TimeUnit.SECONDS, new Callable<Boolean>() {
      @Override
      public Boolean call() throws Exception {
        return defaultClient().listMasters().get().isEmpty() ? null : true;
      }
    });

    final CuratorFramework curator = zk().curatorWithSuperAuth();

    final String path = Paths.statusMasterUp(TEST_MASTER);
    final List<ACL> acls = curator.getACL().forPath(path);
    assertEquals(
        Sets.newHashSet(aclProvider.getAclForPath(path)),
        Sets.newHashSet(acls));
  }

#end
#end
#No. 189769
#File: E:\bishe\1\ZooKeeperBadNodeTest.java
#Comment:
  /**
   * This is a testing cluster that has one peer that can't be resolved. Note that this is different
   * from a cluster where a peer is down (that's tested in {@link ZooKeeperHeliosFailoverTest}).
   */

#Code:
  private final ZooKeeperTestManager zkc = new ZooKeeperTestingClusterManager() {
    @Override
    public String connectString() {
      return super.connectString() + ",node-that-doesnt-exist:1738";
    }
  };


#end
#end
#No. 189771
#File: E:\bishe\1\ZookeeperCacheLoaderTest.java
#Comment:
    /**
     * Create znode for available broker in ZooKeeper and updates it again to verify ZooKeeper cache update
     *
     * @throws InterruptedException
     * @throws KeeperException
     * @throws IOException
     */

#Code:
    @Test
    public void testZookeeperCacheLoader() throws InterruptedException, KeeperException, Exception {

        DiscoveryZooKeeperClientFactoryImpl.zk = mockZookKeeper;

        ZookeeperCacheLoader zkLoader = new ZookeeperCacheLoader(new DiscoveryZooKeeperClientFactoryImpl(), "", 30_000);

        List<String> brokers = Lists.newArrayList("broker-1:15000", "broker-2:15000", "broker-3:15000");
        // 1. create znode for each broker
        brokers.stream().forEach(b -> {
            try {
                zkLoader.getLocalZkCache().getZooKeeper().create(LOADBALANCE_BROKERS_ROOT + "/" + b, new byte[0],
                        ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            } catch (KeeperException | InterruptedException e) {
                fail("failed while creating broker znodes");
            }
        });

        Thread.sleep(100); // wait for 100 msec: to get cache updated

        // 2. get available brokers from ZookeeperCacheLoader
        List<LoadReport> list = zkLoader.getAvailableBrokers();

        // 3. verify retrieved broker list
        Assert.assertTrue(brokers.containsAll(list));

        // 4.a add new broker
        zkLoader.getLocalZkCache().getZooKeeper().create(LOADBALANCE_BROKERS_ROOT + "/" + "broker-4:15000", new byte[0],
                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        brokers.add("broker-4:15000");

        Thread.sleep(100); // wait for 100 msec: to get cache updated

        // 4.b. get available brokers from ZookeeperCacheLoader
        list = zkLoader.getAvailableBrokers();

        // 4.c. verify retrieved broker list
        Assert.assertTrue(brokers.containsAll(list));

    }

#end
#end
#No. 189772
#File: E:\bishe\1\ZookeeperCacheTest.java
#Comment:
    /**
     * Verifies that blocking call on zkCache-callback will not introduce deadlock because zkCache completes
     * future-result with different thread than zookeeper-client thread.
     * 
     * @throws Exception
     */

#Code:
    @Test(timeOut = 2000)
    void testZkCallbackThreadStuck() throws Exception {
        OrderedSafeExecutor executor = new OrderedSafeExecutor(1, "test");
        ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(2);
        ExecutorService zkExecutor = Executors.newSingleThreadExecutor(new DefaultThreadFactory("mockZk"));
        // add readOpDelayMs so, main thread will not serve zkCacahe-returned future and let zkExecutor-thread handle
        // callback-result process
        MockZooKeeper zkClient = MockZooKeeper.newInstance(zkExecutor, 100);
        ZooKeeperCache zkCacheService = new LocalZooKeeperCache(zkClient, executor, scheduledExecutor);
        ZooKeeperDataCache<String> zkCache = new ZooKeeperDataCache<String>(zkCacheService) {
            @Override
            public String deserialize(String key, byte[] content) throws Exception {
                return new String(content);
            }
        };

        String value = "test";
        String key = "/" + UUID.randomUUID().toString().substring(0, 8);
        String key1 = "/" + UUID.randomUUID().toString().substring(0, 8);
        String key2 = "/" + UUID.randomUUID().toString().substring(0, 8);
        zkClient.create(key, value.getBytes(), null, null);
        zkClient.create(key1, value.getBytes(), null, null);
        zkClient.create(key2, value.getBytes(), null, null);

        CountDownLatch latch = new CountDownLatch(1);

        zkCache.getAsync(key).thenAccept(val -> {
            try {
                zkCache.get(key1);
            } catch (Exception e) {
                fail("failed to get " + key2, e);
            }
            latch.countDown();
        });

        latch.await();
        executor.shutdown();
        zkExecutor.shutdown();
        scheduledExecutor.shutdown();
    }


#end
#end
#No. 189779
#File: E:\bishe\1\ZookeeperConfigProvider.java
#Comment:
    /**
     * @param client curator instance for connecting to the config ensemble
     * @param baseZPath the base path for config nodes
     * @param defaults default properties
     * @param hostname this JVM's hostname
     * @throws Exception errors
     */

#Code:
    public ZookeeperConfigProvider(CuratorFramework client, String baseZPath, Properties defaults, String hostname) throws Exception
    {
        this.client = client;
        this.defaults = defaults;
        this.hostname = hostname;
        configPath = ZKPaths.makePath(baseZPath, CONFIG_PATH);
        lockPath = ZKPaths.makePath(baseZPath, LOCK_PATH);
        cache = new PathChildrenCache(client, configPath, true);
    }


#end
#end
#No. 189781
#File: E:\bishe\1\ZooKeeperConfiguration.java
#Comment:
    /**
     * Return a managed Curator connection.  This created connection will be wrapped in a
     * {@link ManagedCuratorFramework} and offered to the provided {@link Environment} parameter.
     *
     * @deprecated Use {@link #newManagedCurator(LifecycleEnvironment)} instead.
     */

#Code:
    @Deprecated
    public CuratorFramework newManagedCurator(Environment env) {
        return newManagedCurator(env.lifecycle());
    }

#end
#end
#No. 189782
#File: E:\bishe\1\ZooKeeperConfiguration.java
#Comment:
    /**
     * Return a managed Curator connection.  This created connection will be wrapped in a
     * {@link ManagedCuratorFramework} and offered to the provided {@link LifecycleEnvironment} parameter.
     */

#Code:
    public CuratorFramework newManagedCurator(LifecycleEnvironment env) {
        CuratorFramework curator = newCurator();
        env.manage(new ManagedCuratorFramework(curator));
        return curator;
    }

#end
#end
#No. 189792
#File: E:\bishe\1\ZooKeeperRegistrarServiceTest.java
#Comment:
  /**
   * An overload of {@link #createStubRegistrar(boolean)} which invokes the Consumer in
   * tryToRegister before completing {@link #complete}. This can be used to customize the behavior
   * of tryToRegister without having to declare yet another subclass of ZooKeeperRegistrar.
   */

#Code:
  private ZooKeeperRegistrar createStubRegistrar(
      boolean registered, ClientConsumer clientConsumer) {

    return new ZooKeeperRegistrar() {
      @Override
      public void startUp() throws Exception {
      }

      @Override
      public void shutDown() throws Exception {
        shutdownComplete.set(null);
      }

      @Override
      public boolean tryToRegister(ZooKeeperClient client)
          throws KeeperException, HostNotFoundException {

        clientConsumer.accept(client);

        complete.set(null);
        return registered;
      }
    };
  }

#end
#end
#No. 189793
#File: E:\bishe\1\ZooKeeperRegistrarUtil.java
#Comment:
  /**
   * Re-register an agent with a different host id. Will remove the existing status of the agent
   * but preserve any jobs deployed to the host and their history.
   * @param client ZooKeeperClient
   * @param host Host
   * @param hostId ID of the host
   * @throws HostNotFoundException If the hostname we are trying to re-register as doesn't exist.
   * @throws KeeperException If an unexpected zookeeper error occurs.
   */

#Code:
  public static void reRegisterHost(final ZooKeeperClient client,
                                    final String host, final String hostId)
      throws HostNotFoundException, KeeperException {
    // * Delete everything in the /status/hosts/<hostname> subtree
    // * Don't delete any history for the job (on the host)
    // * DON'T touch anything in the /config/hosts/<hostname> subtree, except updating the host id
    log.info("re-registering host: {}, new host id: {}", host, hostId);
    try {
      final List<ZooKeeperOperation> operations = Lists.newArrayList();

      // Check that the host exists in ZK
      operations.add(check(Paths.configHost(host)));

      // Remove the host status
      final List<String> nodes = safeListRecursive(client, Paths.statusHost(host));
      for (final String node : reverse(nodes)) {
        operations.add(delete(node));
      }

      // ...and re-create the /status/hosts/<host>/jobs node + parent
      operations.add(create(Paths.statusHost(host)));
      operations.add(create(Paths.statusHostJobs(host)));

      // Update the host ID
      // We don't have WRITE permissions to the node, so delete and re-create it.
      operations.add(delete(Paths.configHostId(host)));
      operations.add(create(Paths.configHostId(host), hostId.getBytes(UTF_8)));

      client.transaction(operations);
    } catch (NoNodeException e) {
      throw new HostNotFoundException(host);
    } catch (KeeperException e) {
      throw new HeliosRuntimeException(e);
    }
  }

#end
#end
#No. 189797
#File: E:\bishe\1\ZooKeeperServerConfig.java
#Comment:
    /**
     * @param clientPort   the port the ZooKeeper client uses to connect to
     * @param dataDir      the directory ZooKeeper uses to store its data
     * @param dataLogDir   the directory ZooKeeper uses to store its logs
     * @param tickTime     the keep alive tick time
     * @param initLimit    initialisation limit
     * @param syncLimit    synchronisation limit
     */

#Code:
    @Inject
    public ZooKeeperServerConfig(@ConfigProperty(name = "ZOOKEEPER_CLIENT_PORT", defaultValue = "2181")
                                 int clientPort,
                                 @ConfigProperty(name = "ZOOKEEPER_DATADIR", defaultValue = "ensemble/data")
                                 String dataDir,
                                 @ConfigProperty(name = "ZOOKEEPER_DATA_LOG_DIR", defaultValue = "ensemble/log")
                                 String dataLogDir,
                                 @ConfigProperty(name = "ZOOKEEPER_TICKTIME", defaultValue = "" + ZooKeeperServer.DEFAULT_TICK_TIME)
                                 int tickTime,
                                 @ConfigProperty(name = "ZOOKEEPER_INIT_LIMIT")
                                 int initLimit,
                                 @ConfigProperty(name = "ZOOKEEPER_SYNC_LIMIT")
                                 int syncLimit) {
        this.dataDir = dataDir;
        this.dataLogDir = dataLogDir;
        this.syncLimit = syncLimit;
        this.initLimit = initLimit;
        if (clientPort > 0) {
            this.clientPortAddress = new InetSocketAddress(clientPort);
        }
    }

#end
#end
#No. 189798
#File: E:\bishe\1\ZookeeperServerLifecycleTest.java
#Comment:
    /**
     * Configures and invokes an Zookeeper Server inside a separate thread.
     *
     * @throws Exception
     */

#Code:
    @BeforeClass
    public static void configureLifecycle() throws Exception {
        serverLifecycle = new ZookeeperServerLifecycle();
        serverLifecycle.configureServer(port, dataDir, null, null, null);
        serverLifecycle.start();
    }

#end
#end
#No. 189799
#File: E:\bishe\1\ZookeeperServerLifecycleTest.java
#Comment:
    /**
     * This is a basic smoke test- It is to ensure that we can connect
     * to the spawned resource.
     *
     * @throws Exception
     */

#Code:
    @Test
    public void canConnectToServer() throws Exception {
        ZooKeeper keeper = newZooKeeper();

        keeper.close();
    }

#end
#end
#No. 189800
#File: E:\bishe\1\ZooKeeperSessionExpireRecoveryTest.java
#Comment:
    /**
     * Verify we are able to recover when receiving a SessionExpired event on global ZK session
     */

#Code:
    @Test
    public void testSessionExpired() throws Exception {
        admin.clusters().createCluster("my-cluster", new ClusterData("test-url"));

        assertEquals(admin.clusters().getClusters(), Lists.newArrayList("my-cluster"));

        mockZookKeeper.failNow(Code.SESSIONEXPIRED);

        assertEquals(admin.clusters().getClusters(), Lists.newArrayList("my-cluster"));

        try {
            admin.clusters().createCluster("my-cluster-2", new ClusterData("test-url"));
            fail("Should have failed, because global zk is down");
        } catch (PulsarAdminException e) {
            // Ok
        }

        admin.clusters().createCluster("cluster-2", new ClusterData("test-url"));
    }




#end
#end
#No. 189803
#File: E:\bishe\1\ZoomifyTiler.java
#Comment:
    /**
     * Delete a file
     * @param path the path of the directory to be deleted
     */

#Code:
    private static void deleteFile(File file) throws IOException {
        if (!file.delete()) {
            throw new IOException("Failed to delete file: " + file);
        }
    }

#end
#end
#No. 189804
#File: E:\bishe\1\ZoomifyTiler.java
#Comment:
    /**
     * Recursively deletes a directory
     * @param path the path of the directory to be deleted
     */

#Code:
    private static void deleteDir(File dir) throws IOException {
        if (!dir.isDirectory()) {
            deleteFile(dir);
        } else {
            for (File file : dir.listFiles()) {
                if (file.isDirectory()) {
                    deleteDir(file);
                } else {
                    deleteFile(file);
                }
            }
            if (!dir.delete()) {
                throw new IOException("Failed to delete directory: " + dir);
            }
        }
    }

#end
#end
#No. 189805
#File: E:\bishe\1\ZoomifyTiler.java
#Comment:
    /**
     * Creates a directory
     * @param parent the parent directory for the new directory
     * @param name the new directory name
     */

#Code:
    private static File createDir(File parent, String name) throws IOException {
        assert (parent.isDirectory());
        File result = new File(parent + File.separator + name);
        if (!(result.exists() || result.mkdir())) {
            throw new IOException("Unable to create directory: " + result);
        }
        return result;
    }

#end
#end
#No. 189806
#File: E:\bishe\1\ZoomifyTiler.java
#Comment:
    /**
     * Loads image from file
     * @param file the file containing the image
     */

#Code:
    private static BufferedImage loadImage(File file) throws IOException {
        FileSeekableStream stream = null;
        BufferedImage result = null;
        try {
            stream = new FileSeekableStream(file);
            PlanarImage planarImage = JAI.create("stream", stream);
            //PlanarImage planarImage = JAI.create("fileload", file.getAbsolutePath());            
            result = planarImage.getAsBufferedImage();
        } catch (Exception e) {
            e.printStackTrace();
            throw new IOException("Cannot read image file: " + file.getAbsolutePath());
        } finally {
            if (stream != null) {
                stream.close();
            }
        }
        return result;
    }

#end
#end
#No. 189807
#File: E:\bishe\1\ZoomifyTiler.java
#Comment:
    /**
     * Gets an image containing the tile at the given row and column
     * for the given image.
     * @param img - the input image from whihc the tile is taken
     * @param row - the tile's row (i.e. y) index
     * @param col - the tile's column (i.e. x) index
     */

#Code:
    private static BufferedImage getTile(BufferedImage img, int row, int col) {
        int x = col * tileSize;
        int y = row * tileSize;
        int w = tileSize;
        int h = tileSize;
        if (x + w > img.getWidth()) {
            w = img.getWidth() - x;
        }
        if (y + h > img.getHeight()) {
            h = img.getHeight() - y;
        }
        if (debugMode) {
            System.out.printf("getTile: row=%d, col=%d, x=%d, y=%d, w=%d, h=%d\n",
                    row, col, x, y, w, h);
        }
        assert (w > 0);
        assert (h > 0);
        BufferedImage result = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
        Graphics2D g = result.createGraphics();
        g.drawImage(img, 0, 0, w, h, x, y, x + w, y + h, null);

        return result;
    }

#end
#end
#No. 189808
#File: E:\bishe\1\ZoomifyTiler.java
#Comment:
    /**
     * Returns resized image
     * NB - useful reference on high quality image resizing can be found here:
     *   http://today.java.net/pub/a/today/2007/04/03/perils-of-image-getscaledinstance.html
     * @param width the required width
     * @param height the frequired height
     * @param img the image to be resized
     */

#Code:
    private static BufferedImage resizeImage(BufferedImage img, double width, double height) {
        int w = (int) width;
        int h = (int) height;
        BufferedImage result = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
        Graphics2D g = result.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
        g.drawImage(img, 0, 0, w, h, 0, 0, img.getWidth(), img.getHeight(), null);
        //surprisingly this gives worse results
        //RenderingHints qualityHints = new RenderingHints(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        //BufferedImage result = JAI.create("SubsampleAverage", img, width / (double) img.getWidth(), height / (double) img.getHeight(), qualityHints).getAsBufferedImage();
        return result;
    }

#end
#end
#No. 189809
#File: E:\bishe\1\ZoomifyTiler.java
#Comment:
    /**
     * Saves image to the given file
     * @param img the image to be saved
     * @param path the path of the file to which it is saved (less the extension)
     * @param quality the compression quality to use (0-1)
     */

#Code:
    private static void saveImageAtQuality(BufferedImage img, String path, float quality) throws IOException {
        File outputFile = new File(path + ".jpg");
        Iterator iter = ImageIO.getImageWritersByFormatName("jpeg");
        ImageWriter writer = (ImageWriter) iter.next();
        ImageWriteParam iwp = writer.getDefaultWriteParam();
        iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        iwp.setCompressionQuality(quality);
        FileImageOutputStream output = new FileImageOutputStream(outputFile);
        writer.setOutput(output);
        IIOImage image = new IIOImage(img, null, null);
        try {
            writer.write(null, image, iwp);
        } catch (IOException e) {
            throw new IOException("Unable to save image file: " + outputFile);
        } finally {
            if (writer != null) {
                writer.dispose();
            }
            if (output != null) {
                output.close();
            }
        }
    }

#end
#end
#No. 189810
#File: E:\bishe\1\ZoomifyTiler.java
#Comment:
    /**
     * Write image descriptor XML file
     * @param width image width
     * @param height image height
     * @param file the file to which it is saved
     */

#Code:
    private static void saveImageDescriptor(int width, int height, int numTiles, File file) throws IOException {
        String xmlHeader = "<?xml version=\"1.0\" encoding=\"utf-8\"?>";        
        ArrayList<String> lines = new ArrayList<String>();
        lines.add(xmlHeader);
        lines.add("<IMAGE_PROPERTIES WIDTH=\"" + width + "\" HEIGHT=\"" + height + "\" NUMTILES=\"" + numTiles + "\" NUMIMAGES=\"1\" VERSION=\"1.8\" TILESIZE=\"" + tileSize + "\"/>");
        saveText(lines, file);
    }

#end
#end
#No. 189811
#File: E:\bishe\1\ZoomifyTiler.java
#Comment:
    /**
     * Saves strings as text to the given file
     * @param lines the image to be saved
     * @param file the file to which it is saved
     */

#Code:
    private static void saveText(ArrayList lines, File file) throws IOException {
        if (verboseMode) {
            System.out.printf("Writing file: %s\n", file);
        }
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(file);
            PrintStream ps = new PrintStream(fos);
            for (int i = 0; i < lines.size(); i++) {
                ps.println((String) lines.get(i));
            }
        } catch (IOException e) {
            throw new IOException("Unable to write to text file: " + file);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    }


#end
#end
#No. 189813
#File: E:\bishe\1\ZoomListener.java
#Comment:
	/** Increments or decrements and rounds the length of visible audio data.
	 *  @param value The original length of visible audio data
	 *  @param sign  The direction of change (+1.0 or -1.0) 
	 *  @return      The new length of visible audio data
	 */

#Code:
	public static double delta(double value, double sign) {
		if (value >= 5.0)
			return Math.floor(value + sign * value / 5.0 + 0.5);
		if (value >= 1.0)
			return Math.floor(5.0 * (value + sign * value / 5.0) + 0.5) / 5.0;
		if (value >= 0.5)
			return Math.floor(10.0 * (value + sign * value / 5.0) + 0.5) / 10.0;
		return Math.floor(10.0 * (value + sign * 0.1) + 0.5) / 10.0;
	} // delta()



#end
#end
#No. 189816
#File: E:\bishe\1\ZoomPanel.java
#Comment:
    /**
     * Returns the current zoom level. 1.0 means 100%
     */

#Code:
    public double getCurrentZoomLevel() {
        return currentZoomLevel;
    }

#end
#end
#No. 189817
#File: E:\bishe\1\ZoomPanel.java
#Comment:
    /**
     * Adds an action listener that will be notified when the zoom level changes.
     */

#Code:
    public void addActionListener(ActionListener listener) {
        if (listener == null) {
            return;
        }
        
        this.listeners.add(listener);
    }

#end
#end
#No. 189818
#File: E:\bishe\1\ZoomPanel.java
#Comment:
    /**
     * Notifies listeners that the zoom level has changed.
     */

#Code:
    private void notifyListeners() {
        for (ActionListener listener : this.listeners) {
            listener.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ""));
        }
    }

#end
#end
#No. 189827
#File: E:\bishe\1\ZoomScaling.java
#Comment:
	/**
	 * @param id
	 * @param scaleType
	 */

#Code:
	public ZoomScaling() {
		super(R.id.itemZoomable, ScaleType.MATRIX);
		matrix = new Matrix();
		scaling = 1;
	}

#end
#end
#No. 189828
#File: E:\bishe\1\ZoomScaling.java
#Comment:
	/**
	 * Call after scaling and matrix have been changed to resolve scrolling
	 * @param activity
	 */

#Code:
	private void resolveZoom(VncCanvasActivity activity)
	{
		activity.vncCanvas.scrollToAbsolute();
		activity.vncCanvas.pan(0,0);
	}

#end
#end
#No. 189829
#File: E:\bishe\1\ZoomScaling.java
#Comment:
	/**
	 *  Set scaling to one of the clicks on the zoom scale
	 */

#Code:
	private void standardizeScaling()
	{
		scaling = ((float)((int)(scaling * 4))) / 4;
	}


#end
#end
#No. 189833
#File: E:\bishe\1\ZParams.java
#Comment:
  /**
   * Set weights.
   * @param weights weights.
   */

#Code:
  public ZParams weights(final double... weights) {
    params.add(WEIGHTS.raw);
    for (final double weight : weights) {
      params.add(Protocol.toByteArray(weight));
    }

    return this;
  }

#end
#end
#No. 189834
#File: E:\bishe\1\ZrcListView.java
#Comment:
    /**
     * Obtain the view and add it to our list of children. The view can be made
     * fresh, converted from an unused view, or used as is if it was in the
     * recycle bin.
     *
     * @param position Logical position in the list
     * @param y Top or bottom edge of the view to add
     * @param flow If flow is true, align top edge to y. If false, align bottom
     *            edge to y.
     * @param childrenLeft Left edge where children should be positioned
     * @param selected Is this position selected?
     * @return View that was added
     */

#Code:
    private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) {
        View child;

        if (!mDataChanged) {
            // Try to use an existing view for this position
            child = mRecycler.getActiveView(position);
            if (child != null) {
                // Found it -- we're using an existing child
                // This just needs to be positioned
                setupChild(child, position, y, flow, childrenLeft, selected, true);

                return child;
            }
        }

        // Make a new view for this position, or convert an unused view if
        // possible
        child = obtainView(position, mIsScrap);

        // This needs to be positioned and measured
        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);

        return child;
    }


#end
#end
#No. 189836
#File: E:\bishe\1\ZrcListView.java
#Comment:
    /**
     * @return Whether the views created by the ListAdapter can contain
     *         focusable items.
     */

#Code:
    public boolean getItemsCanFocus() {
        return mItemsCanFocus;
    }

#end
#end
#No. 189837
#File: E:\bishe\1\ZrcListView.java
#Comment:
    /**
     * convert all views to header view
     */

#Code:
    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        int count = getChildCount();
        if (count > 0) {
            for (int i = 0; i < count; ++i) {
                addHeaderView(getChildAt(i));
            }
            removeAllViews();
        }
    }

#end
#end
#No. 189841
#File: E:\bishe\1\ZRegion1.java
#Comment:
/**
 * This example, due to Stephen Heumann, motivated a bug fix in the
 * handling of z regions.
 */

#Code:
class ZRegion1<region R> {
    ZRegion1<R> y;
    void m() {
        ZRegion1<this> z = new ZRegion1<this>();
	// z was erroneously substituted for 'this' here
        z.y = new ZRegion1<this>();
    }
}
#end
#end
#No. 189843
#File: E:\bishe\1\ZRTCPTransformer.java
#Comment:
    /**
     * Close the transformer engine.
     * 
     * The close functions closes all stored default crypto contexts. This deletes key data
     * and forces a cleanup of the crypto contexts.
     */

#Code:
    public void close() {
        if (srtcpOut != null) {
            srtcpOut.close();
            srtcpOut = null;
        }
        if (srtcpIn != null) {
            srtcpIn.close();
            srtcpIn = null;
        }
    }

#end
#end
#No. 189844
#File: E:\bishe\1\ZRTCPTransformer.java
#Comment:
    /**
     * Encrypt a SRTCP packet
     * 
     * Currently SRTCP packet encryption / decryption is not supported
     * So this method does not change the packet content
     * 
     * @param pkt plain SRTCP packet to be encrypted
     * @return encrypted SRTCP packet
     */

#Code:
    public RawPacket transform(RawPacket pkt) {
        if (srtcpOut == null) {
            return pkt;
        }
        return srtcpOut.transform(pkt);
    }

#end
#end
#No. 189845
#File: E:\bishe\1\ZRTCPTransformer.java
#Comment:
    /**
     * Decrypt a SRTCP packet
     * 
     * Currently SRTCP packet encryption / decryption is not supported
     * So this method does not change the packet content
     * 
     * @param pkt encrypted SRTCP packet to be decrypted
     * @return decrypted SRTCP packet
     */

#Code:
    public RawPacket reverseTransform(RawPacket pkt) {
        if (srtcpIn == null) {
            return pkt;
        }
        return srtcpIn.reverseTransform(pkt);
    }

#end
#end
#No. 189846
#File: E:\bishe\1\ZRTCPTransformer.java
#Comment:
    /**
     * @param srtcpIn the srtcpIn to set
     */

#Code:
    public void setSrtcpIn(PacketTransformer srtcpIn) {
        this.srtcpIn = srtcpIn;
    }

#end
#end
#No. 189847
#File: E:\bishe\1\ZRTCPTransformer.java
#Comment:
    /**
     * @param srtcpOut the srtcpOut to set
     */

#Code:
    public void setSrtcpOut(PacketTransformer srtcpOut) {
        this.srtcpOut = srtcpOut;
    }

#end
#end
#No. 189848
#File: E:\bishe\1\ZrtpCodes.java
#Comment:
   /**
    * This enum defines the information message severity.
    *
    * The ZRTP implementation issues information messages to inform the user
    * about ongoing processing, unusual behavior, or alerts in case of severe
    * problems. Each main severity code a number of sub-codes exist that
    * specify the exact nature of the problem. 
    *
    * An application gets message severity codes and the associated sub-codes
    * via the ZrtpUserCallback#showMessage method.
    * 
    * The severity levels and their meaning are:
    *
    * <dl>
    * <dt>Info</dt> <dd>keeps the user informed about ongoing processing and
    *     security setup. The enumeration InfoCodes defines the sub-codes.
    * </dd>
    * <dt>Warning</dt> <dd>is an information about some security issues, e.g. if
    *     an AES 256 encryption is request but only DH 3072 as public key scheme
    *     is supported. ZRTP will establish a secure session (SRTP). The
    *     enumeration WarningCodes defines the sub-codes.
    * </dd>
    * <dt>Severe</dt> <dd>is used if an error occurred during ZRTP protocol usage.
    *     In case of <em>Severe</em> ZRTP will <b>not</b> establish a secure session.
    *     The enumeration SevereCodes defines the sub-codes.
    * </dd>
    * <dt>ZrtpError</dt> <dd>shows a ZRTP security problem. Refer to the enumeration
    *     ZrtpErrorCodes for sub-codes. GNU ZRTP of course will <b>not</b> 
    *     establish a secure session.
    * </dd>
    * </dl>
    */

#Code:
    enum  MessageSeverity {
        Info,
        Warning,
        Severe,
        ZrtpError
   }

#end
#end
#No. 189849
#File: E:\bishe\1\ZrtpCodes.java
#Comment:
    /**
     * Sub-codes for Info
     */

#Code:
    enum InfoCodes {
        InfoHelloReceived,              //!< Hello received, preparing a Commit
        InfoCommitDHGenerated,          //!< Commit: Generated a public DH key
        InfoRespCommitReceived,         //!< Responder: Commit received, preparing DHPart1
        InfoDH1DHGenerated,             //!< DH1Part: Generated a public DH key
        InfoInitDH1Received,            //!< Initiator: DHPart1 received, preparing DHPart2
        InfoRespDH2Received,            //!< Responder: DHPart2 received, preparing Confirm1
        InfoInitConf1Received,          //!< Initiator: Confirm1 received, preparing Confirm2
        InfoRespConf2Received,          //!< Responder: Confirm2 received, preparing Conf2Ack
        InfoRSMatchFound,               //!< At least one retained secrets matches - security OK
        InfoSecureStateOn,              //!< Entered secure state
        InfoSecureStateOff              //!< No more security for this session
    }

#end
#end
#No. 189850
#File: E:\bishe\1\ZrtpCodes.java
#Comment:
    /**
     * Sub-codes for Warning
     */

#Code:
    enum WarningCodes {
        WarningDHAESmismatch,           //!< Commit contains an AES256 cipher but does not offer a Diffie-Helman 4096
        WarningGoClearReceived,         //!< Received a GoClear message
        WarningDHShort,                 //!< Hello offers an AES256 cipher but does not offer a Diffie-Helman 4096
        WarningNoRSMatch,               //!< No retained shared secrets available - must verify SAS
        WarningCRCmismatch,             //!< Internal ZRTP packet checksum mismatch - packet dropped
        WarningSRTPauthError,           //!< Dropping packet because SRTP authentication failed!
        WarningSRTPreplayError,         //!< Dropping packet because SRTP replay check failed!
        WarningNoExpectedRSMatch        //!< Valid retained shared secrets availabe but no matches found - must verify SAS

    }

#end
#end
#No. 189851
#File: E:\bishe\1\ZrtpCodes.java
#Comment:
    /**
     * Sub-codes for Severe
     */

#Code:
    enum SevereCodes {
        SevereHelloHMACFailed,          //!< Hash HMAC check of Hello failed!
        SevereCommitHMACFailed,         //!< Hash HMAC check of Commit failed!
        SevereDH1HMACFailed,            //!< Hash HMAC check of DHPart1 failed!
        SevereDH2HMACFailed,            //!< Hash HMAC check of DHPart2 failed!
        SevereCannotSend,               //!< Cannot send data - connection or peer down?
        SevereProtocolError,            //!< Internal protocol error occurred!
        SevereNoTimer,                  //!< Cannot start a timer - internal resources exhausted?
        SevereTooMuchRetries,           //!< Too much retries during ZRTP negotiation - connection or peer down?
        SevereSecurityException         //!< Java throwed a security exception
    }

#end
#end
#No. 189852
#File: E:\bishe\1\ZrtpCodes.java
#Comment:
    /**
      * Error codes according to the ZRTP specification chapter 6.9
      *
      * GNU ZRTP uses these error codes in two ways: to fill the appropriate
      * field ing the ZRTP Error packet and as sub-code in 
      * ZrtpUserCallback#showMessage(). GNU ZRTP uses these error codes also
      * to report received Error packtes, in this case the sub-codes are their
      * negative values.
      *
      * The enumeration member comments are copied from the ZRTP specification.
      */

#Code:
    enum ZrtpErrorCodes {
        MalformedPacket(0x10),          //!< Malformed packet (CRC OK, but wrong structure)
        CriticalSWError(0x20),          //!< Critical software error
        UnsuppZRTPVersion(0x30),        //!< Unsupported ZRTP version
        HelloCompMismatch(0x40),        //!< Hello components mismatch
        UnsuppHashType(0x51),           //!< Hash type not supported
        UnsuppCiphertype(0x52),         //!< Cipher type not supported
        UnsuppPKExchange(0x53),         //!< Public key exchange not supported
        UnsuppSRTPAuthTag(0x54),        //!< SRTP auth. tag not supported
        UnsuppSASScheme(0x55),          //!< SAS scheme not supported
        NoSharedSecret(0x56),           //!< No shared secret available, DH mode required
        DHErrorWrongPV(0x61),           //!< DH Error: bad pvi or pvr ( == 1, 0, or p-1)
        DHErrorWrongHVI(0x62),          //!< DH Error: hvi != hashed data
        SASuntrustedMiTM(0x63),         //!< Received relayed SAS from untrusted MiTM
        ConfirmHMACWrong(0x70),         //!< Auth. Error: Bad Confirm pkt HMAC
        NonceReused(0x80),              //!< Nonce reuse
        EqualZIDHello(0x90),            //!< Equal ZIDs in Hello
        GoClearNotAllowed(0x100),       //!< GoClear packet received, but not allowed
        IgnorePacket(0x7fffffff);
        
        public int value;
        ZrtpErrorCodes(int val) {
            value = val;
        }

    }

#end
#end
#No. 189853
#File: E:\bishe\1\ZrtpCodes.java
#Comment:
    /**
     * Information codes for the Enrollment user callbacks.
     */

#Code:
    enum InfoEnrollment {
        EnrollmentRequest,              //!< Aks user to confirm or deny an enrollment request
        EnrollmentCanceled,             //!< User did not confirm the PBX enrollment
        EnrollmentFailed,               //!< Enrollment process failed, no PBX secret available
        EnrollmentOk                    //!< Enrollment process for this PBX was ok
    }

#end
#end
#No. 189854
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Convenience function that sets the mandatory algorithms only.
     *
     * Mandatory algorithms are:
     * <ul>
     * <li> Hash: SHA256 </li>
     * <li> Symmetric Cipher: AES 128 </li>
     * <li> Public Key Algorithm: DH3027, Mult </li>
     * <li> SAS type: base 32 </li>
     * <li> SRTP Authentication lengths: 32, 80 </li>
     *</ul>
     */

#Code:
    @SuppressWarnings("unused")
    public void setMandatoryOnly() {
        clear();
        hashes.addAlgo(ZrtpConstants.SupportedHashes.S256);

        symCiphers.addAlgo(ZrtpConstants.SupportedSymCiphers.AES1);

        publicKeyAlgos.addAlgo(ZrtpConstants.SupportedPubKeys.DH3K);
        publicKeyAlgos.addAlgo(ZrtpConstants.SupportedPubKeys.MULT);

        sasTypes.addAlgo(ZrtpConstants.SupportedSASTypes.B32);

        authLengths.addAlgo(ZrtpConstants.SupportedAuthLengths.HS32);
        authLengths.addAlgo(ZrtpConstants.SupportedAuthLengths.HS80);
    }

#end
#end
#No. 189855
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Clears all configuration data.
     * 
     * This function clears all configuration data. If an application hands
     * over an empty set of configuration data ZRTP does not set any
     * algorithm identifiers in the Hello message. In this case the receiver
     * has to select algorithms from the mandatory set of algorithms.
     */

#Code:
    @SuppressWarnings("unused")
    public void clear() {
        hashes.clear();
        symCiphers.clear();
        publicKeyAlgos.clear();
        sasTypes.clear();
        authLengths.clear();        
    }

#end
#end
#No. 189856
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Enables or disables trusted MitM processing.
     *
     * For further details of trusted MitM processing refer to ZRTP
     * specification, chapter 7.3
     * 
     * @param yesNo
     *    If set to true then trusted MitM processing is enabled.
     */

#Code:
    @SuppressWarnings("unused")
    public void setTrustedMitM(boolean yesNo) {
        enableTrustedMitM = yesNo;
    }

#end
#end
#No. 189857
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Check status of trusted MitM processing.
     * 
     * @return
     *    Returns true if trusted MitM processing is enabled.
     */

#Code:
    @SuppressWarnings("unused")
    public boolean isTrustedMitM() {
        return enableTrustedMitM;
    }

#end
#end
#No. 189858
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Enables or disables SAS signature processing.
     * 
     * For further details of trusted MitM processing refer to ZRTP
     * specification, chapter 7.2
     *
     * @param yesNo
     *    If set to true then certificate processing is enabled.
     */

#Code:
    @SuppressWarnings("unused")
    public void setSasSignature(boolean yesNo) {
        enableSasSignature = yesNo;
    }

#end
#end
#No. 189859
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Check status of SAS signature processing.
     * 
     * @return
     *    Returns true if certificate processing is enabled.
     */

#Code:
    @SuppressWarnings("unused")
    public boolean isSasSignature() {
        return enableSasSignature;
    }

#end
#end
#No. 189860
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Enables or disables paranoid mode.
     *
     * For further explanation of paranoid mode refer to the documentation
     * of ZRtp class.
     * 
     * @param yesNo
     *    If set to true then paranoid mode is enabled.
     */

#Code:
    @SuppressWarnings("unused")
    public void setParanoidMode(boolean yesNo) {
        enableParanoidMode = yesNo;
    }

#end
#end
#No. 189861
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Check status of paranoid mode.
     * 
     * @return
     *    Returns true if paranoid mode is enabled.
     */

#Code:
    @SuppressWarnings("unused")
    public boolean isParanoidMode() {
        return enableParanoidMode;
    }



#end
#end
#No. 189863
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Add a hash algorithm to configuration data at defined position.
     * 
     * Adds the specified hash algorithm to the configuration data. 
     * 
     * @param algo
     *            The identifier of the hash algorithm to add.
     * @param index
     *            The index into the configuration data
     * @return Number of free hash configuration data slots.
     */

#Code:
    @SuppressWarnings("unused")
    public int addHashAlgoAt(int index, ZrtpConstants.SupportedHashes algo) {
        return hashes.addAlgoAt(index, algo);
    }

#end
#end
#No. 189864
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Remove a hash algorithm from configuration data.
     * 
     * Removes the specified algorithm from hash configuration data. If the
     * algorithm was not configured previously the function does not modify the
     * configuration data and return the number of free configuration data
     * slots.
     * 
     * If an application removes all algorithms then ZRTP does not include any
     * algorithm into the hello message and falls back to a predefined mandatory
     * algorithm. In this case SHA256.
     * 
     * @param algo
     *            The identifier of the hash algorithm to remove.
     * @return Number of free hash configuration slots.
     */

#Code:
    @SuppressWarnings("unused")
    public int removeHashAlgo(ZrtpConstants.SupportedHashes algo) {
        return hashes.removeAlgo(algo);
    }

#end
#end
#No. 189865
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the number of configured hash algorithms.
     * 
     * @return The number of configured hash algorithms (used configuration data
     *         slots)
     */

#Code:
    @SuppressWarnings("unused")
    public int getNumConfiguredHashes() {
        return hashes.getNumConfiguredAlgos();
    }

#end
#end
#No. 189866
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the identifier of the hash algorithm at the given index.
     * 
     * If the index does not point to a configured slot then the function
     * returns the value <code>EndSupportedHashes</code>.
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpConstants.SupportedHashes getHashAlgoAt(int index) {
        try {
            return hashes.getAlgoAt(index);
        } catch (IndexOutOfBoundsException e) {
            return null;
        }
    }

#end
#end
#No. 189867
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns Iterable for the hashes.
     * 
     * Use this in for-each loop such as
     * <code>for (ZrtpConstants.SupportedHashes sh: config.hashes()) {</code>
     * 
     * @return The hash Iterable.
     */

#Code:
    @SuppressWarnings("unused")
    public Iterable<ZrtpConstants.SupportedHashes> hashes() {
        return hashes;
    }

#end
#end
#No. 189868
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Check if ZrtpConfigure contains a hash algorithm.
     * 
     * @return True if ZrtpConfigure contains the algorithm.
     */

#Code:
    @SuppressWarnings("unused")
    public boolean containsHashAlgo(ZrtpConstants.SupportedHashes hash) {
            return hashes.containsAlgo(hash);
    }

#end
#end
#No. 189869
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /*
     * SymCipher configuration functions
     */

#Code:
    /**
     * Add a symmetric cipher algorithm to configuration data.
     * 
     * Adds the specified cipher algorithm to the configuration data. If no free
     * configuration data slot is available the function does not add the
     * algorithm and return zero.
     * 
     * @param algo
     *            The identifier of the cipher algorithm to add.
     * @return Number of free cipher configuration data slots.
     */
    @SuppressWarnings("unused")
    public int addSymCipherAlgo(ZrtpConstants.SupportedSymCiphers algo) {
        return symCiphers.addAlgo(algo);
    }

#end
#end
#No. 189870
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Add a symmetric cipher algorithm to configuration data.
     * 
     * Adds the specified cipher algorithm to the configuration data. 
     * 
     * @param algo
     *            The identifier of the cipher algorithm to add.
     * @param index
     *            The index into the configuration data
     * @return Number of free cipher configuration data slots.
     */

#Code:
    @SuppressWarnings("unused")
    public int addSymCipherAlgoAt(int index, ZrtpConstants.SupportedSymCiphers algo) {
        return symCiphers.addAlgoAt(index, algo);
    }

#end
#end
#No. 189871
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Remove a symmetric cipher algorithm from configuration data.
     * 
     * Removes the specified algorithm from cipher configuration data. If the
     * algorithm was not configured previously the function does not modify the
     * configuration data and return the number of free configuration data
     * slots.
     * 
     * If an application removes all algorithms then ZRTP does not include any
     * algorithm into the hello message and falls back to a predefined mandatory
     * algorithm. In this case AES 128.
     * 
     * @param algo
     *            The identifier of the cipher algorithm to remove.
     * @return Number of free cipher configuration slots.
     */

#Code:
    @SuppressWarnings("unused")
    public int removeSymCipherAlgo(ZrtpConstants.SupportedSymCiphers algo) {
        return symCiphers.removeAlgo(algo);
    }

#end
#end
#No. 189872
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the number of configured symmetric cipher algorithms.
     * 
     * @return The number of configured cipher algorithms (used configuration
     *         data slots)
     */

#Code:
    @SuppressWarnings("unused")
    public int getNumConfiguredSymCiphers() {
        return symCiphers.getNumConfiguredAlgos();
    }

#end
#end
#No. 189873
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the identifier of the symmetric cipher algorithm at the given
     * index.
     * 
     * If the index does not point to a configured slot then the function
     * returns the value <code>EndSupportedSymCiphers</code>.
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpConstants.SupportedSymCiphers getSymCipherAlgoAt(int index) {
        try {
            return symCiphers.getAlgoAt(index);
        } catch (IndexOutOfBoundsException e) {
            return null;
        }
    }

#end
#end
#No. 189874
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns Iterable for the symmetric ciphers.
     * 
     * Use this in for-each loop such as
     * <code>for (ZrtpConstants.SupportedHashes sh: config.symCiphers()) {</code>
     * 
     * @return The symCiphers Iterable.
     */

#Code:
    @SuppressWarnings("unused")
    public Iterable<ZrtpConstants.SupportedSymCiphers> symCiphers() {
        return symCiphers;
    }

#end
#end
#No. 189875
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Check if ZrtpConfigure contains a cipher algorithm.
     * 
     * @return True if ZrtpConfigure contains the algorithm.
     */

#Code:
    @SuppressWarnings("unused")
    public boolean containsCipherAlgo(ZrtpConstants.SupportedSymCiphers cipher) {
            return symCiphers.containsAlgo(cipher);
    }

#end
#end
#No. 189877
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Add a public key algorithm to configuration data.
     * 
     * Adds the specified public key algorithm to the configuration data. 
     * 
     * @param algo
     *            The identifier of the public key algorithm to add.
     * @param index
     *            The index into the configuration data
     * @return Number of free public key configuration data slots.
     */

#Code:
    @SuppressWarnings("unused")
    public int addPubKeyAlgoAt(int index, ZrtpConstants.SupportedPubKeys algo) {
        return publicKeyAlgos.addAlgoAt(index, algo);
    }

#end
#end
#No. 189878
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Remove a public key algorithm from configuration data.
     * 
     * Removes the specified algorithm from public key configuration data. If
     * the algorithm was not configured previously the function does not modify
     * the configuration data and return the number of free configuration data
     * slots.
     * 
     * @param algo
     *            The identifier of the public key algorithm to remove.
     * @return Number of free public key configuration slots.
     */

#Code:
    @SuppressWarnings("unused")
    public int removePubKeyAlgo(ZrtpConstants.SupportedPubKeys algo) {
        return publicKeyAlgos.removeAlgo(algo);
    }

#end
#end
#No. 189879
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the number of configured public key algorithms.
     * 
     * @return The number of configured public key algorithms (used
     *         configuration data slots)
     */

#Code:
    @SuppressWarnings("unused")
    public int getNumConfiguredPubKeys() {
        return publicKeyAlgos.getNumConfiguredAlgos();
    }

#end
#end
#No. 189880
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the identifier of the public key algorithm at the given index.
     * 
     * If the index does not point to a configured slot then the function
     * returns the value <code>EndSupportedPubKeys</code>.
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpConstants.SupportedPubKeys getPubKeyAlgoAt(int index) {
        try {
            return publicKeyAlgos.getAlgoAt(index);
        } catch (IndexOutOfBoundsException e) {
            return null;
        }
    }

#end
#end
#No. 189881
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns Iterable for public key algorithms.
     * 
     * Use this in for-each loop such as
     * <code>for (ZrtpConstants.SupportedHashes sh: config.publicKeyAlgos()) {</code>
     * 
     * @return The publicKeyAlgos Iterable.
     */

#Code:
    @SuppressWarnings("unused")
    public Iterable<ZrtpConstants.SupportedPubKeys> publicKeyAlgos() {
        return publicKeyAlgos;
    }

#end
#end
#No. 189882
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Check if ZrtpConfigure contains a Public key algorithm.
     * 
     * @return True if ZrtpConfigure contains the algorithm.
     */

#Code:
    @SuppressWarnings("unused")
    public boolean containsPubKeyAlgo(ZrtpConstants.SupportedPubKeys pubkey) {
            return publicKeyAlgos.containsAlgo(pubkey);
    }



#end
#end
#No. 189884
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Add a SAS type algorithm to configuration data.
     * 
     * Adds the specified SAS type algorithm to the configuration data. 
     * 
     * @param algo
     *            The identifier of the SAS type algorithm to add.
     * @param index
     *            The index into the configuration data
      * @return Number of free SAS type configuration data slots.
     */

#Code:
    @SuppressWarnings("unused")
    public int addSasTypeAlgoAt(int index, ZrtpConstants.SupportedSASTypes algo) {
        return sasTypes.addAlgoAt(index, algo);
    }

#end
#end
#No. 189885
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Remove a SAS type algorithm from configuration data.
     * 
     * Removes the specified algorithm from SAS type configuration data. If the
     * algorithm was not configured previously the function does not modify the
     * configuration data and return the number of free configuration data
     * slots.
     * 
     * If an application removes all algorithms then ZRTP does not include any
     * algorithm into the hello message and falls back to a predefined mandatory
     * algorithm. In this case base 32.
     * 
     * @param algo
     *            The identifier of the SAS type algorithm to remove.
     * @return Number of free SAS type configuration slots.
     */

#Code:
    @SuppressWarnings("unused")
    public int removeSasTypeAlgo(ZrtpConstants.SupportedSASTypes algo) {
        return sasTypes.removeAlgo(algo);
    }

#end
#end
#No. 189886
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the number of configured SAS type algorithms.
     * 
     * @return The number of configured SAS type algorithms (used configuration
     *         data slots)
     */

#Code:
    @SuppressWarnings("unused")
    public int getNumConfiguredSasTypes() {
        return sasTypes.getNumConfiguredAlgos();
    }

#end
#end
#No. 189887
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the identifier of the SAS type algorithm at the given index.
     * 
     * If the index does not point to a configured slot then the function
     * returns the value <code>EndSupportedSASTypes</code>.
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpConstants.SupportedSASTypes getSasTypeAlgoAt(int index) {
        try {
            return sasTypes.getAlgoAt(index);
        } catch (IndexOutOfBoundsException e) {
            return null;
        }
    }

#end
#end
#No. 189888
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns Iterable for SAS algorithms.
     * 
     * Use this in for-each loop such as
     * <code>for (ZrtpConstants.SupportedHashes sh: config.sasTypes()) {</code>
     * 
     * @return The sasTypes Iterable.
     */

#Code:
    @SuppressWarnings("unused")
    public Iterable<ZrtpConstants.SupportedSASTypes> sasTypes() {
        return sasTypes;
    }

#end
#end
#No. 189889
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Check if ZrtpConfigure contains a SAS algorithm.
     * 
     * @return True if ZrtpConfigure contains the algorithm.
     */

#Code:
    @SuppressWarnings("unused")
    public boolean containsSasTypeAlgo(ZrtpConstants.SupportedSASTypes sas) {
            return sasTypes.containsAlgo(sas);
    }


#end
#end
#No. 189891
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Add a SRTP authentication length to configuration data.
     * 
     * Adds the specified SRTP authentication length to the configuration data.
     * If no free configuration data slot is available the function does not add
     * the algorithm and return zero.
     * 
     * @param algo
     *            The identifier of the SRTP authentication length to add.
     * @param index
     *            The index into the configuration data
     * @return Number of free SRTP authentication length configuration data
     *         slots.
     */

#Code:
    @SuppressWarnings("unused")
    public int addAuthLengthAt(int index, ZrtpConstants.SupportedAuthLengths algo) {
        return authLengths.addAlgoAt(index, algo);
    }

#end
#end
#No. 189892
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Remove a SRTP authentication length from configuration data.
     * 
     * Removes the specified algorithm from SRTP authentication length
     * configuration data. If the algorithm was not configured previously the
     * function does not modify the configuration data and returns the number of
     * free configuration data slots.
     * 
     * If an application removes all algorithms then ZRTP does not include any
     * algorithm into the hello message and falls back to a predefined mandatory
     * algorithm. In this case length 32.
     * 
     * @param algo
     *            The identifier of the SRTP authentication length to remove.
     * @return Number of free SRTP authentication length configuration slots.
     */

#Code:
    @SuppressWarnings("unused")
    public int removeAuthLength(ZrtpConstants.SupportedAuthLengths algo) {
        return authLengths.removeAlgo(algo);
    }

#end
#end
#No. 189893
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the number of configured SRTP authentication lengths.
     * 
     * @return The number of configured SRTP authentication lengths (used
     *         configuration data slots)
     */

#Code:
    @SuppressWarnings("unused")
    public int getNumConfiguredAuthLengths() {
        return authLengths.getNumConfiguredAlgos();
    }

#end
#end
#No. 189894
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the identifier of the SRTP authentication length at the given
     * index.
     * 
     * If the index does not point to a configured slot then the function
     * returns the value <code>EndSupportedAuthLength</code>.
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpConstants.SupportedAuthLengths getAuthLengthAt(int index) {
        try {
            return authLengths.getAlgoAt(index);
        } catch (IndexOutOfBoundsException e) {
            return null;
        }
    }

#end
#end
#No. 189895
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns Iterable for SRTP authentication lengths.
     * 
     * Use this in for-each loop such as
     * <code>for (ZrtpConstants.SupportedHashes sh: config.authLengths()) {</code>
     * 
     * @return The authLengths Iterable.
     */

#Code:
    @SuppressWarnings("unused")
    public Iterable<ZrtpConstants.SupportedAuthLengths> authLengths() {
        return authLengths;
    }

#end
#end
#No. 189896
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Check if ZrtpConfigure contains a Auth lengths.
     * 
     * @return True if ZrtpConfigure contains the algorithm.
     */

#Code:
    @SuppressWarnings("unused")
    public boolean containsAuthLength(ZrtpConstants.SupportedAuthLengths length) {
            return authLengths.containsAlgo(length);
    }


#end
#end
#No. 189898
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Add an algorithm to configuration data.
     * 
     * Adds an length to the configuration data. The function determines which
     * table to access based on the declaring class of the parameter.
     * 
     * If no free configuration data slot is available the function does not add
     * the algorithm and return zero.
     * 
     * @param algo
     *            The identifier of the algorithm to add.
     * @param index
     *            The index into the configuration data
     * @return Number of free algorithm configuration data
     *         slots.
     */

#Code:
    public <T extends Enum<T>>int addAlgoAt(int index, T algo) {
        Class<T> clazz = algo.getDeclaringClass();
        if (clazz.equals(ZrtpConstants.SupportedHashes.class)) {
            return hashes.addAlgoAt(index, ZrtpConstants.SupportedHashes.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedSymCiphers.class)) {
            return symCiphers.addAlgoAt(index, ZrtpConstants.SupportedSymCiphers.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedPubKeys.class)) {
            return publicKeyAlgos.addAlgoAt(index, ZrtpConstants.SupportedPubKeys.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedSASTypes.class)) {
            return sasTypes.addAlgoAt(index, ZrtpConstants.SupportedSASTypes.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedAuthLengths.class)) {
            return authLengths.addAlgoAt(index, ZrtpConstants.SupportedAuthLengths.class.cast(algo));
        }
        return -1;
    }

#end
#end
#No. 189899
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Remove an algorithm from configuration data.
     * 
     * Removes an length to the configuration data. The function determines which
     * table to access based on the declaring class of the parameter.
     * 
     * If the algorithm was not configured previously the
     * function does not modify the configuration data and returns the number of
     * free configuration data slots.
     * 
     * If an application removes all algorithms then ZRTP does not include any
     * algorithm into the hello message and falls back to a predefined mandatory
     * algorithm. In this case length 32.
     * 
     * @param algo
     *            The identifier of the algorithm to remove.
     * @return Number of free algorithm configuration slots.
     */

#Code:
    public <T extends Enum<T>>int removeAlgo(T algo) {
        Class<T> clazz = algo.getDeclaringClass();
        if (clazz.equals(ZrtpConstants.SupportedHashes.class)) {
            return hashes.removeAlgo(ZrtpConstants.SupportedHashes.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedSymCiphers.class)) {
            return symCiphers.removeAlgo(ZrtpConstants.SupportedSymCiphers.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedPubKeys.class)) {
            return publicKeyAlgos.removeAlgo(ZrtpConstants.SupportedPubKeys.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedSASTypes.class)) {
            return sasTypes.removeAlgo(ZrtpConstants.SupportedSASTypes.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedAuthLengths.class)) {
            return authLengths.removeAlgo(ZrtpConstants.SupportedAuthLengths.class.cast(algo));
        }
        return -1;
    }

#end
#end
#No. 189900
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns the number of configured algorithms.
     * 
     * The function determines which table to access based on the declaring class
     * of the parameter.
     * 
     * @param algo
     *            The identifier of the algorithm. Used only to identify 
     *            configure data.
     */

#Code:
    public <T extends Enum<T>> int getNumConfiguredAlgos(T algo) {
        Class<T> clazz = algo.getDeclaringClass();
        if (clazz.equals(ZrtpConstants.SupportedHashes.class)) {
            return hashes.getNumConfiguredAlgos();
        }
        if (clazz.equals(ZrtpConstants.SupportedSymCiphers.class)) {
            return symCiphers.getNumConfiguredAlgos();
        }
        if (clazz.equals(ZrtpConstants.SupportedPubKeys.class)) {
            return publicKeyAlgos.getNumConfiguredAlgos();
        }
        if (clazz.equals(ZrtpConstants.SupportedSASTypes.class)) {
            return sasTypes.getNumConfiguredAlgos();
        }
        if (clazz.equals(ZrtpConstants.SupportedAuthLengths.class)) {
            return authLengths.getNumConfiguredAlgos();
        }
        return -1;
    }

#end
#end
#No. 189901
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Returns Iterable for SRTP authentication lengths.
     * 
     * Use this in for-each loop such as
     * <code>for (ZrtpConstants.SupportedHashes sh: config.authLengths()) {</code>
     * 
     * @param algo
     *            The identifier of the algorithm to get.
     * @return The authLengths Iterable.
     */

#Code:
    @SuppressWarnings("unchecked")
    public <T extends Enum<T>>Iterable<T> algos(T algo) {
        Class<T> clazz = algo.getDeclaringClass();
        if (clazz.equals(ZrtpConstants.SupportedHashes.class)) {
            // return (Iterable<T>)hashes;
        	return (Iterable)hashes;
        }
        if (clazz.equals(ZrtpConstants.SupportedSymCiphers.class)) {
            return (Iterable)symCiphers;
        }
        if (clazz.equals(ZrtpConstants.SupportedPubKeys.class)) {
            return (Iterable)publicKeyAlgos;
        }
        if (clazz.equals(ZrtpConstants.SupportedSASTypes.class)) {
            return (Iterable)sasTypes;
        }
        if (clazz.equals(ZrtpConstants.SupportedAuthLengths.class)) {
            return (Iterable)authLengths;
        }
        return null;
    }

#end
#end
#No. 189902
#File: E:\bishe\1\ZrtpConfigure.java
#Comment:
    /**
     * Check if ZrtpConfigure contains an algorithm.
     * 
     * @return True if ZrtpConfigure contains the algorithm.
     */

#Code:
    @SuppressWarnings("unused")
    public <T extends Enum<T>>boolean containsAuthLength(T algo) {
        Class<T> clazz = algo.getDeclaringClass();
        if (clazz.equals(ZrtpConstants.SupportedHashes.class)) {
            return hashes.containsAlgo(ZrtpConstants.SupportedHashes.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedSymCiphers.class)) {
            return symCiphers.containsAlgo(ZrtpConstants.SupportedSymCiphers.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedPubKeys.class)) {
            return publicKeyAlgos.containsAlgo(ZrtpConstants.SupportedPubKeys.class.cast(algo));
        }
        if (clazz.equals(ZrtpConstants.SupportedSASTypes.class)) {
            return sasTypes.containsAlgo(ZrtpConstants.SupportedSASTypes.class.cast(algo));
        }
        return clazz.equals(ZrtpConstants.SupportedAuthLengths.class) &&
                authLengths.containsAlgo(ZrtpConstants.SupportedAuthLengths.class.cast(algo));
    }

#end
#end
#No. 189904
#File: E:\bishe\1\ZrtpConfigureTableModel.java
#Comment:
    /**
     * Move a Configuration entry up or down one position.
     * 
     * The "move up" is Converted to a "move down" with modified row index
     * and flags.
     * 
     * @param row
     *        Which row to move
     * @param up
     *        If true move up, else move down
     * @param upSave
     *        Because the functions converts a move up into a move down
     *        this flag shows what the caller intented. Needed to adjust
     *        an index return value.
     * @return
     */

#Code:
    public int move(int row, boolean up, boolean upSave) {
        if (up) {
            if (row <= 0)
                throw new IllegalArgumentException("rowIndex");

            return move(row - 1, false, upSave) - 1;
        }
        T swap;
        if (row >= (getRowCount() - 1))
            throw new IllegalArgumentException("rowIndex");

        // Can't move down last last entry of active list.
//        if (row == active.getNumConfiguredPubKeys() - 1) {
//            // this was a "move up" of the first inActive member adjust index
//            return upSave ? row + 2 : row;
//        }

//        if (row >= active.getNumConfiguredPubKeys()) {
//            if (inActive.getNumConfiguredPubKeys() <= 1) {
//                return row + 2;
//            }
//            row -= active.getNumConfiguredPubKeys();
//            swap = inActive.getPubKeyAlgoAt(row);
//            inActive.removePubKeyAlgo(swap);
//            inActive.addPubKeyAlgoAt(row + 1, swap);
//            row++;                           // take active rows into account
//        }
//        else {
            if (active.getNumConfiguredAlgos(algorithm) <= 1) {
                return row;
            }
            swap = active.getAlgoAt(row, algorithm);
            active.removeAlgo(swap);
            active.addAlgoAt(row + 1, swap);
//        }

        fireTableRowsUpdated(0, getRowCount());
        return row + 1;
    }

#end
#end
#No. 189905
#File: E:\bishe\1\ZrtpConfigureTableModel.java
#Comment:
    /**
     * Saves the ZrtpConfigure data for this algorithm to configure file
     */

#Code:
    public void saveConfig() {
        StringBuffer algoStr = new StringBuffer();
        for (T sh: active.algos(algorithm)) {
            algoStr.append(sh.name());
            algoStr.append(';');
        }
        // save in configuration data using the appropriate key
    }

#end
#end
#No. 189906
#File: E:\bishe\1\ZrtpConfigureTableModel.java
#Comment:
    /**
     * Sets the ZrtpConfigure data for this algorithm to a predefined set.
     * 
     * The caller prepared active ZrtpConfigureto contain a standard set of
     * algorithms. Get the names and construct a string, then call initialize
     * to setup the inActive ZrtpConfigure data.
     */

#Code:
    public void setStandardConfig() {
        StringBuffer algoStr = new StringBuffer();
        for (T sh: active.algos(algorithm)) {
            algoStr.append(sh.name());
            algoStr.append(';');
        }
        initialize(algoStr.toString());
        fireTableRowsUpdated(0, getRowCount());
    }




#end
#end
#No. 189911
#File: E:\bishe\1\ZrtpPacketConf2Ack.java
#Comment:
    /**
     * Constructor for ErrorAck message initialized with received data.
     * 
     * @param data received from the network.
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpPacketConf2Ack(final byte[] data) {
        super(data);
    }



#end
#end
#No. 189917
#File: E:\bishe\1\ZrtpPacketDHPart.java
#Comment:
    /**
     * Constructor for a new DHPart message with DH part type.
     * 
     * @param pkt type of DH key agreement to use
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpPacketDHPart(final ZrtpConstants.SupportedPubKeys pkt) {
        super(null);
        setPubKeyType(pkt);
    }

#end
#end
#No. 189918
#File: E:\bishe\1\ZrtpPacketDHPart.java
#Comment:
    /**
     * Constructor for DHPart message initialized with received data.
     * 
     * @param data received from the network.
     */

#Code:
    public ZrtpPacketDHPart(final byte[] data) {
        super(data);

        short len = getLength();
        if (len == 85) {
            dhLength = 256;
        }
        else if (len == 117) {
            dhLength = 384;
        }
        else if (len == 37) {
            dhLength = 64;
        }
        else if (len == 45) {
            dhLength = 96;
        }
        else if (len == 29) {    // E255
            dhLength = 32;
        }
        else {
            dhLength = 0;
        }
    }




#end
#end
#No. 189922
#File: E:\bishe\1\ZrtpPacketError.java
#Comment:
    /**
     * Constructor for Error message initialized with received data.
     * 
     * @param data received from the network.
     */

#Code:
    public ZrtpPacketError(final byte[] data) {
        super(data);
    }

#end
#end
#No. 189923
#File: E:\bishe\1\ZrtpPacketError.java
#Comment:
    /**
     * Get the error code from the Error packet.
     * 
     * Refer to the ZRTP specification about the error code semantics.
     * 
     * @return the error code.
     */

#Code:
    public final int getErrorCode() { 
        return ZrtpUtils.readInt(packetBuffer, CODE_OFFSET); 
    }

#end
#end
#No. 189924
#File: E:\bishe\1\ZrtpPacketError.java
#Comment:
    /**
     * Set the error code in the Error packet.
     * 
     * Refer to the ZRTP specification about the error code semantics.
     * 
     * @param code the error code.
     */

#Code:
    public final void setErrorCode(final int code) {
        ZrtpUtils.int32ToArrayInPlace(code, packetBuffer, CODE_OFFSET);
    }



#end
#end
#No. 189927
#File: E:\bishe\1\ZrtpPacketErrorAck.java
#Comment:
    /**
     * Constructor for ErrorAck message initialized with received data.
     * 
     * @param data received from the network.
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpPacketErrorAck(final byte[] data) {
        super(data);
    }




#end
#end
#No. 189930
#File: E:\bishe\1\ZrtpPacketHelloAck.java
#Comment:
    /**
     * Constructor for HelloAck message initialized with received data.
     * 
     * @param data received from the network.
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpPacketHelloAck(byte[] data) {
        super(data);
    }



#end
#end
#No. 189933
#File: E:\bishe\1\ZrtpPacketPing.java
#Comment:
    /**
     * Constructor for Ping message initialized with received data.
     * 
     * @param data received from the network.
     */

#Code:
    public ZrtpPacketPing(final byte[] data) {
        super(data);
    }

#end
#end
#No. 189934
#File: E:\bishe\1\ZrtpPacketPing.java
#Comment:
    /**
     * Get the endpoint hash from Ping packet.
     * 
     * @return the endpoint hash.
     */

#Code:
    public final byte[] getEpHash() { 
        return ZrtpUtils.readRegion(packetBuffer, EP_OFFSET, 2*ZRTP_WORD_SIZE);
    }

#end
#end
#No. 189935
#File: E:\bishe\1\ZrtpPacketPing.java
#Comment:
    /**
     * Set the endpoint hash.
     */

#Code:
    @SuppressWarnings("unused")
    public final void setEpHash(final byte[] data) {
        System.arraycopy(data, 0, packetBuffer, EP_OFFSET, 2*ZRTP_WORD_SIZE);
    }


#end
#end
#No. 189937
#File: E:\bishe\1\ZrtpPacketPingAck.java
#Comment:
    /**
     * Constructor for PingAck message initialized with received data.
     * 
     * @param data received from the network.
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpPacketPingAck(final byte[] data) {
        super(data);
    }

#end
#end
#No. 189938
#File: E:\bishe\1\ZrtpPacketPingAck.java
#Comment:
    /**
     * Get the remote endpoint hash from Ping packet.
     * 
     * @return the endpoint hash.
     */

#Code:
    @SuppressWarnings("unused")
    public final byte[] getRemoteEpHash() {
        return ZrtpUtils.readRegion(packetBuffer, REMOTE_EP_OFFSET, 2*ZRTP_WORD_SIZE);
    }

#end
#end
#No. 189939
#File: E:\bishe\1\ZrtpPacketPingAck.java
#Comment:
    /**
     * Set the remote endpoint hash.
     * 
     */

#Code:
    public final void setRemoteEpHash(final byte[] data) {
        System.arraycopy(data, 0, packetBuffer, REMOTE_EP_OFFSET, 2*ZRTP_WORD_SIZE);
    }

#end
#end
#No. 189940
#File: E:\bishe\1\ZrtpPacketPingAck.java
#Comment:
    /**
     * Get the local endpoint hash from Ping packet.
     * 
     * @return the endpoint hash.
     */

#Code:
    @SuppressWarnings("unused")
    public final byte[] getLocalEpHash() {
        return ZrtpUtils.readRegion(packetBuffer, LOCAL_EP_OFFSET, 2*ZRTP_WORD_SIZE);
    }

#end
#end
#No. 189941
#File: E:\bishe\1\ZrtpPacketPingAck.java
#Comment:
    /**
     * Set the local endpoint hash.
     * 
     */

#Code:
    public final void setLocalEpHash(final byte[] data) {
        System.arraycopy(data, 0, packetBuffer, LOCAL_EP_OFFSET, 2*ZRTP_WORD_SIZE);
    }

#end
#end
#No. 189942
#File: E:\bishe\1\ZrtpPacketPingAck.java
#Comment:
    /**
     * Set the peer's ssrc.
     * 
     */

#Code:
    public final void setPeerSSRC(final int data) {
        ZrtpUtils.int32ToArrayInPlace(data, packetBuffer, PEER_SSRC_OFFSET);
    }



#end
#end
#No. 189944
#File: E:\bishe\1\ZrtpPacketRelayAck.java
#Comment:
    /**
     * Constructor for ErrorAck message initialized with received data.
     * 
     * @param data received from the network.
     */

#Code:
    @SuppressWarnings("unused")
    public ZrtpPacketRelayAck(final byte[] data) {
        super(data);
    }





#end
#end
#No. 189949
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the keyInitiator
         */

#Code:
        public byte[] getKeyInitiator() {
            return keyInitiator;
        }

#end
#end
#No. 189950
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @param keyInitiator the keyInitiator to set
         */

#Code:
        public void setKeyInitiator(byte[] keyInitiator) {
            this.keyInitiator = keyInitiator;
        }

#end
#end
#No. 189951
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the keyResponder
         */

#Code:
        public byte[] getKeyResponder() {
            return keyResponder;
        }

#end
#end
#No. 189952
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @param keyResponder the keyResponder to set
         */

#Code:
        public void setKeyResponder(byte[] keyResponder) {
            this.keyResponder = keyResponder;
        }

#end
#end
#No. 189953
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the role
         */

#Code:
        public ZrtpCallback.Role getRole() {
            return role;
        }

#end
#end
#No. 189954
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @param role the role to set
         */

#Code:
        public void setRole(ZrtpCallback.Role role) {
            this.role = role;
        }

#end
#end
#No. 189955
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the saltInitiator
         */

#Code:
        public byte[] getSaltInitiator() {
            return saltInitiator;
        }

#end
#end
#No. 189956
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @param saltInitiator the saltInitiator to set
         */

#Code:
        public void setSaltInitiator(byte[] saltInitiator) {
            this.saltInitiator = saltInitiator;
        }

#end
#end
#No. 189957
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the saltResponder
         */

#Code:
        public byte[] getSaltResponder() {
            return saltResponder;
        }

#end
#end
#No. 189958
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @param saltResponder the saltResponder to set
         */

#Code:
        public void setSaltResponder(byte[] saltResponder) {
            this.saltResponder = saltResponder;
        }

#end
#end
#No. 189959
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the srtpAuthTagLen
         */

#Code:
        public int getSrtpAuthTagLen() {
            return srtpAuthTagLen;
        }

#end
#end
#No. 189960
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @param srtpAuthTagLen the srtpAuthTagLen to set
         */

#Code:
        public void setSrtpAuthTagLen(int srtpAuthTagLen) {
            this.srtpAuthTagLen = srtpAuthTagLen;
        }

#end
#end
#No. 189961
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the initKeyLen
         */

#Code:
        public int getInitKeyLen() {
            return initKeyLen;
        }

#end
#end
#No. 189962
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @param initKeyLen the initKeyLen to set
         */

#Code:
        public void setInitKeyLen(int initKeyLen) {
            this.initKeyLen = initKeyLen;
        }

#end
#end
#No. 189963
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the initSaltLen
         */

#Code:
        public int getInitSaltLen() {
            return initSaltLen;
        }

#end
#end
#No. 189964
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @param initSaltLen the initSaltLen to set
         */

#Code:
        public void setInitSaltLen(int initSaltLen) {
            this.initSaltLen = initSaltLen;
        }

#end
#end
#No. 189965
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the respKeyLen
         */

#Code:
        public int getRespKeyLen() {
            return respKeyLen;
        }

#end
#end
#No. 189966
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @param respKeyLen the respKeyLen to set
         */

#Code:
        public void setRespKeyLen(int respKeyLen) {
            this.respKeyLen = respKeyLen;
        }

#end
#end
#No. 189967
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the respSaltLen
         */

#Code:
        public int getRespSaltLen() {
            return respSaltLen;
        }

#end
#end
#No. 189968
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @param respSaltLen the respSaltLen to set
         */

#Code:
        public void setRespSaltLen(int respSaltLen) {
            this.respSaltLen = respSaltLen;
        }

#end
#end
#No. 189969
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the symEncAlgorithm
         */

#Code:
        public ZrtpConstants.SupportedSymAlgos getSymEncAlgorithm() {
            return symEncAlgorithm;
        }

#end
#end
#No. 189970
#File: E:\bishe\1\ZrtpSrtpSecrets.java
#Comment:
        /**
         * @return the authAlgorithm
         */

#Code:
        public ZrtpConstants.SupportedAuthAlgos getAuthAlgorithm() {
            return authAlgorithm;
        }


#end
#end
#No. 189973
#File: E:\bishe\1\ZSTR.java
#Comment:
/**
 * A null-terminated ASCII string.
 *
 * @author Andreas Fagschlunger
 */

#Code:
public class ZSTR
		extends CharArray
		implements ASCII {

	public ZSTR(final int length) {
		this(length, false);
	}

	public ZSTR(final int length, final boolean allocate) {
		super(length);
		if (length < 1) {
			throw new IllegalArgumentException("Illegal length: " + length + ", must be >= 1");
		}
		if (allocate) {
			allocate();
		}
	}

	public ZSTR(final String s) {
		this(s.length() + 1, true);
		put((s + NUL).getBytes(US_ASCII));
	}

	@Override
	public String toString() {
		String result = new String(getBytes(), US_ASCII);
		if (result.indexOf(NUL) != -1) {
			result = result.substring(0, result.indexOf(NUL));
		}
		return result;
	}
}


#end
#end
#No. 189975
#File: E:\bishe\1\ZStreamingQuoteControl.java
#Comment:
	/**
	 * getInstance - singleton instance provider
	 * @return ZStreamingQuoteControl singleton instance
	 */

#Code:
	public static ZStreamingQuoteControl getInstance() {
		if (zStreamingQuoteControl == null) {
			zStreamingQuoteControl = new ZStreamingQuoteControl();
		}

		return zStreamingQuoteControl;
	}

#end
#end
#No. 189976
#File: E:\bishe\1\ZStreamingQuoteControl.java
#Comment:
	/**
	 * start - public method to start Web Socket For Streaming Quote
	 * @param apiKey
	 * @param userId
	 * @param publicToken
	 */

#Code:
	public void start(String apiKey, String userId, String publicToken){
		if(ZStreamingConfig.isStreamingQuoteStartAtBootup()){
			//start Streaming Quote WebSocket - immediately
			System.out.println("ZStreamingQuoteControl.start(): Starting Streaming Quote WS");
			startStreamingQuote(apiKey, userId, publicToken);
		} else{
			//start Streaming Quote WebSocket - at market open
			Thread t = new Thread(new Runnable(){
				private boolean runnable = true;
				private DateFormat dtFmt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				private TimeZone timeZone = TimeZone.getTimeZone("IST");
				private String refTime = todaysDate + " " + QUOTE_STREAMING_TIME;
				
				@Override
				public void run() {
					dtFmt.setTimeZone(timeZone);
					try {
						Date timeRef = dtFmt.parse(refTime);
						while(runnable){
							Date timeNow = Calendar.getInstance(timeZone).getTime();
							if(timeNow.compareTo(timeRef) >= 0){
								System.out.println("ZStreamingQuoteControl.start().StreamingQuoteStartThread.run(): Starting Streaming Quote WS at: " + timeNow);
								runnable = false;
								startStreamingQuote(apiKey, userId, publicToken);
							}
							Thread.sleep(1000);
						}
					} catch (ParseException e1) {
						System.out.println("ZStreamingQuoteControl.start(): ParseException while parsing time: [" + refTime + "], cause: " + e1.getMessage());
					} catch (InterruptedException e) {
						System.out.println("ZStreamingQuoteControl.start(): InterruptedException for Thread sleep");
					}						
				}			
			});
			t.start();
		}
	}

#end
#end
#No. 189977
#File: E:\bishe\1\ZStreamingQuoteControl.java
#Comment:
	/**
	 * stop - public method to stop Web Socket For Streaming Quote
	 */

#Code:
	public void stop(){
		stopStreamingQuote();
	}

#end
#end
#No. 189978
#File: E:\bishe\1\ZStreamingQuoteControl.java
#Comment:
	/**
	 * getOHLCDataByTimeRange - public method to get OHLC Data between a time range
	 * @param instrumentToken
	 * @param fromTime
	 * @param toTime
	 * @return OHLCquote
	 */

#Code:
	public OHLCquote getOHLCDataByTimeRange(String instrumentToken, String fromTime, String toTime){
		if (ZStreamingConfig.isStreamingQuoteStoringRequired() && (streamingQuoteStorage != null)) {
			//Get OHLC Data
			return streamingQuoteStorage.getOHLCDataByTimeRange(instrumentToken, fromTime, toTime);
		} else{
			return null;
		}
	}

#end
#end
#No. 189979
#File: E:\bishe\1\ZStreamingQuoteControl.java
#Comment:
	/**
	 * getQuoteListByTimeRange - public method to get complete Streamed Data between a time range
	 * @param instrumentToken
	 * @param fromTime
	 * @param toTime
	 * @return StreamingQuote List
	 */

#Code:
	public List<StreamingQuote> getQuoteListByTimeRange(String instrumentToken, String fromTime, String toTime){
		if (ZStreamingConfig.isStreamingQuoteStoringRequired() && (streamingQuoteStorage != null)) {
			//Get Complete Streamed Data
			return streamingQuoteStorage.getQuoteListByTimeRange(instrumentToken, fromTime, toTime);
		} else{
			return null;
		}
	}

#end
#end
#No. 189980
#File: E:\bishe\1\ZStreamingQuoteControl.java
#Comment:
	/**
	 * updateTodaysDate - private method to update todays date
	 */

#Code:
	private void updateTodaysDate(){
		DateFormat dtFmt = new SimpleDateFormat("yyyy-MM-dd");
		dtFmt.setTimeZone(timeZone);
		todaysDate = dtFmt.format(Calendar.getInstance(timeZone).getTime());
	}

#end
#end
#No. 189981
#File: E:\bishe\1\ZStreamingQuoteControl.java
#Comment:
	/**
	 * startStreamingQuote - private method to start streaming Quote
	 * @param apiKey
	 * @param userId
	 * @param publicToken
	 */

#Code:
	private void startStreamingQuote(String apiKey, String userId, String publicToken){
		String URIstring = 
				STREAMING_QUOTE_WS_URL_TEMPLATE + "api_key="+ apiKey + "&user_id="+ userId + "&public_token=" + publicToken;
		
		DateFormat quoteTableDtFmt = new SimpleDateFormat("ddMMyyyy");
		quoteTableDtFmt.setTimeZone(timeZone);
		String date = quoteTableDtFmt.format(Calendar.getInstance(timeZone).getTime());
		
		if (ZStreamingConfig.isStreamingQuoteStoringRequired() && (streamingQuoteStorage != null)) {
			// Initialize streaming Quote Storage
			streamingQuoteStorage.initializeJDBCConn();
			streamingQuoteStorage.createDaysStreamingQuoteTable(date);
		}
		
		//Instrument Tokens List for subscribing
		List<String> instrumentList = getInstrumentTokensList();
		
		//Start Web Socket for streaming data
		websocketThread = new WebsocketThread(URIstring, instrumentList, streamingQuoteStorage);
		streamingQuoteStarted = websocketThread.startWS();
		if(streamingQuoteStarted){
			Thread t = new Thread(websocketThread);
			t.start();
		} else{
			System.out.println("ZStreamingQuoteControl.startStreamingQuote(): ERROR: WebSocket Streaming Quote not started !!!");
		}
	}

#end
#end
#No. 189982
#File: E:\bishe\1\ZStreamingQuoteControl.java
#Comment:
	/**
	 * stopStreamingQuote - private method to stop streaming Quote WS
	 */

#Code:
	private void stopStreamingQuote(){
		//stop web socket for streaming quote URL
		if(streamingQuoteStarted && websocketThread != null){
			websocketThread.stopWS();
			//Allow WS to get closed
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				System.out.println("ZStreamingQuoteControl.stopStreamingQuote(): ERROR: InterruptedException while sleeping");
			}
		}
		
		if(ZStreamingConfig.isStreamingQuoteStoringRequired() && (streamingQuoteStorage != null)){
			//Close streaming quote storage
			streamingQuoteStorage.closeJDBCConn();
		}
	}

#end
#end
#No. 189983
#File: E:\bishe\1\ZStreamingQuoteControl.java
#Comment:
	/**
	 * getInstrumentsList - private method to get Instruments List for streaming quotes
	 * @return Instruments List
	 */

#Code:
	private List<String> getInstrumentTokensList(){
		String[] instrumentsArr = ZStreamingConfig.getInstrumentTokenArr();
		List<String> instrumentList = Arrays.asList(instrumentsArr);
		System.out.println("ZStreamingQuoteControl.getInstrumentTokensList(): Subscribe Instrument Tokens: " + instrumentList);
		
		return instrumentList;
	}

#end
#end
#No. 189984
#File: E:\bishe\1\ZStreamRef.java
#Comment:
/**
 * A reference to the native zlib's z_stream structure.
 */

#Code:

class ZStreamRef {

    private long address;
    ZStreamRef (long address) {
        this.address = address;
    }

    long address() {
        return address;
    }

    void clear() {
        address = 0;
    }
}

#end
#end
#No. 189985
#File: E:\bishe\1\ZTauElement.java
#Comment:
/**
 * Class representing an element of <code><b>Z</b>[&tau;]</code>. Let
 * <code>&lambda;</code> be an element of <code><b>Z</b>[&tau;]</code>. Then
 * <code>&lambda;</code> is given as <code>&lambda; = u + v&tau;</code>. The
 * components <code>u</code> and <code>v</code> may be used directly, there
 * are no accessor methods.
 * Immutable class.
 */

#Code:
class ZTauElement
{
    /**
     * The &quot;real&quot; part of <code>&lambda;</code>.
     */
    public final BigInteger u;

    /**
     * The &quot;<code>&tau;</code>-adic&quot; part of <code>&lambda;</code>.
     */
    public final BigInteger v;

    /**
     * Constructor for an element <code>&lambda;</code> of
     * <code><b>Z</b>[&tau;]</code>.
     * @param u The &quot;real&quot; part of <code>&lambda;</code>.
     * @param v The &quot;<code>&tau;</code>-adic&quot; part of
     * <code>&lambda;</code>.
     */
    public ZTauElement(BigInteger u, BigInteger v)
    {
        this.u = u;
        this.v = v;
    }
}


#end
#end
#No. 190012
#File: E:\bishe\1\ZWindow.java
#Comment:
	/**
	 * Write a character to the framebuffer at the current cursor position.
	 * 
	 * @param ascii
	 *          the character
	 */

#Code:
	public void printzascii(short ascii) {
		printChar(ZScreen.zascii_to_unicode(ascii));
	}

#end
#end
#No. 190013
#File: E:\bishe\1\ZWindow.java
#Comment:
	/**
	 * Tell the buffer that it got fetched and can be overwritten on the next
	 * turn.
	 */

#Code:
	public void retrieved() {
		if (upper) {
			// NOTE: The lower window doesn't support formatted text. Some games
			// (e.g. curses and anchorhead) work around that limitation by
			// temporarily expanding the upperwindow, printing formatted text there,
			// then collapsing it again. Whatever is in the upperwindow is suppose
			// to stay, the "overflow" technically becomes part of the lower window
			// and hence needs to be cleared.
			if (maxCursor > endWindow) {
				Arrays.fill(frameBuffer, endWindow, maxCursor, ' ');
			}
			maxCursor = endWindow;
		}
		else {
			cursorx = 0;
			cursory = 0;
			cursor = 0;
		}
		regions=null;
	}

#end
#end
#No. 190014
#File: E:\bishe\1\ZWindow.java
#Comment:
	/**
	 * Transform a portion of the framebuffer into a string, add newline
	 * characters as required by the window width.
	 * 
	 * @param start
	 *          first character
	 * @param end
	 *          last character
	 * @return a formated string
	 */

#Code:
	public String stringyfy(int start, int end) {
		if (width<1 || start>=end) {
			return "";
		}
		int len = width;
		int total = end - start;
		char[] tmp = new char[total + total / len];
		int i = start;
		int o = 0;
		while (i < total - len) {
			System.arraycopy(frameBuffer, i, tmp, o, len);
			i += len;
			o += (len + 1);
			tmp[o - 1] = '\n';
		}
		// copy rest
		if (i < total) {
			System.arraycopy(frameBuffer, i, tmp, o, total - i);
		}

		return new String(tmp);
	}

#end
#end
#No. 190015
#File: E:\bishe\1\ZWindow.java
#Comment:
	/**
	 * Dirty hack! Calculate the length of the framebuffer excluding the last line
	 * containing the prompt.
	 * 
	 * @return length of the text in the buffer without the prompt.
	 */

#Code:
	public int noPrompt() {
		int ret = cursor - 1; // Put ret on the last character.
		if (ret < 0) {
			return cursor;
		}
		while (ret > 0 && frameBuffer[ret] == ' ') {
			ret--;
		}
		if (ret > 1 && frameBuffer[ret] == '>') {
			ret--;
		}
		else {
			// No idea what this is ... better safe than sorry.
			return cursor;
		}
		while (ret > 0 && frameBuffer[ret] == '\n') {
			// Remove all trailing newlines.
			ret--;
		}
		ret++; // Because we x-ed the last real character.
		return ret;
	}

#end
#end
#No. 190016
#File: E:\bishe\1\ZwitscherRepository.java
#Comment:
    /**
     * Fallback method called by Hystrix in case of error.
     *
     * @param q the query, not used actually
     * @return empty collection
     */

#Code:
    @SuppressWarnings("unused")
    protected Collection<String> none(final String q) {
        log.warn("Using fallback for Zwitscher messages.");
        return Collections.emptyList();
    }


#end
#end
#No. 190019
#File: E:\bishe\1\ZygosityType.java
#Comment:
/**
 * <p>Java class for ZygosityType.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p>
 * <pre>
 * &lt;simpleType name="ZygosityType">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;enumeration value="Homozygote"/>
 *     &lt;enumeration value="SingleHeterozygote"/>
 *     &lt;enumeration value="CompoundHeterozygote"/>
 *     &lt;enumeration value="Hemizygote"/>
 *     &lt;enumeration value="not provided"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 */

#Code:
@XmlType(name = "ZygosityType")
@XmlEnum
public enum ZygosityType {

    @XmlEnumValue("Homozygote")
    HOMOZYGOTE("Homozygote"),
    @XmlEnumValue("SingleHeterozygote")
    SINGLE_HETEROZYGOTE("SingleHeterozygote"),
    @XmlEnumValue("CompoundHeterozygote")
    COMPOUND_HETEROZYGOTE("CompoundHeterozygote"),
    @XmlEnumValue("Hemizygote")
    HEMIZYGOTE("Hemizygote"),
    @XmlEnumValue("not provided")
    NOT_PROVIDED("not provided");
    private final String value;

    ZygosityType(String v) {
        value = v;
    }

    public String value() {
        return value;
    }

    public static ZygosityType fromValue(String v) {
        for (ZygosityType c: ZygosityType.values()) {
            if (c.value.equals(v)) {
                return c;
            }
        }
        throw new IllegalArgumentException(v);
    }

}

#end
#end
#No. 190020
#File: E:\bishe\1\zzDetokenizeTaxonNames.java
#Comment:
   	/** Called to alter the taxon name in a single cell.  If you use the alterContentOfCells method of this class, 
   	then you must supply a real method for this, not just this stub. */

#Code:
   	public boolean alterName(Taxa taxa, int it){
   		boolean nameChanged = false;
		String name = taxa.getTaxonName(it);
		if (name!=null){
			taxa.setTaxonName(it, parser.getFirstToken(name), false);
			nameChanged = true;
		}
		return nameChanged;
   	}

#end
#end
#No. 190021
#File: E:\bishe\1\Z_TYPE.java
#Comment:
/**
 * Created by zyao89 on 2017/3/19.
 * Contact me at 305161066@qq.com or zyao89@gmail.com
 * For more projects: https://github.com/zyao89
 * My Blog: http://zyao89.me
 */

#Code:
public enum Z_TYPE
{
    CIRCLE(CircleBuilder.class),
    CIRCLE_CLOCK(ClockBuilder.class),
    STAR_LOADING(StarBuilder.class),
    LEAF_ROTATE(LeafBuilder.class),
    DOUBLE_CIRCLE(DoubleCircleBuilder.class),
    PAC_MAN(PacManBuilder.class),
    ELASTIC_BALL(ElasticBallBuilder.class),
    INFECTION_BALL(InfectionBallBuilder.class),
    INTERTWINE(IntertwineBuilder.class),
    TEXT(TextBuilder.class),
    SEARCH_PATH(SearchPathBuilder.class),
    ROTATE_CIRCLE(RotateCircleBuilder.class),
    ;

    private final Class<?> mBuilderClass;

    Z_TYPE(Class<?> builderClass)
    {
        this.mBuilderClass = builderClass;
    }

    <T extends ZLoadingBuilder>T newInstance(){
        try
        {
            return (T) mBuilderClass.newInstance();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return null;
    }
}


#end
#end
#No. 190037
#File: E:\bishe\1\_348.java
#Comment:
    /**
     * Initialize your data structure here.
     */

#Code:
    public _348(int n) {
        row = new int[n];
        col = new int[n];
        diag1 = new int[2 * n];
        diag2 = new int[2 * n];
        this.n = n;
    }

#end
#end
#No. 190038
#File: E:\bishe\1\_348.java
#Comment:
    /**
     * Player {player} makes a move at ({row}, {col}).
     *
     * @param r      The row of the board.
     * @param c      The column of the board.
     * @param player The player, can be either 1 or 2.
     * @return The current winning condition, can be either:
     * 0: No one wins.
     * 1: Player 1 wins.
     * 2: Player 2 wins.
     */

#Code:
    public int move(int r, int c, int player) {
        int value = player == 1 ? 1 : -1;
        row[r] += value;
        col[c] += value;
        diag1[r + c] += value;
        diag2[r - c + n] += value;

        if (row[r] == n || col[c] == n || diag1[r + c] == n || diag2[r - c + n] == n) return 1;
        else if (row[r] == -n || col[c] == -n || diag1[r + c] == -n || diag2[r - c + n] == -n) return 2;
        else return 0;
    }

#end
#end
#No. 190043
#File: E:\bishe\1\_AccountResource.java
#Comment:
    /**
     * GET  /activate -> activate the registered user.
     */

#Code:
    @RequestMapping(value = "/activate",
            method = RequestMethod.GET,
            produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed
    public ResponseEntity<String> activateAccount(@RequestParam(value = "key") String key) {<% if (javaVersion == '8') { %>
        return Optional.ofNullable(userService.activateRegistration(key))
            .map(user -> new ResponseEntity<String>(HttpStatus.OK))
            .orElse(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR));<% } else { %>
        User user = userService.activateRegistration(key);
        if (user == null) {
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
        return new ResponseEntity<String>(HttpStatus.OK);<% } %>

#end
#end
#No. 190044
#File: E:\bishe\1\_AccountResource.java
#Comment:
    /**
     * GET  /authenticate -> check if the user is authenticated, and return its login.
     */

#Code:
    @RequestMapping(value = "/authenticate",
            method = RequestMethod.GET,
            produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed
    public String isAuthenticated(HttpServletRequest request) {
        log.debug("REST request to check if the current user is authenticated");
        return request.getRemoteUser();
    }

#end
#end
#No. 190045
#File: E:\bishe\1\_AccountResource.java
#Comment:
    /**
     * GET  /account -> get the current user.
     */

#Code:
    @RequestMapping(value = "/account",
            method = RequestMethod.GET,
            produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed
    public ResponseEntity<UserDTO> getAccount() {<% if (javaVersion == '8') { %>
        return Optional.ofNullable(userService.getUserWithAuthorities())
            .map(user -> new ResponseEntity<>(
                new UserDTO(
                    user.getLogin(),
                    null,
                    user.getFirstName(),
                    user.getLastName(),
                    user.getEmail(),
                    user.getLangKey(),<% if (databaseType == 'sql' || databaseType == 'mongodb') { %>
                    user.getAuthorities().stream().map(Authority::getName).collect(Collectors.toCollection(LinkedList::new))),<% } %><% if (databaseType == 'cassandra') { %>
                    user.getAuthorities().stream().collect(Collectors.toCollection(LinkedList::new))),
<% } %>
                HttpStatus.OK))
            .orElse(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR));<% } else { %>
        User user = userService.getUserWithAuthorities();
        if (user == null) {
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
        List<String> roles = new ArrayList<>();
        for (Authority authority : user.getAuthorities()) {
            roles.add(authority.getName());
        }
        return new ResponseEntity<>(
            new UserDTO(
                user.getLogin(),
                null,
                user.getFirstName(),
                user.getLastName(),
                user.getEmail(),
                user.getLangKey(),
                roles),
            HttpStatus.OK);<% } %>
    }

#end
#end
#No. 190046
#File: E:\bishe\1\_AccountResource.java
#Comment:
    /**
     * POST  /account -> update the current user information.
     */

#Code:
    @RequestMapping(value = "/account",
            method = RequestMethod.POST,
            produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed
    public ResponseEntity<String> saveAccount(@RequestBody UserDTO userDTO) {<% if (javaVersion == '8') { %>
        return userRepository
            .findOneByLogin(userDTO.getLogin())
            .filter(u -> u.getLogin().equals(SecurityUtils.getCurrentLogin()))
            .map(u -> {
                userService.updateUserInformation(userDTO.getFirstName(), userDTO.getLastName(), userDTO.getEmail());
                return new ResponseEntity<String>(HttpStatus.OK);
            })

#end
#end
#No. 190047
#File: E:\bishe\1\_AccountResource.java
#Comment:
    /**
     * POST  /change_password -> changes the current user's password
     */

#Code:
    @RequestMapping(value = "/account/change_password",
            method = RequestMethod.POST,
            produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed
    public ResponseEntity<?> changePassword(@RequestBody String password) {
        if (StringUtils.isEmpty(password) || password.length() < 5 || password.length() > 50) {
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }

#end
#end
#No. 190048
#File: E:\bishe\1\_AccountResource.java
#Comment:
    /**
     * GET  /account/sessions -> get the current open sessions.
     */

#Code:
    @RequestMapping(value = "/account/sessions",
            method = RequestMethod.GET,
            produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed
    public ResponseEntity<List<PersistentToken>> getCurrentSessions() {<% if (javaVersion == '8') { %>
        return userRepository.findOneByLogin(SecurityUtils.getCurrentLogin())
            .map(user -> new ResponseEntity<>(
                persistentTokenRepository.findByUser(user),
                HttpStatus.OK))
            .orElse(new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR));<% } else { %>
        User user = userRepository.findOneByLogin(SecurityUtils.getCurrentLogin());
        if (user == null) {
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
        return new ResponseEntity<>(
            persistentTokenRepository.findByUser(user),
            HttpStatus.OK);<% } %>
    }

#end
#end
#No. 190049
#File: E:\bishe\1\_AccountResource.java
#Comment:
    /**
     * DELETE  /account/sessions?series={series} -> invalidate an existing session.
     *
     * - You can only delete your own sessions, not any other user's session
     * - If you delete one of your existing sessions, and that you are currently logged in on that session, you will
     *   still be able to use that session, until you quit your browser: it does not work in real time (there is
     *   no API for that), it only removes the "remember me" cookie
     * - This is also true if you invalidate your current session: you will still be able to use it until you close
     *   your browser or that the session times out. But automatic login (the "remember me" cookie) will not work
     *   anymore.
     *   There is an API to invalidate the current session, but there is no API to check which session uses which
     *   cookie.
     */

#Code:
    @RequestMapping(value = "/account/sessions/{series}",
            method = RequestMethod.DELETE)
    @Timed
    public void invalidateSession(@PathVariable String series) throws UnsupportedEncodingException {
        String decodedSeries = URLDecoder.decode(series, "UTF-8");<% if (javaVersion == '8') { %>
        userRepository.findOneByLogin(SecurityUtils.getCurrentLogin()).ifPresent(u -> {
            persistentTokenRepository.findByUser(u).stream()
                .filter(persistentToken -> StringUtils.equals(persistentToken.getSeries(), decodedSeries))
                .findAny().ifPresent(t -> persistentTokenRepository.delete(decodedSeries));
        });<% } else { %>
        User user = userRepository.findOneByLogin(SecurityUtils.getCurrentLogin());
        List<PersistentToken> persistentTokens = persistentTokenRepository.findByUser(user);
        for (PersistentToken persistentToken : persistentTokens) {
            if (StringUtils.equals(persistentToken.getSeries(), decodedSeries)) {
                persistentTokenRepository.delete(decodedSeries);
            }
        }<% } %>



#end
#end
#No. 190051
#File: E:\bishe\1\_Application.java
#Comment:
    /**
     * Main method, used to run the application.
     */

#Code:
    public static void main(String[] args) throws UnknownHostException {
        SpringApplication app = new SpringApplication(Application.class);
        app.setShowBanner(false);

        SimpleCommandLinePropertySource source = new SimpleCommandLinePropertySource(args);

        // Check if the selected profile has been set as argument.
        // if not the development profile will be added
        addDefaultProfile(app, source);<% if (databaseType == 'sql') { %>
        addLiquibaseScanPackages();<% } %>
        Environment env = app.run(args).getEnvironment();
        log.info("Access URLs:\n----------------------------------------------------------\n\t" +
            "Local: \t\thttp://127.0.0.1:{}\n\t" +
            "External: \thttp://{}:{}\n----------------------------------------------------------",
            env.getProperty("server.port"),
            InetAddress.getLocalHost().getHostAddress(),
            env.getProperty("server.port"));

    }

#end
#end
#No. 190052
#File: E:\bishe\1\_Application.java
#Comment:
    /**
     * Set a default profile if it has not been set
     */

#Code:
    private static void addDefaultProfile(SpringApplication app, SimpleCommandLinePropertySource source) {
        if (!source.containsProperty("spring.profiles.active")) {
            app.setAdditionalProfiles(Constants.SPRING_PROFILE_DEVELOPMENT);
        }
    }<% if (databaseType == 'sql') { %>

    /**
     * Set the liquibases.scan.packages to avoid an exception from ServiceLocator.
     */
    private static void addLiquibaseScanPackages() {
        System.setProperty("liquibase.scan.packages", Joiner.on(",").join(
            "liquibase.change", "liquibase.database", "liquibase.parser",
            "liquibase.precondition", "liquibase.datatype",
            "liquibase.serializer", "liquibase.sqlgenerator", "liquibase.executor",
            "liquibase.snapshot", "liquibase.logging", "liquibase.diff",
            "liquibase.structure", "liquibase.structurecompare", "liquibase.lockservice",
            "liquibase.ext", "liquibase.changelog"));
    }<% } %>

#end
#end
#No. 190053
#File: E:\bishe\1\_AuditEventConverter.java
#Comment:
    /**
     * Convert a list of PersistentAuditEvent to a list of AuditEvent
     * @param persistentAuditEvents the list to convert
     * @return the converted list.
     */

#Code:
    public List<AuditEvent> convertToAuditEvent(Iterable<PersistentAuditEvent> persistentAuditEvents) {
        if (persistentAuditEvents == null) {
            return Collections.emptyList();
        }

        List<AuditEvent> auditEvents = new ArrayList<>();

        for (PersistentAuditEvent persistentAuditEvent : persistentAuditEvents) {
            AuditEvent auditEvent = new AuditEvent(persistentAuditEvent.getAuditEventDate().toDate(), persistentAuditEvent.getPrincipal(),
                    persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData()));
            auditEvents.add(auditEvent);
        }

        return auditEvents;
    }



#end
#end
#No. 190055
#File: E:\bishe\1\_AuditEventConverter.java
#Comment:
    /**
     * Internal conversion. This method will allow to save additionnals data.
     * By default, it will save the object as string
     *
     * @param data the data to convert
     * @return a map of String, String
     */

#Code:
    public Map<String, String> convertDataToStrings(Map<String, Object> data) {
        Map<String, String> results = new HashMap<>();

        if (data != null) {
            for (String key : data.keySet()) {
                Object object = data.get(key);

                // Extract the data that will be saved.
                if (object instanceof WebAuthenticationDetails) {
                    WebAuthenticationDetails authenticationDetails = (WebAuthenticationDetails) object;
                    results.put("remoteAddress", authenticationDetails.getRemoteAddress());
                    results.put("sessionId", authenticationDetails.getSessionId());
                } else {
                    results.put(key, object.toString());
                }
            }
        }

        return results;
    }

#end
#end
#No. 190056
#File: E:\bishe\1\_BitIntSet.java
#Comment:
    /**
     * Tests the auto-expansion of the set
     */

#Code:
    public void test_expand() {
        BitIntSet set = new BitIntSet(32);
        int[] values = {0, 1, 31, 32, 128};

        for (int i = 0; i < values.length; i++) {
            set.add(values[i]);
        }

        IntIterator iter = set.iterator();

        for (int i = 0; i < values.length; i++) {
            assertTrue(iter.hasNext());
            assertEquals(values[i], iter.next());
        }
        assertFalse(iter.hasNext());
    }


#end
#end
#No. 190058
#File: E:\bishe\1\_CacheConfiguration.java
#Comment:
    /**
    * @return the unique instance.
    */

#Code:
    public static HazelcastInstance getHazelcastInstance() {
        return hazelcastInstance;
    }<% } %>
}
}

#end
#end
#No. 190059
#File: E:\bishe\1\_DetailedFormatter.java
#Comment:
	/**
	 * Format a log record with the format %isodatetime %loglevel [%threadid] %loggername: %message
	 *
	 * @param r a log record
	 * @return a formatted log record
	 */

#Code:
	@Override
	public String format(LogRecord r) {
		StringBuilder sb = new StringBuilder();
		sb.append(ISO_DATE_TIME_FORMATTER.print(r.getMillis())).append(" ");
		sb.append(r.getLevel().getName()).append(" ");
		sb.append("[").append(r.getThreadID()).append("] ");
		sb.append(r.getLoggerName()).append(": ");
		sb.append(formatMessage(r)).append(LINE_SEPARATOR);
		if (r.getThrown() != null) {
			sb.append("Stacktrace: ");
			sb.append(ExceptionUtils.getStackTrace(r.getThrown()));
		}
		return sb.toString();
	}



#end
#end
#No. 190063
#File: E:\bishe\1\_GZipResponseUtil.java
#Comment:
    /**
     * Checks whether a gzipped body is actually empty and should just be zero.
     * When the compressedBytes is {@link #EMPTY_GZIPPED_CONTENT_SIZE} it should be zero.
     *
     * @param compressedBytes the gzipped response body
     * @param request         the client HTTP request
     * @return true if the response should be 0, even if it is isn't.
     */

#Code:
    public static boolean shouldGzippedBodyBeZero(byte[] compressedBytes, HttpServletRequest request) {

        //Check for 0 length body
        if (compressedBytes.length == EMPTY_GZIPPED_CONTENT_SIZE) {
            if (LOG.isTraceEnabled()) {
                LOG.trace("{} resulted in an empty response.", request.getRequestURL());
            }
            return true;
        } else {
            return false;
        }
    }

#end
#end
#No. 190064
#File: E:\bishe\1\_GZipResponseUtil.java
#Comment:
    /**
     * Performs a number of checks to ensure response saneness according to the rules of RFC2616:
     * <ol>
     * <li>If the response code is {@link javax.servlet.http.HttpServletResponse#SC_NO_CONTENT} then it is illegal for the body
     * to contain anything. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.5
     * <li>If the response code is {@link javax.servlet.http.HttpServletResponse#SC_NOT_MODIFIED} then it is illegal for the body
     * to contain anything. See http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5
     * </ol>
     *
     * @param request        the client HTTP request
     * @param responseStatus the responseStatus
     * @return true if the response should be 0, even if it is isn't.
     */

#Code:
    public static boolean shouldBodyBeZero(HttpServletRequest request, int responseStatus) {

        //Check for NO_CONTENT
        if (responseStatus == HttpServletResponse.SC_NO_CONTENT) {
            if (LOG.isDebugEnabled()) {
                LOG.debug("{} resulted in a {} response. Removing message body in accordance with RFC2616.",
                        request.getRequestURL(), HttpServletResponse.SC_NO_CONTENT);
            }
            return true;
        }

        //Check for NOT_MODIFIED
        if (responseStatus == HttpServletResponse.SC_NOT_MODIFIED) {
            if (LOG.isDebugEnabled()) {
                LOG.debug("{} resulted in a {} response. Removing message body in accordance with RFC2616.",
                        request.getRequestURL(), HttpServletResponse.SC_NOT_MODIFIED);
            }
            return true;
        }
        return false;
    }

#end
#end
#No. 190065
#File: E:\bishe\1\_GZipResponseUtil.java
#Comment:
    /**
     * Adds the gzip HTTP header to the response.
     * <p/>
     * <p>
     * This is need when a gzipped body is returned so that browsers can properly decompress it.
     * </p>
     *
     * @param response the response which will have a header added to it. I.e this method changes its parameter
     * @throws GzipResponseHeadersNotModifiableException Either the response is committed or we were called using the include method
     *                                                   from a {@link javax.servlet.RequestDispatcher#include(javax.servlet.ServletRequest, javax.servlet.ServletResponse)}
     *                                                   method and the set header is ignored.
     */

#Code:
    public static void addGzipHeader(HttpServletResponse response) throws GzipResponseHeadersNotModifiableException {
        response.setHeader("Content-Encoding", "gzip");
        boolean containsEncoding = response.containsHeader("Content-Encoding");
        if (!containsEncoding) {
            throw new GzipResponseHeadersNotModifiableException("Failure when attempting to set "
                    + "Content-Encoding: gzip");
        }
    }

#end
#end
#No. 190066
#File: E:\bishe\1\_GZipServletFilter.java
#Comment:
    /**
     * Checks if the request uri is an include. These cannot be gzipped.
     */

#Code:
    private boolean isIncluded(final HttpServletRequest request) {
        String uri = (String) request.getAttribute("javax.servlet.include.request_uri");
        boolean includeRequest = !(uri == null);
        if (includeRequest && log.isDebugEnabled()) {
            log.debug("{} resulted in an include request. This is unusable, because"
                    + "the response will be assembled into the overrall response. Not gzipping.",
                    request.getRequestURL());
        }
        return includeRequest;
    }

#end
#end
#No. 190067
#File: E:\bishe\1\_GZipServletResponseWrapper.java
#Comment:
    /**
     * Flush OutputStream or PrintWriter
     *
     * @throws IOException
     */

#Code:
    @Override
    public void flushBuffer() throws IOException {

        //PrintWriter.flush() does not throw exception
        if (this.printWriter != null) {
            this.printWriter.flush();
        }

        if (this.gzipOutputStream != null) {
            this.gzipOutputStream.flush();
        }

        // doing this might leads to response already committed exception
        // when the PageInfo has not yet built but the buffer already flushed
        // Happens in Weblogic when a servlet forward to a JSP page and the forward
        // method trigger a flush before it forwarded to the JSP
        // disableFlushBuffer for that purpose is 'true' by default
        if (!disableFlushBuffer) {
            super.flushBuffer();
        }
    }

#end
#end
#No. 190068
#File: E:\bishe\1\_GZipServletResponseWrapper.java
#Comment:
    /**
     * Flushes all the streams for this response.
     */

#Code:
    public void flush() throws IOException {
        if (printWriter != null) {
            printWriter.flush();
        }

        if (gzipOutputStream != null) {
            gzipOutputStream.flush();
        }
    }

#end
#end
#No. 190069
#File: E:\bishe\1\_GZipServletResponseWrapper.java
#Comment:
    /**
     * Set if the wrapped reponse's buffer flushing should be disabled.
     *
     * @param disableFlushBuffer true if the wrapped reponse's buffer flushing should be disabled
     */

#Code:
    public void setDisableFlushBuffer(boolean disableFlushBuffer) {
        this.disableFlushBuffer = disableFlushBuffer;
    }

#end
#end
#No. 190070
#File: E:\bishe\1\_HazelcastCacheRegionFactory.java
#Comment:
    /**
     * @return true - for a large cluster, unnecessary puts will most likely slow things down.
     */

#Code:
    public boolean isMinimalPutsEnabledByDefault() {
        return true;
    }

#end
#end
#No. 190072
#File: E:\bishe\1\_Logger.java
#Comment:
    /**
     * Get a logger for the name.
     */

#Code:
    public static _Logger of(String name)
    {
        return _LoggerS.getLogger(name);
    }

#end
#end
#No. 190073
#File: E:\bishe\1\_Logger.java
#Comment:
    /**
     * Get a logger for the class name.
     */

#Code:
    public static _Logger of(Class clazz)
    {
        return _LoggerS.getLogger(clazz.getName());
    }

#end
#end
#No. 190074
#File: E:\bishe\1\_Logger.java
#Comment:
    /**
     * Set the logger provider.
     * <p>
     *     The provider returns a _Logger for a given name.
     *     For example
     * </p>
     * <pre>
     *     // enable DEBUG for all
     *     _Logger.setProvider( (name) -&gt;
     *         new _SimpleLogger(name, _Logger._Level.DEBUG, System.err)
     *     );
     * </pre>
     * <p>
     *     This method should be called in the very beginning of the application,
     *     before other classes are initialized.
     * </p>
     */

#Code:
    public static void setProvider(Function<String, _Logger> loggerProvider)
    {
        _LoggerS.loggerProvider = loggerProvider; // not volatile
    }

#end
#end
#No. 190075
#File: E:\bishe\1\_MainActivity.java
#Comment:
  /**
   * Inform the view about back events.
   */

#Code:
  @Override
  public void onBackPressed() {
    // Give the view a chance to handle going back. If it declines the honor, let super do its thing.
    if (!mainFlow.goBack()) {
      super.onBackPressed();
    }
  }

#end
#end
#No. 190076
#File: E:\bishe\1\_MainActivity.java
#Comment:
  /**
   * Inform the view about up events.
   */

#Code:
  @Override
  public boolean onOptionsItemSelected(MenuItem item) {
    MenuItemSelectionHandler action = menuItemSelectionHandlers.get(item.getItemId());
    if (action != null) {
      return action.execute();
    }

    return super.onOptionsItemSelected(item);
  }



#end
#end
#No. 190078
#File: E:\bishe\1\_MainActivity.java
#Comment:
  /**
   * Configure the app activity bar
   */

#Code:
  private void configureActionBar() {
    setSupportActionBar(actionBarToolbar);

    menuItemSelectionHandlers = map(
      android.R.id.home, new UpSelectionHandler(),
      R.id.action_environment, new SwitchEnvironmentSelectionHandler()
    );

    actionBarOwner.takeView(this);
  }

#end
#end
#No. 190079
#File: E:\bishe\1\_MainActivity.java
#Comment:
  /**
   * Inflate the view container layout and inject our view components
   */

#Code:
  private void inflateViewContainerLayout() {
    setContentView(R.layout.activity_main);
    ButterKnife.inject(this);
    mainFlow = mainView.getFlow();
  }

#end
#end
#No. 190080
#File: E:\bishe\1\_MainActivity.java
#Comment:
  /**
   * Initalise the root activity Mortar scope
   */

#Code:
  private void initActivityScope(Bundle savedInstanceState) {
    MortarScope parentScope = Mortar.getScope(getApplication());
    activityScope = Mortar.requireActivityScope(parentScope, new MainScreen());
    Mortar.inject(this, this);
    activityScope.onCreate(savedInstanceState);
  }

#end
#end
#No. 190081
#File: E:\bishe\1\_MetricService.java
#Comment:
    /**
     * Create a new {@link MetricService} instance.
     * @param publicMetrics the metrics to expose. The collection will be sorted using the
     * {@link AnnotationAwareOrderComparator}.
     */

#Code:
    public MetricService(Collection<PublicMetrics> publicMetrics) {
        Assert.notNull(publicMetrics, "PublicMetrics must not be null");
        this.publicMetrics = new ArrayList<>(publicMetrics);
        AnnotationAwareOrderComparator.sort(this.publicMetrics);
    }

#end
#end
#No. 190082
#File: E:\bishe\1\_Name.java
#Comment:
    /**
     * Replace disallowed name characters and whitespace with an underscore.
     *
     * @return string with replacements
     */

#Code:
    public Name replaceUnsafeNameChars() {
        return Name.of(value().trim()
                .replaceAll("\\s|[^\\w]", "_")
                .replaceAll("arn", "Arn"));
    }


#end
#end
#No. 190086
#File: E:\bishe\1\_SecurityConfiguration.java
#Comment:
    /**
     * This allows SpEL support in Spring Data JPA @Query definitions.
     *
     * See https://spring.io/blog/2014/07/15/spel-support-in-spring-data-jpa-query-definitions
     */

#Code:
    @Bean
    EvaluationContextExtension securityExtension() {
        return new EvaluationContextExtensionSupport() {
            @Override
            public String getExtensionId() {
                return "security";
            }

            @Override
            public SecurityExpressionRoot getRootObject() {
                return new SecurityExpressionRoot(SecurityContextHolder.getContext().getAuthentication()) {};
            }
        };
    }

#end
#end
#No. 190087
#File: E:\bishe\1\_WorkflowId.java
#Comment:
    /**
     * Make a unique and valid workflowId.
     * Replaces bad characters and whitespace, appends a random int, and trims to MAX_ID_LENGTH,
     * which also makes it easy for amazon cli use.
     *
     * @param workflow The workflow to generate the Id for
     *
     * @return unique workflowId
     */

#Code:
    public static WorkflowId randomUniqueWorkflowId(Workflow<?,?> workflow) {
        Name name = workflow.name().replaceUnsafeNameChars();
        String randomize = format(".%010d", ThreadLocalRandom.current().nextInt(0, Integer.MAX_VALUE));
        String nameAsString = trimToMaxLength(name.value(), MAX_ID_LENGTH - randomize.length());
        return WorkflowId.of(assertValidSwfValue(nameAsString + randomize));
    }



#end#end